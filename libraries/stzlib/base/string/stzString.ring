#--------------------------------------------------------------#
#              SOFTANZA LIBRARY (V0.9) - STZSTRING             #
#    An accelerative library for Ring applications, and more!  #
#--------------------------------------------------------------#
#                                                              #
#    Description  : The class for managing Unicode strings     #
#    Version      : V0.9 (2020-2025)                           #
#    Author       : Mansour Ayouni (kalidianow@gmail.com)      #
#                                                              #
#--------------------------------------------------------------#


/*
	#TODO Add:
	QStringRef methods

	TODO: use QStringView for read-only operations, and QByteArray
	for UT8-only string
	#--> Better performance.

	#TODO Consider using Allegro extension (via Ring GameEngine)
	# for unicode string manipulation ~> My tests prove it's more
	# performant the Qt and basic Ring native string management.

	#TODO //
	Get inspiration from the python ftfy library to add Unicode text
	cleansing in Softanza
	link: https://ftfy.readthedocs.io
*/

  /////////////////
 ///   CLASS   ///
/////////////////

class stzString from stzObject

	@oQString
	@cMarquer = DefaultMarquerChar()

	@aConstraints = []

	@cLanguage = :English	# Set explicitly using SetLanguage()
				#TODO (future)// Infere the language from the string

	These
	Those

	// Initializes the content of the softanza string object
	def init(pcStr)

		if CheckingParams()

			if NOT ( isString(pcStr) or @IsQString(pcStr) or
				 (isList(pcStr) and StzListQ(pcStr).IsPairOfStrings()) )

				StzRaise("Can't create the stzString object! pcStr must be a string, a QString object, or a pair of strings.")
			ok

			if IsQString(pcStr)
				QStringObject() = pcStr
				return

			but isList(pcStr) and StzListQ(pcStr).IsPairOfStrings() # Named string
				@cVarName = pcStr[1] # Inherited from stzObject
				@oQString = new QString2()
				@oQString.append(pcStr[2])
				return
			ok

		ok

		@oQString = new QString2()
		@oQString.append(pcStr)

		These = This
		Those = This

		# Adding the first entry in the object history

		StartObjectTime()
		TraceObjectHistory(This)

	  #==========================#
	 #   CHECKING CONSTRAINTS   #
	#==========================#
	#TODO // Generalize this feature to other classes

	def EnforcedConstraints()
		return @@aConstraints

		def Constraints()
			return This.EnforcedConstraints()

	def VerifyConstraint(pcConstraintName)

		@str = This.Content()

		cCondition = Constraints()[ :OnStzString ][ pcConstraintName ]

		if cCondition = ""
			stzRaise("Inexsitant contraint!")
		ok

		CompileConstraint(cCondition)

		StzStringQ(cCondition) {

			ReplaceCS("@string", @str,  0)
			Simplify()
			RemoveTheseBounds("{", "}")

			cCondition = Content()
		}

		cCode  = 'bResult = ""+ (' + cCondition + ')'
		eval(cCode)

		if bResult = 0
			stzRaise([
				:Where = "stzString.ring > VerifyCondition()",
				:What  = "Execution is cancelled by Softanza",
				:Why   = "A constraint on the string object is not verified!",
				:Todo  = "Check that constraint (" + pcName + ") and adjust your logic accordingly ;)"

			])
		ok

	def VerifyConstraints()
		bResult = 1

		for aPair in This.Constraints()
			cConstraintName = aPair[1]
			This.VerifyConstraint(cConstraintName) = 0
			
		next

	  #=======================================#
	 #     GETTING CONTENT OF THE STRING     #
	#=======================================#

	// Returns the string's content
	def Content()

		return QStringObject().left(QStringObject().size())

		#TODO // Replace with QStringObject().count() with size()
		# ~> count() returns number of unicode codepoints
		# ~> size() returns number of chars
		#UPDATE // Done using Ring 1.22 (thanks @Mahmoud)

		#< @FunctionFluentForm

		def ContentQ() # Same as Copy()
			return new stzString(This.Content())

		#>

		#< @FunctionAlternativeForm

		def Value()
			return This.Content()

			def ValueQ()
				return This.ContentQ()
	
		def String()
			return This.Content()

			def StringQ()
				return This # Returns the object not a new one!

		def TheString()
			return This.Content()

			def TheStringQ() # Returns the object not a new one!
				return This

		def AsWellR()
			return This.Content()

			def AsWell()
				return This.Content()

			def AsWellQ()
				return This

		def R()
			return This.Content()

		#>


	def QStringObject()
		return @oQString

		def ToQStringObject()
			return This.QStringObject()

		def ToQString()
			return This.QStringObject()

	  #=======================================#
	 #  GETTING A COPY OF THE STRING OBJECT  #
	#=======================================#

	def Copy()
		return new stzString( This.String() )

	def ReversedCopy()
		return This.Copy().ReverseQ()

	  #========================================#
	 #  CHECKING IF THE STRING IS PALINDROME  #
	#========================================#

	def IsPalindromeCS(pCaseSensitive)
		if This.NumberOfChars() < 2
			return 0
		ok

		cReversed = This.Reversed()
		if This.IsEqualtToCS( cReversed, pCaseSensitive) = 1
			return 1
		else
			return 0
		ok


		def IsPalindromCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

		def IsMirroredCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsPalindrome()
		return This.IsPalindromeCS(1)

		def IsPalindrom()
			return This.IsPalindrome()

		def IsMirrored()
			return This.ISPalindrome()

	  #==================================#
	 #  GETTING THE CASE OF THE STRING  #
	#==================================#

	def StringCase()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		if This.IsLowercase()
			return :Lowercase

		but This.IsUppercase()
			return :Uppercase

		but This.IsCapitalcase()
			return :Capitalcase

		but This.IsTitlecase()
			return :Titlecase

		but This.IsCaseFold()
			return :Casefold

		else
			return :Hybridcase
		ok

		#< @FunctionAlternativeForms

		def CharCase()
			return This.StringCase()

		def CharsCase()
			return This.StringCase()

		def Kase()
			return This.StringCase()

		def WordCase()
			return This.StringCase()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF THE STRING HAS THE SAME CASE AS AN OTHER GIVEN STRING  #
	#---------------------------------------------------------------------#

	def HasSameCaseAs(pcOtherStr)
		return This.CharCase() = StzStringQ(pcOtherStr).CharCase()

		def HasSameCharCaseAs(pcOtherStr)
			return This.HasSameCaseAs(pcOtherStr)

		#< @FunctionNegativeForm

		def HasDifferentCaseAs(pcOtherStr)
			return NOT This.HasSameCaseAs(pcOtherStr)

		def HasDifferentCharCase(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

		def HasNoSameCaseAs(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

			def HasNoSameCharCaseAs(pcOtherStr)
				return This.HasNoSameCaseAs(pcOtherStr)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING IS IN HYBRID CASE  #
	#--------------------------------------------#

	def IsHybridcase()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		bResult = Q( This.StringCase() ).IsNotOneOfThese([ StringCases() ])
		return bResult

		def IsHybridCased()
			return This.IsHybridcase()

	  #===========================================#
	 #   APPENDING THE STRING WITH A SUBSTRING   #
	#===========================================#

	def AppendWith(pcStr)

		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		_oQCopy_ = @oQString
		_oQCopy_.append(pcStr)
		
		_cResult_ = _oQCopy_.mid(0, _oQCopy_.size())
		This.UpdateWith(_cResult_)

		#< @FunctionFluentForm

		def AppendWithQ(pcStr)
			This.AppendWith(pcStr)
			return This
	
		#>

		#< @FunctionAlternative

		def Append(pcStr)
			if isList(pcStr) and StzListQ(pcStr).IsWithOrByNamedParam()
				pcStr = pcStr[2]
			ok

			This.AppendWith(pcStr)

			def AppendQ(pcStr)
				This.Append(pcStr)
				return This
	
		#>

	def AppendedWith(pcStr)
		cResult = This.Copy().AppendWithQ(pcStr).Content()
		return cResult

		def Appended(pcStr)
			cResult = This.Copy().AppendQ(pcStr).Content()
			return cResult

	  #-------------------------------------#
	 #   APPENDING THE STRING FROM START   #
	#-------------------------------------#

	def Prepend(pcOtherStr)
		if isList(pcOtherStr) and StzListQ(pcOtherStr).IsWithOrByNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		cResult = pcOtherStr + This.String()
		This.Update( cResult )

		#< @FunctionFluentForm

		def PrpendQ(pcOtherStr)
			This.Prepend(pcOtherStr)
			return This
	
		#>

	def Prepended(pcOtherStr)
		return This.Copy().PrependQ(pcOtherStr).Content()

	  #=================================#
	 #  ADDING A SUBSTRING --EXTENDED  #
	#=================================#

	def AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("Ring programin language")
		o1.AddXT("g", :To = "programmin")

		? o1.Content()
		#--> Ring programming language
		*/

		if isList(pcSubStr)
			oSubStr = new stzList(pcSubStr)

			# Adding after

			if oSubStr.IsOneOfTheseNamedParams([ :After, :AfterEach, :To, :ToEach  ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after nth

			but oSubStr.IsOneOfTheseNamedParams([ :AfterNth, :ToNth ])
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]
				This.ReplaceNthCS(n, pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after first

			but oSubStr.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				pcSubStr = pcSubStr[2]
				This.ReplaceFirstCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after last

			but oSubStr.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				pcSubStr = pcSubStr[2]
				This.ReplaceLastCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after these/many

			but oSubStr.IsOneOfTheseNamedParams([ :AfterThese, :ToThese, :AfterMany, :toMany ])
				pcSubStr = pcSubStr[2]
				if NOT isList(pcSubStr)
					StzRaise("Incorrect param type! pcSubStr must be a list.")
				ok

				acTemp = []
				nLen = len(pcSubStr)
				for i = 1 to nLen
					acTemp + (pcSubStr[i] + pcNewSubStr)
				next

				This.ReplaceManyByManyCS(pcSubStr, acTemp, pCaseSensitive)

			#==

			# Adding before

			but oSubStr.IsOneOfTheseNamedParams([ :Before, :BeforeEach ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before nth

			but oSubStr.IsBeforeNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)
		
			# Adding before first

			but oSubStr.IsBeforeFirstNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before last

			but oSubStr.IsBeforeLastNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			#==

			# Adding around

			but oSubStr.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsPairOfStrings()
					This.ReplaceCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)

				else	
					This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around nth

			but oSubStr.IsAroundNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsPairOfStrings()
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok
		
			# Adding around first

			but oSubStr.IsAroundFirstNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsPairOfStrings()
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around last

			but oSubStr.IsAroundLastNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsPairOfStrings()
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			ok

		ok

		def AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def AddedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def AddXT(pcNewSubStr, pcSubStr)
		This.AddCSXTQ(pcNewSubStr, pcSubStr, 1)

		def AddXTQ(pcNewSubStr, pcSubStr)
			This.AddXT(pcNewSubStr, pcSubStr)
			return This

	def AddedXT(pcNewSubStr, pcSubStr)
		return This.Copy().AddXTQ(pcNewSubStr, pcSubStr).Content()

	   #--------------------------------------------------------------------#
	  #   ADDING A SUBSTRING AFTER A POSITION, MANY POSITIONS, A SECTION,  #
	 #   MANY SECTIONS, OR AFTER THE OCCURRENCES OF AN OTHER SUBSTRING    #
	#--------------------------------------------------------------------#

	#TODO
	# Add these functions

	def AddAfter()
		StzRaise("Function not yet implemented!")

	def AddAfterPosition()
		StzRaise("Function not yet implemented!")

	def AddAfterPositions()
		StzRaise("Function not yet implemented!")

	def AddAfterSection()
		StzRaise("Function not yet implemented!")

	def AddAfterSections()
		StzRaise("Function not yet implemented!")

	def AddAfterSubString()
		StzRaise("Function not yet implemented!")

	def AddAfterSubStrings()
		StzRaise("Function not yet implemented!")

	def AddAfterNthOccurrenceOfSubString()
		StzRaise("Function not yet implemented!")

	def AddAfterTheseOccurrencesOfSubString()
		StzRaise("Function not yet implemented!")

	   #---------------------------------------------------------------------#
	  #   ADDING A SUBSTRING BEFORE A POSITION, MANY POSITIONS, A SECTION,  #
	 #   MANY SECTIONS, OR AFTER THE OCCURRENCES OF AN OTHER SUBSTRING     #
	#---------------------------------------------------------------------#

	#TODO
	# Add these functions

	def AddBefore()
		StzRaise("Function not yet implemented!")

	def AddBeforePosition()
		StzRaise("Function not yet implemented!")

	def AddBeforePositions()
		StzRaise("Function not yet implemented!")

	def AddBeforeSection()
		StzRaise("Function not yet implemented!")

	def AddBeforeSections()
		StzRaise("Function not yet implemented!")

	def AddBeforeSubString()
		StzRaise("Function not yet implemented!")

	def AddBeforeSubStrings()
		StzRaise("Function not yet implemented!")

	def AddBeforeNthOccurrenceOfSubString()
		StzRaise("Function not yet implemented!")

	def AddBeforeTheseOccurrencesOfSubString()
		StzRaise("Function not yet implemented!")

	   #--------------------------------------------------------------------#
	  #  ADDING A SUBSTRING AROUND A SECTION, MANY SECTIONS, A SUBSTRING,  #
	 #  OR MANY SUBSTRINGS (BOUNDING THEM WITH THE SUBSTRING)             #
	#--------------------------------------------------------------------#
	
	#TODO
	# Add these functions

	def AddAround()
		StzRaise("Function not yet implemented!")

	def AddAroundSection()
		StzRaise("Function not yet implemented!")

	def AddAroundSections()
		StzRaise("Function not yet implemented!")

	def AddAroundSubString()
		StzRaise("Function not yet implemented!")

	def AddAroundSubStrings()
		StzRaise("Function not yet implemented!")

	  #=================================================#
	 #  EXTENDING THE STRING WITH THE GIVEN SUBSTRING  #
	#=================================================#

	def ExtendWith(pSubStr)
		if CheckingParams()
			if isList(pSubStr)
				This.ExtendWithMany(pSubStr)
				return
			ok
	
			if NOT isString(pSubStr)
				StzRaise("Incorrect param type! pSubStr must be a string.")
			ok
		ok

		This.AppendWith(pSubStr)

		#< @FunctionFluentForm

		def ExtendWithQ(pSubStr)
			This.ExtendWith(pSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithSubString(pSubStr)
			This.ExtendWith(pSubStr)

			def ExtendWithSubStringQ(pSubStr)
				This.ExtendWithSubString(pSubStr)
				return This

		#>

	def ExtendedWith(pSubStr)
		aResult = This.Copy().ExtendWithQ(pSubStr).Content()
		return aResult

		def ExtendedWithSubString(pSubStr)
			return This.ExtendedWith(pSubStr)

	  #---------------------------------------------#
	 #  EXTENDING THE STRING WITH MANY SUBSTRINGS  #
	#---------------------------------------------#

	def ExtendWithMany(pacSubStr)
		if CheckingParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		This.AppendWith( QRT(pacSubStr, :stzListOfStrings).Concatenated() )

		#< @FunctionFluentForm

		def ExtendWithManyQ(pacSubStr)
			This.ExtendWithMany(pacSubStr)

		#>

		#< @FunctionAlternativeForms

		def ExtendWithTheseSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithThese(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		#>

	def ExtendedWithMany(pacSubStr)
		cResult = This.Copy().ExtendWithManyQ(pacSubStr).Content()
		return cResult

		def ExtendedWithTheseSubStrings(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

		def ExtendedWithThese(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

	  #-----------------------------------#
	 #  EXTENDING THE STRING TO N CHARS  #
	#-----------------------------------#

	def ExtendToPosition(n)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nLen = This.NumberOfItems()

		This.AppendWith( Q(" ").RepeatedNTimes( n - nLen ) )
		
		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if CheckingParams()
				if isList(n) and
				   ( Q(n).IsPositionNamedParam() or Q(n).IsToNCharsNamedParam() )
	
					n = n[2]
				ok
			ok

			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNChars(n)
			This.ExtendToPosition(n)
			
			def ExtendToNCharsQ(n)
				This.ExtendToNChars(n)
				return This

		def Extend(n)
			if CheckingParams()
				if isList(n) and StzListQ(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNChars ])
					n = n[2]
				ok
			ok

			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		cResult = This.Copy().ExtendToPositionQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNChars(n)
			return This.ExtendedToPosition(n)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToPositionWith(n, pcChar)

		if CheckingParams()
			if isString(pcChar) and pcChar = :CharsRepeated
				This.ExtendToPositionWithCharsRepeated(n)
				return
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if NOT ( isString(pcChar) and StzStringQ(pcChar).IsChar() )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		nLen = This.NumberOfChars()

		if n > nLen
			This.AppendWith( Q(pcChar).RepeatedNTimes(n - nLen) )
		ok

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToWithQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsWithQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#--

		def ExtendToPositionUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToPositionUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToUsing(n, pcChar)
			This.ExtendToPositionUsing(n, pcChar)

			def ExtendToUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#--

		def ExtendToPositionBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToPositionByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToBy(n, pcChar)
			This.ExtendToPositionBy(n, pcChar)

			def ExtendToByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#>


	def ExtendedToPositionWith(n, pcChar)
		cResult = This.Copy().ExtendToPositionWithQ(n, pcChar).Content()
		return This

		#< @FunctionAlternativeForms

		def ExtendedToWith(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToNCharsWith(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)
			
		#--

		def ExtendedToPositionUsing(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToUsing(n, pcChar)
			This.ExtendToPositionUsing(n, pcChar)

		def ExtendedToNCharsUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
		#--

		def ExtendedToPositionBy(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToBy(n, pcChar)
			This.ExtendToPositionBy(n, pcChar)

		def ExtendedToNCharsBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
		#>

		#< @FunctionMisspelledForm

		def ExtendtedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE STRING CHARS  #
	#--------------------------------------------------------------------------#

	def ExtendToPositionWithCharsRepeated(n)
		This.ExtendToPositionWithCharsIn(n, This.Chars())

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsRepeatedQ(n)
			This.ExtendToPositionWithCharsRepeated(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToWithCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		def ExtendToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToPositionByRepeadingCharsQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)


		def ExtendToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToByRepeatingCharsQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)


		#--

		def ExtendToByCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToByCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		def ExtendToUsingCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToUsingCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		#>

	def ExtendedToPositionWithCharsRepeated(n)
		cResult = This.Copy().ExtendToPositionWithCharsRepeatedQ(n).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToWithCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToPositionByRepeadingChars(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToByRepeatingChars(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		#--

		def ExtendedToByCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToUsingCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		#>

	  #-------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE GIVEN CHARS  #
	#-------------------------------------------------------------------------#

	def ExtendToPositionWithCharsIn(n, pacChars)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if NOT ( isList(pacChars) and StzListQ(pacChars).IsListOfChars() )
				StzRaise("Incorrect param type! pacChars must be a list or chars.")
			ok
		ok

		nLen = len(pacChars)
		nTemp = n - nLen

		cTemp = ""

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				cTemp += pacChars[j]
			next
		ok

		This.ExtendWith(cTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsInQ(n, pacChars)
			This.ExtendToPositionWithCharsIn(n, pacChars)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtendToWithCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToWithCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		def ExtendToByCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToByCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		def ExtendToUsingCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToUsingCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		#>

	def ExtendedToPositionWithCharsIn(n, pacChars)
		cResult = This.Copy().ExtendToPositionWithCharsInQ(n, pacChars).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedToWithCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		def ExtendedToByCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		def ExtendedToUsingCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToNCharsXT(n, pUsing)
		if isList(pUsing) and StzListQ(pUsing).IsUsingOrByOrWithNamedParam()
			pUsing = pUsing[2]
		ok

		This.ExtendToNCharsUsing(n, pUsing)

		#< @FunctionFluentFom

		def ExtendToNCharsXTQ(n, pUsing)
			This.ExtendToNCharsXT(n, pUsing)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToNPositionsXT(n, pUsing)
			This.ExtendToNCharsXT(n, pUsing)

		#>

	def ExtendedToNCharsXT(n, pUsing)
		cResult = This.ExtendToNCharsXTQ(n, pUsing).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToNPositionsXT(n, pUsing)
			This.ExtendedToNCharsXT(n, pUsing)

		#>

	  #-----------------------------------------#
	 #  EXTENDING THE STRING - A GENERAL FORM  #
	#-----------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :With = "DE")
		o1.Show()
		#--> "ABCDE"

		EXAMPLE 2

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :ToPosition = 5 )
		o1.Show()
		#--> "ABCDE  "

		EXAMPLE 3

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
		o1.Show()
		#--> "ABCDEAB"

		EXAMPLE 4

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> "ABCDE**"

		EXAMPLE 5

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :WithCharsIn = [ "D", "E" ])
		o1.Show()
		#--> "ABCDEDE"

		EXAMPL 6

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToNChars = 7, :Withc = "." )
		o1.Show()
		#--> "ABC...."

		*/

		oNParam = Q(n)
		oWithParam = Q(pWith)

		if isString(n) and n = :String

			if isList(pWith)
				oWith = new stzList(pWith)

				# Case 1: o1.ExtendXT( :String, :With = "DE")
				if oWith.IsWithOrByOrUsingNamedParam()
					This.ExtendWith(pWith[2])
					return

				# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
				but oWith.IsToOrToPositionNamedParam()
					This.ExtendToPosition(pWith[2])
					return

				ok
			ok

		# Case ExtendXT( :ToNChars, 5 )
		but isString(n) and n = :ToNChars and isNumber(pWith)
			This.ExtendToPosition(n)

		# Case ExtendXT( :ToNChars = 5, :Using = "." )
		but isList(n) and oNParam.IsToNCharsNamedParam()
			if isList(pWith) and oWithParam.IsUsingOrWithOrByNamedParam()
				pwith = pWith[2]
			ok

			if NOT isString(pWith)
				StzRaise("Incorrect param type! pWith must be a string.")
			ok

			This.ExtendToNCharsUsing(n[2], pWith)

		but isList(n) and oNParam.IsToOrToPositionNamedParam()

			if isList(pWith) and oNParam.IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeated(n[2])
					#NOTE // This is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    ring_find([
				:ByRepeatingChars, :WithCharsItemsRepeated,
				:ByCharsRepeated ], pWith ) > 0

				if isList(n) and oNParam.IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithCharsRepeated(n)
				return

			# Case 5: o1.ExtendXT( :ToPosition = 5, :WithCharsIn = "DE")
			but oWithParam.IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

		#< @FunctionFluentForm
	
		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		cResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return cResult

	  #--------------------------------------------#
	 #  SHRINKING THE STRING TO A GIVEN POSITION  #
	#============================================#

	def ShrinkTo(n)
		if CheckingParams()
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsNCharsNamedParam() )
	
				n = n[2]
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveSection( n+1, nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNCharsQ(n)
				This.ShrinkToNChars(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================#
	 #     LOWERCASING THE STRING    #
	#===============================#

	def ApplyLowercase() # Understand it as a verb, an action on main string!
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toLower(This.String()) )

		#< @FunctionFluentForm

	 	// Transforms the string to lowercase AND Returns the lowercased
		// stzString object to take other actions on it!
		def ApplyLowercaseQ() # Q for Queue -> a chain of actions
			This.ApplyLowercase()
			return This

		def ApplyLowercaseQC()
			_oCopy_ = This.Copy()
			_oCopy_.ApplyUppercase()
			return _oCopy_

		#>

		#< @FunctionAlternativeForm

		def Lowercase() # Understand it as a verb that "lowercases" the string
			This.ApplyLowercase()

			def LowercaseQ()
				This.Lowercase()
				return This

			def LowercaseQC()
				return This.ApplyLowercaseQC()
	
		#>

		#< @FunctionMisspelledForm

		def Lowcase()
			This.ApplyLowercase()

		def ApplyLowcase()
			This.ApplyLowercase()

		#>

	def Lowercased()
		cResult = This.Copy().LowercaseQ().Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedQ()
			return new stzString(This.Lowercased())

		#>

		#< @FunctionAlternativeForms
			
		def ToLowercase()
			return This.Lowercased()

			def ToLowercaseQ()
				if This.Lowercased()
					return This
				else
					return AFalseObject()
				ok
		#--

		def LowercaseB()
			return This.Lowercased()

			def LowercaseBQ()
				if This.Lowercased()
					return This
				else
					return AFalseObject()
				ok

		#>

	  #-------------------------------------------------#
	 #     LOWERCASING THE STRING IN A GIVEN LOCALE    #
	#-------------------------------------------------#

	// Tranforms the string to LOCALE-SENSITIVE lowercase
	def ApplyLowercaseInLocale(pcLocale)
		/*
		Apply the special cases documented in unicode here:
		--> http://unicode.org/Public/UNIDATA/SpecialCasing.txt

		*/

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToLowercase(This.String()) )

		#< @FunctionFluentForm

		def ApplyLowercaseInLocaleQ(pcLocale)
			This.ApplyLowercaseInLocale(pcLocale)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def LowercaseInLocale(pLocale) # Understand it as a verb that "lowercases" the string in the givan locale
			This.ApplyLowercaseInLocale(pLocale)

			def LowercaseInLocaleQ(pLocale)
				This.LowercaseInLocale(pLocale)
				return This
	
		#>

		#< @FunctionMisspelledForm

		def ApplyLowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)

		def LowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)
			
		#>

	def LowercasedInLocale(pcLocale)
		cResult = This.Copy().LowercaseInLocaleQ(pcLocale).Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedInLocaleQ(pLocale)
			return new stzString( This.LowercasedInLocale(pLocale) )

		#>

		#< @FunctionMisspelledForm

		def LowcasedInLocale(pcLocale)
			return This.LowercasedInLocale(pcLocale)

		#>

	  #----------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE  #
	#----------------------------------------#

	def IsLowercase()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		if This.Lowercased() = This.String()
			return 1
		else
			return 0
		ok


		#< @FunctionFluentForm

		def IsLowerercaseQ()
			if This.IsLowercase()
				return new stzString(This.Content())
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForm

		def IsLowercased()
			return This.IsLowercase()

			def IsLowercasedQ()
				return This.IsLowerercaseQ()

		def IsLower()
			return This.IsLowercase()

			def IsLowerQ()
				return This.IsLowerercaseQ()

		def IsInLowercase()
			return This.IsLowercase()

			def InLowercaseQ()
				return This.IsLowerercaseQ()

		def IsInALowercase()
			return This.IsLowercase()

			def IsInALowercasQ()
				return This.IsLowerercaseQ()

		def IsALowercase()
			return This.IsLowercase()

			def IsALowercaseQ()
				return This.IsLowerercaseQ()

		#>

		#< @FunctionNegativeForms

		def IsNotLowercase()
			return NOT This.IsLowercase()

		def IsNotLowercased()
			return This.IsNotLowercase()

		def IsNotLower()
			return This.IsNotLowercase()

		def IsNotInLowercase()
			return This.IsNotLowercase()

		def IsNotInALowercase()
			return This.IsNotLowercase()

		#>

		#< @FunctionMisspelledForms

		def IsLowcased()
			return This.IsLowercase()

		def IsLowcase()
			return This.IsLowercase()

		def IsLowarcase()
			return This.IsLowercase()

		#--

		def InLowarcase()
			return This.IsLowercase()

		def InLowercase()
			return This.IsLowercase()

		#>

	  #----------------------------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE IN A GIVEN LOCALE  #
	#----------------------------------------------------------#

	def IsLowercaseInLocale(pLocale)
		bResult = StzLocaleQ(pLocale).StringLowercased(This.String()) = This.String() #TODO // replace with DefaultLocale
		return bResult

		#< @FunctionAlternativeForms

		def IsLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

		#< @FunctionMisspelledForm

		def IsLowcaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

	  #-------------------------------------------------------------#
	 #  CHECHINK IF THE STRING IS THE LOWERCASE OF A GIVEN STRING  #
	#-------------------------------------------------------------#

	def IsLowercaseOf(pcStr)
		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		return ring_lower(pcStr) = This.String()

	def IsLowercaseOfXT(pcStr, paLocale)
		/* Example
		Q("many").IsLowercaseOfXT("MANY", :InThisLocale = "fr_FR")
		*/
	
		if NOT ( isList(paLocale) and len(paLocale) = 2 )
			stzRaise("Incorrect format!")
		ok
	
		if NOT isString(paLocale[1])
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( ring_find([ :InThisLocale, :InLocale ], paLocale[1]) > 0 )
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( isString(paLocale[2]) or (isList([paLocale[2]]) and len(paLocale[2]) = 2) )
			stzRaise("Incorrect format!")
		ok
	
		if isString(paLocale[2]) and NOT StzStringQ(paLocale[2]).IsLocaleAbbreviation()
			stzRaise("Incorrect format!")
		ok
	
		if isList(paLocale[2]) and NOT StzListQ(paLocale[2]).IsLocaleList()
			stzRaise("Incorrect format!")
		ok
	
		return Q(pcStr).LowercasedInLocale(paLocale[2]) = This.String()

	  #===============================#
	 #     UPPERCASING THE STRING    #
	#===============================#

	def ApplyUppercase()
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toUpper(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseQ()
			This.ApplyUppercase()
			return This

		def ApplyUppercaseQC()
			_oCopy_ = This.Copy()
			_oCopy_.ApplyLowercase()
			return _oCopy_

		#>

		#< @FunctionAlternativeForm

		def Uppercase() # Understand it as a verb that "uppercases" the string
			This.ApplyUppercase()

			def UppercaseQ()
				return This.ApplyUppercaseQ()

			def UppercaseQC()
				return This.ApplyUppercaseQC()

		def UppercaseIt()
			This.ApplyUppercase()

			def UppercaseItQ()
				return This.ApplyUppercaseQ()

			def UppercaseItQC()
				return This.ApplyUppercaseQC()

		#>

		#< @FunctionFutureForms

		def UppercaseF()
			@AddFuture(:Uppercase)

			def UppercaseFQ()
				@AddFuture(:Uppercase)
				return This

		def UppercaseFF()
			@ExecuteFutureXT(This, FutureOrder())

			def UppercaseFFQ()
				@ExecuteFutureXT(This, FutureOrder())
				return This
		#--

		def UppercasingF(pcStr)
			@AddFuture(:Uppercase)

			def UppercasingFQ(pcStr)
				@AddFuture(:Uppercase)
				return new stzString(pcStr)

		def UppercasingFF(pcStr)
			@ExecuteFutureXT(This, FutureOrder())

			def UppercasingFFQ(pcStr)
				@ExecuteFutureXT(This, FutureOrder())
				return new stzString(pcStr)

		#>

	def Uppercased()
		return This.Copy().UppercaseQ().Content()

		#< @FunctionFluentForm

		def UppercasedQ()
			return new stzString( This.Uppercased() )

		#>

		#< @FunctionAlternativeForms
			
		def ToUppercase()
			return This.Uppercased()

				def ToUppercaseQ()
					if This.Uppercased()
						return This
					else
						return AFalseObject()
					ok
		#--

		def UppercaseB()
			return This.Uppercased()

			def UpperBQ()
				if This.Uppercased()
					return This
				else
					return AFalseObject()
				ok

		#>

	// Tranforms the string to LOCALE-SENSITIVE UPPERCase
	def ApplyUppercaseInLocale(pcLocale)

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToUpperCase(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseInLocaleQ(pcLocale)
			This.ApplyUppercaseInLocale(pcLocale)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseInLocale(pLocale) # Understand it as a verb that "uppercases" the string in the givan locale
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInLocaleQ(pLocale)
				This.ApplyUppercaseInLocale(pLocale)
				return This
	
		def LocaleUppercase(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def LocaleUppercaseQ(pLocale)
				This.LocaleUppercase(pLocale)
				return This

		def UppercaseIn(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInQ(pLocale)
				This.UppercaseIn(pLocale)
				return This

		#>

	def UppercasedInLocale(pLocale)
		return This.Copy().UppercaseInLocaleQ(pLocale).Content()

		#< @FunctionAlternativeForms

		def LocaleUppercased(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercasedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		def toLocaleUppercase(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercadedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		#>

	def IsUppercase()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		if This.Uppercased() = This.String()
			return 1
		else
			return 0
		ok

		#< @FunctionFluentForm
		# Useful in Natural-Coding, like for example:
		# Q("RING").IsAStringQ().WichQ().IsUppercaseQ().AndQ().ContainingQ(TheLetter("I"))
		#--> TRUE

		def IsUpperercaseQ()
			if This.IsUppercase()
				return new stzString(This.Content())
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsUppercased()
			return This.IsUppercase()

			def IsUppercasedQ()
				return This.IsUpperercaseQ()

		def IsUpper()
			return This.IsUppercase()

			def IsUpperQ()
				return This.IsUpperercaseQ()

		def IsInUppercase()
			return This.IsUppercase()

			def IsInUppercaseQ()
				return This.IsUpperercaseQ()

		def InUppercase()
			return This.IsUppercase()

			def InUppercaseQ()
				return This.IsUpperercaseQ()

		def IsAnUppercase()
			return This.IsUppercase()

			def IsAnUppercaseQ()
				return This.IsUppercaseQ()

		#>

		#< @FunctionNegativeForms

		def IsNotUppercase()
			return NOT This.IsUppercase()

		def IsNotUppercased()
			return This.IsUppercase()

		def IsNotUpper()
			return This.IsUppercase()

		def IsNotInUppercase()
			return This.IsUppercase()

		def IsNotInAnUppercase()
			return This.IsUppercase()

		#>

		#< @FunctionFutureForms

		def IsUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsIsUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsUppercasedF()
			@AddFutureXT(:Uppercase, @FutureOrder())
		
			def IsUppercasedFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsUpperF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsUpperFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsInUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsInUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def InUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())
	
			def IsUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#>

	def IsUppercaseInLocale(pLocale)

		if This.UppercasedInLocale(pLocale) = This.String()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForm

		def IsUppercasedInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#--

		def IsUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUppercasedIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#>

	def IsUppercaseOf(pcStr)
		return Q(pcStr).UppercaseQ().IsEqualTo(This.Content())

	def IsUppercaseOfInLocale(pcStr, pLocale)
		return This.UppercasedInLocale(pLocale) = pcStr

	  #---------------------------------------#
	 #  UPPERCASING A SECTION IN THE STRING  #
	#=======================================#

	def UppercaseSection(n1, n2)
		cUpper = This.SectionQ(n1, n2).Uppercased()
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionQ(n1, n2)
			This.UppercaseSection(n1, n2)
			return This

	def SectionUppercased(n1, n2)
		cResult = This.Copy().UppercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInUppercase(n1, n2)
			return This.SectionUppercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def UppercaseSectionInLocale(n1, n2, pLocale)
		cUpper = This.SectionQ(n1, n2).UppercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionInLocaleQ(n1, n2, pLocale)
			This.UppercaseSection(n1, n2)
			return This

		def UppercaseSectionIn(n1, n2, pLocale)
			return This.UppercaseSectionInQ(n1, n2, pLocale)

			def UppercaseSectionInQ(n1, n2, pLocale)
				This.UppercaseSectionIn(n1, n2)
				return This

	def SectionUppercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().UppercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInUppercaseInLocale(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionUppercasedIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionInUppercaseIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  UPPERCASING MANY SECTIONS IN THE STRING  #TODO // Check for performance!
	#-------------------------------------------#

	def UppercaseSections(anSections)
		if CheckingParams()
			if NOT (isList(anSections) and StzListQ(anSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(anSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			cUpper = _oCopy_.SectionQ(anSections[i][1], anSections[i][2]).Uppercased()
			_oCopy_.ReplaceSection(anSections[i][1], anSections[i][2], cUpper)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def UppercaseSectionsQ(anSections)
			This.UppercaseSections(anSections)
			return This

		#>

	def SectionsUppercased(anSections)
		cResult = This.Copy().UppercaseSectionsQ(anSections).Content()
		return cResult

		def SectionsInUppercase(anSections)
			return This.SectionsUppercased()

	#-- WITH LOCALE SENSITIVITY

	def UppercaseSectionsInLocale(anSections, pLocale)
		if CheckingParams()
			if NOT (isList(anSections) and StzListQ(anSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(anSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			cUpper = _oCopy_.SectionQ(anSections[i][1], anSections[i][2]).UppercasedInLocale(pLocale)
			_oCopy_.UppercaseSection(anSections[i][1], anSections[i][2], cUpper)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentFrom

		def UppercaseSectionsInLocaleQ(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)
			return This
		#>

		#< @FunctioAlternativeForm

		def UppercaseSectionsIn(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)

			def UppercaseSectionsInQ(anSections, pLocale)
				This.UppercaseSectionsIn(anSections, pLocale)
				return This
		#>

	def SectionsUppercasedInLocale(anSections, pLocale)
		cResult = This.Copy().UppercaseSectionsInLocaleQ(anSections, pLocale).Content()
		return cResult

		def SectionsInUppercaseInLocale(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsUppercasedIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsInUppercaseIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

	  #---------------------------------------#
	 #  LOWERCASING A SECTION IN THE STRING  #
	#=======================================#

	def LowercaseSection(n1, n2)
		cLower = This.SectionQ(n1, n2).Lowercased()
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionQ(n1, n2)
			This.LowercaseSection(n1, n2)
			return This

	def SectionLowercased(n1, n2)
		cResult = This.Copy().LowercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInLowercase(n1, n2)
			return This.SectionLowercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def LowercaseSectionInLocale(n1, n2, pLocale)
		cLower = This.SectionQ(n1, n2).LowercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionInLocaleQ(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)
			return This

		def LowercaseSectionIn(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)

			def LowercaseSectionInQ(n1, n2, pLocale)
				This.LowercaseSectionIn(n1, n2, pLocale)
				return This

	def SectionLowercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().LowercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInLowercaseInLocale(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionLowercasedIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionInLowercaseIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  LOWERCASING MANY SECTIONS IN THE STRING  #TODO // Check for performance!
	#-------------------------------------------#

	def LowercaseSections(paSections)
		if CheckingParams()
			if NOT (isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			cLower = _oCopy_.SectionQ(paSections[i][1], paSections[i][2]).Lowercased()
			_oCopy_.ReplaceSection(paSections[i][1], paSections[i][2], cLower)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def LowercaseSectionsQ(paSections)
			This.LowercaseSections(paSections)
			return This

		#>

	def SectionsLowercased(paSections)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercase(paSections)
			return SectionsLowercased(paSections)

	#-- WITH LOCALE SENSITIVITY

	def LowercaseSectionsInLocale(paSections, pLocale)
		if CheckingParams()
			if NOT (isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		_oCopy_ = This.Content()

		for i = 1 to nLen
			cLower = _oCopy_.SectionQ(paSections[i][1], paSections[i][2]).LowercasedInLocale(pLocale)
			_oCopy_.LowercaseSection(paSections[i][1], paSections[i][2], cLower)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def LowercaseSectionsInLocaleQ(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)
			return This
		#>

		#< @FunctionAlternativeForm

		def LowercaseSectionsIn(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)

			def LowercaseSectionsInQ(paSections, pLocale)
				This.LowercaseSectionsIn(paSections, pLocale)
				return This
		#>

	def SectionsLowercasedInLocale(paSections, pLocale)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercaseInLocale(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsLowercasedIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsInLowercaseIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

	  #-----------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def UppercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSections(aSections)

		#< @FunctionFluentForm

		def UppercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.UppercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseCSXT(pcSubStr, pCaseSensitive)
			This.UppercaseSubStringCS(pcSubStr, pCaseSensitive)

			def UppercaseCSXTQ(pcSubStr, pCaseSensitive)
				return This.UppercaseSubStringCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringUppercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubString(pcSubStr)
		This.UppercaseSubStringCS(pcSubStr, 1)

		#< @FunctionFluetForm

		def UppercaseSubStringQ(pcSubStr)
			This.UppercaseSubStringCSQ(pcSubStr, 1)

		#>

		#< @FunctionAlternativeForms

		def UppercaseXT(pcSubStr)
			This.UppercaseSubString(pcSubStr)

			def UppercaseXTQ(pcSubStr)
				return This.UppercaseSubStringQ(pcSubStr)

		#>

	def SubStringUppercased(pcSubStr)
		cResult = This.Copy().UppercaseSubStringQ(pcStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

		def SubStringInUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSectionsInLocale(aSections, pLocale)

		#< @FunctionFluentForm

		def UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def UppercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

		def UppercaseInCSXT(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def UppercaseInCSXTQ(pcSubStr, pLocale, pCaseSensitive)
				return This.UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringUppercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubStringInLocale(pcSubStr, pLocale)
		This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, 1)

		#< @FunctionFluentForm

		def UppercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, 1)

		#>

		#< @FunctionAlternativeForms

		def UppercaseSubStringIn(pcSubStr, pLocale)
			This.UppercaseSubStringInLocale(pcSubStr, pLocale)

			def UppercaseSubStringInQ(pcSubStr, pLocale)
				This.UppercaseSubStringIn(pcSubStr, pLocale)
				return This

		def UppercaseInXT(pcSubStr, pLocale)
			This.UppercaseSubStringInLocale(pcSubStr, pLocale)

			def UppercaseInXTQ(pcSubStr, pLocale)
				return This.UppercaseSubStringInLocaleQ(pcSubStr, pLocale)

		#>

	#-- @FunctionPassiveForms

	def SubStringUppercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().UppercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringToUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		#>

	  #-----------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def LowercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSections(aSections)

		#< @FunctionAlternativeForms

		def LowercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.LowercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def LowercaseCSXT(pcSubStr, pCaseSensitive)
			This.LowercaseSubStringCS(pcSubStr, pCaseSensitive)

			def LowercaseCSXTQ(pcSubStr, pCaseSensitive)
				return This.LowercaseSubStringCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringLowercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubString(pcSubStr)
		This.LowercaseSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def LowercaseSubStringQ(pcSubStr)
			This.LowercaseSubStringCSQ(pcSubStr, 1)

		#>

		#< @FunctionAlternativeForm

		def LowercaseXT(pcSubStr)
			This.LowercaseSubString(pcSubStr)

			def LowercaseXTQ(pcSubStr)
				return This.LowercaseSubStringQ(pcSubStr)

		#>

	#-- @FunctionPassiveForm

	def SubStringLowercased(pcSubStr)
		cResult = This.Copy().LowercaseSubStringQ(pcStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

		def SubStringInLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSectionsInLocale(aSections, pLocale)

		#< @FunctionFluentForm

		def LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def LowercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

		def LowercaseInCSXT(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def LowercaseInCSXTQ(pcSubStr, pLocale, pCaseSensitive)
				return This.LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringLowercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubStringInLocale(pcSubStr, pLocale)
		This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, 1)

		#< @FunctonFluentForm

		def LowercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, 1)

		#>

		#< @FunctionAlternativeForms

		def LowercaseSubStringIn(pcSubStr, pLocale)
			This.LowercaseSubStringInLocale(pcSubStr, pLocale)

			def LowercaseSubStringInQ(pcSubStr, pLocale)
				This.LowercaseSubStringIn(pcSubStr, pLocale)
				return This

		def LowercaseInXT(pcSubStr, pLocale)
			This.LowercaseSubStringInLocale(pcSubStr, pLocale)

			def LowercaseInXTQ(pcSubStr, pLocale)
				return This.LowercaseSubStringInLocaleQ(pcSubStr, pLocale)
		#>

	#-- @FunctionPassiveForm

	def SubStringLowercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().LowercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringLowercasedIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		#>

	  #================================#
	 #     CAPITALIZING THE STRING    #
	#================================#

	def ApplyCapitalcase()
		if This.IsEmpty()
			return
		ok

		# Getting the positions of the words in the string
		#TODO // delegate the work to stzText when ready

		anPos = This.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]
		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)

		ok

		nLen = len(anPos)

		for i = 1 to nLen
			cCapChar = This.CharQ(anPos[i]).Uppercased()
			This.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		#< @FunctionFluentForm

		def ApplyCapitalcaseQ()
			This.ApplyCapitalcase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Capitalcase() # Understand it as a verb that "capitalcases" the string
			This.ApplyCapitalcase()

			def CapitalcaseQ()
				This.Capitalcase()
				return This

		def Capitalise()
			This.ApplyCapitalcase()

			def CapitaliseQ()
				This.Capitalise()
				return This

		def Capitalize()
			This.ApplyCapitalcase()

			def CapitalizeQ()
				This.Capitalize()
				return This

		#>	
	
	def CapitalCased()
		return This.Copy().ApplyCapitalCaseQ().Content()

		def CapitalCaseApplied()
			return This.CapitalCased()

		def Capitalised()
			return This.CapitalCased()

		def Capitalized()
			return This.CapitalCased()

		def ToCapitalCase()
			return This.CapitalCased()

		def InCapitalCase()
			return This.CapitalCased()

	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyCapitalCaseInLocale(pLocale)
		# Lowercasing all the string first

		oStr = This.Copy().LowercaseQ()

		# Getting the positions of the words in the string
		#TODO // delegate the work to stzText when ready

		anPos = oStr.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]

		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)
			anPos = ring_sort(anPos)
		ok

		nLen = len(anPos)

		for i = 1 to nLen
			
			cCapChar = oStr.CharAtPositionQRT(anPos[i], :stzString).
						UppercasedInLocale(pLocale)

			oStr.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		This.Update( oStr.Content() )

		#< @FunctionFluentForm

		def ApplyCapitalcaseInLocaleQ(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def CapitalcaseInLocale(pLocale) # Understand it as a verb that "capitalcases" the string in the givan locale
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInLocaleQ(pLocale)
				This.CapitalcaseInLocale(pLocale)
				return This

		def CapitaliseInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInLocaleQ(pLocale)
				This.CapitaliseInLocale(pLocale)
				return This

		def CapitalizeInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInLocaleQ(pLocale)
				This.CapitalizeInLocale(pLocale)
				return This
		#--

		def ApplyCapitalCaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def ApplyCapitalCaseInQ(pLocale)
				This.ApplyCapitalCaseIn(pLocale)
				return This

		def CapitalcaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInQ(pLocale)
				This.CapitalcaseIn(pLocale)
				return This

		def CapitaliseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInQ(pLocale)
				This.CapitaliseIn(pLocale)
				return This

		def CapitalizeIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInQ(pLocale)
				This.CapitalizeIn(pLocale)
				return This

		#>
		
	def CapitalCasedInLocale(pLocale)
		return This.Copy().CapitalCaseInLocaleQ(pLocale).Content()

		#< @FunctionFluentForm

		def CapitalcasedInLocaleQ()
			return new stzString( This.CapitalCasedInLocale() )

		#>

		#< @FunctionAlternativeForms

		def CapitalisedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def CapitalizedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseIn(pLocale)
			return CapitalcasedInLocale(pLocale)

		#>

	def IsCapitalcase()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		if This.CapitalCased() = This.String()
			return 1
		else
			return 0
		ok
		
		#< @FunctionAlternativeForms

		def IsCapitalCased()
			return This.IsCapitalcase()

		def IsCapitalised()
			return This.IsCapitalcase()

		def IsCapitalized()
			return This.IsCapitalcase()

		def IsInCapitalcase()
			return This.IsCapitalcase()

		#>

	def IsCapitalcaseOf(pcStr)
		return This.Capitalcased() = pcStr

	def IsCapitalcaseOfInLocale(pcStr, pLocale)
		return This.CapitalcasedInLocale(pLocale) = pcStr

		def IsCapitalcaseOfIn(pcStr, pLocale)
			return This.IsCapitalcaseOfInLocale(pcStr, pLocale)

	  #=============================#
	 #   TITLECASING THE STRING    #
	#=============================#

	def ApplyTitlecase()
		oLocale = new stzLocale( "C" )
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseQ()
			This.ApplyTitlecase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Titlecase() # Understand it as a verb that "titlecases" the string
			This.ApplyTitleCase()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def Titelise()
			This.ApplyTitleCase()

			def TiteliseQ()
				This.Titelise()
				return This

		def Titelize()
			This.ApplyTitleCase()

			def TitelizeQ()
				This.Titelize()
				return This
		#>	

	def TitleCased()
		return This.Copy().ApplyTitleCaseQ().Content()

		def Titelised()
			return This.TitleCased()
	
		def Titelized()
			return This.TitleCased()

		def InTitlecase()
			return This.TitleCased()
	
	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyTitlecaseInLocale(pLocale)
		oLocale = new stzLocale(pLocale)
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseInLocaleQ(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def TitlecaseInLocale(pLocale) # Understand it as a verb that "titlecases" the string in the givan locale
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInLocaleQ(pLocale)
				This.TitlecaseInLocale(pLocale)
				return This
		
		def TiteliseInLocale(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInLocaleQ(pLocale)
				This.TiteliseInLocale(pLocale)
				return This

		def TitelizeInLocale(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInLocaleQ(pLocale)
				This.TitelizeInLocale(pLocale)
				return This

		#--

		def ApplyTitlecaseInLocaleIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def ApplyTitlecaseInLocaleInQ(pLocale)
				This.ApplyTitlecaseInLocaleIn(pLocale)
				return This

		def TitlecaseIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInQ(pLocale)
				This.TitlecaseIn(pLocale)
				return This
		
		def TiteliseIn(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInQ(pLocale)
				This.TiteliseIn(pLocale)
				return This

		def TitelizeIn(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInQ(pLocale)
				This.TitelizeIn(pLocale)
				return This

		#>
			
	def TitlecasedInLocale(pLocale)
		cResult = This.Copy().TitleCaseInLocaleQ(pLocale).Content()
		return cResult

		def TitlecasedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)


	def IsTitlecase()
		if NOT This.ContainsLatinLetters()
			return ""
		ok

		if This.TitleCased() = This.String()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsTitlecased()
			return This.IsTitlecase()

		def IsTitelised()
			return This.IsTitlecase()

		def IsTitelized()
			return This.IsTitlecase()

		def IsInTitlecase()
			return This.IsTitlecase()

		#>

	def IsTitlecaseOf(pcStr)
		return This.Titlecased() = pcStr

	  #================================#
	 #    CASEFOLDING THE STRING      #
	#================================#

	/*
	INFO
	----

	The casefold() method is an aggressive lower() method which
	converts strings to case folded strings for caseless matching.
	
	WARNING:
	--------

	Review the Qt behaviour regarding QString.toCaseFolded() method.

	In fact, when writing:

	? StzStringQ("der Fluß").CaseFolded()

	We should have as result:

	"der fluss"

	since "ß" is casefolded to "ss" in german.

	But, Qt don't do that!
	
	*/

	// Transforms the string to casefolded style
	def CaseFold() # Understand it as a verb that "casefolds" the string
		This.Update( This.CaseFolded() )

		#< @FunctionFluentForm

		def CaseFoldQ()
			This.CaseFold()
			return This
	
		#>

	def CaseFolded()
		return QStringObject().toCasefolded()

	def IsCaseFolded()
		if NOT This.ContainsLatinLetters()
			return ""

		ok

		if This.Copy().CaseFolded() = This.Content()
			return 1
		else
			return 0
		ok

		return bResult

		#< @FunctionAlternativeForm

		def IsCaseFold()
			return This.IsCaseFolded()

		#>

	def IsCaseFoldedOf(pcStr)
		return This.CaseFolded() = pcStr

	  #================================#
	 #   CHECKING IF STRING IS WORD   #
	#================================#
	#TODO // should move to stzText

	def IsWord()

		if This.IsEmpty() or This.IsNumberInString()
			return 0
		ok

		_acChars_ = This.Chars()
		_nLen_ = len(_acChars_)
		_bResult_ = 1

		for i = 1 to _nLen_
			_c_ = _acChars_[i]
			_oChar_ = new stzChar(_c_)

			if _oChar_.IsNotLetter() and
			   _oChar_.IsNotNumber() and
			   _c_ != HyphenShort() and
			   _c_ != HyphenLong() and
			   _c_ != Underscore() and
			   _oChar_.IsNotArabic7arakah() and
			   _c_ != ArabicTamdeed()

				_bResult_ = 0
				exit
			ok

		next

		return _bResult_

	def IsArabicWord()
		bResult = This.ToStzText().IsArabicWord()
		return bResult

	def IsLatinWord()
		bResult = This.ToStzText().IsLatinWord()
		return bResult

	  #-------------------------------------#
	 #   CHECKING IF STRING IS STOPWORD    #
	#-------------------------------------#
	#TODO // Should move to stzText

	def IsStopWord()
		return StopWordsQ().Contains(This.Lowercased())

	def IsStopWordIn(pcLang)
		bResult = This.ToStzText().IsStopWordIn(pcLang)
		return bResult

	def LanguageIfStopWord()
		cResult = This.ToStzText().LanguageIfStopWord()
		return cResult

	  #===================================================#
	 #  NUMBER OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#===================================================#

	def NumberOfSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return 0
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		nResult = 0

		if _bCase_ = 1
			n = This.NumberOfChars()
			nResult = n * (n + 1) / 2
	
		else
			#TODO (Future)// Think of a numeric solution

			acSubStrCS = This.SubStringsCS(0)
			nResult = len(acSubStrCS)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def HowManySubstringsCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		def HowManySubstringCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStrings()
		return This.NumberOfSubStringsCS(1)

		#< @FunctionAlternativeForms

		def HowManySubstrings()
			return This.NumberOfSubStrings()

		def HowManySubstring()
			return This.NumberOfSubStrings()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#=============================================================#

	def SubStringsCS(pCaseSensitive)
		#NOTE // Got help from Google Bard for the basic algorithm used here

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )

				if pCaseSensitive = 1
					acResult + cSubStr

				else

					if ring_find(acResult, cSubStr) = 0
						acResult + cSubStr
					ok
				ok
			next
		next
		
		 return acResult


		#< @FunctionFluentForm

		def SubStringsCSQ(pCaseSensitive)
			return This.SubStringsCSQRT(pCaseSensitive, :stzList)

		def SubStringsCSQRT(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStrings()
		return This.SubStringsCS(1)

		#< @FunctionFluentForm

		def SubStringsQ()
			return This.SubStringsQRT(:stzList)

		def SubStringsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStrings() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------#
	 #  LIST OF UNIQUE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------#

	def UniqueSubStringsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen
				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
	
				if ring_find(acResult, cSubStr) = 0
					acResult + cSubStr
				ok

			next
		next

		return acResult

		def SubStringsCSU(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

		def SubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStrings()
		return This.UniqueSubStringsCS(1)

		def SubStringsU()
			return This.UniqueSubStrings()

		def SubStringsWithoutDuplication()
			return This.UniqueSubStrings()

	  #---------------------------------------------#
	 #  NUMBER OF UNIQUE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------#

	def NumberOfUniqueSubStringsCS(pCaseSensitive)
		return len( This.UniqueSubStringsCS(pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfSubStringsCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringsCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#--

		def NumberOfSubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStrings()
		return This.NumberOfUniqueSubStringsCS(1)

		#< @FunctionAlternativeForms

		def NumberOfSubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstrings()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstring()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringU()
			return This.NumberOfUniqueSubStrings()

		#--

		def NumberOfSubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		#>

	  #----------------------------------------------------------#
	 #  POSITIONS OF ALL THE POSSIBLE SUBSTRINGS IN THE STRING  #
	#==========================================================#

	def FindAllSubStringsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		anResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				if pCaseSensitive = 1
					if ring_find(anResult, i) = 0
						anResult + i
					ok
					acSubStr + cSubStr
				else

					if ring_find(acSubStr, cSubStr) = 0
						if ring_find(anResult, i) = 0
							anResult + i
						ok
						acSubStr + cSubStr
					ok
				ok
			next
		next
		
		 return anResult

		#< @FunctionAlternativeForms

		def FindAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def AllSubStringsPositionsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#--

		def FindAllSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def AllSubStringsPositionsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#==

		def FindSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def SubStringsPositionsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#--

		def FindSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def SubStringsPositionsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllSubStrings()
		return This.FindSubStringsCS(1)

		#< @FunctionAlternativeForms

		def FindAllPossibleSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfAllSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfAllPossibleSubStrings()
			return This.FindAllSubStrings()

		def AllSubStringsPositions()
			return This.FindAllSubStrings()

		#--

		def FindAllSubStringsZ()
			return This.FindAllSubStrings()

		def FindAllPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfAllSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfAllPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def AllSubStringsPositionsZ()
			return This.FindAllSubStrings()

		#==

		def FindSubStrings()
			return This.FindAllSubStrings()

		def FindPossibleSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfPossibleSubStrings()
			return This.FindAllSubStrings()

		def SubStringsPositions()
			return This.FindAllSubStrings()

		#--

		def FindSubStringsZ()
			return This.FindAllSubStrings()

		def FindPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def SubStringsPositionsZ()
			return This.FindAllSubStrings()

		#>

	   #------------------------------------------------------------#
	  #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	 #   THE STRING AND RETURNING THEM AS SECTIONS                #
	#------------------------------------------------------------#

	def FindAllSubStringsAsSectionsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				if pCaseSensitive = 1
					aResult + [ i, j ]
					acSubStr + cSubStr
				else

					if ring_find(acSubStr, cSubStr) = 0
						aResult + [ i, j ]
						acSubStr + cSubStr
					ok
				ok
			next
		next
		
		 return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#--

		def FindSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindAllSubStringsAsSectionsCS(pCaseSensitive)

		def FindSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindPossibleSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllSubStringsAsSections()
		return This.FindAllSubStringsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindAllSubStringsZZ()
			return This.FindSubStringsAsSections()

		def FindAllPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def FindAllPossibleSubStringsZZ()
			return This.FindSubStringsAsSections()

		#--

		def FindSubStringsAsSections()
			return This.FindAllSubStringsAsSections()

		def FindSubStringsZZ()
			return This.FindSubStringsAsSections()

		def FindPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def FindPossibleSubStringsZZ()
			return This.FindSubStringsAsSections()

		#>

	  #==========================================================#
	 #  FINDING CHARS OR SUBSTRINGS BASED ON A GIVEN CONDITION  #
	#==========================================================#

	def FindWCS(pcCondition, pCaseSensitive)

		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubStr = oCond.ContainsCS("@substring", 0)

		if bChar = 1 and bSubStr = 1
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keywor but not both.")
		ok
		
		if bChar = 1 and bSubStr = 0
			return This.FindCharsWCS(pcCondition, pCaseSensitive)

		but bSubStr = 1 and bChar = 0 and bPos = 0
			return This.FindSubStringsWCS(pcCondition, pCaseSensitive)

		else
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keyword.")
		ok

		#< @FunctionAlternativeForm

		def FindWCSZ(pcCondition, pCaseSensitive)
			return This.FindWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindW(pcCondition)
		return This.FindWCS(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindWZ(pcCondition)
			return This.FindW(pcCondition)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING AS SECTIONS THE SUBSTRINGS (OR EVEN CHARS) VERIFYING THE GIVEN CONDITION -- ZZ  #
	#------------------------------------------------------------------------------------------#

	def FindAsSectionsWCS(pcCondition, pCaseSensitive)
		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubStr = oCond.ContainsCS("@substring", 0)

		if bChar = 1 and bSubStr = 1
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keywor but not both.")
		ok
		
		if bChar = 1 and bSubStr = 0
			return This.FindCharsWCSZZ(pcCondition, pCaseSensitive)

		but bSubStr = 1 and bChar = 0 and bPos = 0
			return This.FindSubStringsWCSZZ(pcCondition, pCaseSensitive)

		else
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keyword.")
		ok

		def FindWCSZZ(pcCondition, pCaseSensitive)
			return This.FindAsSectionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsW(pcCondition)
		return This.FindAsSectionsWCS(pcCondition, 1)

		def FindWZZ(pcCondition)
			return This.FindAsSectionsW(pcCondition)

	  #----------------------------------------------------------------#
	 #  FINDING CHARS OR SUBSTRINGS BASED ON A GIVEN CONDITION -- XT  #
	#================================================================#

	def FindWCSXT(pcCondition, pCaseSensitive)
		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubStr = oCond.ContainsCS("@substring", 0)

		if bChar = 1 and bSubStr = 1
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keyword but not both.")
		ok
		
		if bChar = 1 and bSubStr = 0
			return This.FindCharsWCSXT(pcCondition, pCaseSensitive)

		but bSubStr = 1 and bChar = 0 and bPos = 0
			return This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)

		else
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keyword.")
		ok

		def FindWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWXT(pcCondition)
		return This.FindWCSXT(pcCondition, 1)

		def FindWXTZ(pcCondition)
			return This.FindWXT(pcCondition)

	  #------------------------------------------------------------------#
	 #  FINDING CHARS OR SUBSTRINGS BASED ON A GIVEN CONDITION -- XTZZ  #
	#------------------------------------------------------------------#

	def FindAsSectionsWCSXT(pcCondition, pCaseSensitive)

		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubStr = oCond.ContainsCS("@substring", 0)

		if bChar = 1 and bSubStr = 1
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keywor but not both.")
		ok
		
		if bChar = 1 and bSubStr = 0
			return This.FindCharsWCSXTZZ(pcCondition, pCaseSensitive)

		but bSubStr = 1 and bChar = 0
			return This.FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)

		else
			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keyword.")
		ok

		def FindWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindAsSectionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsWXT(pcCondition)
		return This.FindAsSectionsWCSXT(pcCondition, 1)

		def FindWXTZZ(pcCondition)
			return This.FindAsSectionsWXT(pcCondition)

	  #------------------------------------------------------------------------------#
	 #  FINDING ALL POSSIBLE SUBSTRINGS IN THE STRINGS VERIFYING A GIVEN CONDITION  #                  #
	#==============================================================================#

	def FindAllSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCS(pcCondition, pCaseSensitive)
		anResult = U( This.FindManyCS(acSubStrings, pCaseSensitive) )
		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsW(pcCondition)
		return This.FindAllSubStringsWCS(pcCondition, 1)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindAllPossibleSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		#--

		def FindSubStringsW(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindPossibleSubStringsW(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindPossibleSubStringsWZ(pcCondition)
			return This.FindAllSubStringsWCS(pcCondition)

		#>


	  #----------------------------------------------------------------------------------------------#
	 #  FINDING ALL POSSIBLE SUBSTRINGS IN THE STRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #                  #
	#----------------------------------------------------------------------------------------------#

	def FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = U( This.FindManyCS(acSubStrings, pCaseSensitive) )
		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsWXT(pcCondition)
		return This.FindAllSubStringsWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindAllPossibleSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		#--

		def FindSubStringsWXT(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindPossibleSubStringsWXT(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindPossibleSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWCSXT(pcCondition)

		#>

	    #------------------------------------------------------------#
	   #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	  #   THE STRING WHERE A GIVEN CONDITION IS VERIFIED AND       #
	 #   RETURNING THEM AS SECTIONS                               #
	#============================================================#

	def FindAllSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCS(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSubStrings, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsAsSectionsW(pcCondition)
		return This.FindAllSubStringsAsSectionsWCS(pcCondition, 1)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindAllPossibleSubStringsAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindAllPossibleSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#--

		def FindSubStringsAsSectionsW(pcCondition)
			return This.FindAllSubStringsAsSectionsW(pcCondition)

		def FindSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindPossibleSubStringsAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsWCS(pcCondition)

		def FindPossibleSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#>

	    #------------------------------------------------------------#
	   #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	  #   THE STRING WHERE A GIVEN CONDITION IS VERIFIED AND       #
	 #   RETURNING THEM AS SECTIONS -- WXT/EXTENDED               #
	#============================================================#

	def FindAllSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSubStrings, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsAsSectionsWXT(pcCondition)
		return This.FindAllSubStringsAsSectionsWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindAllPossibleSubStringsAsSectionsWXT(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindAllPossibleSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		#--

		def FindSubStringsAsSectionsWXT(pcCondition)
			return This.FindAllSubStringsAsSectionsWXT(pcCondition)

		def FindSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindPossibleSubStringsAsSectionsWXT(pcCondition)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition)

		def FindPossibleSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		#>

	  #===============================================#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR POSITIONS  #
	#===============================================#
	#TODO // Check performance
	#UPDATE // Done

	def AllSubStringsCSZ(pCaseSensitive)

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				nPos = ring_find(acSubStr, cSubStr)
				if nPos = 0
					aResult + [ cSubStr, [ i ] ]
					acSubStr + cSubStr

				else
					aResult[nPos][2] + i
				ok

			next
		next
		
		 return aResult

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#--

		def SubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def SubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#== Adding U

		def AllSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#--

		def SubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def SubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#== Adding Unique

		def UniqueSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def UniqueSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AllSubStringsZ()
		return This.AllSubStringsCSZ(1)

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsZ()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#--

		def SubStringsZ()
			return This.AllSubStringsZ()

		def SubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		def PossibleSubStringsZ()
			return This.AllSubStringsZ()

		def PossibleSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#== Adding U

		def AllSubStringsUZ()
			return This.AllSubStringsZ()

		def AllSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsUZ()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		#--

		def SubStringsUZ()
			return This.AllSubStringsZ()

		def SubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		def PossibleSubStringsUZ()
			return This.AllSubStringsZ()

		def PossibleSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		#== Adding Unique

		def UniqueSubStringsZ()
			return This.AllSubStringsZ()

		def UniqueSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#>

	  #----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR SECTIONS  #
	#----------------------------------------------#
	#TODO // Check performance
	#UPDATE // Done

	def AllSubStringsCSZZ(pCaseSensitive)

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				nPos = ring_find(acSubStr, cSubStr)

				if nPos = 0
					aResult + [ cSubStr, [ [ i, j ] ] ]
					acSubStr + cSubStr

				else
					aResult[nPos][2] + [ i, j ]
				ok

			next
		next
		
		 return aResult

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#--

		def SubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def SubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#== Adding U

		def AllSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#--

		def SubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def SubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#== Adding Unique

		def UniqueSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def UniqueSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AllSubStringsZZ()
		return This.SubStringsCSZZ(1)

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsZZ()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#--

		def SubStringsZZ()
			return This.AllSubStringsZZ()

		def SubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		def PossibleSubStringsZZ()
			return This.AllSubStringsZZ()

		def PossibleSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#== Adding U

		def AllSubStringsUZZ()
			return This.AllSubStringsZZ()

		def AllSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsUZZ()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		#--

		def SubStringsUZZ()
			return This.AllSubStringsZZ()

		def SubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		def PossibleSubStringsUZZ()
			return This.AllSubStringsZZ()

		def PossibleSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		#== Adding Unique

		def UniqueSubStringsZZ()
			return This.AllSubStringsZZ()

		def UniqueSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#>

	  #------------------------------------------------------#
	 #  GETTING THE LIST OF ALL SUBSTRINGS MADE OF N CHARS  #
	#======================================================#

	def SubStringsOfNCharsCS(n, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)


		for i = 1 to nLen
			for j = i to nLen
				if n = j-i+1
					cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
					acResult + cSubStr
				ok
			next
		next

		return acResult

		def SubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.SubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOfNChars(n)
		return This.SubStringsOfNCharsCS(n, 1)

		def SubStringsMadeOfNChars(n)
			return This.SubStringsOfNChars(n)

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-------------------------------------------------------------#

	def UniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen
				if n = j-i+1
					cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				
					if ring_find(acResult, cSubStr) = 0
						acResult + cSubStr
					ok
				ok
			next
		next

		return acResult

		#< @FunctionAlternativeForms

		def UniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsWithoutDuplicationMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#--

		def SubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsMadeOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def WithoutDuplicationMadeOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESITIVITY

	def UniqueSubStringsOfNChars(n)
		return This.UniqueSubStringsOfNCharsCS(n, 1)

		#< @FunctionAlternativeForms

		def UniqueSubStringsMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsWithoutDuplicationMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		#--

		def SubStringsOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsMadeOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		def WithoutDuplicationMadeOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		#>

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS MADE OF N CHARS  #
	#----------------------------------------------------#

	def NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.SubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsOfNChars(n)
		return This.NumberOfSubStringsOfNCharsCS(n, 1)

		def NumberOfSubStringsMadeOfNChars(n)
			return This.NumberOfSubStringsOfNChars(n)

	  #-----------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-----------------------------------------------------------#

	def NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfUniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManyUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#--

		def NumberOfSubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def NumberOfSubStringsMadeOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManySubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsOfNChars(n)
		return This.NumberOfUniqueSubStringsOfNCharsCS(n, 1)

		#< @FunctionAlternativeForms

		def NumberOfUniqueSubStringsMadeOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)
	
		def HowManyUniqueSubStringsOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		#--

		def NumberOfSubStringsOfNCharsU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		def NumberOfSubStringsMadeOfNCharsU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)
	
		def HowManySubStringsOfNCharsCU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		#>

#TODO // Add these functions
# def FindSubStringsOfNChars()
# def FindSubStringsOfNCharsZZ()
# def SubStringsOfNCharsZ()
# def SubStringsOfNCharsZZ()

	  #----------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#================================================================#

	def NumberOfSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = len( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsW(pcCondition)
		return This.NumberOfSubStringsWCS(pcCondition, 1)

	  #-------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS VERIFYING A GIVEN CONDITION -- WX/EXTENDED  #
	#-------------------------------------------------------------------------------#

	def NumberOfSubStringsWCSXT(pcCondition, pCaseSensitive)
		nResult = len( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsWXT(pcCondition)
		return This.NumberOfSubStringsWCSXT(pcCondition, 1)

	  #-----------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#=======================================================================#

	def NumberOfUniqueSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = len( This.UniqueSubStringsWCS(pcCondition, pCaseSensitive) )
		return nResult

		def NumberOfSubStringsWCSU(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsW(pcCondition)
		return This.NumberOfUniqueSubStringsWCS(pcCondition, 1)

		def NumberOfSubStringsWU(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------------------#

	def NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)
		nResult = len( This.UniqueSubStringsWCSXT(pcCondition, pCaseSensitive) )
		return nResult

		def NumberOfSubStringsWCSXTU(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)

		def NumberOfSubStringsWCSUXT(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsWXT(pcCondition)
		return This.NumberOfUniqueSubStringsWCSXT(pcCondition, 1)

		def NumberOfSubStringsWXTU(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

		def NumberOfSubStringsWUXT(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	#=====================================================================================#

	def SubStringsWCS(pcCondition, pCaseSensitive)
		acResult = This.SubStringsCSQ(pCaseSensitive).ItemsW(pcCondition)
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringsW(pcCondition)
		return This.SubStringsWCS(pcCondition, 1)

	  #-----------------------------------------------------------------------------------------------------#
	 #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------------------------#

	def SubStringsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SubStringsCSQ(pCaseSensitive).ItemsWXT(pcCondition)
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXT(pcCondition)
		return This.SubStringsWCSXT(pcCondition, 1)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR POSITIONS -- WZ/EXTENSION                                         #
	#=====================================================================================#

	def SubStringsWCSZ(pcCondition, pCaseSensitive)

		acSubStr = U( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		anPos = This.FindManyCS(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, anPos ])

		return aResult

		def SubStringsAndTheirPositionsWCS(pcCondition, pCaseSensitive)
			return This.SubStringsAndTheirPositionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWZ(pcCondition)
		return This.SubStringsWCSZ(pcCondition, 1)

		def SubStringsAndTheirPositionsW(pcCondition)
			return This.SubStringsAndTheirPositionsW(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR POSITIONS -- WXTZ/EXTENSION                                       #
	#-------------------------------------------------------------------------------------#

	def SubStringsWCSXTZ(pcCondition, pCaseSensitive)

		acSubStr = U( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		anPos = This.FindManyCS(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, anPos ])

		return aResult

		def SubStringsAndTheirPositionsWCSXT(pcCondition, pCaseSensitive)
			return This.SubStringsAndTheirPositionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXTZ(pcCondition)
		return This.SubStringsWCSXTZ(pcCondition, 1)

		def SubStringsAndTheirPositionsWXT(pcCondition)
			return This.SubStringsAndTheirPositionsWXT(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR SECTIONS -- WZZ/EXTENSION                                         #
	#=====================================================================================#

	def SubStringsWCSZZ(pcCondition, pCaseSensitive)

		acSubStr  = U( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		aSections = This.FindManyCSZZ(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, aSections ])

		return aResult

		def SubStringsAndTheirSectionsWCS(pcCondition, pCaseSensitive)
			return This.SubStringsWCSZZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWZZ(pcCondition)
		return This.SubStringsWCSZZ(pcCondition, 1)

		def SubStringsAndTheirSectionsW(pcCondition)
			return This.SubStringsWZZ(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR SECTIONS -- WXZZ/EXTENSION                                        #
	#=====================================================================================#

	def SubStringsWCSXTZZ(pcCondition, pCaseSensitive)

		acSubStr  = U( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		aSections = This.FindManyCSZZ(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, aSections ])

		return aResult

		def SubStringsAndTheirSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.SubStringsWCSXTZZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXTZZ(pcCondition)
		return This.SubStringsWCSXTZZ(pcCondition, 1)

		def SubStringsAndTheirSectionsWXT(pcCondition)
			return This.SubStringsWXTZZ(pcCondition)

	  #----------------------------------------------------#
	 #  GETTING THE GIVEN SUBSTRINGS AND THEIR POSITIONS  #
	#====================================================#

	def TheseSubStringsCSZ(pacSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSubStrU = U( pacSubStr ) # U removes duplicates
		nLen = len(acSubStrU)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindCS(acSubStrU[i], pCaseSensitive)
			aResult + [ acSubStrU[i], anPos ]
		next

		return aResult


		def TheseSubStringsAndTheirPositionsCS(pacSubStr, pCaseSensitive)
			return This.TheseSubStringsCSZ(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsZ(pacSubStr)
		return This.TheseSubStringsCSZ(pacSubStr, 1)

		def TheseSubStringsAndTheirPositions(pacSubStr)
			return This.TheseSubStringsZ(pacSubStr)

	  #---------------------------------------------------#
	 #  GETTING THE GIVEN SUBSTRINGS AND THEIR SECTIONS  #
	#---------------------------------------------------#

	def TheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSubStrU = U( pacSubStr ) # U removes duplicates
		nLen = len(acSubStrU)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindCSZZ(acSubStrU[i], pCaseSensitive)
			aResult + [ acSubStrU[i], anPos ]
		next

		return aResult

		def TheseSubStringsAndTheirSectionsCS(pacSubStr, pCaseSensitive)
			return This.TheseSubStringsCSZZ(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsZZ(pacSubStr)
		return This.TheseSubStringsCSZZ(pacSubStr, 1)

		def TheseSubStringsAndTheirSections(pacSubStr)
			return This.TheseSubStringsZZ(pacSubStr)

	  #================================================#
	 #  FINDING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#================================================#

	def FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		aAntiSections = This.FindAntiSections(aSections)
		nLen = len(aAntiSections)

		anResult = []

		for i = 1 to nLen
			anResult + aAntiSections[1][1]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringsExceptCSZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindAllExceptCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindExceptCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindAllButCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsExcept(pacSubStr)
		return This.FindSubStringsExceptCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringsExceptZ(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindSubStringsOtherThan(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindSubStringsOtherThanZ(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindExcept(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindAllExcept(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindAllBut(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#==============================================================#

	def FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindAntiSections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindExceptAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindAllExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindAllButCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsExceptAsSections(pacSubStr)
		return This.FindSubStringsExceptAsSectionsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringsExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindSubStringsOtherThanAsSections(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindSubStringsOtherThanZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindExceptAsSections(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindAllExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindAllButZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		#>

	  #------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#================================================#

	def SubStringsExceptCS(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def SubStringsExceptTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def OtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def OtherThanTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExcept(pacSubStr)
		return This.SubStringsExceptCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringsExceptThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def SubStringsOtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def SubStringsOtherThanThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def Except(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def ExceptThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def OtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def OtherThanThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED ALONG WITH THEIR POSITIONS  #
	#===========================================================================#

	def SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acSubStr = This.Sections(aSections)

		anPos = []
		nLen = len(aSections)
		for i = 1 to nLen
			anPos + aSections[i][1]
		next

		aResult = Association([ acSubStr, anPos ])
		return aResult

		return acResult

		#< @FunctionAlternativeForms

		def SubStringsAndTheirPositionsExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		def SubStringsAndTheirPositionsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptCSZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExceptZ(pacSubStr)
		return This.SubStringsExceptCSZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringsAndTheirPositionsExcept(pacSubStr)
			return This.SubStringsExceptZ(pacSubStr)

		def SubStringsOtherThanZ(pacSubStr)
			return This.SubStringsExceptZ(pacSubStr)

		def SubStringsAndTheirPositionsOtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def ExceptZ(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED ALONG WITH THEIR SECTIONS  #
	#==========================================================================#

	def SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acSubStr = This.Sections(aSections)

		aResult = Assocation([ acSubStr, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def SubStringsAndTheirSectionsExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCSZZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def SubStringsAndTheirSectionsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def ExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExceptZZ(pacSubStr)
		return This.SubStringsExceptCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringsAndTheirSectionsExcept(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def SubStringsOtherThanZZ(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def SubStringsAndTheirSectionsOtherThan(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def ExceptZZ(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		#>

	  #=================#
	 #      LINES      #
	#=================#

	def LinesCS(pCaseSensitive)
		return This.SplitCS(NL, pCaseSensitive)

		#< @FunctionFluentForm

		def LinesCSQ(pCaseSensitive)
			return new stzList(This.LinesCS(pCaseSensitive))

		def LinesCSQRT(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.LinesCS(pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.LinesCS(pCaseSensitive))

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
	#-- WIHTOUT CASESENSITIVITY

	def Lines()
		return This.LinesCS(1)

		#< @FunctionFluentForms

		def LinesQ()
			return This.LinesQRT(:stzList)

		def LinesQRT(pcReturnType)
			return This.LinesCSQRT(TRUE, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  GETTING THE NUMBER OF LINES IN THE STRING  #
	#---------------------------------------------#

	def NumberOfLinesCS(pCaseSensitive)
		return len(This.LinesCS(pCaseSensitive))

		def HowManyLinesCS(pCaseSensitive)
			return This.NumberOfLinesCS(pCaseSensitive)

		def CountLinesCS(pCaseSensitive)
			return This.NumberOfLinesCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def NumberOfLines()
		return This.NumberOfLinesCS(1)

		def HowManyLines()
			return This.NumberOfLines()

		def CountLines()
			return This.NumberOfLines()

	  #----------------#
	 #  UNIQUE LINES  #
	#================#

	def UniqueLinesCS(pCaseSensitive)
		acResult = This.LinesCSQ(pCaseSensitive).DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForm

		def UniqueLinesCSQ(pCaseSensitive)
			return This.UniqueLinesCSQRT(pCaseSensitive, :stzList)

		def UniqueLinesCSQRT(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueLinesCS(pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueLinesCS(pCaseSensitive))

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LinesCSU(pCaseSensitive)
			return This.UniqueLinesCS(pCaseSensitive)

			def LinesCSQU(pCaseSensitive)
				return This.LinesCSQRU(pCaseSensitive, :stzList)

			def LinesCSQRU(pCaseSensitive, pcReturnType)
				return This.UniqueLinesCSQRT(pCaseSensitive, pcReturnType)

		def LinesWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueLinesCS(pCaseSensitive)

			def LinesWithoutDuplicationCSQ(pCaseSensitive)
				return This.LinesWithoutDuplicationCSQRT(pCaseSensitive, :stzList)

			def LinesWithoutDuplicationCSQRT(pCaseSensitive, pcReturnType)
				return This.UniqueLinesCSQRT(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UniqueLines()
		return This.UniqueLinesCS(1)

		#< @FunctionFluentForm

		def UniqueLinesQ()
			return This.UniqueLinesQRT(:stzList)

		def UniqueLinesQRT(pcReturnType)
			return This.UniqueLinesCSQRT(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def LinesU()
			return This.UniqueLines()

			def LinesQU()
				return This.LinesQRU(:stzList)

			def LinesQRU(pcReturnType)
				return This.UniqueLinesQRT(pcReturnType)

		def LinesWithoutDuplication()
			return This.UniqueLines()

			def LinesWithoutDuplicationQ()
				return This.LinesWithoutDuplicationQRT(:stzList)

			def LinesWithoutDuplicationQRT(pcReturnType)
				return This.UniqueLinesQRT(pcReturnType)

		#>

	  #----------------------------------------------------#
	 #  GETTING THE UNIQUE NUMBER OF LINES IN THE STRING  #
	#----------------------------------------------------#

	def NumberOfUniqueLinesCS(pCaseSensitive)
		return len(This.UniqueLinesCS(pCaseSensitive))

		#< @FunctionAlternativeForms

		def HowManyUniqueLinesCS(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def CountUniqueLinesCS(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		#--

		def NumberOfLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def HowManyLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def CountLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfUniqueLines()
		return This.NumberOfUniqueLinesCS(1)

		#< @FunctionAlternativeForms

		def HowManyUniqueLines()
			return This.NumberOfUniqueLines()

		def CountUniqueLines()
			return This.NumberOfUniqueLines()

		#--

		def NumberOfLinesU()
			return This.NumberOfUniqueLines()

		def HowManyLinesU()
			return This.NumberOfUniqueLines()

		def CountLinesU()
			return This.NumberOfUniqueLines()

		#>

	  #-------------------------------------#
	 #  GETTING THE NUMBER OF EMPTY LINES  #
	#=====================================#

	def NumberOfEmptyLinesCS(pCaseSensitive)
		acLines = This.LinesCS(pCaseSensitive)
		nLen = len(acLines)

		nResult = 0

		for i = 1 to nLen
			if ring_trim(acLines[i]) = ""
				nResult++
			ok
		next

		return nResult


		#< @FunctionAlternativeForms

		def HowManyEmptyLinesCS(pCaseSensitive)
			return This.NumberOfEmptyLinesCS(pCaseSensitive)

		def HowManyEmptyLineCS(pCaseSensitive)
			return This.NumberOfEmptyLinesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfEmptyLines()
		return This.NumberOfEmptyLinesCS(1)

		#< @FunctionAlternativeForms

		def HowManyEmptyLines()
			return This.NumberOfEmptyLines()

		def HowManyEmptyLine()
			return This.NumberOfEmptyLines()

		#>

	  #--------------------------------------------#
	 #  REMOVING THE EMPTY LINES FROM THE STRING  #
	#============================================#

	def RemoveEmptyLinesCS(pCaseSensitive)
		acLines = This.LinesCS(pCaseSensitive)
		nLen = len(acLines)

		cResult = ""

		for i = 1 to nLen
			if NOT ring_trim(acLines[i]) = ""
				cResult += acLines[i] + NL
			ok
		next

		cResult = StzStringQ(cResult).LastCharRemoved()
		This.UpdateWith(cResult)


		#< @FunctionFluentForm

		def RemoveEmptyLinesCSQ(pCaseSensitive)
			This.RemoveEmptyLinesCS(pCaseSensitive)
			return This

		#>

	def EmptyLinesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveEmptyLinesCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveEmptyLines()
		This.RemoveEmptyLinesCS(1)

		#< @FunctionFluentForm

		def RemoveEmptyLinesQ()
			return This.RemoveEmptyLinesCSQ(1)

		#>

	def EmptyLinesRemoved()
		return This.EmptyLinesRemovedCS(1)

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#==========================================#

	def RemoveLinesWCS(pcCondition, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(This[@i]).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		cResult = This.LinesCSQRT(pCaseSensitive, :stzListOfStrings).
			       RemoveWQ(pCaseSensitive, pcCondition).
			       ConcatenatedUsing(NL)

		This.Update(cResult)

		#< @FunctionFluentForm

		def RemoveLinesWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLinesWCS(pcCondition, pCaseSensitive)
			return This

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLinesW(pcCondition)
		This.RemoveLinesWCS(pcCondition, 1)

		#< @FunctionFluentForm

		def RemoveLinesWQ(pcCondition)
			This.RemoveLinesW(pcCondition)
			return This

		#>

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#==========================================#

	def RemoveLinesWCSXT(pcCondition, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(@line).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		cResult = This.LinesCSQ(pCaseSensitive).
			       RemoveWCSXTQ(pcCondition, pCaseSensitive).
			       ConcatenatedUsing(NL)

		This.Update(cResult)

		#< @FunctionFluentForm

		def RemoveLinesWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLinesWCSXT(pcCondition, pCaseSensitive)
			return This

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLinesWXT(pcCondition)
		This.RemoveLinesWCSXT(pcCondition, 1)

		#< @FunctionFluentForm

		def RemoveLinesWXTQ(pcCondition)
			This.RemoveLinesWXT(pcCondition)
			return This

		#>

	  #=========================================#
	 #  MANAGING INVISBLE CHARS IN THE STRING  #
	#=========================================#


	def ContainsInvisibleChars()

		acCharsNames = This.CharsNames()
		acInvisibleCharsNames = @InvisibleCharsNames()
		nLen = len(acInvisibleCharsNames)

		for i = 1 to nLen
			if ring_find(acCharsNames, acInvisibleCharsNames[i]) > 0
				return TRUE
			ok

		next

		return FALSE

		def ContainsInvisible()
			return This.ContainsInvisibleChars()

	  #-----------------------------------------------------#
	 #  GETTING THE LIST OF INVISIBLE CHARS IN THE STRING  #
	#-----------------------------------------------------#

	def InvisibleChars()

		acCharsNames = This.CharsNames()
		acInvisibleCharsNames = @InvisibleCharsNames()
		nLen = len(acInvisibleCharsNames)

		acResult = []

		for i = 1 to nLen
			if ring_find(acCharsNames, acInvisibleCharsNames[i]) > 0
				acResult + acInvisibleCharsNames[i]
			ok

		next

		return acResult

		def Invisibles()
			return This.InvisibleChars()

	  #---------------------------------#
	 #  GETTING INVISIBLE CHARS NAMES  #
	#---------------------------------#

	def InvisibleCharsNames()

		acCharsNames = This.CharsNames()
		acInvisibleCharsNames = @InvisibleCharsNames()
		nLen = len(acInvisibleCharsNames)

		acResult = []

		for i = 1 to nLen
			if ring_find(acCharsNames, acInvisibleCharsNames[i]) > 0
				acResult + @CharName(acInvisibleCharsNames[i])
			ok

		next

		return acResult

		def InvisiblesNames()
			return This.InvisibleCharsNames()

	  #-------------------------------------------#
	 #  FINDING INVISIBLE CHARS FROM THE STRING  #
	#-------------------------------------------#

	def FindInvisibleChars()

		acCharsNames = This.CharsNames()
		acInvisibleCharsNames = @InvisibleCharsNames()
		nLen = len(acInvisibleCharsNames)

		anResult = []

		for i = 1 to nLen
			nPos = ring_find(acCharsNames, acInvisibleCharsNames[i])
			if nPos > 0
				anResult + nPos
			ok

		next

		return anResult

		def FindInvisible()
			return This.FindInvisibleChars()

		def FindInvisibles()
			return This.FindInvisibleChars()

	  #--------------------------------------------#
	 #  REMOVING INVISIBLE CHARS FROM THE STRING  #
	#--------------------------------------------#

	def RemoveInvisibleChars()
		This.RemoveCharsAtPositions(This.FindInvisibleChars())

		def RemoveInvisibleCharsQ()
			This.RemoveInvisibleChars()
			return This

		def RemoveInvisibles()
			This.RemoveInvisibleChars()

			def RemoveInvisiblesQ()
				return This.RemoveInvisibleCharsQ()

	def InvisbleCharsRemoved()
		_cResult_ = This.Copy().RemoveInvisibleCharQ().Content()
		return _cResult_

		def InvisiblesRemoved()
			return This.InvisibleCharsRemoved()

	  #--------------------------------------------#
	 #  REPLACING INVISIBLE CHARS FROM THE STRING  #
	#--------------------------------------------#

	def ReplaceInvisibleChars(pCharOrMany)

		if CheckParams()
			if isList(pCharOrMany) and StzListQ(pCharOrMany).IsWithOrByOrUsingNamedParam()
				pCharOrMany = pCharOrMany[2]
			ok
		ok

		if isString(pCharOrMany)
			This.ReplaceCharsAtPositions(This.FindInvisibleChars(), pCharOrMany)

		but isList(pCharOrMany)

			This.ReplaceCharsAtPositionsByMany(This.FindInvisibleChars(), pCharOrMany)

		else
			stzraise("Incorrect param type! pCharOrMany must be a string or list.")
		ok

		def ReplaceInvisibleCharsQ(pCharOrMany)
			This.ReplaceInvisibleChars(pCharOrMany)
			return This

		def ReplaceInvisibles(pCharOrMany)
			This.ReplaceInvisibleChars(pCharOrMany)

			def ReplaceInvisiblesQ(pCharOrMany)
				return This.ReplaceInvisibleCharsQ(pCharOrMany)

	def InvisbleCharsReplaced(pCharOrMany)
		_cResult_ = This.Copy().ReplaceInvisibleCharQ(pCharOrMany).Content()
		return _cResult_

		def InvisiblesReplaced(pCharOrMany)
			return This.InvisibleCharsReplaced(pCharOrMany)

	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS NUMBERS  #
	#===========================================#

	def ContainsNumbers()
		acDigits = "0" : "9"
		nLen = len(acDigits)

		cContent = This.Content()
		bResult = 0

		for i = 1 to nLen
			n = This.FindFirst(acDigits[i])
			if n > 0
				bResult = 1
				exit
			ok
		next

		return bResult

	#TODO
	# Add ContainsNumbersXT() that finds other types of numbers other then decimal

	  #===============================#
	 #  GETTING AND SETTING MARQUER  #
	#===============================#

	def MarquerChar()
		return @cMarquer
		
		def Marquer()
			return @cMarquer
	
	def SetMarquerChar(c)
		if NOT (isString(c) and IsChar(c))
			StzRaise("Incorrect param type! c must be a char.")
		ok
	
		@cMarquer = c
	
		#NOTE // A marquer char can be set at the global level or string object level
	
		def SetMarquer()
			@cMarquer = c

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MARQUERS  #
	#============================================#

	def ContainsMarquers()
		if This.NumberOfMarquers() > 0
			return 1
		else
			return 0
		ok

	  #---------------------------------------#
	 #  CHECKING IF THE STRING IS A MARQUER  #
	#=======================================#

	def IsMarquer()

		nLen = This.NumberOfChars()

		if nLen < 2
			return 0
		ok

		if NOT This.FirstChar() = "#"
			return 0
		ok

		if NOT This.SectionQ(2, nLen).IsNumberInString()
			return 0
		ok
 
		return 1

		def IsAMarquer()
			return This.IsMarquer()

	  #----------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING  #
	#==============================================#

	def Marquers()
		cMarquerChar = This.Marquer()

		oCopy = This.AddQ(" ")
		nLenStr = oCopy.NumberOfChars()
		
		anPos = oCopy.Find(cMarquerChar)
		nLenPos = len(anPos)
		
		if nLenPos = 0
			return []
		ok
		
		if anPos[nLenPos] != cMarquerChar
			anPos + nLenStr
		ok
		
		
		acResult = []
		
		for i = 1 to nLenPos
			n1 = anPos[i]+1
			n2 = anPos[i+1]-1
			cMarquer = ""
		
			for j = n1 to n2
				char = oCopy.QStringObject().mid(j-1, 1)
		
				if char = "0" or char = "1" or char = "2" or
				   char = "3" or char = "4" or char = "5" or
				   char = "6" or char = "7" or char = "8" or
				   char = "9"
		
					cMarquer += char
				else
					exit
				ok
				
			next
		
			if cMarquer != ""
				acResult + (cMarquerChar + cMarquer)
			ok
		next
		
		return acResult

		def MarquersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.Marquers())

			on :stzList
				return new stzList(This.Marquers())

			other
				stzRaise("Unsupported return type!")
			off

	  #---------------------------------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING -- WITHOUT DUPLICATION  #
	#=====================================================================#

	def UniqueMarquers()
		return StzListQ(This.Marquers()).UniqueItems()

		#< @FunctionFluentForms

		def UniqueMarquersQ()
			return This.UniqueMarquersQRT(:stzList)

		def UniqueMarquersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueMarquers())

			on :stzList
				return new stzList(This.UniqueMarquers())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SetOfMarquers()
			return This.UniqueMarquers()

			def SetOfMarquersQ()
				return This.UniqueMarquersQ()

			def SetOfMarquersQRT(pcReturnType)
				return This.UniqueMarquersQRT(pcReturnType)

		def MarquersU()
			return This.UniqueMarquers()

			def MarquersUQ()
				return This.UniqueMarquersQ()

			def MarquersUQRT(pcReturnType)
				return This.UniqueMarquersQRT(pcReturnType)

		def MarquersWithoutDuplication()
			return This.UniqueMarquers()

			def MarquersWithoutDuplicationQ()
				return This.UniqueMarquersQ()

			def MarquersWithoutDuplicationQRT(pcReturnType)
				return This.UniqueMarquersQRT(pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE MARQUERS ~> WITHOUT DUPLICATION  #
	#----------------------------------------------------------------#

	def NumberOfUniqueMarquers()
		nResult = len( This.UniqueMarquers() )
		return nResult

		def NumberOfMarquersU()
			return This.NumberOfUniqueMarquers()

	  #------------------------------------------------#
	 #  GETTING THE NUMBER OF MARQUERS IN THE STRING  #
	#================================================#

	def NumberOfMarquers()
		return len(This.Marquers())

		def CountMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquer()
			return This.NumberOfMarquers()

	  #-------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS IN EACH MARQUER IN THE STRING  #
	#=============================================================#

	def NumberOfCharsInEachMarquer()
		acMarquers = This.Marquers()
		nLen = len(acMarquers)

		aResult = []
		for i = 1 to nLen
			aResult + len(acMarquers[i])
		next

		return aResult

		#< @FunctionAlternativeForms

		def SizeOfEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def MarquersNumbersOfChars()
			return This.NumberOfCharsInEachMarquer()

		def CountCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		#>

	  #-------------------------------#
	 #   MFINDING ARQUERS POSITIONS  #
	#===============================#

	def FindMarquers()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? FindMarquers()
			#--> [ 12, 25, 44, 66 ]
		
		}
		*/

		acMarquers = This.Marquers()
		aResult = []

		n = 1

		for cMarquer in acMarquers
			n = This.FindNextOccurrence( cMarquer, n )
			/* WARNING: Don't use:
			n = This.FindNextMarquer(cMarquer)
			--> Circular call --> Stackoverflow
			*/
			aResult + n
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindMarquersZ()
			return This.FindMarquers()

		def MarquersOccurrences()
			return This.FindMarquers()

		def MarquersPositions()
			return This.FindMarquers()

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#================================================#

	def MarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersAndPositions() " Use MarquersZ() instead
			#--> [ "#1" = 12, "#2" = 25 , "#3" = 44, "#1" = 66 ]
		
		}
		*/

		aResult = Association([ This.Marquers(), This.MarquersPositions() ]).
		return aResult

		#< @FunctionAlternativeForms

		def MarquersAndTheirPositions()
			return This.MarquersAndPositions()

		def MarquersAndOccurrences()
			return This.MarquersAndPositions()

		def MarquersAndTheirOccurrences()
			return This.MarquersAndPositions()

		def MarquersZ()
			return This.MarquersAndPositions()

		#>

	  #-------------------------------------------------------#
	 #   UNIQUE MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#=======================================================#

	def UniqueMarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? UniqueMarquersAndPositions() # Use MarquersUZ() instead
			#--> [ "#1" = [12, 66], "#2" = [26], "#3" = [44] ]
		
		}
		*/
		acMarquers = This.UniqueMarquers()
		nLen = len(acMarquers)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindAll(acMarquers[i])
			aResult + [ acMarquers[i], anPos ]
		next

		return aResult
		

		#< @FunctionAlternativeForms

		def UniqueMarquersAndTheirPositions()
			return This.UniqueMarquersAndPositions()

		def UniqueMarquersAndOccurrences()
			return This.MarquersAndPositions()

		def UniqueMarquersAndTheirOccurrences()
			return This.UniqueMarquersAndPositions()

		def MarquersUZ()
			return This.UniqueMarquersAndPositions()

		def UniqueMarquersZ()
			return This.UniqueMarquersAndPositions()

		def MarquersAndPositionsU()
			return This.UniqueMarquersAndPositions()

		def MarquersAndTheirPositionsU()
			return This.UniqueMarquersAndPositions()

		#>

	  #----------------------------#
	 #      FINDING A MARQUER     #
	#============================#

	def OccurrencesOfMarquer(pcMarquer)

		aResult = This.UniqueMarquersAndTheirPositions()[pcMarquer]
			# ~> Or you can simply say: This.MarquersUZ()[pcMarquer]

		if isString(aResult) and aResult = ""
			return []
		else
			return aResult
		ok

		#< @FunctionFluentForm

		def OccurrencesOfMarquerQ(pcMarquer)
			return This.OccurrencesOfMarquerQRT(pcMarquer, :stzList)

		def OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.OccurrencesOfMarquer(pcMArquer) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.OccurrencesOfMarquer(pcMArquer) )

			other
				stzRaise("Unsupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def PositionsOfMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfMarquerQRT(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)

		def PositionsOfThisMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfThisMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfThisMarquerQRT(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)

		def MarquerPositions(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def MarquerPositionsQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def MarquerPositionsQRT(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)

		def FindMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindMarquerQRT(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)

		def FindThisMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindThisMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindThisMarquerQRT(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQRT(pcMarquer, pcReturnType)

			#>

	  #-------------------------------------#
	 #    GETTING A MARQUER BY POSITION    #
	#=====================================#

	def MarquerByPosition(pnPosition)
		aMarquers = This.MarquersAndTheirPositionsU()
		nLen = len(aMarquers)

		cResult = ""

		for i = 1 to nLen
			n = ring_find(aMarquers[i][2], pnPosition)
			if n > 0
				cResult = aMarquers[i][1]
				exit
			ok
		next

		return cResult

		def MarquerByPositionQ(pnPosition)
			return new stzString( This.MarquerByPosition() )

		def MarquerByOccurrence(pnPosition)
			return This.MarquerByPosition(pnPosition)

			def MarquerByOccurrenceQ(pnPosition)
				return new stzString( This.MarquerByOccurrence(pnPosition) )

	  #-------------------------------------------#
	 #    GETTING A MARQUER BY MANY POSITIONS    #
	#===========================================#

	def MarquerByPositions(panPos)
		cMarquer = This.MarquerByPosition(panPos[1])
		anPos = This.FindMarquer(cMarquer)

		cResult = ""

		if StzListQ(panPos).IsIncludedIn(anPos)
			cResult = cMarquer
		ok

		return cResult


		def MarquerByOccurrences(panPos)
			return This.MarquerByPositions(panPos)

	  #-------------------------------------------#
	 #    GETTING MARQUERS BY THEIR POSITIONS    #
	#===========================================#

	def MarquersByPositions(panPos)
		oHash = new stzHashList( MarquersUZ() )
		acResult = oHash.KeysByValues(panPos)

		return acResult

		def MarquersByOccurrences(panPos)
			return This.MarquersByPositions(panPos)

	  #----------------------------------#
	 #   FINDING MARQUERS AS SECTIONS   #
	#==================================#

	def FindMarquersZZ()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? FindMarquersZZ()
			#--> [  [12, 13], [ 25, 26],  [44, 45], [66, 67]  ]
		
		}
		*/

		anStartPos  = This.FindMarquers()
		anNbOfChars = This.MarquersNumbersOfChars()

		aResult = []

		for i = 1 to len(anStartPos)
			aResult + [ anStartPos[i], anStartPos[i] + anNbOfChars[i] - 1 ]
		next

		return aResult


		#< @FunctionAlternativeForm

		def FindMarquersAsSections()
			return This.FindMarquersZZ()

		def MarquersSections()
			return This.FindMarquersZZ()
		
		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR SECTIONS -- ZZ/Extended   #
	#================================================#

	def MarquersAndSections()

		aResult = Association([ This.Marquers(), This.MarquersSections() ])
		return aResult

		#< @FunctionFluentForm

		def MarquersAndSectionsQ()
			return This.MarquersAndSectionsQRT(:stzList)

		def MarquersAndSectionsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndSections() )

			on :stzHashList
				return new stzHashList( This.MarquersAndSections() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZ()
			return This.MarquersAndSections()

			def MarquersZZQ()
				return This.MarquersAndSectionsQ()

			def MarquersZZQRT(pcReturnType)
				return This.MarquersAndSectionsQRT(pcReturnType)

		def MarquersAndTheirSections()
			return This.MarquersAndSections()

			def MarquersAndTheirSectionsQ()
				return This.MarquersAndSectionsQ()

			def MarquersAndTheirSectionsQRT(pcReturnType)
				return This.MarquersAndSectionsQRT(pcReturnType)

		#>

	  #-------------------------------------------------------#
	 #  UNIQUE MARQUERS AND THEIR SECTIONS -- ZZU/Extended   #
	#=======================================================#

	def UniqueMarquersAndSections()

		aMarquers = This.MarquersAndTheirSections()
		nLen = len(aMarquers)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			cMarquer = aMarquers[i][1]
			aSection = aMarquers[i][2]

			if ring_find(acSeen, cMarquer) = 0

				aResult + [ cMarquer, [ aSection ] ]
				acSeen + cMarquer

			else

				aResult[cMarquer] + aSection
			ok

		next
		
		return aResult

		#< @FunctionFluentForm

		def UniqueMarquersAndSectionsQ()
			return new stzList(This.UniqueMarquersAndSections())

		def UniqueMarquersAndSectionsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndSections() )

			on :stzList
				return new stzList( This.UniqueMarquersAndSections() )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersUZZ()
			return This.UniqueMarquersAndSections()

			def MarquersZZUQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersZZUQRT(pcReturnType)
				return This.UniqueMarquersAndSectionsQRT(pcReturnType)

		def UniqueMarquersAndTheirSections()
			return This.UniqueMarquersAndSections()

			def UniqueMarquersAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def UniqueMarquersandTheirSectionsQRT(pcReturnType)
				return This.UniqueMarquersAndSectionsQRT(pcReturnType)

		def MarquersUAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersUAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUAndTheirSectionsQRT(pcReturnType)
				return This.UniqueMarquersAndSectionsQRT(pcReturnType)

		def MarquersWithoutDuplicationAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationAndTheirSectionsQRT(pcReturnType)
				return This.UniqueMarquersAndSectionsQRT(pcReturnType)

		def MarquersWithoutDuplicationZZ()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationZZQRT(pcReturnType)
				return This.UniqueMarquersAndSectionsQRT(pcReturnType)

		#>
	
	  #-----------------------------------------#
	 #    SORTING MARQUERS INSIDE THE STRING   #
	#=========================================#

	def MarquersAreSorted()
		bResult = StzListQ(This.Marquers()).ItemsAreSorted()
		return bResult

	def MarquersSortingOrder()
		bResult = StzListQ(This.Marquers()).SortingOrder()
		return bResult

	def MarquersAreUnsorted()
		bResult = StzListQ(This.Marquers()).ItemsAreUnsorted()
		return bResult

		def MarquersAreNotSorted()
			return This.MarquersAreUnsorted()

	def MarquersAreSortedInAscending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInAscending()
		return bResult

	def MarquersAreSortedInDescending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInDescending()
		return bResult

	#--

	def MarquersSortedInAscending()
		aResult = StzListQ(This.Marquers()).SortedInAscending()
		return aResult

		def MarquersSorted()
			return This.MarquersSortedInAscending()
	
	def UniqueMarquersSortedInAscending()
		aResult = StzListQ(This.UniqueMarquers()).SortedInAscending()
		return aResult

		def UniqueMarquersSorted()
			return This.UniqueMarquersSortedInAscending()

		def MarquersSortedInAscendingU()
			return This.UniqueMarquersSortedInAscending()

		def UniqueMarquersSortedU()
			return This.UniqueMarquersSortedInAscending()

	#--

	def MarquersSortedInDescending()
		aResult = StzListQ(This.Marquers()).SortedInDescending()
		return aResult

	def UniqueMarquersSortedInDescending()
		aResult = StzListQ(This.UniqueMarquers()).SortedInDescending()
		return aResult

		def MarquersSortedInDescendingU()
			return This.UniqueMarquersSortedInDescending()

	#--

	def MarquersPositionsSortedInAscending()
		aResult = StzListQ(This.MarquersPositions()).SortedInAscending()
		return aResult

		def MarquersPositionsSorted()
			return This.MarquersPositionsSortedInAscending()

	#--

	def MarquersPositionsSortedInDescending()
		aResult = StzListQ(This.MarquersPositions()).SortedInDescending()
		return aResult

	#--

	def MarquersAndPositionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		anPos = This.MarquersPositionsSortedInAscending()

		aResult = Association([ acMarquers, anPos ])

		return aResult

		def MarquersSortedInAscendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedInAscending()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersSortedZ()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingZ()
			return This.MarquersAndPositionsSortedInAscending()

	def UniqueMarquersAndPositionsSortedInAscending()

		aUniqueMarquers = This.UniqueMarquersSortedInAscending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAll(aUniqueMarquers[i]) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInAscendingAndTheirPositions()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersAndTheirPositionsSortedInAscending()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersSortedZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersSortedInAscendingZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		#--

		def MarquersAndPositionsSortedInAscendingU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingAndTheirPositionsU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedInAscendingU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedUZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingUZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		#>

	#--

	def MarquersAndPositionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		anPos = This.MarquersPositionsSortedInDescending()

		aResult = StzPairOfListsQ( acMarquers, anPos ).Associate()

		return aResult

		def MarquersSortedInDescendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedInDescending()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingZ()
			return This.MarquersAndPositionsSortedInDescending()

	def UniqueMarquersAndPositionsSortedInDescending()

		aUniqueMarquers = This.UniqueMarquersSortedInDescending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAll(aUniqueMarquers[i]) ]
		next

		return aResult


		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInDescendingAndTheirPositions()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def UniqueMarquersAndTheirPositionsSortedInDescending()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def UniqueMarquersSortedInDescendingZ()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		#--

		def MarquersAndPositionsSortedInDescendingU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingAndTheirPositionsU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedOInDescendingU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingUZ()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		#>

	#--

	def MarquersAndSectionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		nLen = len(acMarquers)

		anPos = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLen
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPos[i]
			n2 = n1 + nLenMarquer - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def MarquersSortedInAscendingAndTheirSections()
			return This.MarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingZZ()
			return This.MarquersAndSectionsSortedInAscending()

		def MarquersSortedZZ()
			return This.MarquersAndSectionsSortedInAscending()

		#>

	def UniqueMarquersAndSectionsSortedInAscending()

		aUniqueMarquers = This.UniqueMarquersSortedInAscending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAsSections(aUniqueMarquers[i]) ]
		next

		return aResult


		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInAscendingAndTheirSections()
			return This.UniqueMarquersAndSecionsSortedInAscending()

		def UniqueMarquersAndTheirSectionsSortedInAscending()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def UniqueMarquersSortedInAscendingZZ()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		#--

		def MarquersAndSectionsSortedInAscendingU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingAndTheirSectionsU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersAndTheirSectionsSortedOInAscendingU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingUZZ()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedUZZ()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		#>

	#--

	def MarquersAndSectionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		nLenMarquers = len(acMarquers)

		anPos = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLenMarquers
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPos[i]
			n2 = n1 + nLenMarquers - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def MarquersSortedInDescendingAndTheirSections()
			return This.MarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingZZ()
			return This.MarquersAndSectionsSortedInDescending()

		#>

	def UniqueMarquersAndSectionsSortedInDescending()

		aUniqueMarquers = This.UniqueMarquersSortedInDescending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAsSections(aUniqueMarquers[i]) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInDescendingAndTheirSections()
			return This.UniqueMarquersAndSecionsSortedInDescending()

		def UniqueMarquersAndTheirSectionsSortedInDescending()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def UniqueMarquersSortedInDescendingZZ()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		#--

		def MarquersAndSectionsSortedInDescendingU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingAndTheirSectionsU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersAndTheirSectionsSortedOInDescendingU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingUZZ()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		#>

	#--

	def SortMarquersInAscending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInAscending()
			? Content()
		}

		# !--> My name is #1, may age is #2, and my job is #3.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		/* Reminder
		#--> [ "#1" = [12, 13], "#1" = [26, 27], "#2" = [44, 45], "#3" = [66, 67] ]
		*/

		_oCopy_ = This.Copy()

		for i = len(aMarquersSections) to 1 step -1
			cMarquer = aMarquersSections[i][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			_oCopy_.ReplaceSection(n1, n2, cMarquer)
		next

		This.UpdateWith(_oCopy_.Content())


		def SortMarquersInAscendingQ()
			This.SortMarquersInAscending()
			return This

		def SortMarquers()
			This.SortMarquersInAscending()

			def SortMarquersQ()
				This.SortMarquers()
				return This

		def SortMarquersUp()
			This.SortMarquersInAscending()

			def SortMarquersUpQ()
				This.SortMarquers()
				return This

	def StringWithMaquersSortedInAscending()
		cResult = This.Copy().SortMarquersInAscendingQ().Content()
		return cResult

		def StringWithMarquersSorted()
			return This.StringWithMaquersSortedInAscending()

		def StringWithMarquersSortedUp()
			return This.StringWithMaquersSortedInAscending()

	def SortMarquersInDescending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInDescending()
			? Content()
		}

		# !--> My name is #3, may age is #2, and my job is #1.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersSections)

		/* Reminder
		Q("My name is #2, may age is #1, and my job is #3.") {
			? MarquersAndSections()
		}

		#--> [ "#1" = [12, 13], "#2" = [27, 28], "#3" = [45, 46]  ]
		*/

		_oCopy_ = This.Copy()

		for i = nLen to 1 step - 1
			cMarquer = aMarquersSections[nLen - i + 1][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			_oCopy_.ReplaceSection(n1, n2, cMarquer)
		next

		This.UpdateWith(_oCopy_.Content())


		def SortMarquersInDescendingQ()
			This.SortMarquersInDescending()
			return This

		def SortDownMarquers()
			This.SortMarquersInDescending()
	
			def SortDownMarquersQ()
				This.SortDownMarquers()
				return This

	def StringWithMaquersSortedInDescending()
		cResult = This.Copy().SortMarquersInDescendingQ().Content()
		return cResult

		def StringWithMaquersSortedDown()
			return This.StringWithMaquersSortedInDescending()

	  #--------------------------------------------#
	 #  REPLACING MARQUERS WITH GIVEN SUBSTRINGS  #
	#============================================#

	def ReplaceMarquers(pacSubStr)
		if CheckingParams()
			if isList(pacSubStr) and StzListQ(pacSubStr).IsWithOrByNamedParam()
				pacSubStr = pacSubStr[2]
			ok
		ok

		aMarquersXT = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersXT)

		nMin = Min([ len(pacSubStr), nLen ])
		_oCopy_ = This.Copy()

		for i = nLen to 1 step -1
			
			cMarquer = aMarquersXT[i][1]

			_oCopy_.ReplaceAll(cMarquer, pacSubStr[i])
		next

		This.UpdateWith(_oCopy_.Content())


		def ReplaceMarquersQ(pacSubStr)
			This.ReplaceMarquers(pacSubStr)
			return This

	def MarquersReplaced(pacSubStr)
		return This.Copy().ReplaceMarquersQ(pacSubStr).Content()

		#< @FunctionMisspelledForm

		def MarquersRepalced(pacSubStr)
			return This.MarquersReplaced(pacSubStr)

		#>

	  #------------------------------------------#
	 #    REPLACING SUBSTRINGS WITH MARQUERS    #
	#==========================================#

	def ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

		acSubStr = StzListQ(pacSubStr).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(acSubStr)

		acMarquers = []

		cMarquer = This.Marquer()
		for i = 1 to nLen
			acMarquers + ( cMarquer + i )
		next

		This.ReplaceManyByManyCS(acSubStr, acMarquers, pCaseSensitive)

		def ReplaceSubstringsWithMarquersCSQ(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)
			return This

		def MarkTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

			def MarkTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.MarkTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def MarkSubStringsCS(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

			def MarkSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.MarkSubStringsCS(pacSubStr, pCaseSensitive)
				return This

	def SubstringsReplacedWithMarquersCS(pacSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubstringsWithMarquersCSQ(pacSubStr, pCaseSensitive).Content()
		return cResult

		def SubstringsMarquedCS(pacSubStr, pCaseSensitive)
			return This.SubstringsReplacedWithMarquersCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubstringsWithMarquers(pacSubStr)
		This.ReplaceSubstringsWithMarquersCS(pacSubStr, 1)

		def MarkTheseSubStrings(pacSubStr)
			This.ReplaceSubstringsWithMarquers(pacSubStr)

			def MarkTheseSubStringsQ(pacSubStr)
				This.MarkTheseSubStrings(pacSubStr)
				return This

		def MarkSubStrings(pacSubStr)
			This.ReplaceSubstringsWithMarquers(pacSubStr)

			def MarkSubStringsQ(pacSubStr)
				This.MarkSubStrings(pacSubStr)
				return This

	def SubstringsReplacedWithMarquers(pacSubStr)
		return This.SubstringsReplacedWithMarquersCS(pacSubStr, 1)

		def SubstringsMarqued(pacSubStr)
			return This.SubstringsReplacedWithMarquers(pacSubStr)

	  #------------------------#
	 #    PARSING MARQUERS    #
	#========================#

	#TODO : Add these functions	
	# 	NthMarquerZ(n)
	# 	NthMarquerZZ(n)
	
	# 	NextNthMarquerZZ(n, nStart)
	# 	PreviousNthMarquerZZ(n, nStart)

	def NthMarquer(n)
		if CheckingParams()
			if NOT isNumber(n)
				stzRaise("Incorrect param type! n should be a number.")
			ok
		ok

		try
			return This.Marquers()[n]
		catch
			return ""
		done

		def NthMarquerQ(n)
			return new stzString( This.NthMarquer(n) )

	def FirstMarquer()
		return This.NthMarquer(1)

		def FirstMarquerQ()
			return new stzString( This.LastMarquer() )

		#-- MISSPELLED

		def FristMarquer()
			return This.FirstMarquer()

			return This.FristMArquerQ()
				return This.FirstMarquerQ()

	def LastMarquer()
		n = This.NumberOfMarquers()
		acResult = This.Marquers()[ n ]
		return acResult

		def LastMarquerQ()
			return new stzString( This.LastMarquer() )

	  #------------------------------#
	 #    FINDING THE NTH MARQUER   #
	#==============================#

	def FindNthMarquer(n)
		if CheckingParams()
			if isString(n)
				if n = :First or n = :FirstMarquer
					n = 1
				but n = :Last or n = :LastMarquer
					n = This.NumberOfMarquers()
				ok
			ok
		ok

		return This.FindNthOccurrence( n, This.Marquer() )

		def NthMarquerOccurrence(n)
			return This.FindNthMarquer(n)

		def NthMarquerPosition(n)
			return This.FindNthMarquer(n)

		def PositionOfNthMarquer(n)
			return This.FindNthMarquer(n)

	def FindFirstMarquer()
		return This.FindNthMarquer(1)

		#< @FunctionAlternativeForms

		def FirstMarquerOccurrence()
			return This.FindFirstMarquer()

		def FirstMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFirstMarquer()
			return This.FindFirstMarquer()

		#>

		#< @FunctionMisspelledForms

		def FindFristMarquer()
			return This.FindFirstMarquer()

		def FristMarquerOccurrence()
			return This.FindFirstMarquer()

		def FristMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFristMarquer()
			return This.FindFirstMarquer()

		#>

	def FindLastMarquer()
		return This.FindNthMarquer(This.NumberOfMarquers())

		def LastMarquerOccurrence()
			return This.FindLastMarquer()

		def LastMarquerPosition()
			return This.FindLastMarquer()

		def PositionOfLastMarquer()
			return This.FindLastMarquer()


	  #--------------------------------------------------#
	 #    NEXT MARQUERS STARTING AT A GIVEN POSITION    #
	#==================================================#

	def NextMarquers(pnStartingAt)
		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		nLen =  This.NumberOfChars()
		acResult = This.SectionQ(pnStartingAt, nLen).Marquers()
		return acResult

		#< @FunctionFluentForms

		def NextMarquersQ(pnStartingAt)
			return This.NextMarquersQRT(pnstartingAt, :stzList)

		def NextMarquersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NextMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.NextMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextMarquersST(pnStartingAt)
			return This.NextMarquers(pnStartingAt)

			def NextMarquersSTQ(pnStartingAt)
				return This.NextMarquersQ(pnStartingAt)

			def NextMarquersSTQRT(pnStartingAt, pcReturnType)
				return This.NextMarquersQRT(pnStartingAt, pcReturnType)

		#>

	  #--------------------------------------#
	 #    RETURNING THE NTH NEXT MARQUER    #
	#======================================#

	def NthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> #3
		*/

		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		nLen = This.NumberOfChars()
		oStr = This.SectionQ(pnStartingAt, nLen)
		cResult = oStr.Marquers()[ n ]
		return cResult

		#< @FunctionFluentForm

		def NthNextMarquerQ(n, pnStartingAt)
			return new stzString( This.NthNextMarquer(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def NextNthMarquer(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		#--

		def NthNextMarquerST(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NthNextMarquerSTQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		def NextNthMarquerST(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerSTQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		#>

	  #------------------------------------#
	 #    FINDING THE NTH NEXT MARQUER    #
	#====================================#

	def FindNthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> 44
		*/

		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT (isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok

		ok

		nLen = This.NumberOfChars()
		oStr = This.SectionQ(pnStartingAt, nLen)

		nPos = oStr.MarquersPositions()[ n ] + pnStartingAt - 1
		
		return nPos

		#< @FunctionAlternativeForms

		def FindNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		#--

		def FindNthNextMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def FindNextNthMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrenceS(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPositionST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPositionST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------#
	 #    NTH NEXT MARQUER, ALONG WITH ITS POSITION    #
	#=================================================#

	def NthNextMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthNextMarquer(n, pnStartingAt)
		nPosition = This.FindNthNextMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthNextMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthNextMarquerAndItsPositionQRT(n, pnStartingAt,  :stzList)

		def NthNextMarquerAndItsPositionQRT(n, pnStartingAt,  pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQ(n, pnStartingAt)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQRT(n, pnStartingAt, pcReturnType)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

		def NextNthMarque(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#--

		def NthNextMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

		def NextNthMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

		def NextNthMarquerSTZ(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    FINDING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def FindNextMarquer(pnStartingAt)
		return This.FindNthNextMarquer(1, pnStartingAt)

		#< @FunctionAlternativeForms

		def NextMarquerPosition(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquer(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrence(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		#--

		def FindNextMarquerST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerPositionST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquerST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrenceST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    GETTING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def NextMarquer(pnStartingAt)
		return This.NthNextMarquer(1, pnStartingAt)

		#< @FunctionFluentForm

		def NextMarquerQ(pnStartingAt)
			return new stzString( This.NextMarquer(pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def NextMarquerST(pnStartingAt)
			return This.NextMarquer(pnStartingAt)

			def NextMarquerSTQ(pnStartingAt)
				return new stzString( This.NextMarquer_S(pnStartingAt) )

		#>

	  #--------------------------------------------------------------------------#
	 #    GETTING NEXT MARQUER AND ITS POSITION STARTING AT A GIVEN POSITION    #
	#==========================================================================#

	def NextMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.NextMarquer(pnStartingAt)
		nPosition = This.NextMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def NextMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.NextMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def NextMarquerAndItsOccurrence(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

			def NextMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.NextMarquerAndItsOccurrence(pnStartingAt) )

		def NextMarquerZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		#--

		def NextMarquerAndItsOccurrenceST(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		def NextMarquerSTZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		#>

	  #---------------------------------#
	 #    GETTING PREVIOUS MARQUERS    #
	#=================================#

	def PreviousMarquers(pnStartingAt)
		if CheckingParams()
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0 )
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		acResult = This.SectionQ(1, pnStartingAt).Marquers()
		return acResult

		#< @FunctionFluentForms

		def PreviousMarquersQ(pnStartingAt)
			return This.PreviousMarquersQRT(pnstartingAt, :stzList)

		def PreviousMarquersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquersST(pnStartingAt)
			return This.PreviousMarquers(pnStartingAt)

			def PreviousMarquersSTQ()
				return This.PreviousMarquersQ()

			def PreviousMarquersSTQRT(pnStartingAt, pcReturnType)
				return This.PreviousMarquersQRT(pnstartingAt, pcReturnType)

		#>

	  #------------------------------------#
	 #    GETTING NTH PREVIOUS MARQUER    #
	#====================================#

	def NthPreviousMarquer(n, pnStartingAt)
		nPos = This.FindNthPreviousMarquer(n, pnStartingAt)

		return This.MarquerByPosition(nPos)
		
		#< @FunctionFluentForm

		def NthPreviousMarquerQ(n, pnStartingAt)
			return new stzString( This.NthPreviousMarquer(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousNthMarquer(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

			def PreviousNthMarquerQ(n, pnStartingAt)
				return new stzString( This.PreviousNthMarquer(n, pnStartingAt) )

		#--

		def NthPreviousMarquerST(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerST(n, pnStartingAt)
			return This.PreviousNthMarquer(n, pnStartingAt)

		#>

	  #------------------------------------#
	 #    FINDING NTH PREVIOUS MARQUER    #
	#====================================#

	def FindNthPreviousMarquer(n, pnStartingAt)
		if CheckingParams()
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		oStr = This.SectionQ(1,  pnStartingAt)

		anPos = oStr.MarquersPositions()
		nLenPos = len(anPos)

		nResult = 0

		n = nLenPos - n + 1
		if n >= 1 and n <= nLenPos
			nResult = anPos[n]
		ok

		return nResult
		
		#< @FunctionAlternativeForm

		def FindPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#--

		def FindNthPreviousMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def FindPreviousNthMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPositionST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPositionST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING NTH PREVIOUS MARQUER  ALONG WITH ITS POSITION -- Z/Extended   #
	#=========================================================================#

	def NthPreviousMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthPreviousMarquer(n, pnStartingAt)
		nPosition = This.FindNthPreviousMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthPreviousMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPositionQRT(n, pnStartingAt, pcReturnType)

		def NthPreviousMarquerAndItsPositionQRT(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def PreviousNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		#--

		def NthPreviousMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerSTZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerSTZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #------------------------------#
	 #   FINDING PREVIOUS MARQUER   #
	#==============================#

	def FindPreviousMarquer(pnStartingAt)
		return This.FindNthPreviousMarquer(1, pnStartingAt)

		#< @FunctionAlternativeForms

		def PreviousMarquerPosition(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquer(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrence(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		#--

		def FindPreviousMarquerST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerPositionST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquerST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrenceST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		#>

	  #------------------------------#
	 #   GETTING PREVIOUS MARQUER   #
	#==============================#

	def PreviousMarquer(pnStartingAt)
		return This.NthPreviousMarquer(1, pnStartingAt)

		#< @FunctionFluentForm

		def PreviousMarquerQ(pnStartingAt)
			return new stzString( This.PreviousMarquer(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerST(pnStartingAt)
			return This.PreviousMarquer(pnStartingAt)

		#>

	  #--------------------------------------------------------------------#
	 #   FINDING PREVIOUS MARQUER ALONG WITH ITS POSITION -- Z/Extension  #
	#====================================================================#

	def PreviousMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.PreviousMarquer(pnStartingAt)
		nPosition = This.PreviousMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def PreviousMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.PreviousMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerAndItsOccurrence(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.PreviousMarquerAndItsOccurrence(pnStartingAt) )

		def PreviousMarquerZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		#--

		def PreviousMarquerAndItsPositionST(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		def PreviousMarquerAndItsOccurrenceST(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		def PreviousMarquerSTZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		#>

	  #===========================================================#
	 #   CHECKING IF THE STRING CONTAINS DUPLICATED SUBSTRINGS   #
	#===========================================================#

	def ContainsDuplicatedSubStringsCS(pCaseSensitive)

		if This.NumberOfDuplicatesCS(pCaseSensitive) > 0
			return 1
		else
			return 0
		ok

		def ContainsDuplicatesCS(pCaseSensitive)
			return This.ContainsDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedSubStrings()
		return This.ContainsDuplicatedSubStringsCS(1)
	
		def ContainsDuplicates()
			return This.ContainsDuplicatedSubStrings()

	  #----------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED IN THE STRING   #
	#----------------------------------------------------------------#

	def ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		return bResult

		def ContainsDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicated(pcSubStr)
		return This.ContainsDuplicatedCS(pcSubStr, 1)

		def ContainsDuplicatedSubString(pcSubStr)
			return This.ContainsDuplicated(pcSubStr)

	  #-----------------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED N-TIMES IN THE STRING  #
	#-----------------------------------------------------------------------#

	def ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive) = n
			return 1
		else
			return 0
		ok

		def SubStringIsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedNTimes(n, pcSubStr)
		return This.ContainsDuplicatedNTimesCS(n, pcSubStr, 1)

		def SubStringIsDuplicatedNTimes(n, pcSubStr)
			return This.ContainsDuplicatedNTimes(n, pcSubStr, pItem)

	  #-----------------------------------------------------------------------#
	 #   HOW MANY TIMES A GIVEN SUBSTRING IS DUPLICATED INSIDE THE STRING?   #
	#-----------------------------------------------------------------------#

	def NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		nResult =  This.SubStringsCSQ(pCaseSensitive).
				NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfTimesSubStringIsDuplicated(pcSubStr)
		return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicated(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#--

		def NumberOfDuplicatesOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOf(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING THE EXISTENCE OF NON DUPLICATED SUBSTRINGS IN THE STRING  #
	#=====================================================================#

	def ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

		bResult = This.SubStringsCSQ(pCaseSensitive).
			       ContainsNonDuplicatedItemsCS(pCaseSensitive)

		return bResult

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedsubStrings()
		return This.ContainsNonDuplicatedSubStringsCS(1)

		def ContainsNoDuplications()
			return This.ContainsNonDuplicatedSubStrings()

	  #-------------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsCS(pCaseSensitive)
		acResult = This.Copy().RemoveDuplicatedSubStringsCSQ(pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedISubStrings()
		return This.NonDuplicatedSubStringsCS(1)

	  #---------------------------------------#
	 #  NUMBER OF NON DUPLICATED SUBSTRINGS  #
	#---------------------------------------#

	def NumberOfNonDuplicatedSubStringsCS(pCaseSensitive)
		nResult = This.SubStringsCSQ(pCaseSensitive).NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedSubStrings()
		return This.NumberOfNonDuplicatedSubStringsCS(1)

	  #-------------------------------------#
	 #  FINDING NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------#

	def FindNonDuplicatedSubStringsCS(pCaseSensitive)
		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)
		anResult = []

		for i = 1 to nLen
			# By defintion, a non duplicated substring apprears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			anResult + nPos
		next

		anResult = Q(anResult).Sorted()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedSubStrings()
		return This.FindNonDuplicatedSubStringsCS(1)

	  #-------------------------------------------------#
	 #  NON DUPLICATED SUBSTRINGS AND THEIR POSITIONS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated substrings appears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			aResult + [ acNonDuplicated[i], nPos ]
		next

		return aResult

		def NonDuplicatedSubstringsCSZ(pCaseSensitive)
			return This.NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedSubStringsAndTheirPositions()
		return This.NonDuplicatedSubStringsAndTheirPositionsCS(1)

		def NonDuplicatedSubStringsZ()
			return This.NonDuplicatedSubStringsAndTheirPositions()

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)

		nResult = len( This.DuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(1)

		#< @functionAlternativeForms

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		#>

	  #----------------------#
	 #  FINDING DUPLICATES  #
	#----------------------#

	def FindDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesCSXT(pCaseSensitive)
		anResult = Q(anPos).ToSet()
		return anResult

		def FindDuplicatesCSZ(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(1)

		def FindDuplicatesZ()
			return This.FindDuplicates()

	  #----------------------------------#
	 #  FINDING DUPLICATES -- EXTENDED  #
	#----------------------------------#

	# This extended form keeps the positions even if they are duplicated
	#TODO // Illistrate it with an example.

	def FindDuplicatesCSXT(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		anResult = QRT(aSections, :stzListOfPairs).FirstItems()
		return anResult

		def FindDuplicatesCSXTZ(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesCSXT(1)

		def FindDuplicatesXTZ()
			return This.FindDuplicatesXT()

	  #----------------------------------#
	 #  FINDING DUPLICATES AS SECTIONS  #
	#----------------------------------#

	def FindDuplicatesAsSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		nLen = len(acDuplicates)

		aResult = []

		for i = 1 to nLen
			aSections = This.FindAsSectionsCSQ(acDuplicates[i], pCaseSensitive).
					 FirstItemRemoved()

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = QRT(aResult, :stzListOfPairs).Sorted()
		return aResult

		#< @FunctionAlternativeForm

		def FindDuplicatesCSZZ(pCaseSensitive)
			return This.FindDuplicatesAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesAsSections()
		return This.FindDuplicatesAsSectionsCS(1)

		#< @FunctionAlternativeForm

		def FindDuplicatesZZ()
			return This.FindDuplicatesAsSections()

		#>

	  #--------------#
	 #  DUPLICATES  #
	#--------------#

	def DuplicatesCS(pCaseSensitive)
		
		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = This.Section(i, j)

				if Q(acResult).ContainsNoCS(cSubStr, pCaseSensitive) and
				   This.NumberOfOccurrenceCS(cSubStr, 1) > 1

					acResult + cSubStr
				ok

			next
		next
		
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(1)

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR POSITIONS -- Z/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirPositionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesCSXT(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZ(pCaseSensitive)
			return This.DuplicatesAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirPositions()
		return This.DuplicatesAndTheirPositionsCS(1)

		def DuplicatesZ()
			return This.DuplicatesAndTheirPositions()

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR SECTIONS -- ZZ/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZZ(pCaseSensitive)
			return This.DuplicatesAndTheirSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirSections()
		return This.DuplicatesAndTheirSectionsCS(1)

		def DuplicatesZZ()
			return This.DuplicatesAndTheirSections()

	  #---------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		anResult = []
		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			del(anPos, 1)
			anResult = anPos
		ok

		return anResult
		
		#< @FunctionAlternativeForms

		def PositionsOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		def FindThisDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		def FindDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubString(pcSubStr)
		return This.FindDuplicatesOfSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def PositionsOfDuplicatesOfSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

		def FindThisDuplicatedSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

		def FindDuplicatedSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN CHAR   #
	#----------------------------------------#

	def FindDuplicatesOfCharCS(pcChar, pCaseSensitive)
		if NOT (isString(pcChar) and @IsChar(pcChar))
			StzRaise("Incorrect param type! pcChar must be a char.")
		ok

		anResult = This.FindDuplicatesOfSubStringCS(pcChar, pCaseSensitive)
		return anResult
		
		#< @FunctionAlternativeForms

		def PositionsOfDuplicatesOfCharCS(pcChar, pCaseSensitive)
			return This.FindDuplicatesOfCharCS(pcChar, pCaseSensitive)

		def FindThisDuplicatedCharCS(pcChar, pCaseSensitive)
			return This.FindDuplicatesOfCharCS(pcChar, pCaseSensitive)

		def FindDuplicatedCharCS(pcChar, pCaseSensitive)
			return This.FindDuplicatesOfCharCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfChar(pcChar)
		return This.FindDuplicatesOfCharCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def PositionsOfDuplicatesOfChar(pcChar)
			return This.FindDuplicatesOfChar(pcChar)

		def FindThisDuplicatedChar(pcChar)
			return This.FindDuplicatesOfChar(pcChar)

		def FindDuplicatedChar(pcChar)
			return This.FindDuplicatesOfChar(pcChar)

		#>

	  #---------------------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING AS SECTIONS   #
	#---------------------------------------------------------#

	def FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = []
		anPos = This.FindOccurrencesAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			aResult = Q(anPos).FirstItemRemoved()
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindDuplicatesOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindThisDuplicatedSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindDuplicatedSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindThisDuplicatedSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindDuplicatedSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubStringAsSections(pcSubStr)
		return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindDuplicatesOfSubStringZZ(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

		def FindThisDuplicatedSubStringAsSections(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

		def FindDuplicatedSubStringAsSections(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

		def FindThisDuplicatedSubStringZZ(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

		def FindDuplicatedSubStringZZ(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTUVE CHARS IN THE STRING  #
	#======================================================#

	def FindDuplicatedConsecutiveCharsCS(pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindDupSecutiveItemsCS(pCaseSensitive)
		return anResult

		def FindDupSecutiveCharsCS(pCaseSensitive) # ~> DUPSECITIVE = DUPLICATED + CONSECUTIVE
			return This.FindDuplicatedConsecutiveCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveChars()
		return This.FindDuplicatedConsecutiveCharsCS(1)

		def FindDupSecutiveChars()
			return This.FindDuplicatedConsecutiveChars()

	  #---------------------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTUVE CHARS IN THE STRING -- ZZ/EXTENDED  #
	#---------------------------------------------------------------------#

	def FindDuplicatedConsecutiveCharsCSZZ(pCaseSensitive)
		anPos = This.CharsCSQ(pCaseSensitive).FindDupSecutiveItemsCS(pCaseSensitive)
		oLoN = new stzListOfNumbers(anPos)
		aResult = oLoN.ContigToSections()
		return aResult

		#< @FunctionAlternativeForms

		def FindDupSecutiveCharsCSZZ(pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharsCSZZ(pCaseSensitive)

		def FindDuplicatedConsecutiveCharsAsSectionsCS(pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveCharsZZ()
		return This.FindDuplicatedConsecutiveCharsCSZZ(1)

		#< @FunctionAlternativeForms

		def FindDupSecutiveCharsZZ()
			return This.FindDuplicatedConsecutiveCharsZZ()

		def FindDuplicatedConsecutiveCharsAsSections()
			return This.FindDuplicatedConsecutiveCharsZZ()

		#>

	  #--------------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def FindDuplicatedConsecutiveCharCS(c, pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindDupSecutiveItemCS(c, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveCharCS(c, pCaseSecutive)
			return This.FindDuplicatedConsecutiveCharCS(c, pCaseSensitive)

		#--

		def FindDupSecutiveCharCS(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCS(c, pCaseSensitive)

		def FindThisDupSecutiveCharCS(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCS(c, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveChar(c)
		return This.FindDuplicatedConsecutiveCharCS(c, 1)

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveChar(c)
			return This.FindDuplicatedConsecutiveChar(c)

		#--

		def FindDupSecutiveChar(c)
			return This.FindDuplicatedConsecutiveChar(c)

		def FindThisDupSecutiveChar(c)
			return This.FindDuplicatedConsecutiveChar(c)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN CHAR -- ZZ/EXTENDED  #
	#-----------------------------------------------------------------------------#

	def FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)
		anPos = This.CharsCSQ(pCaseSensitive).FindDupSecutiveItemCS(c, pCaseSensitive)
		oLoN = new stzListOfNumbers(anPos)
		aResult = oLoN.ContigToSections()

		return aResult

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveCharCSZZ(c, pCaseSecutive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		#--

		def FindDupSecutiveCharCSZZ(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		def FindThisDupSecutiveCharCSZZ(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		#==

		def FindDuplicatedConsecutiveCharAsSectionsCS(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		def FindThisDuplicatedConsecutiveCharAsSectionsCS(c, pCaseSecutive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		#--

		def FindDupSecutiveCharAsSectionsCS(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		def FindThisDupSecutiveCharAsSectionsCS(c, pCaseSensitive)
			return This.FindDuplicatedConsecutiveCharCSZZ(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveCharZZ(c)
		return This.FindDuplicatedConsecutiveCharCSZZ(c, 1)

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveCharZZ(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		#--

		def FindDupSecutiveCharZZ(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		def FindThisDupSecutiveCharZZ(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		#==

		def FindDuplicatedConsecutiveCharAsSections(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		def FindThisDuplicatedConsecutiveCharAsSections(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		#--

		def FindDupSecutiveCharAsSections(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		def FindThisDupSecutiveCharAsSections(c)
			return This.FindDuplicatedConsecutiveCharZZ(c)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN SUBSTRING  #
	#===================================================================#

	def FindDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringCSZZ(pcSubStr, pCaseSensitive)

		nLen = len(aSections)
		if nLen <= 1
			return []
		ok

		anResult = []

		for i = 2 to nLen
			if aSections[i-1][2] = aSections[i][1] - 1
				anResult + aSections[i][1]
			ok
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSecutive)
			return This.FindDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindDupSecutiveSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSensitive)

		def FindThisDupSecutiveSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveSubString(pcSubStr)
		return This.FindDuplicatedConsecutiveSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveSubString(pcSubStr)
			return This.FindDuplicatedConsecutiveSubString(pcSubStr)

		#--

		def FindDupSecutiveSubString(pcSubStr)
			return This.FindDuplicatedConsecutiveSubString(pcSubStr)

		def FindThisDupSecutiveSubString(pcSubStr)
			return This.FindDuplicatedConsecutiveSubString(pcSubStr)

		#>

	  #----------------------------------------------------------------------------------#
	 #  FINDING DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN SUBSTRING -- ZZ/EXTENDED  #
	#----------------------------------------------------------------------------------#

	def FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringCSZZ(pcSubStr, pCaseSensitive)

		nLen = len(aSections)
		if nLen <= 1
			return []
		ok

		aResult = []

		for i = 2 to nLen
			if aSections[i-1][2] = aSections[i][1] - 1
				aResult + aSections[i]
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSecutive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindDupSecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindThisDupSecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#==

		def FindDuplicatedConsecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindThisDuplicatedConsecutiveSubStringAsSectionsCS(pcSubStr, pCaseSecutive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindDupSecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindThisDupSecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatedConsecutiveSubStringZZ(pcSubStr)
		return This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindThisDuplicatedConsecutiveSubStringZZ(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		#--

		def FindDupSecutiveSubStringZZ(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		def FindThisDupSecutiveSubStringZZ(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		#==

		def FindDuplicatedConsecutiveSubStringAsSections(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		def FindThisDuplicatedConsecutiveSubStringAsSections(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		#--

		def FindDupSecutiveSubStringAsSections(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		def FindThisDupSecutiveSubStringAsSections(pcSubStr)
			return This.FindDuplicatedConsecutiveSubStringZZ(pcSubStr)

		#>

	  #---------------------------------------------------------------------------------#
	 #  DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN SUBSTRING ALONG THEIR POSITIONS  #
	#---------------------------------------------------------------------------------#

	def DuplicatedConsecutiveSubStringCSZ(pcSubStr, pCaseSensitive)

		anPos = This.FindDuplicatedConsecutiveSubStringCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ThisDuplicatedConsecutiveSubStringCSZ(pcSubStr, pCaseSecutive)
			return This.DuplicatedConsecutiveSubStringCSZ(pcSubStr, pCaseSensitive)

		#--

		def DupSecutiveSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZ(pcSubStr, pCaseSensitive)

		def ThisDupSecutiveSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatedConsecutiveSubStringZ(pcSubStr)
		return This.DuplicatedConsecutiveSubStringCSZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def ThisDuplicatedConsecutiveSubStringZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZ(pcSubStr)

		#--

		def DupSecutiveSubStringZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZ(pcSubStr)

		def ThisDupSecutiveSubStringZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZ(pcSubStr)

		#>

	  #---------------------------------------------------------------------------------#
	 #  DUPLICAtED CONSECUTIVE OCCURRENCES OF A GIVEN SUBSTRING ALONG THEIR POSITIONS  #
	#---------------------------------------------------------------------------------#

	def DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		aSections = This.FindDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSections ]

		return aResult

		#< @FunctionAlternativeForms

		def ThisDuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSecutive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def DupSecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def ThisDupSecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#==

		def DuplicatedConsecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def ThisDuplicatedConsecutiveSubStringAsSectionsCS(pcSubStr, pCaseSecutive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def DupSecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		def ThisDupSecutiveSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatedConsecutiveSubStringZZ(pcSubStr)
		return This.DuplicatedConsecutiveSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def ThisDuplicatedConsecutiveSubStringZZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		#--

		def DupSecutiveSubStringZZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		def ThisDupSecutiveSubStringZZ(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		#==

		def DuplicatedConsecutiveSubStringAsSections(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		def ThisDuplicatedConsecutiveSubStringAsSections(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		#--

		def DupSecutiveSubStringAsSections(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		def ThisDupSecutiveSubStringAsSections(pcSubStr)
			return This.DuplicatedConsecutiveSubStringZZ(pcSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING THE POSITIONS OF DUPLICATED CONSECUTIVE SUBSTRINGS IN THE STRING  #
	#============================================================================#

	def FindDupSecutiveSubStringsCS(pCaseSensitive)

		acSubStr = This.ConsecutiveSubStringsQ().DupSecutiveItemsCS(pCaseSensitive)
		nlen = len(acSubStr)


		anResult = []

		for i = 1 to nLen
			aSections = This.FindCSZZ(acSubStr[i], pCaseSensitive)
			nLenTemp = len(aSections)

			for j = 2 to nLenTemp
				if aSections[j-1][2] = aSections[j][1] - 1
					anResult + aSections[j][1]
				ok
			next

		next

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDupSecutiveSubStrings()
		return This.FindDupSecutiveSubStringsCS(1)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE SECTIONS OF DUPLICATED CONSECUTIVE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindDupSecutiveSubStringsCSZZ(pCaseSensitive)

		acSubStr = This.ConsecutiveSubStringsQ().DupSecutiveItemsCS(pCaseSensitive)
		nlen = len(acSubStr)


		anResult = []

		for i = 1 to nLen
			aSections = This.FindCSZZ(acSubStr[i], pCaseSensitive)
			nLenTemp = len(aSections)

			for j = 2 to nLenTemp
				if aSections[j-1][2] = aSections[j][1] - 1
					anResult + aSections[j]
				ok
			next

		next

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDupSecutiveSubStringsZZ()
		return This.FindDupSecutiveSubStringsCSZZ(1)

	  #---------------------------------------------------------------#
	 #  GETTING THE DUPLICATED CONSECUTIVE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------------------------#

	def DupSecutiveSubStringsCS(pCaseSensitive)

		acResult = This.ConsecutiveSubStringsQ().DupSecutiveItemsCS(pCaseSensitive)
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveSubStrings()
		return This.DupSecutiveSubStringsCS(1)

	  #----------------------------------------------------------------------------#
	 #  GETTING THE DUPLICATED CONSECUTIVE SUBSTRINGS ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------------#

	def DupSecutiveSubStringsCSZ(pCaseSensitive)

		acSubStr = This.ConsecutiveSubStringsQ().DupSecutiveItemsCS(pCaseSensitive)
		nlen = len(acSubStr)


		aResult = []

		for i = 1 to nLen

			aPart = [ acSubStr[i], [] ]

			aSections = This.FindCSZZ(acSubStr[i], pCaseSensitive)
			nLenTemp = len(aSections)

			for j = 2 to nLenTemp
				if aSections[j-1][2] = aSections[j][1] - 1
					aPart[2] + aSections[j][1]
				ok
			next

			aResult + aPart

		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveSubStringsZ()
		return This.DupSecutiveSubStringsCSZ(1)

	  #---------------------------------------------------------------------------#
	 #  GETTING THE DUPLICATED CONSECUTIVE SUBSTRINGS ALONG WITH THEIR SECTIONS  #
	#---------------------------------------------------------------------------#

	def DupSecutiveSubStringsCSZZ(pCaseSensitive)

		acSubStr = This.ConsecutiveSubStringsQ().DupSecutiveItemsCS(pCaseSensitive)
		nlen = len(acSubStr)


		aResult = []

		for i = 1 to nLen

			aPart = [ acSubStr[i], [] ]

			aSections = This.FindCSZZ(acSubStr[i], pCaseSensitive)
			nLenTemp = len(aSections)

			for j = 2 to nLenTemp
				if aSections[j-1][2] = aSections[j][1] - 1
					aPart[2] + aSections[j]
				ok
			next

			aResult + aPart

		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveSubStringsZZ()
		return This.DupSecutiveSubStringsCSZZ(1)

	  #--------------------------------------------------------------#
	 #  REMOVING DUPLICATED CONSECUTIVE SUBSTRINGS FROM THE STRING  #
	#==============================================================#

	def RemoveDupSecutiveSubStringsCS(pCaseSensitive)
		aSections = This.FindDupSecutiveSubStringsCSZZ(pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveDupSecutiveSubStringsCSQ(pCaseSensitive)
			This.RemoveDupSecutiveSubStringsCS(pCaseSensitive)
			return This

	def DupSecutiveSubStringsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDupSecutiveSubStringsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveDupSecutiveSubStrings()
		return This.RemoveDupSecutiveSubStringsCS(1)

		def RemoveDupSecutiveSubStringsQ()
			return This.RemoveDupSecutiveSubStringsCSQ(1)

	def DupSecutiveSubStringRemoved()
		return This. DupSecutiveSubStringsRemovedCS(1)

	  #-----------------------------------------------------------#
	 #  GETTING THE LIST OF CONSESECUTIVE SUBSTRINGS OF N CHARS  #
	#===========================================================#

	def ConsecutiveSubStringsOfNChars(n)

		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		acResult = []
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					acResult + QStringObject().mid(j-1, n)
				ok
			next
		
		next
		
		return acResult

		#< @FunctionFluentForm

		def ConsecutiveSubStringsOfNCharsQ(n)
			return new stzList(This.ConsecutiveSubStringsOfNChars(n))

		def ConsecutiveSubStringsOfNCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ConsecutiveSubStringsOfNChars(n))

			on :stzListOfStrings
				return new stzListOfStrings(This.ConsecutiveSubStringsOfNChars(n))

			on :stzListOfChars
				return new stzListOfChars(This.ConsecutiveSubStringsOfNChars(n))
			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def AdjuscentSubStringsOfNChars(n)
			return This.ConsecutiveSubStringsOfNChars(n)

			def AdjuscentSubStringsOfNCharsQ(n)
				return This. ConsecutiveSubStringsOfNCharsQ(n)

			def AdjuscentSubStringsOfNCharsQRT(n, pcReturnType)
				return Thus.ConsecutiveSubStringsOfNCharsQRT(n, pcReturnType)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CONSECUTIVE SUBSTRINGS OF N CHARS IN THE STRING  #
	#-------------------------------------------------------------------------#

	def NumberOfConsecutiveSubStringsOfNChars(n)
		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		nResult = 0
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					nResult++
				ok
			next
		
		next
		
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfAdjacentSubStringsOfNChars(n)
			return This.NumberOfConsecutiveSubStringsOfNChars(n)

		def HowManyConsecutiveSubStringsOfNChars(n)
			return This.NumberOfConsecutiveSubStringsOfNChars(n)

		def HowManyAdjacentSubStringsOfNChars(n)
			return This.NumberOfConsecutiveSubStringsOfNChars(n)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING THE PositioNS OF CONSECUTIVE SUBSTRINGS OF N CHARS -- XT  #
	#--------------------------------------------------------------------#

	def FindConsecutiveSubStringsOfNChars(n)
		anResult = U( This.FindConsecutiveSubStringsOfNCharsXT(n) )
		return anResult

		def FindAdjacentConsecutiveSubStringsOfNChars(n)
			return This.FindConsecutiveSubStringsOfNChars(n)

	#--

	def FindConsecutiveSubStringsOfNCharsXT(n)
		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		anResult = []
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					anResult + i
				ok
			next
		
		next
		
		return anResult

		#< @FunctionAlternativeForms

		def FindAdjacentSubStringsOfNCharsXT(n)
			return This.FindConsecutiveSubStringsOfNChars(n)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING THE PositioNS OF CONSECUTIVE SUBSTRINGS OF N CHARS -- ZZ  #
	#--------------------------------------------------------------------#

	def FindConsecutiveSubStringsOfNCharsZZ(n)

		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		aResult = []
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					aResult + [ j, j+n-1 ]
				ok
			next
		
		next
		
		return aResult

		#< @FunctionAlternativeForms

		def FindAdjacentSubStringsOfNCharsZZ(n)
			return This.FindConsecutiveSubStringsOfNCharsZZ(n)

		#>

	  #----------------------------------------------------------------------------#
	 #  GETTING THE CONSECUTIVE SUBSTRINGS of N CHARS ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------------#

	def ConsecutiveSubStringsOfNCharsZ(n)
		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		aResult = []
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					aResult + [ QStringObject().mid(j-1, n), j ]
				ok
			next
		
		next
		
		return aResult

		#< @FunctionAlternativeForms

		def AdjacentSubStringsOfNCharsZ(n)
			return This.ConsecutiveSubStringsOfNCharsZ(n)

		#>

	  #---------------------------------------------------------------------------#
	 #  GETTING THE CONSECUTIVE SUBSTRINGS of N CHARS ALONG WITH THEIR SECTIONS  #
	#---------------------------------------------------------------------------#

	def ConsecutiveSubStringsOfNCharsZZ(n)
		# Checking the n param

		if CheckingParams()
			if not isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early checks

		nLen = This.NumberOfChars()

		if EarlyCheck()
			if n <= 0 or n > nLen
				return []
			ok
		ok

		# Doing the job
		    
		aResult = []
		
		for i = 1 to n
		
			for j = i to nLen step n
				if j + n - 1 <= nLen
					aResult + [ QStringObject().mid(j-1, n), [ j, j+n-1 ] ]
				ok
			next
		
		next
		
		return aResult

		#< @FunctionAlternativeForms

		def AdjacentSubStringsOfNCharsZZ(n)
			return This.ConsecutiveSubStringsOfNCharsZZ(n)

		#>

	  #------------------------------------------------------------#
	 #  GETTING THE LIST OF CONSECUTIVE SUBSTRINGS IN THE STRING  #
	#============================================================#

	def ConsecutiveSubStrings()
		nLen = This.NumberOfChars()
		if nLen <= 1
			return []
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		acResult = []

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				acResult + acTemp[j]
			next
		next

		return acResult

		#< @FunctionFluentForms

		def ConsecutiveSubStringsQ()
			return new stzList(This.ConsecutiveSubStrings())

		def ConsecutiveSubStringsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				new stzList( This.ConsecutiveSubStrings() )

			on :stzListOfStrings
				new stzListOfStrings( This.ConsecutiveSubStrings() )

			on :stzListOfChars
				new stzListOfChars( This.ConsecutiveSubStrings() )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def AdjuscentSubStrings()
			return This.ConsecutiveSubStrings()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CONSECUTIVE SUBSTRINGS IN THE STRING  #
	#--------------------------------------------------------------#

	def NumberOfConsecutiveSubStrings()
		nLen = This.NumberOfChars()
		if nLen <= 1
			return 0
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		nResult = 0

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				nResult++
			next
		next

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfAdjacentSubStrings()
			return This.NumberOfConsecutiveSubStrings()

		def HowManyConsecutiveSubStrings()
			return This.NumberOfConsecutiveSubStrings()

		def HowManyAdjacentSubStrings()
			return This.NumberOfConsecutiveSubStrings()

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING THE PositioNS OF CONSECUTIVE SUBSTRINGS IN THE STRING -- XT  #
	#-----------------------------------------------------------------------#

	def FindConsecutiveSubStrings()
		anResult = U( This.FindConsecutiveSubStringsXT() )
		return anResult

		def FindAdjacentSubStrings()
			return This.FindConsecutiveSubStrings()

	#--

	def FindConsecutiveSubStringsXT()

		nLen = This.NumberOfChars()
		if nLen <= 1
			return 0
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		anResult = []

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				anResult + j
			next
		next

		return anResult

		def FindAdjacentSubStringsXT()
			return This.FindConsecutiveSubStringsXT()

	  #-----------------------------------------------------------------------#
	 #  FINDING THE PositioNS OF CONSECUTIVE SUBSTRINGS IN THE STRING -- ZZ  #
	#-----------------------------------------------------------------------#

	def FindConsecutiveSubStringsZZ()
		nLen = This.NumberOfChars()
		if nLen <= 1
			return 0
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		aResult = []

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				aResult + [ j, j + i - 1 ]
			next
		next

		return aResult

		def FindAdjacentSubStringsZZ()
			return This.FindConsecutiveSubStringsZZ()

	  #-------------------------------------------------------------------------------#
	 #  GETTING THE CONSECUTIVE SUBSTRINGS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------------#

	def ConsecutiveSubStringsZ()
		nLen = This.NumberOfChars()
		if nLen <= 1
			return 0
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		aResult = []

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				aResult + [ QStringObject().mid(j-1, j + i - 1), j ]
			next
		next

		return aResult

		def AdjacentSubStringsZ()
			return This.ConsecutiveSubStringsZ()

	  #------------------------------------------------------------------------------#
	 #  GETTING THE CONSECUTIVE SUBSTRINGS IN THE STRING ALONG WITH THEIR SECTIONS  #
	#------------------------------------------------------------------------------#

	def ConsecutiveSubStringsZZ()
		nLen = This.NumberOfChars()
		if nLen <= 1
			return 0
		ok

		nMax = ( nLen - nLen % 2 ) / 2

		aResult = []

		for i = 1 to nMax
			acTemp = This.ConsecutiveSubStringsOfNChars(i)
			nLenTemp = len(acTemp)

			for j = 1 to nLenTemp
				aResult + [ QStringObject().mid(j-1, j + i - 1), [ j, j + i - 1 ] ]
			next
		next

		return aResult

		def AdjacentSubStringsZZ()
			return This.ConsecutiveSubStringsZZ()

	  #-------------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE STRING   #
	#===========================================#

	def RemoveDuplicatesCS(pCaseSensitive)

		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		_cResult_ = This.Copy().RemoveSections(aSections)
		This.UpdateWith(_cResult_)


		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

	def DuplicatesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return cResult

		def WithoutDuplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(1)

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

		def WithoutDuplicates()
			return This.DuplicatesRemoved()

		def WithoutDuplication()
			return This.DuplicatesRemoved()

		def WithoutDuplications()
			return This.DuplicatesRemoved()

  	  #----------------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN SUBSTRING   #
	#----------------------------------------------#

	def RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

			def RemoveDuplicatesOfThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisSubstringRemovedCS(pcSubStr, pCaseSensitive)
			return This.DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubString(pcSubStr)
		This.RemoveDuplicatesOfSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringQ(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcsubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubString(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcSubStr)

			def RemoveDuplicatesOfThisSubStringQ(pcSubStr)
				This.RemoveDuplicatesOfThisSubString(pcSubStr)
				return This

		#>

	def DuplicatesOfSubStringRemoved(pcSubStr)
		return This.DuplicatesOfSubStringRemovedCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisSubStringRemoved(pcSubStr)
			return This.DuplicatesOfSubStringRemoved(pcSubStr)

		#>

	  #--------------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN SUBSTRINGS   #
	#--------------------------------------------------#

	def RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param! paItems must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(pacSubStr[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsCSQ(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

			def RemoveDuplicatesOfTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubStrings(pacSubStr)
		This.RemoveDuplicatesOfSubStringsCS(pacSubStr, 1)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsQ(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOfTheseSubStrings(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)

			def RemoveDuplicatesOfTheseSubStringsQ(pacSubStr)
				This.RemoveDuplicatesOfTheseSubStrings(pacSubStr)
				return This

		#>

	  #===============================================#
	 #   TRANSFORMING THE STRING TO A STZTEXTOBJECT  #
	#===============================================#

	def ToStzText()
		return new stzText( This.String() )

	  #===============================================#
	 #      NUMBER OF OCCURRENCE OF A SUBSTRING      #
	#===============================================#

	def NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		# Unfortunately, we don't have a direct function that
		# returns this in Ring or RingQt. So, we implement it
		# in our own and pay for the performance tax on sutch
		# an elementary feature in any language!

		nResult = StringCountCS(This.Content(), pcSubStr, pCaseSensitive)
		return nResult

		#< @FunctionFluentForm

		def NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def NumberOfOccurrenceOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
		
		def HowManyCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def HowManyCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def CountCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def CountCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def CountSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def CountSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pcSubStr)
		return This.NumberOfOccurrenceCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def NumberOfOccurrenceQ(pcSubStr)
			return new stzNumber( This.NumberOfOccurrence(pcSubStr) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrences(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOf(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesOfQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOfOccurrenceOf(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOfOccurrenceOfSubstring(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOfSubstring(pcSubStr)
			return This.NumberOfOccurrenceOfSubstring(pcSubStr)

			def NumberOfOccurrencesOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
		
		def HowMany(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def HowManyQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOf(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def Count(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

		def CountSubString(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

		#>

	  #----------------------------------------------------------------------#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION    #
	#======================================================================#

	def NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckingParams()
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if isString(pnStartingAt)
				if pnStartingAt = :Start or
			  	   pnStartingAt = :First or
				   pnStartingAt = :FirstChar

					pnStartingAt = 1

				but pnStartingAt = :End or
			  	    pnStartingAt = :Last or
				    pnStartingAt = :LastChar

					pnStartingAt = This.NumberOfChars()
				ok
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		# Doing the job

		nResult = This.SectionQ(pnStartingAt, This.NumberOfChars()).
			      NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		return nResult

		#< @FunctionFluentForm

		def NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
			return new stzNumber( This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfOccurrencesSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NumberOfOccurrencesOfSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfOccurrencesOfSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def NumberOfOccurrenceOfSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfOccurrenceOfSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceOfSubstringSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfOccurrenceOfSubstringSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NumberOfOccurrencesOfSubstringSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubstringSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfOccurrencesOfSubstringSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def CountSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def CountSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def HowManySTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def HowManySTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NumberOfSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

			def NumberOfSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.NumberOfOccurrenceSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceST(pcSubStr, pnStartingAt)
		return NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionFluentForm

		def NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
			return new stzNumber( This.NumberOfOccurrenceST(pcSubStr, pnStartingAt) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def NumberOfOccurrencesSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
	
		def NumberOfOccurrencesOfST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def NumberOfOccurrencesOfSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOfOccurrenceOfST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def NumberOfOccurrenceOfSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)

		def NumberOfOccurrenceOfSubstringST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def NumberOfOccurrenceOfSubstringSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
	
		def NumberOfOccurrencesOfSubstringST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceOfSubstringST(pcSubStr, pnStartingAt)

			def NumberOfOccurrencesOfSubstringSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
	
		def CountST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def CountSTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
	
		def HowManyST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def HowManySTQ(pcSubStr, pnStartingAt)
				return This.NumberOfOccurrenceSTQ(pcSubStr, pnStartingAt)
	
		def NumberOfST(pcSubStr, pnStartingAt)
			return This.NumberOfOccurrenceST(pcSubStr, pnStartingAt)

			def NumberOfSTQ(pcSubStr, pnStartingAt)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING N (OR MORE) TIMES IN THE LIST  #
	#==============================================================#

	def SubStringsOccurringNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		acResult = This.SubStringsQ().ItemsOccurringNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringAtLeastNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringAtLeastNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringNTimes(n)
		return This.SubStringsOccurringNTimesCS(n, 1)

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesQ(n)
			return new stzList( This.SubStringsOccurringNTimes(n) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimes(n) # One r instead of 2
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccuringNTimesQ(n)
				return This.SubStringsOccurringNTimesQ(n)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNTimesOrMore(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringNTimesOrMoreQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		def SubStringsOccurringNTimesAndMore(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringNTimesAndMoreQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		def SubStringsOccurringAtLeastNTimes(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringAtLeastNTimesQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		#>

	  #------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING EXACTLY N TIMES IN THE LIST  #
	#------------------------------------------------------------#

	def SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		acResult = This.SubStringsQ().ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringExactlyNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringExactlyNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringExactlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringExactlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringExactlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringExactlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#--

		def SubStringsOccurringOnlyNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringOnlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringOnlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringExactlyNTimes(n)
		return This.SubStringsOccurringExactlyNTimesCS(n, 1)

		#< @FunctionFluentForm

		def SubStringsOccurringExactlyNTimesQ(n)
			return This.SubStringsOccurringExactlyNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringExactlyNTimes(n) # One r instead of 2
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccuringExactlyNTimesQ(n)
				return This.SubStringsOccurringExactlyNTimesQ(n)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringExactlyNTimesOrMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringExactlyNTimesOrMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringExactlyNTimesAndMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringExactlyNTimesAndMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		#--

		def SubStringsOccurringOnlyNTimes(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringOnlyNTimesOrMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesOrMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringOnlyNTimesAndMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesAndMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING MORE THAN N TIMES IN THE LIST  #
	#--------------------------------------------------------------#

	def SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		acResult = This.SubStringsQ().ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNoLessThanNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccuringNoLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringMoreThanNTimes(n)
		return This.SubStringsOccurringMoreThanNTimesCS(n, 1)

		#< @FunctionFluentForm

		def SubStringsOccurringMoreThanNTimesQ(n)
			return This.SubStringsOccurringMoreThanNTimes(n)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNoLessThanNTimes(n)
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccurringNoLessThanNTimesQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringMoreThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccuringMoreThanNTimesQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		def SubStringsOccuringNoLessThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccuringNoLessThanNTimesCQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING LESS THAN N TIMES IN THE LIST  #
	#--------------------------------------------------------------#

	def SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		acResult = This.SubStringsQ().ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringNoMoreThanNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def SubStringsOccuringLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccuringNoMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringLessThanNTimes(n)
		return This.SubStringsOccurringLessThanNTimesCS(n, 1)

		#< @FunctionFluentForm

		def SubStringsOccurringLessThanNTimesQ(n)
			return This.SubStringsOccurringLessThanNTimes(n)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringNoMoreThanNTimes(n)
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccurringNoMoreThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def SubStringsOccuringLessThanNTimes(n)
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccuringLessThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		def SubStringsOccuringNoMoreThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccuringNoMoreThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		#>

	  #------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING N TIMES OR LESS IN THE LIST  #
	#------------------------------------------------------------#

	def SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive) #TODO // Check for performance
		acResult = This.SubStringsQ().ItemsOccurringNTimesOrLessCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesOrLessCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesOrLessCS(n, pCaseSensitive) # On r instead of 2
			return This.SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive)

			def SubStringsOccuringNTimesOrLessCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringNTimesOrLessCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringNTimesOrLess(n)
		return This.SubStringsOccurringNTimesOrLessCS(n, 1)

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesOrLessQ(n)
			return This.SubStringsOccurringNTimesOrLess(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesOrLess(n) # On r instead of 2
			return This.SubStringsOccurringNTimesOrLess(n)

			def SubStringsOccuringNTimesOrLessQ(n)
				return This.SubStringsOccurringNTimesOrLessQ(n)

		#>

	  #=======================================================#
	 #    CHECKING IF THE STRING IS ONE OF THE RING TYPES    #
	#=======================================================#

	def IsRingType()
		cUPPER = ring_upper(This.Content())

		if cUPPER = "NUMBER" or cUPPER = "STRING" or cUPPER = "LIST" or
		   cUPPER = "OBJECT" or cUPPER = "COBJECT"

			return 1

		else
			return 0
		ok

		def IsARingType()
			return This.IsRingType()

	  #==============================#
	 #  GETTING THE SIZE IN BYTES   #
	#==============================#

	def NumberOfBytesPerChar()
		aResult = []
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			aResult + [ acChars[i], @MSize(acChars[i]) ]
		next

		return aResult

		#< @FunctionAlternativeFormss

		def CountBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytePerChar()
			return This.NumberOfBytesPerChar()

		def SizeInBytesPerChar()
			return This.NumberOfBytesPerChar()

		def SizeInBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		def CountBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		def NumberOfBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		#>

	  #------------------------------#
	 #   BYTES AND BYTES PER CHAR   #
	#==============================#

	def Bytes()
		return This.ToStzListOfBytes().Content()

		#< @FunctionFluentForms

		def BytesQ()
			return This.ToStzListOfBytes()

		#>
	
		#< @FunctionAlternativeForm

		def ToListOfBytes()
			return This.Bytes()
	
			def ToListOfBytesQ()
				return This.BytesQ()
	
		#>

	def BytesPerChar()
		return This.ToStzListOfBytes().BytesPerChar()

	  #--------------------------------------#
	 #   BYTECODES AND BYTECODES PER CHAR   #
	#--------------------------------------#

	def Bytecodes()
		return This.ToStzListOfBytes().Bytecodes()

	def BytecodesPerChar()
		return This.ToStzListOfBytes().BytecodesPerChar()

	  #--------------------------------------------------------#
	 #   TRANSFORMING THE STRING TO A stzListOfBytes OBJECT   #
	#--------------------------------------------------------#

	def ToStzListOfBytes()
		return new stzListOfBytes( This.String() )

	  #===========================================#
	 #   N RIGHT CHARS RETURNED AS A SUBSTRING   #
	#===========================================#

	def NRightCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return ""

		but n > nLen
			return This.Content()

		else
			if This.IsRightToleft()
				cResult = This.Section( 1, n )
			else
				cResult = This.Section( nLen - n + 1, nLen )
			end
					
			return cResult
		ok

		#< @FunctionFluentForm

		def NRightCharsAsSubStringQ(n)
			return new stzString( This.NRightCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NRightCharsAsString(n)
			return This.NRightCharsAsSubString(n)

			def NRightCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

		def RightNCharsAsSubString(n)
			return This.NRightCharsAsSubString(n)
	
			def RightNCharsAsString(n)
				return This.RightNCharsAsSubString(n)

			def RightNCharsAsSubStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

			def RightNCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)
	
		def Right(n)
			return This.NRightCharsAsSubString(n)

			def RightQ(n)
				return This.NRightCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Right2CharsAsSubString()
			return This.NRightCharsAsSubString(2)

			def Right2CharsAsString()
				return This.Right2CharsAsSubString()

			def 2RightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def 2RightCharsAsString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsString()
				return This.NRightCharsAsSubString(2)

		def Right3CharsAsSubString()
			return This.NRightCharsAsSubString(3)

			def Right3CharsAsString()
				return This.Right3CharsAsSubString()

			def 3RightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def 3RightCharsAsString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsString()
				return This.NRightCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLeftCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return ""

		but n > nLen
			return This.Content()

		else
			if IsRightToleft()
				cResult = Section( nLen - n + 1, nLen )
			else
				cResult = Section( 1, n)
			end
	
			return cResult
		ok

		#< @FunctionFluentForm

		def NLeftCharsAsSubStringQ(n)
			return new stzString( This.NLeftCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLeftCharsAsString(n)
			return This.NLeftCharsAsSubString(n)

			def NLeftCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def LeftNCharsAsSubString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsSubStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)
	
		def LeftNCharsAsString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def Left(n)
			return This.NLeftCharsAsSubString(n)

			def LeftQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Left2CharsAsSubString()
			return This.NLeftCharsAsSubString(2)

			def Left2CharsAsString()
				return This.Left2CharsAsSubString()

			def 2LefthtCharsAsSubString()
				return This.NLefttCharsAsSubString(2)

			def 2LefthtCharsAsString()
				return This.NLefttCharsAsSubString(2)

			def LeftTwoCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def LeftTwoCharsAsString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsString()
				return This.NLeftCharsAsSubString(2)

		def Left3CharsAsSubString()
			return This.NLeftCharsAsSubString(3)

			def Left3CharsAsString()
				return This.Left3CharsAsSubString()

			def 3LeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def 3LeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

		#>

	  #-------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A SUBSTRING   #
	#-------------------------------------------#

	def NFirstCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NRightCharsAsSubString(n)
		else
			return This.NLeftCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsAsSubStringQ(n)
			return new stzString( This.NFirstCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NFirstCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFirstCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FirstNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FirstNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
		#>

		#< @FunctionSpecificForms

		def First2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def First2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def First3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def First3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

		#< @FunctionMisspelledForms

		def NFristCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFristCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FristNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FristNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FristNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FristNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		#-- Specific misspelled forms

		def Frist2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def Frist2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FristCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FristCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FristTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FristTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFristCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFristCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def Frist3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def Frist3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FristCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FristCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FristThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FristThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFristCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFristCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LAST CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLastCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftCharsAsSubString(n)
		else
			return This.NRightCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsAsSubStringQ(n)
			return new stzString( This.NLastCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLastCharsAsString(n)
			return This.NLastCharsAsSubString(n)

			def NLastCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsSubString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsSubStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2CharsAsSubString()
			return This.NLastCharsAsSubString(2)

			def Last2CharsAsString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsString()
				return This.NLastCharsAsSubString(2)

		def Last3CharsAsSubString()
			return This.NLastCharsAsSubString(3)

			def Last3CharsAsString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsString()
				return This.NLastCharsAsSubString(3)

		#>

	  #-----------------------------------------------------------#
	 #   GETTING THE NEXT NTH CHAR STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------#

	def NextNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return ""
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)

			if ring_find([
				:First, :FirstPosition, :FirstString, :FirstItem ], pnStartingAt) > 0

				pnStartingAt = 1
			
			but ring_find([
				:Last, :LastPosition, :LastString, :LastItem ], pnStartingAt) > 0

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if pnStartingAt >= 1 and pnStartingAt <= This.NumberOfChars() - 1
			if pnStartingAt + n <= This.NumberOfChars()
				cResult = This.CharAt(pnStartingAt + n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def NextNthCharQ(n, pnStartingAt)
			return This.NextNthCharQRT(n, pnStartingAt, :stzString)

		def NextNthCharQRT(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NextNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.NextNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthNextChar()
			return This.NextNthChar()

			def NthNextCharQ()
				return This.NextNthCharQ(n, pnStartingAt)
	
			def NthNextCharQRT(pcReturnType)
				return This.NextNthCharQRT(n, pnStartingAt, pcReturnType)

		#--

		def NextNthCharST(n, pnStartingAt)
			return This.NextNthChar(n, pnStartingAt)

			def NextNthCharSTQ(n, pnStartingAt)
				return This.NextNthCharQ(n, pnStartingAt)

			def NextNthCharSTQRT(n, pnStartingAt, pcReturnType)
				return This.NextNthCharQRT(n, pnStartingAt, pcReturnType)

		def NthNextCharST()
			return This.NextNthChar()

			def NthNextCharSTQ()
				return This.NextNthCharQ(n, pnStartingAt)
	
			def NthNextCharSTQRT(pcReturnType)
				return This.NextNthCharQRT(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2ndChar()
			return This.NextNthChar(2)

			def 2ndNextChar()
				return This.NextNthChar(2)

			def NextSecondChar()
				return This.NextNthChar(2)

			def SecondNextChar()
				return This.NextNthChar(2)

		def Next3rdChar()
			return This.NextNthChar(3)

			def 3rdNextChar()
				return This.NextNthChar(3)

			def NextThirdChar()
				return This.NextNthChar(3)

			def ThirdNextChar()
				return This.NextNthChar(3)

		#>

	  #-------------------------------------------------------#
	 #   GETTING THE NEXT CHAR STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------------#

	def NextChar(paStartingAt)
		return This.NextNthChar(1)

		#< @FunctionFluentForm

		def NextCharQ(pnStartingAt)
			return This.NextCharQRT(pnStartingAt, :stzString)

		def NextCharQRT(pnStartingAt, pcReturnType)
			return This.NextNthCharQRT(1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NextCharST(paStartingAt)
			return This.NextChar(paStartingAt)

			def NextCharSTQ(paStartingAt)
				return This.NextCharQ(pnStartingAt)

			def NextCharSTQRT(pnStartingAt, pcReturnType)
				return This.NextCharQRT(pnStartingAt, pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #   GETTING THE PREVIOUS NTH CHAR STARTING AT A GIVEN POSITION   #
	#----------------------------------------------------------------#

	def PreviousNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)

			if ring_find([
				:First, :FirstPosition, :FirstString, :FirstItem ], pnStartingAt) > 0

				pnStartingAt = 1
			
			but ring_find([
				:Last, :LastPosition, :LastString :LastItem ], pnStartingAt) > 0

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if pnStartingAt >= 2 and pnStartingAt <= This.NumberOfChars()

			if pnStartingAt - n >= 1
				cResult = This.CharAt(pnStartingAt - n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def PreviousNthCharQ(n, pnStartingAt)
			return This.PreviousNthCharQRT(n, pnStartingAt, :stzString)

		def PreviousNthCharQRT(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthPreviousChar()
			return This.PreviousNthChar()

			def NthPreviousCharQ()
				return This.NthPreviousCharQRT(:stzString)
	
			def NthPreviousCharQRT(pcReturnType)
				return This.PreviousNthCharQRT(n, pnStartingAt, pcReturnType)

		#--

		def PreviousNthCharST(n, pnStartingAt)
			return This.PreviousNthChar(n, pnStartingAt)

			def PreviousNthCharSTQ(n, pnStartingAt)
				return This.PreviousNthCharQ(n, pnStartingAt)

			def PreviousNthCharSTQRT(n, pnStartingAt, pcReturnType)
				return This.PreviousNthCharQ(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2ndChar()
			return This.PreviousNthChar(2)

			def 2ndPreviousChar()
				return This.PreviousNthChar(2)

			def PreviousSecondChar()
				return This.PreviousNthChar(2)

			def SecondPreviousChar()
				return This.PreviousNthChar(2)

		def Previous3rdChar()
			return This.PreviousNthChar(3)

			def 3rdPreviousChar()
				return This.PreviousNthChar(3)

			def PreviousThirdChar()
				return This.PreviousNthChar(3)

			def ThirdPreviousChar()
				return This.PreviousNthChar(3)

		#>

	  #------------------------------------------------------------#
	 #   GETTING THE PREVIOUS CHAR STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------------#

	def PreviousChar(pnStartingAt)
		return This.PreviousNthChar(n, 1)

		#< @FunctionFluentForm

		def PreviousCharQ(pnStartingAt)
			return This.PreviousCharQRT(pnStartingAt, :stzString)

		def PreviousCharQRT(pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousChar(pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousChar(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off	
		#>

		#< @FunctionAlternativeForm

		def PreviousCharST(pnStartingAt)
			return This.PreviousChar(pnStartingAt)

			def PreviousCharSTQ(pnStartingAt)
				return This.PreviousCharQ(pnStartingAt)

			def PreviousCharSTQRT(pnStartingAt, pcReturnType)
				return This.PreviousCharQ(pnStartingAt, pcReturnType)

		#>

	  #------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A SUBSTRING)   #
	#------------------------------------------------------------------------#

	def NextNCharsAsSubString(n, pnStartingAt)

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt,  pnStartingAt + n - 1)
		return cResult

		#< @FunctionFluentForm

		def NextNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString(This.NextNCharsAsSubString(n, pnStartingAt))

		#>

		#< @FunctionAlternativeForm

		def NextNCharsAsString(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#--

		def NextNCharsAsSubStringST(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsSubStringSTQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		def NextNCharsAsStringST(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringSTQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Next2CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(2, pnStartingAt)

			def Next2CharsAsString(pnStartingAt)
				return This.Next2CharsAsSubString(pnStartingAt)

			def 2NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def 2NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

		def Next3CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(3, pnStartingAt)

			def Next3CharsAsString(pnStartingAt)
				return This.Next3CharsAsSubString(pnStartingAt)

			def 3NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def 3NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A SUBSTRING  #
	#-------------------------------------------------------------------------#

	def PreviousNCharsAsSubString(n, pnStartingAt)

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt - n + 1, pnStartingAt)

		return cResult

		#< @FunctionFluentForm

		def PreviousNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString( This.PreviousNCharsAsSubString(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def PreviousNCharsAsString(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)
	
		#--

		def PreviousNCharsAsSubStringST(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsSubStringSTQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)

		def PreviousNCharsAsStringST(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringSTQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Previous2CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def Previous2CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

		def Previous3CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def Previous3CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)
	
			def PreviousThreeCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def PreviousThreeCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

		#>

	  #===============================================#
	 #   N RIGHT CHARS RETURNED AS A LIST OF CHARS   #
	#===============================================#

	def NRightChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return []

		but n > nLen
			return This.Content()

		ok

		acResult = []

		if This.IsRightToleft()
			acResult = This.SectionQ( 1, n ).Chars()
		else
			acResult = This.SectionQ( nLen - n + 1, nLen ).Chars()
		end
					
		return acResult

		#< @FunctionFluentForm

		def NRightCharsQ(n)
			return This.NRightCharsQRT(n, :stzList)

		def NRightCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NRightChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NRightChars(n) )

			on :stzListOfChars
				return new stzListOfchars( This.NRightChars(n) )

			on :stzString
				return new stzString( This.NRightCharsQRT(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def RightNChars(n)
			return This.NRightChars(n)
	
			def RightNCharsQ(n)
				return This.NRightCharsQ(n)

			def RightNCharsQRT(n, pcReturnType)
				return This.NRightCharsQRT(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Right2Chars()
			return This.NRightChars(2)

			def 2RightChars()
				return This.NRightChars(2)

			def RightTwoChars()
				return This.NRightChars(2)

			def TwoRightChars()
				return This.NRightChars(2)

	
		def Right3Chars()
			return This.NRightChars(3)

			def 3RightChars()
				return This.NRightChars(3)

			def RightThreeChars()
				return This.NRightChars(3)

			def ThreeRightChars()
				return This.NRightChars(3)

		#>

	  #----------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLeftChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return []

		but n > nLen
			return This.Content()

		ok

		acResult = []

		if IsRightToleft()
			acResult = SectionQ( nLen - n + 1, nLen ).Chars()
		else
			acResult = SectionQ( 1, n).Chars()
		end
	
		return acResult


		#< @FunctionFluentForm

		def NLeftCharsQ(n)
			return This.NLeftCharsQRT(n, :stzList)

		def NLeftCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLeftChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLeftChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLeftChars(n) )

			on :stzString
				return new stzString( This.NLeftCharsQRT(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LeftNChars(n)
			return This.NLeftChars(n)
	
			def LeftNCharsQ(n)
				return This.NLeftCharsQ(n)

			def LeftNCharsQRT(n, pcReturnType)
				return This.NLeftCharsQRT(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Left2Chars()
			return This.NLeftChars(2)

			def 2LefthtChars()
				return This.NLefttChars(2)

			def LeftTwoChars()
				return This.NLeftChars(2)

			def TwoLeftChars()
				return This.NLeftChars(2)

	
		def Left3Chars()
			return This.NLeftChars(3)

			def 3LeftChars()
				return This.NLeftChars(3)

			def LeftThreeChars()
				return This.NLeftChars(3)

			def ThreeLeftChars()
				return This.NLeftChars(3)

		#>

	  #-----------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A LIST OF CHARS   #
	#-----------------------------------------------#

	def NFirstChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		if This.IsRightToLeft()
			return This.NRightChars(n)
		else
			return This.NLeftChars(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsQ(n)
			return This.NLeftCharsQRT(n, :stzList)

		def NFirstCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NFirstChars(n) )

			on :stzString
				return new stzString( This.NFirstCharsQRT(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FirstNChars(n)
			return This.NFirstChars(n)
	
			def FirstNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FirstNCharsQRT(n, pcReturnType)
				return This.NFirstCharsQRT(n, pcReturnType)

		#-- item as alternative of char #TODO generalise it!

		def NFirstItems(n)
			return This.NFirstChars(n)

			def NFirstItemsQ(n)
				return This.NFirstCharsQ(n)

		def FirstNItems(n)
			return This.NFirstChars(n)

			def FirstNItemsQ(n)
				return This.NFirstCharsQ(n)

		#>

		#< @FunctionSpecificForms

		def First2Chars()
			return This.NFirstChars(2)

			def 2FirstChars()
				return This.NFirstChars(2)

			def FirstTwoChars()
				return This.NFirstChars(2)

			def TwoFirstChars()
				return This.NFirstChars(2)

		def First3Chars()
			return This.NFirstChars(3)

			def 3FirstChars()
				return This.NFirstChars(3)

			def FirstThreeChars()
				return This.NFirstChars(3)

			def ThreeFirstChars()
				return This.NFirstChars(3)

		def First4Chars()
			return This.FirstNChars(4)
	
			def 4FirstChars()
				return This.First4Chars()
	
			def FirstFourChars()
				return This.First4Chars()
	
			def FourFirstChars()
				return This.First4Chars()
	
		def First5Chars()
			return This.FirstNChars(5)
	
			def 5FirstChars()
				return This.First5Chars()
	
			def FirstFiveChars()
				return This.First5Chars()
	
			def FiveFirstChars()
				return This.First5Chars()
	
		def First6Chars()
			return This.FirstNChars(6)
	
			def 6FirstChars()
				return This.First6Chars()
	
			def FirstSixChars()
				return This.First6Chars()
	
			def SixFirstChars()
				return This.First6Chars()
	
		def First7Chars()
			return This.FirstNChars(7)
	
			def 7FirstChars()
				return This.First7Chars()
	
			def FirstSevenChars()
				return This.First7Chars()
	
			def SevenFirstChars()
				return This.First7Chars()
	
		def First8Chars()
			return This.FirstNChars(8)
	
			def 8FirstChars()
				return This.First8Chars()
	
			def FirstEightChars()
				return This.First8Chars()
	
			def EightFirstChars()
				return This.First8Chars()
	
		def First9Chars()
			return This.FirstNChars(9)
	
			def 9FirstChars()
				return This.First9Chars()
	
			def FirstNineChars()
				return This.First9Chars()
	
			def NineFirstChars()
				return This.First9Chars()
	
		def First10Chars()
			return This.FirstNChars(10)
	
			def 10FirstChars()
				return This.First10Chars()
	
			def FirstTenChars()
				return This.First10Chars()
	
			def TenFirstChars()
				return This.First10Chars()
	
		#>

		#< @FunctionAlternativeForms

		def FristNChars(n)
			return This.NFirstChars(n)
	
			def FristNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FristNCharsQRT(n, pcReturnType)
				return This.NFirstCharsQRT(n, pcReturnType)

		#-- specific misspelled forms

		def Frist2Chars()
			return This.NFirstChars(2)

			def 2FristChars()
				return This.NFirstChars(2)

			def FristTwoChars()
				return This.NFirstChars(2)

			def TwoFristChars()
				return This.NFirstChars(2)

		def Frist3Chars()
			return This.NFirstChars(3)

			def 3FristChars()
				return This.NFirstChars(3)

			def FristThreeChars()
				return This.NFirstChars(3)

			def ThreeFristChars()
				return This.NFirstChars(3)

		def Frist4Chars()
			return This.FristNChars(4)
	
			def 4FristChars()
				return This.First4Chars()
	
			def FristFourChars()
				return This.First4Chars()
	
			def FourFristChars()
				return This.First4Chars()
	
		def Frist5Chars()
			return This.FirstNChars(5)
	
			def 5FristChars()
				return This.First5Chars()
	
			def FristFiveChars()
				return This.First5Chars()
	
			def FiveFristChars()
				return This.First5Chars()
	
		def Frist6Chars()
			return This.FirstNChars(6)
	
			def 6FristChars()
				return This.First6Chars()
	
			def FristSixChars()
				return This.First6Chars()
	
			def SixFristChars()
				return This.First6Chars()
	
		def Frist7Chars()
			return This.FirstNChars(7)
	
			def 7FristChars()
				return This.First7Chars()
	
			def FristSevenChars()
				return This.First7Chars()
	
			def SevenFristChars()
				return This.First7Chars()
	
		def Frist8Chars()
			return This.FirstNChars(8)
	
			def 8FristChars()
				return This.First8Chars()
	
			def FristEightChars()
				return This.First8Chars()
	
			def EightFristChars()
				return This.First8Chars()
	
		def Frist9Chars()
			return This.FirstNChars(9)
	
			def 9FristChars()
				return This.First9Chars()
	
			def FristNineChars()
				return This.First9Chars()
	
			def NineFristChars()
				return This.First9Chars()
	
		def Frist10Chars()
			return This.FirstNChars(10)
	
			def 10FristChars()
				return This.First10Chars()
	
			def FristTenChars()
				return This.First10Chars()
	
			def TenFristChars()
				return This.First10Chars()

		#>

	  #----------------------------------------------#
	 #   N LAST CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLastChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftChars(n)
		else
			return This.NRightChars(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsQ(n)
			return This.NLastCharsQRT(n, :stzList)

		def NLastCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLastChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLastChars(n) )

			on :stzString
				return new stzString( This.NLastCharsQRT(n, :stzListOfStrings).Concatenated() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNChars(n)
			return This.NLastChars(n)
	
			def LastNCharsQ(n)
				return This.NLastCharsQ(n)

			def LastNCharsQRT(n, pcReturnType)
				return This.NLastCharsQRT(n, pcReturnType)

		#-- item as alternative of char #TODO generalise it!

		def NLastItems(n)
			return This.NLastChars(n)

			def NLastItemsQ(n)
				return This.NLastCharsQ(n)

		def LastNItems(n)
			return This.NLastChars(n)

			def LastNItemsQ(n)
				return This.NLastCharsQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2Chars()
			return This.NLastChars(2)

			def 2LastChars()
				return This.NLastChars(2)

			def LastTwoChars()
				return This.NLastChars(2)

			def TwoLastChars()
				return This.NLastChars(2)

		def Last3Chars()
			return This.NLastChars(3)

			def 3LastChars()
				return This.NLastChars(3)

			def LastThreeChars()
				return This.NLastChars(3)

			def ThreeLastChars()
				return This.NLastChars(3)

		def Last4Chars()
			return This.LastNChars(4)
	
			def 4LastChars()
				return This.Last4Chars()
	
			def LastFourChars()
				return This.Last4Chars()
	
			def FourLastChars()
				return This.Last4Chars()
	
		def Last5Chars()
			return This.LastNChars(5)
	
			def 5LastChars()
				return This.Last5Chars()
	
			def LastFiveChars()
				return This.Last5Chars()
	
			def FiveLastChars()
				return This.Last5Chars()
	
		def Last6Chars()
			return This.LastNChars(6)
	
			def 6LastChars()
				return This.Last6Chars()
	
			def LastSixChars()
				return This.Last6Chars()
	
			def SixLastChars()
				return This.Last6Chars()
	
		def Last7Chars()
			return This.LastNChars(7)
	
			def 7LastChars()
				return This.Last7Chars()
	
			def LastSevenChars()
				return This.Last7Chars()
	
			def SevenLastChars()
				return This.Last7Chars()
	
		def Last8Chars()
			return This.LastNChars(8)
	
			def 8LastChars()
				return This.Last8Chars()
	
			def LastEightChars()
				return This.Last8Chars()
	
			def EightLastChars()
				return This.Last8Chars()
	
		def Last9Chars()
			return This.LastNChars(9)
	
			def 9LastChars()
				return This.Last9Chars()
	
			def LastNineChars()
				return This.Last9Chars()
	
			def NineLastChars()
				return This.Last9Chars()
	
		def Last10Chars()
			return This.LastNChars(10)
	
			def 10LastChars()
				return This.Last10Chars()
	
			def LastTenChars()
				return This.Last10Chars()
	
			def TenLastChars()
				return This.Last10Chars()
	
		#>

	  #---------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A LIST OF CHARS)  #
	#---------------------------------------------------------------------------#

	def NextNChars(n, pnStartingAt)

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtOrStartingAtPositionNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt+1, pnStartingAt + n).Chars()
		return acResult

		#< @FunctionFluentForm

		def NextNCharsQ(n, pnStartingAt)
			return This.NextNCharsQRT(n, pnStartingAt, :stzList)

		def NextNCharsQRT(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NNextChars(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsQ(n, pnStartingAt)
				return This.NNextCharsQRT(n, pnStartingAt, :stzList)

			def NNextCharsQRT(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQRT(n, pnStartingAt, pcReturnType)

		#--

		def NextNCharsST(n, pnStartingAt)
			return This.NNextChars(n, pnStartingAt)

			def NextNCharsSTQ(n, pnStartingAt)
				return This.NextNCharsQ(n, pnStartingAt)

			def NextNCharsSTQRT(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQRT(n, pnStartingAt, pcReturnType)

		def NNextCharsST(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsSTQ(n, pnStartingAt)
				return This.NNextCharsQRT(n, pnStartingAt, :stzList)

			def NNextCharsSTQRT(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQRT(n, pnStartingAt, pcReturnType)


		#>

		#< @FunctionSpecificForms

		def Next2Chars(pnStartingAt)
			return This.NextNChars(2, pnStartingAt)

			def 2NextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def NextTwoChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def TwoNextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

		def Next3Chars(pnStartingAt)
			return This.NextNChars(3, pnStartingAt)

			def 3NextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def NextThreeChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def ThreeNextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A LIST OF CHARS  #
	#-----------------------------------------------------------------------------#

	def PreviousNChars(n, pnStartingAt)

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtOrStartingAtPositionNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt - n, pnStartingAt-1).Chars()

		return acResult

		#< @FunctionFluentForm

		def PreviousNCharsQ(n, pnStartingAt)
			return This.PreviousNCharsQRT(n, pnStartingAt, :stzList)

		def PreviousNCharsQRT(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NPreviousChars(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsQ(n, pnStartingAt)
				return This.NPreviousCharsQRT(n, pnStartingAt, :stzList)

			def NPreviousCharsQRT(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQRT(n, pnStartingAt, pcReturnType)

		#--

		def PreviousNCharsST(n, pnStartingAt)
			return This.NPreviousChars(n, pnStartingAt)

			def PreviousNCharsSTQ(n, pnStartingAt)
				return This.PreviousNCharsQ(n, pnStartingAt)

			def PreviousNCharsSTQRT(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQRT(n, pnStartingAt, pcReturnType)

		def NPreviousCharsST(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsSTQ(n, pnStartingAt)
				return This.NPreviousCharsQRT(n, pnStartingAt, :stzList)

			def NPreviousCharsSTQRT(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQRT(n, pnStartingAt, pcReturnType)
		#>

		#< @FunctionSpecificForms

		def Previous2Chars(pnStartingAt)
			return This.PreviousNChars(2, pnStartingAt)

			def 2PreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def PreviousTwoChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def TwoPreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

		def Previous3Chars(pnStartingAt)
			return This.PreviousNChars(3, pnStartingAt)

			def 3PreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def PreviousThreeChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def ThreePreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

		#>

	  #====================================================#
	 #  INFERING A RING OR SOFTANZA TYPE FROM THE STRING  #
	#====================================================#

	def InfereType()
		cStr = This.Lowercased()

		# Checking if the string correponds to one of the 4 Ring types

		if cStr = :number or cStr = :numbers or Q(cStr).BeginsWith(:Number)
			return :Number
	
		but cStr = :string or cStr = :strings or Q(cStr).BeginsWith(:String)
			return :String
	
		but cStr = :list or cStr = :lists or Q(cStr).BeginsWith(:List) or
		    cStr = :pair or cStr = :pairs or Q(cStr).BeginsWith(:pair)
	
			return :List
	
		but cStr = :object or cStr = :objects or Q(cStr).BeginsWith(:Object)
			return :Object
	
		ok
	
		# Checking if the string correponds to one of the Softanza types

		oStr = new stzString(cStr)
		oStzPlusStr = new stzString("stz" + cStr)

		if oStr.BeginsWithCS("stz",  0)
			acStzClasses = StzClassesXT()
			nLen = len(acStzClasses)

			for i = 1 to nLen
				aPair = acStzClasses[i]
				if aPair[1] = cStr or aPair[2] = cStr
					return aPair[1]
				ok
			next

		but oStzPlusStr.IsStzType()
			return "stz" + cStr

		but oStr.IsPluralOfAStzType()
			return PluralToStzType(cStr)

		but oStzPlusStr.IsPluralOfAStzType()
			return PluralToStzType("stz" + cStr)

		ok

		#< @FunctionAlternativeForms

		def InfereTypeQ()
			return new stzString( This.InfereType() )

		def InfereStzClass()
			return This.InfereType()

			def InfereStzClassQ()
				return new stzString( This.InfereStzClass() )

		def InfereStzClassName()
			return This.InfereType()

			def InfereStzClassNameQ()
				return new stzString( This.InfereStzClass() )

		#>

	def InferedType()
		return This.InfereType()

		#< @FunctionAlternativeForms

		def InferedStzClass()
			return This.InfereType()

		def InferedStzClassName()
			return This.InfereType()

		#>

	  #----------------------------------------------------#
	 #  INFERING A SOFTANZA CLASS METHOD FROM THE STRING  #
	#----------------------------------------------------#

	def InfereMethod(pcFromStzClass)

		if isList(pcFromStzClass) and
		   Q(pcFromStzClass).IsOneOfTheseNamedParams([ :From, :In, :Of ])
			pcFromStzClass = pcFromStzClass[2]
		ok

		if NOT isString(pcFromStzClass)
			stzRaise("Incorrect param type! pcFromStzClass must be a string.")
		ok

		if Q(pcFromStzClass).IsPluralOfAStzType()
			pcFromStzClass = PluralToStzType(pcFromStzClass)
		ok

		if NOT Q(pcFromStzClass).IsStzClass()
			stzRaise("Syntax error! pcFromStzClass must be a valid Softanza class name.")
		ok

		cCode = 'acTheseMethods = Stz("' +
			Q(pcFromStzClass).FirstNCharsRemoved(3) + '",
			:Methods)'

		eval(cCode)

		cMethod = ""

		oList = new stzList( acTheseMethods )

		if oList.ContainsCS( "is" + This.String(),  0 )
			cMethod = "is" + This.String()

		but oList.ContainsCS( "is" + This.LastCharRemoved(),  0 )
			cMethod = "is" + This.LastCharRemoved()

		else
			stzRaise("Sorry! Can't infere the method name from the provided string.")
		ok

		return cMethod

		def InfereMethodQ()
			return new stzString( This.InfereMethod() )

	def InferedMethod()
		return InfereMthod()

	  #--------------------------------------------------------------#
	 #    CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	#--------------------------------------------------------------#

	def IsStzClassName()
		acStzClasses = StzClasses()

		n = ring_find( StzClasses(), This.Lowercased() )

		if n > 0
			return 1
		else
			return 0
		ok

		def IsStzType()
			return This.IsStzClassName()

		def IsStzClass()
			return This.IsStzClassName()

		def IsAStzClassName()
			return This.IsStzClassName()

		def IsAStzType()
			return This.IsStzClassName()

		def IsAStzClass()
			return This.IsStzClassName()

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF ANY SOFTANZA TYPE  #
	#------------------------------------------------------------------#

	def IsPluralOfAStzType()

		if QRT( StzTypesXT(), :stzListOfPairs ).
		   SecondItemsQ().
		   ContainsCS( This.Content(), 0 )

			return 1

		else
			return 0
		ok

		#< @FunctionAlternativeForm

		def IsPluralOfStzType()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClassName()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClassName()
			return This.IsPluralOfAStzType()

		#--

		def IsStzClassInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassInPlural()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPlural()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPlural()
			return This.IsPluralOfAStzType()

		#>

	   #-------------------------------------------------------------#
	  #   CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	 #   NO MATTER IT WAS IN SINGULAR OR PLURAL FORM               #
	#-------------------------------------------------------------#

	def IsStzClassNameXT()
		
		if This.IsStzClassName() or This.IsStzClassNameInPluralForm()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsStzTypeXT()
			return This.IsStzClassNameXT()

		def IsStzClassXT()
			return This.IsStzClassNameXT()

		def IsAStzClassNameXT()
			return This.IsStzClassNameXT()

		def IsAStzTypeXT()
			return This.IsStzClassNameXT()

		def IsAStzClassXT()
			return This.IsStzClassNameXT()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF A GIVEN SOFTANZA TYPE  #
	#----------------------------------------------------------------------#

	def IsPluralOfThisStzType(cType)

		if Q(cType).IsAStzType() and
		   PluralOfThisStzType(cType) = This.String()

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsPluralOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsPluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsThePluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#>

	  #=====================================================================#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER  #
	#=====================================================================#

	#TODO // Unify the bounds fucntions in stzString and stzList

	def FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)
		if CheckingParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params types! Both n1 and n2 must be numbers.")
			ok

			if NOT @BothAreNumbers(nCharsBefore, nCharsAfter)
				StzRaise("Incorrect params types! Both nCharsBefore and nCharsAfter must be numbers.")
			ok
		ok

		if nCharsBefore > n1
			nCharsBefore = n1 - 1
		ok

		nLen = This.NumberOfChars()

		if nCharsAfter > nLen - n2
			nCharsAfter = nLen - n2
		ok

		anSectionBefore = [0, 0]

		if nCharsBefore != 0
			anSectionBefore[1] = (n1 - nCharsBefore)
			anSectionBefore[2] = (n1 - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (n2 + 1)
			anSectionAfter[2] = (n2 + nCharsAfter)
		ok

		aResult = [ anSectionBefore, anSectionAfter ]

		return aResult

		#< @FunctionAlternativeForm

		def FindSectionBoundsAsSections(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)

		#>

	def FindSectionBounds(n1, n2, nCharsBefore, nCharsAfter)

		anResult = QRT(
			This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter),
			:stzListOfPairs
		).FirstItems()

		return anResult

		def FindSectionBoundsZ(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBounds(n1, n2, nCharsBefore, nCharsAfter)

	def FindSectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
		anResult = QRT(
			This.FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter),
			:stzListOfPairs
		).FirstItems()

		return anResult

		def FindSectionBoundsIBZ(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
			
	  #---------------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	def FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter)
		aSections = This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)

		aSections[1][1]++
		aSections[1][2]++

		aSections[2][1]--
		aSections[2][2]--

		return aSections

	  #---------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER  #
	#=====================================================================#

	def SectionBounds(n1, n2, nCharsBefore, nCharsAfter)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.SectionBounds(10, 13, 2, 3)
		#--> [ "<<", ">>>" ]

		*/

		aSections = This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)
		acResult = This.Sections(aSections)

		return acResult

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	def SectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
		aSections = This.FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter)
		return This.Sections(aSections)

	  #-------------------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, ALONG WITH THEIR POSITIONS  #
	#=================================================================================================#

	def SectionBoundsZ(n1, n2, nCharBefore, nCharsAfter) #TODO // check for performance

		acBounds = This.SectionBounds(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBounds(n1, n2, nCharBefore, nCharsAfter)

		aResult = Associattion([ acBounds, anPos ])
		#NOTE: We've used a misspelled form of Association()
		# function (a one more "t"), but Softanza tolerates it!

		return aResult

		def SectionBoundsAndTheirPositions(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsZ(n1, n2, nCharBefore, nCharsAfter)

	  #-------------------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, ALONG WITH THEIR POSITIONS  #
	#=================================================================================================#

	def SectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter) #TODO // check for performance

		acBounds = This.SectionBounds(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, anPos ])

		return aResult

		def SectionBoundsAndTheirSections(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter)

	   #----------------------------------------------------------------------#
	  #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER,  #
	 #  INCLDUING BOUNDS, ALONG WITH THEIR POSITIONS                        #
	#======================================================================#

	def SectionBoundsIBZ(n1, n2, nCharBefore, nCharsAfter) #TODO // check for performance

		acBounds = This.SectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, anPos ])

		return aResult

		def SectionBoundsAndTheirPositionsIB(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsIBZ(n1, n2, nCharBefore, nCharsAfter)

	   #----------------------------------------------------------------------#
	  #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER,  #
	 #  INCLDUING BOUNDS, ALONG WITH THEIR SECTIONS                         #
	#======================================================================#

	def SectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter) #TODO // check for performance

		acBounds  = This.SectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)
		aSections = This.FindSectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, aSections ])
		return aResult

		def SectionBoundsAndTheirSectionsIB(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter)

	  #---------------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	# A more expressive, but less performant, alternative to SectionsBounds()

	def Sit(paPositionOrSection, paHarvest)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.Sit(
			:OnSection = [10, 13],
			:Harvest = [ :NCharsBefore = 2, :NCharsAfter = 3 ]
		)

		#--> [ "<<", ">>>" ]

		*/

		# Checking params

		if CheckingParams()

			if isList(paPositionOrSection) and
				Q(paPositionOrSection).IsOneOfTheseNamedParams([
					:On, :OnPosition, :OnSection,
					:In, :InPosition, :InSection,
					:Position, :Section
				])
	
				paPositionOrSection = paPositionOrSection[2]
			ok
	
			if isNumber(paPositionOrSection)
	
				aTemp = []
				aTemp + paPositionOrSection
				aTemp + paPositionOrSection
	
				paPositionOrSection = aTemp
			ok
	
			if NOT ( isList(paPositionOrSection) and
				 Q(paPositionOrSection).IsPairOfNumbers() )
	
				stzRaise("Incorrect param! paPositionOrSection must be a position (number) or a section (pair of numbers).")
			ok
	
			aSection = paPositionOrSection
			bReturnSections = 0
	
			if isList(paHarvest) and
			   Q(paHarvest).IsOneOfTheseNamedParams([
	
					:Harvest, :AndHarvest,
					:AndThenHarvest, :ThenHarvest,
	
					:Yield, :AndYield,
					:AndThenYield, :ThenYield,
	
					:HarvestSection, :AndHarvestSection,
					:AndThenHarvestSection, :ThenHarvestSection,
	
					:YieldSection, :AndYieldSection,
					:AndThenYieldSection, :ThenYieldSection,
	
					:HarvestSections, :AndHarvestSections,
					:AndThenHarvestSections, :ThenHarvestSections,
	
					:YieldSections, :AndYieldSections,
					:AndThenYieldSections, :ThenYieldSections ])
	
				if Q(paHarvest[1]).ContainsCS(:Section,  0)
					bReturnSections = 1
				ok
	
				paHarvest = paHarvest[2]
			ok
	
			if NOT len(paHarvest) = 2
				stzRaise("Incorrect param! paHarvest must be a list of 2 items.")
			ok
	
			if isList(paHarvest[1]) and StzListQ(paHarvest[1]).IsNCharsBeforeNamedParam()
				paHarvest[1] = paHarvest[1][2]
			ok
	
			if isList(paHarvest[2]) and StzListQ(paHarvest[2]).IsNCharsAfterNamedParam()
				paHarvest[2] = paHarvest[2][2]
			ok
	
			if NOT @BothAreNumbers(paHarvest[1], paHarvest[2])
				stzRaise("Incorrect param! paHarvest must be a pair of numbers.")
			ok
	
		ok

		#-- Doing the job

		nCharsBefore = paHarvest[1]
		if nCharsBefore > aSection[1] - 1
			nCharsBefore = aSection[1] - 1
		ok

		nLen = This.NumberOfChars()
		nCharsAfter  = paHarvest[2]
		if nCharsAfter > nLen - aSection[2]
			nCharsAfter = nLen - aSection[2]
		ok

		anSectionBefore = [0, 0]

		if nCharsBefore != 0
			anSectionBefore[1] = (aSection[1] - nCharsBefore)
			anSectionBefore[2] = (aSection[1] - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (aSection[2] + 1)
			anSectionAfter[2] = (aSection[2] + nCharsAfter)
		ok

		if bReturnSections
			aResult = [ anSectionBefore, anSectionAfter ]
			
		else
			aResult = This.Sections([ anSectionBefore, anSectionAfter ])
		ok

		return aResult

		#< @FunctionAlternativeForms

		def SitIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SitOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Settle(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SettleIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SettleOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Enclose(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def EncloseIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def EncloseOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Occuppy(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def OccuppyIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def OccuppyOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Stay(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def StayIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def StayOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		#>

	#TODO // Add these alternatives

	def SitOnSection(n1, n2, paHarvest)
		return This.Sit([n1, n2], paHarvest)

		#< @FunctionAlternativeForms

		def SitOnSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitOnSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def SitInSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitInSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitInSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def StayInSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayOnSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayInSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayInSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def EncloseSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def EncloseSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def EncoloseSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def OccuppySection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def OccuppySectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def OccuppySectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#>

	def SitAndYield(paPositionOrSection, paHarvest)
		return This.Sit(paPositionOrSection, paHarvest)

		#< @FunctionAlternatives

		def StayAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def EncloseAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def OccuppyAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		#--

		def SitAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def StayAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def EncloseAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def OccuppyAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		#>

	def SitOnPosition(n, paHarvest)
		return This.Sit(n, paHarvest)

		def SitInPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def SitAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def StayInPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def StayAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def EnclosePosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def EncloseAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)


	def SitOnPositionAndYield(n, paHarvest)
		return This.Sit(n, paHarvest)

		#< @FunctionAlternativeForms

		def SitInPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def SitAtPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayOnPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayInPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayAtPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		#--

		def SitAtPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayOnPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayInPositionAndHaervest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayAtPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF MANY SECTIONS, N CHARS BEFORE AND N CHARS AFTER  # 
	#-------------------------------------------------------------------------#

	def SectionsBounds(paSections, nCharsBefore, nCharsAfter)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> and [[happy]]] day!")

		o1.SectionsBounds([ [10, 13], [24, 28] ], 2, 3)
		#--> [ ["<<", ">>>"], ["[[", "]]]"] ]

		*/

		if CheckingParams()
			if NOT (isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acResult = []

		nLenSections = len(paSections)

		for i = 1 to nLenSections

			n1 = paSections[i][1]
			n2 = paSections[i][2]

			if nCharsBefore > n1
				nCharsBefore = n1 - 1
			ok
	
			nLenStr = This.NumberOfChars()
	
			if nCharsAfter > nLenStr - n2
				nCharsAfter = nLenStr - n2
			ok
	
			anSectionBefore = [0, 0]
	
			if nCharsBefore != 0
				anSectionBefore[1] = (n1 - nCharsBefore)
				anSectionBefore[2] = (n1 - 1)
			ok
	
			anSectionAfter = [0, 0]
			if anSectionAfter != 0
				anSectionAfter[1] = (n2 + 1)
				anSectionAfter[2] = (n2 + nCharsAfter)
			ok
				
			acResult + This.Sections([ anSectionBefore, anSectionAfter ])
		next

		return acResult

		#< @FunctionAlternativeForm

		def ManySectionsBounds(paSections, nCharsBefore, nCharsAfter)
			return This.SectionsBounds(paSections, nCharsBefore, nCharsAfter)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF MANY SECTIONS, RESPECTIVELY, N CHARS BEFORE AND N CHARS AFTER  # 
	#---------------------------------------------------------------------------------------#

	#todo

	  #==============================#
	 #     BOUNDS OF THE STRING     #
	#==============================#

	// Verifies if the string is bounded by one or two substrings

	def IsBoundedByCS(pacBounds, pCaseSensitive)
		/* EXAMPLE

		# Case 1 : Checking if the string is bounded by ONE substring

		o1 = new stzString("-♥-")
		? o1.IsBoundedBy("-") #--> TRUE

		# Case 1 : Checking if the string is bounded by TWO substrings

		o1 = new stzString("-♥_")
		? o1.IsBoundedBy([ "-", "_" ]) #--> TRUE

		# Case 3 : A special case to check if the string is bounded
		# by one or two substrings, INSIDE an other string

		? Q("♥").IsBoundedBy([ "-", :In = "-♥-" ])
		#--> TRUE

		*/

		# Managing this special syntax:
		# ? Q("♥").IsBoundedBy([ "-", :In = "-♥-" ])

		if isList(pacBounds) and StzListQ(pacBounds).IsPair() and
		   isList(pacBounds[2]) StzListand Q(pacBounds[2]).IsPair()

			oParam = new stzList(pacBounds[2])

			if oParam.IsInNamedParam()
				return This.IsBoundedByInCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			but oParam.IsAndNamedParam()
				pacBounds[2] = pacBounds[2][2]
			ok

		ok

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		but isList(pacBounds) and StzListQ(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a list of pairs.")
		ok

		if This.BeginsWithCS(cBound1, pCaseSensitive) and
		   This.EndsWithCS(cBound2, pCaseSensitive)

			return 1

		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsBoundedBy(pacBounds)
		return This.IsBoundedByCS(pacBounds, 1)

	   #--------------------------------------------------------#
	  #  CHECKING IF THE STRING IS BOUNDED BY A GIVEN PAIR OF  #
	 #  SUBSTRINGS INSIDE A GIVEN STRING                      #
	#--------------------------------------------------------#

	def IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		/* EXAMPLE 1

		? Q("♥").IsBoundedByXT([ "-", :In = "-♥-" ])
		#--> TRUE

		EXAMPLE 2

		o1 = new stzString("♥")
		? o1.IsBoundedByIn([ "-", "-" ], :In = "... -♥- ...")
		#--> TRUE

		*/

		if isString(pacBounds)
			aTemp = []
			aTemp + pacBounds + pacBounds

			pacBounds = aTemp
		ok

		if NOT ( isList(pacBounds) and StzListQ(pacBounds).IsPairOfStrings() )
			StzRaise("Incorrect param type! paBounds must be a pair of strings.")
		ok


		if isList(pIn) and StzListQ(pIn).IsInOrInsideNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pIn must be a string or list.")
		ok

		bResult = 0

		if isString(pIn)

			oStr = new stzString(pIn)
			bResult = oStr.SubStringIsBoundedByCS( This.String(), pacBounds, pCaseSensitive )

		but isList(pIn) and StzListQ(pIn).IsListOfStrings()

			#TODO
			StzRaise("Currently, the function works only on one string. List of strings are not supported.")
		ok
	
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundedByCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenCSIB(pacBounds, pIn, pCaseSensitive)

			if NOT ( isList(pacBounds) and len(pacBounds) = 2 )
				StzRaise("Incorrect param! pacBounds must be a list of 2 items.")
			ok

			acBounds = []

			if isString(pacBounds[1])
				acBounds + pacBounds[1]
			ok

			if isString(pacBounds[2])
				acBounds + pacBounds[2]

			but isList(pacBounds[2]) and
			   Q(pacBounds[2]).IsAndNamedParam() and
			   isString(pacBounds[2][2])

				acBounds + pacBounds[2][2]
				
			ok

			if NOT Q(acBounds).IsPairOfStrings()
				StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
			ok

			bResult = This.IsBoundedByInCS(acBounds, pIn, pCaseSensitive)

			return bResult

		def IsBoundedByInCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenInCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBetweenInCSIB(pacBounds, pIn, pCaseSensitive)

		#--

		def IsBoundedByCSXT(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenCSXT(pacBounds, pIn, pCaseSensitive)
			return This.IsBetweenCSIB(pacBounds, pIn, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def IsBoundedByIn(pacBounds, pIn)
		return This.IsboundedByInCS(pacBounds, pIn, 1)

		#< @FunctionAlternativeForm

		def IsBoundedByIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenIB(pacBounds, pIn)
			return This.IsBetweenCSIB(pacBounds, pIn, 1)

		def IsBoundedByInIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenInIB(pacBounds, pIn)
			return This.IsBetweenCSIB(pacBounds, pIn, 1)

		#--

		def IsBoundedByXT(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenXT(pacBounds, pIn)
			return This.IsBetweenIB(pacBounds, pIn)

		#>

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDING OF A GIVEN STRING INSIDE ANOTHER STRING  #
	#------------------------------------------------------------------------------#

	def IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("_")
		? o1.IsBoundOf("world", :In = "hello _world_ and <world>!")
		#--> TRUE
		*/

		if CheckingParams()
			if isList(pcInStr) and StzListQ(pcInStr).IsInNamedParam()
				pcInStr = pcInStr[2]
			ok

			if NOT isString(pcInStr)
				StzRaise("Incorrect param type! pcInStr must be a string.")
			ok
		ok

		cBounded = This.String() + pcSubStr + This.String()
		bResult = StzStringQ(pcInStr).ContainsCS(cBounded, pCaseSensitive)

		return bResult

		#< @FunctionAlternativeForms

		def IsBoundOfCSXT(pcSubStr, pcInStr, pCaseSensitive)
			return This.IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)

		def IsBoundOfInCS(pcSubStr, pcInStr, pCaseSensitive)
			if CheckingParams()	
				if NOT isString(pcInStr)
					StzRaise("Incorrect param type! pcInStr must be a string.")
				ok
			ok
			return This.IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESNESITUVURT

	def IsBoundOf(pcSubStr, pcInStr)
		bResult = This.IsBoundOfCS(pcSubStr, pcInStr, 1)
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundOfXT(pcSubStr, pcInStr)
			return This.IsBoundOf(pcSubStr, pcInStr)

		def IsBoundOfIn(pcSubStr, pcInStr)
			return This.IsBoundOfCS(pcSubStr, pcInStr, 1)

		#>

	#==

	def IsFirstBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).FirstBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return 1
		else
			return 0
		ok

	def IsFirstBoundOf(pcOtherStr)
		return This.IsFirstBoundOfCS(pcOtherStr, 1)

	#==

	def IsLastBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LastBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return 1
		else
			return 0
		ok

		def IsSecondBoundOfCS(pcOtherStr, pCaseSensitive)
			return This.IsLastBoundOfCS(pcOtherStr, pCaseSensitive)

	def IsLastBoundOf(pcOtherStr)
		return This.IsLastBoundOfCS(pcOtherStr, 1)

		def IsSecondBoundOf(pcOtherStr)
			return This.IsLastBoundOf(pcOtherStr)

	#==

	def IsLeftBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LeftBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return 1
		else
			return 0
		ok

	def IsLeftBound(pcOtherStr)
		return This.IsLetfBoundOfCS(pcOtherStr, 1)

	#==

	def IsRightBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).RightBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return 1
		else
			return 0
		ok

	def IsRightBoundOf(pcOtherStr)
		return This.IsRightBoundOfCS(pcOtherStr, 1)

	  #------------------------------------#
	 #     ADDING BOUNDS TO THE STRING    #
	#====================================#

	def AddBounds(pacBounds)
		if NOT ( isString(pacBounds) or ( isList(pacBounds) and len(pacBounds) = 2) )
			StzRaise("Incorrect param type! pacBounds must be a string or a pair.")
		ok

		if isList(pacBounds[2]) and StzListQ(pacBounds[2]).IsAndNamedParam()
			pacBounds[2] = pacBounds[2][2]
		ok

		if NOT isString(pacBounds[1])
			StzRaise("Incorrect param type! the first item of pacBounds must be a string.")
		ok

		if isList(pacBounds) and StzListQ(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		but isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			StzRaise("Incorrect param type! pacBounds must tbe a string or pair of strings.")
		ok

		cResult = cBound1 + This.String() + cBound2
		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def AddBoundsQ(pacBounds)
			This.AddBounds(pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundWithQ(pacBounds)
				return This.AddBoundsQ(pacBounds)

		def BoundItWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundItWithQ(pacBounds)
				return This.AddBoundsQ(pacBounds)

		#>

	def StringWithBoundsAdded(pacBounds)
		cResult = This.Copy().AddBoundsQ(pacBounds).Content()

		#< @FunctionAlternativeForms

		def StringBoundedWith(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		def BoundedWith()
			return This.StringWithBoundsAdded(pacBounds)

		def BoundsAdded()
			return This.StringWithBoundsAdded(pacBounds)

		def StringBoundedBy(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		#>

	  #------------------------------------------#
	 #  BOUNDING A SECTION WITH TWO SUBSTRINGS  #
	#------------------------------------------#

	def BoundSection(n1, n2, pacBounds)
		if CheckingParams()
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

			if isList(pacBounds) and StzListQ(pacBounds).IsWithOrUsingOrByNamedParam()
				pacBounds = pacBounds[2]
				if isList(pacBounds[2]) and StzListQ(pacBounds[2]).IsAndNamedParam()
					pacBounds[2] = pacBounds[2][2]
				ok
			ok

			if isString(pacBounds)
				pacTemp = []
				pacTemp + pacBounds + pacBounds
				pacBounds = pacTemp
			ok

			if NOT ( isList(pacBounds) and @IsPairOfStrings(pacBounds) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		aSection = ring_sort([n1, n2])
		n1 = aSection[1]
		n2 = aSection[2]

		This.InsertAfterPosition(n2, pacBounds[2])
		This.InsertBeforePosition(n1, pacBounds[1])

		#< @FunctionFluentForm

		def BoundSectionQ(n1, n2, pacBounds)
			This.BoundSection(n1, n2, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAroundSection(pacBounds, n1, n2)
			This.BoundSection(n1, n2, pacBounds)

			def InsertAroundSectionQ(pacBounds, n1, n2)
				return This.BoundSectionQ(n1, n2, pacBounds)

		def AddBoundsToSection(pacBounds, n1, n2)
			This.BoundSection(n1, n2, pacBounds)

			def AddBoundsToSectionQ(pacBounds, n1, n2)
				return This.BoundSectionQ(pacBounds, n1, n2)

		def AddBoundToSection(pcBound, n1, n2)
			This.BoundSection(n1, n2, pcBound)

			def AddBoundToSectionQ(pcBound, n1, n2)
				return This.BoundSectionQ(n1, n2, pcBound)

		#>

	def SectionBounded(n1, n2, pacBounds)
		acResult = This.Copy().BoundSectionQ(n1, n2, pacBounds).Content()
		return acResult

		#< @FunctionAlternativeForms

		def InsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def SubStringsInsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def SubStringInsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def BoundsAddedToSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def BoundAddedToSection(pcSubStr, n1, n2)
			return This.SectionBounded(n1, n2, pcSubStr)

		#>

	  #----------------------------------------------#
	 #  BOUNDING MANY SECTIONS WITH TWO SUBSTRINGS  #
	#----------------------------------------------#

	def BoundSections(aSections, pacBounds)
		if CheckingParams()
			if NOT (isList(aSections) and @IsListOfPairsOfNumbers(aSections))
				StzRaise("Incorrect param type! aSections must be a list of pairs of numbers.")
			ok

			if isList(pacBounds) and StzListQ(pacBounds).IsWithOrUsingOrByNamedParam()
				pacBounds = pacBounds[2]
				if isList(pacBounds[2]) and StzListQ(pacBounds[2]).IsAndNamedParam()
					pacBounds[2] = pacBounds[2][2]
				ok
			ok

			if isString(pacBounds)
				pacTemp = []
				pacTemp + pacBounds + pacBounds
				pacBounds = pacTemp
			ok

			if NOT ( isList(pacBounds) and @IsPairOfStrings(pacBounds) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		aSections = StzListOfPairsQ(aSections).Sorted()
		nLen = len(aSections)

		if nLen = 0
			return

		but nLen = 1
			This.BoundSection(aSections[1][1], aSections[1][2], pacBounds)
			return
		ok

		# If some sections are included in others then remove them
			#TODO // Turn this to a method RemoveIncluded() in stzListOfPairs
	
		aSectionsXT = [] + aSections[1]
		for i = 2 to nLen
			if ( aSections[i][1] > aSections[i-1][1] and aSections[i][1] < aSections[i-1][2] ) and
			   ( aSections[i][2] > aSections[i-1][1] and aSections[i][2] < aSections[i-1][2] )

				// do nothing
			else

				aSectionsXT + aSections[i]
			ok
		next

		# Inserting the bounds around the sections

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
			n1 = aSectionsXT[i][1]
			n2 = aSectionsXT[i][2]

			This.InsertAfterPosition(n2, pacBounds[2])
			This.InsertBeforePosition(n1, pacBounds[1])
		next

		#< @FunctionFluentForm

		def BoundSectionsQ(aSections, pacBounds)
			This.BoundSections(aSections, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAroundSections(pacBounds, aSections)
			This.BoundSections(aSections, pacBounds)

			def InsertAroundSectionsQ(pacBounds, aSections)
				return This.BoundSectionsQ(aSections, pacBounds)

		def AddBoundsToSections(pacBounds, aSections)
			This.BoundSections(aSections, pacBounds)

			def AddBoundsToSectionsQ(pacBounds, aSections)
				return This.BoundSectionsQ(aSections, pacBounds)

		def AddBoundToSections(pcSubStr, aSections)
			This.BoundSections(aSections, pcSubStr)

			def AddBoundToSectionsQ(pcSubStr, aSections)
				return This.BoundSectionsQ(aSections, pcSubStr)

		#>

	def SectionsBounded(aSections, pacBounds)
		acResult = This.Copy().BoundSectionsQ(aSections, pacBounds).Content()
		return acResult

		#< @FunctionAlternativeForms

		def InsertedAroundSections(pacBounds, aSections)
			return This.SectionsBounded(aSections, pacBounds)

		def BoundsAddedToSections(pacBounds, aSections)
			return This.SectionsBounded(aSections, pacBounds)

		def BoundAddedToSections(pcSubStr, aSections)
			return This.SectionsBounded(pcSubStr, aSections)

		#>

	  #--------------------------------------------------------#
	 #  BOUNDING MANY SECTIONS WITH MANY BOUNDING SUBSTRINGS  #
	#--------------------------------------------------------#

	def BoundSectionsByMany(paSections, paManyBounds)

		if CheckingParams()
			if NOT (isList(paSections) and IsListOfPairsOfNumbersSortedUp(paSections))
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers sorted in ascending.")
			ok

			if NOT ( isList(paManyBounds) and IsListOfStringsOrPairsOfStrings(paManyBounds))
				StzRaise("Incorrect param type! paManyBounds must be a list of strings and/or pairs of strings.")
			ok
		ok

		# Justifying the two params sizes to their minimum

		nLenSections = len(paSections)
		nLenBounds = len(paManyBounds)
		nMin = Min([ nLenSections, nLenBounds ])

		aSections = []
		if nLenSections > nMin
			for j = 1 to nMin
				aSections + paSections[j]
			next
		else
			aSections = paSections

		ok

		aBounds = []
		if nLenBounds > nMin
			for j = 1 to nMin
				aBounds + paManyBounds[j]
			next
		else
			aBounds = paManyBounds
		ok

		# Doing the job

		for i = nMin to 1 step -1
			This.BoundSection(aSections[i][1], aSections[i][2], aBounds[i])
		next

		#< @FunctionFluentForm

		def BoundSectionsByManyQ(paSections, paManyBounds)
			This.BoundSectionsByMany(paSections, paManyBounds)
			return This

		#>

		#< @FunctionAlternativeForm

		def BoundSectionsWithMany(paSections, paManyBounds)
			This.BoundSectionsByMany(paSections, paManyBounds)

			def BoundSectionsWithManyQ(paSections, paManyBounds)
				return This.BoundSectionsByManyQ(paSections, paManyBounds)

		#>

	def SectionsBoundedByMany(paSections, paManyBounds)
		cResult = This.Copy().BoundSectionsByManyQ(paSections, paManyBounds).Content()
		return cResult

		def SectionsBoundedWithMany(paSections, paManybounds)
			return This.SectionsBoundedByMany(paSections, paManyBounds)

	  #------------------------------------------------#
	 #  BOUNDING A SUBSTRING BY TWO OTHER SUBSTRINGS  #
	#------------------------------------------------#

	def BoundCS(pcSubStr, pacBounds, pCaseSensitive)
		
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.BoundSections(aSections, pacBounds)

		#< @FunctionFluentForm

		def BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringCSQ(pcSubStr, pacBounds, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def InsertAroundSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def InsertAroundSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def AddBoundsToSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def AddBoundsToSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def AddBoundToSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def AddBoundToSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		#>


	def SubStringBoundedCS(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().BoundCSQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

		def BoundsAddedToSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.SubStringBoundedCS(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Bound(pcSubStr, pacBounds)
		This.BoundCS(pcSubStr, pacBounds, 1)

		#< @FunctionFluentForm

		def BoundQ(pcSubStr, pacBounds)
			This.Bound(pcSubStr, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubString(pcSubStr, pacBounds)
			This.Bound(pcSubStr, pacBounds)

			def BoundSubStringQ(pcSubStr, pacBounds)
				return This.BoundQ(pcSubStr, pacBounds)

		def InsertAroundSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def InsertAroundSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		def AddBoundsToSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def AddBoundsToSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		def AddBoundToSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def AddBoundToSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		#>

	def SubStringBounded(pcSubStr, pacBounds)
		return This.SubStringBoundedCS(pcSubStr, pacBounds, 1)

		def BoundsAddedToSubString(pcSubStr, pacBounds)
			return This.SubStringBounded(pcSubStr, pacBounds)

	  #----------------------------------------------------#
	 #  BOUNDING MANY SUBSTRINGS BY TWO OTHER SUBSTRINGS  #
	#----------------------------------------------------#

	def BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)
		This.BoundSections(aSections, pacBounds)

		#< @FunctionFluentForm

		def BoundManyCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundManyCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStringsCS(pacSubStr, pacBounds, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringsCSQ(pacSubStr, pacBounds, pCaseSensitive)
				return This.BoundManyCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def InsertAroundSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def InsertAroundSubStringsCSQ(pacBounds, pacSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		def AddBoundsToSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def AddBoundsToSubStringsCSQ(pacBounds, pacSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		def AddBoundToSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def AddBoundToSubStringsCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		#>


	def SubStringsBoundedCS(pacSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

		def BoundsAddedToSubStringsCS(pacSubStr, pacBounds, pCaseSensitive)
			return This.SubStringsBoundedCS(pacSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def BoundMany(pacSubStr, pacBounds)
		This.BoundManyCS(pacSubStr, pacBounds, 1)

		#< @FunctionFluentForm

		def BoundManyQ(pcSubStr, pacBounds)
			This.BoundMany(pcSubStr, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStrings(pacSubStr, pacBounds)
			This.BoundMany(pacSubStr, pacBounds)

			def BoundSubStringsQ(pacSubStr, pacBounds)
				return This.BoundManyQ(pcSubStr, pacBounds)

		def InsertAroundSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def InsertAroundSubStringsQ(pacBounds, pacSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		def AddBoundsToSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def AddBoundsToSubStringsQ(pacBounds, pacSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		def AddBoundToSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def AddBoundToSubStringsQ(pacBounds, pcSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		#>

	def SubStringsBounded(pacSubStr, pacBounds)
		cResult = This.Copy().BoundManyQ(pacSubStr, pacBounds).Content()
		return cResult

		def BoundsAddedToSubStrings(pacSubStr, pacBounds)
			return This.SubStringsBounded(pacSubStr, pacBounds)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY TWO OTHER SUBSTRINGS  #
	#====================================================================#

	def SubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		/* EXAMPLES

		o1 = new stzString("aa♥♥aaa bb♥♥bbb")
		
		? o1.SubStringIsBoundedBy("♥♥", "aa") #--> TRUE

		? o1.SubStringIsBoundedBy("♥♥", "bb") #--> TRUE
		
		? o1.SubStringIsBoundedBy("♥♥", [ "aa", "aaa" ] ) #--> TRUE

		*/

		if CheckingParams() = 1
			if isList(pacBounds)
				if len(pacBounds) != 2
					pacBounds = Q(pacBounds).Pairified()
				ok

			but isString(pacBounds)
				aTemp = []
				aTemp  + pacBounds + pacBounds
				pacBounds = aTemp
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		# Doing the job

		if IsListOfPairs(pacBounds)
			nLen = len(pacBounds)
			bResult = 1

			for i = 1 to nLen
				bResult = This.SubStringIsBoundedByCS(pcSubStr, pacBounds[i], pCaseSensitive)
			next

			return bResult
		ok

		nLen1 = Q(pacBounds[1]).NumberOfChars()
		nLen2 = Q(pacBounds[2]).NumberOfChars()

		aSections = This.FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		bResult = 0

		for i = 1 to nLen

			acEffectiveBounds = This.Sit( :OnSection = aSections[i], :AndYield = [ nLen1, nLen2 ])

			if Q(acEffectiveBounds[1]).IsEqualToCS(pacBounds[1], pCaseSensitive) and
			   Q(acEffectiveBounds[2]).IsEqualToCS(pacBounds[2], pCaseSensitive)

				bResult = 1
				exit
			ok
		next

		return bResult
		

	def SubStringIsBoundedBy(pcSubStr, pacBounds)
		return This.SubStringIsBoundedByCS(pcSubStr, pacBounds, 1)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY MANY PAIRS OF SUBSTRINGS  #
	#------------------------------------------------------------------------#
	
	def SubStringIsBoundedByManyCS(pcSubStr, pacPairsOfBounds, pCaseSensitive)
		#TODO // Add "These" as alternative of "Many"

		/* EXAMPLE

		? o1.SubStringIsBoundedBy("♥♥", [ [ "aa","aaa" ], ["bb","bbb"] ]) #--> TRUE

		*/

		if NOT isList(pacPairsOfBounds)
			StzRaise("Incorrect param type! pacPairsOfBounds must be a list.")
		ok

		bResult = 1
		
		nLen = len(pacPairsOfBounds)
		for i = 1 to nLen
			if NOT This.SubStringIsBoundedByCS(pcSubStr, pacPairsOfBounds[i], pCaseSensitive)
				bResult = 0
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBoundedByMany(pacSubStr, pacPairsOfBounds)
		return This.SubStringIsBoundedByManyCS(pacSubStr, pacPairsOfBounds, 1)

	  #=====================================================================================#
	 #  CHECKING IF A SUBSTRING COMES BEFORE AN OTHER SUBSTRING OR POSITION IN THE STRING  #
	#=====================================================================================#

	def SubStringIsBeforeCS(pcSubStr, p, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p)
			oParam = Q(p)
			if oParam.IsPositionNamedParam()
				return This.SubStringIsBeforePositionCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsSubStringNamedParam()
				return This.SubStringIsBeforeSubStringCS(pcSubStr, p[2], pCaseSensitive)
			ok
		ok

		if isNumber(p)
			return This.SubStringIsBeforePositionCS(pcSubStr, p, pCaseSensitive)
		but isString(p)
			return This.SubStringIsBeforeSubStringCS(pcSubStr, p, pCaseSensitive)
		else
			StzRaise("Incorrect param! p must be a number or a string.")
		ok

		#< @FunctionAlternativeForm

		def SubStringComesBeforeCS(pcSubStr, p, pCaseSensitive)
			return This.SubStringIsBeforeCS(pcSubStr, p)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBefore(pcSubStr, p)
		return This.SubStringIsBeforeCS(pcSubStr, p, 1)

		#< @FunctionAlternativeForm

		def SubStringComesBefore(pcSubStr, p)
			return This.SubStringIsBefore(pcSubStr, p)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsBeforePositionCS(pcSubStr, n, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos < n
			return 1
		else
			return 0
		ok

		def SubStringComesBeforePositionCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringIsBeforePositionCS(pcSubStr, n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBeforePosition(pcSubStr, n)
		return This.SubStringIsBeforePositionCS(pcSubStr, n, 1)

		def SubStringComesBeforePosition(pcSubStr, n)
			return This.SubStringIsBeforePosition(pcSubStr, n)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		nOtherPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)

		if nPos < nOtherPos
			return 1
		else
			return 0
		ok

		def SubStringComesBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBeforeSubString(pcSubStr, pcOtherSubStr)
		return This.SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, 1)

		def SubStringComesBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.SubStringIsBeforeSubString(pcSubStr, pcOtherSubStr)

	  #------------------------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING COMES AFTER AN OTHER SUBSTRING OR POSITION IN THE STRING  #
	#====================================================================================#

	def SubStringIsAfterCS(pcSubStr, p, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p)
			oParam = Q(p)
			if oParam.IsPositionNamedParam()
				return This.SubStringIsAfterPositionCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsSubStringNamedParam()
				return This.SubStringIsAfterSubStringCS(pcSubStr, p[2], pCaseSensitive)
			ok
		ok

		if isNumber(p)
			return This.SubStringIsAfterPositionCS(pcSubStr, p, pCaseSensitive)

		but isString(p)
			return This.SubStringIsAfterSubStringCS(pcSubStr, p, pCaseSensitive)

		else
			StzRaise("Incorrect param! p must be a number or a string.")
		ok

		#< @FunctionAlternativeForm

		def SubStringComesAfterCS(pcSubStr, p, pCaseSensitive)
			return This.SubStringIsAfterCS(pcSubStr, p)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfter(pcSubStr, p)
		return This.SubStringIsAfterCS(pcSubStr, p, 1)

		#< @FunctionAlternativeForm

		def SubStringComesAfter(pcSubStr, p)
			return This.SubStringIsAfter(pcSubStr, p)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsAfterPositionCS(pcSubStr, n, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos > n
			return 1
		else
			return 0
		ok

		def SubStringComesAfterPositionCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringIsAfterPositionCS(pcSubStr, n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfterPosition(pcSubStr, n)
		return This.SubStringIsAfterPositionCS(pcSubStr, n, 1)

		def SubStringComesAfterPosition(pcSubStr, n)
			return This.SubStringIsAfterPosition(pcSubStr, n)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		nOtherPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)

		if nPos > nOtherPos
			return 1
		else
			return 0
		ok

		def SubStringComesAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfterSubString(pcSubStr, pcOtherSubStr)
		return This.SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, 1)

		def SubStringComesAfterSubString(pcSubStr, pcOtherSubStr)
			return This.SubStringIsAfterSubString(pcSubStr, pcOtherSubStr)

	  #---------------------------------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING COMES BETWEEN TWO OTHER SUBSTRINGS OR POSITIONS INSIDE THE STRING  #
	#=============================================================================================#

	def SubStringIsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(p1)
			oP1 = Q(p1)
			if oP1.IsPositionsNamedParam()
				if isList(p2) and StzListQ(p2).IsAndNamedParam()
					p2 = p2[2]
				ok

				return This.SubStringIsBetweenPositionsCS(pcSubStr, p1[2], p2, pCaseSensitive)

			but oP1.IsSubStringsNamedParam()
				if isList(p2) and StzListQ(p2).IsAndNamedParam()
					p2 = p2[2]
				ok

				return This.SubStringIsBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)
			ok
		ok

		if BothAreNumbers(p1, p2)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, p1, p2, pCaseSensitive)

		but BothAreStrings(p1, p2)
			return This.SubStringIsBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)

		else
			StzRaise("Incorrect params types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionAlternativeForm

		def SubStringComesBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.SubStringIsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetween(pcSubStr, p1, p2)
		return This.SubStringIsBetweenCS(pcSubStr, p1, p2, 1)

		#< @FunctionAlternativeForm

		def SubStringComesBetween(pcSubStr, p1, p2)
			return This.SubStringIsBetween(pcSubStr, p1, p2)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		bResult = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def SubStringComesBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		def SubStringComesInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		def SubStringComesInsideSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetweenPositions(pcSubStr, n1, n2)
		return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, 1)

		#< @FunctionAlternativeForms

		def SubStringComesBetweenPositions(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		def SubStringComesInSection(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		def SubStringComesInsideSection(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("---♥♥...**---")
		
		? o1.SubStringComesBetween("...", "♥♥", "**")
		#--> TRUE
		
		? o1.SubStringComesBetween("...", "**", "♥♥")
		#--> TRUE

		*/

		if CheckingParams()
			if isList(pcSubStr1) and StzListQ(pcSubStr1).IsSubStringsNamedParam()
				pcSubStr1 = pcSubStr1[2]
			ok
	
			if isList(pcSubStr2) and StzListQ(pcSubStr2).IsAndNamedParam()
				pcSubStr2 = pcSubStr2[2]
			ok
		ok

		n1 = This.FindFirstCS(pcSubStr1, pCaseSensitive)
		n2 = This.FindLastCS(pcSubStr2, pCaseSensitive)
		bOk1 = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)

		n1 = This.FindFirstCS(pcSubStr2, pCaseSensitive)
		n2 = This.FindLastCS(pcSubStr1, pCaseSensitive)
		bOk2 = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)

		bResult = bOk1 or bOk2

		return bResult

		def SubStringComesBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, p2CaseSensitive)
			return This.SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, p2CaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
		return This.SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		def SubStringComesBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This.SubStringIsBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

	  #=============================================================================#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING BY RETURNING THEIR SECTIONS  #
	#=============================================================================#

	def FindBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		aSection1 = [1, 1]
		if This.HasLeadingCharsCS(pCaseSensitive)
			aSection1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		ok

		aSection2 = [1, 1]
		if This.HasTrailingCharsCS(pCaseSensitive)
			aSection2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ aSection1, aSection2 ]
		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindStringBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBoundsAsSections()
		return This.FindBoundsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSections()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()

		#--

		def FindBoundsZZ()
			return This.FindBoundsAsSections()

		def FindStringBoundsZZ()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsZZ()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondoundsZZ()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsZZ()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsZZ()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsZZ()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsZZ()
				return This.FindBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		aResult = [
			This.FindTrailingCharsAsSectionCS(pCaseSensitive),
			This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindSecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBoundsAsSections()
		return This.FindLastAndFirstBoundsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		#--

		def FindLastAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindSecondAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftAndRightBoundsAsSections()
		return This.FindLeftAndRightBoundsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSections()
			return This.FindLeftAndRightBoundsAsSections()

		#--

		def FindLeftAndRightBoundsZZ()
			return This.FindLeftAndRightBoundsAsSections()

		def FindStringLeftAndRightBoundsZZ()
			return This.FindLeftAndRightBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0] , [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSectionsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		def FindStringRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightAndLeftBoundsAsSections()
		return This.FindRightAndLeftBoundsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSections()
			return This.FindRightAndLeftBoundsAsSections()

		#--

		def FindRightAndLeftBoundsZZ()
			return This.FindRightAndLeftBoundsAsSections()

		def FindStringRightAndLeftBoundsZZ()
			return This.FindRightAndLeftBoundsAsSections()

		#>

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDED (HAS BOUNDS)  #
	#==================================================#

	def IsBoundedCS(pCaseSensitive)
		if This.NumberOfChars() > 2
			return 1
		else
			return 0
		ok

		def HasBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

		def ContainsBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsBounded()
		return This.IsBoundedCS(1)

		def HasBounds()
			return This.IsBounded()

		def ContainsBounds()
			return This.HasBounds()

	  #-------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def FindBoundsCS(pCaseSensitive)
		#TODO
		# Reveiew it! Many be non accurate

		aResult = [
			This.FindLeadingCharsCS(pCaseSensitive),
			This.FindTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBounds()
		return This.FindBoundsCS(1)

		#< @FunctionAlternativeForms

		def FindStringBounds()
			return This.FindBounds()

		def FindFirstAndLastBounds()
			return This.FindBounds()

			def FindFirstAndSecondBounds()
				return This.FindBounds()
	
		def FindFirstAndLastStringBounds()
			return This.FindBounds()

			def FindFirstAndSecondStringBounds()
				return This.FindBounds()
	
		def FindStringFirstAndLastBounds()
			return This.FindBounds()

			def FindStringFirstAndSecondBounds()
				return This.FindBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLastAndFirstBoundsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsCS(pCaseSensitive),
			This.FindLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBounds()
		return This.FindLastAndFirstBoundsCS(1)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringLastAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLeftAndRightBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringLeftAndRightBoundsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsCS(pCaseSensitive)

	#--

	def FindLeftAndRightBounds()
		return This.FindLeftAndRightBoundsCS(1)

		def FindStringLeftAndRightBounds()
			return This.FindLeftAndRightBounds()

	  #--------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindRightAndLeftBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)
			
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringRightAndLeftBoundsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsCS(pCaseSensitive)

	#--

	def FindRightAndLeftBounds()
		return This.FindRightAndLeftBoundsCS(1)

		def FindStringRightAndLeftBounds()
			return This.FindRightAndLeftBounds()

	  #---------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#===============================================================#

	def FindBoundsCSXT(panLenBounds, pCaseSensitive)
		return This.FindBoundsCS(panLenBounds, pCaseSensitive)

		#< @FunctioAlternativeForms

		def FindStringBoundsCSXT(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXT(panLenBounds, pCaseSensitive)

		def FindBoundsCSXTZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXT(panLenBounds, pCaseSensitive)

		def FindStringBoundsCSXTZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXT(panLenBounds, pCaseSensitive)

		#>

	def FindBoundsXT(panLenBounds)
		return This.FindBoundsCSXT(panLenBounds, 1)

		#< @FunctionAlternativeForms

		def FindStringBoundsXT(panLenBounds)
			return This.FindBoundsXT(panLenBounds)

		def FindBoundsXTZ(panLenBounds)
			return This.FindBoundsCSXT(panLenBounds)

		def FindStringBoundsXTZ(panLenBounds)
			return This.FindBoundsXT(panLenBounds)

		#>

	  #-------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#-------------------------------------------------#

	def FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)

		if CheckingParams()
			if islist(panLenBounds) and StzListQ(panLenBounds).IsUpToNCharsNamedParam()
				panLenBounds = panLenBounds[2]
			ok

			if isNumber(panLenBounds)
				nTemp = panLenBounds
				panLenBounds = [ nTemp, nTemp ]
			ok

			if NOT ( isList(panLenBounds) and len(panLenBounds) = 2 and
				 isNumber(panLenBounds[1]) and isNumber(panLenBounds[2]) )

				StzRaise("Incorrect param type! panLenBounds must be a number or pair of numbers.")

			ok
		ok

		n1 = panLenBounds[1]
		n2 = panLenBounds[2]

		aSections = This.FindBoundsCSZZ(pCaseSensitive)
		if len(aSections) = 0
			return []
		ok

		aBound1 = aSections[1]
		aBound2 = aSections[2]

		nLenBound1 = aBound1[2] - aBound1[1] + 1
		if n1 < nLenBound1
			aBound1[2] = aBound1[1] + n1 - 1
		ok

		aResult = []

		nLenBound2 = aBound2[2] - aBound1[2] + 1
		if n2 < nLenBound2
			nTemp = aBound2[1] + n2 - 1
			if nTemp < aBound2[2]
				aBound2[2] = aBound2[1] + n2 - 1
			ok
		ok

		return [ aBound1, aBound2 ]

		#< @FunctioAlternativeForms

		def FindStringBoundsCSXTZZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)

		#--

		def FindBoundsAsSectionsCSXT(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)

		def FindStringBoundsAsSectionsCSXT(panLenBounds, pCaseSensitive)
			return This.FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def FindBoundsXTZZ(panLenBounds)
		return This.FindBoundsCSXTZZ(panLenBounds, 1)

		#< @FunctioAlternativeForms

		def FindStringBoundsXTZZ(panLenBounds)
			return This.FindBoundsXTZZ(panLenBounds)

		#--

		def FindBoundsAsSectionsXT(panLenBounds)
			return This.FindBoundsXTZZ(panLenBounds)

		def FindStringBoundsAsSectionsXT(panLenBounds)
			return This.FindBoundsXTZZ(panLenBounds)

		#>

	  #-------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def BoundsCSXT(panLenBounds, pCaseSensitive)
		aSections = This.FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)
		return This.Sections(aSections)

		def StringBoundsCSXT(panLenBounds, pCaseSensitive)
			return This.BoundsCSXT(panLenBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def BoundsXT(panLenBounds)
		return This.BoundsCSXT(panLenBounds, 1)

		def StringBoundsXT(panLenBounds)
			return This.BoundsXT(panLenBounds)

	  #---------------------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING UP TO N CHARS  #
	#===============================================================#

	def FindBoundsUpToNCharsCS(panLenBounds, pCaseSensitive)

		anResult = This.FindBoundsCSXT(panLenBounds, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindStringBoundsUpToNCharsCS(panLenBounds, pCaseSensitive)
			return This.FindBoundsToNCharsCS(panLenBounds, pCaseSensitive)

		def FindBoundsUpToNCharsCSZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsUpToNCharsCS(panLenBounds, pCaseSensitive)

		def FindStringBoundsUpToNCharsCSZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsToNCharsCS(panLenBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSISITIVITY

	def FindBoundsUpToNChars(panLenBounds)
		return This.FindBoundsUpToNCharsCS(panLenBounds, 1)

		#< @FunctionAlternativeForms

		def FindStringBoundsUpToNChars(panLenBounds)
			return This.FindBoundsToNChars(panLenBounds)

		def FindBoundsUpToNCharsZ(panLenBounds)
			return This.FindBoundsUpToNChars(panLenBounds)

		def FindStringBoundsUpToNCharsZ(panLenBounds)
			return This.FindBoundsToNChars(panLenBounds)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) THE TWO BOUNDS (IF ANY) OF THE STRING UP TO N CHARS  #
	#------------------------------------------------------------------------------#

	def FindBoundsUpToNCharsCSZZ(panLenBounds, pCaseSensitive)

		aResult = This.FindBoundsCSXTZZ(panLenBounds, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsUpToNCharsCSZZ(panLenBounds, pCaseSensitive)
			return This.FindBoundsToNCharsCSZZ(panLenBounds, pCaseSensitive)

		#--

		def FindBoundsToNCharsAsSectionsCS(panLenBounds, pCaseSensitive)
			return This.FindBoundsToNCharsCSZZ(panLenBounds, pCaseSensitive)

		def FindStringBoundsUpToNCharsAsSectionsCS(panLenBounds, pCaseSensitive)
			return This.FindBoundsToNCharsCSZZ(panLenBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSISITIVITY

	def FindBoundsUpToNCharsZZ(panLenBounds)
		return This.FindBoundsUpToNCharsCSZZ(panLenBounds, 1)

		#< @FunctionAlternativeForms

		def FindStringBoundsUpToNCharsZZ(panLenBounds)
			return This.FindBoundsToNCharsZZ(panLenBounds)

		#--

		def FindBoundsToNCharsAsSections(panLenBounds)
			return This.FindBoundsToNCharsZZ(panLenBounds)

		def FindStringBoundsUpToNCharsAsSections(panLenBounds)
			return This.FindBoundsToNCharsZZ(panLenBounds)

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING UP TO N CHARS  #
	#---------------------------------------------------------------#

	def BoundsUpToNCharsCS(panLenBounds, pCaseSensitive)

		aResult = This.BoundsCSXT(panLenBounds, pCaseSensitive)
		return aResult

		def StringBoundsUpToNCharsCS(panLenBounds, pCaseSensitive)
			return This.BoundsToNCharsCS(panLenBounds, pCaseSensitive)

	#-- WITHOUT CASESENSISITIVITY

	def BoundsUpToNChars(panLenBounds)
		return This.BoundsUpToNCharsCS(panLenBounds, 1)

		def StringBoundsUpToNChars(panLenBounds)
			return This.BoundsUpToNChars(panLenBounds)

	  #-------------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING -- XT  #
	#=======================================================#

	def BoundsCS(pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("<<Ring>>")
		? o1.Bounds()
		#--> [ "<<", ">>" ]

		EXAMPLE 2

		o1 = new stzString("---Ring___")
		? o1.Bounds()
		#--> [ "---, "___" ]

		EXAMPLE 3

		o1 = new stzString("Ring")
		? o1.Bounds()
		#--> [ "R", "g" ]

		*/

		acResult = []

		if This.ContainsLeadingAndTrailingCharsCS(pCaseSensitive)

			acResult = [
				This.LeadingCharsAsStringCS(pCaseSensitive),
				This.TrailingCharsAsStringCS(pCaseSensitive)
			]

		else

			acResult = [ This.FirstChar(), This.LastChar() ]
		ok

		return acResult

		#< @FunctionAlternativeForms

		def StringBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def FirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFristAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def Bounds()
		return This.BoundsCS(1)

		#< @FunctionAlternativeForms

		def StringBounds()
			return This.Bounds()

		def FirstAndLastBounds()
			return This.Bounds()

		def StringFirstAndLastBounds()
			return This.Bounds()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBounds()
			return This.Bounds()

		def StringFristAndLastBounds()
			return This.Bounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LastAndFirstBoundsCS(pCaseSensitive)
		acResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FirstBoundCS(pCaseSensitive)
		]

		return acResult

		#< @FunctionAlternatoveForms

		def SecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringLastAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBounds()
		return This.LastAndFirstBoundsCS(1)

		#< @FunctionAlternatoveForms

		def SecondAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringLastAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringSecondAndFirstBounds()
			return This.LastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LeftAndRightBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = This.LastBoundCS(pCaseSensitive)

		else
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = Thus.FirstBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringLeftAndRightBoundsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBounds()
		return This.LeftAndRightBoundsCS(1)

		def StringLeftAndRightBounds()
			return This.LeftAndRightBoundsCS()

	  #--------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def RightAndLeftBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = This.FirstBoundCS(pCaseSensitive)

		else
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = Thus.LastBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringRightAndLeftBoundsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBounds()
		return This.RightAndLeftBoundsCS(1)

		def StringRightAndLeftBounds()
			return This.RightAndLeftBoundsCS()

	  #------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#========================================================================#

	def BoundsCSZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def FirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def FristAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFristAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFristAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZ()
		return This.BoundsCSZ(1)

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositions()
			return This.BoundsZ()

		def StringBoundsZ()
			return This.BoundsZ()

		def StringBoundsAndTheirPositions()
			return This.BoundsZ()

		#--

		def FirstAndLastBoundsZ()
			return This.BoundsZ()

		def FirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFirstAndLastBoundsZ()
			return This.BoundsZ()

		def StringFirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsZ()
			return This.BoundsZ()

		def FristAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFristAndLastBoundsZ()
			return This.BoundsZ()

		def StringFristAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------------------#

	def BoundsCSZZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def FirstAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def FristAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFristAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFristAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZZ()
		return This.BoundsCSZZ(1)

		#< @FunctionAlternativeForms

		def BoundsAndTheirSections()
			return This.BoundsZZ()

		def StringBoundsZZ()
			return This.BoundsZZ()

		def StringBoundsAndTheirSrctions()
			return This.BoundsZZ()

		#--

		def FirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def FirstAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>


		#< @FunctionMisspelledForms

		def FristAndLastBoundsZZ()
			return This.BoundsZZ()

		def FristAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFristAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFristAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZ()
		return This.LastAndFirstBoundsCSZ(1)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

		def LastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def SecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsZ()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZZ()
		return This.LastAndFirstBoundsCSZZ(1)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

		def LastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def SecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsZZ()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZ()
		return This.LeftAndrightBoundsCSZ(1)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsZ()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZZ()
		return This.LeftAndRightBoundsCSZZ(1)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndrightBoundsZZ()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ(pCaseSensitive)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZ()
		return This.RightAndLeftBoundsCSZ(1)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsZ()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZZ()
		return This.RightAndLeftBoundsCSZZ(1)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSections()
		return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsZZ()
			return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsAndTheirSections()
			return This.RightAndLeftBoundsZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING  #
	#=========================================#

	def FindFirstBoundCS(pCaseSensitive)
		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			return 1
		else
			return 0
		ok

		def FindStringFirstBoundCS(pCaseSensitive)
			return This.FindFirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBound()
		return This.FindFirstBoundCS(1)

		def FindStringFirstBound()
			return This.FindFirstBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			anResult + 1 + n
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringFirstBoundAsSectionCS(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		#--

		def FindFirstBoundCSZZ(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		def FindStringFirstBoundCSZZ(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBoundAsSection()
		return This.FindFirstBoundAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindStringFirstBoundAsSection()
			return This.FindFirstBoundAsSection()

		#--

		def FindFirstBoundZZ()
			return This.FindFirstBoundAsSection()

		def FindStringFirstBoundZZ()
			return This.FindFirstBoundAsSection()

		#>

	  #-----------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING  #
	#-----------------------------------------#

	def FirstBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[1]
		return cResult

		def StringFirstBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

		#-- MISSPELLED

		def FristBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

		def StringFristBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstBound()
		return This.FirstBoundCS(1)

		def StringFirstBound()
			return This.FirstBound()

		#-- MISSPELLED

		def FristBound()
			return This.FirstBound()

		def StringFristBound()
			return This.FirstBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def FirstBoundCSZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def FristBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFristBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFristBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZ()
		return This.FirstBoundCSZ(1)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFirstBoundZ()
			return This.FirstBoundZ()

		def StringFirstBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

		#< @FunctionMisspelledForms

		def FristBoundZ()
			return This.FirstBoundZ()

		def FristBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFristBoundZ()
			return This.FirstBoundZ()

		def StringFristBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def FirstBoundCSZZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundCSZZ(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristBoundCSZZ(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def FristBoundAndItsSectionCS(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def StringFristBoundCSZZ(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def StringFristBoundAndItsSectionCS(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZZ()
		return This.FirstBoundCSZZ(1)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFirstBoundZZ()
			return THis.FirstBoundZZ()

		def StringFirstBoundAndItsSection()
			return THis.FirstBoundZZ()

		#>

		#< @FunctionMisspelledForms

		def FristBoundZZ()
			return This.FirstBoundZZ()

		def FristBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFristBoundZZ()
			return This.FirstBoundZZ()

		def StringFristBoundAndItsSection()
			return This.FirstBoundZZ()

		#>

		#TODO // Complete to add misspelled forms to all functions
		# containing First in their names

	  #----------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING  #
	#========================================#

	def FindLastBoundCS(pCaseSensitive)
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			return This.NumberOfChars() - n + 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindStringLastBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindStringSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBound()
		return This.FindLastBoundCS(1)

		#< @FunctionAlternativeForms

		def FindStringLastBound()
			return This.FindLastBound()

		def FindSecondBound()
			return This.FindLastBound()

		def FindStringSecondBound()
			return This.FindLastBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			nLen = This.NumberOfChars()
			anResult + (nLen - n + 1) + nLen
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#--

		def FindLastBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringLastBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBoundAsSection()
		return This.FindLastBoundAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		#--

		def FindLastBoundZZ()
			return This.FindLastBoundAsSection()

		def FindStringLastBoundZZ()
			return This.FindLastBoundAsSection()

		def FindSecondBoundZZ()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundZZ()
			return This.FindLastBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING  #
	#----------------------------------------#

	def LastBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[2]
		return cResult

		#< @FunctionAlternativeForms

		def StringLastBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def SecondBoundCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def StringSecondBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBound()
		return This.LastBoundCS(1)

		#< @FunctionAlternativeForms

		def StringLastBounds()
			return This.LastBound()

		def SecondBound()
			return This.LastBound()

		def StringSecondBounds()
			return This.LastBound()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LastBoundCSZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZ(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def LastBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def SecondBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZ()
		return This.LastBoundCSZ(1)

		#< @FunctionAlternativeForms

		def SecondBoundZ()
			return This.LastBoundZ()

		def LastBoundAndItsPosition()
			return This.LastBoundZ()

		def SecondBoundAndItsPosition()
			return This.LastBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LastBoundCSZZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZZ(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def LastBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def SecondBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZZ()
		return This.LastBoundCSZZ(1)

		#< @FunctionAlternativeForms

		def SecondBoundZZ()
			return This.LastBoundZZ()

		def LastBoundAndItsSection()
			return This.LastBoundZZ()

		def SecondBoundAndItsSection()
			return This.LastBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING  #
	#========================================#

	def FindLeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundCSZ(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		def FindStringLeftBoundCS(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		def FindStringLeftBoundCSZ(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBound()
		return This.FindLeftBoundCS(1)

		#< @FunctionAlternativeForms

		def FindLeftBoundZ()
			return This.FindLeftBound()

		def FindStringLeftBound()
			return This.FindLeftBound()

		def FindStringLeftBoundZ()
			return This.FindLeftBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLeftBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindStringLeftBoundAsSectionCS(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		#--

		def FindLeftBoundCSZZ(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		def FindStringLeftBoundCSZZ(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBoundAsSection()
		return This.FindLeftBoundAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindStringLeftBoundAsSection()
			return This.FindLeftBoundAsSection()

		#--

		def FindLeftBoundZZ()
			return This.FindLeftBoundAsSection()

		def FindStringLeftBoundZZ()
			return This.FindLeftBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING  #
	#----------------------------------------#

	def LeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[1]

		else # case IsRightToLeft()
			return This.BoundsCS(pCaseSensitive)[2]
		ok


		def StringLeftBoundCS(pCaseSensitive)
			return This.LeftBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftBound()
		return This.LeftBoundCS(1)

		def StringLeftBound()
			return This.LeftBound()

	  #----------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LeftBoundCSZ(pCaseSensitive)
		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundCSZ(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundAbdItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZ()
		return This.LeftBoundCSZ(1)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPosition()
			return This.LeftBoundZ()

		def StringLeftBoundZ()
			return This.LeftBoundZ()

		def StringLeftBoundAbdItsPosition()
			return This.LeftBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LeftBoundCSZZ(pCaseSensitive)

		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundCSZZ(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundAbdItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZZ()
		return This.LeftBoundCSZZ(1)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSection()
			return This.LeftBoundZZ()

		def StringLeftBoundZZ()
			return This.LeftBoundZZ()

		def StringLeftBoundAbdItsSection()
			return This.LeftBoundZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING  #
	#=========================================#

	def FindRightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundCSZ(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		def FindStringRightBoundCS(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		def FindStringRightBoundCSZ(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightBound()
		return This.FindRightBoundCS(1)

		#< @FunctionAlternativeForms

		def FindRightBoundZ()
			return This.FindRightBound()

		def FindStringRightBound()
			return This.FindRightBound()

		def FindStringRightBoundZ()
			return This.FindRightBound()

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindRightBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundCSZZ(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		def FindStringRightBoundAsSectionCS(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		def FindStringRightBoundCSZZ(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightBoundAsSection()
		return This.FindRightBoundAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindRightBoundZZ()
			return This.FindRightBoundAsSection()

		def FindStringRightBoundAsSection()
			return This.FindRightBoundAsSection()

		def FindStringRightBoundZZ()
			return This.FindRightBoundAsSection()

		#>

	  #-----------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING  #
	#-----------------------------------------#

	def RightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[2]

		else # case IsRightToRight()
			return This.BoundsCS(pCaseSensitive)[1]
		ok

		def StringRightBoundCS(pCaseSensitive)
			return This.RightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightBound()
		return This.RightBoundCS(1)

		def StringRightBound()
			return This.RightBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def RightBoundCSZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundCSZ(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZ()
		return This.RightBoundCSZ(1)

		#< @FunctionAlternativeForms

		def RightBoundAndItsPosition()
			return This.RightBoundZ()

		def StringRightBoundZ()
			return This.RightBoundZ()

		def StringRightBoundAndItsPosition()
			return This.RightBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def RightBoundCSZZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundCSZZ(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZZ()
		return This.RightBoundCSZZ(1)

		#< @FunctionAlternativeForms

		def RightBoundAndItsSection()
			return This.RightBoundZZ()

		def StringRightBoundZZ()
			return This.RightBoundZZ()

		def StringRightBoundAndItsSection()
			return This.RightBoundZZ()

		#>

	  #---------------------------------#
	 #  REMOVING BOUNDS OF THE STRING  #
	#=================================#

	def RemoveStringBoundsCS(pCaseSensitive)

		if This.IsBoundedCS(pCaseSensitive)
			aSections = This.FindStringBoundsAsSectionsCS(pCaseSensitive)
			This.RemoveSections(aSections)
		ok

		#< @FunctionFluentForm

		def RemoveStringBoundsCSQ(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveBoundsCSQ(pCaseSensitive)
				This.RemoveBoundsCS(pCaseSensitive)
				return This
	
		#--

		def RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveStringFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndSecondBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#>

	def StringBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveStringBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringFirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringFirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringSecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def SecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringRightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def RightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringBounds()
		return This.RemoveStringBoundsCS(1)

		#< @FunctionFluentForm

		def RemoveStringBoundsQ()
			This.RemoveStringBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBounds()
			This.RemoveStringBounds()

			def RemoveBoundsQ()
				This.RemoveBounds()
				return This
	
		#--

		def RemoveStringFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndLastBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		def RemoveStringFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndSecondBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		#--

		def RemoveFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndLastBoundsQ()
				This.RemoveFirstAndLastBounds()
				return This

		def RemoveFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndSecondBoundsQ()
				This.RemoveFirstAndSecondBounds()
				return This

		#--

		def RemoveStringLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringLastAndFirstBoundsQ()
				This.RemoveStringLastAndFirstBounds()
				return This

		def RemoveStringSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringSecondAndFirstBoundsQ()
				This.RemoveStringSecondAndFirstBounds()
				return This

		#--

		def RemoveLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveLastAndFirstBoundsQ()
				This.RemoveLastAndFirstBounds()
				return This

		def RemoveSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveSecondAndFirstBoundsQ()
				This.RemoveSecondAndFirstBounds()
				return This

		#--

		def RemoveStringLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveStringLeftAndRightBoundsQ()
				This.RemoveStringLeftAndRightBounds()
				return This

		#--

		def RemoveLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveLeftAndRightBoundsQ()
				This.RemoveLeftAndRightBounds()
				return This

		#--

		def RemoveStringRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveStringRightAndLeftBoundsQ()
				This.RemoveStringRightAndLeftBounds()
				return This

		#--

		def RemoveRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveRightAndLeftBoundsQ()
				This.RemoveRightAndLeftBounds()
				return This

		#>

	def StringBoundsRemoved()
		cResult = This.Copy().RemoveStringBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringFirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringFirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def LastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringSecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def SecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		def LeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringRightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		def RightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		#>

	  #--------------------------------------#
	 #  REMOVING LEFT BOUND OF THE STRING   #
	#======================================#

	def RemoveStringLeftBoundCS(pCaseSensitive)
	
		cBounds = This.LeftBoundCS(pCaseSensitive)
		This.RemoveFromLeftCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundCSQ(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundCS(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)

			def RemoveLeftBoundCSQ(pCaseSensitive)
				This.RemoveLeftBoundCS(pCaseSensitive)
				return This

		#>

	def StringLeftBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pCaseSensitive).Content()
		return cResult

		def LeftBoundRemovedCS(pCaseSensitive)
			return This.StringLeftBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLeftBound()
		This.RemoveStringLeftBoundCS(1)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundQ()
			This.RemoveStringLeftBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBound()
			This.RemoveStringLeftBound()

			def RemoveLeftBoundQ()
				This.RemoveLeftBound()
				return This

		#>

	def StringLeftBoundRemoved()
		cResult = This.Copy().RemoveStringLeftBoundQ().Content()
		return cResult

		def LeftBoundRemoved()
			return This.StringLeftBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringRightBoundCS(pCaseSensitive)
	
		cBounds = This.RightBoundCS(pCaseSensitive)
		This.RemoveFromRightCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringRightBoundCSQ(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundCS(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)

			def RemoveRightBoundCSQ(pCaseSensitive)
				This.RemoveRightBoundCS(pCaseSensitive)
				return This

		#>

	def StringRightBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pCaseSensitive).Content()
		return cResult

		def RightBoundRemovedCS(pCaseSensitive)
			return This.StringRightBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringRightBound()
		This.RemoveStringRightBoundCS(1)

		#< @FunctionFluentForm

		def RemoveStringRightBoundQ()
			This.RemoveStringRightBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBound()
			This.RemoveStringRightBound()

			def RemoveRightBoundQ()
				This.RemoveRightBound()
				return This

		#>

	def StringRightBoundRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundQ().Content()
		return cResult

		def RightBoundRemoved()
			return This.StringRightBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING FIRST BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringFirstBoundCS(pCaseSensitive)
	
		cBounds = This.FirstBoundCS(pCaseSensitive)
		This.RemoveFromStartCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundCSQ(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundCS(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)

			def RemoveFirstBoundCSQ(pCaseSensitive)
				This.RemoveFirstBoundCS(pCaseSensitive)
				return This

		#>

	def StringFirstBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pCaseSensitive).Content()
		return cResult

		def FirstBoundRemovedCS(pCaseSensitive)
			return This.StringFirstBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringFirstBound()
		This.RemoveStringFirstBoundCS(1)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundQ()
			This.RemoveStringFirstBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBound()
			This.RemoveStringFirstBound()

			def RemoveFirstBoundQ()
				This.RemoveFirstBound()
				return This

		#>

	def StringFirstBoundRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundQ().Content()
		return cResult

		def FirstBoundRemoved()
			return This.StringFirstBoundRemoved()

	  #--------------------------------------#
	 #  REMOVING LAST BOUND OF THE STRING   #
	#--------------------------------------#

	def RemoveStringLastBoundCS(pCaseSensitive)
	
		cBounds = This.LastBoundCS(pCaseSensitive)
		This.RemoveFromEndCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLastBoundCSQ(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveLastBoundCSQ(pCaseSensitive)
				This.RemoveLastBoundCS(pCaseSensitive)
				return This


		def RemoveStringSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveStringSecondBoundCSQ(pCaseSensitive)
				This.RemoveStringSecondBoundCS(pCaseSensitive)
				return This

		def RemoveSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveSecondBoundCSQ(pCaseSensitive)
				This.RemoveSecondBoundCS(pCaseSensitive)
				return This

		#>

	def StringLastBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def StringSecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def SecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLastBound()
		This.RemoveStringLastBoundCS(1)

		#< @FunctionFluentForm

		def RemoveStringLastBoundQ()
			This.RemoveStringLastBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBound()
			This.RemoveStringLastBound()

			def RemoveLastBoundQ()
				This.RemoveLastBound()
				return This


		def RemoveStringSecondBound()
			This.RemoveStringLastBound()

			def RemoveStringSecondBoundQ()
				This.RemoveStringSecondBound()
				return This

		def RemoveSecondBound()
			This.RemoveStringLastBound()

			def RemoveSecondBoundQ()
				This.RemoveSecondBound()
				return This

		#>

	def StringLastBoundRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemoved()
			return This.StringLastBoundRemoved()

		def StringSecondBoundRemoved()
			return This.StringLastBoundRemoved()

		def SecondBoundRemoved()
			return This.StringLastBoundRemoved()

		#>

	  #--------------------------------------#
	 #  FINDING THE GIVEN SUBSTRING BOUNDS  #
	#======================================#

	def FindTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = []

		for i = 1 to nLen step 2

			# Checking the bounds

			if aSections[i][2] - aSections[i][1] + 1 != nLenBound1
				loop
			ok

			if aSections[i+1][2] - aSections[i+1][1] + 1 != nLenBound2
				loop
			ok

			if NOT This.SectionQ(aSections[i][1], aSections[i][2]).IsEqualToCS(cBound1, pCaseSensitive)
				loop
			ok

			if NOT This.SectionQ(aSections[i+1][1], aSections[i+1][2]).IsEqualToCS(cBound2, pCaseSensitive)
				loop
			ok

			# Checking the substring

			n1 = aSections[i][2]+1
			n2 = aSections[i+1][1]-1

			if NOT (n2 - n1 + 1 = nLenSubStr)
				loop
			ok

			if This.SectionQ(n1, n2).IsEqualToCS(pcSubStr, pCaseSensitive)
				anResult + aSections[i][1] + aSections[i+1][1]
			ok
		next

		return anResult

		def FindTheseSubStringBoundsCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringBounds(pcSubStr, pacBounds)
		return This.FindTheseSubStringBoundsCS(pcSubStr, pacBounds, 1)

		def FindTheseSubStringBoundsZ(pcSubStr, pacBounds)
			return This.FindTheseSubStringBounds(pcSubStr, pacBounds)

	  #------------------------------------------------------#
	 #  FINDING THE GIVEN SUBSTRING BOUNDS -- ZZ/EXTENSION  #
	#------------------------------------------------------#

	def FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = []

		for i = 1 to nLen step 2

			# Checking the bounds

			if aSections[i][2] - aSections[i][1] + 1 != nLenBound1
				loop
			ok

			if aSections[i+1][2] - aSections[i+1][1] + 1 != nLenBound2
				loop
			ok

			if NOT This.SectionQ(aSections[i][1], aSections[i][2]).IsEqualToCS(cBound1, pCaseSensitive)
				loop
			ok

			if NOT This.SectionQ(aSections[i+1][1], aSections[i+1][2]).IsEqualToCS(cBound2, pCaseSensitive)
				loop
			ok

			# Checking the substring

			n1 = aSections[i][2]+1
			n2 = aSections[i+1][1]-1

			if NOT (n2 - n1 + 1 = nLenSubStr)
				loop
			ok

			if This.SectionQ(n1, n2).IsEqualToCS(pcSubStr, pCaseSensitive)
				aResult + aSections[i] + aSections[i+1]
			ok
		next

		return aResult

		def FindTheseSubStringBoundsAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringBoundsZZ(pcSubStr, pacBounds)
		return This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, 1)

		def FindTheseSubStringBoundsAsSections(pcSubStr, pacBounds)
			return This.FindTheseSubStringBoundsZZ(pcSubStr, pacBounds)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR POSITIONS  #
	#=====================================================================================#

	#NOTE #AI #CHATGPT
	# This function has been designed by the aid of ChatGPT

	def FindTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
		/* EXAMPLE

		#                       5     11             26        36    42
		o1 = new stzString("The <<Ring>> programming <<language>> is <<Waooo!>>")
		? o1.FindTheseBounds("<<", ">>")

		*/

		nLen = This.NumberOfChars()
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()
		nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

		anResult = []
		nPos = 1

		while nPos < nLen

	        	n1 = This.FindFirstSTCS(pcBound1, nPos, pCaseSensitive)

	        	if n1 = 0
	            		exit
	       		 ok

	        	n2 = This.FindFirstSTCS(pcBound2, n1 + nLenBound1, pCaseSensitive)
	       		if n2 = 0
	            		exit
			ok
	        
	       		anResult + n1 + n2      
	        	nPos = n2
	    	end
	    
	   	return anResult


		#< @FunctionAlternativeForms

		def FindTheseBoundsCSZ(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseBounds(pcBound1, pcBound2)
		return This.FindTheseBoundsCS(pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForms

		def FindTheseBoundsZ(pcBound1, pcBound2)
			return This.FindTheseStringBounds(pcBound1, pcBound2)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR SECTIONS  #
	#------------------------------------------------------------------------------------#

	#NOTE #AI #CHATGPT
	# This function has been designed by the aid of ChatGPT

	def FindTheseBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

		nLen = This.NumberOfChars()
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()
		nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

		aResult = []
		nPos = 1

		while nPos < nLen

	        	n1 = This.FindFirstSTCS(pcBound1, nPos, pCaseSensitive)

	        	if n1 = 0
	            		exit
	       		 ok

	        	n2 = This.FindFirstSTCS(pcBound2, n1 + nLenBound1, pCaseSensitive)
	       		if n2 = 0
	            		exit
			ok
	        
	       		aResult + [ n1, n1 + nLenBound1 - 1 ] + [ n2, n2 + nLenBound2 - 1 ]     
	        	nPos = n2
	    	end
	    
	   	return aResult


		#< @FunctionAlternativeForms

		def FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseBoundsZZ(pcBound1, pcBound2)
		return This.FindTheseBoundsCSZZ(pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForms

		def FindTheseBoundsAsSections(pcBound1, pcBound2)
			return This.FindTheseBoundsZZ(pcBound1, pcBound2)

		#>

	  #--------------------------------------------------------#
	 #  REMOVING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING  #
	#========================================================#

	def RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def TheseBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseBounds(pcBound1, pcBound2)
		return This.RemoveTheseBoundsCS(pcBound1, pcBound2, 1)

		#< @FunctionFluentForm

		def RemoveTheseBoundsQ(pcBound1, pcBound2)
			This.RemoveTheseBounds(pcBound1, pcBound2)
			return This

		#>

	def TheseBoundsRemoved(pcBound1, pcBound2)
		cResult = This.Copy().RemoveTheseBoundsQ(pcBound1, pcBound2).Content()
		return cResult

	  #---------------------------------#
	 #  SWAPPING BOUNDS OF THE STRING  #
	#=================================#

	def SwapBoundsCS(pCaseSensitive)
		aSections = This.FindBoundsAsSectionsCS(pCaseSensitive)
		This.SwapSections( aSections[1], aSections[2] )

		#< @FunctionFluentForm

		def SwapBoundsCSQ(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBoundsCS(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)

			def SwapStringBoundsCSQ(pCaseSensitive)
				This.SwapStringBoundsCS(pCaseSensitive)
				return This

		#>

	def BoundsSwappedCS(pCaseSensitive)
		cResult = This.Copy(). SwapBoundsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SwapBounds()
		return This.SwapBoundsCS(1)

		#< @FunctionFluentForm

		def SwapBoundsQ()
			This.SwapBounds()
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBounds()
			This.SwapBounds()

			def SwapStringBoundsQ()
				This.SwapStringBounds()
				return This

		#>

	def BoundsSwapped()
		cResult = This.Copy(). SwapBoundsQ().Content()
		return cResult

		def StringBoundsSwapped()
			return This.BoundsSwapped()


	  #=======================================================================#
	 #  FINDING (AS SECTIONS) THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=======================================================================#

	def FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		n = This.NumberOfChars()
		# To be sure n exceeds the size of the largest bound, since we know that
		# the called function returns all the chars in this case

		aResult = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSections(pcSubStr)
		return This.FindSubStringBoundsAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsZZ(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		def FindBoundsOfAsSections(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		def FindBoundsOfZZ(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING -- XT  #
	#-----------------------------------------------------------------------------#

	def FindSubStringBoundsAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		aResult = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSXTZZ(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		def FindBoundsOfAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		def FindBoundsOfCSXTZZ(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSectionsXT(pcSubStr, panLenBounds)
		return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, 1, panLenBounds)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsXTZZ(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, panLenBounds)

		def FindBoundsOfAsSectionsXT(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, panLenBounds)

		def FindBoundsOfXTZZ(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, panLenBounds)

		#>

	  #---------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def FindSubStringBoundsCS(pcSubStr, pCaseSensitive)
		n = This.NumberOfChars()
		# To be sure n exceeds the size of the largest bound, since we know that
		# the called function returns all the chars in this case

		aResult = This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBounds(pcSubStr)
		return This.FindSubStringBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsZ(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		def FindBoundsOf(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		def FindBoundsOfZ(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING -- XT  #
	#---------------------------------------------------------------#

	def FindSubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		aResult = This.FindSubStringBoundsUpToNCharsCS(pcSubStr, panLenBounds,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSXTZ(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		def FindBoundsOfCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		def FindBoundsOfCSXTZ(pcSubStr, panLenBounds, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsXT(pcSubStr, panLenBounds)
		return This.FindSubStringBoundsCSXT(pcSubStr, 1, panLenBounds)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsXTZ(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsXT(pcSubStr, panLenBounds)

		def FindBoundsOfXT(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsXT(pcSubStr, panLenBounds)

		def FindBoundsOfXTZ(pcSubStr, panLenBounds)
			return This.FindSubStringBoundsXT(pcSubStr, panLenBounds)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS AS SECTIONS - UP TO [ N1, N2 ] CHARS - OF A GIVEN SUBSTRING   #
	#===================================================================================#

	def FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds, pCaseSensitive)
		#< @MotherFunctionOf = FindAsSectionsCS() #>

		if CheckingParams()
			if isList(panLenBounds) and StzListQ(panLenBounds).IsUpToNCharsNamedParam()
				panLenBounds = panLenBounds[2]
			ok

			if isNumber(panLenBounds)
				nTemp = panLenBounds
				panLenBounds = [ nTemp, nTemp ]
			ok

			if NOT ( isNumber(panLenBounds[1]) and isNumber(panLenBounds[2]) )

				StzRaise("Incorrect param type! panLenBounds must be a pair of numbers.")
			ok
		ok

		n1 = panLenBounds[1]
		n2 = panLenBounds[2]

		if n1 < 1 or n2 < 1
			StzRaise("Incorrect param values! n1 and n2 must be both greater then 1.")
		ok

		nLenBound1 = n1
		nLenBound2 = n2

		# Getting the list of chars, and the list of sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok
		acChars = This.Chars()
		
		aSections = This.FindAsSectionsCS(pcSubStr,  pCaseSensitive)
		nLenSections = len(aSections)
		if nLenSections = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLenSections--
		ok

		if aSections[nLenSections][2] = nLenStr
			ring_del(aSections, nLenSections)
			nLenSections--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLenSections
			
			#== Getting the first bound

			nTemp = 0

			n1 = aSections[i][1]
			c = acChars[n1-1]
			
			for j = n1 - 2 to 1 step - 1
				nTemp++
				if nTemp = n1 or acChars[j] != c
					exit
				ok
			next

			# Empty chars can't be part of a bound

			if NOT @trim(This.Section(j + 1, n1 - 1)) = ""
				nDiff = n1 - 1 - j
				if nLenBound1 < nDiff
					aResult + [ j + 1, j + nLenBound1 ]
				else
					aResult + [ j + 1, n1 - 1 ]
				ok
			ok

			#== Getting the second bound

			nTemp = 0

			n2 = aSections[i][2]
			c = acChars[n2+1]

			for j = n2 + 2 to nLenStr
				nTemp++
				if nTemp = n2 or acChars[j] != c
					exit
				ok
			next

			# Empty chars can't be part of a bound


			if NOT @trim(This.Section(n2 + 1, j - 1)) = ""
				nDiff = j - 1 - n2
				if nLenBound2 < nDiff
					aResult + [ n2 + 1, n2 + nLenBound2 ]
				else
					aResult + [ n2 + 1, j - 1 ]
				ok
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsCSZZ(pcSubStr, panLenBounds,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds,  pCaseSensitive)

		def FindBoundsOfUpToNCharsAsSectionsCS(pcSubStr, panLenBounds,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCSZZ(pcSubStr, panLenBounds,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds,  pCaseSensitive)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING THE BOUNDS - UP TO [ N1, N2 ] CHARS - OF A GIVEN SUBSTRING   #
	#-----------------------------------------------------------------------#

	def FindSubStringBoundsUpToNCharsCS(pcSubStr, panLenBounds, pCaseSensitive)
		aSections = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, panLenBounds, pCaseSensitive)
		nLen = len(aSections)
		anResult = []
	
		for i = 1 to nLen
			anResult + aSections[i][1]
		next
	
		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsCSZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCS(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCSZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsUpToNChars(pcSubStr, panLenBounds)
		return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, panLenBounds,  1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		def FindBoundsOfUpToNChars(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		def FindBoundsOfUpToNCharsZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		#>

	  #-------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING -- IB/EXTENSION  #
	#-------------------------------------------------------------------------#

	def FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundsCSIBZZ(pcSubStr, pCaseSensitive)
		anResult = QRT(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSIB(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsIB(pcSubStr)
		return This.FindSubStringBoundsCSIB(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsIBZ(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		def FindBoundsOfIB(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		def FindBoundsOfIBZ(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING  #
	#=================================================================#

	def FindBoundedSubStringCS(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		anResult = []

		for i = 1 to nLen step 2
			anResult + anSections[i][2]++
		next

		return anResult

		def FindBoundedSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubString(pcSubStr)
		return This.FindBoundedSubStringCS(pcSubStr, 1)

		def FindBoundedSubStringZ(pcSubStr)
			return This.FindBoundedSubString(pcSubStr)

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------#

	def FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ anSections[i][2]++, anSections[i+1][1]-- ]
		next

		return aResult

		def FindBoundedSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringZZ(pcSubStr)
		return This.FindBoundedSubStringCSZZ(pcSubStr, 1)

		def FindBoundedSubStringAsSections(pcSubStr)
			return This.FindBoundedSubStringZZ(pcSubStr)

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- IB/EXTENSION  #
	#=================================================================================#

	def FindBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			anResult + aSections[i][1]
		next

		return anResult

		def FindBoundedSubStringCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSIB(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringIB(pcSubStr)
		return This.FindBoundedSubStringCSIB(pcSubStr, 1)

		def FindBoundedSubStringIBZ(pcSubStr)
			return This.FindBoundedSubStringIB(pcSubStr)

	  #-----------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- IBZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------#

	def FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ anSections[i][1], anSections[i+1][2] ]
		next

		return aResult

		def FindBoundedSubStringAsSectionsCSIB(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringIBZZ(pcSubStr)
		return This.FindBoundedSubStringCSIBZZ(pcSubStr, 1)

		def FindBoundedSubStringAsSectionsIB(pcSubStr)
			return This.FindBoundedSubStringIBZZ(pcSubStr)

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS BOUNDS OF A GIVEN SUBSTRING  #
	#===============================================================#

	def ContainsBoundsOfCS(pcSubStr, pCaseSensitive)
		if len( This.BoundsOfCS(pcSubStr, pCaseSensitive) ) > 0
			return 1

		else
			return 0
		ok

		def SubStringIsBoundedCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

		def SubStringHasBoundsCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundsOf(pcSubStr)
		return This.ContainsBoundsOfCS(pcSubStr, 1)

		def SubStringIsBounded(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

		def SubStringHasBounds(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#===========================================================================#

	def FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringFirstBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringFirstBoundsAsSections(pcSubStr)
		return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		def FindFirstBoundsAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		#--

		def FindSubStringFirstBoundsZZ(pcSubStr)
			return This.FindSubStringFirstBoundsSections(pcSubStr)

		def FindFirstBoundsOfZZ(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		def FindFirstBoundsZZ(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#==

		def FindSubStringLastBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLastBoundsAsSections(pcSubStr)
		return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#==

		def FindSubStringLastBoundsZZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBoundsOfZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringLeftBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsOfAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLeftBoundsAsSections(pcSubStr)
		return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#--

		def FindSubStringLeftBoundsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsOfAsSectionsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSectionsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringRightBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringRightBoundsAsSections(pcSubStr)
		return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		def FindRightBoundsAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		#--

		def FindSubStringRightBoundsZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QRT(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringFirstBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringFirstBounds(pcSubStr)
		return This.FindSubStringFirstBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOf(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBounds(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#--

		def FindSubStringFirstBoundsZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBoundsOfZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBoundsZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QRT(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForsm

		def FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#==

		def FindLastBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLastBounds(pcSubStr)
		return This.FindSubStringLastBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForsm

		def FindLastBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#==

		def FindLastBoundsOfZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOfZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringLeftBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLeftBounds(pcSubStr)
		return This.FindSubStringLeftBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOf(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBounds(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#--

		def FindSubStringLeftBoundsZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBoundsOfZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBoundsZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringRightBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringRightBounds(pcSubStr)
		return This.FindRightBoundsOfCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindRightBoundsOf(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBounds(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#--

		def FindSubStringRightBoundsZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBoundsOfZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBoundsZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def SubStringBoundsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<Ring>>, the beautiful ((Ring))!")
		? o1.BoundsOf("Ring")
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def BoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQRT(pcSubStr, pCaseSensitive, :stzList)

			def BoundsOfCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBounds(pcSubstr)
		return This.SubStringBoundsCS(pcSubstr, 1)

		#< @FunctionAlternativeForms

		def BoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def BoundsOfQ(pcSubStr)
				return This.BoundsOfCSQ(pcSubStr, 1)

			def BoundsOfQRT(pcSubStr, pcReturnType)
				return This.BoundsOfCSQRT(pcSubStr, 1, pcReturnType)

		#--

		def SubStringFirstAndLastBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndLastBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndLastBoundsQRT(pcSubStr, pcReturnType)
				return This.BoundsOfQRT(pcSubStr, pcReturnType)

		def SubStringFirstAndSecondBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndSecondBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndSecondBoundsQRT(pcSubStr, pcReturnType)
				return This.BoundsOfQRT(pcSubStr, pcReturnType)

		def FirstAndLastBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndLastBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndLastBoundsOfQRT(pcSubStr, pcReturnType)
				return This.BoundsOfQRT(pcSubStr, pcReturnType)

		def FirstAndSecondBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndSecondBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndSecondBoundsOfQRT(pcSubStr, pcReturnType)
				return This.BoundsOfQRT(pcSubStr, pcReturnType)

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE FIRST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#-------------------------------------------------------------#

	def SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def FirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringFirstBounds(pcSubStr)
		return This.SubStringFirstBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FirstBoundsOf(pcSubStr)
			return This.SubStringFirstBounds(pcSubStr)

		def FirstBounds(pcSubStr)
			return This.FirstBoundsCS(pcSubStr, 1)

		#>

	  #------------------------------------------------------------#
	 #  GETTING THE LAST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#------------------------------------------------------------#

	def SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def LastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def LastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.LastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringLastBounds(pcSubStr)
		return This.SubStringLastBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def LastBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SubStringSecondBounds(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SecondBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		#--

		def LastBounds(pcSubStr)
			return This.LastBoundsCS(pcSubStr, 1)

		def SecondBounds(pcSubStr)
			return This.LastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def LeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringLeftBounds(pcSubStr)
		return This.SubStringLeftBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def LeftBoundsOf(pcSubStr)
			return This.SubStringLeftBounds(pcSubStr)

		def LeftBounds(pcSubStr)
			return This.LeftBoundsCS(pcSubStr, 1)
 
		#>

	  #------------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUNDS OF A GIVEN SUBSTRIG INSIDE THE STRING  #
	#------------------------------------------------------------------#

	def SubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightBoundsOfCS(pcsubStr, pCaseSensitive)
			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def RightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringRightBounds(pcSubStr)
		return This.SubStringRightBoundsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def RightBoundsOf(pcsubStr)
			return This.SubStringRightBounds(pcSubStr)

		def RightBounds(pcSubStr)
			return This.RightBoundsCS(pcSubStr, 1)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS, UP TO N CHARS, OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================================#

	def SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<<Ring>>>, the beautiful (((Ring)))!")
		? o1.BoundsOfUpToNchars("Ring", 2)
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfUptoNcharsAsSectionsCS(pcSubStr, n, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, :stzList)

		def SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def BoundsUpToNCharsOfCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, :stzList)

			def BoundsOfUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndLastBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndLastBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndSecondBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndSecondBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def FirstAndLastBoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def FirstAndLastBoundsOfUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def FirstAndSecondBoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def FirstAndSecondBoundsOfUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQRT(pcSubStr, n, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBoundsUpToNChars(pcSubstr, n)
		return This.SubStringBoundsUpToNCharsCS(pcSubstr, n, 1)

		#< @FunctionAlternativeForms

		def BoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def BoundsUpToNCharsOfQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQRT(pcSubStr, n, :stzList)

			def BoundsOfUpToNCharsQRT(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def SubStringFirstAndLastBoundsUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def SubStringFirstAndLastBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)

		def SubStringFirstAndSecondBoundsUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def SubStringFirstAndSecondBoundsUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def SubStringFirstAndSecondBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)

		def FirstAndLastBoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def FirstAndLastBoundsOfUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def FirstAndLastBoundsOfUpToNCharsQRT(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)

		def FirstAndSecondBoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def FirstAndSecondBoundsOfUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def FirstAndSecondBoundsOfUpToNCharsQRT(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQRT(pcSubStr, n, pcReturnType)

		#>

	  #-------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS, UP TO N CHARS, OF A GIVEN SUBSTRING IN THE STRING -- XT  #
	#-------------------------------------------------------------------------------#

	def SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<<Ring>>>, the beautiful (((Ring)))!")
		? o1.BoundsOfXT("Ring", [ 2, 2 ])
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCSXT(pcSubStr, panLenBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, :stzList)

		def SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

			def BoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
				return This.BoundsOfCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, :stzList)

			def BoundsOfCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

			def FirstAndLastBoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)

			def FirstAndLastBoundsOfCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfCSXT(pcSubStr, panLenBounds, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, panLenBounds, pCaseSensitive)

			def FirstAndSecondBoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, panLenBounds, pCaseSensitive)

			def FirstAndSecondBoundsOfCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQRT(pcSubStr, panLenBounds, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBoundsXT(pcSubstr, panLenBounds)
		return This.SubStringBoundsCSXT(pcSubstr, panLenBounds, 1)

		#< @FunctionAlternativeForms

		def BoundsOfXT(pcSubStr, panLenBounds)
			return This.SubStringBoundsXT(pcSubStr, panLenBounds)

			def BoundsXTOfQ(pcSubStr, panLenBounds)
				return This.BoundsOfXTQRT(pcSubStr, panLenBounds, :stzList)

			def BoundsOfXTQRT(pcSubStr, panLenBounds, pcReturnType)
				return This.SubStringBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsXT(pcSubStr, panLenBounds)
			return This.SubStringBoundsXT(pcSubStr, panLenBounds)

			def SubStringFirstAndLastBoundsXTQ(pcSubStr, panLenBounds)
				return This.BoundsOfXTQ(pcSubStr, panLenBounds)

			def SubStringFirstAndLastBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)
				return This.SubStringBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)

		def SubStringFirstAndSecondBoundsXT(pcSubStr, panLenBounds)
			return This.SubStringBoundsXT(pcSubStr, panLenBounds)

			def SubStringFirstAndSecondBoundsXTQ(pcSubStr, panLenBounds)
				return This.BoundsOfXTQ(pcSubStr, panLenBounds)

			def SubStringFirstAndSecondBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)
				return This.SubStringBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)

		def FirstAndLastBoundsOfXT(pcSubStr, panLenBounds)
			return This.SubStringBoundsXT(pcSubStr, panLenBounds)

			def FirstAndLastBoundsOfXTQ(pcSubStr, panLenBounds)
				return This.BoundsOfXTQ(pcSubStr, panLenBounds)

			def FirstAndLastBoundsOfXTQRT(pcSubStr, panLenBounds, pcReturnType)
				return This.SubStringBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)

		def FirstAndSecondBoundsOfXT(pcSubStr, panLenBounds)
			return This.SubStringBoundsXT(pcSubStr, panLenBounds)

			def FirstAndSecondBoundsOfXTQ(pcSubStr, panLenBounds)
				return This.BoundsOfXTQ(pcSubStr, panLenBounds)

			def FirstAndSecondBoundsOfXTQRT(pcSubStr, panLenBounds, pcReturnType)
				return This.SubStringBoundsXTQRT(pcSubStr, panLenBounds, pcReturnType)

		#>

	  #------------------------------------#
	 #  REMOVING BOUNDS OF THE SUBSTRING  #
	#====================================#

	def RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)


		#< @FunctionFluentForm

		def RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsOfCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr,pCaseSensitive)

			def RemoveSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSecondAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringLeftAndRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftAndRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringRightAndLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightAndLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndLastBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLastAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SecondAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLeftAndRightBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LeftAndRightBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringRightAndLeftBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def RightAndLeftBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringBounds(pcSubStr)
		return This.RemoveSubStringBoundsCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringBoundsQ(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveBoundsOfQ(pcSubStr)
				This.RemoveBoundsOf(pcSubStr)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndLastBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		def RemoveSubStringFirstAndSecondBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndSecondBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		#--

		def RemoveFirstAndLastBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveFirstAndLastBoundsOfQ(pcSubStr)
				This.RemoveFirstAndLastBoundsOf(pcSubStr)
				return This

		def RemoveFirstAndSecondBoundsOf(pcSubStr)
			This.RemoveSubStringBoundsOf(pcSubStr)

			def RemoveFirstAndSecondBoundsOfQ(pcSubStr)
				This.RemoveFirstAndSecondBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLastAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStق)

			def RemoveSubStringLastAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringLastAndFirstBounds(pcSubStr)
				return This

		def RemoveSubStringSecondAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringSecondAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringSecondAndFirstBounds(pcSubStr)
				return This

		#--

		def RemoveLastAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLastAndFirstBoundsOfQ(pcSubStr)
				This.RemoveLastAndFirstBoundsOf(pcSubStr)
				return This

		def RemoveSecondAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSecondAndFirstBoundsOfQ(pcSubStr)
				This.RemoveSecondAndFirstBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLeftAndRightBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringLeftAndRightBoundsQ(pcSubStr)
				This.RemoveSubStringLeftAndRightBounds(pcSubStr)
				return This

		#--

		def RemoveLeftAndRightBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLeftAndRightBoundsOfQ(pcSubStr)
				This.RemoveLeftAndRightBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringRightAndLeftBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringRightAndLeftBoundsQ(pcSubStr)
				This.RemoveSubStringRightAndLeftBounds(pcSubStr)
				return This

		#--

		def RemoveRightAndLeftBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveRightAndLeftBoundsOfQ(pcSubStr)
				This.RemoveRightAndLeftBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndLastBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringFirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLastAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LastAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringSecondAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SecondAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLeftAndRightBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LeftAndRightBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringRightAndLeftBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def RightAndLeftBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#>

	  #----------------------------------------#
	 #  REMOVING LEFT BOUND OF THE SUBSTRING  #
	#========================================#

	def RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLeftBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		def LeftBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBounds()
		This.RemoveSubStringLeftBoundsCS(1)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsQ()
			This.RemoveSubStringLeftBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBounds(pcSubStr)
			This.RemoveLeftBoundsCS(pcSubStr, 1)

			def RemoveLeftBoundsQ(pcSubStr)
				This.RemoveLeftBounds(pcSubStr)
				return This

		def RemoveLeftBoundsOf(pcSubStr)
			This.RemoveSubStringLeftBounds(pcSubStr)

			def RemoveLeftBoundsOfQ(pcSubStr)
				This.RemoveLeftBoundsOf(pcSubStr)

		#>

	def SubStringLeftBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLeftBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemoved()
			return This.SubStringLeftBoundsRemoved()

		def LeftBoundOfsRemoved()
			return This.SubStringLeftBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringRightBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		def RightBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBounds()
		This.RemoveSubStringRightBoundsCS(1)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsQ()
			This.RemoveSubStringRightBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBounds(pcSubStr)
			This.RemoveRightBoundsCS(pcSubStr, 1)

			def RemoveRightBoundsQ(pcSubStr)
				This.RemoveRightBounds(pcSubStr)
				return This

		def RemoveRightBoundsOf(pcSubStr)
			This.RemoveSubStringRightBounds(pcSubStr)

			def RemoveRightBoundsOfQ(pcSubStr)
				This.RemoveRightBoundsOf(pcSubStr)

		#>

	def SubStringRightBoundsRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemoved()
			return This.SubStringRightBoundsRemoved()

		def RightBoundOfsRemoved()
			return This.SubStringRightBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING FIRST BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringFirstBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		def FirstBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBounds()
		This.RemoveSubStringFirstBoundsCS(1)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsQ()
			This.RemoveSubStringFirstBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBounds(pcSubStr)
			This.RemoveFirstBoundsCS(pcSubStr, 1)

			def RemoveFirstBoundsQ(pcSubStr)
				This.RemoveFirstBounds(pcSubStr)
				return This

		def RemoveFirstBoundsOf(pcSubStr)
			This.RemoveSubStringFirstBounds(pcSubStr)

			def RemoveFirstBoundsOfQ(pcSubStr)
				This.RemoveFirstBoundsOf(pcSubStr)

		#>

	def SubStringFirstBoundsRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemoved()
			return This.SubStringFirstBoundsRemoved()

		def FirstBoundOfsRemoved()
			return This.SubStringFirstBoundsRemoved()

		#>

	  #----------------------------------------#
	 #  REMOVING LAST BOUND OF THE SUBSTRING  #
	#----------------------------------------#

	def RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLastBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		def LastBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBounds()
		This.RemoveSubStringLastBoundsCS(1)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsQ()
			This.RemoveSubStringLastBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBounds(pcSubStr)
			This.RemoveLastBoundsCS(pcSubStr, 1)

			def RemoveLastBoundsQ(pcSubStr)
				This.RemoveLastBounds(pcSubStr)
				return This

		def RemoveLastBoundsOf(pcSubStr)
			This.RemoveSubStringLastBounds(pcSubStr)

			def RemoveLastBoundsOfQ(pcSubStr)
				This.RemoveLastBoundsOf(pcSubStr)

		#>

	def SubStringLastBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemoved()
			return This.SubStringLastBoundsRemoved()

		def LastBoundOfsRemoved()
			return This.SubStringLastBoundsRemoved()

		#>

	  #-----------------------------------------------------#
	 #  REMOVING A SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS  #
	#=====================================================#

	def RemoveBoundedSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveBoundedSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveBoundedSubStringCS(pcSubStr, pCaseSensitive)
			return This

	def BoundedSubStringRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveBoundedSubStringCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveBoundedSubString(pcSubStr)
		This.RemoveBoundedSubStringCS(pcSubStr, 1)

		def RemoveBoundedSubStringQ(pcSubStr)
			This.RemoveBoundedSubString(pcSubStr)
			return This

	def BoundedSubStringRemoved(pcSubStr)
		cResult = This.Copy().RemoveBoundedSubStringQ(pcSubStr).Content()
		return This

	  #---------------------------------------------------------------------#
	 #  REMOVING A SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#---------------------------------------------------------------------#

	def RemoveBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveBoundedSubStringCSIBQ(pcSubStr, pCaseSensitive)
			This.RemoveBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
			return This

	def BoundedSubStringRemovedCSIB(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveBoundedSubStringCSIBQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveBoundedSubStringIB(pcSubStr)
		This.RemoveBoundedSubStringCSIB(pcSubStr, 1)

		def RemoveBoundedSubStringIBQ(pcSubStr)
			This.RemoveBoundedSubStringIB(pcSubStr)
			return This

	def BoundedSubStringRemovedIB(pcSubStr)
		cResult = This.Copy().RemoveBoundedSubStringIBQ(pcSubStr).Content()
		return This

	  #-------------------------------------------------------#
	 #  REMOVING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS  #
	#=======================================================#

	def RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveTheseSubStringBoundsCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVE

	def RemoveTheseSubStringBounds(pcSubStr, pacBounds)
		This.RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, 1)

		def RemoveTheseSubStringBoundsQ(pcSubStr, pacBounds)
			This.RemoveTheseSubStringBounds(pcSubStr, pacBounds)
			return This

	  #----------------------------------------#
	 #  SWAPPING BOUNDS OF A GIVEN SUBSTRING  #
	#========================================#

	def SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		aPairsOfSections = Q(aSections).SplitToListsOfNItems(2)
		nLen = len(aPairsOfSections)

		for i = 1 to nLen
			This.SwapSections(aPairsOfSections[i][1], aPairsOfSections[i][2])
		next

		#< @FunctionFluentForm

		def SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def SubStringLastAndFirstBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def FirstAndLastBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStringBounds(pcSubStr)
		This.SwapSubStringBoundsCS(pcSubStr, 1)
	
		#< @FunctionFluentForm

		def SwapSubStringBoundsQ(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapBoundsOfQ(pcSubStr)
				This.SwapBoundsOf(pcSubStr)
				return This

		#--

		def SwapSubStringFirstAndLastBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringFirstAndLastBoundsQ(pcSubStr)
				This.SwapSubStringFirstAndLastBounds(pcSubStr)
				return This

		def SwapSubStringLastAndFirstBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringLastAndFirstBoundsQ(pcSubStr)
				This.SwapSubStringLastAndFirstBounds(pcSubStr)
				return This

		#--

		def SwapFirstAndLastBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapFirstAndLastBoundsOfQ(pcSubStr)
				This.SwapFirstAndLastBoundsOf(pcSubStr)
				return This

		def SwapLastAndFirstBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapLastAndFirstBoundsOfQ(pcSubStr)
				This.SwapLastAndFirstBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsSwapped(pcSubStr)
		cResult = This.Copy().SwapSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def SubStringLastAndFirstBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def FirstAndLastBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def LastAndFirstBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#>

	  #========================================================================================#
	 #  FINDING ANY SUBSTRING BETWEEN THE FIRST AND LAST OCCURRENCES OF TWO GIVEN SUBSTRINGS  #
	#========================================================================================#

	def FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)
		if NOT isString(pcBound1) and isString(pcBound2)
			StzRaise("Incorrect param types! pcBound1 and pcBound2 must be both strings.")
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		n1 = This.FindFirstOccurrenceCS(pcBound1, pCaseSensitive) + nLen1
		n2 = This.FindLastOccurrenceCS(pcBound2, pCaseSensitive) - 1

		if n2 < n1
			nTemp = n2
			n2 = n1
			n1 = nTemp
		ok

		aResult = [ n1, n2 ]
		return aResult

		#< @FunctionAlternativeForms

		def FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		def FindAnyBetweenCSZZ(pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSection(pcBound1, pcBound2)
		return This.FindBetweenAsSectionCS(pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForms

		def FindAnyBetweenAsSection(pcBound1, pcBound2)
			return This.FindBetweenAsSection(pcBound1, pcBound2)

		def FindAnyBetweenZZ(pcBound1, pcBound2)
			return This.FindBetweenAsSection(pcBound1, pcBound2)

		#>

	  #=======================================================#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=======================================================#

	def RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		aSection = This.FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSection(aSection[1], aSection[2])

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

			def RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
				return This.RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)

		#>

	def AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetween(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCS(pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm

		def RemoveBetween(pcBound1, pcBound2)
			This.RemoveAnyBetween(pcBound1, pcBound2)

			def RemoveBetweenQ(pcBound1, pcBound2)
				return This.RemoveAnyBetweenQ(pcBound1, pcBound2)

		#>

	def AnyBetweenRemoved(pcBound1, pcBound2)
		acResult = This.Copy().RemoveAnyBetweenCSQ(pcBound1, pcBound2).Content()
		return acResult

		def BetweenRemoved(pcBound1, pcBound2)
			return This.AnyBetweenRemoved(pcBound1, pcBound2)

	  #-------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#-------------------------------------------------------------------#
	#--> Bounds are also removed (TODO: Generalise this feature)

	def RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		aSection = This.FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and StzListQ(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		aSection[1] = aSection[1] - nLen1
		aSection[2] = aSection[2] + nLen2

		This.RemoveSection(aSection[1], aSection[2])

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

		#--

		def RemoveBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

			def RemoveBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
				return This.RemoveAnyBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)

		#>

	def AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

		def RemovedBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetweenIB(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, 1)

		#< @FunctionFluentForm

		def RemoveAnyBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnyBetweenIB(pcBound1, pcBound2)
			return This

		#--

		def RemoveBetweenIB(pcBound1, pcBound2)
			This.RemoveAnyBetweenIB(pcBound1, pcBound2)

			def RemoveBetweenIBQ(pcBound1, pcBound2)
				return This.RemoveAnyBetweenIBQ(pcBound1, pcBound2)

		#>

	def AnyBetweenRemovedIB(pcBound1, pcBound2)
		acResult = This.Copy().RemoveBetweenIBQ(pcBound1, pcBound2).Content()
		return acResult

		def RemovedBetweenIB(pcBound1, pcBound2)
			return This.AnyBetweenRemovedIB(pcBound1, pcBound2)

	  #============================================================#
	 #     REMOVING LEFT BOUND OF A SUBSTRING FROM THE STRING     #
	#============================================================#

	def RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.LeftNChars( nLenSubStr ) = pcSubStr
			This.ReplaceFirstOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			return This
		#>


		#< @FunctionAlternativeForms

		def RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBound(pcSubStr)
		This.RemoveSubStringLeftBoundCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundQ(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveLeftBoundOfQ(pcSubStr)
				This.RemoveLeftBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLeftBound(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachSubStringLeftBoundQ(pcSubStr)
				This.RemoveEachSubStringLeftBound(pcSubStr)
				return This

		def RemoveEachLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachLeftBoundOfQ(pcSubStr)
				This.RemoveEachLeftBoundOf(pcSubStr)
				return This

		#>

	def SubStringLeftBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLeftBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemoved(pcSubStr)
			return This.SubStringLeftBoundRemoved(pcSubStr)

		#>

	  #--------------------------------------------#
	 #    REMOVING RIGHT BOUND FROM THE STRING    #
	#--------------------------------------------#

	def RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.RightNChars( nLenSubStr ) = pcSubStr
			This.ReplaceLastOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringrightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult


		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBound(pcSubStr)
		This.RemoveSubStringRightBoundCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundQ(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOf(pcSubStr)
			This.RemoveSubStringrightBound(pcSubStr)

			def RemoveRightBoundOfQ(pcSubStr)
				This.RemoveRightBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringRightBound(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachSubStringRightBoundQ(pcSubStr)
				This.RemoveEachSubStringRightBound(pcSubStr)
				return This

		def RemoveEachRightBoundOf(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachRightBoundOfQ(pcSubStr)
				This.RemoveEachRightBoundOf(pcSubStr)
				return This

		#>

	def RightSubStringBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringRightBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemoved(pcSubStr)
			return This.SubStringRightBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   REMOVING FIRST BOUND FROM THE STRING    #
	#-------------------------------------------#

	def RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() than...
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm
	
		def RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBound(pcSubStr)
		This.RemoveSubStringFirstBoundCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveFirstBoundOfQ(pcSubStr)
				This.RemoveFirstBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringFirstBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringFirstBoundQ(pcSubStr)
				This.RemoveEachSubStringFirstBound(pcSubStr)
				return This

		def RemoveEachFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveEachFirstBoundOfQ(pcSubStr)
				This.RemoveEachFirstBoundOf(pcSubStr)
				return This

		#>


	def SubStringFirstBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringFirstBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemoved(pcSubStr)
			return This.SubStringFirstBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REMOVING EACH LAST BOUND OF A SUBSTRING FROM THE STRING   #
	#-------------------------------------------------------------#

	def RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() then...
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def EachSubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBound(pcSubStr)
		This.RemoveSubStringLastBoundCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveLastBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSecondBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSubStringSecondBoundQ(pcSubStr)
				This.RemoveSubStringSecondBound(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLastBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringLastBoundQ(pcSubStr)
				This.RemoveEachSubStringLastBound(pcSubStr)
				return This

		def RemoveEachLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachLastBoundOfQ(pcSubStr)
				This.RemoveEachLastBoundOf(pcSubStr)
				return This

		def RemoveEachSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSecondBoundOfQ(pcSubStr)
				This.RemoveEachSecondBoundOf(pcSubStr)
				return This

		def RemoveEachSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringSecondBoundQ(pcSubStr)
				This.RemoveEachSubStringSecondBound(pcSubStr)
				return This

		#>

	def SubStringLastBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLastBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def SubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def EachSubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CHECKING OF THE STRING CONTAINS THE GIVEN BOUNDS   #
	#------------------------------------------------------#

	def ContainsTheseBoundsCS(pacBounds, pCaseSensitive)
		if NOT ( isList(pacBounds) and StzListQ(pacBounds).IsAPairOfStrings() )
			StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
		ok

		if (NOT This.ContainsCS(pacBounds[1])) or
		   (NOT This.ContainsCS(pacBounds[2]))

			return 0
		ok

		n1 = This.FindFirstCS(pacBounds[1])
		n2 = This.FindFirstCS(pacBounds[2])

		if n1 < n2
			return 1
		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseBounds(pacBounds)
		return This.ContainsTheseBoundsCS(pacBounds, 1)

	  #============================#
	 #   REPEATED LEADING CHARS   #
	#============================#

	def RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> 'eee'
			'exeeeeeTUNIS' 	--> ''
		*/

		nLen = This.NumberOfCharsCS(pCaseSensitive)

		if nLen = 0 or nLen = 1
			return ""
		ok

		if NOT This.CharQ(1).IsEqualToCS( This.Char(2), pCaseSensitive)
			return ""
		ok

		cResult = ""
	
		bContinue = 1
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = 0
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = 0
			ok

		end

		n = i
		if i > 2
			n--
		ok

		cResult = This.Section(1, n)
		return cResult

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedLeadingCharsAsStringCS(pCaseSensitive)
			ThisRepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedLeadingCharsCSXT(pCaseSensitive)
			ThisRepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingCharsAsSubString()
		return This.RepeatedLeadingCharsAsSubStringCS(1)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringQ()
			return new stzString( This.RepeatedLeadingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		#--

		def RepeatedLeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		#--

		def RepeatedLeadingCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		#>

	  #--------------------------------------#
	 #  LEADING SUBSTRING AND ITS POSITION  #
	#--------------------------------------#

	def LeadingSubStringCSZ(pCaseSensitive)
		cSubStr = This.LeadingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		return [ cSubStr, 1 ]

		def LeadingSubStringAndItsPositionCS(pCaseSensitive)
			return This.LeadingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeadingSubStringZ()
		return This.LeadingSubStringCSZ(1)

		def LeadingSubStringAndItsPosition()
			return This.LeadingSubStringZ()

	  #-------------------------------------#
	 #  LEADING SUBSTRING AND ITS SECTION  #
	#-------------------------------------#

	def LeadingSubStringCSZZ(pCaseSensitive)
		cSubStr = This.LeadingSubStringCS(pCaseSensitive)
		aSection = This.FindLeadingSubStringCSZZ(pCaseSensitive)

		if cSubStr = ""
			return []
		ok

		return [ cSubStr, aSection ]

		def LeadingSubStringAndItsSectionCS(pCaseSensitive)
			return This.LeadingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeadingSubStringZZ()
		return This.LeadingSubStringCSZZ(1)

		def LeadingSubStringAndItsSection()
			return This.LeadingSubStringZZ()

	  #----------------------------#
	 #   REPEATED LEADING CHARS   #
	#----------------------------#

	def RepeatedLeadingCharsCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> [ 'e', 'e', 'e' ]
			'exeeeeeTUNIS' 	--> []
		*/

		nLen = This.NumberOfCharsCS(pCaseSensitive)
		if nLen = 0 or nLen = 1
			return ""
		ok

		if NOT This.CharQ(1).IsEqualToCS( This.Char(2), pCaseSensitive )
			return []
		ok

		acResult = []
	
		bContinue = 1
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = 0
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = 0
			ok

		end

		n = i
		if i > 2
			n--
		ok

		acResult = This.CharsInSection(1, n)
		return acResult

		#< @FunctionFluentForm

		def RepeatedLeadingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedLeadingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingRepeatedCharsCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsCSQ(pCaseSensitive)
	
		def LeadingCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingCharsCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChars()
		return This.RepeatedLeadingCharsCS(1)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsQ()
			return new stzList( This.RepeatedLeadingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChars()
			return This.RepeatedLeadingChars()

			def LeadingRepeatedCharsQ()
				return This.RepeatedLeadingCharsQ()
	
		def LeadingChars()
			return This.RepeatedLeadingChars()

			def LeadingCharsQ()
				return This.RepeatedLeadingCharsQ()
	
		#>

	  #-------------------------------------#
	 #  GETTING THE REPEATED LEADING CHAR  #
	#-------------------------------------#

	def RepeatedLeadingCharCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return This.Char(1)
		else
			return ""
		ok

		#< @FunctionFleuntForms

		def RepeatedLeadingCharCSQ(pCaseSensitive)
			return This.RepeatedLeadingCharCSQRT(pCaseSensitive, :stzChar)

		def RepeatedLeadingCharCSQRT(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedLeadingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingRepeatedCharCSQRT(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQRT(pCaseSensitive, pcReturnType)

			def LeadingRepeatedCharCSQ(pCaseSensitive)
				return This.LeadingRepeatedCharCSQRT(pCaseSensitive, :stzChar)
	
		def LeadingCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingCharCSQRT(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQRT(pCaseSensitive, pcReturnType)

			def LeadingCharCSQ(pCaseSensitive)
				return This.LeadingCharCSQRT(pCaseSensitive, :stzString)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChar()
		return This.RepeatedLeadingCharCS(1)


		#< @FunctionFleuntForms

		def RepeatedLeadingCharQ()
			return This.RepeatedLeadingCharQRT(:stzString)

		def RepeatedLeadingCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingChar())

			on :stzString
				return new stzString(This.RepeatedLeadingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChar()
			return This.RepeatedLeadingChar()

			def LeadingRepeatedCharQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQRT(pcReturnType)

			def LeadingRepeatedCharQ()
				return This.LeadingRepeatedCharQRT(:stzChar)
	
		def LeadingChar()
			return This.RepeatedLeadingChar()

			def LeadingCharQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQRT(pcReturnType)

			def LeadingCharQ()
				return This.LeadingCharQRT(:stzChar)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED LEADING CHARS IN THE STRING  #
	#--------------------------------------------------------------#

	def NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0

		if This.ContainsLeadingCharsCS(pCaseSensitive)
			nResult = This.LeadingCharsCSQ(pCaseSensitive).NumberOfChars()
		ok

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def NumberOfLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
	
		def CountLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def CountLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedLeadingChars()
		return This.NumberOfRepeatedLeadingCharsCS(1)

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def NumberOfLeadingChars()
			return This.NumberOfRepeatedLeadingChars()
	
		def CountLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChar()
			return This.NumberOfRepeatedLeadingChars()

		def CountLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChar()
			return This.NumberOfRepeatedLeadingChars()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED LEADING CHAR IN THE STRING  #
	#---------------------------------------------------------------------#

	def RepeatedLeadingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)

		def LeadingCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedLeadingCharIs(c)
		return This.RepeatedLeadingCharIsCS(c, 1)

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIs(c)
			return This.RepeatedLeadingCharIs(c)

		def LeadingCharIs(c)
			return This.RepeatedLeadingCharIs(c)
	
		#>

	  #----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED LEADING CHAR  #
	#====================================================#

	def HasRepeatedLeadingCharsCS(pCaseSensitive)
		if This.LeadingSubStringCS(pCaseSensitive) != ""
			return 1
		else

			return 0
		ok

		#< @FunctionAlternativeForms

		def HasLeadingSubStringCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#== adding A

		def HasALeadingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasALeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def HasARepeatedLeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsARepeatedLeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsALeadingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsALeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingChars()
		return This.HasRepeatedLeadingCharsCS(1)

		#< @FunctionAlternativeForms

		def HasLeadingSubString()
			return This.HasRepeatedLeadingChars()

		def HasLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def HasLeadingChars()
			return This.HasRepeatedLeadingChars()

		#--

		def ContainsRepeatedLeadingChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingChars()
			return This.HasRepeatedLeadingChars()

		#== adding A

		def HasALeadingRepeatedChar()
			return This.HasRepeatedLeadingChars()

		def HasALeadingChar()
			return This.HasRepeatedLeadingChars()

		#--

		def HasARepeatedLeadingChar()
			return This.HasRepeatedLeadingChars()

		def ContainsARepeatedLeadingChar()
			return This.HasRepeatedLeadingChars()

		def ContainsALeadingRepeatedChar()
			return This.HasRepeatedLeadingChars()

		def ContainsALeadingChar()
			return This.HasRepeatedLeadingChars()

		#>

	  #-----------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS  # 
	#===============================================#

	def FindRepeatedLeadingCharsCS(pCaseSensitive)

		_nLen_ = This.NumberOfChars()

		if _nLen_ < 2
			return []
		ok

		_n_ = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if _n_ = 0
			return []
		ok

		_anResult_ = 1:n

		return _anResult_

		#< @FunctionALternativeForm

		def FindLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

		def FindLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingChars()
		return This.FindRepeatedLeadingCharsCS(1)

		#< @FunctionALternativeForm

		def FindLeadingChars()
			return This.FindRepeatedLeadingChars()

		def FindLeadingCharsZ()
			return This.FindRepeatedLeadingChars()

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS AND RETURNING THEM AS SECTION  # 
	#-----------------------------------------------------------------------------#

	def FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		anResult = [ 1, n ]

		return anResult

		#< @FunctionAlternativeForms

		def FindLeadingSubStringCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingSubStringAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingCharsAsSection()
		return This.FindRepeatedLeadingCharsAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindLeadingSubStringZZ()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingSubStringAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingCharsZZ()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingCharsAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------#

	def RepeatedLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZ()
		return This.RepeatedLeadingCharsCSZ(1)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsZ()
			return This.RepeatedLeadingCharsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR SECTION  #
	#-----------------------------------------------------------#

	def RepeatedLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZZ()
		return This.RepeatedLeadingCharsCSZZ(1)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsZZ()
			return This.RepeatedLeadingCharsZZ()

		#>

	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING CHARS   #
	#=====================================#

	def RemoveRepeatedLeadingCharsCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingCharsCSQ()
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingSubStringCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingSubStringCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#==

		#== Char (without an "s")

		def RemoveRepeatedLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveRepeatedLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#-- adding ANY

		def RemoveAnyRepeatedLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyRepeatedLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveAnyLeadingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyLeadingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()
	
		def RemoveanyLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedLeadingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingCharsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeadingSubStringRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#==

		def RepeatedLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#--

		def AnyRepeatedLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def AnyLeadingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def AnyLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingChars()
		This.RemoveRepeatedLeadingCharsCS(1)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingCharsQ()
			This.RemoveRepeatedLeadingChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingSubString()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingSubStringQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveLeadingRepeatedChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharsQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveLeadingChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharsQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#== Char (without an "s")

		def RemoveRepeatedLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveRepeatedLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveLeadingRepeatedChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#-- adding ANY

		def RemoveAnyRepeatedLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyRepeatedLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveAnyLeadingRepeatedChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyLeadingRepeatedCharQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveanyLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedLeadingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingCharsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeadingSubStringRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingRepeatedCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#==

		def RepeatedLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingRepeatedCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#--

		def AnyRepeatedLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def AnyLeadingRepeatedCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def AnyLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#>

	  #=============================#
	 #   REPEATED TRAILING CHARS   #
	#=============================#

	def RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)
		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		_oQStr_ = QStringObject()
		nLenStr = _oQStr_.size()

		cLastChar = _oQStr_.mid(nLenStr-1, 1)

		cResult = ""

		for i = 1 to n
			cResult += cLastChar
		next

		return cResult

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def RepeatedTrailingSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingRepeatedSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		#==

		def TrailingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedTrailingCharsAsStringCS(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedTrailingCharsCSXT(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingRepeatedCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharsAsSubString()
		return This.RepeatedTrailingCharsAsSubStringCS(1)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringQ()
			return new stzString( This.RepeatedTrailingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def RepeatedTrailingSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingRepeatedSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#==

		def TrailingRepeatedCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		#--

		def RepeatedTrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingRepeatedCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#--

		def RepeatedTrailingCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingRepeatedCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#>

	  #-----------------------------#
	 #   REPEATED TRAILING CHARS   #
	#-----------------------------#

	def RepeatedTrailingCharsCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		_oQStr_ = QStringObject()
		nLenStr = _oQStr_.size()
		cLastChar = _oQStr_.mid(nLenStr-1, 1)

		acResult = []

		for i = 1 to n
			acResult + cLastChar
		next

		return acResult


		#< @FunctionFluentForm

		def RepeatedTrailingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedTrailingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingRepeatedCharsCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsCSQ(pCaseSensitive)

		def TrailingCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingCharsCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChars()
		return This.RepeatedTrailingCharsCS(1)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsQ()
			return new stzList( This.RepeatedTrailingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedChars()
			return This.RepeatedTrailingChars()

			def TrailingRepeatedCharsQ()
				return This.RepeatedTrailingCharsQ()
	
		def TrailingChars()
			return This.RepeatedTrailingChars()

			def TrailingCharsQ()
				return This.RepeatedTrailingCharsQ()
	
		#>

	  #--------------------------------------#
	 #  GETTING THE REPEATED TRAILING CHAR  #
	#--------------------------------------#

	def RepeatedTrailingCharCS(pCaseSensitive)

		_nLen_ = This.NumberOfChars()

		if _nLen_ < 2
			return ""
		ok

		_cLastChar_ = This.QStringObject().mid(_nLen_ - 1, 1)
		_cBeforeLastChar_ = This.QStringObject().mid(_nLen_ -2, 1)

		if StzStringQ(_cLastChar_).IsEqualToCS(_cBeforeLastChar_, pCaseSensitive)
			return _cLastChar_
		else
			return ""
		ok


		#< @FunctionFleuntForms

		def RepeatedTrailingCharCSQ(pCaseSensitive)
			return This.RepeatedTrailingCharCSQRT(pCaseSensitive, :stzChar)

		def RepeatedTrailingCharCSQRT(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedTrailingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedTrailingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingRepeatedCharCSQRT(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQRT(pCaseSensitive, pcReturnType)

			def TrailingRepeatedCharCSQ(pCaseSensitive)
				return This.TrailingRepeatedCharCSQRT(pCaseSensitive, :stzChar)
	
		def TrailingCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingCharCSQRT(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQRT(pCaseSensitive, pcReturnType)

			def TrailingCharCSQ(pCaseSensitive)
				return This.TrailingCharCSQRT(pCaseSensitive, :stzChar)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChar()
		return This.RepeatedTrailingCharCS(1)


		#< @FunctionFleuntForms

		def RepeatedTrailingCharQ()
			return This.RepeatedTrailingCharQRT(:stzString)

		def RepeatedTrailingCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedTrailingChar())

			on :stzString
				return new stzString(This.RepeatedTrailingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedChar()
			return This.RepeatedTrailingChar()

			def TrailingRepeatedCharQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQRT(pcReturnType)

			def TrailingRepeatedCharQ()
				return This.TrailingRepeatedCharQRT(:stzChar)
	
		def TrailingChar()
			return This.RepeatedTrailingChar()

			def TrailingCharQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQRT(pcReturnType)

			def TrailingCharQ()
				return This.TrailingCharQRT(:stzChar)
	
		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED TRAILING CHARS IN THE STRING  #
	#---------------------------------------------------------------#

	def NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		_nLen_ = This.NumberOfChars()

		if _nLen_ < 2
			return 0
		ok

		_cLastChar_ = This.QStringObject().mid(_nLen_ -1, 1)
		_cBeforeLastChar_ = This.QStringObject().mid(_nLen_ -2, 1)

		if NOT StzStringQ(_cLastChar_).IsEqualToCS(_cBeforeLastChar_, pCaseSensitive)
			return 0
		ok

		_n_ = 0

		for @i = _nLen_ to 1 step - 1

			_cChar_ = This.QStringObject().mid(@i-1, 1)

			if NOT StzStringQ(_cChar_).IsEqualToCS(_cLastChar_, pCaseSensitive)
				exit
			else
				_n_++
			ok
		next

		return _n_


		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def NumberOfTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
	
		def CountTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def CountTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedTrailingChars()
		return This.NumberOfRepeatedTrailingCharsCS(1)

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def NumberOfTrailingChars()
			return This.NumberOfRepeatedTrailingChars()
	
		def CountTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingRepeatedChar()
			return This.NumberOfRepeatedTrailingChars()

		def CountTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingChar()
			return This.NumberOfRepeatedTrailingChars()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED TRAILING CHAR IN THE STRING  #
	#----------------------------------------------------------------------#

	def RepeatedTrailingCharIsCS(c, pCaseSensitive)

		_nLen_ = This.NumberOfChars()

		if _nLen_ < 2
			return 0
		ok

		_cLastChar_ = This.QStringObject().mid( _nLen_ - 1, 1)
		_cBeforeLastChar_ = This.QStringObject().mid( _nLen_ - 2, 1)

		if StzStringQ(_cLastChar_).IsEqualToCS(_cBeforeLastChar_, pCaseSensitive) and
		   StzStringQ(c).IsEqualToCS(_cLastChar_, pCaseSensitive)

			return 1
		else
			return 0
		ok


		#< @FunctionAlternativeForms

		def TrailingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)

		def TrailingCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedTrailingCharIs(c)
		return This.RepeatedTrailingCharIsCS(c, 1)

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharIs(c)
			return This.RepeatedTrailingCharIs(c)

		def TrailingCharIs(c)
			return This.RepeatedTrailingCharIs(c)
	
		#>

	  #-----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED TRAILING CHAR  #
	#=====================================================#

	def HasRepeatedTrailingCharsCS(pCaseSensitive)

		nLen = This.NumberOfChars()

		if nLen < 2
			return 0
		ok

		cLastChar = This.QStringObject().mid(nLen-1, 1)
		cBeforeLastChar = this.QStringObject().mid(nLen-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return 1
		else
			return 0

		ok

		#< @FunctionAlternativeForms

		def HasTrailingSubStringCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)
		
		def HasTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#== adding A

		def HasATrailingSubStringCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasATrailingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasATrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def HasARepeatedTrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsARepeatedTrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsATrailingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsATrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedTrailingChars()
		return This.HasRepeatedTrailingCharsCS(1)

		#< @FunctionAlternativeForms

		def HasTrailingSubString()
			return This.HasRepeatedTrailingChars()

		def HasTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def HasTrailingChars()
			return This.HasRepeatedTrailingChars()

		#--

		def ContainsRepeatedTrailingChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingChars()
			return This.HasRepeatedTrailingChars()

		#== adding A

		def HasATrailingSubString()
			return This.HasRepeatedTrailingChars()

		def HasATrailingRepeatedChar()
			return This.HasRepeatedTrailingChars()

		def HasATrailingChar()
			return This.HasRepeatedTrailingChars()

		#--

		def HasARepeatedTrailingChar()
			return This.HasRepeatedTrailingChars()

		def ContainsARepeatedTrailingChar()
			return This.HasRepeatedTrailingChars()

		def ContainsATrailingRepeatedChar()
			return This.HasRepeatedTrailingChars()

		def ContainsATrailingChar()
			return This.HasRepeatedTrailingChars()

		#>

	  #------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS  # 
	#================================================#

	def FindRepeatedTrailingCharsCS(pCaseSensitive)

		_oQStr_ = QStringObject()
		nLenStr = _oQStr_.size()

		if nLenStr < 2
			return []
		ok

		cLastChar = _oQStr_.mid(nLenStr-1, 1)
		cBeforeLastChar = _oQStr_.mid(nLenStr-2, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return []
		ok

		n = 0
		for i = nLenStr to 1 step -1
			if StzStringQ(_oQStr_.mid(i-1, 1)).IsEqualToCS(cLastChar, pCaseSensitive)
				n++
			else
				exit
			ok
		next

		anResult = (nLenStr-n+1) : nLenStr
		return anResult


		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		def FindTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		def FindTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingChars()
		return This.FindRepeatedTrailingCharsCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsZ()
			return This.FindRepeatedTrailingChars()

		def FindTrailingChars()
			return This.FindRepeatedTrailingChars()

		def FindTrailingCharsZ()
			return This.FindRepeatedTrailingChars()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS AND RETURNING THEM AS SECTION  # 
	#------------------------------------------------------------------------------#

	def FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		_oQStr_ = QStringObject()
		nLenStr = _oQStr_.size()

		if nLenStr < 2
			return []
		ok

		cLastChar = _oQStr_.mid(nLenStr-1, 1)
		cBeforeLastChar = _oQStr_.mid(nLenStr-2, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return []
		ok

		n = 0
		for i = nLenStr to 1 step -1
			if StzStringQ(_oQStr_.mid(i-1, 1)).IsEqualToCS(cLastChar, pCaseSensitive)
				n++
			else
				exit
			ok
		next

		aResult = [ (nLenStr-n+1), nLenStr ]

		return aResult


		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		def FindTrailingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		def FindTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingCharsAsSection()
		return This.FindRepeatedTrailingCharsAsSectionCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsZZ()
			return This.FindRepeatedTrailingCharsAsSection()

		def FindTrailingCharsAsSection()
			return This.FindRepeatedTrailingCharsAsSection()

		def FindTrailingCharsZZ()
			return This.FindRepeatedTrailingCharsAsSection()

		#>

	  #----------------------------------#
	 #  FINDING THE TRAILING SUBSTRING  #
	#==================================#

	def FindTrailingSubStringCS(pCaseSensitive)
		aSection = This.FindTrailingCharsCSZZ(pCaseSensitive)
		if len(aSection) = 0
			return 0
		else
			return aSection[1]
		ok

		def FindTrailingSubStringCSZ(pCaseSensitive)
			return This.FindTrailingSubStringCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTrailingSubString()
		return This.FindTrailingSubStringCS(1)

		def FindTrailingSubStringZ()
			return This.FindTrailingSubString()

	  #-------------------------------------------------#
	 #  FINDING THE TRAILING SUBSTRING -- ZZ/EXTENDED  #
	#-------------------------------------------------#

	def FindTrailingSubStringCSZZ(pCaseSensitive)
		aSection = This.FindTrailingCharsCSZZ(pCaseSensitive)
		if len(aSection) = 0
			return []
		else
			return aSection
		ok

		def FindTrailingSubStringAsSectionCS(pCaseSensitive)
			return This.FindTrailingSubStringCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTrailingSubStringZZ()
		return This.FindTrailingSubStringCSZZ(1)

		def FindTrailingSubStringAsSection()
			return This.FindTrailingSubStringZZ()

	  #----------------------------------------------------------#
	 #  GETTING THE TRAILING SUBSTRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------#

	def TrailingSubStringCSZ(pCaseSensitive)

		cSubStr = This.TrailingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		nPos = This.FindTrailingSubStringCS(pCaseSensitive)

		aResult = [ cSubStr, nPos ]
		return aResult


		def TrailingSubStringAndItsPositionCS(pCaseSensitive)
			return This.TrailingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TrailingSubStringZ()
		return This.TrailingSubStringCSZ(1)

		def TrailingSubStringAndItsPosition()
			return This.TrailingSubStringZ()

	  #---------------------------------------------------------#
	 #  GETTING THE TRAILING SUBSTRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------#

	def TrailingSubStringCSZZ(pCaseSensitive)

		cSubStr = This.TrailingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		anSection = This.FindTrailingSubStringCSZZ(pCaseSensitive)

		aResult = [ cSubStr, anSection ]
		return aResult


		def TrailingSubStringAndItsSectionCS(pCaseSensitive)
			return This.TrailingSubStringCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TrailingSubStringZZ()
		return This.TrailingSubStringCSZZ(1)

		def TrailingSubStringAndItsSection()
			return This.TrailingSubStringZZ()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR POSITION  #
	#=============================================================#

	def RepeatedTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZ()
		return This.RepeatedTrailingCharsCSZ(1)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsZ()
			return This.RepeatedTrailingCharsZ()

		#>

	  #------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR SECTION  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsCSZZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZZ()
		return This.RepeatedTrailingCharsCSZZ(1)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsZZ()
			return This.RepeatedTrailingCharsZZ()

		#>

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING CHARS   #
	#======================================#

	def RemoveRepeatedTrailingCharsCS(pCaseSensitive)

		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingCharsCSQ()
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingSubStringCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingSubStringCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#--

		def RemoveTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#== Char (without an "s")

		def RemoveRepeatedTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveRepeatedTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		def RemoveTrailingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#-- adding ANY

		def RemoveAnyRepeatedTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyRepeatedTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		def RemoveAnyTrailingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyTrailingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveanyTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def TrailingSubStringRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#--

		def TrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#==

		def RepeatedTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#--

		def AnyRepeatedTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def AnyTrailingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def AnyTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingChars()
		This.RemoveRepeatedTrailingCharsCS(1)

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingCharsQ()
			This.RemoveRepeatedTrailingChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingSubString()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingSubStringQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#--

		def RemoveTrailingRepeatedChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharsQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveTrailingChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharsQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		#== Char (without an "s")

		def RemoveRepeatedTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveRepeatedTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		def RemoveTrailingRepeatedChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#-- adding ANY

		def RemoveAnyRepeatedTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyRepeatedTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		def RemoveAnyTrailingRepeatedChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyTrailingRepeatedCharQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveanyTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedTrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedTrailingCharsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def TrailingSubStringRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#--

		def TrailingRepeatedCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()	

		#==

		def RepeatedTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingRepeatedCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#--

		def AnyRepeatedTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def AnyTrailingRepeatedCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def AnyTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING AND TRAILING CHARS  # 
	#============================================================#

	def FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfChars() - n + 1
		ok
		
		anResult = [ n1, n2 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingChars()
		return This.FindRepeatedLeadingAndTrailingCharsCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsZ()
			return This.FindRepeatedLeadingAndTrailingChars()

		def FindLeadingAndTrailingChars()
			return This.FindRepeatedLeadingAndTrailingChars()

		def FindLeadingAndTrailingCharsZ()
			return This.FindRepeatedLeadingAndTrailingChars()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING AND LEADING CHARS  # 
	#============================================================#

	def FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfCharsCS(pCaseSensitive) - n + 1
		ok

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok
		
		anResult = [ n2, n1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingChars()
		return This.FindRepeatedTrailingAndLeadingCharsCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsZ()
			return This.FindRepeatedTrailingAndLeadingChars()

		def FindTrailingAndLeadingChars()
			return This.FindRepeatedTrailingAndLeadingChars()

		def FindTrailingAndLeadingCharsZ()
			return This.FindRepeatedTrailingAndLeadingChars()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED LEADING AND TRAILING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok
		
		# Composing the result

		aResult = [ [ nLead1, nLead2], [ nTrail1, nTrail2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingCharsAsSections()
		return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsZZ()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		def FindLeadingAndTrailingCharsAsSections()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		def FindLeadingAndTrailingCharsZZ()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED TRAILING AND LEADING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok
		
		# Composing the result

		aResult = [ [ nTrail1, nTrail2], [ nLead1, nLead2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsAsSectionsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingCharsAsSections()
		return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsZZ()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		def FindTrailingAndLeadingCharsAsSections()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		def FindTrailingAndLeadingCharsAsSectionsZZ()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED LEADING AND TRAILING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingAndTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingAndTrailingCharsZ()
		return This.RepeatedLeadingAndTrailingCharsCSZ(1)

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsZ()
			return This.RepeatedLeadingAndTrailingCharsZ()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZ()
		return This.RepeatedTrailingAndLeadingCharsCSZ(1)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsZ()
			return This.RepeatedTrailingAndLeadingCharsZ()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZZ()
		return This.RepeatedTrailingAndLeadingCharsCSZZ(1)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsZZ()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		#>

	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING CHARS   #
	#==================================================#

	def RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingAndTrailingCharsCSQ()
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)

		def LeadingAndTrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingAndTrailingChars()
		This.RemoveRepeatedLeadingAndTrailingCharsCS(1)

		def RemoveRepeatedLeadingAndTrailingCharsQ()
			This.RemoveRepeatedLeadingAndTrailingChars()
			return This

		def RemoveLeadingAndTrailingRepeatedChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingRepeatedCharsQ()
				This.RemoveLeadingAndTrailingRepeatedChars()
				return This
	
		def RemoveLeadingAndTrailingChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingCharsQ()
				This.RemoveLeadingAndTrailingChars()
				return This
	
	def RepeatedLeadingAndrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsQ().Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

		def LeadingAndTrailingCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()
		
	  #----------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS LEADING AND TRAILING CHARS  #
	#----------------------------------------------------------#

	def HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.HasRepeatedTrailingCharsCS(pCaseSensitive)

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingAndTrailingChars()
		return This.HasRepeatedLeadingAndTrailingCharsCS(1)

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#--

		def ContainsRepeatedLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#>

	  #--------------------------------------------#
	 #   REMOVING A GIVEN REPEATED LEADING CHAR   #
	#============================================#

	def RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
		if This.LeadingCharCSQ(pCaseSensitive).IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedLeadingCharCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingCharCS(c, pCaseSensitive)
				return This

	#-- @FunctionPassiveForm

	def ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisLeadingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def ThisLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedLeadingChar(c)
		if This.RepeatedLeadingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedLeadingCharCS(c, 1)
		ok

		def RemoveThisRepeatedLeadingCharQ(c)
			This.RemoveThisRepeatedLeadingChar(c)
			return This

		def RemoveThisLeadingRepeatedChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingRepeatedCharQ(c)
				This.RemoveThisLeadingRepeatedChar(c)
				return This

		def RemoveThisLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingCharQ(c)
				This.RemoveThisLeadingChar(c)
				return This

	def ThisRepeatedLeadingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharQ(c).Content()
		return cResult

		def ThisLeadingRepeatedCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def ThisLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

	  #---------------------------------------------#
	 #   REMOVING A GIVEN REPEATED TRAILING CHAR   #
	#---------------------------------------------#

	def RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
		#< QtBased >

		_oQStr_ = QStringObject()
		nLenStr = _oQStr_.size()

		if nLenStr < 2
			return
		ok

		cLastChar = _oQStr_.mid(nLenStr-1, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(c, pCaseSensitive)
			return
		ok

		cBeforeLastChar = _oQStr_.mid(nLenStr-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			aSection = This.FindRepeatedTrailingCharsCSZZ(pCaseSensitive)
			This.RemoveSection(aSection[1], aSection[2])
		ok

		#< @FunctionAlternativeForms

		def RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingCharCS(c, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForm

	def ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		def ThisTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedTrailingChar(c)
		This.RemoveThisRepeatedTrailingCharCS(c, 1)

		#< @FunctionAlternativeForms

		def RemoveThisRepeatedTrailingCharQ(c)
			This.RemoveThisRepeatedTrailingChar(c)
			return This

		def RemoveThisTrailingRepeatedChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingRepeatedCharQ(c)
				This.RemoveThisTrailingRepeatedChar(c)
				return This

		def RemoveThisTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingCharQ(c)
				This.RemoveThisTrailingChar(c)
				return This

		#>

	#-- @FunctionPassiveForm

	def ThisRepeatedTrailingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharQ(c).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingRepeatedCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def ThisTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		#>

	  #--------------------------------------------------------#
	 #   REMOVING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#========================================================#

	def RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
		This.RemoveThisRepeatedLeadingCharCS(c1, pCaseSensitive)
		This.RemoveThisRepeatedTrailingCharCS(c2, pCaseSensitive)
		
		def RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			return This

		def RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndRepeatedCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
				return This

		def RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

		def TheseLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
		This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, 1)

		def RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
			return This

		def RemoveTheseLeadingAndRepeatedChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndRepeatedCharsQ(c1, c2)
				This.RemoveTheseLeadingAndRepeatedChars(c1, c2)
				return This

		def RemoveTheseLeadingAndTrailingChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndTrailingCharsQ(c1, c2)
				This.RemoveTheseLeadingAndTrailingChars(c1, c2)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)

		def TheseLeadingAndTrailingCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
	
	  #==========================================#
	 #   REPLACING EACH REPEATED LEADING CHAR   #
	#==========================================#

	def ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		/* Example:

		StzStringQ("aaaAAAH RING!").
		ReplaceEachLeadingCharCS( :With = "O", 1)
		--> Gives: "OOOAAAH RING!"

		StzStringQ("aaaAVAR").
		ReplaceEachLeadingCharCS( :With = "O",  0)
		--> Gives: "OOOOOOH RING!"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			This.ReplaceSection(
				1, n,
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.REachepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingChar(cNewSubStr)

		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingCharQ(cNewSubStr)
				This.ReplaceEachLeadingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachLeadingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedLeadingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachLeadingCharEachReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

		def EachLeadingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

	  #----------------------------------#
	 #   REPLACING EACH TRAILING CHAR   #
	#----------------------------------#

	def ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		/* Example:

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", 1)
		--> Gives: "RINGaaaOOO"

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O",  0)
		--> Gives: "RINGOOOOOO"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n > 0
			nStart = This.NumberOfChars() - n + 1
			This.ReplaceSection(
				nStart, This.NumberOfChars(),
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedTrailingChar(cNewSubStr)

		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedTrailingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingCharQ(cNewSubStr)
				This.ReplaceEachTrailingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachTrailingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedTrailingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

		def EachTrailingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

	  #-----------------------------------------------#
	 #   REPLACING EACH LEADING AND TRAILING CHARS   #
	#-----------------------------------------------#

	def ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		#-- Char withous "s"

		def ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingandTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChars(cNewSubStr)
				return This

		#-- Char without "s"

		def ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChar(cNewSubStr)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingOrLeadingChar(cNewSubStr)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		return This.ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplace(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplace(cNewSubStr)

		def EachLeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharsReplaced()
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#>

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceFirstNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, 1)

		def ReplaceRepeatedLeadingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)
			return This

		def ReplaceLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)

			def ReplaceLeadingCharsQ(cNewSubStr)
				This.ReplaceLeadingChars(cNewSubStr)
				return This

	def RepeatedLeadingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedLeadingCharsQ(cNewSubStr).Content()

		def LeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingCharReplaced(wNewSubStr)

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceLastNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedTrailingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, 1)

		def ReplaceRepeatedTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)
			return This

		def ReplaceTrailingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)

			def ReplaceTrailingCharsQ(cNewSubStr)
				This.ReplaceTrailingChars(cNewSubStr)
				return This

	def RepeatedTrailingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedTrailingCharsQ(cNewSubStr).Content()

		def TrailingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingCharReplaced(wNewSubStr)

	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------#
	
	def ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingChars(cNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingRepeatedCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingRepeatedCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

	  #---------------------------------------------#
	 #   REPLACING A GIVEN REPEATED LEADING CHAR   #
	#---------------------------------------------#

	def ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		if NOT This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return
		ok

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfLeadingChars()
			This.ReplaceFirstNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisLeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingChar(c, cNewSubStr)
				return This

		def ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceRepeatedLeadingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingCharQ(c, cNewSubStr)
				This.ReplaceLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceLeadingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedLeadingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def ThisLeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#>

	  #----------------------------------------------#
	 #   REPLACING A GIVEN REPEATED TRAILING CHAR   #
	#----------------------------------------------#

	def ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfTrailingChars()
			This.ReplaceLastNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisTrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingChar(c, cNewSubStr)
				return This

		def ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceRepeatedTrailingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingCharQ(c, cNewSubStr)
				This.ReplaceTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceTrailingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedTrailingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def ThisTrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#>

	  #---------------------------------------------------------#
	 #   REPLACING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------------#

	def ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
	
		This.ReplaceThisRepeatedLeadingCharCS(c1, cNewSubStr, pCaseSensitive)
		This.ReplaceThisRepeatedTrailingCharCS(c2, cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
			This.ReplaceTheseRepeatedTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

				These.ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This
		
		#>

	def TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

		These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

				These.ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
				return This

		#>

	def TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		#>

	  #===============================#
	 #     FORWARD TO END OF LINE    #
        #===============================#

	def ForwardToEndOfLine(nStart)

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		if nStart < 1 or nStart > This.NumberOfChars()
			return ""
		ok

		bInside = 1
		cResult = ""
		i = nStart - 1

		while bInside
			i++
						 
			if i = This.NumberOfChars() or
			   This.CharAtQ(i).IsLineSeparator()
			   
				bInside = 0

			else
				cResult += This.NthChar(i)
			ok	
		end

		return cResult

		#< @FunctionFluentForm
	
		def ForwardToEndOfLineQ(nStart)
			return new stzString( This.ForwardToEndOfLine(nStart) )
	
		#>

	  #----------------------------------#
	 #     BACKWARD TO START OF LINE    #
        #----------------------------------#

	def BackwardToStartOfLine( nStart )

		/* Example:
	
			o1 = new stzString( "Mohammed Ali
				Ben Salah" )
			? o1.BackwardToStartOfLine( :StartingAt = 16 ) #--> Ben
			
		*/

		# Enabling the :StartingAt syntax

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		# Checking the range of possible values for nStart param

		if nStart < 1 or nStart > This.NumberOfChars()
			return ""
		ok

		# Computing the rest of the line

		bInside = 1
		cResult = ""
		i = nStart + 1

		while bInside
			i--
					 
			if i = 0 or This.CharAtQ(i).IsLineSeparator()

				bInside = 0
			
			else
				cResult += This.NthChar(i)
			ok
				
		end

		return StringReverse(cResult)

		#< @FunctionFluentForm

		def BackwardToStartOfLineQ( nStart )
			return new stzString( This.BackToStartOfLine( nStart ) )
	
		#>

	  #============================================================================#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#============================================================================#

	def ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		if len(anPos) > 0
			return 1
		else
			return 0
		ok

		def ContainsBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		def ContainsBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.ContainsSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BETWEEN TWO GIVEN POSITIONS  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		anPos = This.FindSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		if len(anPos) > 0
			return 1
		else
			return 0
		ok

		def ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBetweenPositions(pcSubStr, n1, n2)
		return This.ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, 1)

		def ContainsBetweenPositions(pcSubStr, n1, n2)
			return This.ContainsSubStringBetweenPositions(pcSubStr, n1, n2)

	  #-----------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#===================================================================================#

	def NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nResult = len(This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive))
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyOccurrencesOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyTimeSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyTimesSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowOftenSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)
		return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyOccurrencesOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyTimeSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyTimesSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowOftenSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	  #-------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------------#

	def ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		# Checking params

		if CheckingParams()
			if isList(pacBounds) and len(pacBounds) = 2 and
			   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and pacBounds[2][1] = :And
				aTemp = []
				aTemp + pacBounds[1] + pacBounds[2][2]
				pacBounds = aTemp
			ok
				
			if NOT (isString(pacBounds) or (isList(pacBounds) and StzListQ(pacBounds).IsPairOfStrings()) )
				StzRaise("Incorrect params types! pacBounds must be a string or pair of strings.")
			ok
		ok

		# Doing the job

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		aSections = This.FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		nLen = len(aSections)
		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		# Looping over the sections and checking wether their bounds
		# correspond to cBound1 and cBound2

		bResult = 0

		cBound1 = cBound1
		cBound2 = cBound2

		if IsCaseSensitive(pCaseSensitive)
			cBound1 = Q(cBound1).Lowercased()
			cBound2 = Q(cBound2).Lowercased()
		ok

		for i = 1 to nLen
			
			acBounds = This.SectionBounds(aSections[i][1], aSections[i][2], nLenBound1, nLenBound2)

			if acBounds[1] = cBound1 and acBounds[2] = cBound2

				bResult = 1
				exit

			ok

		next

		return bResult

		#< @FunctionAlternativeForm

		def ContainsThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringBoundedBy(pcSubStr, pacBounds)
		return This.ContainsSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def ContainsThisSubStringBoundedBy(pcSubStr, pacBounds)
			return This.ContainsSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	   #--------------------------------------------------------------#
	  #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO  #
	 #  OTHER SUBSTRINGS STARTING AT A GIVEN POSITION               #
	#--------------------------------------------------------------#

	def ContainsSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = This.NumberOfChars()
		bResult = This.SectionQ(pnStartingAt, nLen).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		return bResult

		def ContainsSubStringBoundedBySartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.ContainsSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, 1)

		def ContainsSubStringBoundedBySartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

	   #-------------------------------------------------------------------------#
	  #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO OTHER       #
	 #  SUBSTRINGS STARTING AT A GIVEN POSITION -- GOiNG IN A GIVEN DIRECTION  #
	#-------------------------------------------------------------------------#

	def ContainsSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = This.NumberOfChars()
		cDirection = @Direction(pcDirection)

		if cDirection = :Forward
			bResult = This.SectionQ(pnStartingAt, nLen).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		else
			bResult = This.SectionQ(1, pnStartingAt).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		ok

		return bResult


		def ContainsSubStringBoundedByStartingAtDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.ContainsSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.ContainsSubStringBoundedBySDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)


		def ContainsSubStringBoundedByStartingAtD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.ContainsSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

	  #---------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=================================================================================#

	def NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nResult = len( This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceOfSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#==

		def CountSubStringsBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceOfSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		def NumberOfOccurrencesOfSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		def CountSubStringsBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	   #---------------------------------------------------------------#
	  #  GETTING THE NUMBER OF OCCURRENCES OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION            #
	#---------------------------------------------------------------#

	def NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nResult = len( This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedBySTCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#==

		def NumberOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByStartingAtCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringBoundedByS(pcSubStr, pacBounds, pnStartingAt)
		return This.NumberOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, 1)

		def NumberOfOccurrenceBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByST(pcSubStr,pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrencesOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#==

		def NumberOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByStartingAt(pcSubStr,pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrencesOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#=======================================================================================#

	def ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		bResult = ( This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive) = n )

		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def ContainsNOccurrenceBetweenCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def ContainsNOccurrencesBetweenCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)
		return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		def ContainsNOccurrenceBetween(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		def ContainsNOccurrencesBetween(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#------------------------------------------------------------------------------------------#

	def ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
		bResult = ( This.CountSubStringsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive) = n )
		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsNOccurrenceBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsNOccurrencesBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrenceOfSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrenceBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrencesBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringboundedBy(n, pcSubstr, pacBounds)
		return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsNOccurrenceBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds)

		def ContainsNOccurrencesBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrenceOfSubStringBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrenceBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrencesBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		#>

	  #----------------------------------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------------------------------------------------------#

	def ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		bResult = ( This.NumberOfOccurrenceboundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive) = n )
		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsNOccurrenceBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsNOccurrencesBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrenceOfSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrenceBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrencesBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringboundedByST(n, pcSubstr, pacBounds, pnStartingAt)
		return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsNOccurrenceBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedBySCST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsNOccurrencesBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrenceOfSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrenceBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrencesBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #========================================================#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST  #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING       #
	#========================================================#

	def FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		/* EXAMPLE 1:

		#                            +--.------------.--------+
		#                            |  13           26       |
		#                            V  |            |        V
		o1 = new stzString("bla bla [[  word bla bla word bla ]] no word bla")
		? o1.FindSubStringBetweenCS("word", "[[", "]]", 0)
		#--> [ 13, 26 ]

		EXAMPLE 2:

		#                            +--.--------..-----.--------+
		#                            |  13       xx     29       |
		#                            V  |        !!     |        V
		o1 = new stzString("bla bla [[  word bla [[ bla word bla ]] no word bla")
		? o1.FindSubStringBetweenCS("word", "[[", "]]", 0)
		#--> [ 13, 29 ]

		EXAMPLE 3:

		#                     |4|               
		o1 = new stzString("12*A*67*A*")
		? o1.FindSubStringBetween("A", "*", "*")
		#--> [4]


		EXAMPLE 4:

		#TODO add an example using positions FindSubStringBetween("ring", 5, 30)
		
		*/

		# Doing the job

		if CheckingParams()
			if isList(pcSubStr1) and
				( StzListQ(pcSubStr1).IsPositionOrPositionsNamedParam() or
				StzListQ(pcSubStr1).IsSubStringOrSubStringsNamedParam() )

				pcSubStr1 = pcSubStr1[2]
			ok

			if isList(pcSubStr2) and
				StzListQ(pcSubStr2).IsAndOrAndPositionOrAndSubStringNamedParam()

				pcSubStr2 = pcSubStr2[2]
			ok

			if NOT ( @AreBothStrings(pcSubStr1, pcSubStr2) or
				 @AreBothNumbers(pcSubStr1, pcSubStr2) )

				StzRaise("Incorrect param type! pcSubStr1, pcSubStr2 must be both strings or numbers.")
			ok
		ok

		n1 = pcSubStr1
		n2 = pcSubStr2

		if @BothAreStrings(pcSubStr1, pcSubStr2)

			n1 = This.FindFirstCS(pcSubStr1, pCaseSensitive)

			if n1 = 0
				return []
			ok

			n1 += StzStringQ(pcSubStr1).NumberOfChars()

			#--

			n2 = This.FindLastCS(pcSubStr2, pCaseSensitive)

			if n2 = 0
				return []
			ok

			n2--

		else // @bothAreNumbers()

			if n1 = 0 or n2 = 0
				return []
			ok

			n1 += 1
			n2 -= 1
		ok

		anResult = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#--

		def FindBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#>

	   #----------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST    #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING -- IB   #
	#----------------------------------------------------------#

	def FindSubStringBetweenCSIB(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr1 = StzSubStringQ(pcSubStr1).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + (anPos[i] - nLenSubStr1)
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenCSIBZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBetweenCSIBZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenIB(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSIB(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenIBZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		#--

		def FindBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		def FindBetweenIBZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		#>

	   #------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN    #
	 #  SUBSTRING AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING  #
	#==============================================================================#

	def BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		if CheckingParams()
			if isList(pSubStrOrPos2) and StzListQ(pSubStrOrPos2).IsAndNamedParam()
				pSubStrOrPos2 = pSubStrOrPos2[2]
			ok
		ok

		if NOT ( @BothAreStrings(pSubStrOrPos1, pSubStrOrPos2) or @BothAreNumbers(pSubStrOrPos1, pSubStrOrPos2) )
			StzRaise("Incorrect params types! pSubStrOrPos1 and pSubStrOrPos2 must be both strings or numbers.")
		ok

		if @BothAreStrings(pSubStrOrPos1, pSubStrOrPos2)

			n1 = This.FindFirstOccurrenceCS(pSubStrOrPos1, pCaseSensitive)

			if n1 = 0
				return ""
			else
				n1 += StzStringQ(pSubStrOrPos1).NumberOfChars()
			ok


			n2 = This.FindLastOccurrenceCS(pSubStrOrPos2, pCaseSensitive)

			if n2 = 0
				return ""
			else
				n2--
			ok

		else // @BothAreNumber

			n1 = pSubStrOrPos1
			n1++

			n2 = pSubStrOrPos2
			n2--
		ok

		cResult = This.Section(n1, n2)
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def Between(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, 1)

		#< @FunctionAlternativeForm

		def SubStringBetween(pSubStrOrPos1, pSubStrOrPos2)
			return This.Between(pSubStrOrPos1, pSubStrOrPos2)

		#>

	   #--------------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	 #  AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- IB/EXTENDED     #
	#======================================================================================#

	def BetweenCSIB(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		if isNumber(pSubStrOrPos1) and isNumber(pSubStrOrPos2)
			return This.Section(pSubStrOrPos1, pSubStrOrPos2)
		ok

		n1 = This.FindFirstCS(pSubStrOrPos1, pCaseSensitive)
		n2 = This.FindLastCS(pSubStrOrPos2, pCaseSensitive) + StzStringQ(pSubStrOrPos2) - 1
		cResult = This.Section(n1, n2)

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIB(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSIB(pSubStrOrPos1, pSubStrOrPos2, 1)

	   #-----------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST     #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING -- IBZZ  #
	#-----------------------------------------------------------#

	def FindSubStringBetweenCSIBZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(aSection)
		nLen1 = StzStringQ(pcSubStr1).NumberOfChars()
		nLen2 = StzStringQ(pcSubStr2).NumberOfChars()
		aResult = []

		for i = 1 to nLen
			aResult + [ aSection[i][1] - nLen1, aSection[i][2] + nLen2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenIBZZ(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSIBZZ(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForms

		def FindBetweenIBZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIBZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN         #
	 #  SUBSTRING AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- ZZ #
	#===================================================================================#

	def BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		cSubStr = This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		aResult = [ cSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForm

		def SubStringBetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def BetweenZZ(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, 1)

		#< @FunctionAlternativeForm

		def SubStringBetweenZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenZZ(pSubStrOrPos1, pSubStrOrPos2)

		#>

	   #--------------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	 #  AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- IBZZ/EXTENDED   #
	#======================================================================================#

	def BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		cSubStr = This.BetweenCSIB(SubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		aResult = [ cSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForms

		def AnyBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		def SubStringBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, 1)

		#< @FunctionAlternativeForms

		def AnyBetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)

		def SubStringBetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)

		#>

	  #======================================================================#
	 #  FINDING OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#======================================================================#

	def FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		# Checking params

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pacBounds) and len(pacBounds) = 2 and
			   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and pacBounds[2][1] = :And
				aTemp = []
				aTemp + pacBounds[1] + pacBounds[2][2]
				pacBounds = aTemp
			ok

			if NOT ( isString(pacBounds) or (isList(pacBounds) and StzListQ(pacBounds).IsPairOfStrings()) )
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		ok

		# Doing the job

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfSrrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()

		anPos = This.FindAllCS( cBound1 + pcSubStr + cBound2, pCaseSensitive )

		anResult = []

		if len(anPos) > 0
			anResult = QRT(anPos, :stzListOfNumbers).AddedToEach(nLenBound1)
		ok

		return anResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)
	
		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubstringBoundedBy(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindSubStringBoundedBy(pcSubStr, pacBounds)
	
		#>

	  #------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#==================================================================#

	def FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		nLenStr = Q(pcSubStr).NumberOfChars()
		nLenPos = len(anPos)

		aResult = []

		for i = 1 to nLenPos
			aResult + [ anPos[i], anPos[i] + nLenStr - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#--

		def FindBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def FindBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionAlternativeForm

		def FindSubStringBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		#--

		def FindBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		def FindBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#---------------------------------------------------------------------#

	def FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		anPos = This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLenStr = Q(pcSubStr).NumberOfChars()
		nLenPos = len(anPos)

		aResult = []

		for i = 1 to nLenPos
			aResult + [ anPos[i], anPos[i] + nLenStr - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		anPos = This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(anPos)

		nLenBound1 = 0

		if isString(pacBounds)
			nLenBound1 = Q(pacBounds).NumberOfChars()
		else
			nLenBound1 = Q(pacBounds[1]).NumberOfChars()
		ok

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] - nLenBound1)
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCSIB(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByIB(pcSubStr, pacBounds)
	
		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS #
	#-------------------------------------------------------------------------------------#

	def FindSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(aSections)

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2]  + nLenBound2
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindSubStringBouondedByCSIBZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBooundedByAsSectionsIB(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------------------#

	def FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nLast = This.NumberOfChars()
		anPos = This.SectionQ(pnStartingAt, nLast).FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(anPos)

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] + pnStartingAt - 1 )
		next

		return anResult

		#< @FunctionalternativeForms
	
		def FindSubStringBoundedBySCSTZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySCST(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#==================================================================================================#

	def FindSubStringBoundedBySCSTZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		anPos = This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(anPos)
		nLenStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByAsSectionsSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounded, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByAsSectionsST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRING STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------------------#

	def FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		anPos = This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(anPos)
		nLenStr = Q(pcSubStr).NumberOfChars()

		nLenBound1 = 0
		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()
		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
		ok

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] - nLenBound1 )
		next

		return anResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION INCLUDING BOUNDS  #
	#===================================================================================================================#

	def FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		aSections = This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(aSections)

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2] + nLenBound2
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByAsSectionsSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByAsSectionsSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=====================================================================================================#

	def FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		nLast = This.NumberOfChars()
		oSection = This.SectionQ(pnStartingAt, nLast)

		cBound1 = ""
		cBound2 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds
		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		cBounded = cBound1 + pcSubStr + cBound2
		nLenBounded = Q(cBounded).NumberOfChars()
		nStart = pnStartingAt
		bContinue = 1
		nTimes = 0

		nResult = 0

		while bContinue

			nPos = oSection.FindNextSTCS(cBounded, nStart, pCaseSensitive)

			if nPos != 0

				nTimes++

				if nTimes = n
					nResult = nPos + nLenBounded
					bContinue = 0

				else
					nStart = nPos + nLenBounded
				ok

			else
				bContinue = 0
			ok
		end

		if nResult > 0
			nResult -= StzStringQ(cBound1).NumberOfChars()
		ok

		return nResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#--------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(1, pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#--

		def FindNextBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenAsSectionsCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#==

		def FindNextSubStringBetweenSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBetweenAsSectionsSTCS(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenAsSectionsSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBetweenZZ(pcSubStr,pcSubStr1, pcSubStr2, pnStartingAt)
		return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextSubStringBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#--

		def FindNextBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenAsSectionsZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#==

		def FindNextSubStringBetweenSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextSubStringBetweenAsSectionsST(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenAsSectionsSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=================================================================================================#

	def FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedByCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySCSTZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedByZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=========================================================================================================#

	def FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		nLast = This.NumberOfChars()
		oSection = This.SectionQ(1, pnStartingAt)

		cBound1 = ""
		cBound2 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds
		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		cBounded = cBound1 + pcSubStr + cBound2
		nLenBound1= Q(cBound1).NumberOfChars()

		nStart = pnStartingAt
		bContinue = 1
		nTimes = 0

		nResult = 0

		while bContinue

			nPos = oSection.FindPreviousSCS(cBounded, nStart, pCaseSensitive)

			if nPos != 0

				nTimes++

				if nTimes = n
					nResult = nPos + nLenBound1
					bContinue = 0

				else
					nStart = nPos
				ok

			else
				bContinue = 0
			ok
		end

		return nResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousNthSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-------------------------------------------------------------------------------------------------------------------------#

	def FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=====================================================================================================#

	def FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nResult = This.FindPreviousNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedBy(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindPreviousSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		anResult = This.FindPreviousNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForm

		def FindPreviousSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByZZ(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSZZ(pcSubStr, pcBound1, pcBound2, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindPreviousSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#==========================================================================================================================#

	def FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nResult = this.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #------------------------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS -- ZZ/EXTENSION  #
	#------------------------------------------------------------------------------------------------------------------------------------------#

	def FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=================================================================================================#

	def FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByIB(1, pcSubStr, pacBounds, pnStartingAt)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedByIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(1, pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByIBZZ(1, pcSubStr, pacBounds, pnStartingAt)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=========================================================================================================#

	def FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nResult = This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)


		#>

	  #-------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-------------------------------------------------------------------------------------------------------------------------#

	def FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  STARTING AT A GIVEN POSITION  #
	#======================================================================================================#

	def FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindPreviousNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  STARTING AT A GIVEN POSITION -- ZZ/EXTENDED  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindPreviousNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#================================================================#

	def FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if CheckingParams()
			if NOT ( ( isString(pcBound1) or isNumber(pcBound1) ) and
				 ( isString(pcBound2) or isNumber(pcBound2) ) )

				StzRaise("Incorrect params types! pcBound1 and pcBound2 must be strings or numbers.")
			ok
		ok

		n1 = 0
		n2 = 0

		if isString(pcBound1)
			n1 = This.FindFirstCS(pcBound1, pCaseSensitive)

		else // isNumber()
			n1 = pcBound1
		ok

		if isString(pcBound2)
			n2 = This.FindLastCS(pcBound2, pCaseSensitive)

		else // isNumber()
			n2 = pcBound2
		ok

		nResult = This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm
	
		def FindNthSubStringBetweenCSZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindNthBetweenCSZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm
	
		def FindNthSubStringBetweenZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		#--

		def FindNthBetween(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		def FindNthBetweenZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#-------------------------------------------------------------------#

	def FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isString(pacBounds) or ( isList(pacBounds) and @IsPairOfStrings(pacBounds) ) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		# Getting the bounds in two separate strings

		cBound1 = ""
		cBound2 = ""

		if isList(pacBounds)
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else // isString()
			cBound1 = pacBounds
			cBound1 = pacBounds
		ok

		# Getting the bounded substring

		cBounded = cBound1 + pcSubStr + cBound2

		# Doing the job

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nResult = This.FindNthCS(n, cBounded, pCaseSensitive) + nLenBound1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitives)

		#--

		def FindNthBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitives)

		def FindNthBoundedByCSZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBy(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBounds)

		#--

		def FindNthBoundedBy(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBounds)

		def FindNthBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBounds)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING ANY NTH SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------#

	def FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nResult = 0
		anPos = This.FindTheseBoundsCS(pacBounds, pCaseSensitive)

		if n <= len(anPos)
			cBound1 = @Bounds(pacBounds)[1]
			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nResult = anPos[n] + nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindAnyNthSubBoundedByCS(n, pacBounds, pCaseSensitive)
			return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)

		def FindAnyNthBoundedByCSZ(n, pacBounds, pCaseSensitive)
			return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyNthSubStringBoundedBy(n, pacBounds)
		return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindAnyNthBoundedBy(n, pacBounds)
			return This.FindAnyNthSubStringBoundedBy(n, pacBounds)

		def FindAnyNthBoundedByZ(n, pacBounds)
			return This.FindAnyNthSubStringBoundedBy(n, pacBounds)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#=====================================================================#

	def FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
	
		#--

		def FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindFirstBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
	
		#--

		def FindFirstBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindFirstBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#---------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindFirstBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBy(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedBy(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBounds)

		def FindFirstBoundedByZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#=================================================================#

	#TODO // check performance!

	def FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCS(nLast, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
	
		#--

		def FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindLastBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
	
		#--

		def FindLastBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindLastBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2s)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#--------------------------------------------------------------------#

	def FindLastSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCS(nLast, pcSubStr, pacBounds, pCaseSensitive)


		#< @FunctionAlternativeForm

		def FindLastSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindLastBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBoundedBy(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindLastSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(pcSubStr, pacBounds)

		#--

		def FindLastBoundedBy(n, pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(n, pcSubStr, pacBounds)

		def FindLastBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(n, pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------#
	  #   FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO   #
	 #   OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS     #
	#=======================================================#

	def FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nPos = This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = [ nPos, nPos + nLenSubStr - 1 ]

		return aResult

		#< @FunctionAlternativeForms
	
		def FindNthSubStringBetweenAsSectionCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindNthBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForms
	
		def FindNthSubStringBetweenAsSection(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		#--

		def FindNthBetweenZZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		def FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		#>

	   #--------------------------------------------------------#
	  #   FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY     #
	 #   TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#=======================================================#

	def FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
		if nPos = 0
			return []
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ nPos, nPos + nLenSubstr - 1 ]

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindNthBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		def FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		#--

		def FindNthBoundedByZZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		def FindNthBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)

		nResult = this.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindNthBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#--

	def FindNthSubStringBoundedByIB(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIB(n, pcSubStr, pacBounds)

		#--

		def FindNthBoundedByIBZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER             #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
		if nPos = 0
			return []
		ok

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		n1 = nPos
		n2 = nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1
		aResult = [ n1, n2 ]

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindNthBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		def FindNthBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsIB(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds)

		#>

	   #----------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  OTHER SUBSTRINGS STARTING AT A GIVEN POSITION     #
	#====================================================#

	def FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
		ok

		nPos = This.SectionQ(pnStartingAt, This.NumberOfChars()).
			FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if nPos = 0
			return 0
		ok

		nResult = nPos + pnStartingAt - 1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSIVITY

	def FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS       #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedByAsSectionSTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByAsSectionST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #---------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#===============================================================#

	def FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		cBound1 = ""

		if isString(pacBounds)
			cBound1 = pacBounds

		else
			cBound1 = pacBounds[1]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		nResult = nPos - nLenBound1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS   #
	#===================================================================================#

	def FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		aResult = []
		nPos = This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos > 0

			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
			aResult = [ nPos, nPos + nLenSubStr - 1 ]

		ok

		return aResult


		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedByAsSectionSTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByAsSectionSTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	#NOTE
	# ...Between...() functions are not DIRECTION-aware and thus can not have an D() extension
	# Also, the same functions can't have an ST() ewtension for :StartingAt

	   #----------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION   #
	#----------------------------------------------------#

	def FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		
		cDirection = @Direction(pcDirection)

		if cDirection = "forward"
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		but cDirection = "backward"
			nLen = This.NumberOfChars()
			return This.FindNthPreviousSubStringBoundedBySCS(n, pcSubStr, pacBounds, nLen, pCaseSensitive)

		else
			StzRaise("Incorrect param! pcDirection must be a string containg :Forward or :Backward.")

		ok

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDCSZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByDCSZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByDZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS          #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		anResult = [ nPos, (nPos + nLenSubStr - 1) ]

		return anResult


		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByAsSectionD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)

		#>
	
	   #--------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nLenBound1 = 0
		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		nResult = nPos - nLenBound1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDCSIBZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByDCSIBZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDIBZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByDIBZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING  #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   # 
	#-------------------------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nPos = This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		nLenBound1 = 0
		nLenBound2 = 0

		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()
			nLenBound2 = nLenBound1
		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			nLenBound2 = StzStringQ(pacBounds[2]).NumberOfChars()
		ok

		anResult = [ nPos, (nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1) ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByAsSectionDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION            #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		cDirection = @Direction(pcDirection)

		if cDirection = :Forward
			return This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		else // :Backward
			return This.FindNthPreviousSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		ok

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDCSZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedBySTDCSZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedBySTDZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING       #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionSTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedByAsSectionSTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING  #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS            #
	#-----------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		cBound1 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
		else
			cBound1 = pacBounds[1]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		nResult = nPos - nLenBound1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedBySTDCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedBySTDIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-----------------------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN   #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS  #
	#-----------------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionSTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedByAsSectionSTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BETWEEN TWO  #
	 #  OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS      #
	#=======================================================#

	def FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm
	
		def FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindFirstBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindFirstBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm
	
		def FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#--

		def FindFirstBetweenZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		def FindFirstBetweenAsSections(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY   #
	 #  TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#-------------------------------------------------------#

	def FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindFirstBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedByZZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		def FindFirstBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindFirstBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		def FindFirstBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedByIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBounds)

		def FindFirstBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER           #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindFirstBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedByIBZZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		def FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	   #------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS         #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, 1)
	
		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionsST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS   #
	#----------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS     #
	#-------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySIBZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION     #
	#------------------------------------------------------#

	def FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCS(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS            #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSZZ(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS    #
	#----------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIB(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING  #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS     # 
	#---------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIBZZ(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIBZZ(1, pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION              #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCS(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING     #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @functionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @functionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING  #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS              #
	#-------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSIB(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN  #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   #
	#------------------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		if nPos = 0
			return []
		else
			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

			if isString(pacBounds)
				cBound1 = pacBounds
				cBound2 = pacBounds
			else
				cBound1 = pacBounds[1]
				cBound2 = pacBounds[2]
			ok

			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nLenBound2 = StzStringQ(cBound2).NumberOfChars()

			anResult = [ nPos, nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1 ]
			return anResult
		ok

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BETWEEN TWO  #
	 #  OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS     #
	#======================================================#

	def FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLast = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(nLast, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm
	
		def FindLastSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindLastBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)
		return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, 1)

		#< @FunctionAlternativeForm
	
		def FindLastSubStringBetweenAsSection(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#--

		def FindLastBetweenZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		def FindLastBetweenAsSection(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY    #
	 #  TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#-------------------------------------------------------#

	def FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindLastBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		#--

		def FindLastBoundedByZZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		def FindLastBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nResult = This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindLastBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		def FindLastBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBounds)

		#--

		def FindLastBoundedByIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBounds)

		def FindLastBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER            #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindLastBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#--

		def FindLastBoundedByIBZZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		def FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	   #------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY   #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------#

	def FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #--------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS        #
	#--------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS   #
	#----------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLast = this.NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIB(nLast, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	   #------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS    #
	#------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIBZZ(nLast, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-----------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION    #
	#-----------------------------------------------------#

	def FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCS(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#>

	   #--------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS           #
	#--------------------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSZZ(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS    #
	#----------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIB(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING   #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS     # 
	#---------------------------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIBZZ(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS   #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION              #
	#---------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nLen = This.NumberOfChars()
		cDirection = @Direction(pcDirection)
		n = @StartingAt(pnStartingAt)

		if n = :First
			n = 1
		but n = :Last
			n = nLen
		ok

		if cDirection = :Forward
			nResult = This.SectionQ(pnStartingAt, nLen).FindLastSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			nResult += pnStartingAt - 1

		else // :Backward
			nResult = This.SectionQ(1, pnStartingAt).FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		ok

		return nResult
		
		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByTSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING      #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nPos = FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		anResult = []

		if nPos > 0
			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
			anResult = [ nPos, nPos + nLenSubStr - 1 ]
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDC(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING   #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS              #
	#-------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceBoundedBySTCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSIB(nLast, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN   #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   #
	#================================================================================================#

	def FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nPos = This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			cBound1 = ""
			cBound2 = ""

			if isString(pacBounds)
				cBound1 = pacBounds
				cBound2 = pacBounds

			else
				cBound1 = pacBounds[1]
				cBound2 = pacBounds[2]
			ok

			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nLenBound2 = StzStringQ(cBound2).NumberOfChars()

			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

			anResult = [ nPos, ( nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1 ) ]
			return anResult
		ok

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	  #=========================================================================================#
	 #  CHECKING IF THE STRING CONTAINS ANY SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#=========================================================================================#

	def ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)

		n1 = This.FindFirstCS(acBounds[1], pCaseSensitive)
		if n1 = 0
			return 0
		ok

		n2 = This.FindFirstCS(acBounds[2], pCaseSensitive)
		if n2 = 0
			return 0
		ok

		if n2 > n1
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def ContainsAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def ContainsBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def ContainsAtLeastASubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubstringsBoundedBy(pacBounds)
		return This.ContainsSubstringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def ContainsAnySubStringBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		def ContainsBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		def ContainsAtLeastASubStringBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		#>

	  #--------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS BOUNDED BY THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------------#

	def NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		nResult = len( This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManyOccurrenceOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManyOccurrencesOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def CountSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def CountOccurrencesOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def CountOccurrenceOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def CountSubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def NumberOfOccurrenceOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManySubStringBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManySubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManyOccurrenceOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)


		def HowManyOccurrencesOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		#--

		def CountSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def CountOccurrencesOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def CountOccurrenceOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def CountSubStringBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS BOUNDED BY THE GIVEN SUBSTRINGS -- IB  #
	#--------------------------------------------------------------------------#

	def NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		nResult = len( This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def HowManySubStringBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def HowManySubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def HowManyOccurrenceOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)


		def HowManyOccurrencesOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsBoundedByIB(pacBounds)
		return This.NumberOfSubStringsBoundedByCSIB(pacBounds, 1)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		def NumberOfOccurrenceOfSubStringsBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		def HowManySubStringBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		def HowManySubStringsBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		def HowManyOccurrenceOfSubStringsBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		def HowManyOccurrencesOfSubStringsBoundedByIB(pacBounds)
			return This.NumberOfSubStringsBoundedByIB(pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#=================================================================#

	def FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)

		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		aSections = This.FindTheseBoundsCSZZ(cBound1, cBound2, pCaseSensitive)

		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen step 2
			anResult + aSections[i][2]++
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindAnyBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedBy(pacBounds)
		return This.FindSubStringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringsBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindSubStringsBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringsBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindAnyBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnyBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- ZZ/EXTENSION  #
	#=================================================================================#

	def FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		aSections = This.FindTheseBoundsCSZZ(cBound1, cBound2, pCaseSensitive)

		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ aSections[i][2]++, aSections[i+1][1]-- ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def FindSubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByZZ(pacBounds)
		return This.FindSubStringsBoundedByCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnySubStringsBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#--

		def FindSubStringsBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#--

		def FindAnyBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnyBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#==

		def FindAnySubStringBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnySubStringsBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#--

		def FindBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#=================================================================#

	def SubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		acResult = []

		if nLen > 0
			acResult = This.Sections(aSections)
		ok

		return acResult


		#< @FunctionAlternativeForms

		def BoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnyBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedBy(pacBounds)
		return This.SubStringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedBy(pacBounds)
			return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringsBoundedBy(pacBounds)
			return This.SubStringsBoundedBy(pacBounds)

		def AnyBoundedBy(pacBounds)
			return This.SubStringsBoundedBy(pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------------------------#

	def SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		anPos = []
		for i = 1 to nLen
			anPos + aSections[i][1]
		next

		aResult = @Association([ This.Sections(aSections), anPos ])
		return aResult



		#< @FunctionAlternativeForms

		def BoundedByCSZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirPositionsCS(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByZ(pacBounds)
		return This.SubStringsBoundedByCSZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnySubStringsBoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnyBoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirPositions(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnySubStringsBoundedByAndTheirPositions(acBounds)
			return This.SubStringsBoundedByCSZ(pacBounds)

		#>
	
	  #-------------------------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS ALONG WITH THEIR SECCTIONS  #
	#-------------------------------------------------------------------------------------------#

	def SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		aResult = @Association([ This.Sections(aSections), aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def BoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByZZ(pacBounds)
		return This.SubStringsBoundedByCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnySubStringsBoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnyBoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirSections(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnySubStringsBoundedByAndTheirSections(acBounds)
			return This.SubStringsBoundedByCSZZ(pacBounds)

		#>

	  #------------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS - U/EXTENDED  #
	#==============================================================================#

	def SubStringsBoundedByCSU(pacBounds, pCaseSensitive)
		return U( This.SubStringsBoundedByCS(pacBounds, pCaseSensitive) )


		#< @FunctionAlternativeForms

		def BoundedByCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSU(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSU(pacBounds, pCaseSensitive)

		def AnyBoundedByCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSU(pacBounds, pCaseSensitive)

		#--

		def UniqueSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSU(pacBounds, pCaseSensitive)

		def UniqueBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSU(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByU(pacBounds)
		return This.SubStringsBoundedByCSU(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedByU(pacBounds)
			return This.SubStringsBoundedByU(pacBounds)

		def AnySubStringsBoundedByU(acBounds)
			return This.SubStringsBoundedByU(pacBounds)

		def AnyBoundedByU(pacBounds)
			return This.SubStringsBoundedByU(pacBounds)

		#--

		def UniqueSubStringsBoundedBy(pacBounds)
			return This.SubStringsBoundedByU(pacBounds)

		def UniqueBoundedBy(pacBounds)
			return This.SubStringsBoundedByU(pacBounds)

		#>

	   #----------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	 #  ALONG WITH THEIR POSITIONS -- U/EXTENDED                      #
	#----------------------------------------------------------------#

	def SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)
		aSections = This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		if nLen = 0
			return []
		ok

		bCase = @CaseSensitive(pCaseSensitive)

		if bCase = 0
			for i = 1 to nLen
				aSections[i][1] = lower(aSections[i][1])
			next
		ok

		acSeen = []
		aResult = []

		for i = 1 to nLen

			nPos = ring_find(acSeen, aSections[i][1])

			if nPos = 0
				aResult + [ aSections[i][1], [ aSections[i][2] ] ]
				acSeen + aSections[i][1]
			else

				aResult[nPos][2] + aSections[i][2]

			ok

		next

		return aResult

		#< @FunctionAlternativeForms

		def BoundedByCSUZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSUZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirPositionsCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirPositionsCSU(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByUZ(pacBounds)
		return This.SubStringsBoundedByCSUZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedByUZ(pacBounds)
			return This.SubStringsBoundedByUZ(pacBounds)

		def AnySubStringsBoundedByUZ(pacBounds)
			return This.SubStringsBoundedByUZ(pacBounds)

		def AnyBoundedByUZ(pacBounds)
			return This.SubStringsBoundedByUZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirPositionsU(pacBounds)
			return This.SubStringsBoundedByUZ(pacBounds)

		def AnySubStringsBoundedByAndTheirPositionsU(acBounds)
			return This.SubStringsBoundedByCSUZ(pacBounds)

		#>
	
	   #----------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	 #  ALONG WITH THEIR SECTIONS -- U/EXTENDED                       #
	#----------------------------------------------------------------#

	def SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)
		aSections = This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		if nLen = 0
			return []
		ok

		bCase = @CaseSensitive(pCaseSensitive)

		if bCase = 0
			for i = 1 to nLen
				aSections[i][1] = lower(aSections[i][1])
			next
		ok

		acSeen = []
		aResult = []

		for i = 1 to nLen

			nPos = ring_find(acSeen, aSections[i][1])

			if nPos = 0
				aResult + [ aSections[i][1], [ aSections[i][2] ] ]
				acSeen + aSections[i][1]
			else

				aResult[nPos][2] + aSections[i][2]

			ok

		next

		return aResult

		#< @FunctionAlternativeForms

		def BoundedByCSUZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSUZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirSectionsCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirSectionsCSU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSUZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByUZZ(pacBounds)
		return This.SubStringsBoundedByCSUZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def BoundedByUZZ(pacBounds)
			return This.SubStringsBoundedByUZZ(pacBounds)

		def AnySubStringsBoundedByUZZ(pacBounds)
			return This.SubStringsBoundedByUZZ(pacBounds)

		def AnyBoundedByUZZ(pacBounds)
			return This.SubStringsBoundedByUZZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirSectionsU(pacBounds)
			return This.SubStringsBoundedByUZZ(pacBounds)

		def AnySubStringsBoundedByAndTheirSectionsU(acBounds)
			return This.SubStringsBoundedByCSUZZ(pacBounds)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- IB/EXTENSION  #
	#=================================================================================#

	def FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos = This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		nLen = len(anPos)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] - nLenBound1 )
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def FindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnySubStringBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByIB(pacBounds)
		return This.FindSubStringsBoundedByCSIB(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def FindSubStringsBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnySubStringBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def FindBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnyBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnyBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- IBZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------#

	def FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2] + nLenBound2

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSenitive)

		#--

		def FindAnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByIBZZ(pacBounds)
		return This.FindSubStringsBoundedByCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def FindAnySubStringBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnySubStringsBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def FindBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnyBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnyBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#>

	  #----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#======================================================================#

	def SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aSections = This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return new stzList(This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive))

		#>

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def AnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByCSIB(pacBounds, 1)

		#< @FunctionFluentForm

		def SubStringsBoundedByIBQ(pacBounds)
			return new stzList(This.SubStringsBoundedByIB(pacBounds))

		#>

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		#--

		def AnySubStringBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringsBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def BoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		def AnyBoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBW/EXTENSION  #
	#-----------------------------------------------------------------------#

	def SubStringsBoundedByWCSIB(pacBounds, pcCondition, pCaseSensitive)

		_oaSubStr_ = This.SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
		_acResult_ = _oaSubStr_.ItemsWCS(pcCondition, pCaseSensitive)
		return _acResult_

		#< @FunctionFluentForm

		def SubStringsBoundedByWCSIBQ(pacBounds, pcCondition, pCaseSensitive)
			return new stzList( This.SubStringsBoundedByWCSIB(pacBounds, pcCondition, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def BoundedByWCSIB(pacBounds, pcCondition, pCaseSensitive)
			return This.SubStringsBoundedByWCSIB(pacBounds, pcCondition, pCaseSensitive)

			def BoundedByWCSIBQ(pacBounds, pcCondition, pCaseSensitive)
				return This.SubStringsBoundedByWCSIBQ(pacBounds, pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByWIB(pacBounds, pcCondition)
		return This.SubStringsBoundedByWCSIB(pacBounds, pcCondition, 1)

		#< @FunctionFluentForm

		def SubStringsBoundedByWIBQ(pacBounds, pcCondition)
			return new stzList(This.SubStringsBoundedByWIB(pacBounds, pcCondition))

		#>

		#< @FunctionAlternativeForm

		def BoundedByWIB(pacBounds, pcCondition)
			return This.SubStringsBoundedByWIB(pacBounds, pcCondition)

			def BoundedByWIBQ(pacBounds, pcCondition)
				return This.SubStringsBoundedByWIBQ(pacBounds, pcCondition)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBW/EXTENSION  #
	#-----------------------------------------------------------------------#

	def SubStringsBoundedByWXTCSIB(pacBounds, pcCondition, pCaseSensitive)

		_oaSubStr_ = This.SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
		_acResult_ = _oaSubStr_.ItemsWXT(pcCondition)
		return _acResult_

		#< @FunctionFluentForm

		def SubStringsBoundedByWXTCSIBQ(pacBounds, pcCondition, pCaseSensitive)
			return new stzList( This.SubStringsBoundedByWXTCSIB(pacBounds, pcCondition, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def BoundedByWXTCSIB(pacBounds, pcCondition, pCaseSensitive)
			return This.SubStringsBoundedByWXTCSIB(pacBounds, pcCondition, pCaseSensitive)

			def BoundedByWXTCSIBQ(pacBounds, pcCondition, pCaseSensitive)
				return This.SubStringsBoundedByWXTCSIBQ(pacBounds, pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByWXTIB(pacBounds, pcCondition)
		return This.SubStringsBoundedByWXTCSIB(pacBounds, pcCondition, 1)

		#< @FunctionFluentForm

		def SubStringsBoundedByWXTIBQ(pacBounds, pcCondition)
			return new stzList(This.SubStringsBoundedByWXTIB(pacBounds, pcCondition))

		#>

		#< @FunctionAlternativeForm

		def BoundedByWXTIB(pacBounds, pcCondition)
			return This.SubStringsBoundedByWXTIB(pacBounds, pcCondition)

			def BoundedByWXTIBQ(pacBounds, pcCondition)
				return This.SubStringsBoundedByWXTIBQ(pacBounds, pcCondition)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZ/EXTENSION  #
	#=======================================================================#

	def SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		acSubStr = This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos  = This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		nLen = len(acSubStr)

		bCaseSensitive = @CaseSensitive(pCaseSensitive)

		if bCaseSensitive = 0
			for i = 1 to nLen
				acSubStr[i] = ring_lower(acSubStr[i])
			next
		ok

		#--

		aResult = []
		acSeen = []

		for i = 1 to nLen
			nFound = ring_find(acSeen, acSubStr[i])
			if nFound = 0
				aResult + [ acSubStr[i], anPos[i] ]
				acSeen + acSubStr[i]
			
			else
				n = ring_find(acSeen, acSubStr[i])
				aResult[n] + anPos[i]

			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBZ(pacBounds)
		return This.SubStringsBoundedByCSIBZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnySubStringsBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		#--

		def BoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnyBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZZ/EXTENSION  #
	#------------------------------------------------------------------------#

	def SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		acSubStr   = This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections  = This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		nLen = len(acSubStr)

		bCaseSensitive = @CaseSensitive(pCaseSensitive)

		if bCaseSensitive = 0
			for i = 1 to nLen
				acSubStr[i] = ring_lower(acSubStr[i])
			next
		ok

		#--

		aResult = []
		acSeen = []

		for i = 1 to nLen
			nFound = ring_find(acSeen, acSubStr[i])
			if nFound = 0
				aResult + [ acSubStr[i], aSections[i] ]
				acSeen + acSubStr[i]
			
			else
				n = ring_find(acSeen, acSubStr[i])
				aResult[n] + aSections[i]

			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#==

		def SubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByAsSectionsCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByAsSectionsCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBZZ(pacBounds)
		return This.SubStringsBoundedByCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForms


		def AnySubStringBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		def AnySubStringsBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#--

		def BoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		def AnyBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#==

		def SubStringsBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#--

		def BoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		def AnyBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBU/EXTENSION  #
	#=======================================================================#

	def SubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		return U(This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive))

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBU(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		#--

		def AnySubStringBoundedByAsSectionsCSIBU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAsSectionsCSIBU(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBU(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBU(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBU(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBU(pacBounds)
		return This.SubStringsBoundedByCSIBU(pacBounds, 1)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIBU(pacBounds)
			return This.SubStringsBoundedByIBU(pacBounds)

		#--

		def AnySubStringBoundedByAsSectionsIBU(pacBounds)
			return This.SubStringsBoundedByIBU(pacBounds)

		def AnySubStringsBoundedByAsSectionsIBU(pacBounds)
			return This.FindSubStringsBoundedByIBU(pacBounds)

		#--

		def BoundedByIBU(pacBounds)
			return This.SubStringsBoundedByIBU(pacBounds)

		def AnyBoundedByIBU(pacBounds)
			return This.SubStringsBoundedByIBU(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZU/EXTENSION  #
	#-----------------------------------------------------------------------#

	def SubStringsBoundedByCSIBUZ(pacBounds, pCaseSensitive)

		return U( This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBUZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBUZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBUZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBUZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBUZ(pacBounds)
		return This.SubStringsBoundedByCSIBUZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIBUZ(pacBounds)
			return This.SubStringsBoundedByIBUZ(pacBounds)

		def AnySubStringsBoundedByIBUZ(pacBounds)
			return This.SubStringsBoundedByIBUZ(pacBounds)

		#--

		def BoundedByIBUZ(pacBounds)
			return This.SubStringsBoundedByIBUZ(pacBounds)

		def AnyBoundedByIBUZ(pacBounds)
			return This.SubStringsBoundedByIBUZ(pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZZU/EXTENSION  #
	#------------------------------------------------------------------------#

	def SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		return U( This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive) )



		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBUZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBUZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBUZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBUZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		#==

		def SubStringsBoundedByAsSectionsCSIBU(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByAsSectionsCSIBU(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByAsSectionsCSIBU(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBUZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBUZZ(pacBounds)
		return This.SubStringsBoundedByCSIBUZZ(pacBounds, 1)

		#< @FunctionAlternativeForms


		def AnySubStringBoundedByIBUZZ(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		def AnySubStringsBoundedByIBUZZ(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		#--

		def BoundedByIBUZZ(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		def AnyBoundedByIBUZZ(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		#==

		def SubStringsBoundedByAsSectionsIBU(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		#--

		def BoundedByAsSectionsIBU(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		def AnyBoundedByAsSectionsIBU(pacBounds)
			return This.SubStringsBoundedByIBUZZ(pacBounds)

		#>

	  #===================================================================================#
	 #  DEEP-FINDING OCCURRENCES OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#===================================================================================#

	def DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()
		if nLenBound2 > 1
			nLenBound2++
		ok

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ([ cBound1, cBound2 ], pCaseSensitive)

		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] + nLenBound1
			anResult + n1
		next

		return anResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def DeepFindBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCS(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def DeepFindCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		def DeepFindCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepFindSubStringsBoundedBy(pacBounds)
		return This.DeepFindSubStringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepFindBoundedBy(pacBounds)
			return This.DeepFindSubStringsBoundedBy(pacBounds)

		#--

		def DeepFindSubStringsBoundedByZ(pacBounds)
			return This.DeepFindSubStringsBoundedByCS(pacBounds)

		def DeepFindBoundedByZ(pacBounds)
			return This.DeepFindSubStringsBoundedBy(pacBounds)

		#==

		def DeepFindSubStrings(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedBy(pacBounds)

		def DeepFind(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		#--

		def DeepFindSubStringsZ(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		def DeepFindZ(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- ZZ/EXTENDED  #
	#-----------------------------------------------------------------------------------------------#
	# Bounding substrings are NOT counted in the result

	def DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()
		if nLenBound2 > 1
			nLenBound2++
		ok

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] + nLenBound1
			n2 = aSections[i][2] - nLenBound2
			if nLenBound2 > 1
				n2++
			ok

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def DeepFindBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		def DeepFindCSZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		def DeepFindAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepFindSubStringsBoundedByZZ(pacBounds)
		return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByZZ(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		#--

		def DeepFindSubStringsBoundedByAsSections(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		def DeepFindBoundedByAsSections(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		#==

		def DeepFindSubStringsZZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		def DeepFindSubStringsAsSections(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		def DeepFindZZ(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		def DeepFindAsSections(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult


		#< @FunctionAlternativeForms

		def DeepSubStringsCS(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def DeepBoundedByCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedBy(pacBounds)
		return This.DeepSubStringsBoundedByCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStrings(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedBy(pacBounds)

		def DeepBoundedBy(pacBounds)
			return This.DeepSubStringsBoundedBy(pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- Z/EXTENDED   #
	#--------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
		acSubStr = This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		anPos = This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsCSZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZ(pacBounds, pCaseSensitive)

		def DeepBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByZ(pacBounds)
		return This.DeepSubStringsBoundedByCSZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositions(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByZ(pacBounds)

		def DeepSubStringsAndTheirPositions(pacBounds)
			return This.DeepSubStringsZ(pacBounds)

		def DeepBoundedByZ(pacBounds)
			return This.DeepSubStringsZ(pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- ZZ/EXTENDED  #
	#--------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		acSubStr  = This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsCSZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZZ(pacBounds, pCaseSensitive)

		def DeepBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByZZ(pacBounds)
		return This.DeepSubStringsBoundedByCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSections(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByZZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsZZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByZZ(pacBounds)

		def DeepSubStringsAndTheirSections(pacBounds)
			return This.DeepSubStringsZZ(pacBounds)

		def DeepBoundedByZZ(pacBounds)
			return This.DeepSubStringsZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IB/EXTENDED  #
	#===============================================================================================#

	def DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		anResult = StzListOfPairsQ(aSections).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def DeepFindBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSIBZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepDindSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindSubStringsBoundedByIB(pacBounds)
		return This.DeepFindSubStringsBoundedByCSIB(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByIB(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		#--

		def DeepFindSubStringsBoundedByIBZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		def DeepFindBoundedByIBZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		#==

		def DeepFindSubStringsIBZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByIBZ(pacBounds)

		def DeepFindSubStringsAndTheirPositionsIB(pacBounds)
			return This.DeepDindSubStringsIBZ(pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZZ/EXTENDED  #
	#-------------------------------------------------------------------------------------------------#

	def DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		# Getting the bouning substrings

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		# Doing the job (using a numerical solution based of the bounds positions)

		nNumberOfSections = This.NumberOfOccurrenceCS(cBound1, pCaseSensitive)

		aList1 = This.FindAllCS(cBound1, pCaseSensitive)
		nLenList1 = len(aList1)
		if nLenList1 = 0
			return []
		ok
		
		aList2 = This.FindAllCS(cBound2, pCaseSensitive)
		nLenList2 = len(aList2)
		if nLenList2 = 0
			return []
		ok

		nLenBound2--
		for i = 1 to nLenList2
			aList2[i] += nLenBound2
		next

		aList = aList1
		for i = 1 to nLenList2
			aList + aList2[i]
		next

		aList = ring_sort(aList)

		nLenList = len(aList)
		aSections = []

		while 1

			for i = 2 to nLenList

				if ring_find(aList1, aList[i-1]) > 0 and
				   ring_find(aList2, aList[i]) > 0

					aSections + [ aList[i-1], aList[i] ]
					if len(aSections) = nNumberOfSections
						exit 2
					ok

				ok
			next

			aList = Q(aList).ManyRemoved(Q(aSections).Merged())
			nLenList = len(aList)

		end

		return aSections

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepFindBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSIBZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepDindSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindSubStringsBoundedByIBZZ(pacBounds)
		return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByIBZZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def DeepFindSubStringsBoundedByAsSectionsIB(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		def DeepFindBoundedByAsSectionsIBpacBounds(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		#==

		def DeepFindSubStringsIBZZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		def DeepFindSubStringsAndTheirSectionsIB(pacBounds)
			return This.DeepDindSubStringsIBZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)
		return acResult

		#< @FunctionAlternativeForms

		def DeepSubStringsCSIB(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIB(pacBounds)
		return This.DeepSubStringsBoundedByCSIB(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStringsIB(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIB(pacBounds)

		#>

	  #----------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZ/EXTENDED   #
	#----------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
		acSubStr = This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos = This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepSubStringsCSIBZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIBZ(pacBounds)
		return This.DeepSubStringsBoundedByCSIBZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsIB(pacBounds)
			return This.DeepSubStringsBoundedByIBZ(pacBounds)

		def DeepSubStringsIBZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIBZ(pacBounds)

		def DeepSubStringsAndTheirPositionsIB(pacBounds)
			return This.DeepSubStringsIBZ(pacBounds)

		#>

	  #----------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZZ/EXTENDED  #
	#----------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acSubStr  = This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsCSIBZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIBZZ(pacBounds)
		return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsIB(pacBounds)
			return This.DeepSubStringsBoundedByIBZZ(pacBounds)

		def DeepSubStringsIBZZ(pacBounds)
			if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIBZZ(pacBounds)

		def DeepSubStringsAndTheirSectionsIB(pacBounds)
			return This.DeepSubStringsIBZZ(pacBounds)

		#>

	  #==============================================================#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS  #
	#==============================================================#

	def FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		anResult = This.AntiFindCS(pacBounds, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms


		def FindNestedSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStrings(pacBounds)
		return This.FindNestedSubStringsCS(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedBy(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedBoundedBy(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNested(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		#==

		def FindNestedSubStringsZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedSubStringsBoundedByZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedBoundedByZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS -- ZZ/EXTENSION  #
	#==============================================================================#

	def FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aResult = This.AntiFindCSZZ(pacBounds, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStringsZZ(pacBounds)
		return This.FindNestedSubStringsCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedBoundedByZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		#==

		def FindNestedSubStringsAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedSubStringsBoundedByAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedBoundedByAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		#>

	  #----------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS  #
	#----------------------------------------------------------#

	def NestedSubStringsCS(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aSections = This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStrings(pacBounds)
		return This.NestedSubStringsCS(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedBy(pacBounds)
			return This.NestedSubStrings(pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- Z/EXTENDED  #
	#------------------------------------------------------------------------#

	def NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCS(pacBounds, pCaseSensitive)
		anPos = This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsZ(pacBounds)
		return This.NestedSubStringsCSZ(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByZ(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		#--

		def NestedSubStringsAndTheirPositions(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirPositions(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- ZZ/EXTENDED  #
	#-------------------------------------------------------------------------#

	def NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCS(pacBounds, pCaseSensitive)
		aSections = This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsZZ(pacBounds)
		return This.NestedSubStringsCSZZ(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByZZ(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		#--

		def NestedSubStringsAndTheirSections(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirSections(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS -- IB/EXTENDTED  #
	#==============================================================================#

	def FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		anResult = This.AntiFindCSIB(pacBounds, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms


		def FindNestedSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		def FindNestedCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsCSIBZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		def FindNestedCSIBZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStringsIB(pacBounds)
		return This.FindNestedSubStringsCSIB(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByIB(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		def FindNestedBoundedByIB(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		def FindNestedIB(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		#==

		def FindNestedSubStringsIBZ(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		def FindNestedSubStringsBoundedByIBZ(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		def FindNestedBoundedByIBZ(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		def FindNestedIBZ(pacBounds)
			return This.FindNestedSubStringsIB(pacBounds)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS -- IBZZ/EXTENSION  #
	#--------------------------------------------------------------------------------#

	def FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aResult = This.AntiFindCSIBZZ(pacBounds, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		def FindNestedCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStringsIBZZ(pacBounds)
		return This.FindNestedSubStringsCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByIBZZ(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		def FindNestedBoundedByIBZZ(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		def FindNestedIBZZ(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		#==

		def FindNestedSubStringsAsSectionsIB(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		def FindNestedSubStringsBoundedByAsSectionsIB(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		def FindNestedBoundedByAsSectionsIB(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		def FindNestedAsSectionsIB(pacBounds)
			return This.FindNestedSubStringsIBZZ(pacBounds)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- IB/EXTENDED  #
	#--------------------------------------------_______________--------------#

	def NestedSubStringsCSIB(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aSections = This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsIB(pacBounds)
		return This.NestedSubStringsCSIB(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByIB(pacBounds)
			return This.NestedSubStringsIB(pacBounds)

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- IBZ/EXTENDED  #
	#--------------------------------------------------------------------------#

	def NestedSubStringsCSIBZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCSIB(pacBounds, pCaseSensitive)
		anPos = This.FindNestedSubStringsCSIB(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsIBZ(pacBounds)
		return This.NestedSubStringsCSIBZ(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByIBZ(pacBounds)
			return This.NestedSubStringsIBZ(pacBounds)

		#--

		def NestedSubStringsAndTheirPositionsIB(pacBounds)
			return This.NestedSubStringsIBZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirPositionsIB(pacBounds)
			return This.NestedSubStringsIBZ(pacBounds)

		#>

	  #---------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- IBZZ/EXTENDED  #
	#---------------------------------------------------------------------------#

	def NestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCSIB(pacBounds, pCaseSensitive)
		aSections = This.FindNestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsIBZZ(pacBounds)
		return This.NestedSubStringsCSIBZZ(pacBounds, 1)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByIBZZ(pacBounds)
			return This.NestedSubStringsIBZZ(pacBounds)

		#--

		def NestedSubStringsAndTheirSectionsIB(pacBounds)
			return This.NestedSubStringsIBZZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirSectionsIB(pacBounds)
			return This.NestedSubStringsIBZZ(pacBounds)

		#>

	# TODO: Adding the ...BoundedBy... and ...Between... functions in stzList

	  #=============================================#
	 #   GETTING A RANDOM POSITION IN THE STRING   #
	#=============================================#

	#TODO // Add

	# 	RandomPositions()			RandomChars()
	# 	NRandomPositions()			NRandomChars()

	# 	RandomPositionsGreaterThan()		RandomCharsAfter()
	# 	NRandomPositionsGreaterThan()		NRandomCharsAfter()

	# 	RandomPositionsLessThan()		RandomCharsBefore()
	# 	NRandomPositionsLessThan()		NRandomCharsBefore()

	# 	RandomPositionsExcept()			RandomCharsExcept()
	# 	NRandomPositionsExcept()		NRandomCharsExcept()

	def RandomPosition()

		nResult = ARandomNumberBetween(1, This.NumberOfChars())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPosition()
			return This.RandomPosition()

		def APosition()
			return This.RandomPosition()

		def AnyPosition()
			return This.RandomPosition()

		#>

	  #--------------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING GREATER THAN THE ONE PROVIDED  #
	#--------------------------------------------------------------------------#

	def RandomPositionGreaterThan(n)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfChars()

		if NOT ( n >= 1 and n < nLen - 1 )
			StzRaise("Out of range! n must be >= 1 and < (nLen-1).")
		ok

		nResult = ARandomNumberBetween(n+1, This.NumberOfChars())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def RandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def ARandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		#--

		def APositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def APositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionAfter(n)
			return This.RandomPositionGreaterThan(n)
		
		#>

	  #-----------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING LESS THAN THE ONE PROVIDED  #
	#-----------------------------------------------------------------------#

	def RandomPositionLessThan(n)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfChars()

		if NOT ( n > 1 and n <= nLen )
			StzRaise("Out of range! n must be > 1 and < nLen.")
		ok

		nResult = ARandomNumberBetween(1, n - 1)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def RandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		def ARandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#--

		def APositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def APositionBefore(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING EXECEPT THE ONE PROVIDED  #
	#---------------------------------------------------------------------#

	def RandomPositionExcept(n)

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		aNumbers = Q( 1:This.NumberOfChars() ) - n
		nResult = ARandomNumberIn(aNumbers)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def RandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def ARandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#--

		def APositionExcept(n)
			return This.RandomPositionExcept(n)

		def APositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#>

	  #-----------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING   #
	#=========================================#

	def RandomChar()

		cResult = This.CharAtPosition( This.RandomPosition() )
		return cResult

		#< @functionAlternativeForms

		def ARandomChar()
			return This.RandomChar()

		#--

		def AChar()
			return This.RandomChar()

		def AnyChar()
			return This.RandomChar()

		#>

	  #--------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING AFTER THE PROVIDED POSITION  #
	#--------------------------------------------------------------------#

	def RandomCharAfterPosition(n)

		cResult = This.CharAt( This.RandomPositionGreaterThan(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		#--

		def ACharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		def AnyCharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		#>

	  #---------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING AFTER THE PROVIDED POSITION OR SUBSTRING  #
	#---------------------------------------------------------------------------------#

	def RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)
		if NOT @IsNumberOrString(pPosOrSubStr)
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.RandomCharAfterPosition(pPosOrSubStr)
		else
			nPos = This.FindFirstCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterPosition(nPos)
		ok

		#< @FunctionAlternativeForms

		def ARandomCharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		#--

		def ACharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		def AnyCharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharAfter(pPosOrSubStr)
		return This.RandomCharAfterCS(pPosOrSubStr, 1)

		#< @functionAlternativeForms

		def ARandomCharAfter(pPosOrSubStr)
			return This.RandomCharAfter(pPosOrSubStr)

		#--

		def ACharAfter(pPosOrSubStr)
			return This.RandomCharAfter(pPosOrSubStr)

		def AnyCharAfter(pPosOrSubStr)
			return This.RandomCharAfterCS(pPosOrSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING BEFORE THE PROVIDED POSITION  #
	#---------------------------------------------------------------------#

	def RandomCharBeforePosition(n)

		cResult = This.CharAt( This.RandomPositionLessThan(n) )
		return cResult

		#< @functionAlternativeForms

		def ARandomCharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		#--

		def ACharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		def AnyCharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		#>

	  #----------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING BEFORE THE PROVIDED POSITION OR SUBSTRING  #
	#----------------------------------------------------------------------------------#

	def RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)
		if NOT @IsNumberOrString(pPosOrSubStr)
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.RandomCharBeforePosition(pPosOrSubStr)
		else
			nPos = This.FindFirstCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforePosition(nPos)
		ok

		#< @functionAlternativeForms

		def ARandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		#--

		def ACharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		def  AnyCharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharBefore(pPosOrSubStr)
		return This.RandomCharBeforeCS(pPosOrSubStr, 1)

		#< @FunctionAlternativeForms

		def ARandomCharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		#--

		def ACharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		def  AnyCharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		#>

	  #--------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING EXECEPT THE PROVIDED ONE OR  #
	#  EXCEPT THE ONE AT THE POSITION PROVIDED                           #
	#-------------------------------------------------------------------#

	def RandomCharExceptCS(pPosOrChar, pCaseSensitive)
		if NOT @IsNumberOrChar(pPosOrChar)
			StzRaise("Incorrect param type! pPosOrChar must be a number or char.")
		ok

		if isNumber(pPosOrChar)
			return This.RandomCharExceptPosition(pPosOrChar)

		else
			return This.RandomCharExceptCharCS(pPosOrChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def ARandomCharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		#--

		def ACharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		def AnyCharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomCharExcept(pPosOrChar)
		return This.RandomCharExceptCS(pPosOrChar, 1)

		#< @FunctionAlternativeForms

		def ARandomCharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		#--

		def ACharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		def AnyCharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		#>

	  #---------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING EXECEPT THE ONE AT THE POSITION PROVIDED  #
	#---------------------------------------------------------------------------------#

	def RandomCharExceptPosition(n)
		cResult = This.CharAt( This.RandomPositionExcept(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanPosition(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanCharAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanCharAt(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptAt(n)
			return This.RandomCharExceptPosition(n)

		#==

		def ACharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def ACharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ACharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		#--

		def AnyCharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def AnyCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def AnyCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		#>

	  #---------------------------------------------------------------#
	 #  GETTING A RANDOM CHAR IN THE STRING EXCEPT THE ONE PROVIDED  #
	#---------------------------------------------------------------#

	def RandomCharExceptCharCS(pcChar, pCaseSensitive)
		if NOT ( isString(pcChar) and @IsChar(pcChar) )
			StzRaise("Incorrect param type! pcChar must be a char.")
		ok

		anPos = This.FindAllCS(pcChar, pCaseSensitive)
		anPos = Q(1: This.NumberOfChars()) - Many(anPos)
		nPos  = ARandomNumberIn( anPos )
		cResult = This.CharAt(nPos)
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		#--

		def ACharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		def AnyCharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharExceptChar(pcChar)
		return This.RandomCharExceptCharCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def ARandomCharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		#--

		def ACharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		def AnyCharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		#>

	  #--------------------------------------------#
	 #  GETTING A RANDOM SECTION FROM THE STRING  #
	#============================================#

	def RandomSection()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aResult = This.Section(n1, n2)

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSection()
			return This.RandomSection()

		def AnyRandomSection()
			return This.RandomSection()

		def ASection()
			return This.RandomSection()

		def AnySection()
			return This.RandomSection()

		#--

		def RandomSubString()
			return This.RandomSection()

		def ARandomSubString()
			return This.RandomSection()

		def AnyRandomSubString()
			return This.RandomSection()

		def ASubString()
			return This.RandomSection()

		def AnySubString()
			return This.RandomSection()

		#>

	  #--------------------------------------------------------------------#
	 #  GETTING A RANDOM SECTION FROM THE STRING ALONG WITH ITS POSITION  #
	#--------------------------------------------------------------------#

	def RandomSectionZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, [ n1, n2 ] ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZ()
			return This.RandomSectionZ()

		def AnyRandomSectionZ()
			return This.RandomSectionZ()

		def ASectionZ()
			return This.RandomSectionZ()

		def AnySectionZ()
			return This.RandomSectionZ()

		#--

		def RandomSubStringZ()
			return This.RandomSectionZ()

		def ARandomSubStringZ()
			return This.RandomSectionZ()

		def AnyRandomSubStringZ()
			return This.RandomSectionZ()

		def ASubStringZ()
			return This.RandomSectionZ()

		def AnySubStringZ()
			return This.RandomSectionZ()

		#==

		def RandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ASectionAndItsPosition()
			return This.RandomSectionZ()

		def AnySectionAndItsPosition()
			return This.RandomSectionZ()

		#--

		def RandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def ASubStringAndItsPosition()
			return This.RandomSectionZ()

		def AnySubStringAndItsPosition()
			return This.RandomSectionZ()

		#>

	  #------------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS (AS POSITIONS) FROM THE STRING  #
	#============================================================#

	#TODO // Add "Position" as an misspelled form of "Position"

	def NRandomSectionsAsPositions(n)
		n = NRandomNumberIn(n, 1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok
			
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def NSectionsAsPositions(n)
			return This.NRandomSectionsAsPositions(n)

		#>

	  #---------------------------------------------#
	 #  GETTING N RANDOM SECTIONS FROM THE STRING  #
	#---------------------------------------------#

	def NRandomSections(n)
		aSections = This.NRandomSectionsAsPositions(n)
		aResult = This.Sections(aSections)

		return aResult

	  #------------------------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS FROM THE STRING ALONG WITH THEIR POSITIONS  #
	#------------------------------------------------------------------------#

	def NRandomSectionsZ(n)
		aSections = This.NRandomSectionsAsPositions(n)
		aResult = Association([ This.Sections(aSections), aSections ])

		return aResult

		def NRandomSectionsAndTheirPositions(n)
			return This.NRandomSectionsZ(n)

	  #------------------------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS (AS PAIRS OF POSITIONS) FROM THE STRING  #
	#========================================================================#

	def SomeRandomSectionsAsPairsOfPositions()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsAsPairsOfPositions()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def AnySectionsAsPairsOfPositions()
			return This.SomeRandomSectionsAsPairsOfPositions()

		#--

		def SomeRandomSectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def SomeSectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def AnySectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		#>

	  #----------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS AND THEIR POSITIONS  #
	#----------------------------------------------------#

	def SomeRandomSectionsZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsZ()
			return This.SomeRandomSectionsZ()

		def AnySectionsZ()
			return This.SomeRandomSectionsZ()

		#--

		def SomeRandomSectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def SomeSectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def AnySectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		#==

		def SomeRandomSubStringsZ()
			return This.SomeRandomSectionsZ()

		def SomeSubStringsZ()
			return This.SomeRandomSectionsZ()

		def AnySubStringsZ()
			return This.SomeRandomSectionsZ()

		#--

		def SomeRandomSubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def SomeSubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def AnySubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		#>

	  #---------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS AND THEIR SECTIONS  #
	#---------------------------------------------------#

	def SomeRandomSectionsZZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [n1, n2] ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsZZ()
			return This.SomeRandomSectionsZZ()

		def AnySectionsZZ()
			return This.SomeRandomSectionsZZ()

		#--

		def SomeRandomSectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def SomeSectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def AnySectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		#==

		def SomeRandomSubStringsZZ()
			return This.SomeRandomSectionsZZ()

		def SomeSubStringsZZ()
			return This.SomeRandomSectionsZZ()

		def AnySubStringsZZ()
			return This.SomeRandomSectionsZZ()

		#--

		def SomeRandomSubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def SomeSubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def AnySubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		#>

	  #------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS FROM THE STRING  #
	#================================================#

	def SomeRandomSections()
		aSections = This.SomeRandomSectionsAsPairsOfNumbers()
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def SomeSections()
			return This.SomeRandomSections()

		def AnySections()
			return This.SomeRandomSections()

		#>

	  #================================================#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING   #
	#================================================#

	def SectionCS(n1, n2, pCaseSensitive)

		#TODO // Rethink the necessity of all these named params,
		# what practical value they provide, and in what performance cost!

		#UPDATE // Programmer can skip the param checks by setting SetCheckPrams(0)

		nLen = This.NumberOfChars()

		if CheckingParams()

			# Managing the use of :From and :To named params

			oN1Param = Q(n1)
			oN2Param = Q(n2)

			if isList(n1) and
			   oN1Param.IsOneOfTheseNamedParams([
				:From, :FromPosition, :FromCharAt, :FromCharAtPosition,

				:Start, :FromStart,
				:StartingAt, :StartingAtPosition,
				:StartingAtCharAt, :StartingAtCharAtPosition,

				:Between, :BetweenPosition, :BetweenCharAt,
				:BetweenCharAtPosition,

				:BetweenPositions, :BetweenCharsAtPosition ])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   oN2Param.IsOneOfTheseNamedParams([
				:To, :ToPosition, :ToCharAt, :ToCharAtPosition,
				:ToEndOfWord, :ToEndOfLine, :ToEndOfSentence,

				:EndOfWord, :EndOfLine, :EndOfSentence,

				:End, :ToEnd,
				:Until, :UntilPosition, :UntilCharAt, :UntilCharAtPosition,
				:UpTo, :UpToPosition, :UpToCharAt, :UpToCharAtPosition,

				:And,

				:StartingAt, :StartingAtPosition, :StartingAtCharAt, :StartingAtCharAtPosition ])

				n2 = n2[2]

			ok
	
			# Managing the use of :NthToFirst named param
	
			if isList(n1) and oN1Param.IsOneOfTheseNamedParams([ :NthToFirst, :NthToFirstChar ])
	
				n1 = n1[2] + 1
			ok
	
			if isList(n2) and oN2Param.IsOneOfTheseNamedParams([ :NthToFirst, :NthToFirstChar ])
	
				n2 = n2[2] + 1
			ok
	
			# Managing the use of :NthToLast named param
	
			if isList(n1) and oN1Param.IsOneOfTheseNamedParams([ :NthToLast, :NthToLastChar ])
	
				n1 = nLen - n1[2]
			ok
	
			if isList(n2) and oN2Param.IsOneOfTheseNamedParams([ :NthToLast, :NthToLastChar ])
	
				n2 = nLen - n2[2]
	
			but isList(n2) and oN2Param.IsStoppingAtNamedParam()
	
				n2 = n2[2]
			ok
	
			# Managing the case of :First and :Last keywords
	
			if isString(n1)

				if ring_find([
					:First, :FirstChar,
					:FromFirst, :FromFirstChar ], n1) > 0

					n1 = 1
	
				but ring_find([
					:Last, :LastChar,
					:ToLast, :ToLastChar ], n1) > 0

					n1 = nLen
	
				but n1 = :@
					n1 = n2

				else
					n1 = This.FindFirstCS(n1, pCaseSensitive)
				ok
			ok
		
			if isString(n2)

				if ring_find([
					:End, :Last, :LastChar, :EndOfString,
					:ToEnd, :ToLast, :ToLastChar, :ToEndOfString ], n2) > 0

					n2 = nLen
	
				but ring_find([
					:First, :FirstChar,
					:FromFirst, :FromFirstChar ], n2) > 0

					n2 = 1
	
	
				but n2 = :@
					n2 = n1

				but n2 = :EndOfWord or n2 = :EndOfSentence or n2 = :EndOfLine
					# Do nothing here, will be managed later
				else
					nLen2 = StzStringQ(n2).NumberOfChars()
					n2 = This.FindLastCS(n2, pCaseSensitive) + nLen2 - 1
				ok
			ok

			if n1 = :@ and n2 = :@
				n1 = 1
				n2 = nLen
			ok

			# Managing the case of :EndOfSentence, :EndOfLine, and :EndOfWord keywords
	
			if n1 > 0 and isString(n2) and n2 = :EndOfSentence

				n2 = nLen
				for i = 1 to nLen
					if QStringObject().mid(i-1, 1) = "."
						n2 = i
						exit
					ok
				next

				return This.Section(n1, n2)
			ok
	
			if n1 > 0 and isString(n2) and n2 = :EndOfLine
				n2 = This.FindFirst(NL)
				return This.Section(n1, n2-1)		
			ok

			if n1 > 0 and isString(n2) and n2 = :EndOfWord #TODO // should move to stzText?

				n2 = nLen-1
				for i = 1 to nLen
					if QStringObject().mid(i-1, 1) = " "
						n2 = i-2
						exit
					ok
				next

				return This.Section(n1, n1 + n2 - 2)
			ok

			# Params must be numbers
	
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params! n1 and n2 must be numbers.")
			ok

			#TODO // do same behavior in stzList.Section()
			#TODO // Add SectionXT() that allows using out of index params and return accurate results

		ok

		#NOTE // When positions are given in inversed order, the same
		# section as if they were not inverted is returned, so:
		#--> Q("ring").Section(1,3) and .Section(3,1) both return "rin"

		# In some languages, like Pyhton for example, reverting the positions,
		# inverts the section. So:
		#--> Q("ring").Section(1,3) returns "rin" but .Section(3,1) returns 'nir"

		# If you need to use this feature in Softanza, use the eXTended form of Section(),
		# like this :
		#--> Q("ring").SectionXT(3,1) and it will return "nir"

		anTemp = ring_sort([ n1, n2 ])
		n1 = anTemp[1]
		n2 = anTemp[2]

		# params must be in range

		if NOT 	( ( n1 >= 1 and n1 <= nLen ) and
			   ( n2 >= 1 and n2 <= nLen ) )
				
			StzRaise("Indexes out of range! n1 and n2 must be inside the string.")
		ok

		if n1 = n2
			cResult = This.Char(n1)
			
		but n1 < n2
			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		else // n2 < n1
			# Swapping n1 and n2
			nTemp = n1
			n1 = n2
			n2 = nTemp

			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		ok

		return cResult

		#< @FunctionFluentForm

		def SectionCSQ(n1, n2, pCaseSensitive)
			return new stzString( This.SectionCS(n1, n2, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SliceCS(n1, n2, pCaseSensitive)
			return This.SectionCS(n1, n2, pCaseSensitive)

			#< @FunctionFluentForm

			def SliceCSQ(n1, n2, pCaseSensitive)
				return This.SectionCSQ(n1, n2, pCaseSensitive)

			#>
		#>	

	#-- WITHOUT CASESENSITIVITY

	def Section(n1, n2)
		cResult = This.SectionCS(n1, n2, 1)
		return cResult


		def SectionQ(n1, n2)
			return new stzString(This.Section(n1, n2))

		def Slice(n1, n2)
			return This.Section(n1, n2)

			def SliceQ(n1, n2)
				return new stzString(This.Slice(n1, n2))

	  #-------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- Z/EXTENDED  #
	#-------------------------------------------------------------#

	def SectionCSZ(n1, n2, pCaseSensitive)
		if CheckingParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSZ(n1, n2, pCaseSensitive)
			return This.SectionCSZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZ(n1, n2)
		return This.SectionCSZ(n1, n2, 1)

		def SliceZ(n1, n2)
			return SectionZ(n1, n2)

	  #--------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- ZZ/EXTENDED  #
	#--------------------------------------------------------------#

	def SectionCSZZ(n1, n2, pCaseSensitive)
		if CheckingParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = This.NumberOfChars()
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSZZ(n1, n2, pCaseSensitive)
			return This.SectionCSZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZZ(n1, n2)
		return This.SectionCSZZ(n1, n2, 1)

		def SliceZZ(n1, n2)
			return SectionZZ(n1, n2)

	  #-------------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTended form  #
	#===================================================================#

	def SectionCSXT(n1, n2, pCaseSensitive)

		# This is an extended form of Section() that supports
		# two fency features (that we find in other languages like Python):
		# 	~> n1 and n2 can be negative numbers, and hence their values are counted from the end
		# 	~> n1 can be greater then n2, and hence the section is reversed.

		nLen = This.NumberOfCharsCS(pCaseSensitive)

		if CheckingParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = nLen
			ok

			#==

			if isList(n2) and StzListQ(n2).IsUpToNCharsNamedParam()
				return This.Range(n1, n2[2])
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		# Managing negative values

		if n1 < 0
			n1 = nLen + n1 + 1
			# Be careful : + n1 and not - n1 because n1 is already negative!
		ok

		if n2 < 0
			n2 = nLen + n2 + 1
		ok

		# Managing the case where n1 > n2 --> section reversed

		if n1 > n2
			cResult = This.SectionCSQ(n2, n1, pCaseSensitive).Reversed()

		else
			cResult = This.SectionCS(n2, n1, pCaseSensitive)
		ok

		return cResult

		def SliceCSXT(n1, n2, pCaseSensitive)
			return This.SectionCSXT(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXT(n1, n2)
		return This.SectionCSXT(n1, n2, 1)

		def SliceXT(n1, n2)
			return This.SectionXT(n1, n2)

	  #---------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZ form  #
	#---------------------------------------------------------------#

	def SectionCSXTZ(n1, n2, pCaseSensitive)
		if CheckingParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSXTZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZ(n1, n2)
		return This.SectionCSXTZ(n1, n2, 1)

		def SliceXTZ(n1, n2)
			return This.SectionXTZ(n1, n2)

	  #----------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZZ form  #
	#----------------------------------------------------------------#

	def SectionCSXTZZ(n1, n2, pCaseSensitive)
		if CheckingParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSXTZZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZZ(n1, n2)
		return This.SectionCSXTZZ(n1, n2, 1)

		def SliceXTZZ(n1, n2)
			return This.SectionXTZZ(n1, n2)

	#TODO : RangeZ(), RangeZZ(), RangeXT(), RangeXTZ(), and RangeXTZZ()

	  #-------------------------------------------------------#
	 #  GETTING THE PART OF STRING BEFORE A GIVEN SUBSTRING  #
	#-------------------------------------------------------#

	def BeforeCS(pcSubStr, pCaseSensitive)

		if This.IsEmpty()
			return ""
		ok

		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos = 0
			StzRaise("Can't proceed! The substring you provided does not exist in the string.")
		ok

		return This.Section(1, nPos-1)

		def SubStringBeforeCS(pcSubStr, pCaseSensitive)
			return This.BeforeCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Before(pcSubStr)
		return This.BeforeCS(pcSubStr, 1)

		def SubStringBefore(pcSubStr)
			return This.Before(pcSubStr)

	  #------------------------------------------------------#
	 #  GETTING THE PART OF STRING AFTER A GIVEN SUBSTRING  #
	#------------------------------------------------------#

	def AfterCS(pcSubStr, pCaseSensitive)

		if This.IsEmpty()
			return ""
		ok

		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos = 0
			StzRaise("Can't proceed! The substring you provided does not exist in the string.")

		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		return This.Section(nPos + nLenSubStr, This.NumberOfChars())

		def SubStringAfterCS(pcSubStr, pCaseSensitive)
			return This.AfterCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def After(pcSubStr)
		return This.AfterCS(pcSubStr, 1)

		def SubStringAfter(pcSubStr)
			return This.After(pcSubStr)

	  #-----------------------------------#
	 #   GETTING A RANGE OF THE STRING   #
	#===================================#

	// Returns a subset of the string starting from nStart and ranging over nRange Chars
	def RangeCS(nStartPos, nRange, pCaseSensitive)

		if CheckingParams()
			if NOT isNumber(nRange)
				StzRaise("Incorrect param type! nRange must be a number.")
			ok
		
			if isNumber(nStartPos)
	
				if nStartPos < 0
					nStartPos = This.NumberOfChars() + nStartPos + 1
				ok
		
				if nStartPos = 0 or nRange = 0
					return ""
				ok
			ok
		ok

		# Doing the job

		cResult = ""

		if nRange > 0
			if CheckingParams() and isString(nStartPos)
				nStartPos = This.FindFirstCS(nStartPos, pCaseSensitive)
			ok

			cResult = This.SectionCS( nStartPos, nStartPos + nRange -1, pCaseSensitive )

		else
			n1 = nStartPos + nRange + 1

			if n1 > 0
				cResult = This.SectionCS( n1, nStartPos, pCaseSensitive )
			ok	
		ok

		return cResult

		#< @FunctionFluentForm

		def RangeCSQ(nStartPos, nRange, pCaseSensitive)
			return new stzString( This.RangeCS(nStartPos, nRange, pCaseSensitive) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRangeCS(paParams, pCaseSensitive)
			
			// Default values
			nStartPos = 1
			nRange = This.NumberOfChars()

			// Reading the params
			if StzListQ(paParams).IsRangeNamedParam()
				if isNumber(paParams[ :Start ])
					nStartPos = paParams[ :Start ]
				ok

				if isNumber(paParams[ :Range ])
					nRange = paParams[ :Range ]
				ok

				return This.RangeCS(nStartPos, nRange, pCaseSensitive)
			else
				stzRaise("Incorrect params!")
			ok

		#>

		#< @FunctionInfoForm

		def infRangeCS(pCaseSensitive)
			return [
				:Syntax = "Range(pnstart, pnRange, pCaseSensitive)",
				:Description = "Returns pnRange chars starting at pnStart position",
				:ReturnType = "STRING",
				:NumberOfParams = 3,
				:Params = [
					[
						:Param = "pnStart",
						:Type = "NUMBER",
						:Description = "Start position",
						:Default = 1
					],
					[
						:Param = "pnRange",
						:Type = "NUMBER",
						:Description = "Number of chars of the range",
						:Default = This.NumberOfChars()
					],
					[
						:Param = "pCaseSensitive",
						:Type = "BOOLEAN",
						:Description = "If the first param is a string, apply or not case sensitivity",
						:Default = 1
					]
				]
			]
		#>

		#< @FunctionDefaultForm

		def dftRangeCS(pCaseSensitive)
			return This.nmdRangeCS([ :Start = 1, :Range = This.NumberOfChars(), pCaseSensitive ])

		#>

		#< @FunctionExampleForm

		def expRangeCS(pCaseSensitive)
			return 	'StzStringQ("The Ring programming language").RangeCS("ring", 11,  0)' + NL +
				'--> "Ring programming"'

		#>

		#< @FunctionRandomForm

		def rndRangeCS(pCaseSensitive)
			nStart = random( This.NumberOfChars() )
			nRange = random( This.NumberOfChars() - nStart )

			return 	'This.RangeCS(' + nStart + ', ' + nRange + ', ' + pCaseSensitive + ')' + NL +
				'--> ' + This.RangeCS(nStart, nRange, pCaseSensitive)

		#>

		#< @FunctionTestForm

		def tstRangeCS(pCaseSensitive)
			nCases = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfTestCases ]
			nSucceeded = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfSuccessfulCases ]
			nFailed = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfFailedCases ]


			if nCases = 0
				return "Failed! (" + nFailed + "/" + nCases + ")"

			but nFailed = 0
				return "SUCCESS! (" + nSucceeded + "/" + nCases + ")"
			ok

			if nSucceeded != 0
				return "FAILED! (" + nFailed + "/" + nCases + ")"
			ok

		def tstRangeCSXT(pCaseSensitive)
			aTestCases = [
			['StzStringQ("Ringorialand").Range(9, 4)' , 'land'],
			['StzStringQ("Ringorialand").Range(1, 4)' , 'Ring'],
			['StzStringQ("Ringorialand").Range(4, 6)' , 'gorial']
			]

			aSucceeded = []
			aFailed = []
			i = 0

			for aTest in aTestCases
				i++
				cCode = "cResult = " + aTest[1]

				try
					 eval(cCode)

					if cResult = aTest[2]
						aSucceeded + i
					else
						aFailed + i
					ok
				catch
					aFailed + i
				done
			next
			
			aResult = [
				:NumberOfTestCases = len(aTestCases),
				:NumberOfSuccessfulCases = len(aSucceeded),
				:NumberOfFailedCases = len(aFailed),

				:SuccessfulCases = aSucceeded,
				:FailedCases = aFailed,

				:TestCases = aTestCases
			]

			return aResult

		#>

	#-- WTIHOUT CASESENSITIVITY

	def Range(nStartPos, nRange)
		return This.RangeCS(nStartPos, nRange, 1)

		#< @FunctionFluentForm

		def RangeQ(nStartPos, nRange)
			return new stzString( This.Range(nStartPos, nRange) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRange(paParams)
			return This.nmdRangeCS(paParams, 1)

		#>

		#< @FunctionInfoForm

		def infRange()
			return This.infRangeCS(1)

		#>

		#< @FunctionDefaultForm

		def dftRange()
			return This.dftRangeCS(1)


		#>

		#< @FunctionExampleForm

		def expRange()
			return This.expRangeCS(1)

		#>

		#< @FunctionRandomForm

		def rndRange()
			return This.rndRangeCS(1)

		#>

		#< @FunctionTestForm

		def tstRange()
			return This.tstRangeCS(1)

		def tstRangeXT()
			return This.tstRangeCSXT(1)

		#>

	  #---------------------------------------------#
	 #  GETTING A RANGE OF THE STRING -- EXTENDED  #
	#---------------------------------------------#

	def RangeCSXT(nStartPos, nRange, pCaseSensitive)
		aResult = [ This.RangeCS(nStartPos, nRange, pCaseSensitive), [nStartPos, nRange] ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RangeXT(nStartPos, nRange)
		return This.RangeCSXT(nStartPos, nRange, 1)

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #TODO // Add CaseSensitivity
	#---------------------------------------#

	def Sections(paSections)

		if isString(paSections) or
			(isList(paSections) and
				(Q(paSections).IsOfNamedParam() or
					Q(paSections).IsOfSubStringNamedParam() ) )

			return This.FindAsSections(paSections)
		ok

		if NOT 	( isList(paSections) and
				Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsQ(paSections)
			return This.SectionsQRT(paSections, :stzList)

		def SectionsQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Sections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Sections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

			def ManySectionsQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySectionsQRT(paSections, pcReturnType)
				return This.SectionsQRT(paSections, pcReturnType)

		def Slices(paSections)
			return This.Sections(paSections)

			def SlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def SlicesQRT(paSections, pcReturnType)
				return This.SectionsQRT(paSections, pcReturnType)

		def ManySlices(paSections)
			return This.Sections(paSections)

			def ManySlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySlicesQRT(paSections, pcReturnType)
				return This.SectionsQRT(paSections, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- EXTENDED  #
	#--------------------------------------------------#

	def SectionsXT(paSections)
		if CheckingParams()
			if NOT (isList(paSections) and IsListOfPairs(paSections))
				StzRaise("Incorrect param type! paSections must be a list of pairs.")
			ok
		ok

		nLen = len(paSections)
		acResult = []

		for i = 1 to nLen
			cSection = This.SectionXT( paSections[i][1], paSections[i][2] )
			acResult + cSection
		next

		return acResult

		#< @FunctionFluentForm

		def SectionsXTQ(paSections)
			return This.SectionsXTQRT(paSections, pcReturnType)

		def SectionsXTQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

			def ManySectionsXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySectionsXTQRT(paSections, pcReturnType)
				return This.SectionsXTQRT(paSections, pcReturnType)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

			def SlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def SlicesXTQRT(paSections, pcReturnType)
				return This.SectionsXTQRT(paSections, pcReturnType)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

			def ManySlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySlicesXTQRT(paSections, pcReturnType)
				return This.SectionsXTQRT(paSections, pcReturnType)

		#>

	  #----------------------------------------------------------#
	 #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def NumberOfAntiSections(paSections)
		nResult = len( StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content() )

		return nResult

		#< @FunctionAlternativeForms

		def CountAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSection(paSections)
			return This.NumberOfAntiSections(paSections)

		#>

	   #-------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND  #
	 #  RETURNING THEM AS PAIRS OF NUMBERS                         #
	#=============================================================#

	def FindAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
			  FindAntiSections(paSections)

		return aResult


		def FindAntiSectionsQ(paSections)
			return new stzList(This.FindAntiSections(paSections))

		#< @FunctionAlternativeForms

		def FindAntiSectionsZZ(paSections)
			return This.FindAntiSections(paSections)

			def FindAntiSectionsZZQ(paSections)
				return This.FindAntiSectionsQ(paSections)

		#>

	  #----------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("ABCDEFGHIJ")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ "AB", "F", "IJ" ]
		*/

		aResult = This.Sections( This.FindAntiSectionsZZ(paSections) )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return This.AntiSectionsQRT(paSections, pcReturnType)

		def AntiSectionsQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	def AntiSectionsZ(paSections)
		aResult = @Association([ This.AntiSections(paSections), This.FindAntiSections(paSections) ])
		return aResult

	def AntiSectionsZZ(paSections)
		aResult = @Association([ This.AntiSections(paSections), This.FindAntiSectionsZZ(paSections) ])
		return aResult

	  #---------------------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#---------------------------------------------------------------------#

	def AntiSectionsXT(paSections)

		aAntiSections = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content()

		aResult = This.SectionsXT( aAntiSections )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsXTQ(paSections)
			return This.AntiSectionsXTQRT(paSections, pcReturnType)

		def AntiSectionsXTQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	  #---------------------------------------------------------#
	 #   GETIING NTH ANTI-SECTION OF A GIVEN SET OF SECTIONS   #
	#---------------------------------------------------------#

	def NthAntiSection(n, paSections)
		if n = :First or n = :FirstAntiSection
			n = 1
		but n = :Last or n = :LastAntiSection
			n = This.NumberOfAntiSections(paSections)
		ok

		return This.AntiSections(paSections)[n]

	def FirstAntiSection(paSections)
		return This.NthAntiSections(1, paSections)

	def LastAntiSection(paSections)
		return This.NthAntiSection(:Last, paSections)

	  #-------------------------------------------------------------------#
	 #   FINDING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#

	def FindAsSectionsAndAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
				FindAsSectionsAndAntiSectionsQ(paSections).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def FindAsSectionsAndAntiSectionsZZ(paSections)
			return This.FindAsSectionsAndAntiSections(paSections)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#
		
	def SectionsAndAntiSections(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections( aSectionsAntiSections )

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return This.SectionsAndAntiSectionsQRT(paSections, pcReturnType)

		def SectionsAndAntiSectionsQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	  #------------------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#------------------------------------------------------------------------------#
		
	def SectionsAndAntiSectionsXT(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		nLen = len(aSectionsAntiSections)

		aResult = []

		for i = 1 to nLen
			aSection = aSectionsAntiSections[i]
			aResult + [ This.Section(aSection[1], aSection[2]), aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsXTQ(paSections)
			return This.SectionsAndAntiSectionsXTQRT(paSections, pcReturnType)

		def SectionsAndAntiSectionsXTQRT(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	  #------------------------------------------------------------#
	 #   GENERATING ALL POSSIBLE SECTIONS BETWEEN TOW SUBSTRINGS  #
	#------------------------------------------------------------#

	def SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TAYOUBTA")
		? o1.SectionsFromTo( :From = "T", :To = "A" )
		#--> [ "TA", "TAYOUBTA", "TA" ]

		*/

		if isList(pcSubStr1) and StzListQ(pcSubStr1).IsFromNamedParam()
			pcSubStr1 = pcSubStr1[2]
		ok

		if isList(pcSubStr2) and StzListQ(pcSubStr2).IsToNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		anSections = []

		anPos1 = This.FindAllCS(pcSubStr1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pcSubStr2, pCaseSensitive) #--> [ 2, 8 ]

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		def AllPossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AllPossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SectionsFromTo(pcSubStr1, pcSubStr2)
		return This.SectionsFromToCS(pcSubStr1, pcSubStr2, 1)

		def AllPossibleSectionsFromTo(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def AllPossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSectionsFromTo(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2)

	  #--------------------------------------#
	 #   GETTING MANY RANGES OF THE STRING  #
	#--------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

	  #====================================#
	 #  INSERTING SUBSTRINGS -- EXTENDED  #TODO / ADD OTHER FORMS
	#====================================#

	def InsertXT(pcSubStr, paOptions)
		/*
		o1 = new stzString("99999999999")
		o1.InsertXT("_", [ :After, :EachNChars = 3, :Going = :Forward ])

		? o1.Content()
		#--> 99_999_999_999é

		#--

		o1 = new stzString("99999999999")
		o1.InsertXT([".", "_"], [ :Repeat, :After, :EachNChars = 2, :Going = :Forward ])

		? o1.Content()
		#--> 9_99.99_99.99_99

		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(paOptions)

			oOptions = new stzList(paOptions)

			# Case : Q("999999").InsertXT("-", :EachNChars = 2) --> 99-99-99
			if oOptions.IsOneOfTheseNamedParams([ :Step, :EachNChars ])

				This.SpacifyXT(
					:Using = pcSubStr,
					:EachNChars = paOptions[2],
					:Going = :Forward)

			# Add other cases here

			but oOptions.IsBetweenNamedParam()
				This.InsertSubStringBetween(pcSubStr, paOptions[2][1], paOptions[2][2])

			but oOptions.IsBetweenSubStringsNamedParam()
				cSubStr1 = paOptions[2][1]
				cSubStr2 = paOptions[2][2]

				if NOT ( isString(cSubStr1) and isString(cSubStr1) )
					StzRaise("Incorrect param type! You should provide two substrings.")
				ok

				This.InsertSubStringBetweenSubStrings(pcSubStr, paOptions[2][1], paOptions[2][2])

			but oOptions.IsBetweenPositionsNamedParam()
				n1 = paOptions[2][1]
				n2 = paOptions[2][2]

				if NOT ( isNumber(n1) and isNumber(n2) )
					StzRaise("Incorrect param type! You should provide two numbers.")
				ok

				This.InsertSubStringBetweenPositions(pcSubStr, paOptions[2][1], paOptions[2][2])

			but oOptions.IsBeforeNamedParam()
				This.InsertSubStringBefore(pcSubStr, paOptions[2])

			but oOptions.IsBeforePositionNamedParam()
				This.InsertBeforePosition(pcSubStr, paOptions[2])

			but oOptions.IsBeforeSubStringNamedParam()
				This.InsertBeforeSubString(pcSubStr, paOptions[2])

			but oOptions.IsAfterNamedParam()
				This.InsertSubStringAfter(pcSubStr, paOptions[2])

			but oOptions.IsAfterPositionNamedParam()
				This.AfterBeforePosition(pcSubStr, paOptions[2])

			but oOptions.IsAfterSubStringNamedParam()
				This.InsertAfterSubString(pcSubStr, paOptions[2])

			else
				StzRaise("Unsupported syntax!")
			ok
		ok


		#< @FunctionFluentForm

		def InsertXTQ(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubStringXT(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)

			def InsertSubStringXTQ(pcSubStr, paOptions)
				This.InsertSubStringXT(pcSubStr, paOptions)
				return This

		#>

	def SubStringInsertedXT(pcSubStr, paOptions)
		cResult = This.Copy().InsertXTQ(pcSubStr, paOptions).Content()
		return cResult

	  #---------------------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS   #
	#===============================================================#

	def InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if CheckingParams()

			if isList(p1)
				oTempList = new stzList(p1)

				if oTempList.IsPositionOrPositionsNamedParam() or
				   oTempList.IsSubStringOrSubStringsNamedParam()

					p1 = p1[2]
				ok

			but isList(p2)
				oTempList = new stzList(p2)

				if oTempList.IsAndOrAndPositionOrAndSubStringNamedParam()

					p2 = p2[2]
				ok
			ok

		ok

		if isNumber(p1) and isNumber(p2)
			This.InsertSubStringBetweenPositions(pcSubStr, p1, p2)

		but isString(p1) and isString(p2)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)
			This.InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def InstertBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			This.InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

			def InstertBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)
				return This.InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringInsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
		cResult = This.Copy().InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive).Content()
		return cResult

		def InsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.SubStringInsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

	#== WITHOUT CASESENSITIVITY

	def InsertSubStringBetween(pcSubStr, p1, p2)
		This.InsertSubStringBetweenCS(pcSubStr, p1, p2, 1)

		#< @FunctionFluentForm

		def InsertSubStringBetweenQ(pcSubStr, p1, p2)
			This.InsertSubStringBetween(pcSubStr, p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBetween(pcSubStr, p1, p2)
			This.InsertSubStringBetween(pcSubStr, p1, p2)

			def InsertBetweenQ(pcSubStr, p1, p2)
				return This.InsertSubStringBetweenQ(pcSubStr, p1, p2)

		#>

	#-- @FunctionPassiveForm

	def SubStringInsertedBetween(pcSubStr, p1, p2)
		return This.SubStringInsertedBetweenCS(pcSubStr, p1, p2, 1)

		def InsertedBetween(pcSubStr, p1, p2)
			return This.SubStringInsertedBetween(pcSubStr, p1, p2)

	  #--------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO SUBSTRINGS   #
	#--------------------------------------------------#

	def InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		if CheckingParams()
			if NOT ( isString(pcSubStr) and isString(pcSubStr1) and isString(pcSubStr2) )
				StzRaise("Incorrect param types! pcSubStr, pcSubStr1 and pcSubStr2 must be all strings.")
			ok
		ok

		if EarlyChecks()
			if pcSubStr = "" or
			   pcSubStr1 = "" or
			   pcSubStr = ""

				return
			ok
		ok

		# Doing the job

		aSections = This.FindAnyBoundedByAsSectionsCS([ pcSubStr1, pcSubStr2 ], pCaseSensitive)
		This.ReplaceSections(aSections, pcSubStr)

		#< @FunctionFluentForm

		def InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

		#>	

		#< @FunctionAlternativeForm

		def InsertBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

			def InsertBetweenSubStringsCSQ(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
				return This.InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def InsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
			return This.InsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)

	#== WITHOUT CASESENSITIVITY

	def InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

		This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		#< @FunctionFluentForm

		def InsertSubStringBetweensubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)
			This.InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			This.InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

			def InsertBetweenSubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)
				return This.InsertSubStringBetweenSubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	#-- @FunctionPassiveForm

	def InsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
		return This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, 1)

		def SubStringInsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This.InsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO POSITIONS   #
	#-------------------------------------------------#

	def InsertSubStringBetweenPositions(pcSubStr, n1, n2)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if isList(n1) and StzListQ(n1).IsPositionOrPositionsNamedParam()
				n1 = n1[2]
			ok

			if isList(n2) and StzListQ(n2).IsAndNamedParam()
				n2 = n2[2]
			ok

			if NOT (isNumber(n1) and isNumber(n2))
				StzRaise("Incorrect params types! n1 and n2 must be both numbers.")
			ok
		ok

		if EarlyChecks()
			if pcSubStr = "" or n1 < 0 or n2 > This.NumberOfChars()
				return
			ok
		ok

		# Doing the job

		This.ReplaceSection(n1, n2, pcSubStr)

		#< @FunctionFluentForm

		def InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2)
			This.InsertSubStringBetweenPositions(pcSubStr, n1, n2)
			return This
		#>

		#< @FunctionAlternativeForms

		def InsertBetweenPositions(pcSubStr, n1, n2)
			This.InsertSubStringBetweenPositions(pcSubStr, n1, n2)

			def InsertBetweenPositionsQ(pcSubStr, n1, n2)
				return This.InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2)

		#>

	#-- @FunctionPassiveForms

	def InstertedBetweenPositions(pcSubStr, n1, n2)
		cResult = This.Copy().InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2).Content()

		def SubStringInstertedBetweenPositions(pcSubStr, n1, n2)
			return This.InstertedBetweenPositions(pcSubStr, n1, n2)

	  #------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS   #
	#================================================#

	def InsertBeforeEachNChars(n, pcSubStr)
		This.InsertBeforeEachNCharsXT(n, pcSubStr, :FromEndToStart)

		def InsertBeforeEachNCharsQ(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)
			return This

		def InsertSubStringBeforeEachNChars(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)

			def InsertSubStringBeforeEachNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEachNChars(n, pcSubStr)
				return This

	def SubStringInsertedBeforeEachNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEachNCharsQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS -- EXTENDED  #
	#-----------------------------------------------------------#

	def InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		This.InsertXT( pcSubStr, [ :After, :EachNChars = 3, :Going = :Forward ])

		def InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			return This

		def InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)

			def InsertSubStringBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
				This.InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
				return This

	def SubStringInsertedBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		cResult = This.Copy().InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection).Content()
		return cResult

	  #-------------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE OR AFTER A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def Insert(pcSubStr, pWhere)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pWhere)

			oParam = new stzList(pWhere)

			if oParam.IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pcSubStr, pWhere[2])
				return

			but oParam.IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pcSubStr, pWhere[2])
				return
			ok
		else
			This.InsertBefore(pcSubStr, pWhere)
		ok

		#< @FunctionFluentForm

		def InsertQ(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubString(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)

			def InsertSubStringQ(pcsubStr, pWhere)
				This.InsertSubString(pcSubStr, pWhere)
				return This
		
		#>

	def SubStringInserted(pcSubStr, pWhere)
		cResult = This.Copy().InsetSubStringQ(pcSubStr, pWhere).Content()
		return cResult


	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE A GIVEN POSITION   #
	#----------------------------------------------------#

	/* Inserts a substring:

	 	- in a given position inside the string
	 	  Note: in this case, if nPos > NumberOfChars()
		  --> string is extended with white spaces

		- or, before the occurrence of a given substring
	*/
	 
	def InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)

		if isList(nPos) and StzListQ(nPos).IsPositionOrSubStringNamedParam()
			nPos = nPos[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsPositionOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		#--

		if isString(nPos)
			if isString(pcSubStr)
				This.InsertSubstringBeforeSubStringCS(nPos, pcSubStr, pCaseSensitive)
				
			but isNumber(pcSubStr)

				This.InsertSubstringBeforePosition(nPos, pcSubStr)

			ok

		but isList(nPos)

			if @IsListOfStrings(nPos)
				This.InsertSubStringsBeforeSubStringCS(nPos, pCSubStr, pCaseSensitive)

			but @IsListOfNumbers(nPos)
				This.InsertSubStringBeforePositions(nPos, pcSubStr)
			ok

		but isNumber(nPos)

			if isString(pcSubStr)
				This.InsertSubStringBeforePosition(nPos, pcSubStr)
			ok
		ok

		# The string has changed, check constraints...
		//This.VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms


		def InsertAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)
				return This

		#--

		def InsertSubStringBeforeCS(nPos, pcSubStr, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)

			def InsertSubStringBeforeCSQ(nPos, pcSubStr, pCaseSensitive)
				return This

		def InsertSubStringAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringAtQ(nPos, pcSubStr)
				This.InsertSubStringAt(nPos, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeCS(nPos, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringInsertedAtCS(nPos, pcSubStr, pCaseSensitive)
			This.SubStringInsertedBeforeCS(nPos, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def InsertBefore(nPos, pcSubStr)
		This.InsertBeforeCS(nPos, pcSubStr, 1)

		def InsertBeforeQ(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)
			return This

		def InsertSubStringBefore(nPos, pcSubStr)
			This.InsertSubStringBeforeCS(nPos, pcSubStr, 1)

			def InsertSubStringBeforeQ(nPos, pcSubStr)
				This.InsertSubStringBefore(nPos, pcSubStr)
				return This

	def SubStringInsertedBefore(nPos, pcSubStr)
		cResult = This.Copy().InsertBeforeQ(nPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAt(nPos, pcSubStr)
			return This.SubStringInsertedBefore(nPos, pcSubStr)

	  #-------------------------------------------------#
	 #  INSERTING A SUBSTRING BEFoRE A GIVEN POSITION  #
	#-------------------------------------------------#

	def InsertBeforePosition(nPos, pcSubStr)
		if CheckingParams()
			if isList(pcSubStr) and StzListQ(pcSubStr).IsSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isNumber(nPos) and isString(pcSubStr)
				n = nPos
				cSubStr = pcSubStr
	
			but isNumber(pcSubStr) and isString(nPos)
				n = pcSubStr
				cSubStr = nPos
	
			else
				StzRaise("Incorrect param types! You must provide a string and number.")
			ok
		ok

		oQCopy = QStringObject()
		This.UpdateWith( oQCopy.insert(n-1, cSubStr) )

		#< @FunctionAlternativeForms

		def InsertBeforePositionQ(nPos, pcSubStr)
			This.InsertBeforePosition(nPos, pcSubStr)
			return This

		def InsertAtPosition(nPos, pcSubStr)
			This.InsertBeforePosition(nPos, pcSubStr)

			def InsertAtPosiitonQ(nPos, pcSubStr)
				return This.InsertBeforePositionQ(nPos, pcSubStr)

		def InsertSubStringBeforePosition(nPos, pcSubStr)
			This.InsertBeforePosition(nPos, pcSubStr)

			def InsertSubStringBeforePositionQ(nPos, pcSubStr)
				return This.InsertBeforePositionQ(nPos, pcSubStr)

		def InsertSubStringAtPosition(nPos, pcSubStr)
			This.InsertBeforePosition(nPos, pcSubStr)

			def InsertSubStringAtPosiitonQ(nPos, pcSubStr)
				return This.InsertBeforePositionQ(nPos, pcSubStr)

		#>

	#-- @FunctionPassiveForms

	def SubStringInsertedBeforePosition(nPos, pcSubStr)
		cResult = This.Copy().InsertBeforePositionQ(nPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAtPosition(nPos, pcSubStr)
			This.SubStringInsertedBeforePosition(nPos, pcSubStr)

	   #-----------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A   #
	 #    GIVEN CONDITION APPLIED ON THE STRING SUBSTRINHGS      #
	#===========================================================#

	def InsertBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>
		
	def InsertedBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeSubStringsW(pcCondition, pcSubStr)
		return This.InsertBeforeSubStringsWCS(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWQ(pcCondition, pcSubStr)
			This.InsertBeforeSubStringsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeSubStringsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeSubStringsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING SUBSTRINGS -- WXT/EXTENDED   #
	#------------------------------------------------------------------#

	def InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeSubStringsWXT(pcCondition, pcSubStr)
		return This.InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWXTQ(pcCondition, pcSubStr)
			This.InsertBeforeSubStringsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeSubStringsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeSubStringsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#========================================================#

	def InsertBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeCharsW(pcCondition, pcSubStr)
		return This.InsertBeforeCharsWCS(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeCharsWQ(pcCondition, pcSubStr)
			This.InsertBeforeCharsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeCharsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING CHARS -- WXT/EXTENDED        #
	#------------------------------------------------------------------#

	def InsertBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeCharsWXT(pcCondition, pcSubStr)
		return This.InsertBeforeCharsWCSXT(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeCharsWXTQ(pcCondition, pcSubStr)
			This.InsertBeforeCharsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeCharsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeCharsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING AFTER A GIVEN POSITION   #
	#---------------------------------------------------#

	def InsertAfterCS(nPos, pcSubStr, pCaseSensitive)

		if isList(nPos) and StzListQ(nPos).IsPositionOrSubStringNamedParam()
			nPos = nPos[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsPositionOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		#--

		if isString(nPos)
			if isString(pcSubStr)
				This.InsertSubstringAfterSubStringCS(nPos, pcSubStr, pCaseSensitive)
				
			but isNumber(pcSubStr)

				This.InsertSubstringAfterPosition(nPos, pcSubStr)

			ok

		but isList(nPos)

			if @IsListOfStrings(nPos)
				This.InsertSubStringsAfterSubStringCS(nPos, pCSubStr, pCaseSensitive)

			but @IsListOfNumbers(nPos)
				This.InsertSubStringAfterPositions(nPos, pcSubStr)
			ok

		but isNumber(nPos)

			if isString(pcSubStr)
				This.InsertSubStringAfterPosition(nPos, pcSubStr)
			ok
		ok

		# The string has changed, check constraints...
		//This.VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertAfterCSQ(nPos, pcSubStr, pCaseSensitive)
			This.InsertAfterCS(nPos, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterCS(nPos, pcSubStr, pCaseSensitive)
			This.InsertAfterCS(nPos, pcSubStr, pCaseSensitive)

			def InsertSubStringAfterCSQ(nPos, pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterCS(nPos, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterCSQ(nPos, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfter(nPos, pcSubStr)
		This.InsertAfterCS(nPos, pcSubStr, 1)

		def InsertAfterQ(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)
			return This

		def InsertSubStringAfter(nPos, pcSubStr)
			This.InsertSubStringAfterCS(nPos, pcSubStr, 1)

			def InsertSubStringAfterQ(nPos, pcSubStr)
				This.InsertSubStringAfter(nPos, pcSubStr)
				return This

	def SubStringInsertedAfter(nPos, pcSubStr)
		cResult = This.Copy().InsertAfterQ(nPos, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------#
	 # INSERTING A SUBSTRING AFTER A GIVEN POSITION  #
	#-----------------------------------------------#

	def InsertAfterPosition(nPos, pcSubStr)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isNumber(nPos) and isString(pcSubStr)
				n = nPos
				cSubStr = pcSubStr
	
			but isNumber(pcSubStr) and isString(nPos)
				n = pcSubStr
				cSubStr = nPos
	
			else
				StzRaise("Incorrect param types! You must provide a string and number.")
			ok
		ok

		oQCopy = QStringObject()
		This.UpdateWith( oQCopy.insert(n, cSubStr) )

		#< @FunctionAlternativeForms

		def InsertAfterPositionQ(nPos, pcSubStr)
			This.InsertAfterPosition(nPos, pcSubStr)
			return This

		def InsertSubStringAfterPosition(nPos, pcSubStr)
			This.InsertAfterPosition(nPos, pcSubStr)

			def InsertSubStringAfterPositionQ(nPos, pcSubStr)
				return This.InsertAfterPositionQ(nPos, pcSubStr)

		#>

	#-- @FunctionPassiveForms

	def SubStringInsertedAfterPosition(nPos, pcSubStr)
		cResult = This.Copy().InsertAfterPositionQ(nPos, pcSubStr).Content()
		return cResult

	  #--------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG AFTER NTH OCCURRENCE OF A GIVEN SUBSTRING  #
	#====================================================================#

	def InsertAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertAfterNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertAfterNthCSCQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedAfterNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterNth(n, pcSubStr, pcNewSubStr)
		return This.InsertAfterNthCS(n, pcSubStr, pcNewSubStr, 1)

		def InsertAfterNthQ(n, pcSubStr, pcNewSubStr)
			return This.InsertAfterNthCSQ(n, pcSubStr, pcNewSubStr, 1)

		def InsertAfterNthCQ(n, pcSubStr, pcNewSubStr)
			return This.InsertAfterNthCSCQ(n, pcSubStr, pcNewSubStr, 1)

	def InsertedAfterNth(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterNthQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterNth(n, pcSubStr, pcNewSubStr)
			return This.InsertedAfterNth(n, pcSubStr, pcNewSubStr)

	  #----------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG AFTER FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def InsertAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertAfterFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertAfterFirstCSCQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedAfterFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterFirst(pcSubStr, pcNewSubStr)
		return This.InsertAfterFirstCS(pcSubStr, pcNewSubStr, 1)

		def InsertAfterFirstQ(pcSubStr, pcNewSubStr)
			return This.InsertAfterFirstCSQ(pcSubStr, pcNewSubStr, 1)

		def InsertAfterFirstCQ(pcSubStr, pcNewSubStr)
			return This.InsertAfterFirstCSCQ(pcSubStr, pcNewSubStr, 1)

	def InsertedAfterFirst(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterFirstQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterFirst(pcSubStr, pcNewSubStr)
			return This.InsertedAfterFirst(pcSubStr, pcNewSubStr)

	  #----------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG AFTER LAST  OCCURRENCE OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def InsertAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertAfterLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertAfterLastCSCQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedAfterLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterLast(pcSubStr, pcNewSubStr)
		return This.InsertAfterLastCS(pcSubStr, pcNewSubStr, 1)

		def InsertAfterLastQ(pcSubStr, pcNewSubStr)
			return This.InsertAfterLastCSQ(pcSubStr, pcNewSubStr, 1)

		def InsertAfterLastCQ(pcSubStr, pcNewSubStr)
			return This.InsertAfterLastCSCQ(pcSubStr, pcNewSubStr, 1)

	def InsertedAfterLast(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterLastQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterLast(pcSubStr, pcNewSubStr)
			return This.InsertedAfterLast(pcSubStr, pcNewSubStr)

	  #---------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG BEFORE NTH OCCURRENCE OF A GIVEN SUBSTRING  #
	#=====================================================================#

	def InsertBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertBeforeNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertBeforeNthCSCQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedBeforeNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeNth(n, pcSubStr)
		return This.InsertBeforeNthCS(n, pcSubStr, pcNewSubStr, 1)

		def InsertBeforeNthQ(n, pcSubStr)
			return This.InsertBeforeNthCSQ(n, pcSubStr, pcNewSubStr, 1)

		def InsertBeforeNthCQ(n, pcSubStr)
			return This.InsertBeforeNthCSCQ(n, pcSubStr, pcNewSubStr, 1)

	def InsertedBeforeNth(n, pcSubStr)
		cResult = This.Copy().InsertBeforeNthQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedBeforeNth(n, pcSubStr, pcNewSubStr)
			return This.InsertedBeforeNth(n, pcSubStr, pcNewSubStr)

	  #-----------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG BEFORE FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------#

	def InsertBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertBeforeFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertBeforeFirstCSCQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeFirstCSQ(pcSubStr, pcNewSubStr, pcNewSubStrpCaseSensitive).Content()
		return cResult

		def SubStringInsertedBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedBeforeFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeFirst(pcSubStr, pcNewSubStr)
		return This.InsertBeforeFirstCS(pcSubStr, pcNewSubStr, 1)

		def InsertBeforeFirstQ(pcSubStr, pcNewSubStr)
			return This.InsertBeforeFirstCSQ(pcSubStr, pcNewSubStr, 1)

		def InsertBeforeFirstCQ(pcSubStr, pcNewSubStr)
			return This.InsertBeforeFirstCSCQ(pcSubStr, pcNewSubStr, 1)

	def InsertedBeforeFirst(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeFirstQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedBeforeFirst(pcSubStr, pcNewSubStr)
			return This.InsertedBeforeFirst(pcSubStr, pcNewSubStr)

	  #----------------------------------------------------------------------#
	 #  INSERTING A SUBBStriNG BEFORE LAST  OCCURRENCE OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def InsertBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		This.InsertAfterPosition(nPos, pcNewSubStr)

		def InsertBeforeLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def InsertBeforeLastCSCQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.InsertBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_

	def InsertedBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.InsertedBeforeLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeLast(pcSubStr, pcNewSubStr)
		return This.InsertBeforeLastCS(pcSubStr, pcNewSubStr, 1)

		def InsertBeforeLastQ(pcSubStr, pcNewSubStr)
			return This.InsertBeforeLastCSQ(pcSubStr, pcNewSubStr, 1)

		def InsertBeforeLastCQ(pcSubStr, pcNewSubStr)
			return This.InsertBeforeLastCSCQ(pcSubStr, pcNewSubStr, 1)

	def InsertedBeforeLast(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeLastQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedBeforeLast(pcSubStr, pcNewSubStr)
			return This.InsertedBeforeLast(pcSubStr, pcNewSubStr)

	   #-----------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A   #
	 #    GIVEN CONDITION APPLIED ON THE STRING SUBSTRINHGS      #
	#===========================================================#

	def InsertAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterSubStringsW(pcCondition, pcSubStr)
		return This.InsertAfterSubStringsWCS(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterSubStringsWQ(pcCondition, pcSubStr)
			This.InsertAfterSubStringsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterSubStringsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterSubStringsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING SUBSTRINGS -- WXT/EXTENDED   #
	#------------------------------------------------------------------#

	def InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterSubStringsWXT(pcCondition, pcSubStr)
		return This.InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterSubStringsWXTQ(pcCondition, pcSubStr)
			This.InsertAfterSubStringsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterSubStringsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterSubStringsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#========================================================#

	def InsertAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterCharsW(pcCondition, pcSubStr)
		return This.InsertAfterCharsWCS(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterCharsWQ(pcCondition, pcSubStr)
			This.InsertAfterCharsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterCharsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING CHARS -- WXT/EXTENDED        #
	#------------------------------------------------------------------#

	def InsertAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterCharsWXT(pcCondition, pcSubStr)
		return This.InsertAfterCharsWCSXT(pcCondition, pcSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterCharsWXTQ(pcCondition, pcSubStr)
			This.InsertAfterCharsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterCharsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterCharsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (BEFORE) EVERY N CHARS   #
	#===================================================#

	def InsertBeforeEveryNChars(n, pcSubStr)
		if CheckingParams()

			if isString(n) and isNumber(pcSubStr)
				nTemp = n
				n = pcSubStr
				pcSubStr = nTemp
			ok

			if NOT isNumber(n)
				stzRaise("Incorrect param! n must be a number.")
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok
		ok

		# Doing the job

		_nLen_ = StzSubStringQ(pcsubStr).NumberOfChars()
		_nLenStr_ = This.NumberOfChars()
		_anPos_ = []

		if n = 1
			_anPos_ + 1

		else
		
			for @i = (_nLen_ + 1) to _nLenStr_ step n

				_anPos_ + ( @i - 1 )
			next
		ok

		This.InsertBeforeThesePositions(_anPos_, pcSubStr)


		#< @FunctionFluentForm

		def InsertBeforeEveryNCharsQ(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms
	
		def InsertSubStringBeforeEveryNChars(n, pcSubStr)
			This.InsertEveryNChars(n, pcSubStr)

			def InsertSubStringBeforeEveryNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEveryNChars(n, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeEveryNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEveryNCharsQ(n, pcSubStr).Content()
		return cResult

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (AFTER) EVERY N CHARS    #
	#---------------------------------------------------#

	def InsertAfterEveryNChars(n, pcSubStr)

		if CheckingParams()

			if isString(n) and isNumber(pcSubStr)
				nTemp = n
				n = pcSubStr
				pcSubStr = nTemp
			ok

			if NOT isNumber(n)
				stzRaise("Incorrect param! n must be a number.")
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok

		ok

		# Doing the job

		_nLen_ = StzStringQ(pcSubStr).NumberOfChars()
		_nLenStr_ = This.NumberOfChars()
		_anPos_ = []

		if n > 1
			for @i = 1 to _nLenStr_ - _nLen_ - 1 step n
				_anPos_ + ( @i + 1 )
			next
		ok

		This.InsertAfterThesePositions(_anPos_, pcSubStr)


		#< @FunctionFluentForm

		def InsertAfterEveryNCharsQ(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertSubStringAfterEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)

		def InsertEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)
	
		def InsertSubStringEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertSubStringEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)

		#>

	def SubStringInsertedAfterEachNCHars(n, pcSubStr)
		cResult = This.Copy().InsertAfterEveryNCharsQ(n, pcSubStr).Content()
		return cResult

		def SubStringInsertedEveryNChars(n, pcSubStr)
			return This.SubStringInsertedAfterEachNCHars(n, pcSubStr)

	  #------------------------------------------------#
	 #   INSERTING A SUBSTRING AFTER MANY POSITIONS   #
	#================================================#

	 def InsertAfterPositions(panPos, pcSubStr)

		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
	
				stzRaise("Incorrect param! panPos must be a list of numbers.")
			ok
	
			if isList(pcSubStr) and StzListQ(pcSubStr).IsStringOrSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

		ok

		nLenStr = This.NumberOfChars()
		if nLenstr = 0
			return
		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return
		ok

		# Doing the job

		panPos = ring_sort(panPos)
		oQCopy = QStringObject()

		for i = nLenPos to 1 step -1
			oQCopy.insert(panPos[i], pcSubStr)
		next

		This.UpdateWith( QStringToString(oQCopy) )

		#< @FunctionFluentForm

		def InsertAfterPositionsQ(panPos, pcSubStr)
			This.InsertAfterPositions(panPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterManyPositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertAfterManyPositionsQ(panPos, pcSubstr)
				This.InsertAfterManyPositions(panPos, pcSubstr)
				return This

		def InsertAfterThesePositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertAfterThesePositionsQ(panPos, pcSubstr)
				This.InsertAfterThesePositions(panPos, pcSubstr)
				return This

		#--

		def InsertSubStringAfterPositions(panPos, pcSubStr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterPositionsQ(panPos, pcSubStr)
				This.InsertSubStringAfterPositions(panPos, pcSubStr)
				return This

		def InsertSubStringAfterManyPositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterManyPositionsQ(panPos, pcSubstr)
				This.InsertSubStringAfterManyPositions(panPos, pcSubstr)
				return This

		def InsertSubStringAfterThesePositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterThesePositionsQ(panPos, pcSubstr)
				This.InsertSubStringAfterThesePositions(panPos, pcSubstr)
				return This

		#>

	def SubStringInsertedAfterThesePositions(anPos, pcSubStr)
		cResult = This.Copy().InsertAfterThesePositionsQ(panPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterManyPositions(anPos, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPos, pcSubStr)

		def SubStringInsertedAfterPositions(anPos, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPos, pcSubStr)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BEFORE MANY POSITIONS   #
	#-------------------------------------------------#

	 def InsertBeforePositions(panPos, pcSubStr)

		if CheckingParams()

			if isString(panPos) and isList(pcSubStr)
				tempVal = panPos
				panPos = pcSubStr
				pcSubStr = tempVal
			ok

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				stzRaise("Incorrect param! panPos must be a list of numbers.")
			ok
	
			if isList(pcSubStr) and StzListQ(pcSubStr).IsStringOrSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

		ok

		# Early check

		nLenStr = This.NumberOfChars()
		if nLenstr = 0
			return
		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return
		ok

		panPos = ring_sort(panPos)

		# Doing the job

		oQCopy = QStringObject()

		for i = nLenPos to 1 step -1
			oQCopy.insert(panPos[i]-1, pcSubStr)
		next

		This.UpdateWith( QStringToString(oQCopy) )

		#< @FunctionFluentForm

		def InsertBeforePositionsQ(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeManyPositions(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)

		def InsertBeforeThesePositions(panPos, pcSubStr)

			This.InsertBeforePositions(panPos, pcSubStr)
			
		#--

		def InsertSubStringBeforePositions(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforePositionsQ(panPos, pcSubStr)
				This.InsertSubStringBeforePositions(panPos, pcSubStr)
				return This

		def InsertSubStringBeforeManyPositions(panPos, pcSubstr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforeManyPositionsQ(panPos, pcSubstr)
				This.InsertSubStringBeforeManyPositions(panPos, pcSubstr)
				return This

		def InsertSubStringBeforeThesePositions(panPos, pcSubstr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforeThesePositionsQ(panPos, pcSubstr)
				This.InsertSubStringBeforeThesePositions(panPos, pcSubstr)
				return This

		#>

	def SubStringInsertedBeforeThesePositions(anPos, pcSubStr)
		cResult = This.Copy().InsertBeforeThesePositionsQ(panPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedBeforeManyPositions(anPos, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPos, pcSubStr)

		def SubStringInsertedBeforePositions(anPos, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPos, pcSubStr)


	  #-----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING BEFORE EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#=============================================================================#

	def InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		This.InsertBeforePositions(anPos, pcNewSubStr)

		#< @FunctionFluentForm

		def InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
					return This

		#--

		def InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeSubstring(pcSubStr, pcNewSubStr)
		This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		def InsertBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE NTH       #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )


		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING AFTER EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#============================================================================#

	def InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		for i = 1 to nLen
			anPos[i] += (nLenSubStr - 1)
		next

		This.InsertAfterPositions(anPos, pcNewSubStr)


		#< @FunctionFluentForm

		def InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This	
	
		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def InsertAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#--

		def InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterSubstring(pcSubStr, pcNewSubStr)
		This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		def InsertAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedAfterEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER THE NTH   #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)

	   #-----------------------------------------------------#
	  #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION      #
	 #  BY CONCATNEATING THEM ACCORDING TO A GIVEN FORMAT  #
	#====================================================#

	def InsertSubstringsXT( nPos, aSubStr, paOptions)
		/*
		Example:
	
		o1 = new stzString("All our software versions must be updated!")
		# Defining the position of insertion
		nPosition = o1.PositionAfterSubstring("versions") + 1
			
		# Inserting the list of string using extended configuration
		? o1.InsertListOfSubstringsXT(
			nPosition, [ "V1", "V2", "V3", "V4", "V5" ],
			
			[
			:cInsertBeforOrAfter = :Before,
			:OpeningChar = "(",
			:ClosingChar = ")", 
		
			:MainSeparator = ",",
			:AddSpaceAfterSeparator = 1,
			
			:LastSeparator = "and",
			:AddLastToMainSeparator = 1,
			
			:SpaceOption = :optEnsureLeadingSpace + :optEnsureTrailingSpace
			])
	
		Gives :
		All our software versions (V1, V2, V3, V4, and V5) must be updated!
		*/
	
		# Setting the default options
			
		cInsertBeforeOrAfter = :Before
		cOpeningChar = "("
		cClosingChar = ")"
			
		cMainSeparator = ","
		bAddSpaceAfterSeparator = 1
					
		cLastSeparator = ""
		bAddLastToMainSeparator = 0
			
		cSpaceOption = :AddLeadingSpace + :AddTrailingSpace
	
		# Verifying the syntax of the options provided
		if NOT ( len(paOptions) = 0 or
			 ( len(paOptions) = 1 and paOptions[1] = :Default) )
	
			aPossibleOptions = [ :InsertBeforeOrAfter, :OpeningChar, :ClosingChar, :MainSeparator,
				  :AddSpaceAfterSeparator, :LastSeparator, :AddLastToMainSeparator,
				  :SpaceOption ]
		
			oHash = new stzHashList(paOptions)
			aListOfProvidedOptions = oHash.Keys()
		
			oListOfProvidedOptions = new stzList(aListOfProvidedOptions)
		
			if NOT oListOfProvidedOptions.IsMadeOfSome(aPossibleOptions)
				stzRaise(stzStringError(:UnsupportedOptionsWhileInsertingListOfStrings))
			ok
		
			# If some options are provided then we take them
			#NOTE : if len(paOptions) = 0 or paOptions = [ :Default ] then we preserve
			# the default options already defined
				
			cInsertBeforeOrAfter = paOptions[ :InsertBeforeOrAfter ]	
			cOpeningChar = paOptions[ :OpeningChar ]
			cClosingChar = paOptions[ :ClosingChar ]
					
			cMainSeparator = paOptions[ :MainSeparator ]
			bAddSpaceAfterSeparator = paOptions[ :AddSpaceAfterSeparator ]
		
			cLastSeparator = paOptions[ :LastSeparator ]
			bAddLastToMainSeparator = paOptions[ :AddLastToMainSeparator ]
		
			cSpaceOption = paOptions[ :SpaceOption ]
		ok
	
		# At this level, all the options are defined
		# Beginning the substring construction but the opening char
	
		cSubStr = cOpeningChar
			
		# Checking the behavior of the first inserted substring in regard of adjacent left space

		if NOT cSpaceOption = :DoNothing
			if cSpaceOption = :AddLeadingSpace or
			   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
			   cSpaceOption = :AddTrailingSpace + :AddLeadingSpace
	
				if nPos > 1 and This.NthChar(nPos - 1) != " "
					cSubStr = " " + cOpeningChar
				ok
			ok
		ok
	
		# Looping over the list of strings to concatenate them
		# depending on the logic defined by the options
	
		for i = 1 to len(aSubStr)
			# we add the string itslef
			cSubStr += aSubStr[i]
	
			# while we are not on the last item, or
			# we are on the last item but we are not asked
			# to use an alternative separator at the end
	
			if i < len(aSubStr) - 1 OR
			   (i = len(aSubStr)-1 and cLastSeparator = "")
	
				# Add the main separator after each string
				cSubStr += cMainSeparator
	
				# Add space after separator if required
				if bAddSpaceAfterSeparator = 1
						cSubstr += " "
				ok	
	
			# When reaching the last string, and an alternative
			# separator must be used (it's not null), we check
			# if we should use this last separator alone or
			# in addition to the main separator
	
			but i = len(aSubStr) - 1
	
				if bAddLastToMainSeparator = 1
					cSubStr += cMainSeparator
				ok
	
				if bAddSpaceAfterSeparator = 1
					cSubstr += " "
				ok
	
				if cLastSeparator != ""
					cSubStr += cLastSeparator
				ok
	
				if bAddSpaceAfterSeparator = 1
					cSubstr += " "
				ok
			ok		
		next
	
		# Add the closing char to get the final substring
	
		cSubStr += cClosingChar
	
		# Checking the option of leaving the trailing space
	
		if cSpaceOption = :AddTrailingSpace or
		   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
		   cSpaceOption = :AddTrailiningSpace + :AddLeadingSpace
	
			cSubStr += " "
		ok
	
		if cInsertBeforeOrAfter = :After
			nPos++
		ok

		# Doing the job!

		This.InsertBefore(nPos, cSubStr)
	
		#< @FunctionFluentForm
		
		def InsertSubstringsXTQ( nPos, aSubStr, paOptions)
			This.InsertSubstringsXT( nPos, aSubStr, paOptions)
			return This
		
		#>

		#< @FunctionAlternativeForms

		def InsertManyXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManyXTQ(nPos, aSubStr, paOptions)
				This.InsertManyXT(nPos, aSubStr, paOptions)
				return This

		def InsertManySubStringsXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManySubStringsXTQ(nPos, aSubStr, paOptions)
				This.InsertManySubStringsXT(nPos, aSubStr, paOptions)
				return This

		#>

	def SubstringsInsertedXT(nPos, aSubStr, paOptions)
		cResult = This.Copy().InsertSubstringsXTQ( nPos, aSubStr, paOptions).Content()
		return cResult

		def ManySubStringsInsertedXT(nPos, aSubStr, paOptions)
			return This.SubstringsInsertedXT(nPos, aSubStr, paOptions)

	  #-----------------------------------------------------------------------#
	 #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION BY CONCATNEATING THEM  #
	#=======================================================================#

	def InsertSubstrings(nPos, aSubStr)
		This.InsertSubstringsXT( nPos, aSubStr, [:Default] )
	
		#< @FunctionFluentForm
		
		def InsertSubstringsQ(nPos, aSubStr)
			This.InsertSubstrings(nPos, aSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#TODO // Add "These" as alternative of "Many"

		def InsertMany(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManyQ(nPos, aSubStr)
				This.InsertMany(nPos, aSubStr)
				return This

		def InsertManySubStrings(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManySubStringsQ(nPos, aSubStr)
				This.InsertManySubStrings(nPos, aSubStr)
				return This

		#>

	def SubstringsInserted(nPos, aSubStr)
		cResult = This.Copy().InsertSubstringsQ(nPos, aSubStr).Content()
		return cResult

		def ManySubStringsInserted(nPos, aSubStr)
			return This.SubstringsInserted(nPos, aSubStr)

	  #=================================================#
	 #     REPLACING ALL OCCURRENCES OF A SUBSTRING    #
	#=================================================#
	
	def ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = YES | @QtBased #>

		/* Example:
	
		StzStringQ("Tunis is the town of my memories.") {
			ReplaceAll("Tunis", "Niamey" )
			? Content()
		}
		#--> Niamey is the town of my memories.
	
		*/

		if CheckingParams()

			# Checking the pcSubStr param
	
			if isList(pcSubStr)

				This.ReplaceManyCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return
			ok
	
			if NOT isString(pcSubstr)
				stzRaise("Incorrect param type! pcSubstr must be a string.")
			ok
	
			# Checking the correctness of pcNewSubStr param
	
			if isList(pcNewSubStr)
				_oList_ = StzListQ(pcNewSubStr)

				if _oList_.IsWithOrUsingOrByNamedParam() or
				   _oList_.IsWithManyOrUsingManyOrByManyNamedParam()

					pcNewSubStr = pcNewSubStr[2]
				ok
			ok

			if isList(pcNewSubStr)
				return This.ReplaceByManyCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			ok

		ok

		# Doing the job

		_bCase_ = @CaseSensitive(pCaseSensitive)
		_cResult_ = This.Content()

		_cResult_ = @ReplaceCS(_cResult_, pcSubStr, pcNewSubStr, _bCase_)
		This.UpdateWith(_cResult_)

		#< @FunctionFluentForm
		
		def ReplaceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		def ReplaceCSQC(pcSubStr, pcNewSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return _oCopy_
		#>


		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionMisspelledForm

		#TODO // Add Repalce as a misspelled form to all Replace...() functions

		def RepalceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Replace(pcSubStr, pcNewSubStr)
		This.ReplaceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm
		
		def ReplaceQ(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)
			return This

		def ReplaceQC(pcSubStr, pcNewSubStr)
			_oCopy_ = This.Copy()
			_oCopy_.Replace(pcSubStr, pcNewSubStr)
			return _oCopy_

		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionMisspelledForm

		#TODO // Add Replace as a misspelled form to all Replace...() functions

		def Repalce(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)

		#>

	def SubStringReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceSubStringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	  #---------------------------------#
	 #     REPLACING FIRST N CHARS     #
	#---------------------------------#

	def ReplaceFirstNChars(n, pcNewSubStr)
		This.ReplaceSection(1, n, pcNewSubStr)

		def ReplaceFirstNCharsQ(n, pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)
			return This

		def ReplaceNFirstChars(pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)

			def ReplaceNFirstCharsQ(pcNewSubStr)
				This.ReplaceNFirstChars(pcNewSubStr)
				return This

	def FirstNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceFirstNCharsQ(n, pcNewSubStr).Content()

		def NFirstCharsReplaced(pcNewSubStr)
			return This.FirstNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LAST N CHARS     #
	#--------------------------------#

	def ReplaceLastNChars(n, pcNewSubStr)
		nLen = This.NumberOfChars()
		This.ReplaceSection(This.NumberOfChars() - n + 1, nLen, pcNewSubStr)

		def ReplaceLastNCharsQ(n, pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)
			return This

		def ReplaceNLastChars(pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)

			def ReplaceNLastCharsQ(pcNewSubStr)
				This.ReplaceNLastChars(pcNewSubStr)
				return This

	def LastNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLastNCharsQ(n, pcNewSubStr).Content()

		def NLastCharsReplaced(pcNewSubStr)
			return This.LastNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LEFT N CHARS     #
	#--------------------------------#

	def ReplaceLeftNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceFirstNChars(n, pcNewSubStr)

		else
			This.ReplaceLastNChars(n, pcNewSubStr)
		ok

		def ReplaceLeftNCharsQ(n, pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)
			return This

		def ReplaceNLeftChars(pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)

			def ReplaceNLeftCharsQ(pcNewSubStr)
				This.ReplaceNLeftChars(pcNewSubStr)
				return This

	def LeftNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLeftNCharsQ(n, pcNewSubStr).Content()

		def NLeftCharsReplaced(pcNewSubStr)
			return This.LeftNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING RIGHT N CHARS    #
	#--------------------------------#

	def ReplaceRightNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceLastNChars(n, pcNewSubStr)

		else
			This.ReplaceFirstNChars(n, pcNewSubStr)
		ok

		def ReplaceRightNCharsQ(n, pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)
			return This

		def ReplaceNRightChars(pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)

			def ReplaceNRightCharsQ(pcNewSubStr)
				This.ReplaceNRightChars(pcNewSubStr)
				return This

	def RightNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceRightNCharsQ(n, pcNewSubStr).Content()

		def NRightCharsReplaced(pcNewSubStr)
			return This.RightNCharsReplaced(pcNewSubStr)

	  #-------------------------------#
	 #     REPLACING MIDDLE CHAR     #
	#-------------------------------#

	def ReplaceMiddleChar(pcNewSubStr)
		nPos = This.FindMiddleChar()
		This.ReplaceSection(nPos, nPos, pcNewSubStr)

		def ReplaceMiddleCharQ(pcNewSubStr)
			This.ReplaceMiddleChar(pcNewSubStr)
			return This

	def MiddleCharReplaced(pcNewSubStr)
		cResult = This.Copy().ReplaceMiddleCharQ(pcNewSubStr).Content()
		return cResult

	  #-------------------------------------------#
	 #     REPLACING MANY SUBSTRINGS AT ONCE     #
	#===========================================#

	def ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzString( "a + b - c / d = 0")
		o1.ReplaceMany( ["+", "-", "/" ], :By = "*" )
		? o1.Content()
	
		#--> "a * b * c * d = 0"	
		*/

		if CheckingParams()

			if NOT ( isList(pacSubStr) and
				 @IsListOfStrings(pacSubStr) )
	
				stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
	
			if isList(pNewSubStr) and StzListQ(pNewSubStr).IsWithOrByNamedParam()
				pNewSubStr = pNewSubStr[2]
			ok
	
			if isList(pNewSubStr)
				return This.ReplaceManyByManyCS(pacSubStr, pNewSubStr, pCaseSensitive)
			ok
	
			if NOT isString(pNewSubStr)
				stzRaise("Incorrect param type! pNewSubStr must be a string.")
			ok

		ok

		# Doing the job

		pacSubStr = Q(pacSubStr).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(pacSubStr)	

		bCase = @CaseSensitive(pCaseSensitive)
		cResult = This.Content()
		for i = 1 to nLen
			cResult = @ReplaceCS(cResult, pacSubStr[i], pNewSubStr, bCase)
		next


		This.UpdateWith(cResult)

		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceTheseCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		def ReplaceAllOfTheseCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		def ReplaceManySubstringsCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceManySubstringsCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		#--

		def ReplaceSubStringsCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceSubStringsCSQ(pacSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		#>

	def ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
		acResult = This.Copy().ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def SubStringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def TheseSubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def TheseReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(pacSubstr, pcNewSubstr)
		This.ReplaceManyCS( pacSubstr, pcNewSubstr, 1 )

		#< @FunctionFluentFormn

		def ReplaceManyQ(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)
			return This
		#>

		#< @FunctionAlternativeForm
	
		def ReplaceThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceAllOfThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceAllOfTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceManySubstrings(pacSubstr, pNewSubstr)
			This.ReplaceMany(pacSubstr, pNewSubstr)

			def ReplaceManySubstringsQ(pacSubstr, pNewSubstr)
				This.ReplaceManySubstrings(pacSubstr, pNewSubstr)
				return This

		#--

		def ReplaceSubStrings(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubStr, pNewSubstr)

			def ReplaceSubStringsQ(pacSubStr, pcNewSubStr)
				return This.ReplaceManyQ(pacSubStr, pNewSubstr)

		def ReplaceTheseSubStrings(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubStr, pNewSubstr)

			def ReplaceTheseSubStringsQ(pacSubStr, pcNewSubStr)
				return This.ReplaceManyQ(pacSubStr, pNewSubstr)


		#>

	def ManySubstringsReplaced(pacSubstr, pNewSubstr)
		acResult = This.Copy().ReplaceManySubstringsQ(pacSubstr, pNewSubstr).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def SubStringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def TheseSubstringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def TheseReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		#>

	  #--------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS  #
	#--------------------------------------------#

	def ReplaceByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ruby ring python ring")
		o1.ReplaceByMany("ring", :By = [ "♥", "♥♥", "♥♥♥" ])
	
		? o1.Content() #--> "♥ php ruby ♥♥ python ♥♥♥"

		*/

		if CheckingParams()

			if isList(pacNewSubStr) and StzListQ(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT isList(pacNewSubStr)
				stzRaise("Incorrect param! pacNewSubStr must be a list.")
			ok
	
			nLenNewSubStr = len(pacNewSubStr)
			if nLenNewSubStr > 0 and
	
			   isList(pacNewSubStr[nLenNewSubStr]) and
			   len(pacNewSubStr[nLenNewSubStr]) = 2 and
			   isString(pacNewSubStr[nLenNewSubStr][1]) and
			   pacNewSubStr[nLenNewSubStr][1] = "and"
	
				pacNewSubStr[nLenNewSubStr] = pacNewSubStr[nLenNewSubStr][2]
			ok
	
			if NOT IsListOfStrings(pacNewSubStr)
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok
		ok

		# Doing the job

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nMin = Min([ len(anPos), len(pacNewSubStr) ])
	
		for i = nMin to 1 step -1
			n = anPos[i]
			cNewSubStr = pacNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceSubStringByManyCSQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringByManyCSQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplaceByTheseCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceByTheseSubStringsCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseSubStringsCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def TheseSubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisSubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		#>
		
	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pcSubStr, pacNewSubStr)
		This.ReplaceByManyCS(pcSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceByManyQ(pcSubStr, pacNewSubStr)
			return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, 1)

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByMany(cSubStr, pacNewSubStr)
			This.ReplaceByMany(cSubStr, pacNewSubStr)

			def ReplaceSubStringByManyQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyQ(pcSubStr, pacNewSubStr)

		def ReplaceThisSubStringByMany(cSubStr, pacNewSubStr)
			This.ReplaceByMany(cSubStr, pacNewSubStr)

			def ReplaceThisSubStringByManyQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyQ(pcSubStr, pacNewSubStr)

		#--

		def ReplaceByThese(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceByTheseSubStrings(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByThese(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseSubStrings(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		#>

	#< @FunctionPassiveForms

	def ReplacedByMany(pcSubStr, pacNewSubStr)
		return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		#--

		def ReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def SubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def TheseSubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisSubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		#>

	#>

	  #--------------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS -- EXTENDED (RETURN TO FIRST)  #
	#--------------------------------------------------------------------------#

	def ReplaceByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> "#1 php #2 ruby #1 python #2"

		*/

		if CheckingParams()

			if isList(pacNewSubStr) and StzListQ(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT Q(pacNewSubStr).IsListOfStrings()
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok

		ok

		# doing the job

		anPos = This.FindCSQ(pcSubStr, pCaseSensitive).SortedInDescending()
		nLen = len(anPos)

		acNewSubStrings = StzListQ(pacNewSubStr).SortedInDescending()
		nLen2 = len(acNewSubStrings)
	
		n = 0
		for i = 1 to nLen
			nPos = anPos[i]
			n++
			if n > nLen2
				n = 1
			ok

			cNewSubStr = acNewSubStrings[n]
			This.ReplaceSubStringAtPositionNCS(nPos, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

		#< @FunctionFluentForm

		def ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceSubStringByManyCSXTQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringByManyCSXTQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplaceByTheseCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceByTheseSubStringsCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseSubStringsCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def TheseSubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisSubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		#>
		
	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pcSubStr, pacNewSubStr)
		This.ReplaceByManyCSXT(pcSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceByManyXTQ(pcSubStr, pacNewSubStr)
			return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, 1)

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyXT(cSubStr, pacNewSubStr)
			This.ReplaceByManyXT(cSubStr, pacNewSubStr)

			def ReplaceSubStringByManyXTQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyXTQ(pcSubStr, pacNewSubStr)

		def ReplaceThisSubStringByManyXT(cSubStr, pacNewSubStr)
			This.ReplaceByManyXT(cSubStr, pacNewSubStr)

			def ReplaceThisSubStringByManyXTQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyXTQ(pcSubStr, pacNewSubStr)

		#--

		def ReplaceByTheseXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceByTheseSubStringsXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseSubStringsXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyXT(pcSubStr, pacNewSubStr)
		return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		#--

		def ReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def TheseSubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisSubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		#>

	#>

	  #------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS  #
	#------------------------------------------------------#

	def ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp ring kandaji")
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "♥", "♥♥", "♥♥♥" ])

		? o1.Content() #--> "♥ qt ♥♥ pyhton ♥♥♥ csharp ♥♥"
		*/

		if CheckingParams()
	
			if isList(pacNewSubStr) and StzListQ(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT (isList(pacNewSubStr) and @IsListOfStrings(pacNewSubStr))
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok

		ok

		# Doing the job

		if IsSet(pacSubStr)

			nLenSubStr = len(pacSubStr)
			nLenNewSubStr = len(pacNewSubStr)
	
			if nLenSubStr = 0 or nLenNewSubStr = 0
				return
			ok
	
			if NOT ( nLenSubStr = nLenNewSubStr )
				StzRaise("Incorrect values! nLenSubStr and pacNewSubStr must have the same size.")
			ok
	
			for i = 1 to nLenSubStr
				This.ReplaceCS(pacSubStr[i], pacNewSubStr[i], pCaseSensitive)
			next

		else
			# In case where pacSubStr contains duplicated items
			# ~> an ordered replacement is made

			nLen1 = len(pacSubStr)
			nLen2 = len(pacNewSubStr)
			nMin = Min([ nLen1, nLen2 ])

			acSubStr = []
			if nLen1 > nMin
				for i = 1 to nMin
					acSubStr + pacSubStr[i]
				next
			else
				acSubStr = pacSubStr
			ok

			acNewSubStr = []
			if nLen2 > nMin
				for i = 1 to nMin
					acNewSubStr + pacNewSubStr[i]
				next
			else
				acNewSubStr = pacNewSubStr
			ok


			acSections = StzListQ(acSubStr).SectionsOfSameItems()
			nLen = len(acSections)

			nStart = 1

			for i = 1 to nLen
				
				n = len(acSections[i])

				acNewSubStr = []
			
				for j = nStart to nStart + n - 1
					acNewSubStr + pacNewSubStr[j]
				next
				nStart += n

				This.ReplaceOccurrencesByMany( 1:n, acSections[i][1], acNewSubStr)
			next
		ok

		#< @FunctionFluentForm

		def ReplaceManyByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceManySubStringsByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceManySubStringsByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplacedByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringsReplacedByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

		def ManyReplacedByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(pacSubStr, pacNewSubStr)
		This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceManyByManyQ(pacSubStr, pacNewSubStr)
			This.ReplaceManyByMany(pacSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByMany(pacSubStr, pacNewSubStr)
			This.ReplaceManyByMany(pacSubStr, pacNewSubStr)

			def ReplaceManySubStringsByManyQ(pacSubStr, pacNewSubStr)
				This.ReplaceManySubStringsByMany(pacSubStr, pacNewSubStr)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplacedByMany(pacSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceManyByManyQ(pacSubStr, pacNewSubStr).Content()
		return cResult

		def SubStringsReplacedByMany(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplacedByMany(pacSubStr, pacNewSubStr)

		def ManyReplacedByMany(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplacedByMany(pacSubStr, pacNewSubStr)

	#>

	  #------------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS -- XT  #
	#------------------------------------------------------------#
	# XT ~> Return to beginning if all the other substrings are replaced

	def ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp zai")
		o1.ReplaceManyByManyXT([ "ring", "softanza", "kandaji", "zai" ], :By = [ "♥", "♥♥" ])
		
		? o1.Content()
		# ♥ qt ♥♥ pyhton ♥ csharp ♥♥

		*/

		if CheckingParams()
	
			if isList(pacNewSubStr) and StzListQ(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT (isList(pacNewSubStr) and @IsListOfStrings(pacNewSubStr))
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok	

		ok

		# Doing the job

		nLenSubStr = len(pacSubStr)
		nLenNewSubStr = len(pacNewSubStr)

		if nLenSubStr = 0 or nLenNewSubStr = 0
			return
		ok

		# Extending or shrinking acNewSubStr, if necessary, so it has
		# the same size as acSubStr

		acNewSubStr = []

		if nLenNewSubStr < nLenSubStr
			acNewSubStr = pacNewSubStr
			n = 0
			for i = nLenNewSubStr + 1 to nLenSubStr
				n++
				if n > nLenNewSubStr
					n = 1
				ok
				acNewSubStr + pacNewSubStr[n]
			next
		else
			acNewSubStr = []
			for i = 1 to nLenSubStr
				pacSubStr + pacNewSubStr[i]
			next
		ok

		# Calling the noral function

		This.ReplaceManyByManyCS(pacSubStr, acNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceManyByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceManySubStringsByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceManySubStringsByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplacedByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringsReplacedByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

		def ManyReplacedByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByManyXT(pacSubStr, pacNewSubStr)
		This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceManyByManyXTQ(pacSubStr, pacNewSubStr)
			This.ReplaceManyByManyXT(pacSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyXT(pacSubStr, pacNewSubStr)
			This.ReplaceManyByManyXT(pacSubStr, pacNewSubStr)

			def ReplaceManySubStringsByManyXTQ(pacSubStr, pacNewSubStr)
				This.ReplaceManySubStringsByManyXT(pacSubStr, pacNewSubStr)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplacedByManyXT(pacSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceManyByManyXTQ(pacSubStr, pacNewSubStr).Content()
		return cResult

		def SubStringsReplacedByManyXT(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplaceByManyXT(pacSubStr, pacNewSubStr)

		def ManyReplacedByManyXT(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplacedByManyXT(pacSubStr, pacNewSubStr)

	#>

	  #------------------------------------------#
	 #     REPLACING SUBSTRING AT POSITION N    #
	#==========================================#

	def ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect pram type! pcSubStr must be a string.")
			ok
		ok

		# Doing the job

		nLen = StzStringQ(pcSubStr).NumberOfChars()

		if This.RangeQ(n, nLen).IsEqualToCS(pcSubStr, pCaseSensitive)
			This.ReplaceRange(n, nLen, pcNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#--

		def ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			if isList(n)
				This.ReplaceSubStringAtPositionsCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return
			ok

			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubStringAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	def SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def SubStringAtPositionReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplacedAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplacedAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, 1)

		#< @FunctionAlternativeForms

		def ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
				return This

		def ReplaceAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceAtPositionQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)

		#--

		def ReplaceAt(n, pcSubStr, pcNewSubStr)
			This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, 1)

			def ReplaceAtQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceAtQCS(n, pcSubStr, pcNewSubStr, 1)

		def ReplaceSubStringAt(n, pcSubStr, pcNewSubStr)
			This.ReplaceAt(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceAtQ(n, pcSubStr, pcNewSubStr)

		#>

	def SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, 1).Content()
		return cResult

		#< @FunctionalternativeForms

		def SubStringAtPositionReplaced(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		def ReplacedAtPosition(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		def SubStringReplacedAtPosition(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		#--

		def ReplacedAt(n, pcSubStr, pcNewSubStr)
			cResult = This.Copy().ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, 1).Content()
			return cResult

		def SubStringReplacedAt(n, pcSubStr, pcNewSubStr)
			return This.ReplacedAt(n, pcSubStr, pcNewSubStr)

		#>

	  #--------------------------------------------------------------#
	 #   REPLACING A SUBSTRING OCCURRENCES BY AN OTHER SUBSTRING    #
	#--------------------------------------------------------------#

	def ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring ruby ring php ring")
		o1.ReplaceSubstringAtPositions([ 1, 20 ], "ring", :By = "♥♥♥")

		? o1.Content()
		#--> "♥♥♥ ruby ring php ♥♥♥"
		*/

		anPos = StzListQ(panPos).SortedInDescending()
		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceSubStringAtPositionNCS(anPos[i], pcSubStr, pcNewSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
		
		#>

	def SubStringAtPositionsReplacedCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def ReplacedAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionsReplacedCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionsReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtPositions(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)

			def ReplaceAtPositionsQ(panPos, pcSubStr, pcNewSubStr)
				return This.ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)

		#>

	def SubStringAtPositionsReplaced(panPos, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeforms

		def ReplacedAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionsReplaced(panPos, pcSubStr, pcNewSubStr)

		def SubStringReplacedAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionsReplaced(n, pcSubStr, pcNewSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING AT A SOME GIVEN POSITIONS BY MANY OTHER SUBSTRINGS    #
	#-------------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		/* EXAMPLE 1
		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceSubstringAtPositionsByMany([ 10, 20, 32], "ring", :By = [ "♥", "♥♥", "♥♥♥" ])

		? o1.Content() #--> "ring php ♥ ruby ♥♥ python ♥♥♥ csharp ring"

		*/

		#WARNING // Assumes panPos is provided as a list of numbers sorted in ascending.
		# ~> The check is made automatically by default when CheckParams() is enabled

		if CheckingParams()

			if NOT (isList(panPos) and IsListOfNumbersSortedInAscending(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers sorted in ascending.")
			ok

			if isList(pacNewSubStr) and StzListQ(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT isList(pacNewSubStr)
				stzRaise("Incorrect param! pacNewSubStr must be a lists.")
			ok
	
			nLenNewSubStr = len(pacNewSubStr)
			if nLenNewSubStr > 0 and
	
			   isList(pacNewSubStr[nLenNewSubStr]) and
			   len(pacNewSubStr[nLenNewSubStr]) = 2 and
			   isString(pacNewSubStr[nLenNewSubStr][1]) and
			   pacNewSubStr[nLenNewSubStr][1] = "and"
	
				pacNewSubStr[nLenNewSubStr] = pacNewSubStr[nLenNewSubStr][2]
			ok
	
			if NOT IsListOfStrings(pacNewSubStr)
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok
		ok

		# Keeping only the adequate number of positsions and new substrings
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new substrings

		nMin = Min([ len(panPos), len(pacNewSubStr) ])

		acNewSubStr = []
		for i = 1 to nMin
			acNewSubStr + pacNewSubStr[i]
		next

		aPosAsSections = This.FindCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aPosAsSections)

		aPosZZ = []

		for i = 1 to nMin
			if ring_find(panPos, aPosAsSections[i][1])
				aPosZZ + aPosAsSections[i]
			ok
		next

		# Doing the replacement

		This.ReplaceSectionsByMany(aPosZZ, acNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

	#< @FunctionPassiveForms

	def SubStringAtThesePositionsReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionsByMany(panPos, pcSubStr, pacNewSubStr)
		This.ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsByManyQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceSubStringAtPositionsByMany(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

	#< @FunctionPassiveForm

	def SubStringAtThesePositionsReplacedByMany(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult

	#>

	  #-----------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#=======================================================================#

	def ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
		if isList(pcNewSubStr)
			This.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			return
		ok

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(anPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesCSQ(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceNthOccurrencesCS(anOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthOccurrencesCSQ(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceNthsCS(anOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthsCSQ(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	def OccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
		aResult = This.Copy().ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return aResult

		def TheseOccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

		def NthsOccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)
		This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrences(panOccurr, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)

			def ReplaceTheseOccurrencesQ(panOccurr, pcSubStr, pcNewSubStr)
				return This.ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr)

		def ReplaceNthOccurrences(anOccurr, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)

			def ReplaceNthOccurrencesQ(panOccurr, pcSubStr, pcNewSubStr)
				return This.ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr)

		def ReplaceNths(anOccurr, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)

			def ReplaceNthsQ(panOccurr, pcSubStr, pcNewSubStr)
				return This.ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr)

		#>

	def OccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)
		aResult = This.Copy().ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr).Content()
		return aResult

		def TheseOccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)
			return This.OccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)

		def NthsOccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)
			return This.OccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)

	  #-----------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

		/*
		EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrencesByMany([ 1, 3, 5], "ring", :By = [ "#1", "#3", "#5" ])
	
		? o1.Content() #--> "#1 php ring ruby #3 python ring csharp #5"
		*/

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsByManyCS(anPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesByManyCSQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceNthOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceNthOccurrencesByManyCSQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceNthsByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceNthsByManyCSQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#>

	def OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def TheseOccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def NthOccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def NthsReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
		this.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceTheseOccurrencesByManyQ(panOccurr, pcSubStr, pacNewSubStr)
				This.ReplaceTheseOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
				return This

		def ReplaceNthOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceNthOccurrencesByManyQ(panOccurr, pcSubStr, pacNewSubStr)
				return This.ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr)

		def ReplaceNthsByMany(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceNthsByManyQ(panOccurr, pcSubStr, pacNewSubStr)
				return This.ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr)

		#>

	def OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult 

		def TheseOccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)

		def NthOccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)

		def NthsReplacedByMany(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)

	  #-----------------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS -- XT  #
	#-----------------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsByManyCSXT(anPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesByManyCSXTQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceNthOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceNthOccurrencesByManyCSXTQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceNthsByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceNthsByManyCSXTQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#>

	def OccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def TheseOccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		def NthOccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
		this.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceTheseOccurrencesByManyXTQ(panOccurr, pcSubStr, pacNewSubStr)
				This.ReplaceTheseOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
				return This

		def ReplaceNthOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceNthOccurrencesByManyXTQ(panOccurr, pcSubStr, pacNewSubStr)
				return This.ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr)

		def ReplaceNthsByManyXT(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceNthsByManyXTQ(panOccurr, pcSubStr, pacNewSubStr)
				return This.ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr)

		#>

	def OccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult 

		def TheseOccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)

		def NthOccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubString@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content() #--> "#1 php #2 ruby #3 pyhton #4"

		*/

		if isList(pcDynamicStr) and StzListQ(pcDynamicStr).IsWithOrByNamedParam()
			pcDynamicStr = pcDynamicStr[2]
		ok

		if NOT isString(pcDynamicStr)
			stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
		ok	

		anPos = This.FindAllCSQ(pcSubStr, pCaseSensitive).SortedInDescending()


		@SubString = pcSubStr

		@NumberOfOccurrences = len(anPos)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		acNewSubStr = []

		for @Position in anPos

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPos[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPos[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicStr = StzStringQ(pcDynamicStr).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempStr = ( ' + cDynamicStr + ' )'
			eval(cCode)

			acNewSubStr + cTempStr

		next

		acNewSubStr = StzListQ(acNewSubStr).SortedInDescending()
	
		i = 0
		for @Position in anPos
			i++
			cNewSubStr = acNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(@Position, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringCS@Q(pcSubStr, pcDynamicStr, pCaseSensitive)
			This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubString@(pcSubStr, pcDynamicStr)
		This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, 1)

		def ReplaceSubString@Q(pcSubStr, pcDynamicStr)
			This.ReplaceSubString@(pcSubStr, pcDynamicStr)
			return This

	  #---------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION   #
	#===================================================#

	#TODO : Generalize the CS check to all W() functions in the library

	def ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringW("ring", :Where = '{ Q(@i).IsMultipleOf(10) }', :With = "♥♥♥")

		? o1.Content() #--> "ring php ♥♥♥ ruby ♥♥♥ pyhton ring"

		*/

		aSections = This.FindSubStringWCSZZ(pcSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		def ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringReplacedWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, 1)

		def ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
			return This

	def SubStringReplacedW(pcSubStr, pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------#

	def ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringWXT("ring", :Where = '{ Q(@Position).IsMultipleOf(10) }', :With = "♥♥♥")

		? o1.Content() #--> "ring php ♥♥♥ ruby ♥♥♥ pyhton ring"

		*/

		aSections = This.FindSubStringWCSXTZZ(pcSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		def ReplaceSubStringWCSXTQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringReplacedWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringWCSXTQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringWXT(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, 1)

		def ReplaceSubStringWXTQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringWXT(pcSubStr, pcCondition, pcNewSubStr)
			return This

	def SubStringReplacedWXT(pcSubStr, pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringWXTQ(pcSubStr, pcCondition, pcNewSubStr).Content()
		return cResult

	  #---------------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS) #
	#=======================================================================================#

	def ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

		#>

		#< @FunctionALternativeForm

		def ReplaceThisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

			def ReplaceThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
				return This.ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		#>

		#< @FunctionPassiveForm

		def SubStringBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			cResult = This.Copy().ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive).Content()
			return cResult

		#>

	#--- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, 1)

		#< @FunctionFluentForm

		def ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

		#>

		#< @FunctionALternativeForm

		def ReplaceThisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

			def ReplaceThisBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
				return This.ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		#>

		#< @FunctionPassiveForm

		def SubStringBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			cResult = This.Copy().ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr).Content()
			return cResult

		#>

	  #-----------------------------------------------------------------------#
	 #  REPLACING THE SUBSTRING BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  #
	#-----------------------------------------------------------------------#

	def ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT ( @BothAreStrings(pcBound1, pcBound2) or @BothAreNumbers(pcBound1, pcBound2) )
				StzRaise("Incorrect params types! pcBound1, pcBound2 must be both strings or numbers.")
			ok
		ok

		n1 = 0
		n2 = 0

		if @BothAreStrings(pcBound1, pcBound2)

			n1 = This.FindFirstCS(pcBound1, pCaseSensitive)
			if n1 = 0
				return
			else
				n1 += StzStringQ(pcBound1).NumberOfChars()
			ok

			n2 = This.FindFirstCS(pcBound2, pCaseSensitive)
			if n2 = 0
				return
			else
				n2 += StzStringQ(pcBound2).NumberOfChars() - 1
			ok

		else // @BothAreNumbers

			n1 = pcBound1
			n2 = pcBound2

			if n1 = 0 or n1 = This.NumberOfChars() Or n2 < 2 or n1 = n2
				return
			ok
				
			n1++
			n2--

		ok

		This.ReplaceSection(n1, n2, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

		#>


	#------------

	#TODO
	#Add
	# def ReplaceIBS() # Include Bounds Starting At

	  #----------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A GIVEN SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#==================================================================================#

	def ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
		return This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceThisSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByQ(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- IB() #
	#-----------------------------------------------------------------------------------#
	# ~> Bounds are also replaced not only the substrings

	def ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)
	
		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceSubStringsBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringsBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
		This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceSubStringsBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceSubStringsBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)

		def ReplaceThisSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceThisSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#===========================================================#

	def ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceAnySubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnySubStringsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnyBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)
		return This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringsBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceSubStringsBoundedByQ(pacBounds, pcNewSubStr)
				This.ReplaceSubStringsBoundedBy(pacBounds, pcNewSubStr)
				return This

		def ReplaceAnySubStringsBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceAnySubStringsBoundedByQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)

		def ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceAnyBoundedByQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#
	# ~> Bounds are also replaced not only the sunstrings

	def ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnySubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnySubStringsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnyBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)
		return This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnySubStringsBoundedByIB(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)

			def ReplaceAnySubStringsBoundedByIBQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)

		def ReplaceAnyBoundedByIB(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)

			def ReplaceAnyBoundedByIBQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)

		#>

	  #==============================================================#
	 #  REPLACING A SUBSTRING -- EXTENDED (NNC : NEAR-NATURAL CODE  #
	#==============================================================#

	def ReplaceCSXT(p1, p2, p3, pCaseSensitive)

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").ReplaceXT("♥", [], :With = "*")
		if ( isString(p1) or ( isList(p1) and StzListQ(p1).IsEachNamedParam()) ) and

		   ( ( (isList(p2)   and len(p2) = 0) or
		     ( isString(p2) and p2 = "") or
		     (isNumber(p2) and p2 = 0) ) ) AND

		   ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCS(p1, p3, pCaseSensitive)
			return

		#  Q("*** rin* ***").ReplaceXT("*", :In = "rin*", :With = "g")
		but ( isString(p1) or ( isList(p1) and StzListQ(p1).IsEachNamedParam()) ) and
		    ( isList(p2) and StzListQ(p2).IsInOrInSideNamedParam() )
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam() ) )

			if isList(p1)
				p1 = p1[2] // "*"
			ok

		 	p2 = p2[2] // "rin*"

			if isList(p3)
				p3 = p3[2] // "g"
			ok

			cNewSubStr = Q(p2).ReplaceCSQ(p1, p3, pCaseSensitive).Content() // "ring"

			aSections = This.FindAsSectionsCS(p2, pCaseSensitive)
			This.ReplaceSections(aSections, cNewsubStr)


		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").ReplaceXT("♥", :With = "*", [])
		but ( isString(p1) or ( isList(p1) and StzListQ(p1).IsEachNamedParam()) ) and

		    ( isString(p2) or (isList(p2) and StzListQ(p2).IsWithOrByNamedParam() ) ) AND

		    ( ( (isList(p3)   and len(p3) = 0) or
		      (isString(p3) and p3 = "") or
		      (isNumber(p3) and p3 = 0) ) )

			This.ReplaceCS(p1, p2, pCaseSensitive)
			return

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:Nth = 4, "♥", :With = "\")
		but ( isNumber(p1) or
		    ( isList(p1) and StzListQ(p1).IsNthNamedParam() ) ) and

		    ( isString(p2) or ( isList(p2) and StzListQ(p2).IsEachNamedParam()) ) and

		    ( isString(p3) or ( isList(p3) and StzListQ(p3).IsWithOrByNamedParam() ) )

			if isList(p1) and StzListQ(p1).IsNthNamedParam()
				p1 = p1[2]
			ok

			This.ReplaceNthCS(p1, p2, p3, pCaseSensitive)

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:First, "♥", :With = "\")
		but ( isString(p1) and p1 = :First) and
		    ( isString(p2) or ( isList(p2) and StzListQ(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and StzListQ(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCSXT(1, p2, p3, pCaseSensitive)

		# Q("_/♥\__/♥\__/♥♥__/♥\_").ReplaceXT(:Last, "♥", :With = "\")
		but ( isString(p1) and p1 = :Last) and
		    ( isString(p2) or ( isList(p2) and StzListQ(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and StzListQ(p3).IsWithOrByNamedParam() ) )

			n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
			This.ReplaceCSXT(n, p2, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :AtPosition = 2, :With = "_")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and StzListQ(p2).IsAtPositionNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			if isList(p2) and StzListQ(p2).IsAtPositionNamedParam()
				p2 = p2[2]
			ok
			
			This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :AtPositions = [2, 7], :With = "~")
		but ( isString(p1) ) and

		    ( (isList(p2) and StzListQ(p2).IsListOfNumbers() ) or
		      (isList(p2) and StzListQ(p2).IsAtPositionsNamedParam()) ) and

		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			if isList(p2) and StzListQ(p2).IsAtPositionsNamedParam()
				p2 = p2[2]
			ok

			This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)

		# Q("_♥/♥\__").ReplaceXT("♥", :At = [2, 7], :With = "~")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and StzListQ(p2).IsAtNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			if isList(p2) and StzListQ(p2).IsAtNamedParam()
				p2 = p2[2]
			ok

			if isNumber(p2)
				This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

			but isList(p2) and StzListQ(p2).isListOfNumbers()
				This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)
			ok

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :Between = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and StzListQ(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and StzListQ(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and StzListQ(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok
			
		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedBy = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and StzListQ(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCS(p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and StzListQ(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and StzListQ(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and StzListQ(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCSIB(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok

		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and StzListQ(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCSIB(p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT("♥♥♥", :Between = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and StzListQ(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and StzListQ(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCS(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok
			
		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT("♥♥♥", :BoundedBy = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and StzListQ(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCS(p1, p2, p3, pCaseSensitive)

		# Q("Bla bla <<♥♥♥>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and StzListQ(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and StzListQ(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCSIB(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok

		# Q("Bla bla /♥♥♥/, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and StzListQ(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCSIB(p1, p2, p3, pCaseSensitive)

		#--
		but ( (isList(p1) and StzListQ(p1).IsBetweenNamedParam() ) and
		      (isString(p2) or (isList(p2) and StzListQ(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and StzListQ(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and StzListQ(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and StzListQ(p1).IsBetweenNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and StzListQ(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and StzListQ(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		#-- Allowing :BoundedBy along with :Between

		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and StzListQ(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and StzListQ(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and StzListQ(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			but isString(p2)

				This.ReplaceAnyBetweenCS(p2, p2, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a string, or a pair of strings or numbers.")
			ok
			
		but ( (isList(p1) and StzListQ(p1).IsBoundedByNamedParam() ) and
		      (isString(p2) or (isList(p2) and StzListQ(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and StzListQ(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and StzListQ(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and StzListQ(p1).IsBoundedByNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and StzListQ(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and StzListQ(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and StzListQ(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok

		ok

	#-- WITHOUT CASESENSITIVITY

	def ReplaceXT(p1, p2, p3)
		This.ReplaceCSXT(p1, p2, p3, 1)

	  #-----------------------------------------------------------------------#
	 #  REPLACING ALL SUBSTRINGS EXCEPT THOSE PROVIDED BY A GIVEN SUBSTRING  #
	#=======================================================================#

	def ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("--Ring--&__Softanza__")

		o1.ReplaceAllExcept([ "Ring", "&", "Softanza" ], :With = AHeart() )
		? o1.Content()
		#--> Ring&Softanza

		*/

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionAlternativeForms

		def ReplaceSubStringsExceptCSZ(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsOtherThanCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsOtherThanCSZ(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllButCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)
		This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, 1)

		#< @FunctionAlternativeForms

		def ReplaceSubStringsExceptZ(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceSubStringsOtherThan(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceSubStringsOtherThanZ(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceExcept(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceAllExcept(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceAllBut(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		#>

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
	
		o1 = new stzString("...12...1212...121212...")
		? o1.SubStringsMadeOf("12")
		#--> [ "12", "1212", "121212" ]
	
		*/
	
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)
		
		return acResult
		
		def MadeOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOf(pcSubStr)
		return This.SubStringsMadeOfCS(pcSubStr, 1)
	
		def MadeOf(pcSubStr)
			return This.SubStringsMadeOf(pcSubStr)

	  #-------------------------------------------------------------#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING -- ZZ/EXTENDED  #
	#-------------------------------------------------------------#
	
	def SubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = @Association([ This.Sections(aSections), aSections ])
		
		return aResult

		#< @FunctionAlternativeForms

		def MadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)

		def SubStringsMadeOfAndTheirSectionsCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)

		def MadeOfAndTheirSectionsCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOfZZ(pcSubStr)
		return This.SubStringsMadeOfCSZZ(pcSubStr, 1)
	
		#< @FunctionAlternativeForms

		def MadeOfZZ(pcSubStr)
			return This.SubStringsMadeOfZZ(pcSubStr)

		def SubStringsMadeOfAndTheirSections(pcSubStr)
			return This.SubStringsMadeOfZZ(pcSubStr)

		def MadeOfAndTheirSections(pcSubStr)
			return This.SubStringsMadeOfCSZZ(pcSubStr)

		#>

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anResult = [ anPos[1] ]
		for i = 2 to nLen
			if anPos[i] - anPos[i-1] = nLenSubStr
				loop
			ok

			anResult + anPos[i]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		#--

		def FindMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMadeOf(pcSubStr)
		return This.FindMadeOfCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		#--

		def FindMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)
		#>

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		#                      4   8 1   4 6 8   2
		o1 = new stzString("...12..1212..121212..12.")
		? @@( o1.FindMadeOf("12") )
		#--> [ 4, 8, 10, 14, 16, 18 ]

		*/


		# Checking param type

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if pcSubStr = ""
			return []
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		oSections = new stzListOfSections(aSections)
		aResult = oSections.ContiguousMerged()

		return aResult

/*---		
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive) + [ 0, 0 ]
		nLenSections = len(aSections)

		aResult = []

		for i = 1 to nLenSections - 1

			for j = i to nLenSections - 1
				aCurrentSection = aSections[j]
				aNextSection = aSections[j+1]
	
				aSection = aCurrentSection
				if aCurrentSection[j][2] = aNextSection[j][1] - 1
					aSection[i][2] = aNextSection[j][2]
				
				else
					i += j
					exit
				ok
			next

			aResult + aSection

			
		next

		del( aResult, len(aResult) )

		return aResult
/*---
		# preparing the list of chars

		bCase = CaseSensitive(pCaseSensitive)
		if bCase = 1
			acChars = This.Chars()

		else
			acChars = This.CharsQ().Lowercased()
			pcSubStr = lower(pcSubStr)
		ok

		# Preparing some values we need

		nLenStr = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		cFirstChar = Q(pcSubStr).FirstChar()

		# Finding the positions of pcSubStr in the string

		anPos = This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenPos = len(anPos)

		aResult = []
		
		# For each position

		for i = 1 to nLenPos

			# we start parsing the string from that position

			n = anPos[i]
			nNext = 0
			if i < nLenPos
				nNext = anPos[i+1]
			ok

			# if the char we are parsing does not belong to
			# pcSubStr, then we stop the parsing and return
			# the section (done for each position)

			while 1
				n += nLenSubStr
				if n > nLenStr or
				   (nNext != 0 and n >= nNext)
					exit
				ok

				if NOT acChars[n] = cFirstChar
					aTempSection = [ anPos[i], (n-1) ]

					if len(aResult) > 0 and
					   anPos[i] = aResult[len(aResult)][1]

						aResult[len(aResult)][2] = (n-3)

					else
						aResult + [ anPos[i], (n-3) ]
					ok
				ok

				
			end
		next
		
		return aResult
*/
		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#--  WITHOUT CASESENSITIVITY

	def FindMadeOfAsSections(pcSubStr)
		return This.FindMadeOfAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		#--

		def FindMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def FindSubStringsMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		#>

	  #----------------------------------------------------#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING -- XT  #
	#====================================================#
	
	def SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = This.SectionsXT(aSections)
		return aResult

		def MadeOfCSXT(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOfXT(pcSubStr)
		return This.SubStringsMadeOfCSXT(pcSubStr, 1)
	
		def MadeOfXT(pcSubStr)
			return This.SubStringsMadeOfXT(pcSubStr)

	  #==============================================================#
	 #   REPLACING A CHAR AT A GIVEN POSITION BY A GIVEN SUBSTRING  #
	#==============================================================#

	def ReplaceCharAtPosition(n, pcNewSubStr)
		#< @MotherFunction = ReplaceSection() > @QtBased = 1 #>

		This.ReplaceSection(n, n, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceCharAtPositionQ(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceCharAt(n, pcNewSubStr)
			if isList(n) and StzListQ(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtQ(n, pcNewSubStr)
				This.ReplaceCharAt(n, pcNewSubStr)
				return This

		def ReplaceCharAtPositionN(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceCharAtThisPosition(n, pcNewSubStr)
				return This

		#--

		def ReplaceAnyCharAtPosition(pc, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtPositionQ(pc, pcNewSubStr)
				This.ReplaceAnyCharAtPosition(pc, pcNewSubStr)
				return This

		def ReplaceAnyCharAt(n, pcNewSubStr)
			if isList(n) and StzListQ(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtQ(n, pcNewSubStr)
				This.ReplaceAnyCharAt(n, pcNewSubStr)
				return This

		def ReplaceAnyCharAtPositionN(n, pcNewSubStr)
			This.ReplaceAnyCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceAnyCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceAnyCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceAnyCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceAnyCharAtThisPosition(n, pcNewSubStr)
				return This

		#>

	def CharReplacedAtPosition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		cResult = This.Copy().ReplaceCharAtPositionQ(n, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharReplacedAtThisPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def CharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		#--

		def AnyCharReplacedAtPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def AnyCharReplacedAtThisPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def AnyCharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		#>

		#TODO // Add Replace as misspelling of Replace

	  #-------------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def ReplaceCharsAtPositions(panPos, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		if CheckParams()
			if NOT isList(panPos) and IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByOrUsingNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok
		ok

		nLen = len(panPos)
		if nLen = 0
			return
		ok

		anPos = ring_sort(panPos)

		for i = nLen to 1 step -1
			This.ReplaceCharAtPositionN(anPos[i], pcNewSubStr)
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsQ(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAt(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceCharsAtThesePositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#--

		def ReplaceAnyCharsAtPositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceAnyCharsAt(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceAnyCharsAtThesePositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#>

		#< @FunctionMisspelledForm

		def RepalceCharsAtPositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#>

	def CharsReplacedAtPositions(panPos, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsQ(panPos, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharsReplacedAtThesePositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def CharsAtThesePositionsReplaced(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		#--

		def AnyCharsReplacedAtPositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def AnyCharsReplacedAtThesePositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def AnyCharsAtThesePositionsReplaced(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		#>
	  #-----------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		/* EXAMPLE
		o1 = new stzString("ab3de6gh9")
		o1.ReplaceCharsAtPositionsByMany([3, 6, 9], [ "c", "f", "i" ])

		? o1.Content() #--> "abcdefghi"
		*/

		#WARNING // Assumes panPos is provided in a list of numbers sorted in ascending.
		# ~> The check is made automatically when CheckParams() is enabled.

		if CheckingParams()
			if NOT (isList(panPos) and IsListOfNumbersSortedUp(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers sorted in ascending.")
			ok

			if NOT (isList(pacNewSubStr) and IsListOfStrings(pacNewSubStr))
				StzRaise("Incorrect param type! pacNewSubStr must be a list of strings.")
			ok
		ok

		nMin = Min([ len(panPos), len(pacNewSubStr) ])
		anPos = StzListQ(panPos).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStr).SectionQ(1, nMin).SortedInDescending()

		i = 0

		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceCharAtPosition(anPos[i], acNewSubStrings[i])
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsByManyQ(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAtByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceCharsAtThesePositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		#--

		def ReplaceAnyCharsAtPositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceAnyCharsAtByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceAnyCharsAtThesePositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		#>

	def CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsByManyQ(panPos, pacNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharsReplacedAtThesePositionsByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def CharsAtThesePositionsReplacedByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		#--

		def AnyCharsReplacedAtPositionsByMany(panPos, pacNewSubStr)
			This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def AnyCharsReplacedAtThesePositionsByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def AnyCharsAtThesePositionsReplacedByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		#>

		#TODO // Add Positions as a misspelling of Positions

	  #--------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#====================================================================#

	#TODO # Add case sensitivty

	def ReplaceCharsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		#< @MotherFunctions:
		#	This.FindCharsW() > @RingBased
		#	This.ReplaceSection() > @QtBased
		#>

		/*
		Example:

		StzStringQ( "Text processing with Ring" ) {

			ReplaceAllCharsW(
				:Where = '{ This[@i] = "i" }',
				:With = "*"
			)

			? Content()
		}

		--> Returns: "Text process*ng w*th R*ng"
		*/

		# Checking the correctness of the pcCondition param
			#--> Not necessary! It will be done by the
			# mother function FindAllCharsW()

		# Checking the correctness of the pcNewSubStr param
			#--> Not necceary! It will be done by the
			# called function ReplaceCharsAtPositions()

		# Doing the job

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.ReplaceCharsAtPositions(anPos, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceCharsWCSQ(pCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceCharsWCS(pCondition, pcNewSubStr, pCaseSensitive)
			return This

		#>

	def CharsReplacedWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceCharsW(pcCondition, pcNewSubStr)
		This.ReplaceCharsWCS(pcCondition, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceCharsWQ(pCondition, pcNewSubStr)
			This.ReplaceCharsW(pCondition, pcNewSubStr)
			return This

		#>

	def CharsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------#

	def ReplaceCharsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.ReplaceCharsAtPositions(anPos, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceCharsWCSXTQ(pCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceCharsWCSXT(pCondition, pcNewSubStr, pCaseSensitive)
			return This

		#>

	def CharsReplacedWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceCharsWXT(pcCondition, pcNewSubStr)
		This.ReplaceCharsWCSXT(pcCondition, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceCharsWXTQ(pCondition, pcNewSubStr)
			This.ReplaceCharsWXT(pCondition, pcNewSubStr)
			return This

		#>

	def CharsReplacedWXT(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsWXTQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #-------------------------------------------------------------------------------#
	 #  REPLACING ALL SUSBSTRINGS OBEYING TO A GIVEN CONDITION BY A GIVEN SUBSTRING  #
	#===============================================================================#

	def ReplaceSubStringsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		def ReplaceSubStringsWCSQ(pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringsReplacedWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringsWCSQ(pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsW(pcCondition, pcNewSubStr)
		This.ReplaceSubStringsCSW(pcCondition, pcNewSubStr, 1)

		def ReplaceSubStringsWQ(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsW(pcCondition, pcNewSubStr)
			return This

	def SubStringsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringsWQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #-----------------------------------------------------------------------------------------------#
	 #  REPLACING ALL SUSBSTRINGS OBEYING TO A GIVEN CONDITION BY A GIVEN SUBSTRING -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------------------#

	def ReplaceSubStringsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		def ReplaceSubStringsWCSXTQ(pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringsReplacedWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringsWCSXTQ(pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsWXT(pcCondition, pcNewSubStr)
		This.ReplaceSubStringsCSWXT(pcCondition, pcNewSubStr, 1)

		def ReplaceSubStringsWXTQ(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsWXT(pcCondition, pcNewSubStr)
			return This

	def SubStringsReplacedWXT(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringsWXTQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #----------------------------------------------------#
	 #     REPLACING THE NTH OCCURRENCE OF A SUBSTRING    #
	#====================================================#

	def ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok
		
			if n = :First
				n = 1
		
			but n = :Last
				n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
		
			ok
		ok

		# Doing the job

		n = This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
	
		if n > 0
			oSubStr = new stzString(pcSubStr)
			This.ReplaceSection( n, n + oSubStr.NumberOfChars()-1, pcNewSubStr)
		ok
	
		#< @FunctionFluentForm
	
		def ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForms

		def ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceNthSubstringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthoccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	def NthOccurrenceReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		def NthSubStringReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.NthOccurrenceReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def ReplaceNth(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)

			def ReplaceNthQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNth(n, pcSubStr, pcNewSubStr)
				return This

		def ReplaceNthSubstring(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthoccurrence(n, pcSubStr, pcNewSubStr)

			def ReplaceNthSubStringQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceNthOccurrenceQ(n, pcSubStr, pcNewSubStr)

		#>

	def NthOccurrenceReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr).Content()

		def NthSubStringReplaced(n, pcSubStr, pcNewSubStr)
			return This.NthOccurrenceReplaced(n, pcSubStr, pcNewSubStr)

	  #-------------------------------------------------#
	 #    REPLACING FIRST OCCURRENCE OF A SUBSTRING    #
	#-------------------------------------------------#

	def ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternative

		def ReplaceFirst(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceFirstQ(pcSubStr, pcNewSubStr)
				This.ReplaceFirst(pcSubStr, pcNewSubStr)
				return This

		#>

	def FirstOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	  #--------------------------------------------------#
	 #     REPLACING LAST OCCURRENCE OF A SUBSTRING     #
	#--------------------------------------------------#

	def ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, 1)

		#< @FunctionFluentForm

		def ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def ReplaceLast(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceLastQ(pcSubStr, pcNewSubStr)
				This.ReplaceLast(pcSubStr, pcNewSubStr)
				return This

		#>

	def LastOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok
	
			if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				if ring_find([ :StartingAt, :StartingAtPosition ], nStart[1]) > 0
					nStart = nStart[2]
	
				but nStart[1] = :StartingAtOccurrence
	
					nStart = This.FindNthOccurrenceCS(nStart[2] + 1, pcSubStr, pCaseSensitive)
				ok
				
			ok
	
			if isString(nStart)
				switch nStart
				on :First or :FirstOccurrence
					nStart = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)
	
				on :FirstPosition or :FirstChar
					nStart = 1
	
				off
			ok
		ok

		# Doing the job

		cPart1 = This.Section(1, nStart - 1)
		nLen = This.NumberOfChars()
		oPart2 = This.SectionQ(nStart, nLen)
		cPart2 = oPart2.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def NextNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, 1)

		def ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

	def NextNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def NextOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, 1)

		def ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	   #--------------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                        #
	#--------------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplacePreviousNthOccurrence(2, :Of = "ring", :StartingAtOccurrence = 3, :By = "♥♥♥")
		
		? o1.Content() #--> ♥♥♥ php ring ruby ring python ring
		*/

		if CheckingParams()
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok
	
			if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				if ring_find([ :StartingAt, :StartingAtPosition ], nStart[1]) > 0
					nStart = nStart[2]
	
				but nStart[1] = :StartingAtOccurrence
	
					nStart = This.FindNthOccurrenceCS(nStart[2], pcSubStr, pCaseSensitive)
				ok
				
			ok
	
			if isString(nStart)
				switch nStart
				on :Last or :LastOccurrence
					nStart = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)
	
				on :LastPosition or :LastChar
					nStart = This.NumberOfChars()
	
				off
			ok
		ok

		# Doing the job

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def PreviousNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, 1)

		def ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

	def PreviousNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def PreviousOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, 1)

		def ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	  #----------------------------------------------------#
	 #  REPLACING THE FIRST N OCCURRENCES OF A SUBSTRING  #
	#----------------------------------------------------#

	def ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(anPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceFirstNOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNFirstOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstNOccurrencesCSQ(n, pcNewSubStr, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
		This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, 1)

		def ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)

			def ReplaceNFirstOccurrencesQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
				return This

	def FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr).Content()

		def NFirstOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
			return This.FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)

	  #--------------------------------------------------#
	 #   REPLACING MANY NTH OCCURRENCES OF A SUBSTRING  #
	#==================================================#
	# Based on a problem posted by Gal in RosettaCode

	def ReplaceManyNthSubStringsCS(paNthSubStrNewSubStr, pCaseSensitive)
		/* EXAMPLE
		Q("abracadabra") {
			ReplaceManyNthSubStrings([
				[ 1, 'a', :with = 'A' ],
				[ 2, 'a', :with = 'B' ],
				[ 4, 'a', :with = 'C' ],
				[ 5, 'a', :with = 'D' ],
			
				[ 1, 'b', :with = 'E' ],
				[ 2, 'r', :with = 'F' ]
			])
			? Content()
			# AErBcadCbFD
		}
		*/

		_nLen_ = len(paNthSubStrNewSubStr)

		if CheckingParams()

			if NOT ( isList(paNthSubStrNewSubStr) and @IsListOfLists(paNthSubStrNewSubStr) )
				StzRaise("Incorrect param type! paNthSubStrNewSubStr must be a list of lists.")
			ok

	
			for @i = 1 to _nLen_
				if NOT len(paNthSubStrNewSubStr[@i]) = 3
					StzRaise("Incorrect param! paNthSubStrNewSubStr must contains lists of 3 items each.")
				ok

				if isList(paNthSubStrNewSubStr[@i][3]) and
				   StzListQ(paNthSubStrNewSubStr[@i][3]).IsWithOrByOrUsingNamedParam()

					paNthSubStrNewSubStr[@i][3] = paNthSubStrNewSubStr[@i][3][2]
				ok

				if NOT ( isNumber(paNthSubStrNewSubStr[@i][1]) and
					 isString(paNthSubStrNewSubStr[@i][2]) and
					 isString(paNthSubStrNewSubStr[@i][3]) )

					StzRaise("Incorrect parameter type! paNthSubStrNewSubStr must contain lists, each consisting of a number and two strings (in this order).")


				ok
			next

		ok

		# Positions should be sorted

		_aSorted_ = @SortLists(paNthSubStrNewSubStr)

		# Doing the job

		for @i = _nLen_ to 1 step -1
			This.ReplaceNthSubStringCS(_aSorted_[@i][1], _aSorted_[@i][2], _aSorted_[@i][3], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceManyNthSubStringsCSQ(paNthSubStrNewSubStr, pCaseSensitive)
			This.ReplaceManyNthSubStringsCS(paNthSubStrNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyNthCS(paNthSubStrNewSubStr, pCaseSensitive)
			This.ReplaceManyNthSubStringsCS(paNthSubStrNewSubStr, pCaseSensitive)

			def ReplaceManyNthQ(paNthSubStrNewSubStr)
				return This.ReplaceManyNthSubStringsCSQ(paNthSubStrNewSubStr, pCaseSensitive)

		#>

	def ManyNthSubStringsReplacedCS(paNthSubStrNewSubStr, pCaseSensitive)
		_cResult_ = This.Copy().ReplaceManyNthSubStringsCSQ(paNthSubStrNewSubStr, pCaseSensitive).Content()
		return _cResult_

		def ManyNthReplacedCS(paNthSubStrNewSubStr, pCaseSensitive)
			return This.ManyNthSubStringsReplacedCS(paNthSubStrNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyNthSubStrings(paNthSubStrNewSubStr)
		This.ReplaceManyNthSubStringsCS(paNthSubStrNewSubStr, 1)

		def ReplaceManyNthSubStringsQ(paNthSubStrNewSubStr)
			return This.ReplaceManyNthSubStringsCSQ(paNthSubStrNewSubStr, 1)

	def ManyNthSubStringsReplaced(paNthSubStrNewSubStr)
		return This.ManyNthSubStringsReplacedCS(paNthSubStrNewSubStr, 1)

		def ManyNthReplaced(paNthSubStrNewSubStr)
			return This.ManyNthSubStringsReplaced(paNthSubStrNewSubStr)

	  #========================#
	 #   REPLACING NTH CHAR   # 
	#========================#

	def ReplaceNthChar(n, pSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = 1 #>

		if n = :LastChar or n = :EndOfString or n = :Last
			n = This.NumberOfChars()

		but n = :FirstChar or n = :StartOfString or n = :First
			n = 1
		ok

		if isList(pSubStr) and
		   len(pSubStr) = 2 and
		   StzListQ(pSubStr).IsPairOfStrings()

			if pSubStr[1] = :With
				pSubStr = pSubStr[2]

			ok
		ok

		This.ReplaceSection(n, n , pSubStr)

		#< @FunctionFluentForm

		def ReplaceNthCharQ(n, pcSubStr)
			This.ReplaceNthChar(n, pcSubStr)
			return This

		#>

	def NthCharReplaced(n, pValue)
		cResult = This.Copy().ReplaceNthCharQ(n, pValue).Content()
		return cResult

	  #-----------------------------------------------#
	 #  REPLACING FIRST CHAR WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def ReplaceFirstChar(pcSubStr)
		This.ReplaceNthChar(1, pcSubStr)

		def ReplaceFirstCharQ(pcSubStr)
			This.ReplaceFirstChar(pcSubStr)
			return This

	def FirstCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #----------------------------------------------#
	 #  REPLACING LAST CHAR WITH A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def ReplaceLastChar(pcSubStr)
		This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)

		def ReplaceLastCharQ(pcSubStr)
			This.ReplaceLastChar(pcSubStr)
			return This

	def LastCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #------------------------------------------------------------#
	 #  REPLACING NTH GIVEN CHAR (IF ANY) WITH A GIVEN SUBSTRING  #
	#------------------------------------------------------------#

	def ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)

		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.ReplaceNthChar(n, pcSubStr)
		ok

		def ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive)
			This.ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)
			return This

	def ThisNthCharReplacedCS(n, cChar, pcSubStr, pCaseSensitive)
		return This.Copy().ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisNthChar(n, cChar, pcSubStr)
		This.ReplaceThisNthCharCS(n, cChar, pcSubStr, 1)

		def ReplaceThisNthCharQ(n, cChar, pcSubStr)
			This.ReplaceThisNthChar(n, cChar, pcSubStr)
			return This

	def ThisNthCharReplaced(n, cChar, pcSubStr)
		return This.Copy().ReplaceThisNthCharQ(n, cChar, pcSubStr).Content()

	  #-----------------------------------------------------------------#
	 #  REPLACING A GIVEN FIRST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#-----------------------------------------------------------------#

	def ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.FirstCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(1, pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisFirstCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisFirstChar(c, pcSubStr)
		This.ReplaceThisFirstCharCSQ(c, pcSubStr, 1)

		def ReplaceThisFirstCharQ(c, pcSubStr)
			This.ReplaceThisFirstChar(c, pcSubStr)
			return This

	def ThisFirstCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisFirstCharQ(c, pcSubStr).Content()

	  #----------------------------------------------------------------#
	 #  REPLACING A GIVEN LAST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#----------------------------------------------------------------#

	def ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.LastCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisLastCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisLastChar(c, pcSubStr)
		This.ReplaceThisLastCharCSQ(c, pcSubStr, 1)

		def ReplaceThisLastCharQ(c, pcSubStr)
			This.ReplaceThisLastChar(c, pcSubStr)
			return This

	def ThisLastCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisLastCharQ(c, pcSubStr).Content()

	  #------------------------------------------------#
	 #    REPLACING ALL CHARS WITH A GIVEN SUBSTRING  # 
	#------------------------------------------------#

	def ReplaceAllChars(pcSubStr)

		if CheckingParam()
			if isList(pcSubStr) and StzListQ(pcSubStr).IsWithOrByNamedParam()
				pcSubStr = pcSubStr[2]
			ok
		ok

		_cResult_ = ""
		_nLen_ = This.NumberOfChars()

		for @i = 1 to _nLen_
			_cResult_ += pcSubStr
		next

		This.UpdateWith( _cResult_ )


		#< @FunctionFluentForm

		def ReplaceAllCharsQ(pcSubStr)
			This.ReplaceAllChars(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceChars(pcSubStr)
			This.ReplaceAllChars(pcSubStr)

			def ReplaceCharsQ(pcSubStr)
				return This.ReplaceAllCharsQ(pcSubStr)
		#>


	def AllCharsReplaced(pcSubStr)
		cResult = This.Copy().ReplaceAllCharsQ(pcSubStr).Content()
		return cResult

		def CharsReplaced(pcSubStr)
			return This.AllCharsReplaced(pcSubStr)

	  #================================#
	 #    INTERPOLATING THE STRING    # 
	#================================#

	def Interpolate()
		/* EXAMPLE

		max = RingMaxIntegerXT()
		min = RingMinIntegerXT()

		? Q("The range of integers is {min} to {max}").Interpolated();
		
		#--> The range of integers is '-999_999_999_999_999' to
		     '999_999_999_999_999'

		NOTE the use of the XT() extension to return the number
		spacified by "_"

		*/

		aSectionsXT = This.SubStringsBoundedByZZ(["{", "}"])
		#--> [ [ "min", [ 27, 29 ] ], [ "max", [ 36, 38 ] ] ]

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
		
			cVar	 = aSectionsXT[i][1]
			cCode	 = 'cValue	 = (' + cVar + ' )'
			eval(cCode)
		
			n1 = aSectionsXT[i][2][1] - 1
			n2 = aSectionsXT[i][2][2] + 1
			
			This.ReplaceSection(n1, n2, cValue)

		next

		#< @FunctionFluentForm

		def InterpolateQ()
			This.Interpolate()
			return This

		#>

		#< @FunctionMisspelledForms

		def Interpoltate()
			return This.Interpolate()

			def InterpoltateQ()
				This.Interpoltate()
				return This

		def Intrepolate()
			return This.Interpolate()

			def IntrepolateQ()
				This.Interpoltate()
				return This
		#>
			
	def Interpolated()
		return This.Copy().InterpolateQ().Content()

		#< @FunctionMisspelledForm

		def Interpoltated()
			return This.Interpolated()

		def Intrepolatef()
			return This.Interpolated()

		#>
		
	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS MARKERS  #
	#===========================================#
	#TODO // Reorganize it with similar functions

	def ContainsMarkers()
		/*
		? StzString('My kids are #1, #2, and #3!').ContainsMarkers() --> 1
		*/

		if This.NumberOfMarkers() > 0
			return 1
		else
			return 0
		ok

	  #=============================================#
	 #    CHECKING IF THE STRING IS A RING CODE    # 
	#=============================================#

	def IsValidRingCode()

		try
			eval(This.Copy().Content())
			return 1
		catch
			return 0
		done

		def IsEvaluableRingCode()
			return This.IsValidRingCode()

		def IsRingCode()
			return This.IsValidRingCode()

	  #------------------------------------------------#
	 #    EXECUTING RING CODE HOSTED IN THE STRING    # 
	#------------------------------------------------#

	def Execute()
		if This.IsValidRingCode()
			eval(This.String())
		ok

		def Run()
			This.Execute()

	def ExecuteAndReturn()
		if This.StartsWithCS("return ",  0)
			eval(This.String())
		else
			cCode = "return " + This.String()
			eval(cCode)
		ok

		def RunAndReturn()
			This.ExecuteAndReturn()

	  #============================#
	 #     CLEARING THE STRING    #
	#============================#

	def Clear()
		This.UpdateWith("")

		#< @FunctionFluentForm

		// Clears the string and return it as a StzObject
		// to take other actions on it
		def ClearQ()
			This.Clear()
			return This

		#>

	  #-----------------------------------------------------------#
	 #  VERIFYING IF THE STRING IS EMPTY ("" IN RING TERMS)  #
	#-----------------------------------------------------------#

	def IsEmpty()
		return This.Content() = ""
		
	  #-----------------------#
	 #  RESIZING THE STRING  #
	#-----------------------#

	def Resize(n)
		cResult = ""

		if n <= NumberOfChars()
			cResult = This.FirstNChars(n)
		else
			cResult = This.ExtendToNChars(n, :Using = " ")
		ok

		This.Update(cResult)
		
		#< @FunctionFluentForm

		def ResizeQ(n)
			This.Resize(n)
			return This
	
		#>

	  #-----------------------------------------------#
	 #  ADDING A SUBSTRING AT THE END OF THE STRING  #
	#-----------------------------------------------#

	def AddSubString(pcSubStr)
		This.UpdateWith( This.Content() + pcSubStr )

	  #------------------------------------------#
	 #  ADDING A CHAR AT THE END OF THE STRING  #
	#------------------------------------------#

	def AddChar(c)
		if isString(c) and StzListQ(c).IsChar()
			This.AddSubString(c)
		else
			stzRaise("Incorrect param type! c must be a char.")
		ok


	#----------------------#
	#  HISTORY MANAGEMENT  #
	#----------------------#

	def AddHistoricValueInternal(value)
		# Add to history without triggering TraceObjectHistory
		# This should directly manipulate the internal history array
		if _aHisto = NULL
			_aHisto = []
		ok
		_aHisto + value

	def AddHistoricValueXTInternal(aHistoryData)
		# Add to extended history without triggering TraceObjectHistory
		# This should directly manipulate the internal history array
		if _aHistoXT = NULL
			_aHistoXT = []
		ok
		_aHistoXT + aHistoryData

	  #-----------------------#
	 #  UPDATING THE STRING  #
	#-----------------------#

	def Update(pcNewStr)
	    #< QtBased | Uses QString.clear() and QString.append() >
	
	    if CheckingParams() = 1
	        if isList(pcNewStr) and StzListQ(pcNewStr).IsWithOrByOrUsingNamedParam()
	            pcNewStr = pcNewStr[2]
	        ok
	    ok
	
	    # Updating the object content
	    QStringObject().clear()
	    QStringObject().append(pcNewStr)
	
	    # Tracing the history of updates (only if not already in history update)
	    if _bInHistoryUpdate = 0
	        @TraceObjectHistory(This)
	    ok

		# Verifying constraints (#TODO)

		//This.VerifyConstraints()



		#< @FunctionFluentForm

		def UpdateQ(pcNewStr)
			This.Update(pcNewStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(pcNewStr)
			This.Update(pcNewStr)

			def UpdateWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def UpdateBy(pcNewStr)
			This.Update(pcNewStr)

			def UpdateByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def UpdateUsing(pcNewStr)
			This.Update(pcNewStr)

			def UpdateUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		#--

		def Fill(pcNewStr)
			This.Update(pcNewStr)

			def FillQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def FillWith(pcNewStr)
			This.Update(pcNewStr)

			def FillWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def FillBy(pcNewStr)
			This.Update(pcNewStr)

			def FillByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def FillUsing(pcNewStr)
			This.Update(pcNewStr)

			def FillUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
		#>

	def Updated(pcNewStr)
		return pcNewStr

		#< @FunctionAlternativeForms

		def UpdatedWith(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedBy(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#--

		def Filled(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledWith(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledBy(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#>

	  #========================================#
	 #     CONTAINING ONLY SPACES & LETTERS   #
	#========================================#
	#TODO // Reorganize it with similar functions


	def ContainsOnlySpaces() #NOTE # this is different from ContainsSpaces()
		
		if This.Trimmed() = ""
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfSpaces()
			return This.ContainsOnlySpaces()

		def IsMadeOfOnlySpaces()
			return This.ContainsOnlySpaces()

		def IsBlank()
			return This.ContainsOnlySpaces()

		#>

	def ContainsOnlyLetters() #NOTE # this is different from ContainsLetters()
		aoChars = This.CharsQ().ToListOfStzChars() #NOTE # this is different from ToStzListOfChars()
		nLen = len(aoChars)

		bResult = 1

		for i = 1 to nLen
			if NOT aoChars[i].IsLetter()
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAlphabetic()
			return This.ContainsOnlyLetters()

		def IsAplhabetical()
			return This.ContainsOnlyLetters()

		def IsAlpha()
			return This.ContainsOnlyLetters()

		def IsMadeOfOnlyLetters()
			return This.ContainsOnlyLetters()

		def IsMadeOfLetters()
			return This.ContainsOnlyLetters()

		def AllCharsAreLetters()
			return This.ContainsOnlyLetters()

		#>

	def ContainsLettersAndNumbers()
		if This.ContainsLetters() or This.ContainsNumbers()
			return 1
		else
			return 0
		ok

		def ContainsNumbersAndLetters()
			return This.ContainsLettersAndNumbers() 

		def IsMadeOfNumbersAndLetters()
			return This.ContainsLettersAndNumbers() 

		def IsMadeOfLettersAndNumbers()
			return This.ContainsLettersAndNumbers() 

	def ContainsOnlyLettersOrNumbers()
		if This.ContainsOnlyLetters() or This.ContainsOnlyNumbers()
			return 1
		else
			return 0
		ok

		def ContainsOnlyNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

		def IsMadeOfOnlyNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

		def IsMadeOfNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

	def ContainsOnlyLettersAndNumbers()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)

		bResult = 1

		for i = 1 to nLen
			if NOT aoChars[i].IsLetterOrNumber()
				bResult = 0
				exit
			ok
		next

		return bResult

		#<@ FunctionAlternativeForms

		def ContainsOnlyNumbersAndLetters()
			return This.ContainsOnlyLettersAndNumbers()

		def IsMadeOfOnlyLettersAndNumbers()
			return This.ContainsOnlyLettersAndNumbers()

		def IsMadeOfOnlyNumbersAndLetters()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNum()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNumerical()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNumeric()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlNum()
			return This.ContainsOnlyLettersAndNumbers()

		#>

	  #=========================================================#
	 #  CHEHCKING IF THE STRING STARTS WITH A GIVEN SUBSTRING  #
	#=========================================================#

	def StartsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.startsWith() >

		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param! pcSubStr must be a string.")
			ok
		ok

		# Early check

		if pcSubstr = ""
			return 0
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		_bResult_ = This.QStringObject().startsWith(pcSubStr, _bCase_)

		return _bResult_

		#< @FunctionFluentForm

		def StartsWithCSQ(pcSubStr, pCaseSensitive)

			if This.StartsWithCS(pcSubStr, pCaseSensitive) = 1
				return This
			else
				return AFalseObject()
			ok
		#>

		#< @FunctionAlternativeForm

		def BeginsWithCS(pcSubStr, pCaseSensitive)
			return This.StartsWithCS(pcSubStr, pCaseSensitive)

			def BeginsWithCSQ(pcSubStr, pCaseSensitive)
				return This.StartsWithCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(pcSubStr)
		return This.StartsWithCS(pcSubStr, 1)

		def StartsWithQ(pcSubStr)
			return This.StartsWithCS(pcSubStr, 1)

		def BeginsWith(pcSubStr)
			return This.StartsWith(pcSubStr)

			def BeginsWithQ(pcSubStr)
				return This.StartsWithQ(pcSubStr)

	  #---------------------------------------------------------------#
	 #  CHEHCKING IF THE STRING STARTS WITH A GIVEN SUBSTRING -- XT  #
	#---------------------------------------------------------------#
	# ~> Enables the param to be a list of chars not a substring

	def StartsWithCSXT(pacSubStr, pCaseSensitive)

		if CheckParams()

			if isString( pacSubStr )
				return This.StartsWithCS(pacSubStr, pCaseSensitive)
			ok

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		# Doing the job

		_bResult_ = This.StartsWithCS( @Concat(pacSubStr), pCaseSensitive)
		return _bResult_

		#< @FunctionFluentForm

		def StartsWithCSXTQ(pacSubStr, pCaseSensitive)
			if This.StartsWithCSXT(pacSubStr, pCaseSensitive) = 1
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForm

		def BeginsWithCSXT(pacSubStr, pCaseSensitive)
			return This.StartsWithCSXT(pcSubStr, pCaseSensitive)

			def BeginsWithCSXTQ(pacSubStr, pCaseSensitive)
				return This.StartsWithCSXTQ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def StartsWithXT(pacSubStr)
		return This.StartsWithCSXT(pacSubStr, 1)

		def StartsWithXTQ(pacSubStr)
			return This.StartsWithCSXTQ(pacSubStr, 1)

		def BeginsWithXT(pacSubStr)
			return This.StartsWithXT(pacSubStr)

			def BeginsXTQ(pacSubStr)
				return This.StartsWithXTQ(pacSubStr)

	  #----------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def BeginsWithOneOfTheseCS(pacSubStr, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(pacSubStr) and @IsListofSubStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		_nLen_ = len(pacSubStr)
		_bResult_ = 0

		for @i = 1 to _nLen_
			if This.BeginsWithCS(pacSubStr[i], pCaseSensitive)
				_bResult_ = 1
				exit
			ok
		next

		return _bResult_

		def StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def StartsWithAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def StartsWithAnyCS(paSubStr, pCaseSensitive)
			return This.StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESNESITIVITY

	def BeginsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, 1)

		def StartsWithOneOfThese(paSubStr)
			return This.BeginsWithOneOfThese(paSubStr)

		def StartsWithAnyOfThese(paSubStr)
			return This.StartsWithOneOfThese(paSubStr)

		def StartsWithAny(paSubStr)
			return This.StartsWithOneOfThese(paSubStr)

	  #--------------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#--------------------------------------------------------------------#

	def StartsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and StzListQ(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		if NOT @BothAreStrings(pSubStr1, pSubStr2)
			stzRaise("Incorrect params types! Both pSubStr1 and pSubStr2 must be strings.")
		ok

		return This.StartsWithOneOfTheseCS([pSubStr1, pSubStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWithEither(pSubStr1, pSubStr2)
		return This.StartsWithEitherCS(pSubStr1, pSubStr2, 1)

	  #----------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH A GIVEN GIVEN SUBSTRING  #
	#==========================================================#

	def EndsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses oQString.endsWith() >

		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param! pcSubStr must be a string.")
			ok
		ok

		# Early check

		if pcSubstr = ""
			return 0
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		_bResult_ = This.QStringObject().endsWith(pcSubStr, _bCase_)
		return _bResult_


		#< @FunctionFluentForm

		def EndsWithCSQ(pcSubStr, pCaseSensitive)
			if This.EndsWithCS(pcSubStr, pCaseSensitive) = 1
				return This
			else
				return AFalseObject()
			ok
		#>

		#< @FunctionAlternativeForm

		def FinishesWithCS(pcSubStr, pCaseSensitive)
			return This.EndsWithCS(pcSubStr, pCaseSensitive)

			def FinishesWithCSQ(pcSubStr, pCaseSensitive)
				return This.EndsWithCSQ(pcSubStr, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(pcSubStr)
		return QStringObject().endsWith(pcSubStr, 0)

		def EndsWithQ(pcSubStr)
			return  This.EndsWithCSQ(pcSubStr, 1)

		def FinishesWith(pcSubStr)
			return This.EndsWith()

			def FinishesWithQ(pcSubStr)
				return This.EndsWithQ(pcSubStr)

	  #-------------------------------------------------------------#
	 #  CHEHCKING IF THE STRING ENDS WITH A GIVEN SUBSTRING -- XT  #
	#-------------------------------------------------------------#
	# ~> Enables the param to be a list of chars not a substring

	def EndsWithCSXT(pacSubStr, pCaseSensitive)

		if CheckParams()

			if isString( pacSubStr )
				return This.StartsWithCS(pacSubStr, pCaseSensitive)
			ok

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		# Doing the job

		_bResult_ = This.EndsWithCS( @Concat(pacSubStr), pCaseSensitive)
		return _bResult_

		def EndsWithCSXTQ(pacSubStr, pCaseSensitive)
			if This.EndsWithCSXT(pcSubStr, pCaseSensitive) = 1
				return This
			else
				return AFalseObject()
			ok

		def FinishesWithCSXT(pacSubStr, pCaseSensitive)
			return This.EndsWithCSXT(pcSubStr, pCaseSensitive)

			def FinishesWithCSXTQ(pacSubStr, pCaseSensitive)
				return This.EndsWithCSXTQ(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWithXT(pacSubStr)
		return This.EndsWithCSXT(pacSubStr, 1)

		def EndsWithXTQ(pacSubStr)
			return This.EndsWithCSXTQ(pacSubStr, 1)

		def FinishesWithXT(pacSubStr)
			return This.EndsWithXT(pacSubStr)

			def FinishesWithXTQ(pacSubStr)
				return This.EndsWithXTQ(pacSubStr)

	  #--------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------#

	def EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = 0

		for cSubStr in paSubStr
			if This.EndsWithCS(cSubStr, pCaseSensitive)
				bResult = 1
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def EndsWithAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def EndsWithAnyCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def FinishsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def FinishsWithAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		def FinishesWithAnyCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def EndsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, 1)

		#< @FunctionAlternativeForms

		def EndsWithAnyOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

		def EndsWithAny(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

		def FinishsWithOneOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

		def FinishsWithAnyOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

		def FinishesWithAny(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#------------------------------------------------------------------#

	def EndsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and StzListQ(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		return This.EndsWithOneOfTheseCS([ pSubStr1, pSubStr2], pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def EndsWithEither(pSubStr1, pSubStr2)
		return This.EndsWithEitherCS(pSubStr1, pSubStr2, 1)

	  #====================================================#
	 #  GETTING THE SUBSTRING OCCURRENCE BY ITS POSITION  #
	#====================================================#

	def SubStringOccurrenceByPositionCS(nPos, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.SubStringOccurrenceByPosition(9, "ring") #--> 2
		*/

		nResult = 0

		anPos = This.FindSubStringCS(pcSubStr, pCaseSensitive)
		i = 0
		for n in anPos
			i++
			if n = nPos
				nResult = i
				exit
			ok
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringOccurrenceByPosition(nPos, pcSubStr)
		return This.SubStringOccurrenceByPositionCS(nPos, pcSubStr, 1)

	  #=============================================#
	 #   FINDING THE NTH OCCURRENCE OF SUBSTRING   #
	#=============================================#

	def FindNthCS(n, pcSubstr, pCaseSensitive) #--> Returns 0 if nothing found

		# Resolving the pcSubStr param

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be as a string.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and StzListQ(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (1 or 0).")
		ok

		# Early-checking for better performance (in case of!)

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		# Resolving the n param

		if isString(n)
			cNLowercased = Q(n).Lowercased()
			if cNLowercased = :First or cNLowercased = :FirstOccurrence
				n = 1

			but cNLowercased = :Last or cNLowercased = :LastOccurrence
				n = This.NumberOfOccurrenceCs(pcSubStr, pCaseSensitive)

			else
				n = 0
			ok
		ok

		# Doing the job

		nResult = 0

		nPos = 1
		for i = 1 to n

			nResult = This.QStringObject().indexOf(pcSubStr, nPos - 1, pCaseSensitive) + 1

			if nResult = 0
				exit
			ok

			nPos = nResult + 1
		next

		return nResult

		#< @FunctionAlternativeForm

		def FindNthCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)

		def FindNthSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)

		def FindNthSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)
 
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNth(n, pcSubstr)
		return This.FindNthCS(n, pcSubstr, 1)

		#< @FunctionAlternativeForm

		def FindNthZ(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		def FindNthSubString(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		def FindNthSubStringZ(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		#>

	  #===============================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING AND RETURNING THE POSITION AS SECTION  #
	#===============================================================================#

	def FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)

		anResult = [ nPos, (nPos + Q(pcSubStr).NumberOfChars() - 1) ]
		return anResult

		#< @FunctionAlternativeForms

		def FindNthOccurrenceOfSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceOfSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSection(n, pcSubStr)
		return This.FindNthAsSectionCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthOccurrenceOfSubStringAsSection(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceAsSection(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		#--

		def FindNthZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceOfSubStringZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindFirstOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindFirstCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSection(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSection(pcSubStr)
		return This.FindFirstAsSectionCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindFirstOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#--

		def FindFirstZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceOfSubStringZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#--

		def FindAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindLastOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFLastOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def FindLasteAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSection(pcSubStr)
		return This.FindLastAsSectionCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindFLastOccurrenceAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#--

		def FindLastZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindLastOccurrenceOfSubStringZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindLastOccurrenceZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

		#< @FunctionMisspelledForm

		def FindLasteAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

	  #============================================#
	 #  FINDING THE ANTI-SECTIONS OF A SUBSTRING  #
	#============================================#

	def AntiFindCSZZ(pcSubStr, pCaseSensitive)
		# Works both for one string or many

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSections( This.FindCSZZ(pcSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		#--

		def AntiFindSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		def AntiFindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindZZ(pcSubStr)
		return This.AntiFindAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindAsSections(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		#--

		def AntiFindSubStringZZ(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		def AntiFindSubStringAsSections(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  FINDING THE ONLY ANTI-SECTION (IF ANY) OF A SUBSTRING  #
	#---------------------------------------------------------#
	# @SpecialForm of AntiFindAsSections (without s at the end)

	def AntiFindAsSectionCS(pcSubStr, pCaseSensitive)
		aSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult = []
		if len(aSections) > 0
			aResult = aSections[1]
		ok

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.AntiFindAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSection(pcSubStr)
		return This.AntiFindAsSectionCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSection(pcSubStr)
			return This.AntiFindAsSection(pcSubStr)

		#>

	  #------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS  #
	#================================================#

	def AntiFindManyCS(pacSubStr, pCaseSensitive)

		aSections = This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)
		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			anResult + aSections[i][1]
		next

		return anResult

		#< @FunctionAlternativeForms

		def AntiFindManyCSZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindMany(pcSubStr)
		return This.AntiFindManyCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindManyZ(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		#--

		def AntiFindManySubStrings(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		def AntiFindManySubStringsZ(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS -- ZZ/EXTENDED  #
	#---------------------------------------------------------------#

	def AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSections( This.FindManyCSZZ(pacSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindManyAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#==

		def AntiFindTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		def AntiFindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindManyZZ(pcSubStr)
		return This.AntiFindManyAsSectionsCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindManyAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#--

		def AntiFindManySubStringsZZ(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		def AntiFindManySubStringsAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#==

		def AntiFindTheseSubStringsZZ(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		def AntiFindTheseSubStringsAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#>

	  #-------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF A SUBSTRING -- IB #
	#=================================================#

	def AntiFindCSIBZZ(pcSubStr, pCaseSensitive)
		# Works both for one string or many

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSectionsIB( This.FindCSZZ(pcSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindAsSectionsCSIB(pcSubStr, pCaseSensitive)
			return This.AntiFindCSIBZZ(pcSubStr, pCaseSensitive)

		#--

		def AntiFindSubStringCSIBZZ(pcSubStr, pCaseSensitive)
			return This.AntiFindCSIBZZ(pcSubStr, pCaseSensitive)

		def AntiFindSubStringAsSectionsCSIB(pcSubStr, pCaseSensitive)
			return This.AntiFindCSIBZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindIBZZ(pcSubStr)
		return This.AntiFindAsSectionsCSIB(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindAsSectionsIB(pcSubStr)
			return This.AntiFindIBZZ(pcSubStr)

		#--

		def AntiFindSubStringIBZZ(pcSubStr)
			return This.AntiFindIBZZ(pcSubStr)

		def AntiFindSubStringAsSectionsIB(pcSubStr)
			return This.AntiFindIBZZ(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE ONLY ANTI-SECTION (IF ANY) OF A SUBSTRING -- IB  #
	#---------------------------------------------------------------#
	# @SpecialForm of AntiFindAsSections (without s at the end)

	def AntiFindAsSectionCSIB(pcSubStr, pCaseSensitive)
		aSections = This.AntiFindAsSectionsCSIB(pcSubStr, pCaseSensitive)

		aResult = []
		if len(aSections) > 0
			aResult = aSections[1]
		ok

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSectionCSIB(pcSubStr, pCaseSensitive)
			return This.AntiFindAsSectionCSIB(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSectionIB(pcSubStr)
		return This.AntiFindAsSectionCSIB(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSectionIB(pcSubStr)
			return This.AntiFindAsSectionIB(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS -- IB  #
	#======================================================#

	def AntiFindManyCSIB(pacSubStr, pCaseSensitive)

		aSections = This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)
		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			anResult + aSections[i][1]
		next

		return anResult

		#< @FunctionAlternativeForms

		def AntiFindManyCSIBZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIB(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCSIB(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIB(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsCSIBZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIB(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindManyIB(pcSubStr)
		return This.AntiFindManyCSIB(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindManyIBZ(pacSubStr)
			return This.AntiFindManyIB(pacSubStr)

		#--

		def AntiFindManySubStringsIB(pacSubStr)
			return This.AntiFindManyIB(pacSubStr)

		def AntiFindManySubStringsIBZ(pacSubStr)
			return This.AntiFindManyIB(pacSubStr)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS -- IBZZ/EXTENDED  #
	#-----------------------------------------------------------------#

	def AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSections( This.FindManyCSIBZZ(pacSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindManyAsSectionsCSIB(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCSIBZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsAsSectionsCSIB(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		#==

		def AntiFindTheseSubStringsCSIBZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		def AntiFindTheseSubStringsAsSectionsCSIB(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSIBZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindManyIBZZ(pcSubStr)
		return This.AntiFindManyAsSectionsCSIB(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def AntiFindManyAsSectionsIB(pacSubStr)
			return This.AntiFindManyZZIB(pacSubStr)

		#--

		def AntiFindManySubStringsZZIB(pacSubStr)
			return This.AntiFindManyZZIB(pacSubStr)

		def AntiFindManySubStringsAsSectionsIB(pacSubStr)
			return This.AntiFindManyZZIB(pacSubStr)

		#==

		def AntiFindTheseSubStringsZZIB(pacSubStr)
			return This.AntiFindManyZZIB(pacSubStr)

		def AntiFindTheseSubStringsAsSectionsIB(pacSubStr)
			return This.AntiFindManyZZIB(pacSubStr)

		#>

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- D/Extented  #
	#===================================================#

	def FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		# Checking prams

		if isString(n)
			if n = :Default or n = :First or n = :FirstOccurrence
				n = 1

			but n = :Last or n = :LastOccurrence
				n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 ring_find([ :Default, :Forward, :Backward ], pcDirection) > 0 )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Default, :Forward, and :Backward.")
		ok

		# Doing the job

		nPos = This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSubStringDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		def FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		def FindNthSubStringAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthDZZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZZ(n, pcSubStr, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindNthSubStringDZZ(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		def FindNthAsSectionD(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		def FindNthSubStringAsSectionD(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		#>

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- D/Extented  #
	#-----------------------------------------------------#

	def FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(1, pcSubStr, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstSubStringAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZZ(pcSubStr, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringDZZ(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		def FindFirstAsSectionD(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		def FindFirstSubStringAsSectionD(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- D/Extented  #
	#----------------------------------------------------#

	def FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindLastAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindLastSubStringAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastDZZ(pcSubStr, pcDirection)
		return This.FindLastDCSZZ(pcSubStr, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringDZZ(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		def FindLastAsSectionD(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		def FindLastSubStringAsSectionD(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		#>

	  #====================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- SD/Extented  #
	#====================================================#

	def FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		nPos = FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindNthSubStringSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthSubStringAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindNthSubStringSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def FindNthAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def FindNthSubStringAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		#>

	  #------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- SD/Extented  #
	#------------------------------------------------------#

	def FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCSZZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSubStringAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindFirstAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindFirstSubStringAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #-----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- SD/Extented  #
	#-----------------------------------------------------#

	def FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if pcDirection = :backward
			aResult = This.SectionQ(1, pnStartingAt).FindFirstCSZZ(pcSubStr, pCaseSensitive)
			return aResult

		else // forward
			nLast = This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			aResult = This.FindNthSTCSZZ(nLast, pcSubStr, pnStartingAt, pCaseSensitive)
			return aResult

		ok


		#< @FunctionAlternativeForms

		def FindLastSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSubStringAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindLastAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindLastSubStringAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- S/Extented  #
	#===================================================#

	def FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSubStringAsSectionSTCS(n, pcSubStr, pnSatrtingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindNthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindNthSubStringSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionST(n, pcSubStr, pnStartingAt)
		return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindNthSubStringAsSectionST(n, pcSubStr, pnSatrtingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		def FindNthSTZZ(n, pcSubStr, pnStartingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		def FindNthSubStringSTZZ(n, pcSubStr, pnStartingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		#>

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- S/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSTCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionST(pcSubStr, pnStartingAt)
		return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindFirstSubStringAsSectionST(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		def FindFirstSTZZ(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		def FindFirstSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		#>

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- S/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSTCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
 			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionST(pcSubStr, pnStartingAt)
		return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindLastSubStringAsSectionST(pcSubStr, pnStartingAt)
 			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		def FindLastSTZZ(pcSubStr, pnStartingAt)
			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		def FindLastSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		#>

	  #=======================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#=======================================================#

	def NthCSZ(n, pcSubStr, pCaseSensitive)
		anPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.NthCSZ(n, pcSubStr, pCaseSensitive)

		def NthSubStringAndItsPositionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthZ(n, pcSubStr)
		return This.NthCSZ(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def NthSubStringZ(n, pcSubStr)
			return This.NthZ(n, pcSubStr)

		def NthSubStringAndItsPosition(n, pcSubStr)
			return This.NthZ(n, pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#--------------------------------------------------------#

	def NthCSZZ(n, pcSubStr, pCaseSensitive)
		aSection = This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		def NthAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		def NthSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthZZ(n, pcSubStr)
		return This.FindNthCSZZ(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def NthSubStringZZ(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		def NthAsSection(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		def NthSubStringAsSection(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		#>

	  #=======================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION   #
	#=======================================================================#

	def FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("12♥45♥78♥")
		? o1.FindNthST(2, "♥", :StartingAt = 3)
		#--> 6

		*/

		return This.FindNthSTDCS(n, pcSubStr, pnstartingAt, :Forward, pCaseSensitive)

		def FindNthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthST(n, pcsubStr, pnStartingAt)
		return This.FindNthSTCS(n, pcSubStr, pnStartingAt, 1)

		def FindNthSTZ(n, pcsubStr, pnStartingAt)
			return This.FindNthST(n, pcsubStr, pnStartingAt)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def FindFirstSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)
		
		# Doing the job
		
		_nResult_ = This.QStringObject().indexOf(pcSubStr, pnStartingAt - 1, _bCase_) + 1
		return _nResult_


		def FindFirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstST(pcSubStr, pnStartingAt)
		return This.FindFirstSTCS(pcSubStr, pnStartingAt, 1)

		def FindFirstSTZ(pcSubStr, pnStartingAt)
			return This.FindFirstST(pcSubStr, pnStartingAt)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------#

	def FindLastSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSTCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastST(pcSubStr, pnStartingAt)
		return This.FindLastSTCS(pcSubStr, pnStartingAt, 1)

		def FindLastSTZ(pcSubStr, pnStartingAt)
			return This.FindLastST(pcSubStr, pnStartingAt)

	   #==========================================================================#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                           #
	#==========================================================================#

	def FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
	
			if isList(pcDirection) and
			   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and
				 ring_find([ :Forward, :Default, :Backward ], pcDirection) > 0)
	
				StzRaise("Incorrect param! pcDirection must be a string. " + NL +
					 "Allowed values are :Forward, :Backward, and :Default.")
	
			ok
	
			if NOT ( isString(pcDirection) and
				 (pcDirection = :Forward Or pcDirection = :Backward) )
	
				StzRaise("Incorrect param! pcDirection must be a string. Allowed values are :Forward and :Backward.")
	
			ok

			if isString(n)
	
				if NOT ( isNumber(n) or
					 isString(n) and ring_find([
						:First, :FirstOccurrence, :Last, :LastOccurrence ], n) > 0 )
	
					StzRaise("Incorrect param! n must be a number or one of these " +
						 "two strings (:First or :Last).")
				ok
	
				if pcDirection = :Forward or pcDirection = :Default
	
					if n = :First or n = :FirstOccurrence
						n = 1
		
					but n = :Last or n = :LastOccurrence
						nLen = This.NumberOfChars()
						n = This.SectionQ(pnStartingAt, nLen).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
					ok
	
				else // Backward
	
					if n = :First or n = :FirstOccurrence
						nLen = This.NumberOfChars()
						n = This.SectionQ(pnStartingAt, nLen).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
		
					but n = :Last or n = :LastOccurrence
						n = This.SectionQ(1, pnStartingAt).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
					ok		
	
				ok
		
		
			ok

		ok

		# doing the job

		nResult = 0

		if pcDirection = :Forward
			nLen = This.NumberOfChars()
			nPos  = This.SectionQ(pnStartingAt, nLen).
				FindNthCS(n, pcSubStr, pCaseSensitive)

			if nPos > 0
				nResult = nPos + pnStartingAt - 1
			ok

		else // :Backward

			nResult  = This.FindNthPreviousCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		ok

		return nResult


		def FindNthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSTD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, 1)

		def FindNthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTD(n, pcSubStr, pnStartingAt, pcDirection)

	   #----------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                             #
	#----------------------------------------------------------------------------#

	def FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, 1)

		def FindFirstSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTD(pcSubStr, pnStartingAt, pcDirection)

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                            #
	#---------------------------------------------------------------------------#

	def FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, 1)

		def FindLastSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTD(pcSubStr, pnStartingAt, pcDirection)

	  #===================================================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#===================================================================================#

	def NthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("12♥45♥78♥")
		? o1.NthSZ(2, "♥", :StartingAt = 3)
		#--> [ "♥", 6 ]
		*/

		aResult = [ pcSubStr, This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult

		def NthSubStringSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSTZ(n, pcsubStr, pnStartingAt)
		return This.NthSTCSZ(n, pcSubStr, pnStartingAt, 1)

		def NthSubStringSTZ(n, pcSubStr, pnStartingAt)
			return This.NthSTZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstSTZ(pcSubStr, pnStartingAt)
		return This.FirstSTCSZ(pcSubStr, pnStartingAt, 1)

		def FirstSubstringSTZ(pcSubStr, pnStartingAt)
			return This.FirstSTZ(pcSubStr, pnStartingAt)

	  #------------------------------------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#------------------------------------------------------------------------------------#

	def LastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZ(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastSubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.LastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTZ(pcSubStr, pnStartingAt)
		return This.LastSTCSZ(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def LastSubStringSTZ(pcSubStr, pnStartingAt)
			return This.LastSTCSZ(pcSubStr, pnStartingAt)

		#>

	  #=====================================================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ًZZ/EXTENDED  #
	#=====================================================================================#

	def NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()
		aSection = [ nPos, nPos + nLen - 1 ]

		aResult = [ pcSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthAsSectionSTCS(n, pcSubStr, pnSartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSubStringAsSectionSTCS(n, pcSubStr, pnSartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthSTZZ(n, pcsubStr, pnStartingAt)
		return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def NthSubStringSTZZ(n, pcSubStr, pnStartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		def NthAsSectionST(n, pcSubStr, pnSartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		def NthSubStringAsSectionST(n, pcSubStr, pnSartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#--------------------------------------------------------------------------------------#

	def FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FirstSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSubStringAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstSTZZ(pcSubStr, pnStartingAt)
		return This.FirstSTCSZZ(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FirstSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		def FirstAsSectionST(pcSubStr, pnSartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		def FirstSubStringAsSectionST(pcSubStr, pnSartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZZ(nLast, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def LastSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSubStringAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTZZ(pcSubStr, pnStartingAt)
		return This.LastSTCSZZ(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def LastSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		def LastAsSectionST(pcSubStr, pnSartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		def LastSubStringAsSectionST(pcSubStr, pnSartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		#>

	    #===========================================================================#
	   #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #
	#===========================================================================#

	def NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		
		aResult = [ pcSubStr, This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def NthSubStringSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, 1)

		def NthSubStringSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION                                                     #                           #
	#------------------------------------------------------------------------------#

	def FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.NthSTDCSZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSubstringSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, 1)

		def FirstSubStringSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZ(pcSubStr, pnStartingAt, pcDirection)

	    #---------------------------------------------------------------------------#
	   #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #                          #
	#---------------------------------------------------------------------------#

	def LastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSTCS(pcsubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTDCSZ(nLast, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringSTDCZ(pcSubStr, pnSartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZ(pcSubstr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.LastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, 1)

		def LastSubStringSTD(pcSubStr, pnSartingAt, pcDirection)
			return This.LastSTDZ(pcSubstr, pnStartingAt, pcDirection)

	    #===========================================================================#
	   #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                     #
	#===========================================================================#

	def NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n1 = This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n2 = n1 + Q(pcSubStr).NumberOfChars() - 1
		aResult = [ pcSubStr, [n1, n2] ]
		return aResult

		#< @FunctionAlternativeFrom

		def NthAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSubStringSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSubStringAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
 
		#>

	#-- WITHOUT CASESENSITIVITY

	def NthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeFrom

		def NthAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def NthSubStringSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def NthSubStringAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt, pcDirection)
 
		#>
	    #------------------------------------------------------------------------------#
	   #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                        #                           #
	#------------------------------------------------------------------------------#

	def FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.NthSTDCSZZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FirstSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSubStringAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)


		def FirstSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FirstAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FirstSubStringAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	    #----------------------------------------------------------------------------#
	   #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING  #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                      #                          #
	#----------------------------------------------------------------------------#

	def LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTDCSZZ(nLast, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def LastAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForms

		def LastAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def LastSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def LastSubStringAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- EXTENDED   #
	#======================================================#

	def FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		
		? o1.FindNthXT(2, "word", :Between = ["<<", ">>"])
		#--> 43
		
		? o1.FindNthCSXT(2, "WORD", :Between = ["<<", ">>"],  0)
		#--> 43

		? o1.FindNthXT(2, "word", :StartingAt = 5)
		#--> 43

		? o1.FindNthXT(2, "word", [ :Going = :Backward, :StartingAt = 48 ])
		#--> 11

		*/
	
		# Enabling the syntax :BoundedBy = "*"

		if NOT ( isList(paOption) and StzListQ(paOption).IsPair() and isString(paOption[1]))
			StzRaise("Incorrect param type! paOption must ne a pair starting with a string.")
		ok

		oOption = Q(paOption)

		if oOption.IsBoundedByNamedParam()
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, paOption[2], pCaseSensitive)

		but oOption.IsBoundedByIBNamedParam()
			return This.FindNthSubStringBoundedByCSIB(n, pcSubStr, paOption[2], pCaseSensitive)

		# CASE 2: ? o1.NthXT(2, "word", :Between = ["<<",">>"])
		but oOption.IsBetweenNamedParam()
			return This.FindNthSubStringBetweenCS(n, pcSubStr, paOption[1], paOption[2], pCaseSensitive)

		but oOption.IsBetweenIBNamedParam()
			return This.FindNthSubStringBetweenCSIB(n, pcSubStr, paOption[1], paOption[2], pCaseSensitive)

		# CASE 3: ? o1.FindNthXT(2, "word", :StartingAt = 5)
		but oOption.IsStartingAtNamedParam()
			return This.FindNthSubStringSCS(n, pcSubStr, paOption[2], pCaseSensitive)

		# Case 4: ? o1.FindNthXT(2, "word"; :GoingFrom = :Backward)
		but oOption.IsGoingFromNamedParam()
			return This.FindNthSubStringDCS(n, pcSubStr, paOption[2], pCaseSensitive)

		else
			stzRaise("Incorrect format!")
		ok

		#< @FunctionAlternativeForms

		def FindNthCSXTZ(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		def FindNthSubstringCSXT(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		def FindNthSubstringCSXTZ(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindNthXT(n, pcSubStr, paOption)
		return This.FindNthCSXT(n, pcSubStr, paOption, 1)

		#< @FunctionAlternativeForms

		def FindNthXTZ(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		def FindNthSubstringXT(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		def FindNthSubstringXTZ(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		#>

	  #-------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#-------------------------------------------------------#

	def FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.FindNthCSXT(1, pcSubStr, paOption, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindFirstSubStringCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindFirstSubStringCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstXT(pcSubStr, paOption)
		return This.FindFirstCSXT(pcSubStr, paOption, 1)

		#< @FunctionAlternativeForms

		def FindFirstXTZ(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		def FindFirstSubStringXT(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		def FindFirstSubStringXTZ(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		#>

	  #------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#------------------------------------------------------#

	def FindLastCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.FindNthCSXT(:Last, pcSubStr, paOption, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindLastSubStringCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindLastSubStringCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastXT(pcSubStr, paOption)
		return This.FindLastCSXT(pcSubStr, paOption, 1)

		#< @FunctionAlternativeForms

		def FindLastXTZ(pcSubStr, paOption)
			return This.FindLastXT(pcSubStr, paOption)

		def FindLastSubStringXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastXT(pcSubStr, paOption)

		def FindLastSubStringXTZ(pcSubStr, paOption)
			return This.FindLastXT(pcSubStr, paOption)

		#>

	  #============================================#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING   #
	#============================================#

	// Returns the position of the 1st occurrence of the substring inside the string
	// or returns 0 if nothing is found

	def FindFirstCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		# Early check

		if pcSubStr = ""
			return 0
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job (using Qt)

		nResult = This.QStringObject().indexOf(pcSubStr, 0, _bCase_) + 1

		#NOTE // If nothing is found, Qt returns -1. With the addition of +1, we get 0.

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.FindFirstCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def FirstPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--


		def PositionOfFristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFristCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def FristSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirst(pcSubstr)
		return This.FindFirstCS(pcSubstr, 1)
	
		#< @FunctionAlternativeForms

		def FindFirstQ(pcSubStr)
			return new stzNumber( This.FindFirst(pcSubStr) )

		#>

		#< @FunctionAlternativeForms
	
		def FindFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def First(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def FirstPosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirst(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)
	
		#>

		#< @FunctionMisspelledForms

		def FindFrist(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def PositionOfFristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFrist(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def Frist(pcSubStr)
			return This.FindFirst(pcSubStr)

		#>
		
	  #---------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#---------------------------------------------------------#

	def FirstCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def FirstSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstZ(pcSubStr)
		return This.FindFirstCSZ(pcSubStr, 1)

		def FirstSubstringZ(pcSubStr)
			return This.FirstZ(pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#

	def FirstCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def FirstOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FirstAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstZZ(pcSubStr)
		return This.FindFirstCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FirstOccurrenceZZ(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceOfSubStringZZ(pcSubStr)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FirstAsSection(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceAsSection(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#>

	  #-------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#-------------------------------------------------------#
	#TODO // Add other alternatives

	def FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 ring_find([ :Default, :Forward, :Backward ], pcDirection) > 0)

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		nStart = 1
		if pcDirection = :Backward
			nStart = This.NumberOfChars()
		ok
			
		nResult = FindNthSTDCS(n, pcSubStr, nStart, pcDirection, pCaseSensitive)
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNthD(n, pcSubStr, pcDirection)
		return This.FindNthDCS(n, pcSubStr, pcDirection, 1)

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#---------------------------------------------------------#
	#TODO // Add other alternatives

	def FindFirstDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(1, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstD(pcSubStr, pcDirection)
		return This.FindFirstDCS(pcSubStr, pcDirection, 1)

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#--------------------------------------------------------#
	#TODO // Add other alternatives

	def FindLastDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(:Last, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastD(pcSubStr, pcDirection)
		return This.FindLastDCS(pcSubStr, pcDirection, 1)

	  #--------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#--------------------------------------------------------#
	#TODO // Add other alternatives

	def NthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthDZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZ(n, pcSubStr, pcDirection, 1)

	  #----------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#----------------------------------------------------------#
	#TODO // Add other alternatives

	def FirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZ(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstDZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZ(pcSubStr, pcDirection, 1)

		#< @FunctionMisspelledForm

		def FistDZ(n, pcSubStr, pcDirection)
			return This.FirstDZ(n, pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#---------------------------------------------------------#
	#TODO // Add other alternatives

	def LastDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.NthDCSZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastDZ(pcSubStr, pcDirection)
		return This.FindLastDCSZ(pcSubStr, pcDirection, 1)

	  #---------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#---------------------------------------------------------#
	#TODO // Add other alternatives

	def NthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthDZZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZZ(n, pcSubStr, pcDirection, 1)

	  #-----------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#-----------------------------------------------------------#
	#TODO // Add other alternatives

	def FirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZZ(pcSubStr, pcDirection, 1)

		#< @FunctionMisspelledForm

		def FistDZZ(n, pcSubStr, pcDirection)
			return This.FirstDZZ(n, pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#----------------------------------------------------------#
	#TODO // Add other alternatives

	def LastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.NthDCSZZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastDZZ(pcSubStr, pcDirection)
		return This.LastDCSZZ(pcSubStr, pcDirection, 1)

	  #=================================================#
	 #      FINDING LAST OCCURRENCE OF A SUBSTRING     #
	#=================================================#

	def FindLastCS(pcSubStr, pCaseSensitive)
		#< TODO: @QtBased | Uses QString2.lastIndexOf()

		/* EXAMPLE

		#                      4     0     6    1
		o1 = new stzString("---***---***---***---")
		? o1.FindLast("***")
		#--> 16

		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT This.ContainsCS(pcSubstr, pCaseSensitive)
			return 0
		ok

		n = This.NumberOfOccurrenceCS(pcSubstr, pCaseSensitive)
		nResult = This.FindNthCS(n, pcsubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms
	
		def FindLastOccurrenceCS(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#==

		def FindLastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceCSZ(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#>

	def FindLast(pcSubStr)
		return This.FindLastCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePosition(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLast(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPosition(pcSubStr)
			return This.FindLast(pcSubStr)

		#==

		def FindLastZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastOccurrenceZ(pcSubstr)
			return This.FindLast(pcSubStr)

		def FindLastSubStringZ(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrenceZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePositionZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubStringZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPositionZ(pcSubStr)
			return This.FindLast(pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#--------------------------------------------------------#

	def LastCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternativeForm

		def LastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceOfSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastZ(pcSubStr)
		return This.FindLastCSZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def LastSubStringZ(pcSubStr)
			return This.LastZ(pcSubStr)

		def LastOccurrenceZ(pcSubStr)
			return This.LastZ(pcSubStr)

		def LastOccurrenceOfSubStringZ(pcSubStr)
			return This.LastZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#---------------------------------------------------------#

	def LastCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForm

		def LastSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceCSZz(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastZZ(pcSubStr)
		return This.LastCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def LastSubStringZZ(pcSubStr)
			return This.LastZZ(pcSubStr)

		def LastOccurrenceZz(pcSubStr)
			return This.LastZZ(pcSubStr)

		def LastOccurrenceOfSubStringZZ(pcSubStr)
			return This.LastZZ(pcSubStr, pCaseSensitive)

		#>

	  #===================================================================#
	 #   FINDING THE POSITIONS OF THE OCCURRENCES OF A GIVEN SUBSTRING   #
	#===================================================================#

	def FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.FindOccurrences([ 2, 3 ], "ring") #--> [ 9, 17 ]
		*/

		if CheckingParams()
			
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and StzListQ(panOccurr[nLen]).IsAndNamedParam()
				panOccurr[nLen] = panOccurr[nLen][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panOccurr)
				StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
			ok

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOneTheseNamedParams([ :Of, :OfSubString ])
				#NOTE
				# that IsOneTheseNamedParams() is a misspelled form of
				# IsOneOfTheseNamedParams(). I forgot "These" but hopefully
				# Softanza forgave it ;)
	
				pcSubStr = pcSubStr[2]
			ok

		ok

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLenPos = len(anPos)
		if nLenPos = 0
			return []
		ok

		nLenOccurr = len(panOccurr)

		nLen = Min([ nLenOccurr, nLenPos ])
		anResult = []
		for i = 1 to nLen
			anResult + anPos[panOccurr[i]]
		next

		anResult = ring_sort(anResult)
		return anResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesCSZ(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#--

		def FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		def FindOccurrencesCSZ(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesZ(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#--

		def FindOccurrences(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		def FindOccurrencesZ(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN OCCURRENCES OF A SUBSTRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#------------------------------------------------------------------------------------------#

	def FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, pCaseSensitive)

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesZZ(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesAsSections(panOccurr, pcSubStr)
			return This.FindTheseOccurrencesZZ(panOccurr, pcSubStr)

		#>

	   #=====================================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING,   #
	 #   STARTING AT A GIVEN POSITION, AND GOING IN A GIVEN DIRECTION      #
	#=====================================================================#

	def FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward
			nLen = This.NumberOfChars()
			anPos = This.SectionQ(pnStartingAt, nLen).FindCS(pcSubStr, pCaseSensitive)

			nLen = len(anPos)
			nLenSubStr = Q(pcSubStr).NumberOfChars()
	
			
			for i = 1 to nLen
				anResult + (pnStartingAt + anPos[i] - 1)
			next
	
		else // pcDirection = :Bacward
			anResult = This.SectionQ(1, pnStartingAt).
				 	FindCSQ(pcSubStr, pCaseSensitive).Reversed()

		ok

		return anResult


		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTDCSZ(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTDZ(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING AT A GIVEN   #
	 #   POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING THOSE POSITIONS AS SECTIONS      #
	#----------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		anPos = This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTDCSZZ(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTDZZ(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesAsSectionsSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING STARTING AT A GIVEN POSITION                 #
	#==========================================================#

	def FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
		anResult = This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTCSZ(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesST(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTZ(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesST(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING   #
	 #   AT A GIVEN POSITION AND RETURNING THOSE POSITIONS AS SECTIONS             #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		aResult = This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTCSZZ(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsST(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTZZ(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesAsSectionsST(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING GOING IN A GIVEN DIRECTION                   #
	#==========================================================#

	def FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		if CheckingParams() = 1
			if NOT ( isList(panOccurr) and StzListQ(panOccurr).IsListOfNumbers() )
				StzRaise("Incorrect param type! pabOccurr must be a list of numbers.")
			ok
	
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfOrOfSubString()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(pcDirection) and StzListQ(pcDirection).IsDirectionNamedParam()
				pcDirection = pcDirection[2]
			ok
		ok

		nStartAt = 1

		if pcDirection = :Backward
			nStartAt = This.NumberOfChars()
		ok

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, nStartAt, pcDirection, pCaseSensitive)

		nLen = len(panOccurr)
		anResult = []
		for i = 1 to nLen
			anResult + anPos[panOccurr[i]]
		next

		return anResult


		def FindTheseOccurrencesDCSZ(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, 1)

		def FindTheseOccurrencesDZ(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING GOING IN   #
	 #   A GIVEN DIRECTION AND RETURNING THOSE POSITIONS AS SECTIONS               #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		nLen = len(anPos)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []
		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesDCSZZ(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, 1)

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesDZZ(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)

		#>

	   #=============================================#
	  #   FINDING NEXT OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION              #
	#=============================================#

	#TODO // Add FindAllNextAsSectionsCS()
	# 	    FindNextAsSectionCS()

	def FindAllNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		nLen = This.NumberOfChars()
		oSection = This.SectionQ(pnStartingAt, nLen)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		anResult = []

		if len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt).Content()
		ok

		return anResult
		
		def FindAllNextCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAllNextST(pcSubStr, pnStartingAt)
		return This.FindAllNextSTCS(pcSubStr, pnStartingAt, 1)

		def FindAllNextZ(pcSubStr, pnStartingAt)
			return This.FindAllNextST(pcSubStr, pnStartingAt)

	   #-------------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION                  #
	#-------------------------------------------------#

	#TODO //
	# 	def FindAllPreviousAsSection()
	# 	def FindAllNextAsSection()

	def FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(1, pnStartingAt)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPos

		#< @FunctionAlternativeForms

		def FindAllPreviousCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def FindAllPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindAllPreviousSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllPrevious(pcSubStr, pnStartingAt)
		aResult = This.FindAllPreviousCS(pcSubStr, pnStartingAt, 1)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllPreviousZ(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		#--

		def FindAllPreviousST(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		def FindAllPreviousSTZ(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		#>

	   #=====================================================#
	  #      FINDING NTH NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                   #
	#=====================================================#

	def FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if NOT @BothAreNumbers(n, nStart)
				StzRaise("Incorrect param type! n and nStart must be numbers.")
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
	
			ok

		ok

		# Early checks (gains performance for large strings)

		nLen = This.NumberOfChars()

		if EarlyChecks()
	
			if pcSubStr = ""
				return 0
			ok
	
			if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
				return 0
			ok

			if nStart = nLen
				return 0
			ok

			if nStart < 1 or nStart > nLen
				return 0
			ok

		ok

		# Doint the job

		nResult  = This.SectionQ(nStart+1, nLen).
				FindNthCS(n, pcSubStr, pCaseSensitive)

		if nResult != 0
			nResult += nStart
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthSTCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextSTCSZ( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNextNthSTCSZ( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNextNthCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WYHOUT CASESENSITIVITY

	def FindNthNextST(n, pcSubStr, nStart)
		return This.FindNthNextSTCS(n, pcSubStr, nStart, 1)

		#< @FunctionAlternativeForms

		def FindNextNthST( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNthNextSTZ( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNextNthSTZ( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNthNext( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNextNth( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		#>

	  #--------------------------------------------------------------------------------------#
	 #  FINFING NTH NEXT OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#--------------------------------------------------------------------------------------#

	def FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
		#< @FunctionAlternativeForm

		def FindNthNextCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#--

		def FindNthNextAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FindNthNextAsSection(n, pcSubStr, nStart )
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, 1)
	
		#< @FunctionAlternativeForm

		def FindNthNextZZ(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart)

		#--

		def FindNthNextAsSectionST(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart )

		def FindNthNextSTZZ(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart )

		#>

	   #=========================================================#
	  #      FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                       #
	#=========================================================#

	def FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isString(nStart) and ( nStart = :Last Or nStart = :LastChar )
				nStart = This.NumberOfChars()
			ok
	
			if isString(n)
	
				if n = :First Or n= :FirstOccurrence
					n = 1
	
				but n = :Last Or n = :LastOccurrence
					n = This.SectionQ(1, nStart).NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
				ok
			ok
	
			if NOT ( isNumber(n) and isNumber(nStart) )
				StzRaise("Incorrect param type! n and nStart must be numbers.")
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
	
			ok

		ok

		# Early checks (gains performance for large strings)

		nLen = This.NumberOfChars()

		if EarlyChecks()

			if nStart = 1
				return 0
			ok

			if nStart < 0 or nStart > nLen
				return 0
			ok

			if pcSubStr = ""
				return 0
			ok
	
			if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
				return 0
			ok
	
			if This.SectionQ(1, nStart - 1).
				NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) < n

				return 0
			ok

		ok

		# Full check (only occurrences of pcSubStr are parsed, not every char)

		bCase = @CaseSensitive(pCaseSensitive)
		nPos = nStart - 1
		nFound = 0
		i = 0

		while 1
			i++
			if i > nLen
				exit
			ok

			nPos = This.FindPreviousCS(pcSubStr, nPos, bCase)

			if nPos = 0
				exit
			else
				nFound++
				if nFound = n
					return nPos
				ok
			ok
		end

		return 0

		#< @FunctionAlternativeForms

		def FindPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
 
		def FindNthPreviousCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def FindPreviousNthSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthSTCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindNthPreviousSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindNthPreviousSTCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, 1)

		#< @FunctionAlternativeForms

		def FindPreviousNth(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindPreviousNthZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		#--

		def FindPreviousNthST(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindPreviousNthSTZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousST(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousSTZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINFING NTH PREVIOUS OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#------------------------------------------------------------------------------------------#

	def FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		nPos = This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult

		#< @FunctionAlternativeForms

		def FindPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthPreviousCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindPreviousNthCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#--

		def FindNthPreviousAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthPreviousSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindPreviousNthSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FindNthPreviousAsSection(n, pcSubStr, nStart )
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, 1)

		#< @FunctionAlternativeForms

		def FindPreviousNthAsSection(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindNthPreviousZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		#--

		def FindNthPreviousAsSectionST(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthAsSectionST(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindNthPreviousSTZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthSTZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		#>

	   #-------------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION               #
	#-------------------------------------------------#

	#TODO //Add FindNextW() FindPreviousW()

	def FindNextCS(pcSubStr, nStart, pCaseSensitive)
		#< QTBased | Uses: QString.IndexOf() >

		if CheckingParams()

			# Resolving pcSubStr param

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			# Resolving nStart param

			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if NOT isNumber(nStart)
				StzRaise("Incorrect param type! nStart must be a number.")
			ok

		ok

		# Resolving pCaseSensitive param

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Early checks

		if pcSubStr = ""
			return  0
		ok

		if This.ContainsCS(pcSubStr, _bCase_) = 0
			return 0
		ok

		# Doing the job (Qt-side)

		nResult = This.QStringObject().indexof(pcSubStr, nStart, _bCase_) + 1

		return nResult
		
		#< @FunctionAlternativeForm

		def FindNextCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		#--

		def FindNextSubStringCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSubStringSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSubStringSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNext(pcSubStr, nStart)
		return This.FindNextCS(pcSubStr, nStart, 1)

		#< @FunctionAlternativeForm

		def FindNextZ(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextST(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSTZ(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		#--

		def FindNextSubString(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSubStringST(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSubStringSTZ(pcSubStr, nStart)
			return This.FindNextCS(pcSubStr, nStart)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING ALL NEXT OCCURRENCES OF A SUBSTRING STARTING AT A POSITION  #
	#----------------------------------------------------------------------#

	def FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		anPos = This.SectionQ(pnStartingAt, This.NumberOfChars()).FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		for i = 1 to nLen
			anPos[i] += pnStartingAt
		next

		return anPos

	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrences(pcSubStr, pnStartingAt)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, 1)

	  #------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCES OF A SUBSTRING STARTING AT A POSITION -- ZZ  #
	#------------------------------------------------------------------------#

	def FindNextOccurrencesCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		nLen = This.NumberOfChars()
		if pnStartingAt = nLen
			return []
		ok

		aSections = This.SectionQ(pnStartingAt + 1, nLen).FindAllCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		for i = 1 to nLen
			aSections[i][1] += pnStartingAt
			asections[i][2] += pnStartingAt
		next

		return aSections


		def FindNextOccurrencesAsSectionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrencesZZ(pcSubStr, pnStartingAt)
		return This.FindNextOccurrencesCSZZ(pcSubStr, pnStartingAt, 1)

		def FindNextOccurrencesAsSections(pcSubStr, pnStartingAt)
			return This.FindNextOccurrencesZZ(pcSubStr, pnStartingAt)

	   #-----------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING FROM A GIVEN POSITION N               #
	#=====================================================#

	def FindPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		if EarlyCheck()

			if pcSubStr = "" or
			   NOT This.ContainsCS(pcSubStr, pCaseSensitive)
	
				return 0
			ok
		ok

		_nResult_ = This.SectionQ(1, pnStartingAt - 1).
				FindLastCS(pcSubStr, pCaseSensitive)

		return _nResult_

		#< @FunctionAlternativeForm

		def FindPreviousCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		#--

		def FindPreviousSubStringCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSubStringSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSubStringSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPrevious(pcSubStr, nStart)
		return This.FindPreviousCS(pcSubStr, nStart, 1)
	
		#< @FunctionAlternativeForm

		def FindPreviousZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousST(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSTZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		#--

		def FindPreviousSubString(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSubStringST(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSubStringSTZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE PREVIOUS OCCURRENCES OF A SUBSTRING STARTING AT A POSITION  #
	#--------------------------------------------------------------------------#

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		anPos = This.SectionQ(1, pnStartingAt - 1).FindAllCS(pcSubStr, pCaseSensitive)
		return anPos

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, 1)

	  #--------------------------------------------------------------------------------#
	 #  FINDING ALL PREVIOUS OCCURRENCES OF A SUBSTRING STARTING AT A POSITION -- ZZ  #
	#--------------------------------------------------------------------------------#

	def FindPreviousOccurrencesCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		aSections = This.SectionQ(1, pnStartingAt - 1).FindAllCSZZ(pcSubStr, pCaseSensitive)
		return aSections


		def FindPreviousOccurrencesAsSectionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrencesCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrencesZZ(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrencesCSZZ(pcSubStr, pnStartingAt, 1)

		def FindPreviousOccurrencesAsSections(pcSubStr, pnStartingAt)
			return This.FindPreviousOccurrencesZZ(pcSubStr, pnStartingAt)

	  #-------------------------------------------------#
	 #      FINDING ALL OCCURRENCES OF A SUBSTRING     #
	#=================================================#

	def FindCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if CheckingParams()

			if isList(pcSubStr) and @IsListOfStrings(pcSubStr)
				return This.FindManyCS(pcSubStr, pCaseSensitive)
			ok
	
			if isList(pcSubStr) and
				( Q(pcSubStr).IsOfNamedParam() or
				  Q(pcSubStr).IsOfSubStringNamedParam() )
	
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		# Early check

		if pcSubStr = ""
			return []
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return []
		ok

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		nLenString = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		if nLenString < nLenSubStr
			return []
		ok

		anResult = []

		bContinue = 1
		_nPos_ = 0

		while bContinue
			
			_nPos_ = This.QStringObject().indexOf(pcSubStr, _nPos_, pCaseSensitive) + 1

			if _nPos_ = 0
				bContinue = 0
			else
				anResult + _nPos_
			ok
		end

		return anResult

		#< @FunctionFluentForm

		def FindCSQ(pcSubStr, pCaseSensitive)
				return This.FindCSQRT(pcSubStr, pCaseSensitive, :stzList)
			
		def FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms # See other in botton of file ALTERNATIVES section

		def FindCSZ(pcSubStr, pCaseSensitive)
			return This.FindCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Find(pcSubStr)
		return This.FindCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def FindQ(pcSubStr)
			return This.FindQRT(pcSubStr, :stzList)
		
		def FindQRT(pcSubStr, pcReturnType)
				return This.FindCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms : See others in bottom of file

		def FindZ(pcSubStr)
			return This.Find(pcSubStr)

		#>

	  #-------------------------------------------#
	 #  GETTING THE SUBSTRING AND ITS POSITIONS  #
	#===========================================#

	def SubStringCSZ(pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

	#-- WITHOUT CASESENSITIVITY

	def SubStringZ(pcSubStr)
		return This.SubStringCSZ(pcSubStr, 1)

	  #------------------------------------------#
	 #  GETTING THE SUBSTRING AND ITS SECTIONS  #
	#------------------------------------------#

	def SubStringCSZZ(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]
		return aResult
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringZZ(pcSubStr)
		return This.SubStringCSZZ(pcSubStr, 1)

	  #--------------------------------------------------#
	 #  FINDING POSITIONS OF ANTI-PARTS OF A SUBSTRING  #
	#==================================================#

	def AntiFindCS(pcSubStr, pCaseSensitive)
		anSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		anResult = []
		
		for i = 1 to nLen
			anPos = anSections[i][1] : anSections[i][2]
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		return anResult

		def AntiFindCSZ(pcSubStr, pCaseSensitive)
			return This.AntiFindCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pcSubStr)
		return This.AntiFindCS(pcSubStr, 1)

		def AntiFindZ(pcSubStr)
			return This.AntiFind(pcSubStr)

	  #===============================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING IN A GIVEN DIRECTION  #
	#===============================================================#

	def FindDCS(pcSubStr, pcDirection, pCaseSensitive)
		
		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 ring_find([ :Default, :Forward, :Backward ], pcDirection) > 0 )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		if pcDirection = :Forward or pcDirection = :Default
			return This.FindCS(pcSubStr, pCaseSensitive)

		but pcDirection = :Backward
			return This.FindAllCSQ(pcSubStr, pCaseSensitive).Reversed()

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok

		#< @FunctionFluentForm

		def FindDCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSQRT(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSQRT(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#--

		def FindDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindOccurrencesDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>
 
	#-- WITHOUT CASESENSITIVITY

	def FindD(pcSubStr, pcDirection)
		return This.FindDCS(pcSubStr, pcDirection, 1)

		#< @FunctionFluentForm

		def FindDQ(pcSubStr, pcDirection)
			return This.FindDQRT(pcSubStr, pcDirection, :stzList)
		
		def FindDQRT(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSQRT(pcSubStr, pcDirection, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#--

		def FindDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindOccurrencesDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#>

	   #-----------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                        #
	#-----------------------------------------------------------------------#

	def SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive)

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringDCSZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.SubStringDCSZQRT(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def SubStringDCSZQRT(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringDZ(pcSubStr, pcDirection)
		return This.SubStringDCSZ(pcSubStr, pcDirection, 1)

		#< @FunctionFluentForm

		def SubStringDZQ(pcSubStr, pcDirection)
			return This.SubStringDZQRT(pcSubStr, pcDirection, :stzList)
		
		def SubStringDZQRT(pcSubStr, pcDirection, pcReturnType)
				return This.SubStringDCSZQRT(pcSubStr, pcDirection, 1, pcReturnType)

		#>

	   #-----------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS            #
	#-----------------------------------------------------------------------#

	def SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 ring_find([ :Default, :Forward, :Backward ], pcDirection) > 0 )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		if pcDirection = :Forward or pcDirection = :Default
			return [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]

		but pcDirection = :Backward
			return [ pcSubStr, This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed() ]

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok
		

		#< @FunctionFluentForm

		def SubStringDCSZZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.SubStringDCSZZQRT(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def SubStringDCSZZQRT(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringDZZ(pcSubStr, pcDirection)
		return This.FindDCSZZ(pcSubStr, pcDirection, 1)

		#< @FunctionFluentForm

		def SubStringDZZQ(pcSubStr, pcDirection)
			return This.SubStringDZZQRT(pcSubStr, pcDirection, :stzList)
		
		def SubStringDZZQRT(pcSubStr, pcDirection, pcReturnType)
				return This.SubStringDCSZZQRT(pcSubStr, pcDirection, 1, pcReturnType)

		#>

	  #========================================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#=======================================================================#

	/* TODO - FUTURE
	the ..ST() extension here must also mean :StoppingAt
	*/

	def FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if CheckingParams()
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		# Doing the job

		nLen = This.NumberOfChars()
		anPos = This.SectionQ(pnStartingAt, nLen).FindCS(pcSubStr, pCaseSensitive)

		anResult = []

		if Len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddedToEach(pnStartingAt - 1)
		ok

		return anResult


		#< @FunctionFluentForm

		def FindSTCSQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.FindSTCSQRT(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def FindSTCSQRT(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindST(pcSubStr, pnStartingAt)
		return This.FindSTِS(pcSubStr, pnStartingAt, 1)

		#< @FunctionFluentForm

		def FindSQ(pcSubStr, pnStartingAt)
			return This.FindSQRT(pcSubStr, pnStartingAt, :stzList)
		
		def FindSQRT(pcSubStr, pnStartingAt, pcReturnType)
			return This.FindSQRT(pcSubStr, pnStartingAt, :stzList)

		#>

		#< @FunctionAlternativeForm

		def FindSTZ(pcSubStr, pnStartingAt)
			return This.FindST(pcSubStr, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                          #
	#-------------------------------------------------------------------------#

	def SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		aResult = [ pcSubStr, This.FindSTِS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringSTCSZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.SubStringSTCSZQRT(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def SubStringSTCSZQRT(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringSTZ(pcSubStr, pnStartingAt)
		return This.SubStringSTCSZ(pcSubStr, pnStartingAt, 1)

		#< @FunctionFluentForm

		def SubStringSTZQ(pcSubStr, pnStartingAt)
			return This.SubStringSTZQRT(pcSubStr, pnStartingAt, :stzList)
		
		def SubStringSTZQRT(pcSubStr, pnStartingAt, pcReturnType)
				return This.SubStringSTCSZQRT(pcSubStr, pnStartingAt, 1, pcReturnType)

		#>

	   #-------------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS              #
	#-------------------------------------------------------------------------#

	def SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckingParams()
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		aResult = [ pcSubStr, This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringSTCSZZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.SubStringSTCSZZQRT(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def SubStringSTCSZZQRT(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringSTZZ(pcSubStr, pnStartingAt)
		return This.SubStringSTCSZZ(pcSubStr, pnStartingAt, 1)

		#< @FunctionFluentForm

		def SubStringSTZZQ(pcSubStr, pnStartingAt)
			return This.SubStringSTZZQRT(pcSubStr, pnStartingAt, :stzList)
		
		def SubStringSTZZQRT(pcSubStr, pnStartingAt, pcReturnType)
				return This.SubStringSTCSZZQRT(pcSubStr, pnStartingAt, 1, pcReturnType)

		#>

	   #===========================================================================#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                           #
	#===========================================================================#

	def FindSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckingParams()

			if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and 
				 ring_find([ :Default, :Forward, :Backward ], pcDirection)  > 0 )
	
				StzRaise("Incorrect param! pcDirection must be a string. " +
					 "Allowed values are :Default, :Forward, and :Backward.")
	
			ok

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward or pcDirection = :Default
			anResult = This.FindSTِS(pcSubStr, pnStartingAt, pCaseSensitive)

		else // pcDirection = :Backward

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

			anResult = This.SectionQ(1, pnStartingAt).
					FindCSQ(pcSubStr, pCaseSensitive).
					Reversed()
		ok

		return anResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCS(pcSubStr, pnStartingAt, pcDirection, 1)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#-------------------------------------------------------------------------------#

	def FindSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCSZ(pcSubStr, pnStartingAt, pcDirection, 1)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------#

	def FindSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		# Doing the job

		aResult = This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#==================================================================#

	#TODO // check performance
	# ~> May use the implementation of SubStrings()

	def FindSubStringAsSectionsWCS(pcSubStr, pcCondition, pCaseSensitive)
		if CheckingParams()
			if NOT @BothAreSrings(pcSubStr, pcCondition)
				StzRaise("Incorrect param type! pcSubStr and pcCondition must be both strings.")
			ok
		ok

		# Doing the job

		acSubStrZZ = This.SubStringsWCSZZ(pcCondition, pCaseSensitive)
		nLen = len(acSubStrZZ)

		aResult = []

		for i = 1 to nLen
			if acSubStrZZ[i][1] = pcSubStr
				aResult + acSubStrZZ[i][2]
			ok
		next

		#< @FunctionAlternativeForm

		def FindSubStringWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringAsSectionsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSectionsW(pcSubStr, pcCondition)
		return This.FindSubStringAsSectionsWCS(pcSubStr, pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSubStringWZZ(pcCondition)
			return This.FindSubStringAsSectionsW(pcCondition)

		#>

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- WXT/EXETENDED      #
	#------------------------------------------------------------------#

	def FindSubStringAsSectionsWCSXT(pcSubStr, pcCondition, pCaseSensitive)
		if CheckingParams()
			if NOT @BothAreSrings(pcSubStr, pcCondition)
				StzRaise("Incorrect param type! pcSubStr and pcCondition must be both strings.")
			ok
		ok

		# Doing the job

		acSubStrZZ = This.SubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		nLen = len(acSubStrZZ)

		aResult = []

		for i = 1 to nLen
			if acSubStrZZ[i][1] = pcSubStr
				aResult + acSubStrZZ[i][2]
			ok
		next

		#< @FunctionAlternativeForm

		def FindSubStringWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSectionsWXT(pcSubStr, pcCondition)
		return This.FindSubStringAsSectionsWCSXT(pcSubStr, pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSubStringWXTZZ(pcCondition)
			return This.FindSubStringAsSectionsWXT(pcCondition)

		#>

	  #========================================================#
	 #  FINDING NTH CHAR OR SUBSTRING UPON A GIVEN CONDITION  #
	#========================================================#

	def FindNthWCS(n, pcCondition, pCaseSensitive)
		if CheckingParams()

		ok

		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubString = oCond.ContainsCS("@substring", 0)
		bI@ = oCond.ContainsCS("@i", 0)

		if NOT ( bChar = 1 or bSubString = 1 or bI@ = 1 )
			StzRaise("Incorrect syntax! pcCondition must contain @char or @substring or @i keyword.")

		but (bChar = 1 and bSubString = 1) or
		    (bChar = 1 and bI@ = 1) or
		    (bSubString = 1 and bI@ = 1)

			StzRaise("Incorrect syntax! pcCondition must contain @char or @substring or @i keyword but not all of them.")

		ok

		if bI@ = 1
			return This.FindNthCharsWCS(n, pCondition, pCaseSensitive)

		but bChar = 1
			return This.FindNthCharWCSXT(n, pcCondition, pCaseSensitive)

		but bSubString = 1
			return This.FindNthSubStringWCSXT(n, pcCondition, pCaseSensitive)

		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNthW(n, pcCondition)
		return This.FindNthWCS(n, pcCondition, 1)

	  #--------------------------------------------------------------#
	 #  FINDING NTH CHAR OR SUBSTRING UPON A GIVEN CONDITION -- XT  #
	#--------------------------------------------------------------#

	def FindNthWCSXT(n, pcCondition, pCaseSensitive)
		if CheckingParams()

		ok

		oCond = new stzString(pcCondition)

		bChar = oCond.ContainsCS("@char", 0)
		bSubString = oCond.ContainsCS("@substring", 0)

		if NOT ( bChar = 1 or bSubString = 1 )
			StzRaise("Incorrect syntax! pcCondition must contain @char or @substring keyword.")

		but bChar = 1 and bSubString = 1
			StzRaise("Incorrect syntax! pcCondition must contain @char or @substring keyword but not both.")

		ok

		if bChar = 1 and bSubString = 0
			return This.FindNthCharWCSXT(n, pcCondition, pCaseSensitive)

		but bSubString = 1 and bChar = 0
			return This.FindNthSubStringWCSXT(n, pcCondition, pCaseSensitive)

		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNthWXT(n, pcCondition)
		return This.FindNthWCSXT(n, pcCondition, 1)

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#================================================================#

	def FindNthCharWCS(n, pcCondition, pCaseSensitive)
		#TODO
		# Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextCharW() and use it instead.

		if CheckingParams()
			if isString(n)
				if n = :FirstChar or n = :First
					n = 1
				but n = :LastChar or n = :Last
					n = len(This.FindCharsWCS(pcCondition, pCaseSensitive))
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthCharWCSZ(n, pcCondition, pCaseSensitive)
			return This.FindNthCharWCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVIE

	def FindNthCharW(n, pcCondition)
		return This.FindNthCharWCS(n, pcCondition, 1)

		def FindNthCharWZ(n, pcCondition)
			return This.FindNthCharW(n, pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------------#

	def FindNthCharWCSXT(n, pcCondition, pCaseSensitive)

		if CheckingParams()
			if isString(n)
				if n = :FirstChar or n = :First
					n = 1
				but n = :LastChar or n = :Last
					n = len(This.FindCharsWCSXT(pcCondition, pCaseSensitive))
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthCharWCSXTZ(n, pcCondition, pCaseSensitive)
			return This.FindNthCharWCSXT(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVIE

	def FindNthCharWXT(n, pcCondition)
		return This.FindNthCharWCSXT(n, pcCondition, 1)

		def FindNthCharWXTZ(n, pcCondition)
			return This.FindNthCharWXT(n, pcCondition)

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#================================================================#

	#TODO // Add this function
	# def FindNthSubStringWZZ() # returns the nth (conditional substring and its sections)
	
	def FindNthSubStringWCS(n, pcCondition, pCaseSensitive)
		#TODO // Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextSubStringW() and use it instead.

		if CheckingParams()
			if isString(n)
				if n = :FirstSubString or n = :First
					n = 1
				but n = :LastSubString or n = :Last
					n = nLen # In fact, last char is the last substring
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthSubStringWCSZ(n, pcCondition, pCaseSensitive)
			return This.FindNthSubStringWCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringW(n, pcCondition)
		return This.FindNthSubStringWCS(n, pcCondition, 1)


		def FindNthSubStringWZ(n, pcCondition)
			return This.FindNthSubStringW(n, pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------------#

	#TODO // Add this function
	# def FindNthSubStringWXTZZ() # returns the nth (conditional substring and its sections)
	
	def FindNthSubStringWCSXT(n, pcCondition, pCaseSensitive)

		if CheckingParams()
			if isString(n)
				if n = :FirstSubString or n = :First
					n = 1
				but n = :LastSubString or n = :Last
					n = nLen # In fact, last char is the last substring
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthSubStringWCSXTZ(n, pcCondition, pCaseSensitive)
			return This.FindNthSubStringWCSXT(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringWXT(n, pcCondition)
		return This.FindNthSubStringWCSXT(n, pcCondition, 1)

		def FindNthSubStringWXTZ(n, pcCondition)
			return This.FindNthSubStringWXT(n, pcCondition)

	  #------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#==================================================================#

	def FindFirstCharWCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWCS(1, pcCondition, pCaseSensitive)

		def FindFirstCharWCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstCharWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstCharW(pcCondition)
		return This.FindFirstCharWCS(pcCondition, 1)

		def FindFirstCharWZ(pcCondition)
			return This.FindFirstCharW(pcCondition)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT #
	#------------------------------------------------------------------------#

	def FindFirstCharWCSXT(pcCondition, pCaseSensitive)
		return This.FindNthCharWCSXT(1, pcCondition, pCaseSensitive)

		def FindFirstCharWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindFirstCharWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstCharWXT(pcCondition)
		return This.FindFirstCharWCSXT(pcCondition, 1)

		def FindFirstCharWXTZ(pcCondition)
			return This.FindFirstCharWXT(pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	#=======================================================================#

	def FindFirstSubStringWCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCS(1, pcCondition, pCaseSensitive)

		def FindFirstSubStringWCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstSubStringWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringW(pcCondition)
		return This.FindFirstSubStringWCS(pcCondition, 1)

		def FindFirstSubStringWZ(pcCondition)
			return This.FindFirstSubStringW(pcCondition)

	  #-----------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION -- WXT #
	#-----------------------------------------------------------------------------#

	def FindFirstSubStringWCSXT(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCSXT(1, pcCondition, pCaseSensitive)

		def FindFirstSubStringWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindFirstSubStringWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringWXT(pcCondition)
		return This.FindFirstSubStringWCSXT(pcCondition, 1)

		def FindFirstSubStringWXTZ(pcCondition)
			return This.FindFirstSubStringWXT(pcCondition)

	  #-----------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#=================================================================#

	def FindLastCharWCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWCS(1, pcCondition, pCaseSensitive)

		def FindLastCharWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastCharWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastCharW(pcCondition)
		return This.FindLastCharWCS(pcCondition, 1)

		def FindLastCharWZ(pcCondition)
			return This.FindLastCharW(pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT #
	#-----------------------------------------------------------------------#

	def FindLastCharWCSXT(pcCondition, pCaseSensitive)
		return This.FindNthCharWCSXT(1, pcCondition, pCaseSensitive)

		def FindLastCharWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastCharWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastCharWXT(pcCondition)
		return This.FindLastCharWCSXT(pcCondition, 1)

		def FindLastCharWXTZ(pcCondition)
			return This.FindLastCharWXT(pcCondition)

	  #----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	#======================================================================#

	def FindLastSubStringWCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCS(1, pcCondition, pCaseSensitive)

		def FindLastSubStringWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSubStringWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringW(pcCondition)
		return This.FindLastSubStringWCS(pcCondition, 1)

		def FindLastSubStringWZ(pcCondition)
			return This.FindLastSubStringW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION -- WXT #
	#----------------------------------------------------------------------------#

	def FindLastSubStringWCSXT(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCSXT(1, pcCondition, pCaseSensitive)

		def FindLastSubStringWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastSubStringWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringWXT(pcCondition)
		return This.FindLastSubStringWCSXT(pcCondition, 1)

		def FindLastSubStringWXTZ(pcCondition)
			return This.FindLastSubStringWXT(pcCondition)

	  #============================================#
	 #  FINDING MANY SUBSTRINGS IN THE SAME TIME  # 
	#============================================#

	def FindManyCS(pacSubStr, pCaseSensitive)
		/*
		o1 = new stzString("My name is Mansour. What's your name please?")
		? o1.FindManyCS( [ "name", "your", "please" ], 1 )

		#--> [ [ 4, 33 ], [ 28 ], [ 38 ] ]

		*/

		if CheckingParams()

			if NOT isList(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list.")
			ok

			nLen = len(pacSubStr)
			lastItem = pacSubStr[nLen]

			if isList(lastItem) and
			   isString(latItem[1]) and lastItem[1] = :And

				pacSubStr[nLen] = lastItem[2]
			ok

			if NOT IsListOfStrings(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSubStr = U( pacSubStr )
		nLen = len(acSubStr)

		aResult = []

		for i = 1 to nLen
			aResult + This.FindAllCS(acSubStr[i], pCaseSensitive)
		next

		anResult = Q(aResult).FlattenQ().Sorted()
		return anResult

		#< @FunctionFluentForm

		def FindManyCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQRT(pacSubStr, pCaseSensitive, :stzList)
	
		def FindManyCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def FindManyCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		#--

		def FindTheseCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(pacSubStr)
		return This.FindManyCS(pacSubStr, 1)

		#< @FunctionFluentForm

		def FindManyQ(pacSubStr)
			return This.FindManyQRT(pacSubStr, :stzList)
	
		def FindManyQRT(pacSubStr, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindMany(pacSubStr) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindMany(pacSubStr) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def FindManyZ(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindManySubStrings(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindManySubStringsZ(pacSubStr)
			return This.FindMany(pacSubStr)

		#--

		def FindThese(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseZ(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseSubStrings(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseSubStringsZ(pacSubStr)
			return This.FindMany(pacSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING MANY SUBSTRINGS IN THE SAME TIME -- RETURN POSITIONS AS SECTIONS  # 
	#----------------------------------------------------------------------------#

	def FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		if CheckingParams()

			if NOT isList(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list.")
			ok

			nLen = len(pacSubStr)
			lastItem = pacSubStr[nLen]

			if isList(lastItem) and
			   isString(lastItem[1]) and lastItem[1] = :And

				pacSubStr[nLen] = lastItem[2]
			ok

			if NOT IsListOfStrings(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		pacSubStr = U( pacSubStr )
		nLenSubStr = len(pacSubStr)

		aResult = []

		for i = 1 to nLenSubStr
			aSections = This.FindAsSectionsCS(pacSubStr[i], pCaseSensitive)

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		if len(aResult) > 0
			aResult = Q(aResult).ToStzListOfPairs().Sorted()
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindManyCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindManyAsSections(pacSubStr)
		return This.FindManyAsSectionsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindManySubStringsAsSections(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindManyZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindManySubStringsZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindTheseSubStringsZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING THE POSITIONS OF ALL THE CHARS IN THE STRING  #
	#========================================================#

	def FindCharsCS(pCaseSensitive)
		acChars  = This.CharsCSU(pCaseSensitive)
		anResult = This.FindTheseSubStringsCS(acChars, pCaseSensitive)
		return anResult

		def FindCharsCSZ(pCaseSensitive)
			return This.FindCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindChars()
		return This.FindCharsCS(1)

		def FindCharsZ()
			return This.FindChars()

	  #------------------------------------------------------#
	 #  FINDING THE POSITIONS OF UPPERCASE/LowERCASE CHARS  #
	#======================================================#

	def FindUppercaseChars()
		anResult = []
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			if ring_isupper(acChars[i])
				anResult + i
			ok
		next

		return anResult

	def UppercaseChars()
		return This.CharsAt(This.FindUppercaseChars())

	def UppercaseCharsZ()
		return Association([ This.UppercaseChars(), This.FindUpperCaseChars() ])

	#--

	def FindLowercaseChars()
		anResult = []
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			if ring_isupper(acChars[i])
				anResult + i
			ok
		next

		return anResult

	def LowercaseChars()
		return This.CharsAt(This.FindLowercaseChars())

	def LowercaseCharsZ()
		return Association([ This.LowercaseChars(), This.FindLowerCaseChars() ])




	  #---------------------------------------------------#
	 #  REMOVING CHARS AT GIVEN POSITIONS OF THE STRING  #
	#===================================================#

	def RemoveCharsAt(panPos)

		if CheckingParams()

			if NOT isList(panPos)
				StzRaise("Incorrect param type! panPos must be a list.")
			ok

			if len(panPos) = 0
				return
			ok

			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLen = len(panPos)
		anPos = ring_sort( U(panPos) )
		

		for i = nLen to 1 step -1
			This.RemoveCharAt(anPos[i]) #TODO // check performance!
		next

		def RemoveCharsAtQ(panPos)
			This.RemoveCharsAt(panPos)
			return This

		def RemoveCharsAtPositions(panPos)
			This.RemoveCharsAt(panPos)

			def RemoveCharsAtPositionsQ(panPos)
				This.RemoveCharsAtPositions(panPos)
				return This

	def CharsAtPositionsRemoved(panPos)
		cResult = This.Copy().RemoveCharsAtQ(panPos).Content()
		return cResult

	  #---------------------------------------------#
	 #  FINDING CHARS VERIFYING A GIVEN CONDITION  #
	#=============================================#

	def FindCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindWCS(pcCondition, pCaseSensitive)
		return anResult

		def FindCharsWCSQ(pcCondition, pCaseSensitive)
			return new stzList(This.FindCharsWCS(pcCondition, pCaseSensitive))

		def FindCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsW(pcCondition)
		return This.FindCharsWCS(pcCondition, 1)

		def FindCharsWQ(pcCondition)
			return new stzList(This.FindCharsW(pcCondition))

		def FindCharsWZ(pcCondition)
			return This.FindCharsW(pcCondition)

	  #-------------------------------------------------------------#
	 #  FINDING CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-------------------------------------------------------------#

	def FindCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindWCSXT(pcCondition, pCaseSensitive)
		return anResult

		def FindCharsWCSXTQ(pcCondition, pCaseSensitive)
			return new stzList(This.FindCharsWCSXT(pcCondition, pCaseSensitive))

		def FindCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsWXT(pcCondition)
		return This.FindCharsWCSXT(pcCondition, 1)

		def FindCharsWXTQ(pcCondition)
			return new stzList(This.FindCharsWXT(pcCondition))

		def FindCharsWXTZ(pcCondition)
			return This.FindCharsWXT(pcCondition)

	  #---------------------------------------------------------------------------#
	 #  FINDING CHARS VERIFYING A CONDITION AND RETURNING POSITIONS AS SECTIONS  #
	#---------------------------------------------------------------------------#

	def FindCharsAsSectionsWCS(pcCondition, pCaseSensitive)
		aResult = This.FindCharsWCS(pcCondition, pCaseSensitive).Listified()
		return aResult

		def FindCharsWCSZZ(pcCondition, pCaseSensition)
			return This.FindCharsAsSectionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsAsSectionsW(pcCondition)
		return This.FindCharsAsSectionsWCS(pcCondition, 1)

		def FindCharsZZ(pcCondition, pCaseSensitive)
			return This.FindCharsAsSectionsW(pcCondition)

	  #---------------------------------------------------------------------------------#
	 #  FINDING CHARS VERIFYING A CONDITION AND RETURNING POSITIONS AS SECTIONS -- XT  #
	#---------------------------------------------------------------------------------#

	def FindCharsAsSectionsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		nLen = len(anPos)

		aResult = []
		for i = 1 to nLen
			aResult + [ anPos[i], anPos[i] ]
		next

		return aResult

		def FindCharsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindCharsAsSectionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsAsSectionsWXT(pcCondition)
		return This.FindCharsAsSectionsWCSXT(pcCondition, 1)

		def FindCharsZZXT(pcCondition, pCaseSensitive)
			return This.FindCharsAsSectionsWXT(pcCondition)

	  #--------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#==============================================================#

	def CharsCSZ(pCaseSensitive)

		aResult = [
			This.CharsCS(pCaseSensitive),
			This.FindCharsCSZ(pCaseSensitive)
		]

		return aResult

		def CharsAndTheirPositionsCS(pCaseSensitive)
			return This.CharsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsZ()
		return This.CharsCSZ(1)

		def CharsAndTheirPositions()
			return This.CharsZ()

	  #-------------------------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING VERIFIFUING A GIVEN CONDITION -- Z/EXTENDED  #
	#===============================================================================#

	def CharsWCSZ(pcCondition, pCaseSensitive)
		acChars = U( This.CharsWCS(pcCondition, pCaseSensitive) )
		anPos = This.FindTheseChars(acChars)

		aResult = @Association([ acChars, anPos ])

		return aResult

		def CharsAndTheirPositionsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCSZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsWZ(pcCondition)
		return This.CharsWCSZ(pcCondition, 1)

		def CharsAndTheirPositionsW(pcCondition)
			return This.CharsWZ(pcCondition)

	  #----------------------------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING VERIFIFUING A GIVEN CONDITION -- WXTZ/EXTENDED  #
	#----------------------------------------------------------------------------------#

	def CharsWCSXTZ(pcCondition, pCaseSensitive)
		acChars = U( This.CharsWCSXT(pcCondition, pCaseSensitive) )
		anPos = This.FindTheseChars(acChars)

		aResult = @Association([ acChars, anPos ])

		return aResult

		def CharsAndTheirPositionsWCSXTs(pcCondition, pCaseSensitive)
			return This.CharsWCSXTZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsWXTZ(pcCondition)
		return This.CharsWCSXTZ(pcCondition, 1)

		def CharsAndTheirPositionsWXT(pcCondition)
			return This.CharsWXTZ(pcCondition)

	  #--------------------------------------------#
	 #  FINDING THE POSITIONS OF THE GIVEN CHARS  #
	#============================================#

	def FindTheseCharsCS(pacChars, pCaseSensitive)

		if CheckingParams()
			if NOT ( isList(pacChars) and StzListQ(pacChars).IsListOfChars() )
				StzRaise("Incorrect param type! pacChars must be a list of chars.")
			ok
		ok

		acChars  = U( pacChars )
		anResult = This.FindTheseSubStringsCS(acChars, pCaseSensitive)
		return anResult

		def FindTheseCharsCSZ(pacChars, pCaseSensitive)
			return This.FindCharsCS(pacChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseChars(pacChars)
		return This.FindtheseCharsCS(pacChars, 1)

		def FindTheseCharsZ(pacChars)
			return This.FindChars(pacChars)

	  #--------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def TheseCharsCSZ(pacChars, pCaseSensitive)

		aResult = This.TheseSubStringsCSZ(pacChars, pCaseSensitive)

		return aResult

		def TheseCharsAndTheirPositionsCS(pacChars, pCaseSensitive)
			return This.TheseCharsCSZ(pacChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseCharsZ(pacChars)
		return This.TheseCharsCSZ(pacChars, 1)

		def TheseCharsAndTheirPositions(pacChars)
			return This.TheseCharsZ(pacChars)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and StzListQ(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindSubstringBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindSubStringBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByIBNamedParam()
				return This.FindSubStringBoundedByCSIB(p1, p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSTِS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					return This.FindBeforeSubStringCS(p1, p2[2], pCaseSensitive)

				but isNumber(p2[2])
					return This.FindBeforepositionCS(p1, p2[2], pCaseSensitive)

				ok

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindBeforePositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					return This.FindAfterSubStringCS(p1, p2[2], pCaseSensitive)

				but isNumber(p2[2])
					return This.FindAfterPositionCS(p1, p2[2], pCaseSensitive)

				ok

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAfterPositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitive)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBeforeNamedParam()

				if isString(p2[2])
					return This.FindBeforeSubStringCS( p1[2], p2[2], pCaseSensitive )


			 	but isNumber(p2[2])
					return This.FindBeforePositionCS( p1[2], p2[2], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBeforePositionNamedParam()

				return This.FindBeforePosirtionCS( p1[2], p2[2], pCaseSensitive )


			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsAfterNamedParam()

				if isString(p2[2])
					return This.FindAfterSubStringCS(p1[2], p2[2], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsAfterPositionNamedParam()

				return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and StzListQ(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and StzListQ(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and StzListQ(p2).IsInSectionNamedParam() and StzListQ(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindCSXT(p1, p2, 1)

	  #========#
	 #  NOTE  #
	#========#

	#NOTE
	# These fuctions are defined in stzObject:

	# 	FindFirstNOccurrences(n, pStrOrItem)
	# 	FindFirstNOccurrencesST(n, pcStr, pnStartingAt)
	
	# 	FindLastNOccurrences(n, pStrOrItem)
	# 	FindLastNOccurrencesS(n, pcStr, pnStartingAt)

	# I'm experimenting with this technique of abstraction
	# to make them usable also form stzString and stzList

	#TODO
	# Frankly, I'm not decided yet to keep them or reimplement
	# them in each class apart. Think about the pros and cons!
	
	  #=================================================#
	 #  FINDING THINGS AS SECTIONS, THE EXTENDED FORM  #
	#=================================================#

	def FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and QStzList(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindAsSectionsXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindSubStringBoundedByAsSectionsCS(p1, p2[2], pCaseSensitive)
				
			# FindAsSectionsXT( "*", :BoundedByIB = '"' )
			but oP2.IsBoundedByIBNamedParam()
				return This.FindSubStringBoundedByAsSectionsCSIB(p1, p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				anPos = This.SectionQ(p2[2]).FindCS(p1, pCaseSensitive)
				if len(anPos) = 0
					return []
				ok

				anPos = QRT(anPos, :stzListOfNumbers).AddedToEach(p2[2])
				nLen = Q(p1).NumberOfChars()

				aSections = []
				for i = 1 to nLen
					aSections + [ anPos[i], anPos[i] + nLen - 1 ]
				next

				return aSections

			# FindAsSectionsXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsCSXT( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindAsSectionsXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstAsSectionsCS(p2, pCaseSensitive)
					if nPos > 0
						nLen = This.NumberOfChars()
						return This.FindAsSectionsCSXT( p1, :InSection = [nPos, nLen], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					nLen = This.NumberOfChars()
					return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], nLen], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				nLen = This.NumberOfChars()
				return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], nLen], pCaseSensitive )

			# FindAsSectionsXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and QStzList(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenAsSectionCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedAsSectionByCS(n, [ p1[2], p2 ], pCaseSensitive)

			# FindAsSectionsXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthAsSectionCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindAsSectionsXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindAsSectionCSXT( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsBeforePositionNamedParam()

				return This.FindAsSectionsCSXT( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindAsSectionsXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					nLen = This.NumberOfChars()
					return This.FindAsSectionsCSXT( p1[2], :InSection = [n, nLen], pCaseSensitive)

			 	but isNumber(p2[2])
					nLen = This.NumberOfChars()
					return This.FindAsSectionsCSXT( p1[2], :InSection = [p2[2], nLen], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and StzListQ(p2).IsAfterPositionNamedParam()
				nLen = This.NumberOfChars()
				return This.FindAsSectionsCSXT( p1[2], :InSection = [ p2[2], nLen ], pCaseSensitive )

			# FindAsSectionsXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and StzListQ(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and StzListQ(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenAsSectionsCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindAsSectionsXT( :Any, :BoundedBy = '"' )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and StzListQ(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByAsSectionsCS(p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [5, 24] )
			but isList(p2) and StzListQ(p2).IsInSectionNamedParam() and StzListQ(p2).IsPairOfNumbers()

				aSections = This.SectionQ(p2[1], p2[2]).FindAsSectionsCS(p1, pCaseSensitive)
				nLen = len(aSections)
				nLenSubStr = Q(p2).NumberOfChars()

				aResult = []

				for i = 1 to nLen
					aResult + [ (aSections[i][1] + nLenSubStr - 1), (aSections[i][2] + nLenSubStr - 1) ]
				next

				return aResult
			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionAlternativeForm

		def FindAsSectionCSXT(p1, p2, pCaseSensitive)
		# Without an (s) after Section
		# We need it because some forms
		# return definetly only one section
		# like FindAsSectionXT( :3rd = "*" :InSection = ...)

			return This.FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindAsSectionsXT(p1, p2)
		return This.FindAsSectionsCSXT(p1, p2, 1)

	  #==========================================================#
	 #  FINDING OCCURRENCES OF A SIUBSTRING IN A GIVEN SECTION  #
	#==========================================================#
	
	def FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckingParams()

			if isList(n1) and StzListQ(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)

				if ring_find([ :First, :FirstChar ], n1) > 0
					n1 = 1

				but ring_find([ :Last, :LastChar ], n1)
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			oN2Param = Q(n2)

			if isList(n2) and oN2Param.IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf, :And, :AndPosition ])
				n2 = n2[2]
			ok

			if isString(n2)

				if ring_find([ :First, :FirstChar ], n2)
					n2 = 1

				but ring_find([ :Last, :LastChar ], n2) > 0
					n2 = This.NumberOfChars()

				ok
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Early checks

		if This.IsEmpty() or pcSubStr = ""
			return []
		ok

		if n1 = 0 or n2 = 0
			return []
		ok

		# Doing the job

		anPos = This.SectionQ(n1, n2).FindCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

//		n1 = Min([ n1, n2 ]) #TODO use it when Ring fix

		aTemp = []
		aTemp + n1 + n2
		n1 = Min(aTemp)

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

		#< @FunctionAlternativeForm

		def FindInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pcSubStr, n1, n2)
		return This.FindInSectionCS(pcSubStr, n1, n2, 1)
		
		#< @FunctionAlternativeForm

		def FindInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#--

		def FindSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#--

		def FindBetweenPositions(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringBetweenPositions(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#>

	   #---------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS              #
	#---------------------------------------------------------#

	def FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		if nLenSubStr = 0
			return []
		ok

		anPos = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nLen = len(anPos)

		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult
	
		#< @FunctionAlternativeForm

		def FindInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindBetweenPositionsAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionZZ(pcSubStr, n1, n2)
		return This.FindInSectionAsSectionsCS(pcSubStr, n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindBetweenPositionsAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS  #
	#=======================================================#
	
	def FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckParams() # Allow free params order
			if isList(pcSubStr) and isString(paSections)
				pTemp = pcSubStr
				pcSubStr = paSections
				paSections = pTemp
			ok
		ok

		aSections = This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		nLen = len(aSections)

		if nLen = 0
			return []
		ok

		anResult = StzListOfPairsQ(aSections).FirstItems()
		return anResult

		#< @FunctionAlternativeForms

		def FindInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInTheseSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInTheseSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pcSubStr, paSections)
		return This.FindInSectionsCS(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInManySectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#--

		def FindSubStringInSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#--

		def FindInTheseSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInTheseSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInTheseSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInTheseSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#>

	  #=======================================================================================#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION OR A GIVEN SUBSTRING  #
	#=======================================================================================#

	def FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindBeforePositionCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindBeforeSubStringCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBefore(pcSubStr, pPosOrSubStr)
		return This.FindBeforeCS(pcSubStr, pPosOrSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllBefore(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBefore(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		#--

		def FindBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindAllBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		#>

	   #-----------------------------------------------------------------------#
	  #   FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION OR   #
	 #   A GIVEN SUBSTRING AND RETURNING THEIM AS SECTIONS -- ZZ/EXTENSION   #
	#-----------------------------------------------------------------------#

	def FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeAsSections(pcSubStr, pPosOrSubStr)
		return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllBeforeAsSections(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeAsSections(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		#--

		def FindBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindAllBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION  #
	#==================================================================# 

	def FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		anResult = This.FindInSectionCS(pcSubStr, 1, pnPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePosition(pcSubStr, pnPos)
		return This.FindBeforePositionCS(pcSubStr, pnPos, 1)

		#< @FunctionAlternativeForms

		def FindAllBeforePosition(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindOccurrencesBeforePosition(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		#--

		def FindBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindAllBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING BEFORE A GIVEN POSITION  #
	#--------------------------------------------------------------------------------# 

	def FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, 1, pnPos, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePositionAsSections(pcSubStr, pnPos)
		return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, 1)

		#< @FunctionAlternativeForms

		def FindAllBeforePositionAsSections(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionAsSections(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		#--

		def FindBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindAllBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		#>

	  #-------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN OTHER SUBSTRING  #
	#=========================================================================# 

	def FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		anResult = This.FindInSectionCS(pcSubStr, 1, nPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeSubString(pcSubStr, pcOtherSubStr)
		return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		#--

		def FindBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindAllBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#---------------------------------------------------------------------------------# 

	def FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		aResult = This.FindInSectionAsSectionsCS(1, nPos, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
		return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		#--

		def FindBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindAllBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		#>

	  #======================================================================================#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION OR A GIVEN SUBSTRING  #
	#======================================================================================#

	def FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindAfterPositionCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindAfterSubStringCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfter(pcSubStr, pPosOrSubStr)
		return This.FindAfterCS(pcSubStr, pPosOrSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllAfter(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfter(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		#--

		def FindAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindAllAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		#>

	   #-----------------------------------------------------------------------#
	  #   FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION OR    #
	 #   A GIVEN SUBSTRING AND RETURNING THEIM AS SECTIONS -- ZZ/EXTENSION   #
	#-----------------------------------------------------------------------#

	def FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterAsSections(pcSubStr, pPosOrSubStr)
		return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllAfterAsSections(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterAsSections(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		#--

		def FindAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindAllAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION  #
	#=================================================================# 

	def FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		nLen = This.NumberOfChars()
		anResult = This.FindInSectionCS(pcSubStr, pnPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPosition(pcSubStr, pnPos)
		return This.FindAfterPositionCS(pcSubStr, pnPos, 1)

		#< @FunctionAlternativeForms

		def FindAllAfterPosition(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindOccurrencesAfterPosition(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		#--

		def FindAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindAllAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING AFTER A GIVEN POSITION  #
	#-------------------------------------------------------------------------------# 

	def FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
		nLen = This.NumberOfChars()
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, pnPos, nLen, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPositionAsSections(pcSubStr, pnPos)
		return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, 1)

		#< @FunctionAlternativeForms

		def FindAllAfterPositionAsSections(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionAsSections(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		#--

		def FindAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindAllAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN SUBSTRING  #
	#==================================================================# 

	def FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfChars()
		anResult = This.FindInSectionCS(pcSubStr, nPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterSubString(pcSubStr, pcOtherSubStr)
		return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllAfterSubString(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubString(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		#--

		def FindAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindAllAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING AFTER A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------# 

	def FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfChars()
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, nPos, nLen, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
		return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, 1)

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		#--

		def FindAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindAllAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		#>

	   #=================================================================#
	  #  FINING NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION,  #
	 #  SECTION, OR GIVEN OTHER SUBSTRING                              #
	#=================================================================#

	#TODO
	# Add FindNNearest(n, pItem, pToPositionSectionOrItem, pCaseSensitive)

	def FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		if CheckingParams()
			if NOT isString(pcSubStr)
				StzString("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isNumber(pToPositionSectionOrSubStr) or
				 isList(pToPositionSectionOrSubStr) or
				 isString(pToPositionSectionOrSubStr) )

				StzRaise("Incorrect param type! pToPositionSectionOrSubStr must be " +
					 "a number, a list of numbers, a string or a list.")

			ok
		ok

		if isNumber(pToPositionSectionOrSubStr)
			return This.FindNearestToPositionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		but isString(pToPositionSectionOrSubStr)
			return This.FindNearestToSubStringCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		else // isList()

			if @IsListOfNumbers(pToPositionSectionOrSubStr)
				return This.FindNearestToPositionsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but @IsPairOfNumbers(pToPositionSectionOrSubStr)
				return This.FindNearestTSectionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but @IsListOfPairsOfNumbers(pToPositionSectionOrSubStr)

				return This.FindNearestToSectionsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
	
			but @IsListOfStrings(pToPositionSectionOrSubStr)
				return This.FindNearestToSubStringsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but isList(pToPositionSectionOrSubStr)
				oParam = Q(pToPositionSectionOrSubStr)
		
				if oParam.IsToNamedParam()
					return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToPositionNamedParam()
					return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToPositionsNamedParam()
					return This.FindNearestToPositionsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSectionNamedParam()
		
					n1 = pToPositionSectionOrSubStr[2][1]
					n2 = pToPositionSectionOrSubStr[2][2]
		
					return This.FindNearestToSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		
				but oParam.IsToSectionsNamedParam()
					return This.FindNearestToSectionsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSubStringNamedParam()
					return This.FindNearestToSubStringCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSubStringsNamedParam()
					return This.FindNearestToSubStringsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				ok
	
			ok

			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNearest(pcSubStr, pToPositionSectionOrSubStr)
		return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, 1)

	   #----------------------------------------------------------------------#
	  #  FINdING NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION,      #
	 #  SECTION, OR GIVEN OTHER SUBSTRING, AND RETURNING THEIM AS SECTIONS  #                           #
	#----------------------------------------------------------------------#

	def FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
		n = This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestAsSectionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
			return This.FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestZZ(pcSubStr, pToPositionSectionOrSubStr)
		return This.FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, 1)

		def FindNearestAsSection(pcSubStr, pToPositionSectionOrSubStr)
			return This.FindNearestZZ(pcSubStr, pToPositionSectionOrSubStr)

	  #---------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION  #
	#=====================================================================#

	def FindNearestToPositionCS(pcSubStr, pnPos, pCaseSensitive)

		if EarlyCheck()
			if This.NumberOfChars() = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(pnPos)
				if pnPos = :FirstChar
					pnPos = 1
				but pnPos = :LastChar
					pnPos = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok

		ok

		if NOT pnPos > 0 and pnPos < This.NumberOfChars()
			StzRaise("Index out of range!")
		ok

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anDiff = []
		for i = 1 to nLen
			anDiff + Abs(pnPos - anPos[i])
		next

		nResult = anPos[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPosition(pcSubStr, pnPos)
		return This.FindNearestToPositionCS(pcSubStr, pnPos, 1)

	   #---------------------------------------------------------------------#
	  #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION  #
	 #  AND RETURNING IT AS A SECTION                                      #
	#--------------------------------------------------------------------#

	def FindNearestToPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
		n = This.FindNearestToPositionCS(pcSubStr, pnPos, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestToPositionAsSectionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindNearestToPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionZZ(pcSubStr, pnPos)
		return This.FindNearestToPositionCSZZ(pcSubStr, pnPos, 1)

		def FindNearestToPositionAsSection(pcSubStr, pnPos)
			return This.FindNearestToPositionZZ(pcSubStr, pnPos)
	
	  #----------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCES OF A SUBSTRING TO A GIVEN POSITION -- XT  #
	#----------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToPositionCSXT(pcSubStr, pnPos, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok
		ok

		nLenStr = This.NumberOfChars()

		if pnPos < 1 ans pnPos > nLenStr
			StzRaise("Index out of range! pnPost must be inside the string.")
		ok

		anResult = This.FindNearestToSectionCSXT(pcSubStr, pnPos, pnPos, pCaseSensitive)

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionXT(pcSubStr, pnPos)
		return This.FindNearestToPositionCSXT(pcSubStr, pnPos, 1)

	  #----------------------------------------------------------------#
	 #  FINDING NEAREST OCCURRENCE OF AN ITEM TO THE GIVEN POSITIONS  #
	#================================================================#

	def FindNearestToPositionsCS(pcSubStr, panPos, pCaseSensitive)
	
		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckingParams()

			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return 0
		ok

		anNearest = []
		anDiff = []

		for i = 1 to nLenPos
			anTemp = This.FindNearestToPositionCSXT(pcSubStr, panPos[i], pCaseSensitive)
			nDiff1 = panPos[i] - anTemp[1]
			nDiff2 = anTemp[2] - panPos[i]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

		def FindNearestToPositionsCSZ(pcSubStr, panPos, pCaseSensitive)
			return This.FindNearestToPositionsCS(pcSubStr, panPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositions(pcSubStr, panPos)
		return This.FindNearestToPositionsCS(pcSubStr, panPos, 1)

		def FindNearestToPositionsZ(pcSubStr, panPos)
			return This.FindNearestToPositions(pcSubStr, panPos)

	  #--------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN SECTION  #
	#====================================================================#

	def FindNearestToSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(n1)
				if n1 = :FirstChar
					n1 = 1

				but n1 = :LastChar
					n1 = nLenStr
				ok
			ok
			if isString(n2)
				if n2 = :LastChar
					n2 = nLenStr

				but n2 = :FirstChar
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenStr) and (n2 > 0 and n2 < nLenStr) )
			StzRaise("Index out of range! n1 and n2 must be both inside the string.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pcSubStr, n1, pCaseSensitive)
		nDistBefore = n1 - nNearestBefore

		nNearestAfter  = This.SectionQ(n2, nLenStr).
				 FindNearestToPositionCS(pcSubStr, 1, pCaseSensitive) + n2 - 1

		nDistAfter = nNearestAfter - n2
		
		if nDistBefore < nDistAfter
			nResult = nNearestBefore
		else
			nResult = nNearestAfter
		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSection(pcSubStr, n1, n2)
		return This.FindNearestToSectionCS(pcSubStr, n1, n2, 1)

	  #-------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN SECTION -- XT #
	#-------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToSectionCSXT(pcSubStr, n1, n2, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(n1)
				if n1 = :FirstChar
					n1 = 1

				but n1 = :LastChar
					n1 = nLenStr
				ok
			ok
			if isString(n2)
				if n2 = :LastChar
					n2 = nLenStr

				but n2 = :FirstChar
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenStr) and (n2 > 0 and n2 < nLenStr) )
			StzRaise("Index out of range! n1 and n2 must be both inside the string.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pcSubStr, n1, pCaseSensitive)

		nNearestAfter  = This.SectionQ(n2, nLenStr).
				 FindNearestToPositionCS(pcSubStr, 1, pCaseSensitive) + n2 - 1

		anResult = [ nNearestBefore, nNearestAfter ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSectionXT(pcSubStr, n1, n2)
		return This.FindNearestToSectionCSXT(pcSubStr, n1, n2, 1)

	  #-----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO THE SECTIONS  #
	#-----------------------------------------------------------------#

	def FindNearestToSectionsCS(pcSubStr, paSections, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		nLenSections = len(paSections)
		anNearest = []
		anDiff = []

		for i = 1 to nLenSections
			anTemp = This.FindNearestToSectionCSXT(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nDiff1 = paSections[i][1] - anTemp[1]
			nDiff2 = anTemp[2] - paSections[i][2]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next
		
		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSections(pcSubStr, paSections)
		return This.FindNearestToSectionsCS(pcSubStr, paSections, 1)

	  #----------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN OTHER SUBSTRING  #
	#============================================================================#

	def FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcOtherSubStr, pCaseSensitive)
		nResult = This.FindNearestToSectionsCS(pcSubStr, aSections, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubString(pcSubStr, pcOtherSubStr)
		return This.FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, 1)

	   #----------------------------------------------------------------------------#
	  #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN OTHER SUBSTRING  #
	 #  AND RETURNING ITS POSITION AS A SECTION                                   #
	#----------------------------------------------------------------------------#

	def FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
		n = This.FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestToSubStringAsSectionCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubStringZZ(pcSubStr, pcOtherSubStr)
		return This.FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, 1)

		def FindNearestToSubStringAsSection(pcSubStr, pcOtherSubStr)
			return This.FindNearestToSubStringZZ(pcSubStr, pcOtherSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO GIVEN OTHER SUBSTRINGS  #
	#===========================================================================#

	def FindNearestToSubStringsCS(pcSubStr, pacOtherSubStr, pCaseSensitive)
		aSections = This.FindManyAsSectionsCS(pacOtherSubStr, pCaseSensitive)
		nResult = This.FindNearestToSectionsCS(pcSubStr, aSections, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubStrings(pcSubStr, pacOtherSubStr)
		return This.FindNearestToSubStringsCS(pcSubStr, pacOtherSubStr, 1)

	  #======================================================================#
	 #  GETTING NUMBER OF OCCURRENCES OF A SUBSTRING IN THE GIVEN SECTIONS  #
	#======================================================================#

	def NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		nResult = len( This.FindSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive) )
		return nResult

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrenceInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrencesInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrenceOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrencesOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def CountInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def CountSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceInSections(pcSubStr, paSections)
		return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, 1)

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrenceInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrenceOfSubStringInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesOfSubStringInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrenceInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrencesInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrenceOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrencesOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def CountInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def CountSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		#>

	   #--------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION               #
	#========================================================#

	def FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionsZZ(pcSubStr, paSections)
		return This.FindInSectionsCSZZ(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindInSectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		#--

		def FindSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInSectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		#>

	  #------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#============================================================#

	def FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckingParams()
			if isList(n1) and StzListQ(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)

				if ring_find([ :First, :FirstChar ], n1) > 0
					n1 = 1
				but ring_find([ :Last, :LastChar ], n1) > 0
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			oN2Param = Q(n2)

			if isList(n2) and oN2Param.IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if ring_find([ :Last, :LastChar ], n2) > 0
					n2 = This.NumberOfChars()

				but ring_find([ :First, :FirstChar ], n2) > 0
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		nPos = This.SectionQ(n1, n2).FindNthCS(n, pcSubStr, pCaseSensitive)
		nResult = n1 + nPos - 1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthInSectionCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthBeweenPositionsCSIBZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIBZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1+1, n2-1, pCaseSensitive)

		def FindNthBeweenPositionsCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1+1, n2-1, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSection(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCS(n, pcSubStr, n1, n2, 1)
		
		#< @FunctionAlternativeForm

		def FindNthInSectionZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringInSection(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthBeweenPositionsIBZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIBZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositions(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1+1, n2-1)

		def FindNthBeweenPositionsZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1+1, n2-1)

		#>

	   #------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                   #
	#------------------------------------------------------------#

	def FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nPos = This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anResult = [nPos, nPos + nLenSubStr - 1]
		
		return anResult
	
		#< @FunctionAlternativeForm

		def FindNthInSectionAsSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSennsitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionAsSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCSIBZZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIBZZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthBeweenPositionsAsSectionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsAsSectionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionZZ(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindNthInSectionAsSection(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionAsSection(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositionsIBZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIBZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthBeweenPositionsAsSectionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsAsSectionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#----------------------------------------------------------#

	def FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)
		aPosZZ = FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
		nLen = len(aPosZZ)

		nResult = 0
		if nLen > 0
			nResult = aPosZZ[1]
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNthInManySectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInSectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#--

		def FindNthSubStringInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInSectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSections(n, pcSubStr, paSections)
		return This.FindNthInSectionsCS(n, pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindNthInManySections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthInSectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthInManySectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#--

		def FindNthSubStringInSections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInManySections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInSectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []
		nCounter = 0

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				nCounter++
				if nCounter = n
					aResult = [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
					exit
				ok
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		#--

		def FindNthSubStringInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInSectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionsZZ(n, pcSubStr, paSections)
		return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(pcSubStr, paSections)

		def FindNthInManySectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthInManySectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		#--

		def FindNthSubStringInSectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInSectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#==============================================================#

	def FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindFirstBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSection(pcSubStr, n1, n2)
		return This.FindFirstInSectionCS(pcSubStr, n1, n2, 1)
		
		#< @FunctionAlternativeForm

		def FindFirstInSectionZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringInSection(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		#--

		def FindFirstBetweenPositions(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositions(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		#>

	   #--------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                     #
	#--------------------------------------------------------------#

	def FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindFirstSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindFirstInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionZZ(pcSubStr, n1, n2)
		return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindFirstSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindFirstInSectionAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringInSectionAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		#>

	  #------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#------------------------------------------------------------#

	def FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindFirstInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindFirstSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSections(pcSubStr, paSections)
		return This.FindFirstInSectionsCS(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindFirstInManySections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstInSectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstInManySectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#--

		def FindFirstSubStringInSections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInManySections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindFirstInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindFirstSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionsZZ(pcSubStr, paSections)
		return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		#--

		def FindFirstSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInSectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#=============================================================#

	def FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FinfLastSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FinfLastSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSection(pcSubStr, n1, n2)
		return This.FindLastInSectionCS(pcSubStr, n1, n2, 1)
		
		#< @FunctionAlternativeForm

		def FindLastInSectionZ(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		def FinfLastSubStringInSection(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		def FinfLastSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		#>

	   #-------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                    #
	#-------------------------------------------------------------#

	def FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindLastInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindLastSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindLastSubStringInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionZZ(pcSubStr, n1, n2)
		return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindLastInSectionAsSection(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		def FindLastSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		def FindLastSubStringInSectionAsSection(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindLastInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindLastSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSections(pcSubStr, paSections)
		return This.FindLastInSectionsCS(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindLastInManySections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastInSectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastInManySectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#--

		def FindLastSubStringInSections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInManySections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindLastInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindLastSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionsZZ(pcSubStr, paSections)
		return This.FindLastInSectionsCSZZ(pcSubStr, paSections, 1)

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		#--

		def FindLastSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInSectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInManySectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		#>

	  #===================================================#
	 #   FINDING BY PATTERN (AN ALTERNATIVE TO Regex)   #TODO (FUTURE)
	#===================================================#

	// Finds all the occurrences of a given substring in the string
	// depending on the provided format
	def FindPattern(paFormat) // TODO
		/* ... */

		StzRaise("FindPattern() function is not implemented yet!")

	def FindInside(pcTemplate) // TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInside("KLM", 'amc@bmi') #--> 10

		o1.FindInside("KLM", lower("AMC") + '@' + lower("BMI") #-->

		*/

		/* ... */

		StzRaise("FindInside() function is not implemented yet!")

	def FindInsideW(pcTemplate, pcCondition) #TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInsideW("KLM", :Where = [
			'{ @(3).CharsBefore = "amc" }',
			'{ @(3).CharsAfter = "bmi" }'
		])
		*/

		/* ... */

		StzRaise("FindInsideW() function is not implemented yet!")

	def FindInsideWXT(pcTemplate, pcCondition) #TODO
		StzRaise("FindInsideW() function is not implemented yet!")

	  #===============================================================#
	 #  FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS  #
	#===============================================================#

	def FindAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!")
		? o1.FindAsSections( "ring" )
		#--> [ [7, 10], [24, 27] ]

		*/

		if isList(pcSubStr)
			return This.FindManyAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		anFirstPos = This.FindCS(pcSubStr, pCaseSensitive)
		nLen = len(anFirstPos)

		if nLen = 0
			return []
		ok

		aResult = []

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
			
		for i = 1 to nLen
			aResult + [ anFirstPos[i], anFirstPos[i] + nLenSubStr - 1 ]
		next

		return aResult

		#< @FunctionFlunentForm

		def FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			#TODO // Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FindCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def FindCSZZQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def FindCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def FindAllAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def FindAllAsSectionsCSQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def FindAllAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)


		def FindAllCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def FindAllCSZZQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def FindAllCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def PositionsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def PositionsAsSectionsCSQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def PositionsAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def PositionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def PositionsCSZZQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def PositionsCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def FindSubStringAsSectionsCSQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def FindSubStringAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def FindSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			def FindSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

			def FindSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.FindAsSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSections(pcSubStr)
		return This.FindAsSectionsCS(pcSubStr, 1)

		#< @FunctionFluentForms

		def FindAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQRT(pcSubStr, :stzList)

		def FindAsSectionsQRT(pcSubStr, pcReturnType)
			return This.FindAsSectionsCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def FindZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def FindZZQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def FindZZQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		def FindAllAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def FindAllAsSectionsQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def FindAllAsSectionsQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)


		def FindAllZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def FindAllZZQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def FindAllZZQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		#--

		def PositionsAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def PositionsAsSectionsQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def PositionsAsSectionsQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		def PositionsZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def PositionsZZQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def PositionsZZQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		#--

		def FindSubStringAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def FindSubStringAsSectionsQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def FindSubStringAsSectionsQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		def FindSubStringZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

			def FindSubStringZZQ(pcSubStr)
				return This.FindAsSectionsQ(pcSubStr)

			def FindSubStringZZQRT(pcSubStr, pcReturnType)
				return This.FindAsSectionsQRT(pcSubStr, pcReturnType)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- D/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 ring_find([ :Default, :Forward, :Backward ], pcDirection) > 0 )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		aResult = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, 1)

		#< @FunctionAlternativeForm

		def FindDZZ(pcSubStr, pcDirection)
			return This.FindAsSectionsD(pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- S/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok

		ok

		# Doing the job

		aResult = []

		anPos1 = This.FindSTِS(pcSubStr, pnStartingAt, pCaseSensitive)

		if len(anPos1) > 0
			anPos2 = StzListOfNumbersQ(anPos1).AddedToEach(Q(pcSubStr).NumberOfChars() - 1)
			aResult = Association([ anPos1, anPos2 ])
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsST(pcSubStr, pnStartingAt)
		return This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def FindSTZZ(pcSubStr, pnStartingAt)
			return This.FindAsSectionsST(pcSubStr, pnStartingAt)

		#>

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                    #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param (because we will use it below)

		if isList(pcSubStr) and StzListQ(pcSubStr).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		anPos = This.FindSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult


	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, 1)


	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- Z/EXTENDED                      #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAllSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSTDCSZ(pcSubStr, pnStartingAt, pcDirection, 1)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- ZZ/EXTENDED                     #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, 1)

	  #=====================================================================#
	 #   FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS ANTI-SECTIONS  #
	#=====================================================================#

	def FindAsAntiSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!")

		? o1.FindAsSections("ring")
		#--> [ [7, 10], [24, 27] ]

		? o1.FindAsAntiSections("ring")
		#--> [ [1, 6], [11, 23], [28, 28] ]

		*/

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

		#< @FunctionFlunentForm

		def FindAsAntiSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsAntiSectionsCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def FindAsAntiSectionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			#TODO // Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSections(pcSubStr)
		return This.FindAsAntiSectionsCS(pcSubStr, 1)

		def FindAsAntiSectionsQ(pcSubStr)
			return This.FindAsAntiSectionsQRT(pcSubStr, :stzList)

		def FindAsAntiSectionsQRT(pcSubStr, pcReturnType)
			return This.FindAsAntiSectionsCSQRT(pcSubStr, 1, pcReturnType)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- D/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, 1)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- S/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aSections = This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsST(pcSubStr, pnStartingAt)
		return This.FindAsAntiSectionsSTCS(pcSubStr, pnStartingAt, 1)

	   #--------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS ANTISECTIONS, STARTING FROM A GIVEN  #
	 #  POSITION, AND GOING IN A GIVEN DIRECTION                    #
	#--------------------------------------------------------------#

	def FindAsAntiSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsAntiSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, 1)


	  #==============================#
	 #   NTH SUBSTRING -- EXTENDED  # 
	#==============================#

	def NthSubStringXT(n, paOption)

		cOption = ""
		pOption = []

		if isList(paOption) and
		   Q(paOption).IsOneOfTheseNamedParams([ :Between, :BetweenCS, :Where ])

			cOption = paOption[1]
			pOption = paOption[2]
		ok

		if cOption = :Between
			if isList(pOption) and StzListQ(pOption).IsPairOfStrings()
				return This.NthSubStringBetween(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BetweenCS
			if isList(pOption) and StzListQ(pOption).IsPairOfStrings()
				return This.NthSubStringBetweenCS(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BoundedBy
			
			if isString(pOption) or
			    ( isList(pOption) and StzListQ(pOption).IsPairOfStrings() )

				return This.NthSubStringBoundedBy(n, pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string or a pair of strings.")
			ok

		but cOption = :Where
			if isString(pOption)
				return This.NthSubStringW(pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string.")
			ok
		else
			stzRaise("Can't proceed. Null or unrecognized option.")
		ok

	  #------------------------------------------------#
	 #   NTH SUBSTRING WHERE A CONDITION IS VERIFIED  # 
	#------------------------------------------------#

	#TODO // Reimplement it for better performance
	#TODO // Add cases ensitivity

	def NthSubStringW(n, pcCondition)
		return This.SubStringsW()[n]

	#-- WXT

	def NthSubStringWXT(n, pcCondition)
		return This.SubStringsWXT()[n]

	  #========================================#
	 #  VISUALLY FINDING CHARS IN THE STRING  #
	#========================================#

	def VizFindCharCS(c, pCaseSensitive)
		if ObjectIsStzChar(c)
			c = c.Content()
		ok

		if NOT ( isString(c) and @IsChar(c) )
			return ""
		ok

		cResult = @@( This.Content() )
		anPos = This.FindAllCS( c, pCaseSensitive )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2

			if ring_find(anPos, i) > 0
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindCharCSQ(c, pCaseSensitive)
			return new stzString( This.VizFindCharCS(c, pCaseSenstive) )

		#>

	#-- WITHOUT CASESENSITIVITY

	def VizFindChar(c)
		return This.VizFindCharCS(c, 1)

	  #-----------------------------------------#
	 #      VISUALLY FINDING A SUBSTRING       #
	#-----------------------------------------#

	def VizFindCSXT(pcSubStr, paOptions, pCaseSensitive)

		bCase = CaseSensitive(pCaseSensitive)
		paOptions + [ :CaseSensitive, bCase ]

		return This.VizFindXT(pcSubStr, paOptions)

		#< @FunctionFluentForm

		def VizFindCSXTQ(pcSubStr, paOptions, pCaseSensitive)
			return new stzString( This.VizFindCSXT(pcSubStr, paOptions, pCaseSensitive) )

		#>

	#-- WITHOUT CASESENSitiviTY

	def VizFindXT(pcSubStr, paOptions)

		#TODO // Options check must be abstracted in a dedicated
		# function or classe to avoid dupplication adn code complexity!
		# ~> Can be named stzListOfOptions

		# Checking params

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT ( isList(paOptions) and IsHashList(paOptions) )
			StzRaise("Incorrect param type! paOptions must be a wellformed hashlist.")
		ok

		nLen = len(paOptions)
		acKeys = []

		for i = 1 to nLen
			acKeys + paOptions[i][1]
		next

		# At this level, we are sure pcSubStr is a string and
		# paOptions is a hashlist made of some of the allowed keys for boxing

		# Before going further, Delegate the work to VizFindBoxedXT()
		# when boxing is required

		if ring_find(acKeys, :Boxed) > 0 and
		   isNumber(paOptions[ :Boxed ]) and paOptions[ :Boxed ] = 1

			n = ring_find(acKeys, :boxed)
			del(paOptions, n)

			return This.VizFindBoxedXT(pcSubStr, paOptions)
		ok

		n = ring_find(acKeys, :CS)
		if n > 0 and ring_find(acKeys, :CaseSensitive) > 0
			stzRaise("Incorrect options! :CaseSensitive and its short form :CS must not be used both.")
		ok

		# Unifying the :CaseSensitive / :CS keyword

		if n > 0
			paOptions[n][1] = :CaseSensitive
		ok

		# STEP 2: Reading params values

		bCaseSensitive = 1
		if ( isString(paOptions[:CaseSensitive]) and paOptions[:CaseSensitive] != "" ) or
		   ( isNumber(paOptions[:CaseSensitive]) and (paOptions[:CaseSensitive] = 0 or paOptions[:CaseSensitive] = 1)  )

			bCaseSensitive = paOptions[:CaseSensitive]
		ok

		cPositionSign = "^"

		if isString(paOptions[:PositionSign]) and paOptions[:PositionSign] != ""
			cPositionSign = paOptions[:PositionSign]

		but isString(paOptions[:PositionChar]) and paOptions[:PositionChar] != ""
			cPositionSign = paOptions[:PositionChar]
		ok

		cBlankSign = "-"
		if isString(paOptions[:BlankSign]) and paOptions[:BlankSign] != ""
			cBlankSign = paOptions[:BlankSign]
		ok

		bNumbered = 0
		if ( isString(paOptions[:Numbered]) and paOptions[:Numbered] != "" ) or
		   ( isNumber(paOptions[:Numbered]) and ( paOptions[:Numbered] = 0 or paOptions[:Numbered] = 1 )  )

			bNumbered = paOptions[:Numbered]

		but ( isString(paOptions[:Number]) and paOptions[:Number] != "" ) or
		   ( isNumber(paOptions[:Number]) and ( paOptions[:Number] = 0 or paOptions[:Number] = 1 )  )

			bNumbered = paOptions[:Number]
		ok

		bSpacified = 0
		if ( isString(paOptions[:Spacified]) and paOptions[:Spacified] != "" ) or
		   ( isNumber(paOptions[:Spacified]) and ( paOptions[:Spacified] = 0 or paOptions[:Spacified] = 1 )  )

			bSpacified = paOptions[:Spacified]
		ok

		bSectioned = 0
		if ( isString(paOptions[:Sectioned]) and paOptions[:Sectioned] != "" ) or
		   ( isNumber(paOptions[:Sectioned]) and ( paOptions[:Sectioned] = 0 or paOptions[:Sectioned] = 1 )  )

			bSectioned = paOptions[:Sectioned]
		ok

		# STEP 3: Checking the correctness of the provided values

		bCorrect = 1
		acWhy = [] # Will host the reasons of the errors

		If NOT ( isNumber(bCaseSensitive) and (bCaseSensitive = 0 or bCaseSensitive = 1) )

			bCorrect = 0
			acWhy + ":CaseSensitive option must be a boolean"
		ok

		if NOT ( isString(cPositionSign) and @IsChar(cPositionSign) )

			bCorrect = 0
			acWhy + ":PositionSign option must be a char"
		ok

		if NOT ( isString(cBlankSign) and @IsChar(cBlankSign) )

			bCorrect = 0
			acWhy + ":BlankSign option must be char"
		ok

		if NOT cPositionSign != cBlankSign

			bCorrect = 0
			acWhy + ":PositionSign and :BlankSign options must be different"
		ok

		If NOT ( isNumber(bNumbered) and (bNumbered = 0 or bNumbered = 1) )

			bCorrect = 0
			acWhy + ":Numbered option must be a boalean"
		ok

		If NOT ( isNumber(bSpacified) and (bSpacified = 0 or bSpacified = 1) )

			bCorrect = 0
			acWhy + ":Spacified option must be a boalean"
		ok

		If NOT ( isNumber(bSectioned) and (bSectioned = 0 or bSectioned = 1) )

			bCorrect = 0
			acWhy + ":Sectioned option must be a boalean"
		ok

		if NOT bCorrect
			stzRaise([
				:Where	= "stzString.ring > vizFindXT()",
				:What	= StzListOfStringsQ(acWhy).ConcatenatedUsing(", ") + "."
			])
		ok

		# At this level, we are sure the params are well formed
		#--> Let's do the job!

		if bSpacified
			cString = This.Spacified()
		else
			cString = This.Content()
		ok

		oString = new stzString(cString)

		# Getting the positions

		anPos = oString.FindAllCS( pcSubStr,  bCaseSensitive )
		nLen = len(anPos)

		if nLen = 0
			return
		ok

		# In case sections ar requested, we add the other positions

		if bSectioned
			aSections = This.FindCSZZ(pcSubStr, bCaseSensitive)
			anPos = StzListQ(aSections).Flattened()
			cPositionSign = "'"
		ok

		# Composing the line of marquers

		nLen = oString.NumberOfChars()

		cVizLine = ""

		for i = 1 to nLen
			if ring_find(anPos, i) > 0
				cVizLine += cPositionSign
			else
				cVizLine += cBlankSign
			ok
		next

		# if sections mus be included, we craft the cVizLine accordingly

		if bSectioned

			# First we get the sections of the segments

			nLenSections = len(aSections)
			for i = 1 to nLenSections
				aSections[i][1]++
				aSections[i][2]--
			next

			# Second we fabricate the segment

			nLenSegment = StzStringQ(pcSubStr).NumberOfChars()-2
			cTempSegment = ""

			for i = 1 to nLenSegment
				cTempSegment += cBlankSign
			next

			# Finally we change cVizLine to cope with sections

			oVizLine = new stzString(cVizLine)
			oVizLine.Replace(cBlankSign, " ")
			oVizLine.ReplaceSections(aSections, cTempSegment)
			cVizLine = oVizLine.Content()

		ok

		# the vizline is finalised, we add it to the output

		cResult = oString.Content() + NL + cVizLine

		# In case a numbered line is requested, we add it

		if bNumbered

			# The idea is to use the cVizLine we already have,
			# and get a cPosLine containing numbers and spaces

			cPosLine = ring_substr2(cVizLine, cBlankSign, " ")

			nLenPos = len(anPos)
			aSections = []

			# There is a difficulty we must manage related to
			# keeping the same length of the line as cVizLine
			# whatever length the numbers have.

			# Here we deal with it:

			acPos = []

			for i = 1 to nLenPos
				cPos = ""+ anPos[i]
				acPos + cPos

				nLenNumber = len(cPos)

				n1 = anPos[i]
				n2 = n1 + nLenNumber - 1

				aSections + [ n1, n2 ]
			next

			# Now we have the sections and the numbers-in-strings
			# Let's do the job to get the cPosLine

			oStrPosLine = new stzString(cPosLine)
			cPosLine = oStrPosLine.
				   ReplaceSectionsByManyQ(aSections, acPos).
				   Content()
	
			# Finally, we add cPosLine to the result

			cResult += (NL + cPosLine)
		ok
		
		return cResult

		#< @FunctionFluentForm

		def VizFindXTQ(pcSubStr, paOptions)
			return new stzString( This.VizFindXT(pcSubStr, paOptions) )

		#>

	  #----------------------------------------------#
	 #  VISUALLY FINDING A SUBSTRING IN THE STRING  #
	#----------------------------------------------#

	def VizFindCS(pcSubStr, pCaseSensitive)
		bCaseSensitive = CaseSensitive(pCaseSensitive)
		return This.VizFindXT(pcSubStr, [ :CaseSensitive = bCaseSensitive ])

	#-- WITHOUT CASESENSITIVITY

	def VizFind(pcSubStr)
		return This.VizFindXT(pcSubStr, [ :PositionSign = "^" ])

	  #-------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING  #
	#===========================================#

	def VizFindBoxedCS(pcSubStr, pCaseSensitive)
		return This.VizFindBoxedCSXT(pcSubStr, [ :Boxed = 1 ], @CaseSensitive(pCaseSensitive))

		def VizFindBoxifiedCS(pcSubStr, pCaseSensitive)
			return This.VizFindBoxedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxed(pcSubStr)
		return This.VizFindBoxedCS(pcSubStr, 1)

		def VizFindBoxified(pcSubStr)
			return This.VizFindBoxed(pcSubStr)

	  #-------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING  #
	#-------------------------------------------#

	def VizFindBoxedRoundedCS(pcSubStr, pCaseSensitive)
		return This.VizFindBoxedCSXT(pcSubStr, [ :Boxed = 1, :Rounded = 1 ], CaseSensitive(pCaseSensitive))

		def VizFindBoxifiedRoundedCS(pcSubStr, pCaseSensitive)
			return This.VizFindBoxedRoundedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxedRounded(pcSubStr)
		return This.VizFindBoxedRoundedCS(pcSubStr, 1)

		def VisFindBoxifiedRounded(pcSubStr)
			return This.VizFindBoxedRounded(pcSubStr)

	  #-------------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING -- XT  #
	#-------------------------------------------------#

	def VizFindBoxedCSXT(pcSubstr, paOptions, pCaseSensitive)

		aHilightOption = [ :Hilighted, @Flatten( This.FindCSZZ(pcSubStr, pCaseSensitive) ) ]
		paOptions +  aHilightOption + [ :CaseSensitive, @CaseSensitive(pCaseSensitive) ]

		cResult = This.ToStzListOfChars().BoxXT(paOptions)
		return cResult

		#< @FunctionAlternativeForms

		def VizFindBoxifiedCSXT(pcSubstr, paOptions, pCaseSensitive)
			return This.VizFindBoxedCSXT(pcSubstr, paOptions, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITYs

	def VizFindBoxedXT(pcSubstr, paOptions)
		return This.VizFindBoxedCSXT(pcSubstr, paOptions, 1)

		#< @FunctionAlternativeForm

		def VizFindBoxifiedXT(pcSubstr, paOptions)
			return This.VizFindBoxedXT(pcSubstr, paOptions)

		#>

	  #===========================================#
	 #      VISUALLY FINDING A SUBSTRING -- ZZ   #
	#===========================================#

	def VizFindCSXTZZ(pcSubStr, paOptions, pCaseSensitive)

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		aResult = This.vizFindXT(pcSubStr, [
			:Sectioned = 1,
			:Numbered = 1,
			:CaseSensitive = bCaseSensitive
		])

		return aResult

	#-- WITHOUT CASESENSitiviTY

	def VizFindXTZZ(pcSubStr, paOptions)
		return This.VizFindCSXTZZ(pcSubStr, paOptions, 1)

	  #----------------------------------------------------#
	 #  VISUALLY FINDING A SUBSTRING IN THE STRING -- ZZ  #
	#----------------------------------------------------#

	def VizFindCSZZ(pcSubStr, pCaseSensitive)
		return This.VizFindCSXTZZ(pcSubStr, pCaseSensitive, [])

	#-- WITHOUT CASESENSITIVITY

	def VizFindZZ(pcSubStr)
		return This.VizFindCSXTZZ(pcSubStr, 1, [])

	  #-------------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING -- ZZ  #
	#=================================================#

	def VizFindBoxedCSZZ(pcSubStr, pCaseSensitive)
		return This.VizFindCSXTZZ(pcSubStr, [], pCaseSensitive)

		def VizFindBoxifiedCSZZ(pcSubStr, pCaseSensitive)
			return This.VizFindBoxedCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxedZZ(pcSubStr)
		return This.VizFindBoxedCSZZ(pcSubStr, 1)

		def VizFindBoxifiedZZ(pcSubStr)
			return This.VizFindBoxedZZ(pcSubStr)

	  #-------------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING -- ZZ  #
	#-------------------------------------------------#

	def VizFindBoxedRoundedCSZZ(pcSubStr, pCaseSensitive)
		return This.VizFindCSXTZZ(pcSubStr, [ :Boxed = 1, :Rounded = 1 ], pCaseSensitive)

		def VizFindBoxifiedRoundedCSZZ(pcSubStr, pCaseSensitive)
			return This.VizFindBoxedRoundedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxedRoundedZZ(pcSubStr)
		return This.VizFindBoxedRoundedCSZZ(pcSubStr, 1)

		def VisFindBoxifiedRoundedZZ(pcSubStr)
			return This.VizFindBoxedRounded(pcSubStr)

	  #----------------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING -- XT/ZZ  #
	#----------------------------------------------------#

	def VizFindBoxedCSXTZZ(pcSubstr, paOptions, pCaseSensitive)
		return This.VizFindCSXTZZ(pcSubStr, pCaseSensitive, [ :Boxed = 1 ])

		#< @FunctionAlternativeForm

		def VizFindBoxifiedCSXTZZ(pcSubstr, paOptions, pCaseSensitive)
			return This.VizFindBoxedCSXTZZ(pcSubstr, paOptions, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITYs

	def VizFindBoxedXTZZ(pcSubstr, paOptions)
		return This.VizFindBoxedCSXTZZ(pcSubstr, paOptions, 1)

		#< @FunctionAlternativeForm

		def VizFindBoxifiedXTZZ(pcSubstr, paOptions)
			return This.VizFindBoxedXTZZ(pcSubstr, paOptions)

		#>

	  #==============================================================#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION  #
	#==============================================================#

	# ~> Distance is given by the number of chars inbetween.
	# ~> The starting and target positions are not included.
	# ~> To include them, use ...ST() form of the function

	def DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)
		nResult = This.DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive) - 2
		return nResult

		def DistanceToSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DistanceTo(pcSubStr, pnStartingAt)
		return This.DistanceToCS(pcSubStr, pnStartingAt, 1)

		def DistanceToST(pcSubStr, pnStartingAt)
			return This.DistanceTo(pcSubStr, pnStartingAt)

	  #--------------------------------------------------------------------------#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION -- EXTENDED  #
	#--------------------------------------------------------------------------#

	# ~> XT form : bounds are counted in the distance

	def DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		n1 = pnStartingAt
		n2 = 0

		if isString(pcSubStr)
			n2 = This.FindNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
		
		but isNumber(pcSubStr)
			n1 = pcSubStr

		but isList(pcSubStr)

			oParam = new stzList(pcSubStr)

			if oParam.IsNextNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = This.FindNextCS(pcSubStr, pnStartingAt + 1, pCaseSensitive)

			but oParam.IsNthNextNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   ring_find([ :NextNth, :NthNext ], pcSubStr[1]) > 0 and

				   isList(pcSubStr[2]) and StzListQ(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = This.FindNextNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)
			
				ok

			but oParam.IsPreviousNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = n1
				n1 = This.FindPreviousCS(pcSubStr, pnStartingAt - 1, pCaseSensitive)

			but oParam.IsNthPreviousNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   ring_find([ :PreviousNth, :NthPrevious ], pcSubStr[1]) > 0 and
				   isList(pcSubStr[2]) and len(pcSubStr[2]) = 2 and
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = n1
					n1 = This.FindPreviousNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)

				ok

			ok

		ok

		nResult = n2 - n1 + 1

		return nResult

		def DistanceToSTCSXT(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DistanceToXT(pcSubStr, pnStartingAt)
		return This.DistanceToCSXT(pcSubStr, pnStartingAt, 1)

		def DistanceToSTXT(pcSubStr, pnStartingAt)
			return This.DistanceToXT(pcSubStr, pnStartingAt)

	  #======================================================#
	 #  CHECHING IF THE STRING IS EQUAL TO AN OTHER STRING  #
	#======================================================#

	def IsEqualToCS(pcOtherStr, pCaseSensitive)
		
		if NOT isString(pcOtherStr)
			return 0
		ok

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = 0
			pcOtherStr = lower(pcOtherStr)
			cContent = This.Lowercased()
		ok

		if pcOtherStr = cContent
			return 1
		else
			return 0
		ok

		#< @FunctionFluentForm
		# Usded for natural-coding and chains of truth

		def IsEqualToCSQ(pcOtherStr, pCaseSensitive)
			if This.IsEqualToCS(pcOtherStr, pCaseSensitive)
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsEqualCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def IsEqualCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def EqualToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def EqualToCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def EqualsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def EqualsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def HasSameContentAsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def HasSameContentAsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def HasSameValueAsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def HasSameValueAsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsEqualtCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(pcOtherStr)
		return This.IsEqualToCS(pcOtherStr, 1)

		#< @FunctionFluentForm

		def IsEqualToQ(pcOtherStr)
			return This.IsEqualToCSQ(pcOtherStr, 1)

		#>

		#< @FunctionAlternativeForms

		def EqualTo(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def EqualToQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def Equals(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def EqualsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def HasSameContentAs(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def HasSameContentAsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def HasSameValueAs(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def HasSameValueAsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtTo(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

		#>

	  #======================================#
	 #   CONTAINMENT OF A GIVEN SUBSTRING   #
	#======================================#

	def ContainsCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.indexOf() >

		# Checking params

		if isList(pcSubStr)
			return This.ContainsTheseSubStringsCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a STRING, while you are providing a " +
				   ring_type(pcSubStr) + ".")
		ok

		# Early check

		if pcSubStr = ""
			return 0
		ok

		# Resolving pCaseSensitive param

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job (Qt-side)

		_nResult_ = This.QStringObject().indexOf(pcSubStr, 0, _bCase_)
		if _nResult_ >= 0
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def ContainsSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#-- Used for chains of truth

		def ContainingCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

			def ContainingCSQ(pcSubStr, pCaseSensitive)
				if This.ContainsCS(pcSubStr, pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionNegativeForm

		def ContainsNoCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

			def ContainsNoCSQ(pcSubStr, pCaseSensitive)
				if This.ContainsNoCS(pcSubStr, pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		def DoesNotContainCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

			def DoesNotContainCSQ(pcSubStr, pCaseSensitive)
				return This.ContainsNoCSQ(pcSubStr, pCaseSensitive)

		#--

		def ContainingNoCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

			def ContainingNoCSQ(pcSubStr, pCaseSensitive)
				return This.ContainsNoCSQ(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		def ConttainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Contains(pcSubStr)
		return This.ContainsCS(pcSubstr, 1)

		#< @FunctionAlternativeForm

		def ContainsSubString(pcSubStr)
			return This.Contains(pcSubStr)

		#-- Used for chains of truth

		def Containing(pcSubStr)
			return This.Contains(pcSubStr)

			def ContainingQ(pcSubStr)
				if This.Contains(pcSubStr)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionNegativeForm

		def ContainsNo(pcSubStr)
			return NOT This.Contains(pcSubStr)

			def ContainsNoQ(pcSubStr)
				if This.ContainsNo(pcSubStr)
					return This
				else
					return AFalseObject()
				ok

		def DoesNotContain(pcSubStr)
			return NOT This.Contains(pcSubStr)

			def DoesNotContainQ(pcSubStr)
				return This.ContainsNoQ(pcSubStr)

		#--

		def ContainingNo(pcSubStr)
			return NOT This.Contains(pcSubStr)

			def ContainingNoQ(pcSubStr)
				return This.ContainsNoQ(pcSubStr)

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pcSubStr)
			return This.Contains(pcSubStr)

		def Conttains(pcSubStr)
			return This.Contains(pcSubStr)

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS NO ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def ContainsNoOneOfTheseCS(pacSubStr, pCaseSensitive)

		if CheckingParams()
			if NOT ( isList(pacSubStr) and IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		nLen = len(pacSubStr)
		bResult = 1

		for i = 1 to nLen
			if This.ContainsSubStringCS(pacSubStr[i], pCaseSensitive)
				bResult = 0
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsNoOneOfThese(pacSubStr)
		return This.ContainsNoOneOfTheseCS(pacSubStr, 1)

	  #------------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS CONTAINED IN AN OTHER GIVEN STRING   #
	#------------------------------------------------------------------#

	def IsContainedInCS(pcOtherStr, pCaseSensitive)

		if NOT (isString(pcOtherStr) or isList(pcOtherStr))
			StzRaise("Incorrect param type! pcOtherStr must be a string or list.")
		ok

		bResult = Q(pcOtherStr).ContainsCS(This.String(), pCaseSensitive) 
		return bResult

		#< @FunctionAlternativeForms

		def IsIncludedInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		def ExistsInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		def InnCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(pcOtherStr)
		return This.IsContainedInCS(pcOtherStr, 1)

		#< @FunctionAlternativeForms

		def IsIncludedIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		def ExistsIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		def Inn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		#>

	  #------------------------------------------------#
	 #   CHECKING CONATAINMENT ON A GIVEN CONDITION   #
	#------------------------------------------------#

	def ContainsCharsWCS(pcCondition, pCaseSensitive)
		/* EXAMPLE

		? Q("__---__").ContainsXT(:CharsWhere, 'Q(This[@i]).IsEither("_", :Or = "-")')
		#--> TRUE
		*/

		bResult = This.CharsCSQ(pCaseSensitive).ContainsW(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsCharsW(pcCondition)
		return This.ContainsCharsWCS(pcCondition, 1)

	#==

	def ContainsSubStringsWCS(pcCondition, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsW(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsW(pcCondition)
			return This.ContainsSubStringsWCS(pcCondition, 1)

	#== WXT

	def ContainsCharsWCSXT(pcCondition, pCaseSensitive)

		bResult = This.CharsCSQ(pCaseSensitive).ContainsWXT(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsCharsWXT(pcCondition)
		return This.ContainsCharsWCSXT(pcCondition, 1)

	#==

	def ContainsSubStringsWCSXT(pcCondition, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsWXT(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsWXT(pcCondition)
		return This.ContainsSubStringsWCSXT(pcCondition, 1)

	  #---------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITION/SUBSTRING  #
	#---------------------------------------------------------------------------------------#

	def ContainsBeforeCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and StzListQ(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosBefore = p

		if isString(p)
			nPosBefore = This.FindLastCS(p, pCaseSensitive)
		ok

		bResult = This.ContainsInSectionCS(pcSubStr, 1, nPosBefore-1, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsBefore(pcSubStr, p)
		return This.ContainsBeforeCS(pcSubStr, p, 1)

	  #--------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITION/SUBSTRING  #
	#--------------------------------------------------------------------------------------#

	def ContainsAfterCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and StzListQ(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosAfter = p

		if isString(p)
			nPosAfter = This.FindFirstCS(p, pCaseSensitive)
		ok

		nLenSubStr = This.NumberOfChars()
		bResult = This.ContainsInSectionCS(pcSubStr, nPosAfter+1, nLenSubStr, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfter(pcSubStr, p)
		return This.ContainsAfterCS(pcSubStr, p, 1)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITION  #
	#-----------------------------------------------------------------------------#

	def ContainsBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforePosition(pcSubStr, pnPos)
		return This.ContainsBeforePositionCS(pcSubStr, pnPos, 1)

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#------------------------------------------------------------------------------#

	def ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforeSubString(pcSubStr1, pcSubStr2)
		return This.ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, 1)

	  #----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITION  #
	#----------------------------------------------------------------------------#

	def ContainsAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterPosition(pcSubStr, pnPos)
		return This.ContainsAfterPositionCS(pcSubStr, pnPos, 1)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterSubString(pcSubStr1, pcSubStr2)
		return This.ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, 1)

	  #---------------------------------------#
	 #   CHECKING CONATAINMENT -- EXTENDED   #
	#---------------------------------------#
	#NOTE // This code was so complex before I used ClaudeAI to reorganize it.
	#TODO // Do the same wit other simular functions FindXT, ReplaceXT, RemoveXT...

	#TODO // Add the same function to stzList

	def ContainsCSXT(p1, p2, pCaseSensitive)
		oP1 = Q(p1)
		oP2 = Q(p2)
	
		#=== EMPTY STRING AND BASIC CASES ===
		
		# Empty string cases
	
		if This.String() = "" and isString(p1) = :Chars and
		   (  (isList(p2)   and len(p2) = 0) or
		      (isString(p2) and p2 = ""    ) or
		      (isNumber(p2) and p2 = 0     )    )
	
			return 0
		ok
	
		if ( (isList(p1)   and len(p1) = 0) or
		     (isString(p1) and p1 = ""    ) or
		     (isNumber(p1) and p1 = 0     )    ) and
		   isString(p2) and p2 = :Chars
	
			return 0
		ok
	
		# Direct string comparison
	
		if isString(p1) and isString(p2) and
		   NOT ring_find([
			:CharsW, :CharsWhere, :SubStringsW, :SubStringsWhere
		   ], p1) > 0
	
			return This.ContainsTheseCS([p1, p2], pCaseSensitive)
		ok
	
		# Simple string pairs
	
		if isString(p1) and isList(p2)
	
			if oP2.IsPairOfStrings() and p2[1] = :And
				return This.ContainsTheseCS([p1, p2[2]], pCaseSensitive)
	
				but oP2.IsAtPositionNamedParam() and isNumber(p2[2])
					if ring_find(This.FindCS(p1, pCaseSensitive), p2[2]) > 0
						return 1
					else
						return 0
					ok
				ok
		ok
	
		#=== NUMERIC OCCURRENCES ===
	
		if isNumber(p1) and isString(p2)
			return This.ContainsNOccurrencesCS(p1, p2, pCaseSensitive)
		ok
	
		if isList(p1)
	
			if oP1.IsExactlyNamedParam()
				return This.ContainsNOccurrencesCS(p1[2], p2, pCaseSensitive)
			ok
	
			if oP1.IsMoreThenNamedParam()
				return This.ContainsMoreThenNOccurrencesCS(p1[2], p2, pCaseSensitive)
			ok
	
			if oP1.IsLessThenNamedParam()
				return This.ContainsLessThenNOccurrencesCS(p1[2], p2, pCaseSensitive)
			ok
		ok
	
		#=== BOUNDED AND BETWEEN CASES ===
	
		# Handle bounded strings
	
		if ( isString(p1) or
		     ( isList(p1) and oP1.IsSubStringNamedParam() and isString(p1[2]) ) ) and
		   isList(p2)
	
			if isList(p1)
				cString = p1[2]
			else
				cString = p1
			ok
	
			if oP2.IsBoundedByNamedParam()
				return This.ContainsSubStringBoundedByCS(cString, p2[2], pCaseSensitive)
			ok
	
			if oP2.IsBoundedByIBNamedParam()
				return This.ContainsSubStringBoundedByCSIB(cString, p2[2], pCaseSensitive)
			ok
	
			if oP2.IsBetweenNamedParam() or oP2.IsBetweenIBNamedParam()
	
				if Q(p2[2][2]).IsAndNamedParam()
					aTemp = []
					aTemp + p2[2][1] + p2[2][2][2]
					p2[2] = aTemp
				ok
	
				oP22 = Q(p2[2])
	
				if oP22.isListOfStrings()
	
					if oP2.IsBetweenNamedParam()
						return This.ContainsSubStringBetweenCS(cString, p2[2][1], p2[2][2], pCaseSensitive) :
					else
						return This.ContainsSubStringBetweenCSIB(cString, p2[2][1], p2[2][2], pCaseSensitive)
					ok
				ok
	
				if oP22.isListOfNumbers()
					return This.ContainsSubStringBetweenPositionsCS(cString, p2[2][1], p2[2][2], pCaseSensitive)
				ok
			ok
		ok
	
		#=== CHARACTER OPERATIONS ===
	
		if isString(p1) and isList(p2) and oP2.IsListOfChars()
	
			switch p1
	
			case :Chars
				return This.ContainsTheseSubStrings(p2)
			case :TheseChars
				return This.ContainsTheseSubStrings(p2)
			
			case :SomeOfTheseChars
				return This.ContainsSomeOfTheseSubStrings(p2)
	
			case :OneOfTheseChars
				return This.ContainsOneOfTheseSubStrings(p2)
	
			case :NoneOfTheseChars
				return This.ContainsNoneOfTheseSubStrings(p2)
			off
		ok
	
		if isString(p1) and (p1 = :CharsWhere or p1 = :CharsW) and isString(p2)
			return This.ContainsCharsWXT(p2)
		ok
	
		if isString(p1) and p1 = :Chars and
		   isList(p2) and oP2.IsPairOfStrings() and p2[1] = :Where
	
			return this.ContainsCharsWXT(p2[2])
		ok
	
		#=== SUBSTRING OPERATIONS ===
	
		if isString(p1) and isList(p2) and oP2.IsListOfStrings()
	
			switch p1
	
			case :SubStrings
				return This.ContainsTheseSubStringsCS(p2, pCaseSensitive)
			case :TheseSubStrings
				return This.ContainsTheseSubStringsCS(p2, pCaseSensitive)
	
			case :SomeOfTheseSubStrings
				return This.ContainsSomeOfTheseSubStringsCS(p2, pCaseSensitive)
			case :SomeOfThese
				return This.ContainsSomeOfTheseSubStringsCS(p2, pCaseSensitive)
	
			case :OneOfTheseSubStrings
				return This.ContainsOneOfTheseSubStringsCS(p2, pCaseSensitive)
			case :OneOfThese
				return This.ContainsOneOfTheseSubStringsCS(p2, pCaseSensitive)
	
			case :NoneOfTheseSubStrings
				return This.ContainsNoneOfTheseSubStringsCS(p2, pCaseSensitive)
			case :NoneOfThese
				return This.ContainsNoneOfTheseSubStringsCS(p2, pCaseSensitive)
			off
		ok
	
		#=== POSITION BASED OPERATIONS ===
	
		if ( isString(p1) or
		     ( isList(p1) and oP1.IsSubStringNamedParam() and isString(p1[2]) ) ) and
		   isList(p2)
	
			if isList(p1)
				cString = p1[2]
			else
				cString = p1
			ok
	
			if oP2.IsOneOfTheseNamedParams([ :At, :AtPosition ]) and isNumber(p2[2])
				return This.ContainsAt(p2[2], cString)
			ok
	
			if oP2.IsOneOfTheseNamedParams([ :At, :AtPositions ]) and
			   isList(p2[2]) and StzListQ(p2[2]).IsListOfNumbers()
	
				return This.ContainsAtPositions(p2[2], cString)
			ok
	
			if oP2.IsBeforeNamedParam() and StzListQ(p2[2]).IsStringOrNumber()
				return This.ContainsBefore(cString, p2[2])
			ok
	
			if oP2.IsAfterNamedParam() and StzListQ(p2[2]).IsStringOrNumber()
				return This.ContainsAfter(cString, p2[2])
			ok
	
			if oP2.IsBeforePositionNamedParam() and isNumber(p2[2])
				return This.ContainsBefore(cString, :Position = p2[2])
			ok
	
			if oP2.IsAfterPositionNamedParam() and isNumber(p2[2])
				return This.ContainsAfter(cString, :Position = p2[2])
			ok
	
			if oP2.IsInSectionNamedParam()
				return This.ContainsInSection(cString, p2[2][1], p2[2][2])
			ok
	
			if oP2.IsInSectionsNamedParam()
				return This.ContainsInSections(cString, p2[2])
			ok
		ok
	
		StzRaise("Unsupported syntax")
	
		#-- WITHOUT CASESENSITIVITY
	
		def ContainsXT(p1, p2)
			return This.ContainsCSXT(p1, p2, 1)
	
	  #----------------------------------------------#
	 #    CONTAINING ONE OF THE GIVEN SUBSTRINGS    #
	#==============================================#

	def ContainsOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = 0
		nLen = len(paSubStr)

		for i = 1 to nLen
			if This.ContainsCS( paSubStr[i],  pCaseSensitive)
				bResult = 1
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#--

		def ContainsOneOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(paSubStr)
		return This.ContainsOneOfTheseCS(paSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsAnyOfThese(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAny(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#--

		def ContainsOneOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#>

	  #-------------------------#
	 #    CONTAINING SPACES    #
	#-------------------------#

	def ContainsSpaces()
		return This.Contains(" ")

		#< @FunctionNegativeForm

		def ContainsNoSpaces()
			return NOT This.ContainsSpaces()

		#>

	  #------------------------------------------------#
	 #    CONTAINING BOTH OF THE GIVEN SUBSTRINGS     #
	#================================================#

	def ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		if isList(pcSubStr2) and StzListQ(pcSubStr2).IsAndNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		return This.ContainsEachCS( [pcSubStr1, pcSubStr2], pCaseSensitive )

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pcSubStr1, pcSubStr2)
		return This.ContainsBothCS(pcSubStr1, pcSubStr2, 1)
	
	  #----------------------------------------------------------------#
	 #    CONTAINING ONE GIVEN SUBSTRING OR AN OTHER (BUT NOT BOTH)   #
	#----------------------------------------------------------------#

	def ContainsEitherCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		if isList(pcSubStr2) and StzListQ(pcSubStr2).IsOrNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		#NOTE
		# We can solve it quickly like this:
		# return This.ContainsOnlyOneOfTheseCS([ pcStr1, pcStr2 ], pCaseSensitive)

		b1 = This.ContainsCS(pcSubStr1, pCaseSensitive)
		b2 = This.ContainsCS(pcSubStr2, pCaseSensitive)

		if (b1 = 1 and b2 = 0) or (b1 = 0 and b2 = 1)
			return 1
		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsEither(pcSubStr1, pcSubStr2)
		return This.ContainsEitherCS(pcSubStr1, pcSubStr2, 1)

	  #--------------------------------------------------#
	 #  CONTAONING ONLY ONE OF THE PROVIDED SUBSTRINGS  #
	#--------------------------------------------------#

	def ContainsOnlyOneOfTheseCS(pacSubStr, pCaseSensitive)
		if CheckingParam()
			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		if EarlyCheck()
			if len(pacSubStr) = 0
				return 0
			ok
		ok

		acSubStr = @WithoutDuplication(pacSubStr)
		nLen = len(acSubStr)

		anOccurr = []
		
		for i = 1 to nLen
			anOccurr + This.ContainsCS(acSubStr[i], pCaseSensitive)
		next
		
		nOnes  = Q(anOccurr).HowMany(1)
		nZeros = Q(anOccurr).HowMany(0)

		if nOnes = 1 and nZeros = nLen - 1
			return 1
		else
			return 0
		ok

	#-- WTIHOUT CASESENSITIVITY

	def ContainsOnlyOneOfThese(pacSubStr)
		return This.ContainsOnlyOneOfTheseCS(pacSubStr, 1)

	  #---------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING (OR MANY SUBSTRINGS) IN A GIVEN SECTION  #
	#=============================================================================================#

	def ContainsInSectionCS(p, n1, n2, pCaseSensitive)

		# Ckecking params

		if CheckingParams()
			if NOT ( isString(p) or ( isList(p) and StzListQ(p).IsListOfStrings() ) )
				StzRaise("Incorrect param type! p must be a string or list of strings.")
			ok
		ok

		# Doing the job

		if isString(p)
			return This.ContainsSubStringInSectionCS(p, n1, n2, pCaseSensitive)

		else
			return This.ContainsManySubStringsInSectionCS(p, n1, n2, pCaseSensitive)
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsInSection(p, n1, n2)
		return This.ContainsInSectionCS(p, n1, n2, 1)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING IN A GIVEN SECTION  #
	#------------------------------------------------------------------------#

	def ContainsSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		bResult = This.SectionQ(n1, n2).ContainsSubStringCS(pcSubStr, pCaseSensitive)
		return bResult

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringInSection(pcSubStr, n1, n2)
		return This.ContainsSubStringInSectionCS(pcSubStr, n1, n2, 1)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS THE GIVEN SUBSTRINGS IN A GIVEN SECTION  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)
		bResult = This.Section(n1, n2).ContainsManyCS(pacSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsManyInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsAllTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsEachOfTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringsInSection(pacSubStr, n1, n2)
		return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, 1)

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsManyInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsAllTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsEachOfTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING (OR MANY SUBSTRINGS) IN MANY SECTIONS  #
	#===========================================================================================#

	def ContainsInSectionsCS(p, panSections, pCaseSensitive)

		# Ckecking params

		if CheckingParams()
			if NOT ( isString(p) or ( isList(p) and StzListQ(p).IsListOfStrings() ) )
				StzRaise("Incorrect param type! p must be a string or list of strings.")
			ok
		ok

		# Doing the job

		if isString(p)
			return This.ContainsSubStringInSectionsCS(p, panSections, pCaseSensitive)

		else
			return This.ContainsManySubStringsInSectionsCS(p, panSections, pCaseSensitive)
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsInSections(p, panSections)
		return This.ContainsInSectionsCS(p, panSections, 1)

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING IN MANY SECTIONS  #
	#----------------------------------------------------------------------#

	def ContainsSubStringInSectionsCS(pcSubStr, panSections, pCaseSensitive)
		bResult = This.SectionsQ(panSections).EachContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringInSections(pcSubStr, panSections)
		return This.ContainsSubStringInSectionsCS(pcSubStr, panSections, 1)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS THE GIVEN SUBSTRINGS IN MANY SECTIONS  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)
		bResult = This.SectionsQ(panSections).EachContainsTheseCS(pacSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsManyInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsAllTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsEachOfTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringsInSections(pcSubStr, panSections)
		return This.ContainsSubStringsInSectionsCS(pcSubStr, panSections, 1)

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsManyInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsAllTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsEachOfTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		#>

	  #=======================================================================#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#=======================================================================#

	def NumberOfOccurrenceCSXT(pcSubStr, pacBetweenOrBoundedBy, pCaseSensitive)
		/* EXAMPLE
		
		o1 = new stzString("How many <<many>> are there in (many <<many>>): so <<many>>!")
		? o1.NumberOfOccurrenceXT(
			:OfSubString = "many",
			:BetweenSubStrings = ["<<", :and = ">>"]
			# or :BoundedBy = ["<<", :and = ">>"]
		)
		#--> 

		*/

		if isList(pcSubStr) and ( Q(pcSubStr).IsOfNamedParam() or Q(pcSubStr).IsOfSubStringNamedParam() )
			pcSubStr = pcSubStr[2]
		ok

		cBetweenOrBoundedBy = ""

		if isList(pacBetweenOrBoundedBy)

			# Resolving the case of [ ..., :And = ... ]

			if isList(pacBetweenOrBoundedBy[2]) and
				Q(pacBetweenOrBoundedBy[2]).IsAndNamedParam()
	
					pacBetweenOrBoundedBy[2] = pacBetweenOrBoundedBy[2][2]
			ok

			oParam = new stzList(pacBetweenOrBoundedBy)

			# Reading the parms wether they correspond :Between or :BoundedBy

			if oParam.IsBetweenNamedParam() or
			   oParam.IsBetweenSubStringsNamedParam() or
			   oParam.IsBetweenpositionsNamedParam()

				cBetweenOrBoundedBy = :Between
				pacBetweenOrBoundedBy = pacBetweenOrBoundedBy[2]			

			But oParam.IsBetweenIBNamedParam() or
			    oParam.IsBetweenSubStringsIBNamedParam() or
			    oParam.IsBetweenPositionsIBNamedParam()

				cBetweenOrBoundedBy = :BetweenIB
				pacBetweenOrBoundedBy = pacBetweenOrBoundedBy[2]

			but oParam.IsBoundedByNamedParam() or
			    oParam.IsBoundedBySubStringsNamedParam()

				cBetweenOrBoundedBy = :BoundedBy
				pacBetweenOrBoundedBy = pacBetweenOrBoundedBy[2]			

			But oParam.IsBoundedByIBNamedParam() or
			    oParam.IsBoundedBySubStringsIBNamedParam()

				cBetweenOrBoundedBy = :BoundedByIB
				pacBetweenOrBoundedBy = pacBetweenOrBoundedBy[2]

			ok	
		ok

		# Doing the job

		switch cBetweenOrBoundedBy
		on :Between
			nResult = This.NumberOfOccurrenceBetweenCS(pcSubStr, pacBetweenOrBoundedBy[1], pacBetweenOrBoundedBy[2], pCaseSensitive)

		on :BetweenIB
			nResult = This.NumberOfOccurrenceBetweenCSIB(pcSubStr, pacBetweenOrBoundedBy[1], pacBetweenOrBoundedBy[2], pCaseSensitive)

		on :BoundedBy
			nResult = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBetweenOrBoundedBy, pCaseSensitive)

		on :BoundedByIB
			nResult = This.NumberOfOccurrenceOfSubStringBoundedByCSIB(pcSubStr, pacBetweenOrBoundedBy, pCaseSensitive)

		other
			StzRaise("Unsupported syntax!")
		off

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceXT(pcSubStr, pacBetweenOrBoundedBy)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetweenOrBoundedBy, 1)

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) = n
			return 1
		else
			return 0
		ok

		def ContainsExactlyNOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrences(n, pcSubStr)
		return This.ContainsNOccurrencesCS(n, pcSubStr, 1)

		def ContainsExactlyNOccurrences(n, pcSubStr)
			return This.ContainsNOccurrences(n, pcSubStr)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsMoreThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) > n
			return 1
		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThenNOccurrences(n, pcSubStr)
		return This.ContainsMoreThenNOccurrencesCS(n, pcSubStr, 1)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS LESS THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsLessThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) < n
			return 1
		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsLessThenNOccurrences(n, pcSubStr)
		return This.ContainsLessThenNOccurrencesCS(n, pcSubStr, 1)

	  #==============================================#
	 #   REMOVING A SUBSTRING AT A GIVEN POSITION   #
	#==============================================#

	def RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		if CheckingParams()

			if isList(n) and isList(n)
				This.RemoveSubStringAtPositionsCS(n, pcSubStr, pCaseSensitive)
				return
			ok

		ok

		if This.ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			nRange = StzStringQ(pcSubStr).NumberOfChars()
			This.RemoveRange(n, nRange)
		ok

		#< @FunctionFluentForm

		def RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

			def RemoveSubStringAtPositionCSQ(n, pcSubStr, pCaseSensitive)
				return This.RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)

		def RemoveAtCS(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

			def RemoveAtCSQ(n, pcSubStr, pCaseSensitive)
				return This.RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)
		#>

	def SubStringAtPositionNRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubsStringAtPositionCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedAtCS(n, pcSubStr, pCaseSensitive)
			return This.SubStringAtPositionNRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAt(n, pcSubStr)
		This.RemoveSubStringAtPositionCS(n, pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringAtQ(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPosition(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)

		def RemoveAt(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)

			def RemoveAtQ(n, pcSubStr)
				return This.RemoveSubStringAtQ(n, pcSubStr)

		#>

	def SubStringAtPositionNRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveSubsStringAtPositionQ(n, pcSubStr).Content()
		return cResult

		def SubStringRemovedAt(n, pcSubStr)
			return This.SubStringAtPositionNRemoved(n, pcSubStr)

	  #-----------------------------------------------------#
	 #   REMOVING A SUBSTRING AT A SOME GIVEN POSITIONS    #
	#-----------------------------------------------------#

	def RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python rping cshar ring")
		o1.RemoveSubstringAtPositions([ 10, 20, 32, 44 ], "ring")

		? o1.Content() #--> "ring php ruby python csharp"
		*/

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		anPos = Q(panPos).SortedInAscending()

		# Doing the job

		for i = len(anPos) to 1 step -1
			n = anPos[i]

			This.RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemovedCS(panPos, pcSubStr, pCaseSensitive)

		cResult = This.
			  Copy().
			  RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive).
			  Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAtPositions(panPos, pcSubStr)
		This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsQ(panPos, pcSubStr)
			This.RemoveSubStringAtPositions(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemoved(panPos, pcSubStr)
		return This.SubStringAtPositionsRemovedCS(panPos, pcSubStr, 1)

	  #================================================#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and StzListQ(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if ( (isNumber(n)) and (isString(pcSubStr)) ) or
		   ( (isString(n)) and (isNumber(pcSubStr)) )

			return This.ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		but ( isList(n) and StzListQ(n).IsListOfNumbers() and isString(pcSubStr) ) or
		    ( isString(n) and isList(pcSubStr) and StzListQ(pcSubStr).IsListOfNumbers() )

			return This.ContainsAtPositionsCS(n, pcSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param types! n must be a number and pcSubStr must be a string or vice versa.")
		ok

		def ContainsSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

	def ContainsAt(n, pcSubStr)
		return This.ContainsAtCS(n, pcSubStr, 1)

		def ContainsSubStringAt(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

	  #------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and StzListQ(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(n) and isNumber(pcSubStr)
			temp = pcSubStr
			pcSubStr = n
			n = temp
		ok

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# ? Q("^^♥^^").ContainsAt(2, "♥")

		bResult = 0
		bContinue = 1
		i = 1

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		bResult = ring_find(anPos, n)

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		def SubStringExistsAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPosition(n, pcSubStr)
		return This.ContainsAtPositionCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		def SubStringExistsAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT GIVEN (MANY) POSITIONS   #
	#======================================================#

	def ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		if isList(panPos) and
		   Q(panPos).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			panPos = panPos[2]
		ok

		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(panPos) and isList(pcSubStr) and StzListQ(pcSubStr).IsListOfNumbers()
			temp = pcSubStr
			pcSubStr = panPos
			panPos = temp
		ok

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsListOfStrings()
			return This.ContainsSubStringsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
		ok

		bResult = 1
		nLen = len(panPos)

		for i = 1 to nLen
			if NOT This.ContainsSubStringAtPositionCS(panPos[i], pcSubStr, pCaseSensitive)
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		def ContainsSubStringAtThesePositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPositions(panPos, pcSubStr)
		return This.ContainsAtPositionsCS(panPos, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositions(panPos, pcSubStr)
			return This.ContainsAtPositions(panPos, pcSubStr)

		def ContainsSubStringAtThesePositions(panPos, pcSubStr)
			return This.ContainsAtPositions(panPos, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   CONTAINING SUBSTRINGS AT GIVEN POSITIONS    #
	#-----------------------------------------------#

	def ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if NOT ( len(panPos) = len(pacSubStr) )
			stzRaise("Incorrect values! panPos and pacSubStr lists must have same number of items.")
		ok

		bResult = 1

		#TODO // change for in with for loop --> better performance
		i = 0
		for n in panPos
			i++
			if NOT This.ContainsSubStringAtPosition(n, pacSubStr[i])
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositionsCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		def ContainsSubStringsAtCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		def ContainsManyAtCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsAtPositions(panPos, pacSubStr)
		return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositions(n, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		def ContainsSubStringsAt(panPos, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		def ContainsManyAt(panPos, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   CONTAINING SOME (ONE OR MORE) SUBSTRINGS   #
	#----------------------------------------------#

	def ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		bResult = 0

		nLen = len(pacSubStr)
		n = 0
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				n++
				if n > 1
					bResult = 1
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSomeCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		
		def ContainsSomeOfCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		def ContainsSomeOfTheseCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		def ContainsSomeOfTheseSubStringsCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMore(paSubStr)
		return This.ContainsOneOrMoreCS(paSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsSome(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)
		
		def ContainsSomeOf(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		def ContainsSomeOfThese(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		def ContainsSomeOfTheseSubStrings(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		#>

	  #------------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A SUBSTRING     #
	#------------------------------------------------#

	def ContainsNTimesCS(n, pcSubstr, pCaseSensitive)
		return This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive) = n

		def ContainsNTimesTheSubstringCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNTimesCS(n, pcSubstr, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ContainsNTimes(n, pcSubStr)
		return This.ContainsNTimesCS(n, pcSubstr, 1)

		def ContainsNTimesTheSubstring(n, pcSubstr)
			return This.ContainsNTimes(n, pcSubstr)

	  #-------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A CHAR     #
	#-------------------------------------------#

	def ContainsNTimesTheChar(n, pcChar)
		if NOT IsChar(pcChar)
			return 0
		ok
		
		return This.ContainsNTimesCS(n, pcChar, 0)

	  #-------------------------------------------------#
	 #    CONTAINING ONE OCCURRENCE OF A SUBSTRING     #
	#-------------------------------------------------#

	def ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)
		return This.ContainsNTimesCS(1, pcSubStr, pCaseSensitive)
	
		#< @FunctionAlternativeForms

		def ContainsOnlyOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		def ContainsOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOccurrence(pcSubStr)
		return This.ContainsOneOccurrenceCS(pcSubstr, 1)

		#< @FunctionAlternativeForms

		def ContainsOnlyOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		def ContainsOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		#>
			
	  #--------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THAN N OCCURRENCES OF A SUBSTRING  #
	#--------------------------------------------------------------------------#

	def ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n ust be a number.")
			ok

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr ust be a string.")
			ok
		ok

		bResult = 0

		bContinue = 1
		i = 0
		nPos = 0

		while bContinue
	
			nPos = This.FindFirstSTCS(pcSubStr, nPos + 1, pCaseSensitive)

			if nPos = 0
				bContinue = 0
			else
				i++
				if i > n
					bResult   = 1
					bContinue = 0
				ok
			ok
		end

		return bResult

		def ContainsMoreThenNCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThanNOccurrences(n, pcSubstr)
		return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, 1)

		def ContainsMoreThenN(n, pcSubStr)
			return This.ContainsMoreThanNOccurrences(n, pcSubstr)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OR MORE OCCURRENCES OF A SUBSTRING  #
	#------------------------------------------------------------------------#

	def ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)
		bResult = This.ContainsMoreThenNOccurrencesCS(n - 1, pcSubStr, pCaseSensitive)
		return bResult

		def ContainsNOrMoreCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOrMoreOccurrences(n, pcSubstr)
		return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, 1)
	
		def ContainsNOrMore(n, pcSubStr)
			return This.ContainsNOrMoreOccurrences(n, pcSubstr)

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS EACH OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	#TODO // Unify alternative namings with ContainsMay() in stzList

	def ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
		bResult = 1
		nLen = len(pacSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(pacSubStr[i], pCaseSensitive)
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsManyCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsEachOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

		#< @FunctionNegativeForms

		def ContainsNoneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoOneOfCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([ :These, :TheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsNoSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoSubStringCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseSubStrings(pacSubStr)
		return This.ContainsTheseSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def ContainsThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsMany(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEach(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOne(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		#>

		#< @FunctionNegativeForm

		def ContainsNoneOfTheseSubStrings(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoneOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNone(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoOneOf(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubStringOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubString(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #    CONTAINING CHARS IN A GIVEN SCRIPT   #
	#-----------------------------------------#

	def ContainsCharsInScript(pcScript)
		return This.ToStzText().ContainsScript(pcScript)

		#< @FunctionNegativeForm

		def ContainsNocharsInScript(pcScript)
			return NOT This.ContainsCharsInScript(pcScript)

		#>

	  #---------------------------#
	 #    CONTAINING LETTERS     #
	#---------------------------#

	def ContainsLetter(pcLetter)

		if Q(pcLetter).IsAChar() and
		   StzCharQ(pcLetter).IsLetter()

		  	return This.ContainsCS( pcLetter,  0 )
		else
			return 0
		ok

	def ContainsLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = 0

		for i = 1 to nLen
			if aoChars[i].IsLetter()
				bResult = 1
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLetters()
			return NOT This.ContainsNumbers()

		#>

	def ContainsTheseLetters(pacLetters)
		if CheckingParam()
			if NOT isList(pacLetters)
				StzRaise("Incorrect param type! pacLetters must be a alist.")
			ok
		ok

		if NOT @AreLetters(pacLetters)
			StzRaise("Incorrect param type! pacLetters must be a list of letters.")
		ok

		bResult = This.ContainsTheseCS(pacLetters, 0)
		return bResult

		def ContainsTheLetters(pacLetters)
			return This.ContainsTheseLetters(pacLetters)

	def ContainsArabicLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = 0

		for i = 1 to nLen
			if aoChars[i].IsArabicLetter()
				bResult = 1
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoArabicLetters()
			return NOT This.ContainsArabicNumbers()

		#>

	def ContainsLatinLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = 0

		for i = 1 to nLen
			if aoChars[i].IsLatinLetter()
				bResult = 1
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLatinLetters()
			return NOT This.ContainsLatinNumbers()

		#>

	def ContainsLettersInScript(pcScript)
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = 0

		for i = 1 to nLen
			if aoChars[i].IsLetterInScript(pcScript)
				bResult = 1
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLettersInScript(pcScript)
			return NOT This.ContainsNumbers(pcScript)

		#>

	  #=========================================#
	 #   SPLITTING THE STRING -- XT/EXTENDED   #
	#=========================================#

	#TODO
	# Add SplitAround(), SplitAroundPosition(), SplitAroundPositions(),
	# SplitAroundSubString(), SplitAroundSubStrings(),
	# SplitAroundSection(), SplitAroundSections()
	
	# Add ..IB() extensions to all those functions

	#todo
	# Make same feature in stzList

	#todo
	# add to...() as alternative of SplitTo..() all over the library


	def SplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pSubStrOrPos) and len(pSubStrOrPos) = 2
				
				if isList(pSubStrOrPos[2]) and StzListQ(pSubStrOrPos[2]).IsAndNamedParam()
					pSubStrOrPos[2] = pSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCS(pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositions(pSubStrOrPos[1], pSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCS(pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNParts(pSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNChars(pSubStrOrPos[2])

			but oParam.IsToPartsOfExactlyNCharsNamedParam()
				return This.SplitToPartsOfExactlyNChars(pSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsXTNamedParam()
				return This.SplitToPartsOfNCharsXT(pSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereNamedParam() or oParam.IsAtCharsWNamedParam()
				return This.SplitAtCharsW(pSubStrOrPos[2])

			but oParam.IsAtCharsWhereXTNamedParam() or oParam.IsAtCharsWXTNamedParam()
				return This.SplitAtCharsW(pSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereNamedParam() or oParam.IsAtSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereXTNamedParam() or oParam.IsAtSubStringsWXTNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			#--

			but oParam.IsBeforeCharsWhereNamedParam() or oParam.IsBeforeCharsWNamedParam()
				return This.SplitBeforeCharsW(pSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereXTNamedParam() or oParam.IsBeforeCharsWXTNamedParam()
				return This.SplitBeforeCharsW(pSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereNamedParam() or oParam.IsBeforeSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereXTNamedParam() or oParam.IsBeforeSubStringsWXTNamedParam()
				return This.SplitBeforeSubStringsW(pSubStrOrPos[2])

			#--

			but oParam.IsAfterCharsWhereNamedParam() or oParam.IsAfterCharsWNamedParam()
				return This.SplitAfterCharsW(pSubStrOrPos[2])

			but oParam.IsAfterCharsWhereXTNamedParam() or oParam.IsAfterCharsWXTNamedParam()
				return This.SplitAfterCharsW(pSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereNamedParam() or oParam.IsAfterSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereXTNamedParam() or oParam.IsAfterSubStringsWXTNamedParam()
				return This.SplitAfterSubStringsW(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitCSXTQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitCSXTQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsCSXT(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXT(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXT(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXT(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXT(pSubStrOrPos)
		return This.SplitCSXT(pSubStrOrPos, 1)

		#< @FunctionFluentForm

		def SplitXTQ(pSubStrOrPos)
			return This.SplitXTQRT(pSubStrOrPos, :stzList)

		def SplitXTQRT(pSubStrOrPos, pcReturnType)
			return This.SplitCSXTQRT(pSubStrOrPos, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitsXT(pSubStrOrPos)
			return This.SplitXT(pSubStrOrPos)

			def SplitsXTQ(pSubStrOrPos)
				return This.SplitsXTQRT(pSubStrOrPos, :stzList)

			def SplitsXTQRT(pSubStrOrPos, pcReturnType)
				return This.SplitXTQRT(pSubStrOrPos, pcReturnType)
	
		#>

	def SplittedXT(pSubStrOrPos)
		return This.SplitXT(pSubStrOrPos)

	  #----------------------------------------#
	 #  SPLITTING THE STRING -- XTZ/EXTENDED  #
	#----------------------------------------#

	def SplitCSXTZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSectionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def SplitsCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTZ(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTZQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTZQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTZQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTZQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXTZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZ(pSubStrOrPos)
		return This.SplitCSXTZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def SplitsXTZ(pSubStrOrPos)
			return This.SplitXTZ(pSubStrOrPos)

			def SplitsXTZQ(pSubStrOrPos)
				return This.SplitsXTZQRT(pSubStrOrPos, :stzList)

		def SplitsXTZQRT(pSubStrOrPos, pcReturnType)
			return This.SplitXTZQRT(pSubStrOrPos, pcReturnType)

		#>

	def SplittedXTZ(pSubStrOrPos)
		return This.SplitXTZ(pSubStrOrPos)

	  #-----------------------------------------#
	 #  SPLITTING THE STRING -- XTZZ/EXTENDED  #
	#-----------------------------------------#

	def SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def SplitsCSXTZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTZZQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTZZQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTZZQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTZZQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXTZZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZZ(pSubStrOrPos)
		return This.SplitCSXTZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def SplitsXTZZ(pSubStrOrPos)
			return This.SplitXTZZ(pSubStrOrPos)

			def SplitsXTZZQ(pSubStrOrPos)
				return This.SplitsXTZZQRT(pSubStrOrPos, :stzList)

		def SplitsXTZZQRT(pSubStrOrPos, pcReturnType)
			return This.SplitXTZZQRT(pSubStrOrPos, pcReturnType)

		#>

	def SplittedXTZZ(pSubStrOrPos)
		return This.SplitXTZZ(pSubStrOrPos)

	  #------------------------------------------#
	 #  SPLITTING THE STRING -- A GENERAL FORM  #
	#==========================================#

	def SplitCS(pSubStrOrPos, pCaseSensitive)

		if isList(pSubStrOrPos)

			oParam = StzListQ(pSubStrOrPos)

			if oParam.IsWithOrByOrUsingNamedParam()
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAtNamedParam()
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtPositionNamedParam()
				return This.SplitAtPosition(pSubStrOrPos[2])

			but oParam.IsAtPositionsNamedParam()
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsAtSectionNamedParam()
				return This.SplitAtSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAtSectionIBNamedParam()
				return This.SplitAtSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAtSectionsNamedParam()
				return This.SplitAtSections(pSubStrOrPos[2])

			but oParam.IsAtSectionsIBNamedParam()
				return This.SplitAtSectionsIB(pSubStrOrPos[2])

			but oParam.IsAtSubStringNamedParam()
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtSubStringsNamedParam()
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforePositionNamedParam()
				return This.SplitBeforePosition(pSubStrOrPos[2])

			but oParam.IsBeforePositionsNamedParam()
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsBeforeSectionNamedParam()
				return This.SplitBeforeSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsBeforeSectionIBNamedParam()
				return This.SplitBeforeSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsBeforeSectionsNamedParam()
				return This.SplitBeforeSections(pSubStrOrPos[2])

			but oParam.IsBeforeSectionsIBNamedParam()
				return This.SplitBeforeSectionsIB(pSubStrOrPos[2])

			but oParam.IsBeforeSubStringNamedParam()
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubStringsNamedParam()
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterPositionNamedParam()
				return This.SplitAfterPosition(pSubStrOrPos[2])

			but oParam.IsAfterPositionsNamedParam()
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsAfterSectionNamedParam()
				return This.SplitAfterSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAfterSectionIBNamedParam()
				return This.SplitAfterSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAfterSectionsNamedParam()
				return This.SplitAfterSections(pSubStrOrPos[2])

			but oParam.IsAfterSectionsIBNamedParam()
				return This.SplitAfterSectionsIB(pSubStrOrPos[2])

			but oParam.IsAfterSubStringNamedParam()
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterSubStringsNamedParam()
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAroundNamedParam()
				return This.SplitAroundCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAroundPositionNamedParam()
				return This.SplitAroundPosition(pSubStrOrPos[2])

			but oParam.IsAroundPositionsNamedParam()
				return This.SplitAroundPositions(pSubStrOrPos[2])

			but oParam.IsAroundSectionNamedParam()
				return This.SplitAroundSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAroundSectionIBNamedParam()
				return This.SplitAroundSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAroundSectionsNamedParam()
				return This.SplitAroundSections(pSubStrOrPos[2])

			but oParam.IsAroundSectionsIBNamedParam()
				return This.SplitAroundSectionsIB(pSubStrOrPos[2])
	
			but oParam.IsAroundSubStringNamedParam()
				return This.SplitAroundSubStringCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAroundSubStringsNamedParam()
				return This.SplitAroundSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			ok
		ok

		return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SplitCSQ(pSubStrOrPos, pCaseSensitive)
			return new stzList(This.SplitCS(pSubStrOrPos, pCaseSensitive))

		#>

		#< @FunctionAlternativeForm

		def SplitsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SplitsCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitCSQ(pSubStrOrPos, pCaseSensitive)
	
		#>

	def SplittedCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Split(pSubStrOrPos)
		return This.SplitCS(pSubStrOrPos, 1)

		#< @FunctionFluentForm

		def SplitQ(pSubStrOrPos)
			return new stzList(This.Split(pSubStrOrPos))

		#>

		#< @FunctionAlternativeForm

		def Splits(pSubStrOrPos)
			return This.Split(pSubStrOrPos)

			def SplitsQ(pSubStrOrPos)
				return This.SplitQ(pSubStrOrPos)

		#>

	def Splitted(pSubStrOrPos)
		return This.Split(pSubStrOrPos)

	  #-----------------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING OR POSITION  #
	#===============================================#

	def SplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.SplitAtSubStrings(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2][1],pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedIBParams([ :SectionIB, :ThisSectionIB ]) 
				return This.SplitAtSectionIB(pSubStrOrPos[2][1],pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.SplitAtSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitAtCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCSQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAtCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsAtCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SplitsAtCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitAtCSQ(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsAtCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitAtCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#--

		def SeparatedByCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SeparatedByCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSQRT(pSubStrOrPos, pCaseSensitive, :stzList)
	
			def SeparatedByCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitAtCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pSubStrOrPos)
		return This.SplitAtCS(pSubStrOrPos, 1)

		#< @FunctionAFluentForms

		def SplitAtQ(pSubStrOrPos)
			return This.SplitAtQRT(pSubStrOrPos, :stzList)

		def SplitAtQRT(pSubStrOrPos, pcReturnType)
			return This.SplitAtCSQRT(pSubStrOrPos, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAt(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SplitsAtQ(pSubStrOrPos)
				return This.SplitAtQ(pSubStrOrPos, :stzList)
	
			def SplitsAtQRT(pSubStrOrPos, pcReturnType)
				return This.SplitAtQRT(pSubStrOrPos, pcReturnType)
	
		#--

		def SeparatedBy(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SeparatedByQ(pSubStrOrPos)
				return This.SplitsQRT(pSubStrOrPos, :stzList)
	
			def SeparatedByR(pSubStrOrPos, pcReturnType)
				return This.SplitAtQRT(pSubStrOrPos, pcReturnType)
		
		#>

	def SplittedAt(pSubStrOrPos)
		return This.SplitAt(pSubStrOrPos)

	  #------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR POSITIONS  #
	#==========================================#

	def SplitsCSZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCS(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCS(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeFroms

		def SplitsAndTheirPositionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZ(pSubStrOrPos, pCaseSensitive)

		#--

		def SplitCSZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZ(pSubStrOrPos)
		return This.SplitsCSZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeFroms

		def SplitsAndTheirPositions(pSubStrOrPos)
			return This.SplitsZ(pSubStrOrPos)

		#--

		def SplitZ(pSubStrOrPos)
			return This.SplitsZ(pSubStrOrPos)

		#>

	  #-----------------------------------------#
	 #  GETTING THE SPLITS AND THEIR SECTIONS  #
	#-----------------------------------------#

	def SplitsCSZZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCS(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		#--

		def SplitCSZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZZ(pSubStrOrPos)
		return This.SplitsCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def SplitsAndTheirSections(pSubStrOrPos)
			return This.SplitsZZ(pSubStrOrPos)

		#--

		def SplitZZ(pSubStrOrPos)
			return This.SplitsCSZZ(pSubStrOrPos)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR POSITIONS -- U/EXTENSION  #
	#---------------------------------------------------------#

	def SplitsCSUZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCSU(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSU(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsCSU(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZ(pSubStrOrPos, pCaseSensitive)

		#--

		def UniqueSplitsCSZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZ(pSubStrOrPos, pCaseSensitive)

		def UniqueSplitsAndTheirPositionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZ(pSubStrOrPos, pCaseSensitive)

		#==

		def SplitCSUZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsUZ(pSubStrOrPos)
		return This.SplitsCSUZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsU(pSubStrOrPos)
			return This.SplitsUZ(pSubStrOrPos)

		#--

		def UniqueSplitsZ(pSubStrOrPos)
			return This.SplitsUZ(pSubStrOrPos)

		def UniqueSplitsAndTheirPositions(pSubStrOrPos)
			return This.SplitsUZ(pSubStrOrPos)

		#==

		def SplitUZ(pSubStrOrPos)
			return This.SplitsUZ(pSubStrOrPos)

		#>

	  #-------------------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR SECTIONS -- U/EXTENDED  #
	#-------------------------------------------------------#

	def SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCSU(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsCSUZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		#--

		def UniqueSplitsCSZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		def UniqueSplitsAndTheirSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		#==

		def SplitCSUZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsUZZ(pSubStrOrPos)
		return This.SplitsCSUZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsUZZ(pSubStrOrPos)
			return This.SplitsUZZ(pSubStrOrPos)

		#--

		def UniqueSplitsZZ(pSubStrOrPos)
			return This.SplitsUZZ(pSubStrOrPos)

		def UniqueSplitsAndTheirSections(pSubStrOrPos)
			return This.SplitsUZZ(pSubStrOrPos)

		#==

		def SplitUZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsUZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#===================================#

	def SplitAtPosition(n)

		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtPosition(n)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionQ(n)
			return This.SplitAtPositionQRT(n, :stzList)

		def SplitAtPositionQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitAtThisPositionQ(n)
				return This.SplitAtThisPositionQRT(n, :stzList)

			def SplitAtThisPositionQRT(n, pcReturnType)
				return This.SplitAtPositionQRT(n, pcReturnType)

		#--

		def SplitsAtPosition(n)
			return This.SplitAtPosition(n)

			def SplitsAtPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SplitsAtPositionQRT(n, pcReturnType)
				return This.SplitAtPositionQRT(n, pcReturnType)

		def SplitsThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitsAtThisPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SplitsAtThisPositionQRT(n, pcReturnType)
				return This.SplitAtPositionQRT(n, pcReturnType)

		#--

		def SeparatedByPosition(n)
			return This.SplitAtPosition(n)

			def SeparatedByPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SeparatedByPositionQRT(n, pcReturnType)
				return This.SplitAtPositionQRT(n, pcReturnType)

		#>

	def SplittedAtPosition(n)
		return This.SplitAtPositions(n)

		def SplittedAtThisPosition(n)
			return This.SplitAtPositions(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ(This.NumberOfChars()).SplitAtPositions(anPos)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionsQ(anPos)
			return This.SplitAtPositionsQRT(anPos, :stzList)

		def SplitAtPositionsQRT(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtThesePositionsQ(anPos)
				return This.SplitAtThesePositionsQRT(anPos, :stzList)
	
			def SplitAtThesePositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)

		def SplitAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtManyPositionsQ(anPos)
				return This.SplitAtManyPositionsQRT(anPos, :stzList)
	
			def SplitAtManyPositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)

		#--

		def SplitsAtPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtPositionsQ(anPos)
				return This.SplitsAtPositionsQRT(anPos, :stzList)

			def SplitsAtPositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)

		def SplitsAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtThesePositionsQ(anPos)
				return This.SplitsAtPositionsQRT(anPos, :stzList)

			def SplitsAtThesePositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)

		def SplitsAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtManyPositionsQ(anPos)
				return This.SplitsAtPositionsQRT(anPos, :stzList)

			def SplitsAtManyPositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)

		#--

		def SeparatedByPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SeparatedByPositionsQ(anPos)
				return This.SplitAtPositionsQ(anPos)

			def SeparatedByPositionsQRT(anPos, pcReturnType)
				return This.SplitAtPositionsQRT(anPos, pcReturnType)
		#>

	def SplittedAtPositions(anPos)
		return This.SplitAtPositions(anPos)

		#< @FunctionAlternativeForms

		def SplittedAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplittedAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	  #------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING   #
	#====================================#

	def SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if CheckingParams()

			if This.IsEmpty()
				return []
			ok
	
			if isList(pcSubStr) and StzListQ(pcSubStr).IsListOfStrings()
				return This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive)
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
	
		ok

		if isList(pCaseSensitive) and StzListQ(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (1 or 0).")
		ok

		return @SplitCS(This.Content(), pcSubStr, pCaseSensitive)

//		acResult = @TrimList( QStringListToList( This.QStringObject().split(pcSubStr, 0, pCaseSensitive) ) )
//		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SeparatedBySubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)

			def SeparatedBySubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSQ(pcSubStr, pCaseSensitive)

			def SeparatedBySubStringCSQRT(n, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubString(pcSubStr)
		return This.SplitAtSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def SplitAtSubStringQ(pcSubStr)
			return This.SplitAtSubStringQRT(pcSubStr, :stzList)

		def SplitAtSubStringQRT(pcSubStr, pcReturnType)
			return This.SplitAtSubStringCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAtSubString(pcSubStr)
			return This.SplitAtSubString(pcSubStr)

			def SplitsAtSubStringQ(pcSubStr)
				return This.SplitAtSubStringQ(pcSubStr)

			def SplitsAtSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQRT(pcSubStr, pcReturnType)

		def SplitAtThisSubString(pcSubStr)
			This.SplitAtThisSubStringCS(pcSubStr, 1)

			def SplitAtThisSubStringQ(pcSubStr)
				return This.AtThisSubStringQRT(pcSubStr, :stzList)
	
			def SplitAtThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQRT(pcSubStr, pcReturnType)

		def SplitsAtThisSubString(pcSubStr)
			return This.SplitAtThisSubString(pcSubStr)

			def SplitsAtThisSubStringQ(pcSubStr)
				return This.SplitAtThisSubStringQRT(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQRT(pcSubStr, pcReturnType)

		#--

		def SeparatedBySubString(pcSubStr)
			return This.SplitAtThisSubString(pcSubStr)

			def SeparatedBySubStringQ(pcSubStr)
				return This.SplitAtThisSubStringQ(pcSubStr)

			def SeparatedBySubStringQRT(n)
				return This.SplitAtSubStringQRT(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubString(pcSubStr)
		return This.SplitAtSubString(pcSubStr)

		def SplittedAtThisSubString(pcSubStr)
			return This.SplittedAtSubString(pcSubStr)

	  #---------------------------------------------#
	 #  SPLITS AT A SUBSTRING AND THEIR POSITIONS  #
	#---------------------------------------------#

	def SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
		acSplits = This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		anPos = FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		aResult = Association([ acSplits, anPos ])
		return aResult

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSZQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCSz(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSZQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSZQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCSZ(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCSZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringZ(pcSubStr)
		return This.SplitAtSubStringCSZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def SplitsAtSubStringZ(pcSubStr)
			return This.SplitAtSubStringZ(pcSubStr)

			def SplitsAtSubStringZQ(pcSubStr)
				return This.SplitAtSubStringZQ(pcSubStr)

			def SplitsAtSubStringZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQRT(pcSubStr, pcReturnType)

		def SplitAtThisSubStringZ(pcSubStr)
			This.SplitAtThisSubStringCSZ(pcSubStr, 1)

			def SplitAtThisSubStringZQ(pcSubStr)
				return This.AtThisSubStringZQRT(pcSubStr, :stzList)
	
			def SplitAtThisSubStringZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQRT(pcSubStr, pcReturnType)

		def SplitsAtThisSubStringZ(pcSubStr)
			return This.SplitAtThisSubStringZ(pcSubStr)

			def SplitsAtThisSubStringZQ(pcSubStr)
				return This.SplitAtThisSubStringZQRT(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQRT(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStringZ(pcSubStr)
		return This.SplitAtSubStringZ(pcSubStr)

		def SplittedAtThisSubStringZ(pcSubStr)
			return This.SplittedAtSubStringZ(pcSubStr)

	  #--------------------------------------------#
	 #  SPLITS AT A SUBSTRING AND THEIR SECTIONS  #
	#--------------------------------------------#

	def SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		acSplits  = This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		aSections = FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		aResult = Association([ acSplits, aSections ])
		return aResult

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSZZQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSZZQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSZZQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringZZ(pcSubStr)
		return This.SplitAtSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def SplitsAtSubStringZZ(pcSubStr)
			return This.SplitAtSubStringZZ(pcSubStr)

			def SplitsAtSubStringZZQ(pcSubStr)
				return This.SplitAtSubStringZZQ(pcSubStr)

			def SplitsAtSubStringZZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQRT(pcSubStr, pcReturnType)

		def SplitAtThisSubStringZZ(pcSubStr)
			This.SplitAtThisSubStringCSZZ(pcSubStr, 1)

			def SplitAtThisSubStringZZQ(pcSubStr)
				return This.AtThisSubStringZZQRT(pcSubStr, :stzList)
	
			def SplitAtThisSubStringZZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQRT(pcSubStr, pcReturnType)

		def SplitsAtThisSubStringZZ(pcSubStr)
			return This.SplitAtThisSubStringZZ(pcSubStr)

			def SplitsAtThisSubStringZZQ(pcSubStr)
				return This.SplitAtThisSubStringZZQRT(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringZZQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQRT(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStringZZ(pcSubStr)
		return This.SplitAtSubStringZZ(pcSubStr)

		def SplittedAtThisSubStringZZ(pcSubStr)
			return This.SplittedAtSubStringZZ(pcSubStr)

	  #----------------------------------#
	 #   SPLITTING AT MANY SUBSTRINGS   #
	#==================================#

	def SplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if CheckingParams()

			if This.IsEmpty()
				return []
			ok
	
		ok

		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtManyCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)

			def SplitAtManyCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtTheseSubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtTheseSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtManySubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtManySubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAtSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtManyCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)

			def SplitsAtManyCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplistAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtTheseSubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtTheseSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtManySubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsCSQRT(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtManySubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStrings(pacSubStr)
		return This.SplitAtSubStringsCS(pacSubStr, 1)

		#< @FunctionFluentForm

		def SplitAtSubStringsQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsQRT(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.SplitAtSubStringsCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitAtMany(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtManyQ(pacSubStr)
				return This.SplitAtSubStringsQ(pcSubStr)

			def SplitAtManyQRT(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		def SplitAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtTheseSubStringsQ(pcSubStr)
				return This.SplitAtTheseSubStringsQRT(pcSubStr, :stzList)
	
			def SplitAtTheseSubStringsQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		def SplitAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtManySubStringsQ(pcSubStr)
				return This.SplitAtManySubStringsQRT(pcSubStr, :stzList)
	
			def SplitAtManySubStringsQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		#--

		def SplitsAtSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtSubStringsQ(pacSubStr)
				return This.SplitAtSubStringsQ(pacSubStr)

			def SplitsAtSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pacSubStr, pcReturnType)

		def SplitsAtMany(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtManyQ(pacSubStr)
				return This.SplitAtSubStringsQ(pcSubStr)

			def SplitsAtManyQRT(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		def SplistAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtTheseSubStringsQ(pcSubStr)
				return This.SplitAtTheseSubStringsQRT(pcSubStr, :stzList)
	
			def SplitsAtTheseSubStringsQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		def SplitsAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtManySubStringsQ(pcSubStr)
				return This.SplitAtManySubStringsQRT(pcSubStr, :stzList)
	
			def SplitsAtManySubStringsQRT(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQRT(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStrings(pacSubStr)
		return This.SplitAtSubStrings(pacSubStr)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtMany(pacSubStr)
			return This.SplittedAtSubStrings(pacSubStr)

		#>

	  #----------------------------------#
	 #   SPLITTING AT A GIVEN SECTION   #
	#==================================#

	def SplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionQ(n1, n2)
			return This.SplitAtSectionQRT(n1, n2, :stzList)

		def SplitAtSectionQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSection(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSection(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSection(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQRT(n1, n2, :stzList)

			def SplitAtThisSectionQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionQRT(n1, n2, pcReturnType)

		#--

		def SplitsAtSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitsAtSectionQ(n1, n2)
				return This.SplitAtThisSectionQRT(n1, n2, :stzList)

			def SplitsAtSectionQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionQRT(n1, n2, pcReturnType)

		def SplitsAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitsAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQRT(n1, n2, :stzList)

			def SplitsAtThisSectionQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionQRT(n1, n2, pcReturnType)

		#>


	def SplittedAtSection(n1, n2)
		return This.SplitAtSection(n1, n2)

		def SplittedAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

	  #-----------------------------------------------------#
	 #   SPLITTING AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-----------------------------------------------------#

	def SplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionIBQ(n1, n2)
			return This.SplitAtSectionIBQRT(n1, n2, :stzList)

		def SplitAtSectionIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQRT(n1, n2, :stzList)

			def SplitAtThisSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQRT(n1, n2, pcReturnType)

		#--

		def SplitsAtSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitsAtSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQRT(n1, n2, :stzList)

			def SplitsAtSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQRT(n1, n2, pcReturnType)

		def SplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitsAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQRT(n1, n2, :stzList)

			def SplitsAtThisSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQRT(n1, n2, pcReturnType)

		#>

	def SplittedAtSectionIB(n1, n2)
		return This.SplitAtSectionIB(n1, n2)

		def SplittedAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

	  #--------------------------------#
	 #   SPLITTING AT MANY SECTIONS   #
	#--------------------------------#

	def SplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aTempSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSections(paSections)
		acResult = This.Sections( aTempSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsQ(n1, n2)
			return This.SplitAtSectionsQRT(n1, n2, pcReturnType)

		def SplitAtSectionsQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSections(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSections(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSections(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQRT(paSections, :stzList)

			def SplitAtTheseSectionsQRT(paSections, pcReturnType)
				return This.SplitAtSectionsQRT(paSections, pcReturnType)

		#--

		def SplitsAtSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitsAtSectionsQ(paSections)
				return This.SplitAtTheseSectionsQRT(paSections, :stzList)

			def SplitsAtSectionsQRT(paSections, pcReturnType)
				return This.SplitAtSectionsQRT(paSections, pcReturnType)

		def SplitsAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitsAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQRT(paSections, :stzList)

			def SplitsAtTheseSectionsQRT(paSections, pcReturnType)
				return This.SplitAtSectionsQRT(paSections, pcReturnType)

		#>

	def SplittedAtSections(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSections(paSections)
			return This.SplittedAtSections(paSections)

	  #---------------------------------------------------#
	 #   SPLITTING AT MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------#

	def SplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionsIB(paSections)
		acResult = This.Sections( paSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsIBQ(n1, n2)
			return This.SplitAtSectionsIBQRT(n1, n2, pcReturnType)

		def SplitAtSectionsIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionsIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQRT(paSections, :stzList)

			def SplitAtTheseSectionsIBQRT(paSections, pcReturnType)
				return This.SplitAtSectionsIBQRT(paSections, pcReturnType)

		#--

		def SplitsAtSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitsAtSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQRT(paSections, :stzList)

			def SplitsAtSectionsIBQRT(paSections, pcReturnType)
				return This.SplitAtSectionsIBQRT(paSections, pcReturnType)

		def SplitsAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitsAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQRT(paSections, :stzList)

			def SplitsAtTheseSectionsIBQRT(paSections, pcReturnType)
				return This.SplitAtSectionsIBQRT(paSections, pcReturnType)

		#>

	def SplittedAtSectionsIB(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSectionsIB(paSections)
			return This.SplittedAtSections(paSections)

	  #----------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION OR SUBSTRING   #
	#====================================================#

	def SplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		oParam = Q(pSubStrOrPos)

		if isString(pSubStrOrPos)
			return This.SplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and oParam.IsListOfStrings()
			return This.SplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and oParam.IsListOfNumbers()
			return This.SplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and oParam.IsPairOfNumbers()
			return This.SplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and oParam.IsListOfPairsOfNumbers()
			return This.SplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2][1], pSubStrOrPos[2][1])
	
			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.SplitBeforeSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][1])
	
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.SplitBeforeSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCSQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitBeforeCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitsBeforeCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

			def SplitsBeforeCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)

			def SplitsBeforeCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitBeforeCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>


	def SplittedBeforeCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBefore(pSubStrOrPos)
		return This.SplitBeforeCS(pSubStrOrPos, 1)

		#< @FunctionFluentForms

		def SplitBeforeQ(pSubStrOrPos)
			return This.SplitBeforeQRT(pSubStrOrPos, :stzList)

		def SplitBeforeQRT(pSubStrOrPos, pcReturnType)
			return This.SplitBeforeCSQRT(pSubStrOrPos, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsBefore(pSubStrOrPos)
			return This.SplitBefore(pSubStrOrPos)

			def SplitsBeforeQ(pSubStrOrPos)
				return This.SplitBeforeQ(pSubStrOrPos)

			def SplitsBeforeQRT(pSubStrOrPos, pcReturnType)
				return This.SplitBeforeQRT(pSubStrOrPos, pcReturnType)

		#>

	def SplittedBefore(pSubStrOrPos)
		return This.SplitBefore(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitBeforePosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforePositionQ(n)
			return This.SplitBeforePositionQRT(n, :stzList)

		def SplitBeforePositionQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitBeforeThisPositionQ(n)
				return This.SplitBeforeThisPositionQRT(n, :stzList)

			def SplitBeforeThisPositionQRT(n, pcReturnType)
				return This.SplitBeforePositionQRT(n, pcReturnType)

		#--

		def SplitsBeforePosition(n)
			return This.SplitBeforePosition(n)

			def SplitsBeforePositionQ(n)
				return This.SplitBeforePositionQ(n)

			def SplitsBeforePositionQRT(n, pcReturnType)
				return This.SplitBeforePositionQRT(n, pcReturnType)

		def SplitsBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitsBeforeThisPositionQ(n)
				return This.SplitBeforePositionQ(n)

			def SplitsBeforeThisPositionQRT(n, pcReturnType)
				return This.SplitBeforePositionQRT(n, pcReturnType)
		#>

	def SplittedBeforePosition(n)
		return This.SplitBeforePosition(n)

		def SplittedBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(anPos)

		if CheckingParams()
			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		if This.IsEmpty()
			return []
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult			

		#< @FunctionFluentForms

		def SplitBeforePositionsQ(anPos)
			return This.SplitBeforePositionsQRT(anPos, :stzList)

		def SplitBeforePositionsQRT(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThesePositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeThesePositionsQ(anPos)
				return This.SplitBeforThesePositionsQRT(anPos, :stzList)

			def SplitBeforeThesePositionsQRT(anPos, pcReturnType)
				return This.SplitBeforePositionsQRT(anPos, pcReturnType)

		def SplitBeforeManyPositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeManyPositionsQ(anPos)
				return This.SplitBeforeManyPositionsQRT(anPos, :stzList)

			def SplitBeforeManyPositionsQRT(anPos, pcReturnType)
				return This.SplitBeforePositionsQRT(anPos, pcReturnType)

		#>

	def SplittedBeforePositions(anPos)
		return This.SplitBeforePositions(anPos)

		def SplittedBeforeThesePoitions(anPos)
			return This.SplittedBeforePositions(anPos)

		def SplittedBeforeManyPoitions(anPos)
			return This.SplittedBeforePositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitBeforeThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)

			def SplitBeforeThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsBeforeSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsBeforeSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsBeforeThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsBeforeThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		#>
				
	def SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubString(pcSubStr)
		return This.SplitBeforeSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForms

		def SplitBeforeSubStringQ(pcSubStr)
			return This.SplitBeforeSubStringQRT(pcSubStr, :stzList)

		def SplitBeforeSubStringQRT(pcSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubString(pcSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitBeforeThisSubStringQ(pcSubStr)
				return This.SplitBeforeThisSubStringQRT(pcSubStr, :stzList)

			def SplitBeforeThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQRT(pcSubStr, pcReturnType)

		#--

		def SplitsBeforeSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitsBeforeSubStringQ(pcSubStr)
				return This.SplitBeforeSubStringQ(pcSubStr)

			def SplitsBeforeSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQ(pcSubStr, pcReturnType)

		def SplitsBeforeThisSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitsBeforeThisSubStringQ(pcSubStr)
				return This.SplitBeforeSubStringQ(pcSubStr)

			def SplitsBeforeThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQ(pcSubStr, pcReturnType)

		#>

	def SplittedBeforeSubString(pcSubStr)
		return This.SplitBeforeSubString(pcSubStr)

		def SplittedBeforeThisSubString(pcSubStr)
			return This.SplittedBeforeSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeManySubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeManySubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitsBeforeTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeManySubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitsBeforeManySubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStringsCS(pacSubStr, 1)
	
		#< @FunctionFluentForms

		def SplitBeforeSubStringsQ(pacSubStr)
			return This.SplitBeforeSubStringsQRT(pacSubStr, :stzList)

		def SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeTheseSubStringsQ(pacSubStr)
				return This.SplitBeforeThisSubStringsQRT(pacSubStr, :stzList)

			def SplitBeforeTheseSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)

		def SplitBeforeManySubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeManySubStringsQ(pacSubStr)
				return This.SplitBeforeManySubStringsQRT(pacSubStr, :stzList)

			def SplitBeforeManySubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)

		#--

		def SplitsBeforeSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeSubStringsQ(pacSubStr)
				return This.SplitBeforeSubStringsQ(pacSubStr)

			def SplitsBeforeSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)

		def SplitsBeforeTheseSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeTheseSubStringsQ(pacSubStr)
				return This.SplitBeforeThisSubStringsQRT(pacSubStr, :stzList)

			def SplitsBeforeTheseSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)

		def SplitsBeforeManySubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeManySubStringsQ(pacSubStr)
				return This.SplitBeforeManySubStringsQRT(pacSubStr, :stzList)

			def SplitsBeforeManySubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQRT(pacSubStr, pcReturnType)

		#>

	def SplittedBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStrings(pacSubStr)

		def SplittedBeforeTheseSubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

		def SplittedBeforeManySubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION   #
	#--------------------------------------#

	def SplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionQ(n1, n2)
			return This.SplitBeforeSectionQRT(n1, n2, :stzList)

		def SplitBeforeSectionQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeThisSectionQRT(n1, n2, :stzList)

			def SplitBeforeThisSectionQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQRT(n1, n2, pcReturnType)

		#--

		def SplitsBeforeSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitsBeforeSectionQ(n1, n2)
				return This.SplitBeforeSectionQ(n1, n2)

			def SplitsBeforeSectionQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQRT(n1, n2, pcReturnType)

		def SplitsBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitsBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeSectionQ(n1, n2)

			def SplitsBeforeThisSectionQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQRT(n1, n2, pcReturnType)
		#>

	def SplittedBeforeSection(n1, n2)
		return This.SplitBeforeSection(n1, n2)

		def SplittedBeforeThisSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

	  #--------------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------#

	def SplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionIBQ(n1, n2)
			return This.SplitBeforeSectionIBQRT(n1, n2, :stzList)

		def SplitBeforeSectionIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeThisSectionIBQRT(n1, n2, :stzList)

			def SplitBeforeThisSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQRT(n1, n2, pcReturnType)

		#--

		def SplitsBeforeSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitsBeforeSectionIBQ(n1, n2)
				return This.SplitBeforeSectionIBQ(n1, n2)

			def SplitsBeforeSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQRT(n1, n2, pcReturnType)

		def SplitsBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitsBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeSectionIBQ(n1, n2)

			def SplitsBeforeThisSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQRT(n1, n2, pcReturnType)
		#>

	def SplittedBeforeSectionIB(n1, n2)
		return This.SplitBeforeSectionIB(n1, n2)

		def SplittedBeforeThisSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

	  #------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS   #
	#------------------------------------#

	def SplitBeforeSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsQ(paSections)
			return This.SplitBeforeSectionsQRT(paSections, :stzList)

		def SplitBeforeSectionsQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQRT(paSections, :stzList)

			def SplitBeforeTheseSectionsQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsQRT(paSections, pcReturnType)

		def SplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQRT(paSections, :stzList)

			def SplitBeforeManySectionsQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsQRT(paSections, pcReturnType)

		#--

		def SplitsBeforeSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeSectionsQ(paSections)
				return This.SplitBeforeSectionsQ(paSections)

			def SplitsBeforeSectionsQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsQRT(paSections, pcReturnType)

		def SplitsBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQRT(paSections, :stzList)

			def SplitsBeforeTheseSectionsQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsQRT(paSections, pcReturnType)

		def SplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQRT(paSections, :stzList)

			def SplitsBeforeManySectionsQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsQRT(paSections, pcReturnType)
		#>

	def SplittedBeforeSections(paSections)
		return This.SplitBeforeSections(paSections)

		def SplittedBeforeTheseSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplittedBeforeManySections(paSections)
			return This.SplittedBeforeSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#------------------------------------------------------#

	def SplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsIBQ(paSections)
			return This.SplitBeforeSectionsIBQRT(paSections, :stzList)

		def SplitBeforeSectionsIBQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>


		#< @FunctionAlternativeForms

		def SplitBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQRT(paSections, :stzList)

			def SplitBeforeTheseSectionsIBQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQRT(paSections, pcReturnType)

		def SplitBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQRT(paSections, :stzList)

			def SplitBeforeManySectionsIBQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQRT(paSections, pcReturnType)

		#--

		def SplitsBeforeSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeSectionsIBQ(paSections)
				return This.SplitBeforeSectionsIBQ(paSections)

			def SplitsBeforeSectionsIBQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQRT(paSections, pcReturnType)

		def SplitsBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQRT(paSections, :stzList)

			def SplitsBeforeTheseSectionsIBQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQRT(paSections, pcReturnType)

		def SplitsBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQRT(paSections, :stzList)

			def SplitsBeforeManySectionsIBQRT(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQRT(paSections, pcReturnType)

		#>

	def SplittedBeforeSectionsIB(paSections)
		return This.SplitBeforeSectionsIB(paSections)

		def SplittedBeforeTheseSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplittedBeforeManySectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

	  #--------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN POSITION OR SUBSTRING  #
	#==================================================#

	def SplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.SplitAfterSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.SplitAfterSectionsIB(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.SplitAfterPositions(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.SplitAfterSubStrings(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.SplitAfterSections(pSubStrOrPos)


			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitAfterCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCSQRT(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAfterCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitsAfterCS(pcSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCS(pcSubStr, pCaseSensitive)

			def SplitsAfterCSQ(pcSubStrOrPos, pCaseSensitive)
				return This.SplitAfterCSQ(pcSubStrOrPos, pCaseSensitive)

			def SplitsAfterCSQRT(pcSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitsAfterCSQRT(pcSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAfterCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfter(pSubStrOrPos)
		return This.SplitAfterCS(pSubStrOrPos, 1)

		#< @FunctionFluentForm

		def SplitAfterQ(pSubStrOrPos)
			return This.SplitAfterQRT(pSubStrOrPos, :stzList)

		def SplitAfterQRT(pSubStrOrPos, pcReturnType)
			return This.SplitAfterCSQRT(pSubStrOrPos, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAfter(pcSubStrOrPos)
			return This.SplitAfter(pcSubStr)

			def SplitsAfterQ(pcSubStrOrPos)
				return This.SplitAfterQ(pcSubStrOrPos)

			def SplitsAfterQRT(pcSubStrOrPos, pcReturnType)
				return This.SplitsAfterCSQRT(pcSubStrOrPos, pcReturnType)

		#>

	def SplittedAfter(pSubStrOrPos)
		return This.SplitAfter(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionQ(n)
			return This.SplitAfterPositionQRT(n, :stzList)

		def SplitAfterPositionQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitAfterThisPositionQ(n)
				return This.SplitAfterThisPositionQRT(n, :stzList)

			def SplitAfterThisPositionQRT(n, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		#--

		def SplitsAfterPosition(n)
			return This.SplitAfterPosition(n)

			def SplitsAfterPositionQ(n)
				return This.SplitAfterPositionQ(n)

			def SplitsAfterPositionQRT(n, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		def SplitsAfterthisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitsAfterThisPositionQ(n)
				return This.SplitAfterPositionQ(n)

			def SplitsAfterThisPositionQRT(n, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		#>

	def SplittedAfterPosition(n)
		return This.SplitAfterPosition(n)

		def SplittedAfterThisPosition(n)
			return This.SplittedAfterPosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitAfterPositions(anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionsQ(anPos)
			return This.SplitAfterPositionsQRT(anPos, :stzList)

		def SplitAfterPositionsQRT(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQRT(anPos, :stzList)

			def SplitAfterThesePositionsQRT(anPos, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		def SplitAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQRT(anPos, :stzList)

			def SplitAfterManyPositionsQRT(anPos, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		#--

		def SplitsAfterPositions(panPos)
			return This.SplitAfterPosirtions(panPos)

			def SplitsAfterPositionsQ(panPos)
				return This.SplitAfterPositionsQ(panPos)

			def SplitsAfterPositionsQRT(panPos, pcReturnType)
				return This.SplitsAfterPositionsQRT(panPos, pcReturnType)

		def SplitsAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitsAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQRT(anPos, :stzList)

			def SplitsAfterThesePositionsQRT(anPos, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		def SplitsAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitsAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQRT(anPos, :stzList)

			def SplitsAfterManyPositionsQRT(anPos, pcReturnType)
				return This.SplitAfterPositionQRT(n, pcReturnType)

		#>

	def SplittedAfterPositions(anPos)
		return This.SplitAfterPositions(anPos)

		def SplittedAfterThesePositions(anPos)
			return This.SplittedAfterPositions(anPos)

		def SplittedAfterManyPositions(anPos)
			return This.SplittedAfterPositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitAfterThisSubStringQCS(pcSubStr, pCaseSensitive)
				return This.SplitAfterThisSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)

			def SplitAfterThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAfterSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAfterSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAfterThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAfterThisSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubString(pcSubStr)
		return This.SplitAfterSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForms

		def SplitAfterSubStringQ(pcSubStr)
			return This.SplitAfterSubStringQRT(pcSubStr)

		def SplitAfterSubStringQRT(pcSubStr)
			return This.SplitAfterThisSubStringCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitAfterThisSubStringQ(pcSubStr)
				return This.SplitAfterThisSubStringQRT(pcSubStr, :stzList)

			def SplitAfterThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQRT(pcSubStr, pcReturnType)

		#--

		def SplitsAfterSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitsAfterSubStringQ(pcSubStr)
				return This.SplitAfterSubStringQ(pcSubStr)

			def SplitsAfterSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQ(pcSubStr, pcReturnType)

		def SplitsAfterThisSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitsAfterThisSubStringQ(pcSubStr)
				return This.SplitAfterSubStringQ(pcSubStr)

			def SplitsAfterThisSubStringQRT(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQ(pcSubStr, pcReturnType)

		#>

	def SplittedAfterSubString(pcSubStr)
		return This.SplitAfterSubString(pcSubStr)

		def SplittedAfterThisSubString(pcSubStr)
			return This.SplittedAfterSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterTheseSubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterManySubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterManySubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterManySubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive)

		#--

		def SplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterManySubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStringsCS(pacSubStr, 1)

		#< @FunctionFluentForms

		def SplitAfterSubStringsQ(pacSubStr)
			return This.SplitAfterSubStringsQRT(pacSubStr, :stzList)

		def SplitAfterSubStringsQRT(pacSubStr, pcReturnType)
			return This.SplitAfterSubStringsCSQRT(pacSubStr, :CaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterTheseSubStringsQ(pacSubStr)
				return This.SplitAfterTheseSubStringsQRT(pacSubStr, :stzList)

			def SplitAfterTheseSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQRT(pacSubStr, pcReturnType)

		def SplitAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterManySubStringsQ(pacSubStr)
				return This.SplitAfterManySubStringsQRT(pacSubStr, :stzList)

			def SplitAfterManySubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQRT(pacSubStr, pcReturnType)

		#--

		def SplitsAfterSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterSubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQRT(pacSubStr, pcReturnType)

		def SplitsAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterTheseSubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterTheseSubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQRT(pacSubStr, pcReturnType)

		def SplitsAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterManySubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterManySubStringsQRT(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQRT(pacSubStr, pcReturnType)

		#>

	def SplittedAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

	  #-------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION   #
	#-------------------------------------#

	def SplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSection(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionQ(n1, n2)
			return This.SplitAfterSectionQRT(n1, n2)

		def SplitAfterSectionQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitAfterThisSectionQ(n1, n2)
				return This.SplitAfterThisSectionQRT(n1, n2, :stzList)

			def SplitAfterThisSectionQRT(n1, n2, pcReturnType)
				return This.SplitAfterSectionQRT(n1, n2, pcReturnType)

		#--

		def SplitsAfterSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitsAfterSectionQ(n1, n2)
				return This.SplitAfterSectionQ(n1, n2)

			def SplitsAfteterSectionQRT(n1, n2)
				return This.SplitAfterSectionQRT(n1, n2)

		#>

	def SplittedAfterSection(n1, n2)
		return This.SplitAfterSection(n1, n2)

		def SplittedAfterThisSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

	  #-------------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-------------------------------------------------------#

	def SplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionIB(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionIBQ(n1, n2)
			return This.SplitAfterSectionIBQRT(n1, n2, :stzList)

		def SplitAfterSectionIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSectionIB(n1, n2)
			return This.SplitAfterSectionIB(n1, n2)

			def SplitAfterThisSectionIBQ(n1, n2)
				return This.SplitAfterThisSectionIBQRT(n1, n2, :stzList)

			def SplitAfterThisSectionIBQRT(n1, n2, pcReturnType)
				return This.SplitAfterSectionIBQRT(n1, n2, pcReturnType)

		#>

	def SplittedAfterSectionIB(n1, n2)
		return This.SplitAfterSectionIB(n1, n2)

		def SplittedAfterThisSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

	  #-----------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS   #
	#-----------------------------------#

	def SplitAfterSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsQ(paSections)
			return This.SplitAfterSectionsQRT(paSections, :stzList)

		def SplitAfterSectionsQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSections(paSections)
			return This.SplitAfteSections(paSections)

			def SplitAfterTheseSectionsQ(paSections)
				return This.SplitAfterTheseSectionsQRT(paSections, :stzList)

			def SplitAfterTheseSectionsQRT(paSections, pcReturnType)
				return This.SplitAfterSectionsQRT(paSections, pcReturnType)

		#>

	def SplittedAfterSections(paSections)
		return This.SplitAfterSections(paSections)

		def SplittedAfterTheseSections(paSections)
			return This.SplittedAfterSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------#

	def SplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsIBQ(paSections)
			return This.SplitAfterSectionsIBQRT(paSections, :stzList)

		def SplitAfterSectionsIBQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSectionsIB(paSections)
			return This.SplitAfteSectionsIB(paSections)

			def SplitAfterTheseSectionsIBQ(paSections)
				return This.SplitAfterTheseSectionsIBQRT(paSections, :stzList)

			def SplitAfterTheseSectionsIBQRT(paSections, pcReturnType)
				return This.SplitAfterSectionsIBQRT(paSections, pcReturnType)

		#>

	def SplittedAfterSectionsIB(paSections)
		return This.SplitAfterSectionsIB(paSections)

		def SplittedAfterTheseSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=================================================#

	def SplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSQRT(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSQRT(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCS(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetween(pBound1, pBound2)
		return This.SplitBetweenCS(pBound1, pBound2, 1)

		#< @FunctionFluentForms

		def SplitBetweenQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenQRT(Bound1, pBound2, :stzList)

		def SplitBetweenQRT(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetween(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetween(pBound1, pBound2)
		return This.SplitBetween(pBound1, pBound2)

	  #---------------------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	def SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSIBQRT(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSIBQRT(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenIB(pBound1, pBound2)
		return This.SplitBetweenCSIB(pBound1, pBound2, 1)

		#< @FunctionFluentForms

		def SplitBetweenIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenIBQRT(Bound1, pBound2, :stzList)

		def SplitBetweenIBQRT(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenIB(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenIB(pBound1, pBound2)
		return This.SplitBetweenIB(pBound1, pBound2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS   #
	#------------------------------------#

	def SplitBetweenPositions(n1, n2)
		This.SplitAtSection(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsQ(n1, n2)
			return This.SplitBetweenPositionsQRT(n1, n2, :stzList)

		def SplitBetweenPositionsQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositions(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositions(n1, n2)
			return This.SplitBetweenPositions(n1, n2)

			def SplitBetweenThesePositionsQ(n1, n2)
				return This.SplitBetweenThesePositionsQRT(n1, n2, :stzList)

			def SplitBetweenThesePositionsQRT(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsQRT(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositions(n1, n2)
		return This.SplitBetweenPositions(n1, n2)

		def SplittedBetweenThesePositions(n1, n2)
			return This.SplittedBetweenPositions(n1, n2)

	  #-------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------#

	def SplitBetweenPositionsIB(n1, n2)
		This.SplitAtSectionIB(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsIBQ(n1, n2)
			return This.SplitBetweenPositionsIBQRT(n1, n2, :stzList)

		def SplitBetweenPositionsIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositionsIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositionsIB(n1, n2)
			return This.SplitBetweenPositionsIB(n1, n2)

			def SplitBetweenThesePositionsIBQ(n1, n2)
				return This.SplitBetweenThesePositionsIBQRT(n1, n2, :stzList)

			def SplitBetweenThesePositionsIBQRT(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsIBQRT(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositionsIB(n1, n2)
		return This.SplitBetweenPositionsIB(n1, n2)

		def SplittedBetweenThesePositionsIB(n1, n2)
			return This.SplittedBetweenPositionsIB(n1, n2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO SUBSTRINGS  #
	#------------------------------------#

	def SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		acResult = This.SplitBetweenSections(aSections)
		return acResult

		#< @FunctionFluentForms

		def SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

		def SplitBetweenSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBetweenTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBetweenTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, :stzList)

			def SplitBetweenTheseSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturntype)
				return This.SplitBetweenSubStringsCSQRT(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		acResult = This.Copy().SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive).Content()
		return acResult

		def SplittedBetweenTheseSubStringsCs(pacSubStr, pCaseSensitive)
			return This.SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenSubStrings(pacSubStr)
		return This.SplitBetweenSubStringsCS(pacSubStr, 1)

		#< @FunctionFluentForms

		def SplitBetweenSubStringsQ(pacSubStr)
			return This.SplitBetweenSubStringsQRT(pacSubStr, :stzList)

		def SplitBetweenSubStringsQRT(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStrings(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStrings(pacSubStr)
			return This.SplitBetweenSubStrings(pacSubStr)

			def SplitBetweenTheseSubStringsQ(pacSubStr)
				return This.SplitBetweenTheseSubStringsQRT(pacSubStr, :stzList)

			def SplitBetweenTheseSubStringsQRT(pacSubStr, pcReturntype)
				return This.SplitBetweenSubStringsQRT(pacSubStr, pcReturnType)

		#>


	def SplittedBetweenSubStrings(pacSubStr)
		return This.SplittedBetweenSubStringsCS(pacSubStr, 1)

		def SplittedBetweenTheseSubStrings(pacSubStr)
			return This.SplittedBetweenSubStrings(pacSubStr)

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#============================#

	def SplitToNParts(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToNParts(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToNPartsQ(n)
			return This.SplitToNPartsQRT(n, :stzList)

		def SplitToNPartsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToNParts(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToNParts(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToNParts(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToNSections(n)
			return This.SplitToNParts(n)

			def SplitToNSectionsQ(n, pcReturnType)
				return This.SplitToNPartsQ(n)

			def SplitToNSectionsQRT(n, pcReturnType)
				return This.SplitToNPartsQRT(n, pcReturnType)
	
		#>

	def SplittedToNParts(n)
		return This.SplitToNParts(n)

		def SplittedToNSections(n)
			return this.SplitToNParts(n)

	  #---------------------------------------------#
	 #   SPLITTING TO PARTS OF (EXACTLY) N CHARS   #
	#---------------------------------------------#
	# Remaining part less the n chars is not returned

	def SplitToPartsOfNChars(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfNItems(n)

		aResult = This.Sections( aSections )
		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsQ(n)
			return This.SplitToPartsOfNCharsQRT(n, :stzList)

		def SplitToPartsOfNCharsQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNChars(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

			def SplitToPartsOfExactlyNCharsQ(n)
				return This.SplitToPartsOfNCharsQ(n)

			def SplitToPartsOfExactlyNCharsQRT(n, pcReturnType)
				return This.SplitToPartsOfNCharsQRT(n, pcReturnType)

		#--

		def SplitToSectionsOfNChars(n)
			return This.SplitToPartsOfNChars(n)

			def SplitToSectionsOfNCharsQ(n)
				return This.SplitToPartsOfNCharsQ(n)

			def SplitToSectionsOfNCharsQRT(n, pcReturnType)
				return This.SplitToPartsOfNCharsQRT(n, pcReturnType)

		def SplitToSectionsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

			def SplitToSectionsOfExactlyNCharsQ(n)
				return This.SplitToPartsOfNCharsQ(n)

			def SplitToSectionsOfvNCharsQRT(n, pcReturnType)
				return This.SplitToPartsOfNCharsQRT(n, pcReturnType)

		#>

	def SplittedToPartsOfNChars(n)
		return This.SplitToPartsOfNChars(n)

		def SplittedToPartsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

		def SplittedToSectionsOfNChars(n)
			return This.SplitToPartsOfNChars(n)

		def SplittedToSectionsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

	  #----------------------------------------------#
	 #   SPLITTING TO PARTS OF N CHARS -- EXTENDED  #
	#----------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def SplitToPartsOfNCharsXT(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfNItemsXT(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsXTQ(n)
			return This.SplitToPartsOfNCharsXTQRT(n, :stzList)

		def SplitToPartsOfNCharsXTQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNCharsXT(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToSectionsOfNCharsXT(n)
			return This.SplitToPartsOfNCharsXT(n)

			def SplitToSectionsOfNCharsXTQ(n)
				return This.SplitToPartsOfNCharsQ(n)

			def SplitToSectionsOfNCharsXTQRT(n, pcReturnType)
				return This.SplitToPartsOfNCharsQRT(n, pcReturnType)

		#>

	def SplittedToPartsOfNCharsXT(n)
		return This.SplitToPartsOfNCharsXT(n)

		def SplittedToSectionsOfNCharsXT(n)
			return Thhis.SplitToPartsOfNCharsXT(n)

	#--------------------------------------------------------#
	#  SPLITTING THE STRING TO PARTS HAVING THE GIVEN SIZES  #
	#--------------------------------------------------------#

	def SplitToPartsOfSizes(panSizes)

		# Checnking params

		if CheckingParams()
			if NOT ( isList(panSizes) and IsListOfNumbers(panSizes) )
				StzRaise("Incorrect param type! panSizes must be a list of numbers.")
			ok
		ok

		nLenSizes = len(panSizes)
		if nLenSizes = 0
			return []
		ok

		nLenStr = This.NumberOfChars()

		if Sum(panSizes) > nLenStr
			StzRaise("Incorrect param value! The sum of sizes exceeds the string size.")
		ok

		# Doing the job

		anSizes = ring_sort(panSizes)
		aSections = []

		nSize = 0
		n1 = 1

		for i = 1 to nLenSizes
			
			nSize + panSizes[i]
			nSize += panSizes[i]

			aSections + [ n1, nSize ]
			n1 += panSizes[i]
	
		next

		acResult = This.Sections(aSections)
		return acResult

		#< @FunctionAlternativeForms

		def SplitToPartsOfTheseSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		def SplitToPartsHavingSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		def SplitToPartsHavingTheseSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		def SplitToPartsWithSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		def SplitToPartsWithTheseSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		#--

		def SplitToSectionsOfSizes(panSizes)
			return This.SplitToPartsOfSizes(panSizes)

		def SplitToSectionsOfTheseSizes(panSizes)
			return This.SplitToSectionsOfSizes(panSizes)

		def SplitToSectionsHavingSizes(panSizes)
			return This.SplitToSectionsOfSizes(panSizes)

		def SplitToSectionsHavingTheseSizes(panSizes)
			return This.SplitToSectionsOfSizes(panSizes)

		def SplitToSectionsWithSizes(panSizes)
			return This.SplitToSectionsOfSizes(panSizes)

		def SplitToSectionsWithTheseSizes(panSizes)
			return This.SplitToSectionsOfSizes(panSizes)

		#>

	  #================================================#
	 #  SPLITTING THE STRING UNDER A GIVEN CONDITION  #
	#================================================#

	def SplitWCS(pcCondition, pCaseSensitive)
		if CheckingParams()
			if isList(pcCondition)
				oParam = new stzList(pcCondition)

				if oParam.IsAtNamedParam()
					return This.SplitAtWCS(pcCondition, pCaseSensitive)

				but oParam.IsAtPositionNamedParam()
					return This.SplitAtPositionWCS(pcCondition, pCaseSensitive)

				but oParam.IsAtPositionsNamedParam()
					return This.SplitAtPositionsWCS(pcCondition, pCaseSensitive)

				but oParam.IsAtSubStringNamedParam()
					return This.SplitAtSubStringWCS(pcCondition, pCaseSensitive)

				but oParam.IsAtSubStringsNamedParam()
					return This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive)

				#--

				but oParam.IsBeforeNamedParam()
					return This.SplitBeforeWCS(pcCondition, pCaseSensitive)

				but oParam.IsBeforePositionNamedParam()
					return This.SplitBeforePositionWCS(pcCondition, pCaseSensitive)

				but oParam.IsBeforePositionsNamedParam()
					return This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive)

				but oParam.IsBeforeSubStringNamedParam()
					return This.SplitBeforeSubStringWCS(pcCondition, pCaseSensitive)

				but oParam.IsBeforeSubStringsNamedParam()
					return This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)

				#--

				but oParam.IsAfterNamedParam()
					return This.SplitAfterWCS(pcCondition, pCaseSensitive)

				but oParam.IsAfterPositionNamedParam()
					return This.SplitAfterPositionWCS(pcCondition, pCaseSensitive)

				but oParam.IsAfterPositionsNamedParam()
					return This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive)

				but oParam.IsAfterSubStringNamedParam()
					return This.SplitAfterSubStringWCS(pcCondition, pCaseSensitive)

				but oParam.IsAfterSubStringsNamedParam()
					return This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

				#--

				but oParam.IsAroundNamedParam()
					return This.SplitAroundWCS(pcCondition, pCaseSensitive)

				but oParam.IsAroundPositionNamedParam()
					return This.SplitAroundPositionWCS(pcCondition, pCaseSensitive)

				but oParam.IsAroundPositionsNamedParam()
					return This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive)

				but oParam.IsAroundSubStringNamedParam()
					return This.SplitAroundSubStringWCS(pcCondition, pCaseSensitive)

				but oParam.IsAroundSubStringsNamedParam()
					return This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive)

				ok

			ok

			if NOT isString(pccondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		return This.SplitAtWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitW(pcCondition)
		return This.SplitWCS(pcCondition, 1)

	  #---------------------------------------------#
	 #  SPLITTiNG THE STRING AT A GIVEN CONDITION  #
	#---------------------------------------------#

	def SplitAtWCS(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPos = oCondition.ContainsCS("@position", 0)

		if bChars = 0 and bSubStr = 0 and bPos = 0
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword.")
		ok

		if bChars = 1 and
		   bSubStr = 0 and bPos = 0 and bSection = 0

			return This.SplitAtCharsWCS(pcCondition, pCaseSensitive)

		but bSubStr = 1 and
		    bChars = 0 and bPos = 0and bSection = 0

			return This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive)

		but bPos= 1 and
		    bChars = 0 and bSubStr = 0 and bSection = 0

			return This.SplitAtPositionsWCS(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitAtW(pcCondition)
		return This.SplitAWCS(pcCondition, 1)

	  #======================================================#
	 #  SPLITTING THE STRING UNDER A GIVEN CONDITION -- XT  #
	#======================================================#

	def SplitWCSXT(pcCondition, pCaseSensitive)
		if CheckingParams()
			if isList(pcCondition)
				oParam = new stzList(pcCondition)

				if oParam.IsAtNamedParam()
					return This.SplitAtWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAtCharNamedParam() or oParam.IsAtCharsNamedParam()
					return This.SplitAtCharsWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAtPositionNamedParam() or oParam.IsAtPositionsNamedParam()
					return This.SplitAtPositionWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAtSubStringNamedParam() or oParam.IsAtSubStringsNamedParam()
					return This.SplitAtSubStringWCSXT(pcCondition[2], pCaseSensitive)

				#--

				but oParam.IsBeforeCharNamedParam() or oParam.IsBeforeCharsNamedParam()
					return This.SplitBeforeCharsWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsBeforePositionNamedParam() or oParam.IsBeforePositionsNamedParam()
					return This.SplitBeforePositionWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsBeforeSubStringNamedParam() or oParam.IsBeforeSubStringsNamedParam()
					return This.SplitBeforeSubStringWCSXT(pcCondition[2], pCaseSensitive)

				#--

				but oParam.IsAfterCharNamedParam() or oParam.IsAfterCharsNamedParam()
					return This.SplitAfterCharsWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAfterPositionNamedParam() or oParam.IsAfterPositionsNamedParam()
					return This.SplitAfterPositionWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAfterSubStringNamedParam() or oParam.IsBeforeSubStringsNamedParam()
					return This.SplitAfterSubStringWCSXT(pcCondition[2], pCaseSensitive)

				#--

				but oParam.IsAroundCharNamedParam() or oParam.IsAroundCharsNamedParam()
					return This.SplitAroundCharsWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAroundPositionNamedParam() or oParam.IsAroundPositionsNamedParam()
					return This.SplitAroundPositionWCSXT(pcCondition[2], pCaseSensitive)

				but oParam.IsAroundSubStringNamedParam() or oParam.IsAroundSubStringsNamedParam()
					return This.SplitAroundSubStringWCSXT(pcCondition[2], pCaseSensitive)

				ok

			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		return This.SplitAtWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitWXT(pcCondition)
		return This.SplitWCSXT(pcCondition, 1)

	  #---------------------------------------------------#
	 #  SPLITTiNG THE STRING AT A GIVEN CONDITION -- Xt  #
	#---------------------------------------------------#

	def SplitAtWCSXT(pcCondition, pCaseSensitive)

		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPosition = oCondition.ContainsCS("@position", 0)

		if bChars = 1 and ( bSubStr = 0 and bPosition = 0 )
			return This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive)

		but bSubStr = 1 and ( bChars = 0 and bPosition = 0 )
			return This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)

		but bPosition = 1 and ( bChars = 0 and bSubStr = 0 )
			return This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitAtWXT(pcCondition)
		return This.SplitAtWCSXT(pcCondition, 1)

	  #---------------------------------------------------------#
	 #    SPLITTING AT POSITIONS VERIFYING A GIVEN CONDITION   #
	#=========================================================#

	def SplitAtPositionsWCS(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtPositionsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAtPositionsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtPositionsWCSQRT(pcCondition, pCaseSensitive pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAtPositionsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtPositionWCS(pcCondition, pCaseSensitive)
			return This.SplitAtPositionsWCS(pcCondition, pCaseSensitive)

			def SplitAtPositionWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAtPositionsWCSQ(pcCondition, pCaseSensitive)

			def SplitAtPositionWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAtPositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtPositionsWCS(pcCondition, pCaseSensitive)
		return This.SplitAtPositionsWCS(pcCondition, pCaseSensitive)

		def SplittedAtPositionWCS(pcCondition, pCaseSensitive)
			return This.SplitAtSubstringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtPositionsW(pcCondition)
		return This.SplitAtPositionsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtPositionsWQ(pcCondition)
			return This.SplitAtPositionsWQRT(pcCondition, :stzList)

		def SplitAtPositionsWQRT(pcCondition, pcReturnType)
			return This.SplitAtPositionsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAtPositionW(pcCondition)
			return This.SplitAtPositionsW(pcCondition)

			def SplitAtPositionWQ(pcCondition)
				return This.SplitAtPositionsWQ(pcCondition)

			def SplitAtPositionWQRT(pcCondition, pcReturnType)
				return This.SplitAtPositionsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAtPositionsW(pcCondition)
		return This.SplitAtPositionsW(pcCondition)

		def SplittedAtPositionW(pcCondition)
			return This.SplitAtSubstringsW(pcCondition)

	  #------------------------------------------------------------------------#
	 #    SPLITTING AT POSITIONS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def SplitAtPositionsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtPositionsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAtPositionsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive)

			def SplitAtPositionWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAtPositionsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAtPositionWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAtPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtPositionsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAtPositionsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAtPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAtSubstringsWCSXT(pcCondition, pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def SplitAtPositionsWXT(pcCondition)
		return This.SplitAtPositionsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtPositionsWXTQ(pcCondition)
			return This.SplitAtPositionsWXTQRT(pcCondition, :stzList)

		def SplitAtPositionsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAtPositionsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAtPositionWXT(pcCondition)
			return This.SplitAtPositionsWXT(pcCondition)

			def SplitAtPositionWXTQ(pcCondition)
				return This.SplitAtPositionsWXTQ(pcCondition)

			def SplitAtPositionWXTQRT(pcCondition, pcReturnType)
				return This.SplitAtPositionsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAtPositionsWXT(pcCondition)
		return This.SplitAtPositionsWXT(pcCondition)

		def SplittedAtPositionWXT(pcCondition)
			return This.SplitAtSubstringsWXT(pcCondition)

	  #-------------------------------------------------------------#
	 #    SPLITTING BEFORE POSITIONS VERIFYING A GIVEN CONDITION   #
	#=============================================================#

	def SplitBeforePositionsWCS(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSZ(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforePositionsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitBeforePositionsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforePositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitBeforePositionWCS(pcCondition, pCaseSensitive)
			return This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive)

			def SplitBeforePositionWCSQ(pcCondition, pCaseSensitive)
				return This.SplitBeforePositionsWCSQ(pcCondition, pCaseSensitive)

			def SplitBeforePositionWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitBeforePositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforePositionsWCS(pcCondition, pCaseSensitive)
		return This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive)

		def SplittedBeforePositionWCS(pcCondition, pCaseSensitive)
			return This.SplittedBeforePositionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforePositionsW(pcCondition)
		return This.SplitBeforePositionsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforePositionsWQ(pcCondition)
			return This.SplitBeforePositionsWQRT(pcCondition, :stzList)

		def SplitBeforePositionsWQRT(pcCondition, pcReturnType)
			return This.SplitBeforePositionsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitBeforePositionW(pcCondition)
			return This.SplitBeforePositionsW(pcCondition)

			def SplitBeforePositionWQ(pcCondition)
				return This.SplitBeforePositionsWQ(pcCondition)

			def SplitBeforePositionWQRT(pcCondition, pcReturnType)
				return This.SplitBeforePositionsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedBeforePositionsW(pcConditionà
		return This.SplitBeforePositionsW(pcCondition)

		def SplittedBeforePositionW(pcCondition)
			return This.SplittedBeforePositionsW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #    SPLITTING BEFORE POSITIONS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforePositionsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitBeforePositionsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforePositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforePositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive)

			def SplitBeforePositionWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitBeforePositionsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitBeforePositionWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitBeforePositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforePositionsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive)

		def SplittedBeforePositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedBeforePositionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforePositionsWXT(pcCondition)
		return This.SplitBeforePositionsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforePositionsWXTQ(pcCondition)
			return This.SplitBeforePositionsWXTQRT(pcCondition, :stzList)

		def SplitBeforePositionsWXTQRT(pcCondition, pcReturnType)
			return This.SplitBeforePositionsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitBeforePositionWXT(pcCondition)
			return This.SplitBeforePositionsWXT(pcCondition)

			def SplitBeforePositionWXTQ(pcCondition)
				return This.SplitBeforePositionsWXTQ(pcCondition)

			def SplitBeforePositionWXTQRT(pcCondition, pcReturnType)
				return This.SplitBeforePositionsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedBeforePositionsWXT(pcConditionà
		return This.SplitBeforePositionsWXT(pcCondition)

		def SplittedBeforePositionWXT(pcCondition)
			return This.SplittedBeforePositionsWXT(pcCondition)

	  #------------------------------------------------------------#
	 #    SPLITTING AFTER POSITIONS VERIFYING A GIVEN CONDITION   #
	#============================================================#

	def SplitAfterPositionsWCS(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAfterPositionsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterPositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitAfterPositionWCS(pcCondition, pCaseSensitive)
			return This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive)

			def SplitAfterPositionWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAfterPositionsWCSQ(pcCondition, pCaseSensitive)

			def SplitAfterPositionWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAfterPositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterPositionsWCS(pcCondition, pCaseSensitive)
		return This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive)

		def SplittedAfterPositionWCS(pcCondition, pCaseSensitive)
			return This.SplittedAfterPositionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterPositionsW(pcCondition)
		return This.SplitAfterPositionsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterPositionsWQ(pcCondition)
			return This.SplitAfterPositionsWQRT(pcCondition, :stzList)

		def SplitAfterPositionsWQRT(pcCondition, pcReturnType)
			return This.SplitAfterPositionsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterPositionW(pcCondition)
			return This.SplitAfterPositionsW(pcCondition)

			def SplitAfterPositionWQ(pcCondition)
				return This.SplitAfterPositionsWQ(pcCondition)

			def SplitAfterPositionWQRT(pcCondition, pcReturnType)
				return This.SplitAfterPositionsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAfterPositionsW(pcConditionà
		return This.SplitAfterPositionsW(pcCondition)

		def SplittedAfterPositionW(pcCondition)
			return This.SplittedAfterPositionsW(pcCondition)

	  #---------------------------------------------------------------------------#
	 #    SPLITTING AFTER POSITIONS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------#

	def SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAfterPositionsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive)

			def SplitAfterPositionWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAfterPositionsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAfterPositionWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAfterPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterPositionsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAfterPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedAfterPositionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterPositionsWXT(pcCondition)
		return This.SplitAfterPositionsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterPositionsWXTQ(pcCondition)
			return This.SplitAfterPositionsWXTQRT(pcCondition, :stzList)

		def SplitAfterPositionsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAfterPositionsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterPositionWXT(pcCondition)
			return This.SplitAfterPositionsWXT(pcCondition)

			def SplitAfterPositionWXTQ(pcCondition)
				return This.SplitAfterPositionsWXTQ(pcCondition)

			def SplitAfterPositionWXTQRT(pcCondition, pcReturnType)
				return This.SplitAfterPositionsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAfterPositionsWXT(pcConditionà
		return This.SplitAfterPositionsWXT(pcCondition)

		def SplittedAfterPositionWXT(pcCondition)
			return This.SplittedAfterPositionsWXT(pcCondition)

	  #-------------------------------------------------------------#
	 #    SPLITTING AROUND POSITIONS VERIFYING A GIVEN CONDITION   #
	#=============================================================#

	def SplitAroundPositionsWCS(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAroundPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAroundPositionsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAroundPositionsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAroundPositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitAroundPositionWCS(pcCondition, pCaseSensitive)
			return This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive)

			def SplitAroundPositionWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAroundPositionsWCSQ(pcCondition, pCaseSensitive)

			def SplitAroundPositionWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAroundPositionsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAroundPositionsWCS(pcCondition, pCaseSensitive)
		return This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive)

		def SplittedAroundPositionWCS(pcCondition, pCaseSensitive)
			return This.SplittedAroundPositionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundPositionsW(pcCondition)
		return This.SplitAroundPositionsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAroundPositionsWQ(pcCondition)
			return This.SplitAroundPositionsWQRT(pcCondition, :stzList)

		def SplitAroundPositionsWQRT(pcCondition, pcReturnType)
			return This.SplitAroundPositionsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAroundPositionW(pcCondition)
			return This.SplitAroundPositionsW(pcCondition)

			def SplitAroundPositionWQ(pcCondition)
				return This.SplitAroundPositionsWQ(pcCondition)

			def SplitAroundPositionWQRT(pcCondition, pcReturnType)
				return This.SplitAroundPositionsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAroundPositionsW(pcConditionà
		return This.SplitAroundPositionsW(pcCondition)

		def SplittedAroundPositionW(pcCondition)
			return This.SplittedAroundPositionsW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #    SPLITTING AROUND SBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAroundPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAroundPositionsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAroundPositionsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAroundPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfPositions
				return new stzListOfPositions( This.SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAroundPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive)

			def SplitAroundPositionWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAroundPositionsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAroundPositionWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAroundPositionsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAroundPositionsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAroundPositionsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAroundPositionWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedAroundPositionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundPositionsWXT(pcCondition)
		return This.SplitAroundPositionsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAroundPositionsWXTQ(pcCondition)
			return This.SplitAroundPositionsWXTQRT(pcCondition, :stzList)

		def SplitAroundPositionsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAroundPositionsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAroundPositionWXT(pcCondition)
			return This.SplitAroundPositionsWXT(pcCondition)

			def SplitAroundPositionWXTQ(pcCondition)
				return This.SplitAroundPositionsWXTQ(pcCondition)

			def SplitAroundPositionWXTQRT(pcCondition, pcReturnType)
				return This.SplitAroundPositionsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAroundPositionsWXT(pcConditionà
		return This.SplitAroundPositionsWXT(pcCondition)

		def SplittedAroundPositionWXT(pcCondition)
			return This.SplittedAroundPositionsWXT(pcCondition)

	  #---------------------------------------------------------#
	 #    SPLITTING AT SUBSTRINGS VERIFYING A GIVEN CONDITION   #
	#=========================================================#

	def SplitAtSubStringsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "IIIiiiMMMmmmAAA" )
		? o1.SplitAtSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "III", "MMM", "AAA" ]
		*/

		aSections = This.FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAtSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtSubStringsWCSQRT(pcCondition, pCaseSensitive pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive)

			def SplitAtSubStringWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAtSubStringsWCSQ(pcCondition, pCaseSensitive)

			def SplitAtSubStringWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive)

		def SplittedAtSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplitAtSubstringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringsW(pcCondition)
		return This.SplitAtSubStringsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtSubStringsWQ(pcCondition)
			return This.SplitAtSubStringsWQRT(pcCondition, :stzList)

		def SplitAtSubStringsWQRT(pcCondition, pcReturnType)
			return This.SplitAtSubStringsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAtSubStringW(pcCondition)
			return This.SplitAtSubStringsW(pcCondition)

			def SplitAtSubStringWQ(pcCondition)
				return This.SplitAtSubStringsWQ(pcCondition)

			def SplitAtSubStringWQRT(pcCondition, pcReturnType)
				return This.SplitAtSubStringsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAtSubStringsW(pcCondition)
		return This.SplitAtSubStringsW(pcCondition)

		def SplittedAtSubStringW(pcCondition)
			return This.SplitAtSubstringsW(pcCondition)

	  #------------------------------------------------------------------------#
	 #    SPLITTING AT SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)
		aSections = This.FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAtSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)

			def SplitAtSubStringWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAtSubStringsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAtSubStringWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAtSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAtSubstringsWCSXT(pcCondition, pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def SplitAtSubStringsWXT(pcCondition)
		return This.SplitAtSubStringsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtSubStringsWXTQ(pcCondition)
			return This.SplitAtSubStringsWXTQRT(pcCondition, :stzList)

		def SplitAtSubStringsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAtSubStringsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAtSubStringWXT(pcCondition)
			return This.SplitAtSubStringsWXT(pcCondition)

			def SplitAtSubStringWXTQ(pcCondition)
				return This.SplitAtSubStringsWXTQ(pcCondition)

			def SplitAtSubStringWXTQRT(pcCondition, pcReturnType)
				return This.SplitAtSubStringsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAtSubStringsWXT(pcCondition)
		return This.SplitAtSubStringsWXT(pcCondition)

		def SplittedAtSubStringWXT(pcCondition)
			return This.SplitAtSubstringsWXT(pcCondition)

	  #-------------------------------------------------------------#
	 #    SPLITTING BEFORE SUBSTRINGS VERIFYING A GIVEN CONDITION   #
	#=============================================================#

	def SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeSubStringsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforeSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitBeforeSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)

			def SplitBeforeSubStringWCSQ(pcCondition, pCaseSensitive)
				return This.SplitBeforeSubStringsWCSQ(pcCondition, pCaseSensitive)

			def SplitBeforeSubStringWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)

		def SplittedBeforeSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplittedBeforeSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStringsW(pcCondition)
		return This.SplitBeforeSubStringsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWQ(pcCondition)
			return This.SplitBeforeSubStringsWQRT(pcCondition, :stzList)

		def SplitBeforeSubStringsWQRT(pcCondition, pcReturnType)
			return This.SplitBeforeSubStringsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeSubStringW(pcCondition)
			return This.SplitBeforeSubStringsW(pcCondition)

			def SplitBeforeSubStringWQ(pcCondition)
				return This.SplitBeforeSubStringsWQ(pcCondition)

			def SplitBeforeSubStringWQRT(pcCondition, pcReturnType)
				return This.SplitBeforeSubStringsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedBeforeSubStringsW(pcConditionà
		return This.SplitBeforeSubStringsW(pcCondition)

		def SplittedBeforeSubStringW(pcCondition)
			return This.SplittedBeforeSubStringsW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #    SPLITTING BEFORE SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforeSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

			def SplitBeforeSubStringWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitBeforeSubStringsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitBeforeSubStringWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

		def SplittedBeforeSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStringsWXT(pcCondition)
		return This.SplitBeforeSubStringsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWXTQ(pcCondition)
			return This.SplitBeforeSubStringsWXTQRT(pcCondition, :stzList)

		def SplitBeforeSubStringsWXTQRT(pcCondition, pcReturnType)
			return This.SplitBeforeSubStringsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeSubStringWXT(pcCondition)
			return This.SplitBeforeSubStringsWXT(pcCondition)

			def SplitBeforeSubStringWXTQ(pcCondition)
				return This.SplitBeforeSubStringsWXTQ(pcCondition)

			def SplitBeforeSubStringWXTQRT(pcCondition, pcReturnType)
				return This.SplitBeforeSubStringsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedBeforeSubStringsWXT(pcConditionà
		return This.SplitBeforeSubStringsWXT(pcCondition)

		def SplittedBeforeSubStringWXT(pcCondition)
			return This.SplittedBeforeSubStringsWXT(pcCondition)

	  #------------------------------------------------------------#
	 #    SPLITTING AFTER SUBSTRINGS VERIFYING A GIVEN CONDITION   #
	#============================================================#

	def SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

		aSections = This.FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitAfterSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

			def SplitAfterSubStringWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAfterSubStringsWCSQ(pcCondition, pCaseSensitive)

			def SplitAfterSubStringWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

		def SplittedAfterSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplittedAfterSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStringsW(pcCondition)
		return This.SplitAfterSubStringsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterSubStringsWQ(pcCondition)
			return This.SplitAfterSubStringsWQRT(pcCondition, :stzList)

		def SplitAfterSubStringsWQRT(pcCondition, pcReturnType)
			return This.SplitAfterSubStringsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterSubStringW(pcCondition)
			return This.SplitAfterSubStringsW(pcCondition)

			def SplitAfterSubStringWQ(pcCondition)
				return This.SplitAfterSubStringsWQ(pcCondition)

			def SplitAfterSubStringWQRT(pcCondition, pcReturnType)
				return This.SplitAfterSubStringsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAfterSubStringsW(pcConditionà
		return This.SplitAfterSubStringsW(pcCondition)

		def SplittedAfterSubStringW(pcCondition)
			return This.SplittedAfterSubStringsW(pcCondition)

	  #---------------------------------------------------------------------------#
	 #    SPLITTING AFTER SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------#

	def SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAfterSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

			def SplitAfterSubStringWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAfterSubStringsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAfterSubStringWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAfterSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStringsWXT(pcCondition)
		return This.SplitAfterSubStringsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterSubStringsWXTQ(pcCondition)
			return This.SplitAfterSubStringsWXTQRT(pcCondition, :stzList)

		def SplitAfterSubStringsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAfterSubStringsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterSubStringWXT(pcCondition)
			return This.SplitAfterSubStringsWXT(pcCondition)

			def SplitAfterSubStringWXTQ(pcCondition)
				return This.SplitAfterSubStringsWXTQ(pcCondition)

			def SplitAfterSubStringWXTQRT(pcCondition, pcReturnType)
				return This.SplitAfterSubStringsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAfterSubStringsWXT(pcConditionà
		return This.SplitAfterSubStringsWXT(pcCondition)

		def SplittedAfterSubStringWXT(pcCondition)
			return This.SplittedAfterSubStringsWXT(pcCondition)

	  #-------------------------------------------------------------#
	 #    SPLITTING AROUND SUBSTRINGS VERIFYING A GIVEN CONDITION   #
	#=============================================================#

	def SplitAroundSubStringsWCS(pcCondition, pCaseSensitive)

		aSections = This.FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAroundSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAroundSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAroundSubStringsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAroundSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>


		#< @FunctionAlternativeForm

		def SplitAroundSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive)

			def SplitAroundSubStringWCSQ(pcCondition, pCaseSensitive)
				return This.SplitAroundSubStringsWCSQ(pcCondition, pCaseSensitive)

			def SplitAroundSubStringWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAroundSubStringsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAroundSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive)

		def SplittedAroundSubStringWCS(pcCondition, pCaseSensitive)
			return This.SplittedAroundSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubStringsW(pcCondition)
		return This.SplitAroundSubStringsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAroundSubStringsWQ(pcCondition)
			return This.SplitAroundSubStringsWQRT(pcCondition, :stzList)

		def SplitAroundSubStringsWQRT(pcCondition, pcReturnType)
			return This.SplitAroundSubStringsWCSQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAroundSubStringW(pcCondition)
			return This.SplitAroundSubStringsW(pcCondition)

			def SplitAroundSubStringWQ(pcCondition)
				return This.SplitAroundSubStringsWQ(pcCondition)

			def SplitAroundSubStringWQRT(pcCondition, pcReturnType)
				return This.SplitAroundSubStringsWQRT(pcCondition, pcReturnType)

		#>

	def SplittedAroundSubStringsW(pcConditionà
		return This.SplitAroundSubStringsW(pcCondition)

		def SplittedAroundSubStringW(pcCondition)
			return This.SplittedAroundSubStringsW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #    SPLITTING AROUND SBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAroundSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAroundSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAroundSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAroundSubStringsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAroundSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAroundSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive)

			def SplitAroundSubStringWCSXTQ(pcCondition, pCaseSensitive)
				return This.SplitAroundSubStringsWCSXTQ(pcCondition, pCaseSensitive)

			def SplitAroundSubStringWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
				return This.SplitAroundSubStringsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)

		#>

	def SplittedAroundSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAroundSubStringsWCSXT(pcCondition, pCaseSensitive)

		def SplittedAroundSubStringWCSXT(pcCondition, pCaseSensitive)
			return This.SplittedAroundSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubStringsWXT(pcCondition)
		return This.SplitAroundSubStringsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAroundSubStringsWXTQ(pcCondition)
			return This.SplitAroundSubStringsWXTQRT(pcCondition, :stzList)

		def SplitAroundSubStringsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAroundSubStringsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAroundSubStringWXT(pcCondition)
			return This.SplitAroundSubStringsWXT(pcCondition)

			def SplitAroundSubStringWXTQ(pcCondition)
				return This.SplitAroundSubStringsWXTQ(pcCondition)

			def SplitAroundSubStringWXTQRT(pcCondition, pcReturnType)
				return This.SplitAroundSubStringsWXTQRT(pcCondition, pcReturnType)

		#>

	def SplittedAroundSubStringsWXT(pcConditionà
		return This.SplitAroundSubStringsWXT(pcCondition)

		def SplittedAroundSubStringWXT(pcCondition)
			return This.SplittedAroundSubStringsWXT(pcCondition)

	  #======================================#
	 #  SPLITTING AROUND A GIVEN CONDITION  #
	#======================================#

	def SplitAroundWCS(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPos = oCondition.ContainsCS("@position", 0)

		if bChars = 0 and bSubStr = 0 and bPos = 0
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword.")
		ok

		if bChars = 1 and
		   bSubStr = 0 and bPos = 0

			return This.SplitAroundCharsWCS(pcCondition, pCaseSensitive)

		but bSubStr = 1 and
		    bChars = 0 and bPos = 0

			return This.SplitAroundSubStringsWCS(pcCondition, pCaseSensitive)

		but bPos = 1 and
		    bChars = 0 and bSubStr = 0

			return This.SplitAroundPositionsWCS(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	  #----------------------------------------------------#
	 #    SPLITTING AT CHARS VERIFYING A GIVEN CONDITION   #
	#====================================================#

	def SplitAtCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAtCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAtCharsWQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtCharsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtCharsWCS(pcCondition, pCaseSensitive)
		return This.SplitAtCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtCharsW(pcCondition)
		return This.SplitAtCharsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtCharsWQ(pcCondition)
			return This.SplitAtCharsWQRT(pcCondition, :stzList)

		def SplitAtCharsWQRT(pcCondition, pcReturnType)
			return This.SplitAtCharsWCSQRT(pcCondition, pcReturnType)


		#>

	def SplittedAtCharsW(pcCondition)
		return This.SplitAtCharsW(pcCondition)

	  #-------------------------------------------------------------------#
	 #    SPLITTING AT CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-------------------------------------------------------------------#

	def SplitAtCharsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAtCharsWXT( 'Q(@Char).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAtCharsWXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAtCharsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtCharsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtCharsWXT(pcCondition)
		return This.SplitAtCharsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAtCharsWXTQ(pcCondition)
			return This.SplitAtCharsWXTQRT(pcCondition, :stzList)

		def SplitAtCharsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAtCharsWCSxtQRT(pcCondition, pcReturnType)


		#>

	def SplittedAtCharsWXT(pcCondition)
		return This.SplitAtCharsWXT(pcCondition)

	  #--------------------------------------------------#
	 #    SPLITTING BEFORE VERIFYING A GIVEN CONDITION   #
	#==================================================#

	def SplitBeforeWCS(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPos = oCondition.ContainsCS("@position", 0)

		if bChars = 0 and bSubStr = 0 and bPos = 0
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword.")
		ok

		if bChars = 1 and
		   bSubStr = 0 and bPos = 0 and bSection = 0

			return This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive)

		but bSubStr = 1 and
		    bChars = 0 and bPos = 0and bSection = 0

			return This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)

		but bPos= 1 and
		    bChars = 0 and bSubStr = 0 and bSection = 0

			return This.SplitBeforePositionsWCS(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeW(pcCondition)
		return This.SplitBeforeWCS(pcCondition, 1)

	  #-------------------------------------------------------#
	 #    SPLITTING BEFORE VERIFYING A GIVEN CONDITION -- XT  #
	#-------------------------------------------------------#

	def SplitBeforeWCSXT(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPosition = oCondition.ContainsCS("@position", 0)

		if bChars = 1 and ( bSubStr = 0 and bPosition = 0 )
			return This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive)

		but bSubStr = 1 and ( bChars = 0 and bPosition = 0 )
			return This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

		but bPosition = 1 and ( bChars = 0 and bSubStr = 0 )
			return This.SplitBeforePositionsWCSXT(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeWXT(pcCondition)
		return This.SplitBeforeWCSXT(pcCondition, 1)

	  #--------------------------------------------------------#
	 #    SPLITTING BEFORE CHARS VERIFYING A GIVEN CONDITION   #
	#========================================================#

	def SplitBeforeCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeCharsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeCharsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeCharsWCS(pcCondition, pCaseSensitive)
		return This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeCharsW(pcCondition)
		return This.SplitBeforeCharsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforeCharsWQ(pcCondition)
			return This.SplitBeforeCharsWQRT(pcCondition, :stzList)

		def SplitBeforeCharsWQRT(pcCondition, pcReturnType)
			return This.SplitBeforeCharsWCSQRT(pcCondition, 1, pcReturnType)

		#>

	def SplittedBeforeCharsW(pcCondition)
		return This.SplitBeforeCharsW(pcCondition)

	  #-----------------------------------------------------------------------#
	 #    SPLITTING BEFORE CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------#

	def SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeCharsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeCharsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeCharsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeCharsWXT(pcCondition)
		return This.SplitBeforeCharsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitBeforeCharsWXTQ(pcCondition)
			return This.SplitBeforeCharsWXTQRT(pcCondition, :stzList)

		def SplitBeforeCharsWXTQRT(pcCondition, pcReturnType)
			return This.SplitBeforeCharsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

	def SplittedBeforeCharsWXT(pcCondition)
		return This.SplitBeforeCharsWXT(pcCondition)

	  #-------------------------------------------------#
	 #    SPLITTING AFTER VERIFYING A GIVEN CONDITION   #
	#=================================================#

	def SplitAfterWCS(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPos = oCondition.ContainsCS("@position", 0)

		if bChars = 0 and bSubStr = 0 and bPos = 0
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword.")
		ok

		if bChars = 1 and
		   bSubStr = 0 and bPos = 0 and bSection = 0

			return This.SplitAfterCharsWCS(pcCondition, pCaseSensitive)

		but bSubStr = 1 and
		    bChars = 0 and bPos = 0and bSection = 0

			return This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

		but bPos= 1 and
		    bChars = 0 and bSubStr = 0 and bSection = 0

			return This.SplitAfterPositionsWCS(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterW(pcCondition)
		return This.SplitAfterWCS(pcCondition, 1)

	  #------------------------------------------------------#
	 #    SPLITTING AFTER VERIFYING A GIVEN CONDITION -- XT  #
	#------------------------------------------------------#

	def SplitAfterWCSXT(pcCondition, pCaseSensitive)
		oCondition = new stzString(pcCondition)

		bChars = oCondition.ContainsCS("@char", 0)
		bSubStr = oCondition.ContainsCS("@substring", 0)
		bPosition = oCondition.ContainsCS("@position", 0)

		if bChars = 1 and ( bSubStr = 0 and bPosition = 0 )
			return This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive)

		but bSubStr = 1 and ( bChars = 0 and bPosition = 0 )
			return This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

		but bPosition = 1 and ( bChars = 0 and bSubStr = 0 )
			return This.SplitAfterPositionsWCSXT(pcCondition, pCaseSensitive)

		else
			StzRaise("Syntax error! pcCondition must contains @char or @substring or @position keyword but not many of them.")
		ok

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterWXT(pcCondition)
		return This.SplitAfterWCSXT(pcCondition, 1)

	  #-------------------------------------------------------#
	 #    SPLITTING AFTER CHARS VERIFYING A GIVEN CONDITION   #
	#-------------------------------------------------------#

	def SplitAfterCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAfterCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAfterCharsWCSQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterCharsWCSQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterCharsWCS(pcCondition, pCaseSensitive)
		return This.SplitAfterCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterCharsW(pcCondition)
		return This.SplitAfterCharsWCS(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterCharsWQ(pcCondition)
			return This.SplitAfterCharsWQRT(pcCondition, :stzList)

		def SplitAfterCharsWQRT(pcCondition, pcReturnType)
			return This.SplitAfterCharsWCSQRT(pcCondition, 1, pcReturnType)

		#>

	def SplittedAfterCharsW(pcCondition)
		return This.SplitAfterCharsW(pcCondition)

	  #----------------------------------------------------------------------#
	 #    SPLITTING AFTER CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------#

	def SplitAfterCharsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAfterCharsWCSXTQRT(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterCharsWCSXTQRT(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterCharsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterCharsWXT(pcCondition)
		return This.SplitAfterCharsWCSXT(pcCondition, 1)

		#< @FunctionFluentForms

		def SplitAfterCharsWXTQ(pcCondition)
			return This.SplitAfterCharsWXTQRT(pcCondition, :stzList)

		def SplitAfterCharsWXTQRT(pcCondition, pcReturnType)
			return This.SplitAfterCharsWCSXTQRT(pcCondition, 1, pcReturnType)

		#>

	def SplittedAfterCharsWXT(pcCondition)
		return This.SplitAfterCharsWXT(pcCondition)
	
	  #-----------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND SUBSTRING(S), POSITION(S) OR SECTION(S)  #
	#=======================================================================#

	def SplitAroundCS(pSubStrOrPos, pCaseSensitive)

		if isNumber(pSubStrOrPos)
			return This.SplitAroundPosition(pSubStrOrPos)

		but isString(pSubStrOrPos)
			return This.SplitAroundSubStringCS(pSubStrOrPos, pCaseSensitive)

		but @IsListOfNumbers(pSubStrOrPos)
			return This.SplitAroundPositions(pSubStrOrPos)

		but @IsListOfStrings(pSubStrOrPos)
			return This.SplitAroundSubStrings(pSubStrOrPos)

		but @IsPairOfNumbers(pSubStrOrPos)
			return This.SplitAroundSection(pSubStrOrPos)

		but @IsListOfPairsOfNumbers(pSubStrOrPos)
			return This.SplitAroundSections(pSubStrOrPos)
		
		but isList(pSubStrOrPos)

			oParam = StzListQ(pSubStrOrPos)

			if oParam.IsPositionNamedParam()
				return This.SplitAroundPosition(pSubStrOrPos)

			but oParam.IsPositionIBNamedParam()
				return This.SplitAroundPositionIB(pSubStrOrPos)

			but oParam.IsPositionsNamedParam()
				return This.SplitAroundPositions(pSubStrOrPos)

			but oParam.IsPositionsIBNamedParam()
				return This.SplitAroundPositionsIB(pSubStrOrPos)

			but oParam.IsSectionNamedParam()
				return This.SplitAroundSection(pSubStrOrPos[1], pSubStrOrPos[2])

			but oParam.IsSectionIBNamedParam()
				return This.SplitAroundSectionIB(pSubStrOrPos[1], pSubStrOrPos[2])

			but oParam.IsSectionsNamedParam()
				return This.SplitAroundSections(pSubStrOrPos)

			but oParam.IsSectionsIBNamedParam()
				return This.SplitAroundSectionsIB(pSubStrOrPos)

			but oParam.IsSubStringNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSections(aSections)

			but oParam.IsSubStringIBNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSectionsIB(aSections)

			but oParam.IsSubStringsNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSections(aSections)

			but oParam.IsSubStringsIBNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSectionsIB(aSections)

			ok

		ok

		StzRaise("Incorrect param type! pSubStrOrPos must be number or string or pair of numbers (or a list of them).")

		#< @FunctionFluentForm

		def SplitAroundCSQ(pSubStrOrPos, pCaseSensitive)
			return new stzList( This.SplitAroundCS(pSubStrOrPos, pCaseSensitive) )

		def SplitAroundCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundCS(pSubStrOrPos, pCaseSensitive)
		aResult = This.Copy().SplitAroundCSQ(pSubStrOrPos, pCaseSensitive).Content()
		return aResult

		def SplitsAroundCS(pSubStrOrPos, pCaseSensitive)
			return This.SplittedAroundCS(pSubStrOrPos, pCaseSensitive)

			def SplitsAroundCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplittedAroundCSQ(pSubStrOrPos, pCaseSensitive)

			def SplitsAroundCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplittedAroundCSQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)


	#-- WITHOUT CASESNESITIVITY

	def SplitAround(pSubStrOrPos)
		return This.SplittedAroundCS(pSubStrOrPos, 1)

		def SplitAroundQ(pSubStrOrPos)
			return This.SplitAroundCS(pSubStrOrPos, 1)

		def SplitAroundQRT(pSubStrOrPos, pcReturnType)
			return This.SplitAroundCSQRT(pSubStrOrPos, 1, pcReturnType)

	def SplittedAround(pSubStrOrPos)
		return This.SplittedAroundCS(pSubStrOrPos, 1)

	  #-----------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND SUBSTRING(S), POSITION(S) OR SECTION(S) -- IB  #
	#-----------------------------------------------------------------------------#

	def SplitAroundCSIB(pSubStrOrPos, pCaseSensitive)

		if isNumber(pSubStrOrPos)
			return This.SplitAroundPositionIB(pSubStrOrPos)

		but isString(pSubStrOrPos)
			return This.SplitAroundSubStringCSIB(pSubStrOrPos, pCaseSensitive)

		but @IsListOfNumbers(pSubStrOrPos)
			return This.SplitAroundPositionsIB(pSubStrOrPos)

		but @IsListOfStrings(pSubStrOrPos)
			return This.SplitAroundSubStringsIB(pSubStrOrPos)

		but @IsPairOfNumbers(pSubStrOrPos)
			return This.SplitAroundSectionIB(pSubStrOrPos)

		but @IsListOfPairsOfNumbers(pSubStrOrPos)
			return This.SplitAroundSectionsIB(pSubStrOrPos)
		
		but isList(pSubStrOrPos)

			oParam = StzListQ(pSubStrOrPos)

			if oParam.IsPositionNamedParam()
				return This.SplitAroundPositionIB(pSubStrOrPos)

			but oParam.IsPositionsNamedParam()
				return This.SplitAroundPositionsIB(pSubStrOrPos)

			but oParam.IsSectionNamedParam()
				return This.SplitAroundSectionIB(pSubStrOrPos[1], pSubStrOrPos[2])

			but oParam.IsSectionsNamedParam()
				return This.SplitAroundSectionsIB(pSubStrOrPos)

			but oParam.IsSubStringNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSectionsIB(aSections)

			but oParam.IsSubStringsNamedParam()
				aSections = this.FindAsSectionsCS(pSubStrOrPos, pCaseSensitive)
				return This.SplitAroundSectionsIB(aSections)

			ok

		ok

		StzRaise("Incorrect param type! pSubStrOrPos must be number or string or pair of numbers (or a list of them).")

		#< @FunctionFluentForm

		def SplitAroundCSIBQ(pSubStrOrPos, pCaseSensitive)
			return new stzList( This.SplitAroundCSIB(pSubStrOrPos, pCaseSensitive) )

		def SplitAroundCSIBQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundCSIB(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundCSIB(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundCSIB(pSubStrOrPos, pCaseSensitive)
		aResult = This.Copy().SplitAroundCSIBQ(pSubStrOrPos, pCaseSensitive).Content()
		return aResult

		def SplitsAroundCSIB(pSubStrOrPos, pCaseSensitive)
			return This.SplittedAroundCSIB(pSubStrOrPos, pCaseSensitive)

			def SplitsAroundCSIBQ(pSubStrOrPos, pCaseSensitive)
				return This.SplittedAroundCSIBQ(pSubStrOrPos, pCaseSensitive)

			def SplitsAroundCSIBQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplittedAroundCSIBQRT(pSubStrOrPos, pCaseSensitive, pcReturnType)


	#-- WITHOUT CASESNESITIVITY

	def SplitAroundIB(pSubStrOrPos)
		return This.SplittedAroundCSIB(pSubStrOrPos, 1)

		def SplitAroundIBQ(pSubStrOrPos)
			return This.SplitAroundCSIB(pSubStrOrPos, 1)

		def SplitAroundIBQRT(pSubStrOrPos, pcReturnType)
			return This.SplitAroundCSIBQRT(pSubStrOrPos, 1, pcReturnType)

	def SplittedAroundIB(pSubStrOrPos)
		return This.SplittedAroundCSIB(pSubStrOrPos, 1)

	  #------------------------------------------------#
	 #  SPLITTING THE STRING AROUND A GIVEN POSITION  #
	#------------------------------------------------#

	def SplitAroundPosition(n)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundPosition(n)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundPositionQ(n)
			return new stzList( This.SplitAroundPosition(n) )

		def SplitAroundPositionQRT(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundPosition(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundPosition(n)
		aResult = This.Copy().SplitAroundPositionQ(n).Content()
		return aResult

		def SplitsAroundPosition(n)
			return This.SplittedAroundPosition(n)

	  #------------------------------------------------#
	 #  SPLITTING THE STRING AROUND GIVEN POSITIONS  #
	#-----------------------------------------------#

	def SplitAroundPositions(panPos)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundPositions(panPos)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundPositionsQ(panPos)
			return new stzList( This.SplitAroundPositions(panPos) )

		def SplitAroundPositionsQRT(panPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundPositions(panPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundPositions(panPos) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundPositions(panPos)
		aResult = This.Copy().SplitAroundPositionsQ(panPos).Content()
		return aResult

		def SplitsAroundPositions(panPos)
			return This.SplittedAroundPositions(panPos)

	  #-----------------------------------------------#
	 #  SPLITTING THE STRING AROUND A GIVEN SECTION  #
	#-----------------------------------------------#

	def SplitAroundSection(n1, n2)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSection(n1, n2)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundSectionQ(n1, n2)
			return new stzList( This.SplitAroundSection(n1, n2) )

		def SplitAroundSectionQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSection(n1, n2) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSection(n1, n2)
		aResult = This.Copy().SplitAroundSectionQ(n1, n2).Content()
		return aResult

		def SplitsAroundSection(n1, n2)
			return This.SplittedAroundSection(n1, n2)

	  #-------------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND A GIVEN SECTION -- INCLUDING BOUNDS IB/EXTENDED  #
	#-------------------------------------------------------------------------------#

	def SplitAroundSectionIB(n1, n2)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSectionIB(n1, n2)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundSectionIBQ(n1, n2)
			return new stzList( This.SplitAroundSectionIB(n1, n2) )

		def SplitAroundSectionIBQRT(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSectionIB(n1, n2) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSectionIB(n1, n2)
		aResult = This.Copy().SplitAroundSectionIBQ(n1, n2).Content()
		return aResult

		def SplitsAroundSectionIB(n1, n2)
			return This.SplittedAroundSectionIB(n1, n2)

	  #----------------------------------------------#
	 #  SPLITTING THE STRING AROUND GIVEN SECTIONS  #
	#----------------------------------------------#

	def SplitAroundSections(paSections)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSections(paSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundSectionsQ(paSections)
			return new stzList( This.SplitAroundSections(paSections) )

		def SplitAroundSectionsQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSections(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSections(paSections)
		aResult = This.Copy().SplitAroundSectionsQ(paSections).Content()
		return aResult

		def SplitsAroundSections(paSections)
			return This.SplittedAroundSections(paSections)

	  #------------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND GIVEN SECTIONS -- INCLUDING BOUNDS IB/EXTENDED  #
	#------------------------------------------------------------------------------#

	def SplitAroundSectionsIB(panSections)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSectionsIB(panSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundSectionsIBQ(paSections)
			return new stzList( This.SplitAroundSectionsIB(paSections) )

		def SplitAroundSectionsIBQRT(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSectionsIB(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSectionsIB(paSections)
		aResult = This.Copy().SplitAroundSectionsIBQ(paSections).Content()
		return aResult

		def SplitsAroundSectionsIB(paSections)
			return This.SplittedAroundSectionsIB(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING THE STRING AROUND A GIVEN SUBSTRING  #
	#-------------------------------------------------#

	def SplitAroundSubStringCS(pcSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSections(aSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundsubStringCSQ(pcSubStr, pCaseSensitive)
			return new stzList( This.SplitAroundSubStringCS(pcSubStr, pCaseSensitive) )

		def SplitAroundSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSubStringCS(pcSubStr, pCaseSensitive)
		aResult = This.Copy().SplitAroundSubStringCSQ(pcsubStr, pCaseSensitive).Content()
		return aResult

		def SplitsAroundSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAroundSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubString(pcSubStr)
		return This.SplitAroundSubStringCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def SplitAroundsubStringQ(pcSubStr)
			return This.SplitAroundsubStringCSQ(pcSubStr, 1)

		def SplitAroundSubStringQRT(pcSubStr, pcReturnType)
			return This.SplitAroundSubStringCSQRT(pcSubStr, 1, pcReturnType)

		#>

	def SplittedAroundSubString(pcSubStr)
		return This.SplittedAroundSubStringCS(pcSubStr, 1)

		def SplitsAroundSubString(pcSubStr)
			return This.SplitsAroundSubString(pcSubStr)

	  #---------------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND A GIVEN SUBSTRING -- INCLUDING BOUNDS IB/EXTENDED  #
	#---------------------------------------------------------------------------------#

	def SplitAroundSubStringCSIB(pcSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSectionsIB(aSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundsubStringCSIBQ(pcSubStr, pCaseSensitive)
			return new stzList( This.SplitAroundSubStringCSIB(pcSubStr, pCaseSensitive) )

		def SplitAroundSubStringCSiBQRT(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringCSIB(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringCSIB(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSubStringCSIB(pcSubStr, pCaseSensitive)
		aResult = This.Copy().SplitAroundSubStringCSIBQ(pcsubStr, pCaseSensitive).Content()
		return aResult

		def SplitsAroundSubStringCSIB(pcSubStr, pCaseSensitive)
			return This.SplittedAroundSubStringCSIB(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubStringIB(pcSubStr)
		return This.SplitAroundSubStringCSIB(pcSubStr, 1)

		#< @FunctionFluentForm

		def SplitAroundsubStringIBQ(pcSubStr)
			return This.SplitAroundsubStringCSIBQ(pcSubStr, 1)

		def SplitAroundSubStringIBQRT(pcSubStr, pcReturnType)
			return This.SplitAroundSubStringCSIBQRT(pcSubStr, 1, pcReturnType)

		#>

	def SplittedAroundSubStringIB(pcSubStr)
		return This.SplittedAroundSubStringCSIB(pcSubStr, 1)

		def SplitsAroundSubStringIB(pcSubStr)
			return This.SplittedAroundSubStringIB(pcSubStr)

	  #------------------------------------------------#
	 #  SPLITTING THE STRING AROUND GIVEN SUBSTRINGS  #
	#------------------------------------------------#

	def SplitAroundSubStringsCS(pacSubStrings, pCaseSensitive)

		if CheckingParams()
			if NOT ( isList(pacSubStrings) and @IsListOfStrings(pacSubStrings) )
				StzRaise("Incorrect param type! pacSubStrings must be a list of strings.")
			ok
		ok

		aSections = This.FindManyAsSectionsCS(pacSubStrings, pCaseSensitive)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSections(aSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundsubStringsCSQ(pacSubStrings, pCaseSensitive)
			return new stzList( This.SplitAroundSubStringsCS(pacSubStrings, pCaseSensitive) )

		def SplitAroundSubStringsCSQRT(pcSubStr, pacSubStrings, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringsCS(pacSubStrings, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringsCS(pacSubStrings, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSubStringsCS(pacSubStrings, pCaseSensitive)
		aResult = This.Copy().SplitAroundSubStringsCSQ(pacSubStrings, pCaseSensitive).Content()
		return aResult

		def SplitsAroundSubStringsCS(pacSubStrings, pCaseSensitive)
			return This.SplittedAroundSubStringsCS(pacSubStrings, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubStrings(pacSubStrings)
		return This.SplitAroundSubStringsCS(pacSubStrings, 1)

		#< @FunctionFluentForm

		def SplitAroundsubStringsQ(pacSubStrings)
			return This.SplitAroundsubStringsCSQ(pacSubStrings, 1)

		def SplitAroundSubStringsQRT(pacSubStrings, pcReturnType)
			return This.SplitAroundSubStringsCSQRT(pacSubStrings, 1, pcReturnType)

		#>

	def SplittedAroundSubStrings(pacSubStrings)
		return This.SplittedAroundSubStringsCS(pacSubStrings, 1)

		def SplitsAroundSubStrings(pacSubStrings)
			return This.SplittedAroundSubStrings(pacSubStrings)

	  #------------------------------------------------------------------------------#
	 #  SPLITTING THE STRING AROUND GIVEN SUBSTRINGS -- INCLUDING BOUNDS IB/EXTENDED  #
	#------------------------------------------------------------------------------#

	def SplitAroundSubStringsCSIB(pacSubStrings, pCaseSensitive)

		if CheckingParams()
			if NOT ( isList(pacSubStrings) and @IsListOfStrings(pacSubStrings) )
				StzRaise("Incorrect param type! pacSubStrings must be a list of strings.")
			ok
		ok

		aSections = This.FindManyAsSectionsCS(pacSubStrings, pCaseSensitive)
		aSections = StzSplitterQ(This.NumberOfChars()).SplitAroundSectionsIB(aSections)
		aResult = This.Sections(aSections)
		return aResult

		#< @FunctionFluentForm

		def SplitAroundsubStringsCSIBQ(pacSubStrings, pCaseSensitive)
			return new stzList( This.SplitAroundSubStringsCSIB(pacSubStrings, pCaseSensitive) )

		def SplitAroundSubStringsCSIBQRT(pcSubStr, pacSubStrings, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAroundSubStringsCSIB(pacSubStrings, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAroundSubStringsCSIB(pacSubStrings, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAroundSubStringsCSIB(pacSubStrings, pCaseSensitive)
		aResult = This.Copy().SplitAroundSubStringsCSIBQ(pacSubStrings, pCaseSensitive).Content()
		return aResult

		def SplitsAroundSubStringsCSIB(pacSubStrings, pCaseSensitive)
			return This.SplittedAroundSubStringsCSIB(pacSubStrings, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAroundSubStringsIB(pacSubStrings)
		return This.SplitAroundSubStringsCSIB(pacSubStrings, 1)

		#< @FunctionFluentForm

		def SplitAroundsubStringsIBQ(pacSubStrings)
			return This.SplitAroundsubStringsCSIBQ(pacSubStrings, 1)

		def SplitAroundSubStringsIBQRT(pacSubStrings, pcReturnType)
			return This.SplitAroundSubStringsCSIBQRT(pacSubStrings, 1, pcReturnType)

		#>

	def SplittedAroundSubStringsIB(pacSubStrings)
		return This.SplittedAroundSubStringsCSIB(pacSubStrings, 1)

		def SplitsAroundSubStringsIB(pacSubStrings)
			return This.SplittedAroundSubStringsIB(pacSubStrings)

	  #----------------------------------------------------------------#
	 #  NTH SUBSTRING AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#================================================================#
	# Utility function used to simplify code in stzListOfStrings

	def NthSubstringAfterSplittingStringUsing(n, cSep)
		#TODO // Remake it using FindNthSplitZZ(n)

		return This.Split(cSep)[n]

		def NthSplit(n, cSep)
			return This.NthSubstringAfterSplittingStringUsing(n, cSep)

	  #========================#
	 #   FINDING THE SPLITS   #
	#========================#

	def FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindSplitsAtCharsW(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereOtBeforeCharsWNamedParam()
				return This.FindSplitsBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereOrAfterCharsWNamedParam()
				return This.FindSplitsAfterCharsW(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereOrAtCharsWNamedParam()
				return This.FindSplitsAtSubStringsW(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereOrBeforeCharsWNamedParam()
				return This.FindSplitsBeforeSubStringsW(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereOrAfterCharsWNamedParam()
				return This.FindSplitsAfterSubStringsW(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharsWhereXTOrAtCharsWXTNamedParam()
				return This.FindSplitsAtCharsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
				return This.FindSplitsBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereXTOrAfterCharsWXTNamedParam()
				return This.FindSplitsAfterCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereXTOrAtCharsWXTNamedParam()
				return This.FindSplitsAtSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereXTOrBeforSubStringsWXTNamedParam()
				return This.FindSplitsBeforeSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereXTOrAfterSubstringsWXTNamedParam()
				return This.FindSplitsAfterSubStringsWXT(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXT(pSubStrOrPos)
		return This.FindSplitsCSXT(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsXTZ(pSubStrOrPos)
			return This.FindSplitsXT(pSubStrOrPos)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================#

	def FindSplitsAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplits(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsAtSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsAtSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAt(pSubStrOrPos)
		return This.FindSplitsAtCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtZ(pSubStrOrPos)
			return This.FindSplitsAtCS(pSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN POSITION   #
	#========================================#

	def FindSplitsAtPosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtPosition(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPosition(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtPositionZ(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtThisPositionZ(n)
			return This.FindSplitsAtPosition(n)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AT MANY POSITIONS   #
	#--------------------------------------#

	def FindSplitsAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		#--

		def FindSplitsAtPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtThesePositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING   #
	#=========================================#

	def FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#TODO
		# Add early check where needed in all the library
		# ~> better performance when the function is used in large loops

		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok

		ok

		anResult = This.FindManyCS( U( This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive) ), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSeparatedByCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedByCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubString(pcSubStr)
		return This.FindSplitsAtSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplits(pcSubStr)
			return This.FindSplitsCS(pcSubStr, 1)

		def FindSplitsAtThisSubString(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, 1)
		#--

		def FindSplitsAtSubStringZ(pcSubStr)
			return This.FindSplitsAtSubStringCS(pcSubStr, 1)

		def FindSplitsZ(pcSubStr)
			return This.FindSplitsCS(pcSubStr, 1)

		def FindSplitsAtThisSubStringZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, 1)

		#--

		def FindSeparatedBy(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedBySubString(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedByZ(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedBySubStringZs(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT GIVEN SUBSTRINGS   #
	#----------------------------------------#

	def FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSeparatedBySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)


		def FindSeparatedBySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStrings(pacSubStr)
		return This.FindSplitsAtSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)
	
		def FindSplitsAtManySubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#--

		def FindSplitsAtSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtManySubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#--

		def FindSeparatedBySubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSeparatedBySubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#>

	  #---------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION   #
	#=======================================#

	def FindSplitsAtSectionCS(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSection(n1, n2)
		return This.FindSplitsAtSectionCS(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSection(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#--

		def FindSplitsAtSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		def FindSplitsAtThisSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#==========================================================#

	def FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIB(n1, n2)
		return This.FindSplitsAtSectionCSIB(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindSplitsAtSectionIBZ(n1, n2)
			return This.FindSplitsAtSectionIB(n1, n2)

		def FindSplitsAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS  #
	#====================================#

	def FindSplitsAtSectionsCS(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult
		
		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSections(paSections)
		return This.FindSplitsAtSectionsCS(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSections(paSections)
			return This.FindSplitsAtSections(paSections)

		#--

		def FindSplitsAtSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		def FindSplitsAtTheseSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS -- BOUNDS INCLUDED   #
	#========================================================#

	def FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
	
		ok

		acSplits = This.SplitsAtSectionsIB(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsIB(paSections)
		return This.FindSplitsAtSectionsCSIB(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsIB(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#--

		def FindSplitsAtSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		def FindSplitsAtTheseSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION OR SUBSTRING   #
	#=========================================================#

	def FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsBeforeSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsBeforeSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBefore(pSubStrOrPos)
		return This.FindSplitsBeforeCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeZ(pSubStrOrPos)
			return This.FindSplitsBefore(pSubStrOrPos)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#============================================#

	def FindSplitsBeforePositionCS(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsBeforePosition(n)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePosition(n)
		return This.FindSplitsBeforePositionCS(n, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPosition(n)
			return This.FindSplitsBeforePosition(n)

		#--

		def FindSplitsBeforePositionZ(n)
			return This.FindSplitsBeforePosition(n)

		def FindSplitsBeforeThisPositionZ(n)
			return This.FindSplitsBeforePosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#==========================================#

	def FindSplitsBeforePositionsCS(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositionsCS(anPos)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositions(anPos)
		return This.FindSplitsBeforePositionsCS(anPos, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#--

		def FindSplitsBeforePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeThesePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubString(pcSubStr)
		return This.FindSplitsBeforeSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubString(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		def FindSplitsBeforeThisSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)	

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStrings(pacSubStr)
		return This.FindSplitsBeforeSubStringsCS(pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION   #
	#-------------------------------------------#

	def FindSplitsBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSection(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#--

		def FindSplitsBeforeSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		def FindSplitsBeforeThisSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------#

	def FindSplitsBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIB(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#--

		def FindSplitsBeforeSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		def FindSplitsBeforeThisSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS   #
	#-----------------------------------------#

	def FindSplitsBeforeSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSections(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindSplitsBeforeSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeTheseSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionsIB(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#--

		def FindSplitsBeforeSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeTheseSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------#

	def FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pcSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsAfterSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsAfterSectionsIB(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindSplitsAfterPositions(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindSplitsAfterSubStrings(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfter(pSubStrOrPos)
		return This.FindSplitsAfterCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterZ(pSubStrOrPos)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPosition(n)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPosition(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterThisPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsAfterPositions(anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositions(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositions(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#--

		def FindSplitsAfterPositionsZ(anPos)
			return This.FindSplitsAfterPositions(anPos)

		def FindSplitsAfterThesePositionsZ(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositionsZ(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubString(pcSubStr)
		return This.FindSplitsAfterSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubString(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#--

		def FindSplitsAfterSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		def FindSplitsAfterThisSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStrings(pacSubStr)
		return This.FindSplitsAfterSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#--

		def FindSplitsAfterSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION  #
	#-----------------------------------------#

	def FindSplitsAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSection(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSection(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#--

		def FindSplitsAfterSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		def FindSplitsAfterThisSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------#

	def FindSplitsAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionIB(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIB(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		#--

		def FindSplitsAfterSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		def FindSplitsAfterThisSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS   #
	#----------------------------------------#

	def FindSplitsAfterSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSections(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#--

		def FindSplitsAfterSectionsZ(paSections)
			return This.FindSplitsAfterSections(paSections)

		def FindSplitsAfterTheseSectionsZ(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------#

	def FindSplitsAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#--

		def FindSplitsAfterSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		def FindSplitsAfterTheseSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================#

	def FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok
		
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetween(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenZ(pBound1, pBound2)
			return This.FindSplitsBetween(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIB(pBound1, pBound2)
		return This.FindSplitsBetweenCSIB(pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenIBZ(pBound1, pBound2)
			return This.FindSplitsBetweenIB(pBound1, pBound2)

		#>

	  #----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS  #
	#----------------------------------------#

	def FindSplitsBetweenPositions(n1, n2)
		This.FindSplitsAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositions(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#--

		def FindSplitsBetweenPositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		def FindSplitsBetweenThesePositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#>
		
	  #------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------#

	def FindSplitsBetweenPositionsIB(n1, n2)
		This.FindSplitsAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#--

		def FindSplitsBetweenPositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		def FindSplitsBetweenThesePositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------#

	def FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		anResult = This.FindSplitsBetweenSections(aSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStrings(pacSubStr)
		return This.FindSplitsBetweenSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStrings(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		def FindSplitsBetweenTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#>

	  #---------------------------------#
	 #    FINDING SPLITS TO N PARTS    #
	#=================================#

	def FindSplitsToNParts(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsToNParts(n)
		return anResult

		def FindSplitsToNPartsZ(n)
			return This.FindSplitsToNParts(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNChars(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfExactlyNPositions(n)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNChars(n)
			return This.FindSplitsToPartsOfNChars(n)

		#--

		def FindSplitsToPartsOfNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		def FindSplitsToPartsOfExactlyNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF N CHARS -- EXTENDED   #
	#----------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsXT(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfNPositionsXT(n)

		return anResult

		def FindSplitsToPartsOfNCharsXTZ(n)
			return This.FindSplitsToPartsOfNCharsXT(n)

	  #-----------------------------------------#
	 #   FINSING SPLITS  AT A GIVEN CONDITION   #
	#=========================================#

	def FindSplitsAtWCS(pcCondition, pCaseSensitive)
		if CheckingParams()
			if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		acSplits = This.SplitsAtCSQ(pcCondition, pCaseSensitive).ItemsWCS(pcCondition, pCaseSensitive)
		anResult  = This.FindTheseSubStringsCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAtCSW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtW(pcCondition)
		return This.FindSplitsAtWCS(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtWZ(pcCondition)
			return This.FindSplitsAtW(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINSING SPLITS  AT A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------#

	def FindSplitsAtWCSXT(pcCondition, pCaseSensitive)
		if CheckingParams()
			if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		acSplits = This.SplitsAtCSQ(pcCondition, pCaseSensitive).ItemsWCSXT(pcCondition, pCaseSensitive)
		anResult  = This.FindTheseSubStringsCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAtCSXTW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWXT(pcCondition)
		return This.FindSplitsAtWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtWXTZ(pcCondition)
			return This.FindSplitsAtWXT(pcCondition)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE CHARS BEFORE A GIVEN CONDITION   #
	#=========================================================#

	def FindSplitsBeforeCharsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeCharsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeCharsW(pcCondition)
		return This.FindSplitsBeforeCharsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWZ(pcCondition)
			return This.FindSplitsBeforeCharsW(pcCondition)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE CHARS VERIFYING A GIVEN CONDITION -- WXT  #
	#------------------------------------------------------------------#

	def FindSplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeCharsWXT(pcCondition)
		return This.FindSplitsBeforeCharsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWXTZ(pcCondition)
			return This.FindSplitsBeforeCharsWXT(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE SUBSTRINGS BEFORE A GIVEN CONDITION   #
	#==============================================================#

	def FindSplitsBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsW(pcCondition)
		return This.FindSplitsBeforeSubStringsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWZ(pcCondition)
			return This.FindSplitsBeforeSubStringsW(pcCondition)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsWXT(pcCondition)
		return This.FindSplitsBeforeSubStringsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWXTZ(pcCondition)
			return This.FindSplitsBeforeSubStringsWXT(pcCondition)

		#>


	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER CHARS AFTER A GIVEN CONDITION   #
	#=======================================================#

	def FindSplitsAfterCharsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterCharsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterCharsW(pcCondition)
		return This.FindSplitsAfterCharsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWZ(pcCondition)
			return This.FindSplitsAfterCharsW(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING SPLITS AFTER CHARS VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------#

	def FindSplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterCharsWXT(pcCondition)
		return This.FindSplitsAfterCharsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWXTZ(pcCondition)
			return This.FindSplitsAfterCharsWXT(pcCondition)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER SUBSTRINGS AFTER A GIVEN CONDITION   #
	#============================================================#

	def FindSplitsAfterSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterSubStringsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterSubStringsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsW(pcCondition)
		return This.FindSplitsAfterSubStringsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWZ(pcCondition)
			return This.FindSplitsAfterSubStringsW(pcCondition)

		#>

	  #----------------------------------------------------------------------#
	 #   FINDING SPLITS AFTER SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT  #
	#----------------------------------------------------------------------#

	def FindSplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsWXT(pcCondition)
		return This.FindSplitsAfterSubStringsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWXTZ(pcCondition)
			return This.FindSplitsAfterSubStringsWXT(pcCondition)

		#>

	  #==================================================#
	 #   FINDING THE SPLITS AS SECTIONS -- ZZ/EXTENDED  #
	#==================================================#

	def FindSplitsCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :AtSectionIB, :AtThisSectionIB ]) 
				return This.FindSplitsAtSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSectionsIB, :AtTheseSectionsIB ]) 
				return This.FindSplitsAtSectionsIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSectionIB, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSectionIBZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSectionsIB, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSectionsIBZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSectionIB, :AfterThisSectionIB ]) 
				return This.FindSplitsAfterSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSectionsIB, :AfterTheseSectionsIB ]) 
				return This.FindSplitsAfterSectionsIBZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereNamedParam()
				return This.FindSplitsBeforeCharsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubStringsWhereNamedParam()
				return This.FindSplitsBeforeSubStringsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterCharsWhereNamedParam()
				return This.FindSplitsAfterCharsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterSubStringsWhereNamedParam()
				return This.FindSplitsAfterSubStringsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING WHERE -- XT

			but oParam.IsWhereXTOrAtXTWhereXTNamedParam() # TOD add it in stzList
				return This.FindSplitsAtWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTNamedParam()
				return This.FindSplitsBeforeCharsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubStringsWhereXTNamedParam()
				return This.FindSplitsBeforeSubStringsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterCharsWhereXTNamedParam()
				return This.FindSplitsAfterCharsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterSubStringsWhereXTNamedParam()
				return This.FindSplitsAfterSubStringsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAsSectionsCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXTZZ(pSubStrOrPos)
		return This.FindSplitsCSXTZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsAsSectionsXT(pSubStrOrPos)
			return This.FindSplitsAsSectionsXTZZ(pSubStrOrPos)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING OR POSITION  #
	#==================================================================#

	def FindSplitsAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsAtSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsAtSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtZZ(pSubStrOrPos)
		return This.FindSplitsAtCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSections(pSubStrOrPos)
			return This.FindSplitsAtCSZZ(pSubStr)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN POSITION   #
	#======================================================#

	def FindSplitsAtPositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAtPosition(n)
		aResult = This.FindManyAsSections(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAtPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionZZ(n)
		return This.FindSplitsAtPositionCSZZ(n, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSections(n)
			return This.FindSplitsAtPositionZZ(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY POSITIONS   #
	#----------------------------------------------------#

	def FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.SplitsAtPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAtPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionsZZ(anPos)
		return This.FindSplitsAtPositionsCSZZ(anPos, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#--

		def FindSplitsAtPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtThesePositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING   #
	#=======================================================#

	def FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
	
		ok

		acSplits = U( This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive) )
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSeparatedByCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedByAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringZZ(pcSubStr)
		return This.FindSplitsAtSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplitsZZ(pcSubStr)
			return This.FindSplitsCSZZ(pcSubStr, 1)

		def FindSplitsAtThisSubStringZZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCSZZ(pcSubStr, 1)
		#--

		def FindSplitsAtSubStringAsSectionsZZ(pcSubStr)
			return This.FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, 1)

		def FindSplitsAsSections(pcSubStr)
			return This.FindSplitsAsSectionsCS(pcSubStr, 1)

		def FindSplitsAtThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, 1)

		#--

		def FindSeparatedByZZ(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedByAsSections(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedBySubStringZZ(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedBySubStringAsSections(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		#>


	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT GIVEN SUBSTRINGS   #
	#------------------------------------------------------#

	def FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT @IsListOfStrings(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSeparatedBySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSeparatedBySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringsZZ(pacSubStr)
		return This.FindSplitsAtSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)
	
		def FindSplitsAtManySubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAtSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtManySubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#--

		def FindSeparatedBySubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSeparatedBySubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION   #
	#=====================================================#

	def FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionZZ(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		def FindSplitsAtThisSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCSIB(n1, n2, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAtSectionIBZZ(n1, n2)

		def FindSplitsAtThisSectionAsSectionsIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY SECTIONS   #
	#---------------------------------------------------#

	def FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsZZ(paSections, pCaseSensitive)
		return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsZZ(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#--

		def FindSplitsAtSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		def FindSplitsAtTheseSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pcSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsBeforeSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsBeforeSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeZZ(pSubStrOrPos)
		return This.FindSplitsBeforeCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSections(pSubStrOrPos)
			return This.FindSplitsBeforeZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsBeforePositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsBeforePosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionZZ(n)
		return This.FindSplitsBeforePositionCSZZ(n, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionZZ(n)
			return This.FindSplitsBeforePositionZZ(n)

		#--

		def FindSplitsBeforePositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		def FindSplitsBeforeThisPositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionsZZ(anPos)
		return This.FindSplitsBeforePositionsCSZZ(anPos, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#--

		def FindSplitsBeforePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeThesePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		acSplits = This.SplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringZZ(pcSubStr)
		return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringZZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)

		def FindSplitsBeforeThisSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)	

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
	
		ok

		acSplits = This.SplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsZZ(pacSubStr)
		return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionZZ(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#----------------------------------------------------------------------------#

	def FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCsIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionIBZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIBZZ(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSZZ(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsZZ(paSections)
		return This.FindSplitsBeforeSectionsCSZZ(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsZZ(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsAsSections(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------------------#

	def FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsBeforeSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsIBZZ(paSections)
		return This.FindSplitsBeforeSectionsCSIBZZ(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN POSITION OR SUBSTRING  #
	#---------------------------------------------------------------------#

	def FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindSplitsAfterSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindSplitsAfterSectionsIBZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindSplitsAfterSubStringsZZ(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterZZ(pSubStrOrPos)
		return This.FindSplitsAfterCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSections(pSubStrOrPos)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAfterPosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		def FindSplitsAfterThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionZZ(n)
		return This.FindSplitsAfterPositionCSZZ(n, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionZZ(n)
			return This.FindSplitsAfterPositionZZ(n)

		def FindSplitsAfterThisPositionAsSections(n)
			return This.FindSplitsAfterPositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.plitsAfterPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAfterPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionsZZ(anPos)
		return This.FindSplitsAfterPositionsCSZZ(anPos, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsZZ(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsZZ(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#--

		def FindSplitsAfterPositionsAsSections(anPos)
			return This.FindSplitsAfterPositionsZZ(anPos)

		def FindSplitsAfterThesePositionsAsSections(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsAsSections(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		acSplits = This.SplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringZZ(pcSubStr)
		return This.FindSplitsAfterSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringZZ(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#--

		def FindSplitsAfterSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		def FindSplitsAfterThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsAsSectionsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsZZ(pacSubStr)
		return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAfterSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsAsSectionsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (َAS SECTIONS) AFTER A GIVEN SECTION   #
	#--------------------------------------------------------#

	def FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionZZ(n1, n2)
		return This.FindSplitsAfterSectionCSZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionZZ(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionIBZZ(n1, n2)
		return This.FindSplitsAfterSectionCSIBZZ(n1, n2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIBZZ(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS   #
	#------------------------------------------------------#

	def FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionsZZ(paSections)
		return This.FindSplitsAfterSectionsCSZZ(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsZZ(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSections(paSections)
			return This.FindSplitsAfterSectionsZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSections(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------#

	def FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESNSITIVITY

	def FindSplitsAfterSectionsIBZZ(paSections)
		return This.FindSplitsAfterSectionsCSIBZZ(paSections, 1)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIBZZ(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#====================================================================#

	def FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
				StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
			ok
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = This.FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
			aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCS(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSections(pBound1, pBound2)
			return This.FindSplitsBetweenZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------------------#

	def FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
				StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
			ok
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
			aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIBZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsIB(pBound1, pBound2)
			return This.FindSplitsBetweenIBZZ(pBound1, pBound2)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS  #
	#------------------------------------------------------#

	def FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsZZ(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIBZZ(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO SUBSTRINGS  #
	#-------------------------------------------------------#

	def FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStringsZZ(pacSubStr)
		return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		def FindSplitsBetweenTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) TO N PARTS    #
	#===============================================#

	def FindSplitsToNPartsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToNPartsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		def FindSplitsToNPartsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToNPartsCSZZ(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToNPartsZZ(n)
		return This.FindSplitsToNPartsCSZZ(n, 1)

		def FindSplitsToNPartsAsSections(n)
			return This.FindSplitsToNPartsZZ(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNCharsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNCharsCSZZ(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsToPartsOfNCharsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		def FindSplitsToPartsOfExactlyNCharsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToPartsOfNCharsZZ(n)
		return This.FindSplitsToPartsOfNCharsCSZZ(n, 1)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNCharsZZ(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#--

		def FindSplitsToPartsOfNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		def FindSplitsToPartsOfExactlyNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) TO PARTS OF N CHARS -- EXTENDED   #
	#------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsCSXTZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNCharsXTZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNCharsAsSectionsCSXT(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSXTZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY()

	def FindSplitsToPartsOfNCharsXTZZ(n)
		return This.FindSplitsToPartsOfNCharsCSXTZZ(n, 1)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNCharsAsSectionsXT(n)
			return This.FindSplitsToPartsOfNCharsXTZZ(n)

		#>

	  #-------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDITION   #
	#=======================================================#

	def FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAtWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWZZ(pcCondition)
		return This.FindSplitsAtWCSZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsW(pcCondition)
			return This.FindSplitsAtWZZ(pcCondition)

		#>

	  #------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDITION -- XT  #
	#------------------------------------------------------------#

	def FindSplitsAtWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAtWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWXTZZ(pcCondition)
		return This.FindSplitsAtWCSXTZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWXT(pcCondition)
			return This.FindSplitsAtWXTZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) BEFORE A GIVEN CONDITION   #
	#===========================================================#

	def FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsBeforeWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWZZ(pcCondition)
		return This.FindSplitsBeforeWCSZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsW(pcCondition)
			return This.FindSplitsBeforeWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT BEFORE GIVEN CONDITION -- XT  #
	#-----------------------------------------------------------------#

	def FindSplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWXTZZ(pcCondition)
		return This.FindSplitsBeforeWCSXTZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWXT(pcCondition)
			return This.FindSplitsBeforeWXTZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AFTER A GIVEN CONDITION   #
	#==========================================================#

	def FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAfterWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWZZ(pcCondition)
		return This.FindSplitsAfterWCSZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsW(pcCondition)
			return This.FindSplitsAfterWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT AFTER GIVEN CONDITION -- XT  #
	#----------------------------------------------------------------#

	def FindSplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWXTZZ(pcCondition)
		return This.FindSplitsAfterWCSXTZZ(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWXT(pcCondition)
			return This.FindSplitsAfterWXTZZ(pcCondition)

		#>

	  #===========================#
	 #   FINDING THE NTH SPLIT   #
	#===========================#

	def FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNCharsCS(n, pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindNthSplitAtCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereOrBeforeCharsWNamedParam()
				return This.FindNthSplitBeforeCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereOrAfterCharsWNamedParam()
				return This.FindNthSplitAfterCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtSubstringsWhereOrAtCharsWNamedParam()
				return This.FindNthSplitAtSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereOrBeforeSubstringsWNamedParam()
				return This.FindNthSplitBeforeSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereOrAfterSubstringsWNamedParam()
				return This.FindNthSplitAfterSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAtCharsWhereXTOrAtCharsWXTNamedParam()
				return This.FindNthSplitAtCharsWCSXT(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
				return This.FindNthSplitBeforeCharsWCSXT(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTOrAfterCharsWXTNamedParam()
				return This.FindNthSplitAfterCharsWCSXT(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtSubstringsWhereXTOrAtCharsWXTNamedParam()
				return This.FindNthSplitAtSubstringsWCSXT(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereXTOrBeforeSubstringsWXTNamedParam()
				return This.FindNthSplitBeforeSubstringsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereXTOrAfterSubstringsWXTNamedParam()
				return This.FindNthSplitAfterSubstringsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXT(n, pSubStrOrPos)
		return This.FindNthSplitCSXT(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitXTZ(n, pSubStrOrPos)
			return This.FindNthSplitXT(n, pSubStrOrPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#=======================================================#

	def FindNthSplitAtCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitAtSectionCSIB(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitAtSectionsCSIB(n, pSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCS(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAt(n, pSubStrOrPos)
		return This.FindNthSplitAtCS(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAtZ(n, pSubStrOrPos)
			return This.FindNthSplitAtCS(n, pSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN POSITION   #
	#===========================================#

	def FindNthSplitAtPosition(n, nPos) #NOTE: Case sensitivty has no added value here,
					    # since the split is based on position
					    # and there is no use of ...CS() functions
					    # in the implementatin
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isNumber(n, nPos) and (n = 1 or n = 2) )
				StzRaise("Incorrect pram type! n must be a number equal to 1 or 2.")
				# Because after splitting the string at a given position, there will
				# be only two splits, right?
			ok

		ok

		nResult = 0

		if n = 1
			nResult = 1

		but n = 2
			nResult + (nPos + 1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPosition(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtThisPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY POSITIONS   #
	#-----------------------------------------#

	def FindNthSplitAtPositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtPositions(anPos)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nResult += ( nLen + 1 )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#--

		def FindNthSplitAtPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtThesePositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING   #
	#============================================#

	def FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		acSplits = This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubString(n, pcSubStr)
		return This.FindNthSplitAtSubStringCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplit(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, 1)

		def FindNthSplitAtThisSubString(n, pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, 1)
		#--

		def FindNthSplitAtSubStringZ(n, pcSubStr)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, 1)

		def FindNthSplitZ(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, 1)

		def FindNthSplitAtThisSubStringZ(pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, 1)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT GIVEN SUBSTRINGS   #
	#-------------------------------------------#

	def FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nLenSubStr = StzStringQ(pacSubStr[i]).NumberOfChars()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult


		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStrings(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCS(n, pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)
	
		def FindNthSplitAtManySubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#>

	  #------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION   #
	#==========================================#

	def FindNthSplitAtSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT @AllAreNumbers([n, n1, n2 ])
				StzRaise("Incorrect params type! n, n1 and n2 must all be numbers.")
			ok

			if NOT ( n = 1 or n = 2 )
				StzRaise("Incorrect values ! n must be equal to 1 or 2.")
				# Since the split make two parts only.
			ok
		ok

		if n = 1
			return 1
		
		but n = 2
			return n2 + 1
		ok
		
		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSection(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#--

		def FindNthSplitAtSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		def FindNthSplitAtThisSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------#

	def FindNthSplitAtSectionIB(n, n1, n2)
		nResult = This.FindNthSplitAtSection(n, n1, n2)
		if nResult > 1
			nResult - (n2 - n1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIB(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#--

		def FindNthSplitAtSectionIBZ(n, n1, n2)
			return This.FindNthSplitAtSectionIB(n, n1, n2)

		def FindNthSplitAtThisSectionIBZ(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#>

	  #----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY SECTIONS   #
	#----------------------------------------#

	def FindNthSplitAtSections(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		StzRaise("Feature not implemented yet!")

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSections(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#--

		def FindNthSplitAtSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		def FindNthSplitAtTheseSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------#

	def FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositions(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSection(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSections(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSection(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitBeforeSectionIB(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSections(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitBeforeSectionsIB(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBefore(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCS(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeZ(n, pSubStrOrPos)
			return This.FindNthSplitBefore(n, pSubStrOrPos)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitBeforePosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePosition(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPosition(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#--

		def FindNthSplitBeforePositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		def FindNthSplitBeforeThisPositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitBeforePositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#--

		def FindNthSplitBeforePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeThesePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubString(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubString(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)	

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStrings(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION   #
	#----------------------------------------------#

	def FindNthSplitBeforeSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSection(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSection(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		def FindNthSplitBeforeThisSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-----------------------------------------------------------------#

	def FindNthSplitBeforeSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIB(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		def FindNthSplitBeforeThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SECTIONS   #
	#--------------------------------------------#

	def FindNthSplitBeforeSections(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSections(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSections(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySections(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#--

		def FindNthSplitBeforeSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeTheseSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySectionsZ(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINING NTH SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIB(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIB(paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#--

		def FindNthSplitBeforeSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#----------------------------------------------------------#

	def FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSection(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitAfterSectionIB(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSections(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitAfterSectionsIB(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindNthSplitAfterSubStrings(n, pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSections(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfter(n, pSubStrOrPos)
		return This.FindNthSplitAfterCS(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterZ(n, pSubStrOrPos)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitAfterPosition(n, nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPosition(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterThisPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitAfterPositions(n, anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositions(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositions(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#--

		def FindNthSplitAfterPositionsZ(n, anPos)
			return This.FindNthSplitAfterPositions(n, anPos)

		def FindNthSplitAfterThesePositionsZ(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositionsZ(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitAfterSubStringCS(n, cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubString(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubString(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		def FindNthSplitAfterThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStrings(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION  #
	#--------------------------------------------#

	def FindNthSplitAfterSection(n, n1, n2)

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSection(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSection(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#--

		def FindNthSplitAfterSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		def FindNthSplitAfterThisSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindNthSplitAfterSectionIB(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIB(n, n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		#--

		def FindNthSplitAfterSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		def FindNthSplitAfterThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)


		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS   #
	#-------------------------------------------#

	def FindNthSplitAfterSections(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSections(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#--

		def FindNthSplitAfterSectionsZ(n, paSections)
			return This.FindNthSplitAfterSections(n, paSections)

		def FindNthSplitAfterTheseSectionsZ(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterSectionsIB(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#--

		def FindNthSplitAfterSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		def FindNthSplitAfterTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=========================================================#

	def FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetween(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetween(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenZ(n, pBound1, pBound2)
			return This.FindNthSplitBetween(n, pBound1, pBound2)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIB(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSIBZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIB(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenIBZ(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIB(n, pBound1, pBound2)

		#>

	  #-------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS  #
	#-------------------------------------------#

	def FindNthSplitBetweenPositions(n, n1, n2)
		This.FindNthSplitAtSection(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositions(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		def FindNthSplitBetweenThesePositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#>
		
	  #---------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIB(n, n1, n2)
		This.FindNthSplitAtSectionIB(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		def FindNthSplitBetweenThesePositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO SUBSTRINGS  #
	#--------------------------------------------#

	def FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindNthSplitBetweenSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStrings(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#>

	  #------------------------------------#
	 #    FINDING NTH SPLIT TO N PARTS    #
	#====================================#

	def FindNthSplitToNParts(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNParts(n, nPos)
		return nResult

		def FindNthSplitToNPartsZ(n, nPos)
			return This.FindNthSplitToNParts(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNChars(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositions(n, nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNChars(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF N CHARS -- EXTENDED   #
	#-------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsXT(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsXT(n, nPos)

		return nResult

		def FindNthSplitToPartsOfNCharsXTZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsXT(n, nPos)

	  #====================================================#
	 #   FINDING THE NTH SPLIT AS SECTION -- ZZ/EXTENDED  #
	#====================================================#

	def FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsZZ(n, pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNCharsZZ(n, pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionCSXT(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXTZZ(n, pSubStrOrPos)
		return This.FindNthSplitCSXTXT(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionXT(n, pSubStrOrPos)
			return This.FindNthSplitXTZZ(n, pSubStrOrPos)

		#>

	  #--------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================================#

	def FindNthSplitAtCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAsSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitAtSectionIBZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitAtSectionsIBZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCSZZ(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtZZ(n, pSubStrOrPos)
		return This.FindNthSplitAtCSZZ(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAtCSZZ(n, pSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#========================================================#

	def FindNthSplitAtPositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPositionAsSection(n, nPos)
			return This.FindNthSplitAtPositionZZ(n, nPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-----------------------------------------------------#

	def FindNthSplitAtPositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#--

		def FindNthSplitAtPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#========================================================#

	def FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringZZ(pcSubStr)
		return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, 1)

		def FindNthSplitAtThisSubStringZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, 1)
		#--

		def FindNthSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, 1)

		def FindNthSplitAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, 1)

		def FindNthSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, 1)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#--------------------------------------------------------#

	def FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)
	
		def FindNthSplitAtManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtManySubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=======================================================#

	def FindNthSplitAtSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindNthSplitAtSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIBZZ(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSectionIB(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-----------------------------------------------------#

	def FindNthSplitAtSectionsZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSectionsZZ(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#--

		def FindNthSplitAtSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		def FindNthSplitAtTheseSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING NTH SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------------------#

	def FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitBeforeSectionIBZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitBeforeSectionsIBZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeZZ(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSection(n, pSubStrOrPos)
			return This.FindNthSplitBeforeZZ(n, pSubStrOrPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitBeforePositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPositionZZ(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#--

		def FindNthSplitBeforePositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		def FindNthSplitBeforeThisPositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitBeforePositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#--

		def FindNthSplitBeforePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeThesePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringZZ(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)	

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindNthSplitBeforeSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsZZ(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#--

		def FindNthSplitBeforeSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSection(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIBZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindNthSplitBeforeSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------------------#

	def FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitAfterSectionIBZZ(n, pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitAfterSectionsIBZZ(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindNthSplitAfterSubStringsZZ(n, pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterZZ(n, pSubStrOrPos)
		return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterPositionZZ(n, Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPositionZZ(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		def FindNthSplitAfterThisPositionAsSection(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitAfterPositionsZZ(n, anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositionsZZ(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsZZ(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#--

		def FindNthSplitAfterPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterPositionsZZ(anPos)

		def FindNthSplitAfterThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringZZ(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		def FindNthSplitAfterThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsAsSectionCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsAsSectionZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (َAS SECTION) AFTER A GIVEN SECTION   #
	#----------------------------------------------------------#

	def FindNthSplitAfterSectionZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindNthSplitAfterSectionIBZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIBZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n1, n2)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#--------------------------------------------------------#

	def FindNthSplitAfterSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsZZ(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterSectionsZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterSectionsIBZZ(n, paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================================#

	def FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCS(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSection(n, pBound1, pBound2)
			return This.FindNthSplitBetweenZZ(n, pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCSIB(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIBZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionIB(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#--------------------------------------------------------#

	def FindNthSplitBetweenPositionsZZ(n, n1, n2)
		This.FindNthSplitAtSectionZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#>
		
	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIBZZ(n, n1, n2)
		This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIBZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindNthSplitBetweenSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) TO N PARTS    #
	#=================================================#

	def FindNthSplitToNPartsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNPartsZZ(n, nPos)
		return aResult

		def FindNthSplitToNPartsAsSection(n, nPos)
			return This.FindNthSplitToNPartsZZ(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNCharsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositionsZZ(n, nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNCharsZZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsIBZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsIBZZ(n, nPos)

		return aResult

	  #============================#
	 #   FINDING THE LAST SPLIT   #
	#============================#

	def FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindLastSplitAtCharsW(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereOrBeforeCharsWNamedParam()
				return This.FindLastSplitBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereOrAfterCharsWNamedParam()
				return This.FindLastSplitAfterCharsW(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereOrAtSubStringsWNamedParam()
				return This.FindLastSplitAtSubStringsW(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereOrBeforeSubStringsWNamedParam()
				return This.FindLastSplitBeforeSubStringsW(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereOrAfterSubStringsWNamedParam()
				return This.FindLastSplitAfterSubStringsW(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharsWXTNamedParam()
				return This.FindLastSplitAtCharsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWXTNamedParam()
				return This.FindLastSplitBeforeCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWXTNamedParam()
				return This.FindLastSplitAfterCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWXTNamedParam()
				return This.FindLastSplitAtSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWWXTNamedParam()
				return This.FindLastSplitBeforeSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWWXTNamedParam()
				return This.FindLastSplitAfterSubStringsWXT(pcSubStrOrPos[2])
			ok

		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXT(pSubStrOrPos)
		return This.FindLastSplitCSXT(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitXTZ(pSubStrOrPos)
			return This.FindLastSplitXT(pSubStrOrPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#========================================================#

	def FindLastSplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplit(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAtSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAtSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAt(pSubStrOrPos)
		return This.FindLastSplitAtCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAtZ(pSubStrOrPos)
			return This.FindLastSplitAtCS(pSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN POSITION   #
	#============================================#

	def FindLastSplitAtPosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(nPos)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPosition(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtThisPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY POSITIONS   #
	#------------------------------------------#

	def FindLastSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#--

		def FindLastSplitAtPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtThesePositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING   #
	#=============================================#

	def FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubString(pcSubStr)
		return This.FindLastSplitAtSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplit(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, 1)

		def FindLastSplitAtThisSubString(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, 1)
		#--

		def FindLastSplitAtSubStringZ(pcSubStr)
			return This.FindLastSplitAtSubStringCS(pcSubStr, 1)

		def FindLastSplitZ(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, 1)

		def FindLastSplitAtThisSubStringZ(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, 1)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT GIVEN SUBSTRINGS   #
	#--------------------------------------------#

	def FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStrings(pacSubStr)
		return This.FindLastSplitAtSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)
	
		def FindLastSplitAtManySubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#--

		def FindLastSplitAtSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtManySubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION   #
	#===========================================#

	def FindLastSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSection(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#--

		def FindLastSplitAtSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		def FindLastSplitAtThisSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindLastSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindLastSplitAtSectionIBZ(n1, n2)
			return This.FindLastSplitAtSectionIB(n1, n2)

		def FindLastSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS   #
	#-----------------------------------------#

	def FindLastSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSections(paSections)
			return This.FindLastSplitAtSections(paSections)

		#--

		def FindLastSplitAtSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		def FindLastSplitAtTheseSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsIB(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#--

		def FindLastSplitAtSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		def FindLastSplitAtTheseSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
	
			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitBeforeSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
	
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitBeforeSectionsIB(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBefore(pSubStrOrPos)
		return This.FindLastSplitBeforeCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeZ(pSubStrOrPos)
			return This.FindLastSplitBefore(pSubStrOrPos)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPosition(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#--

		def FindLastSplitBeforePositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		def FindLastSplitBeforeThisPositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#--

		def FindLastSplitBeforePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeThesePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubString(pcSubStr)
		return This.FindLastSplitBeforeSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubString(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		def FindLastSplitBeforeThisSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)	

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStrings(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCS(pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSection(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#--

		def FindLastSplitBeforeSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		def FindLastSplitBeforeThisSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIB(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#--

		def FindLastSplitBeforeSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		def FindLastSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS   #
	#---------------------------------------------#

	def FindLastSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSections(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindLastSplitBeforeSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeTheseSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#--

		def FindLastSplitBeforeSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------#

	def FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAfterSectionIB(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAfterSectionsIB(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindLastSplitAfterPositions(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindLastSplitAfterSubStrings(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfter(pSubStrOrPos)
		return This.FindLastSplitAfterCS(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterZ(pSubStrOrPos)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPosition(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterThisPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositions(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositions(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#--

		def FindLastSplitAfterPositionsZ(anPos)
			return This.FindLastSplitAfterPositions(anPos)

		def FindLastSplitAfterThesePositionsZ(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositionsZ(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitAfterSubStringCS(cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubString(pcSubStr)
		return This.FindLastSplitAfterSubStringCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubString(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#--

		def FindLastSplitAfterSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		def FindLastSplitAfterThisSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStrings(pacSubStr)
		return This.FindLastSplitAfterSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION  #
	#---------------------------------------------#

	def FindLastSplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSection(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#--

		def FindLastSplitAfterSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		def FindLastSplitAfterThisSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindLastSplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		#--

		def FindLastSplitAfterSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		def FindLastSplitAfterThisSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)


		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS   #
	#--------------------------------------------#

	def FindLastSplitAfterSections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSections(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#--

		def FindLastSplitAfterSectionsZ(paSections)
			return This.FindLastSplitAfterSections(paSections)

		def FindLastSplitAfterTheseSectionsZ(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindLastSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#--

		def FindLastSplitAfterSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		def FindLastSplitAfterTheseSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#==========================================================#

	def FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetween(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenZ(pBound1, pBound2)
			return This.FindLastSplitBetween(pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIB(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIB(pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenIBZ(pBound1, pBound2)
			return This.FindLastSplitBetweenIB(pBound1, pBound2)

		#>

	  #--------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS  #
	#--------------------------------------------#

	def FindLastSplitBetweenPositions(n1, n2)
		This.FindLastSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositions(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#--

		def FindLastSplitBetweenPositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		def FindLastSplitBetweenThesePositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#>
		
	  #----------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIB(n1, n2)
		This.FindLastSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#--

		def FindLastSplitBetweenPositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		def FindLastSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------#

	def FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStrings(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCS(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStrings(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#>

	  #-------------------------------------#
	 #    FINDING LAST SPLIT TO N PARTS    #
	#=====================================#

	def FindLastSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNParts(nPos)
		return nResult

		def FindLastSplitToNPartsZ(nPos)
			return This.FindLastSplitToNParts(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNChars(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNChars(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#--

		def FindLastSplitToPartsOfNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		def FindLastSplitToPartsOfExactlyNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindLastSplitToPartsOfNCharsXTZ(nPos)
			return This.FindLastSplitToPartsOfNCharsXT(nPos)

	  #------------------------------------------------#
	 #   FINSING LAST SPLIT BEFORE A GIVEN CONDITION   #
	#================================================#

	def FindLastSplitBeforeWCS(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCS(pcCondition, pCaseSensitive)
		nResult = This.FindLastCS(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitBeforeWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeW(pcCondition)
		return This.FindLastSplitBeforeWCS(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWZ(pcCondition)
			return This.FindLastSplitBeforeW(pcCondition)

		#>

	  #------------------------------------------------------#
	 #   FINSING LAST SPLIT BEFORE A GIVEN CONDITION -- WXT  #
	#------------------------------------------------------#

	def FindLastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		nResult = This.FindLastCSXT(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitBeforeWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWXT(pcCondition)
		return This.FindLastSplitBeforeWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWXTZ(pcCondition)
			return This.FindLastSplitBeforeWXT(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINSING LAST SPLIT AFTER A GIVEN CONDITION   #
	#===============================================#

	def FindLastSplitAfterWCS(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCS(pcCondition, pCaseSensitive)
		nResult = This.FindLastCS(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitAfterWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterW(pcCondition)
		return This.FindLastSplitAfterWCS(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWZ(pcCondition)
			return This.FindLastSplitAfterW(pcCondition)

		#>

	  #-----------------------------------------------------#
	 #   FINSING LAST SPLIT AFTER A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------#

	def FindLastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		nResult = This.FindLastCSXT(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitAfterWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWXT(pcCondition)
		return This.FindLastSplitAfterWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWXTZ(pcCondition)
			return This.FindLastSplitAfterWXT(pcCondition)

		#>

	  #======================================================#
	 #   FINDING THE FIRST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#======================================================#

	def FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindFirstSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindFirstSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindFirstSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindFirstSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindFirstSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindFirstSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindFirstSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharWhereOrAtCharWhereNamedParam()
				return This.FindFirstSplitAtCharWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereOrBeforeCharWNamedParam()
				return This.FindFirstSplitBeforeCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereOrAfterCharWNamedParam()
				return This.FindFirstSplitAfterCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereOrAtSubStringWhereNamedParam()
				return This.FindFirstSplitAtSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereOrBeforeSubStringWNamedParam()
				return This.FindFirstSplitBeforeSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereOrAfterSubStringWNamedParam()
				return This.FindFirstSplitAfterSubStringWZZ(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharWhereXTOrAtCharWherextNamedParam()
				return This.FindFirstSplitAtCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereXTOrBeforeCharXTWNamedParam()
				return This.FindFirstSplitBeforeCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereXTOrAfterCharWXTNamedParam()
				return This.FindFirstSplitAfterCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereXTOrAtSubStringWhereXTNamedParam()
				return This.FindFirstSplitAtSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereXTOrBeforeSubStringWXTNamedParam()
				return This.FindFirstSplitBeforeSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereXTOrAfterSubStringWXTNamedParam()
				return This.FindFirstSplitAfterSubStringWXTZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitXTZZ(pSubStrOrPos)
		return This.FindFirstSplitCSXTZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionXT(pSubStrOrPos)
			return This.FindFirstSplitXTZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#======================================================================#

	def FindFirstSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindFirstSplitAtSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindFirstSplitAtSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtZZ(pSubStrOrPos)
		return This.FindFirstSplitAtCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSection(pSubStrOrPos)
			return This.FindFirstSplitAtCSZZ(pSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#==========================================================#

	def FindFirstSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisPositionAsSection(nPos)
			return This.FindFirstSplitAtPositionZZ(nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-------------------------------------------------------#

	def FindFirstSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtThesePositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#--

		def FindFirstSplitAtPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtThesePositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#==========================================================#

	def FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringZZ(pcSubStr)
		return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindFirstSplitZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, 1)

		def FindFirstSplitAtThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, 1)
		#--

		def FindFirstSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, 1)

		def FindFirstSplitAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, 1)

		def FindFirstSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, 1)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)
	
		def FindFirstSplitAtManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAtSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=========================================================#

	def FindFirstSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionZZ(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAtSectionIBZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindFirstSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSectionsZZ(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#--

		def FindFirstSplitAtSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		def FindFirstSplitAtTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING FIRST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#--------------------------------------------------------------------------#

	def FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindFirstSplitBeforeSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindFirstSplitBeforeSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeZZ(pSubStrOrPos)
		return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSection(pSubStrOrPos)
			return This.FindFirstSplitBeforeZZ(pSubStrOrPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThisPositionZZ(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#--

		def FindFirstSplitBeforePositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		def FindFirstSplitBeforeThisPositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThesePositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#--

		def FindFirstSplitBeforePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeThesePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringZZ(pcSubStr)
		return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)

		#--

		def FindFirstSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)

		def FindFirstSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#-----------------------------------------------------------#

	def FindFirstSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsZZ(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------------------------#

	def FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindFirstSplitAfterSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindFirstSplitAfterSectionsIBZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindFirstSplitAfterSubStringsZZ(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterZZ(pSubStrOrPos)
		return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSection(pSubStrOrPos)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisPositionZZ(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		def FindFirstSplitAfterThisPositionAsSection(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThesePositionsZZ(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsZZ(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#--

		def FindFirstSplitAfterPositionsAsSection(anPos)
			return This.FindFirstSplitAfterPositionsZZ(anPos)

		def FindFirstSplitAfterThesePositionsAsSection(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsAsSection(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringZZ(pcSubStr)
		return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindFirstSplitAfterSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		def FindFirstSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (َAS SECTION) AFTER A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionZZ(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindFirstSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsZZ(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSection(paSections)
			return This.FindFirstSplitAfterSectionsZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#========================================================================#

	def FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCS(pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSection(pBound1, pBound2)
			return This.FindFirstSplitBetweenZZ(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------#

	def FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#----------------------------------------------------------#

	def FindFirstSplitBetweenPositionsZZ(n1, n2)
		This.FindFirstSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#

	def FindFirstSplitBetweenPositionsIBZZ(n1, n2)
		This.FindFirstSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------------------------#

	def FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindFirstSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		def FindFirstSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTION) TO N PARTS    #
	#===================================================#

	def FindFirstSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitToNPartsZZ(nPos)
		return aResult

		def FindFirstSplitToNPartsAsSection(nPos)
			return This.FindFirstSplitToNPartsZZ(nPos)

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindFirstSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindFirstSplitToPartsOfNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		def FindFirstSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#------------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindFirstSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult


	  #----------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) AT A GIVEN CONDITION -- ZZ   #
	#================================================================#

	def FindFirstSplitAtWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAtWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtWZZ(pcCondition)
		return This.FindFirstSplitAtWCSZZ(pcCondition, 1)

	  #------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN CONDITION -- WXTZZ  #
	#------------------------------------------------------------------#

	def FindFirstSplitAtWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAtWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtWXTZZ(pcCondition)
		return This.FindFirstSplitAtWCSXTZZ(pcCondition, 1)

	  #-------------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION -- ZZ  #
	#===================================================================#

	def FindFirstSplitBeforeWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitBeforeWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeWZZ(pcCondition)
		return This.FindFirstSplitBeforeWCSZZ(pcCondition, 1)

	  #----------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION -- WXTZZ  #
	#----------------------------------------------------------------------#

	def FindFirstSplitBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeWXTZZ(pcCondition)
		return This.FindFirstSplitBeforeWCSXTZZ(pcCondition, 1)

	  #------------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- ZZ  #
	#==================================================================#

	def FindFirstSplitAfterWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAfterWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterWZZ(pcCondition)
		return This.FindFirstSplitAfterWCSZZ(pcCondition, 1)

	  #---------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- WXTZZ  #
	#---------------------------------------------------------------------#

	def FindFirstSplitAfterWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAfterWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterWXTZZ(pcCondition)
		return This.FindFirstSplitAfterWCSXTZZ(pcCondition, 1)

	  #=====================================================#
	 #   FINDING THE LAST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#=====================================================#

	def FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and StzListQ(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharWhereOrAtCharWhereNamedParam()
				return This.FindLastSplitAtCharWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereOrBeforeCharWNamedParam()
				return This.FindLastSplitBeforeCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereOrAfterCharWNamedParam()
				return This.FindLastSplitAfterCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereOrAtSubStringWhereNamedParam()
				return This.FindLastSplitAtSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereOrBeforeSubStringWNamedParam()
				return This.FindLastSplitBeforeSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereOrAfterSubStringWNamedParam()
				return This.FindLastSplitAfterSubStringWZZ(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharWhereXTOrAtCharWherextNamedParam()
				return This.FindLastSplitAtCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereXTOrBeforeCharXTWNamedParam()
				return This.FindLastSplitBeforeCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereXTOrAfterCharWXTNamedParam()
				return This.FindLastSplitAfterCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereXTOrAtSubStringWhereXTNamedParam()
				return This.FindLastSplitAtSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereXTOrBeforeSubStringWXTNamedParam()
				return This.FindLastSplitBeforeSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereXTOrAfterSubStringWXTNamedParam()
				return This.FindLastSplitAfterSubStringWXTZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXTZZ(pSubStrOrPos)
		return This.FindLastSplitCSXTZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionXT(pSubStrOrPos)
			return This.FindLastSplitXTZZ(pSubStrOrPos)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#=====================================================================#

	def FindLastSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAtSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAtSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtZZ(pSubStrOrPos)
		return This.FindLastSplitAtCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSection(pSubStrOrPos)
			return This.FindLastSplitAtCSZZ(pSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#=========================================================#

	def FindLastSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPositionAsSection(nPos)
			return This.FindLastSplitAtPositionZZ(nPos)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#------------------------------------------------------#

	def FindLastSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#--

		def FindLastSplitAtPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtThesePositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#=========================================================#

	def FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and StzListQ(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringZZ(pcSubStr)
		return This.FindLastSplitAtSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, 1)

		def FindLastSplitAtThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, 1)
		#--

		def FindLastSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, 1)

		def FindLastSplitAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, 1)

		def FindLastSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, 1)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringsZZ(pacSubStr)
		return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)
	
		def FindLastSplitAtManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAtSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#========================================================#

	def FindLastSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionZZ(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindLastSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAtSectionIBZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#------------------------------------------------------#

	def FindLastSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsZZ(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#--

		def FindLastSplitAtSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		def FindLastSplitAtTheseSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING LAST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------------------#

	def FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitBeforeSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitBeforeSectionsIBZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeZZ(pSubStrOrPos)
		return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSection(pSubStrOrPos)
			return This.FindLastSplitBeforeZZ(pSubStrOrPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPositionZZ(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#--

		def FindLastSplitBeforePositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		def FindLastSplitBeforeThisPositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#--

		def FindLastSplitBeforePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeThesePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringZZ(pcSubStr)
		return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)

		def FindLastSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, 1)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionZZ(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#>

	  #-------------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindLastSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsZZ(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeManySectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#------------------------------------------------------------------------#

	def FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = new stzList(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAfterSectionIBZZ(pSubStrOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAfterSectionsIBZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oParam.IsListOfNumbers()
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos)

			but oParam.IsListOfStrings()
				return This.FindLastSplitAfterSubStringsZZ(pSubStrOrPos)

			but oParam.IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterZZ(pSubStrOrPos)
		return This.FindLastSplitAfterCSZZ(pSubStrOrPos, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSection(pSubStrOrPos)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPositionZZ(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		def FindLastSplitAfterThisPositionAsSection(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and StzListQ(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositionsZZ(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsZZ(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#--

		def FindLastSplitAfterPositionsAsSection(anPos)
			return This.FindLastSplitAfterPositionsZZ(anPos)

		def FindLastSplitAfterThesePositionsAsSection(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsAsSection(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringZZ(pcSubStr)
		return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindLastSplitAfterSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		def FindLastSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringsZZ(pacSubStr)
		return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (َAS SECTION) AFTER A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionZZ(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindLastSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsZZ(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSection(paSections)
			return This.FindLastSplitAfterSectionsZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSection(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=======================================================================#

	def FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, 1)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSection(pBound1, pBound2)
			return This.FindLastSplitBetweenZZ(pBound1, pBound2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, 1)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindLastSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#---------------------------------------------------------#

	def FindLastSplitBetweenPositionsZZ(n1, n2)
		This.FindLastSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIBZZ(n1, n2)
		This.FindLastSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindLastSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, 1)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) TO N PARTS    #
	#==================================================#

	def FindLastSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNPartsZZ(nPos)
		return aResult

		def FindLastSplitToNPartsAsSection(nPos)
			return This.FindLastSplitToNPartsZZ(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindLastSplitToPartsOfNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		def FindLastSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#-----------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult


	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDITION -- ZZ  #
	#==================================================================#

	def FindLastSplitAtWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAtWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtWZZ(pcCondition)
		return This.FindLastSplitAtWCSZZ(pcCondition, 1)

	  #-----------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN CONDITION -- WXTZZ  #
	#-----------------------------------------------------------------#

	def FindLastSplitAtWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAtWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtWXTZZ(pcCondition)
		return This.FindLastSplitAtWCSXTZZ(pcCondition, 1)

	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION -- ZZ  #
	#==================================================================#

	def FindLastSplitBeforeWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWZZ(pcCondition)
		return This.FindLastSplitBeforeWCSZZ(pcCondition, 1)

	  #---------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION -- WXTZZ  #
	#---------------------------------------------------------------------#

	def FindLastSplitBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWXTZZ(pcCondition)
		return This.FindLastSplitBeforeWCSXTZZ(pcCondition, 1)

	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- ZZ   #
	#==================================================================#

	def FindLastSplitAfterWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWZZ(pcCondition)
		return This.FindLastSplitAfterWCSZZ(pcCondition, 1)

	  #--------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- WXTZZ  #
	#--------------------------------------------------------------------#

	def FindLastSplitAfterWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWXTZZ(pcCondition)
		return This.FindLastSplitAfterWCSXTZZ(pcCondition, 1)

	  #====================================#
	 #  GETTING THE PARTS OF THE STRING   #
	#====================================#

	def PartsCS(pCaseSensitive)

		# Early Check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ This.Content() ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars of the string and
		# preparing it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		acResult = []

		for i = 2 to nLen

			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
			else
				acResult + cPart
				cPart = acContent[i]
			ok
	
		next
	
		acResult + cPart

		return acResult

		#< @FunctionFluentForms

		def PartsCSQ(pCaseSensitive)
			return This.PartsCSQRT(pCaseSensitive, :stzList)

		def PartsCSQRT(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsCS(pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionCS(pCaseSensitive) # A verb: to partition
			return This.PartsCS(pCaseSensitive)

			def PartitionCSQ(pCaseSensitive)
				return This.PartitionCSQRT(pCaseSensitive, :stzList)

			def PartitionCSQRT(pCaseSensitive, pcReturnType)
				return This.PartsCSQRT(pCaseSensitive, pcReturnType)

		def PartionedCS(pCaseSensitive)
			return This.PartsCS(pCaseSensitive)

			def PartionedCSQ(pCaseSensitive)
				return This.PartionedCSQRT(pCaseSensitive, :stzList)

			def PartionedCSQRT(pCaseSensitive, pcReturnType)
				return This.PartsCSQRT(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def Parts()
		return This.PartsCS(1)

		#< @FunctionFluentForms

		def PartsQ()
			return This.PartsQRT(:stzList)

		def PartsQRT(pcReturnType)
			return This.PartsCSQRT(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def Partition() # A verb: to partition
			return This.Parts()

			def PartitionQ()
				return This.PartitionQRT(:stzList)

			def PartitionQRT(pcReturnType)
				return This.PartsQRT(pcReturnType)

		def Partioned()
			return This.Parts()

			def PartionedQ()
				return This.PartionedQRT(:stzList)

			def PartionedQRT(pcReturnType)
				return This.PartsQRT(pcReturnType)

		#>

	  #----------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE STRING  #
	#----------------------------------------------------#

	def FindPartsCS(pCaseSensitive)

		# Eraly check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ 1 ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# them for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		anResult = [ 1 ]

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]
				anResult + i
			ok
	
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindPartsCSZ(pCaseSensitive)
			return This.FindPartsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindParts()
		return This.FindPartsCS(1)

		#< @FunctionAlternativeForms

		def FindPartsZ()
			return This.FindParts()

		#>

	  #----------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE STRING  #
	#----------------------------------------------------#

	def FindPartsAsSectionsCS(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ This.Content() ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		aResult = [ [ 1 ] ]
		nLenResult = 1

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]

				aResult[nLenResult] + (i-1)
				aResult + [ i ]
				nLenResult++
			ok
	
		next

		aResult[ len(aResult) ] + nLen
		return aResult

		#< @FunctionAlternativeForms

		def FindPartAsSectionsCSZ(pCaseSensitive)
			return This.FindPartsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindPartsAsSections()
		return This.FindPartsAsSectionsCS(1)

		#< @FunctionAlternativeForms

		def FindPartAsSectionsZ()
			return This.FindPartsAsSections()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def PartsCSZ(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ This.Content(), [ 1, nLen ] ] ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing it
		# for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
				n++
			else
				aResult + [ cPart, i-n-1 ]
				cPart = acContent[i]
				n = 0
			ok
	
		next
	
		aResult + [ cPart, nLen-n ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsCS(pCaseSensitive)
			return This.PartsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZ()
		return This.PartsCSZ(1)

		#< @FunctionAlternativeForms

		def PartAndTheirPositions()
			return This.PartsZ()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE STRING ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------#

	def PartsCSZZ(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ This.Content(), [ 1, nLen ] ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
				n++
			else
				aResult + [ cPart, [ i-n-1, i-1 ] ]
				cPart = acContent[i]
				n = 0
			ok
	
		next
	
		aResult + [ cPart, [ nLen-n, nLen ] ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsCS(pCaseSensitive)
			return This.PartsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZZ()
		return This.PartsCSZZ(1)

		#< @FunctionAlternativeForms

		def PartAndTheirSections()
			return This.PartsZZ()

		#>

	  #---------------------------------------------------------------#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTITION EXPRESSION  #
	#===============================================================#

	/* Note:

	This function analyzes the string, by sequentially partitioning
	its content, using a given "partition expression", a "PartitionExpr",
	for short. Hence, it serves in answering this kind of question:

	How is the string composed in term of some char criteria
	(the char beeing, for example, lowercase or uppercase, or
	left-oriented or right-oriented).

	The PartitionExpr is what we should provide to the method in
	a param as a conditional code containing the @char keyword.

	For example:

	o1 = new stzString("TUNIS gafsa NABEUL beja")
	? o1.PartsUsing( 'Q(@char).CharCase()' ) 

	Uses the CharCase() method in stzChar as a PartitionExpr.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or "", then the classification done will return:

	[
		"TUNIS",	# expression value ~> Uppercase
		" ",		# expression value ~> ""
		"gafsa",	# expression value ~> Lowercase
		" ",		# expression value ~> ""
		"NABEUL",	# expression value ~> Uppercase
		" ",		# expression value ~> ""
		"beja"		# expression value ~> Lowercase
	]

	*/

	def PartsUsingCS(pcPartitionExpr, pCaseSensitive)
		/* EXAMPLES

		See example inf the eXTended form PartsUsingXT()

		*/

		aSections = This.FindPartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def PartsUsingCSQ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSQRT(pcPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCS(pcPartitionExpr, pCaseSensitive)

			def PartsWCSQ(pcPartitionExpr, pCaseSensitive)
				return This.PartsUsingCSQ(pcPartitionExpr, pCaseSensitive)

			def PartsWCSQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsing(pcPartitionExpr)
		return This.PartsUsingCS(pcPartitionExpr, 1)

		#< @FunctionFluentForms

		def PartsUsingQ(pcPartitionExpr)
			return This.PartsUsingQRT(pcPartitionExpr, :stzList)

		def PartsUsingQRT(pcPartitionExpr, pcReturnType)
			return This.PartsUsingCSQRT(pcPartitionExpr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartsW(pcPartitionExpr)
			return This.PartsUsing(pcPartitionExpr)

			def PartsWQ(pcPartitionExpr)
				return This.PartsUsingQ(pcPartitionExpr)

			def PartsWQRT(pcPartitionExpr, pcReturnType)
				return This.PartsUsingQRT(pcPartitionExpr, pcReturnType)

		#>

	  #---------------------------------------------------------------------------#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTITION EXPRESSION -- EXTENDED  #
	#===========================================================================#

	def PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		/*
 
		Examples:

		o1 = new stzString("Abc285XY&من")
		
		? o1.PartsUsing( 'Q(@char).IsLetter()' )
		#--> [ "Abc" = 1, "285" = 0, "XY" = 1, "&" = 0, "من" = 1 ]
		
		? o1.PartsUsing('Q(@char).Orientation()' )
		#--> [ "Abc285XY&" = :LeftToRight, "من" = :RightToLeft ]
		
		? o1.PartsUsing( 'Q(@char).IsUppercase()' )
		#--> [ "A" = 1, "bc285" = 0, "XY" = 1, "&من" = 0 ]
		
		? o1.PartsUsing( 'Q(@char).CharCase()' )
		#--> [ "A" = :Uppercase, "bc" = :Lowercase, "285" = "", "XY" = :Uppercase, "&من" = "" ]

		*/

		aSections = This.FindPartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def PartsUsingCSXTQ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTQRT(pcPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSXTQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

			def PartsWCSXTQ(pcPartitionExpr, pCaseSensitive)
				return This.PartsUsingCSXTQ(pcPartitionExpr, pCaseSensitive)

			def PartsWCSXTQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQRT(pcPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsingXT(pcPartitionExpr)
		return This.PartsUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionFluentForms

		def PartsUsingXTQ(pcPartitionExpr)
			return This.PartsUsingXTQRT(pcPartitionExpr, :stzList)

		def PartsUsingXTQRT(pcPartitionExpr, pcReturnType)
			return This.PartsUsingCSXTQRT(pcPartitionExpr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartsWXT(pcPartitionExpr)
			return This.PartsUsingXT(pcPartitionExpr)

			def PartsWXTQ(pcPartitionExpr)
				return This.PartsUsingXTQ(pcPartitionExpr)

			def PartsWXTQRT(pcPartitionExpr, pcReturnType)
				return This.PartsUsingXTQRT(pcPartitionExpr, pcReturnType)

		#>

	  #------------------------------------------------------------------------------#
	 #  GETTING THE PARTS USING A PARTITION EXPRESSION ALONG WITH THEIR PARTIONERS  #
	#------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartsAndPartitionersUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ This.Sections(aSections), acPartitioners ])
		return aResult

		#< @FunctionAlternativeForm

		def Parts2UsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsAndPartitionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsAndPartitionersUsing(pcPartitionExpr)
		return This.PartsAndPartitionersUsingCS(pcPartitionExpr, 1)

		#< @FunctionAlternativeForm

		def Parts2Using(pcPartitionExpr)
			return This.PartsAndPartitionersUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING THE PARTS USING A PARTITION EXPRESSION ALONG WITH THEIR PARTIONERS -- XT #
	#-----------------------------------------------------------------------------------#

	def PartsAndPartitionersUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ This.Sections(aSections), acPartitioners ])
		return aResult

		#< @FunctionAlternativeForm

		def Parts2UsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsAndPartitionersUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsAndPartitionersUsingXT(pcPartitionExpr)
		return This.PartsAndPartitionersUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionAlternativeForm

		def Parts2UsingXT(pcPartitionExpr)
			return This.PartsAndPartitionersUsingXT(pcPartitionExpr)

		#>

	  #--------------------------------------------------------------------------------#
	 #  GETTING THE PARTIONERS (A GIVEN PARTITION EXPRESSION) ALONG WITH THEIR PARTS  #
	#--------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ acPartitioners, This.Sections(aSections) ])
		return aResult

		#< @FunctionAlternativeForm

		def Partioners2UsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartitionersAndPartsUsing(pcPartitionExpr)
		return This.PartitionersAndPartsUsingCS(pcPartitionExpr, 1)

		#< @FunctionAlternativeForm

		def Partioners2Using(pcPartitionExpr)
			return This.PartitionersAndPartsUsing(pcPartitionExpr)

		#>

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE PARTIONERS (A GIVEN PARTITION EXPRESSION) ALONG WITH THEIR PARTS -- XT #
	#-------------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ acPartitioners, This.Sections(aSections) ])
		return aResult

		#< @FunctionAlternativeForm

		def Partioners2UsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartitionersAndPartsUsingXT(pcPartitionExpr)
		return This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionAlternativeForm

		def Partioners2UsingXT(pcPartitionExpr)
			return This.PartitionersAndPartsUsingXT(pcPartitionExpr)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING PARTS IN THE STRING UPPON A GiVEN PARTITION EXPRESSION  #
	#==================================================================#

	def FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		anPos = StzListQ(aValues).FindPartsCS(pCaseSensitive)
	
		return anPos

		#< @FunctionAlternativeForms

		def FindPartsUsingCSZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCS(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def FindPartsWCSZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsUsing(pcPartitionExpr)
		return This.FindPartsUsingCS(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def FindPartsUsingZ(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		#--

		def FindPartsW(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		def FindPartsWZ(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING PARTS IN THE STRING UPPON A GiVEN PARTITION EXPRESSION -- XT #
	#=======================================================================#

	def FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		anPos = StzListQ(aValues).FindPartsCS(pCaseSensitive)

		return anPos
	
		#< @FunctionAlternativeForms

		def FindPartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def FindPartsWCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsUsingXT(pcPartitionExpr)
		return This.FindPartsUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def FindPartsUsingXTZ(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		#--

		def FindPartsWXT(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		def FindPartsWXTZ(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING PARTS, UPON A GIVEN PARTITON EXPERSSESION -- ZZ/EXTENSION  #
	#=====================================================================#

	def FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
	
		return aSections

		#< @FunctionAlternativeForms

		def FindPartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		def FindPartsAsSectionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsAsSectionsUsing(pcPartitionExpr)
		return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def FindPartsUsingZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		#--

		def FindPartsWZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		def FindPartsAsSectionsW(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING PARTS, UPON A GIVEN PARTITON EXPERSSESION -- XTZZ/EXTENSION  #
	#=======================================================================#

	def FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		if CheckingParams()
			if isList(pcPartitionExpr) and StzListQ(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2

			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = 0 and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], 0)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = 0
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		_oCode_ = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + _oCode_.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		return aSections

		#< @FunctionAlternativeForms

		def FindPartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def FindPartsAsSectionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsAsSectionsUsingXT(pcPartitionExpr)
		return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def FindPartsUsingXTZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		#--

		def FindPartsWXTZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		def FindPartsAsSectionsWXT(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		#>

	  #----------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#==========================================================#

	def PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)
		acParts = This.PartsUsingCS(pcPartitionExpr, pCaseSensitive)
		anPos = This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		aResult = @Association([ acParts, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirPositionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingZ(pcPartitionExpr)
		return This.PartsUsingCSZ(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsing(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		#--

		def PartsWZ(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		def PartsAndTheirPositionsW(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING ALONG WITH THEIR POSITIONS -- eXTended  #
	#----------------------------------------------------------------------#

	def PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)
		acParts = This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		anPos = This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		aResult = @Association([ acParts, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirPositionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingXTZ(pcPartitionExpr)
		return This.PartsUsingCSXTZ(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingXT(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		#--

		def PartsWXTZ(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		def PartsAndTheirPositionsWXT(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING AND RETURNING THEM ALOLG WITH THEIR SECTIONS  #
	#============================================================================#

	def PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
		aSections = o1.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)
		acParts = o1.Sections(aSections)

		aResult = @Association([ acParts, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirSectionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingZZ(pcPartitionExpr)
		return This.PartsUsingCSZZ(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsing(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		#--

		def PartsWZZ(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		def PartsAndTheirSectionsW(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  gettING PARTS IN THE STRING AND RETURNING THEM ALOLG WITH THEIR SECTIONS -- eXTended  #
	#----------------------------------------------------------------------------------------#

	def PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
		aSections = o1.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		acParts = o1.Sections(aSections)

		aResult = @Association([ acParts, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirSectionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingXTZZ(pcPartitionExpr)
		return This.PartsUsingCSXTZZ(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingXT(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		#--

		def PartsWXTZZ(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		def PartsAndTheirSectionsWXT(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		#>

	  #------------------------------------------------------------#
	 #  CLASSIFYING THE PARTS USING A GIVEN PARTITION EXPRESSION  #
	#------------------------------------------------------------#

	def ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		# Get the list of partioners (classes) and parts

		aData = This.PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)
		nLen = len(aData)

		# Getting the list of classes (partioners)

		acClasses = []
		for i = 1 to nLen
			acClasses + aData[i][1]
		next

		acClasses = U(acClasses)

		# Adding the parts to each class

		aResult = []

		for i = 1 to nLen

			cClass = aData[i][1]
			n = ring_find(acClasses, cClass)

			if n = 0

				aResult + [ cClass, aData[i][2] ]

			else
				nLen2 = len(aData[i][2])

				for j = 1 to nLen2
					aResult[n] + aData[i][2][j]
				next
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def ClassifyUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def ClassifyCS(pcPartitionExpr, pCaseSensitive)
			if CheckingParams()
				if isList(pcPartitionExpr) and
				   StzListQ(pcPartitionExpr).IsUsingNamedParam()

					pcPartitionExpr = pcPartitionExpr[2]
				ok
			ok

			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def ClassifyPartsCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyCS(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyPartsUsing(pcPartitionExpr)
		return This.ClassifyPartsUsingCS(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def ClassifyUsing(pcPartitionExpr)
			return This.ClassifyPartsUsing(pcPartitionExpr)

		def Classify(pcPartitionExpr)
			return This.ClassifyCS(pcPartitionExpr)

		def ClassifyParts(pcPartitionExpr)
			return This.Classify(pcPartitionExpr)

		def PartsClassifiedUsing(pcPartitionExpr)
			return This.ClassifyPartsUsing(pcPartitionExpr)

		def PartsClassified(pcPartitionExpr)
			return This.Classify(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------#
	 #  CLASSIFYING THE PARTS USING A GIVEN PARTITION EXPRESSION -- XT #
	#-----------------------------------------------------------------#

	def ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		# Get the list of partioners (classes) and parts

		aData = This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		nLen = len(aData)

		# Getting the list of classes (partioners)

		acClasses = []
		for i = 1 to nLen
			acClasses + aData[i][1]
		next

		acClasses = U(acClasses)

		# Adding the parts to each class

		aResult = []

		for i = 1 to nLen

			cClass = aData[i][1]
			n = ring_find(acClasses, cClass)

			if n = 0

				aResult + [ cClass, aData[i][2] ]

			else
				nLen2 = len(aData[i][2])

				for j = 1 to nLen2
					aResult[n] + aData[i][2][j]
				next
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def ClassifyUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def ClassifyCSXT(pcPartitionExpr, pCaseSensitive)
			if CheckingParams()
				if isList(pcPartitionExpr) and
				   StzListQ(pcPartitionExpr).IsUsingNamedParam()

					pcPartitionExpr = pcPartitionExpr[2]
				ok
			ok

			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def ClassifyPartsCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyCSXT(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyPartsUsingXT(pcPartitionExpr)
		return This.ClassifyPartsUsingCSXT(pcPartitionExpr, 1)

		#< @FunctionAlternativeForms

		def ClassifyUsingXT(pcPartitionExpr)
			return This.ClassifyPartsUsingXT(pcPartitionExpr)

		def ClassifyXT(pcPartitionExpr)
			return This.ClassifyCSXT(pcPartitionExpr)

		def ClassifyPartsXT(pcPartitionExpr)
			return This.ClassifyXT(pcPartitionExpr)

		def PartsClassifiedUsingXT(pcPartitionExpr)
			return This.ClassifyPartsUsingXT(pcPartitionExpr)

		def PartsClassifiedXT(pcPartitionExpr)
			return This.ClassifyXT(pcPartitionExpr)

		#>

	  #=============================#
	 #     DIVIDING THE STRING     #
	#=============================#

	def Divide(paByDividor)
		if isList(paByDividor) and StzListQ(paByDividor).IsByNamedParam()
			paByDividor = paByDividor[2]
		ok

		return This.DivideBy(paDividor)

	def DivideBy(pDividor)
		
		switch ring_type(pDividor)

		on "NUMBER"
			This.SplitToNParts(n)

		on "STRING"
			n = This.NumberOfOccurrence(pDividor)
			oTempStr = StzStringQ(pDividor) * n
			
			if oTempStr.IsEqualTo(This.String())
				return n
			else
				oTempStr = ( This.Copy() - oTempStr.Content() )
				nLen = oTempStr.NumberOfChars()
				if oTempStr.IsEqualTo( This.Section(1, n) )
					nResult = n + nLen / StzStringQ(pDividor).NumberOfChars()
					return nResult
				else
					return n
				ok
			ok
		off

	  #=====================================#
	 #   GETTING THE CHARS SORTING ORDER   #
	#=====================================#

	def CharsSortingOrder()
		cResult = :Unsorted

		if This.CharsAreSorted()
			if This.CharsAreSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

		def SortingOrder()
			return This.CharsSortingOrder()
			

	  #---------------------------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS SAME CHARS SORTING ORDER AS AN OTHER STRING  #
	#---------------------------------------------------------------------------#

	def HasSameCharsSortingOrderAs(pcOtherStr)

		oTemp = new stzString(pcOtherStr)
		if oTemp.CharsSortingOrder() = This.CharsSortingOrder()
			return 1
		else
			return 0
		ok

		def HasSameCharsOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

		def HasSameSortingOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

	  #--------------------------------------------------#
	 #  CHECKING OF THE CHARS OF THE STRING ARE SORTED  #
	#--------------------------------------------------#

	def CharsAreSorted()
		if This.CharsAreSortedInAscending() or
		   This.CharsAreSortedInDescending()
			return 1
		else
			return 0
		ok

		def IsSorted()
			return This.CharsAreSorted()

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE CHARS OF THE STRING ARE SORTED IN ASCENDING  #
	#---------------------------------------------------------------#

	def CharsAreSortedInAscending()
		if @IsListSortedInAscending(This.Chars())
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsSortedInAscending()
			return This.CharsAreSortedInAscending()

		def IsSortedUp()
			return This.CharsAreSortedInAscending()

		def CharsAreSortedUp()
			return This.CharsAreSortedInAscending()

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE CHARS OF THE STRING ARE SORTED IN DESCENDING  #
	#----------------------------------------------------------------#

	def CharsAreSortedInDescending()
		if @IsListSortedInDescending(This.Chars())
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsSortedInDescending()
			return This.CharsAreSortedInDescending()

		def IsSortedDown()
			return This.CharsAreSortedInDescending()

		def CharsAreSortedDown()
			return This.CharsAreSortedInDescending()

		#>

	  #------------------------------------------------#
	 #  SORTING THE CHARS OF THE STRING IN ASCENDING  #
	#------------------------------------------------#

	def SortCharsInAscending()
		
		acChars = This.Chars()
		nLen = len(acChars)

		acChars = ring_sort(acChars)

		cResult = ""

		for i = 1 to nLen
			cResult += acChars[i]
		next

		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def SortCharsInAscendingQ()
			This.SortCharsInAscending()
			return This

		#>

		#< @FunctionAlternativeForms

		def SortCharsUp()
			This.SortCharsInAscending()

			def SortCharsUpQ()
				return This.SortCharsInAscendingQ()

		def SortInAscending()
			This.SortCharsInAscending()

			def SortInAscendingQ()
				return This.SortCharsInAscendingQ()

		def SortUp()
			This.SortCharsInAscending()

			def SortUpQ()
				return This.SortCharsInAscendingQ()

		def SortChars()
			This.SortCharsInAscending()

			def SortCharsQ()
				return This.SortCharsInAscendingQ()

		def Sort()
			This.SortCharsInAscending()

			def SortQ()
				return This.SortCharsInAscendingQ()

		#>

	#--

	def StringWithCharsSortedInAscending()
		cResult = This.Copy().SortCharsInAscendingQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def SortedInAscending()
			return This.StringWithCharsSortedInAscending()

		def Sorted()
			return This.SortedInAscending()

		def CharSorted()
			return This.SortedInAscending()

		def CharsSortedInAscending()
			return This.SortedInAscending()

		#--

		def SortedUp()
			return This.SortedInAscending()

		def CharSortedUp()
			return This.SortedInAscending()

		def StringWithCharsSortedUp()
			return This.StringWithCharsSortedInAscending()

		#>

	  #-------------------------------------------------#
	 #  SORTING THE CHARS OF THE STRING IN DESCENDING  #
	#-------------------------------------------------#

	def SortCharsInDescending()

		acChars = This.Chars()
		nLen = len(acChars)

		acChars = ring_sort(acChars)

		cResult = ""

		for i = nLen to 1 step - 1
			cResult += acChars[i]
		next

		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def SortCharsInDescendingQ()
			This.SortCharsInDescending()
			return This

		#>

		#< @FunctionAlternativeForms

		def SortCharsDown()
			This.SortCharsInDescending()

			def SortCharsDownQ()
				return This.SortCharsInDescendingQ()

		def SortInDescending()
			This.SortCharsInDescending()

			def SortInDescendingQ()
				return This.SortCharsInDescendingQ()

		def SortDown()
			This.SortCharsInDescending()

			def SortDownQ()
				return This.SortCharsInDescendingQ()
		#>

	#--

	def StringWithCharsSortedInDescending()
		cResult = This.Copy().SortInDescendingQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def StringWithCharsSortedDown()
			return This.StringWithCharsSortedInDescending()

		def SortedInDescending()
			return This.StringWithCharsSortedInDescending()

		def SortedDown()
			return This.StringWithCharsSortedInDescending()

		def CharsSortedInDescending()
			return This.StringWithCharsSortedInDescending()

		def CharsSortedDown()
			return This.StringWithCharsSortedInDescending()

		#>

	  #====================================================#
	 #  COMPARING THE STRING TO AN OTHER PROVIDED STRING  #
	#====================================================#

	def CompareCS(pcOtherStr, pCaseSensitive)

		# Returs :
		# 	0 if the two strings are equal
		# 	-1 if the main tring is lesser then the provided string
		# 	1 if the main string is greater then the provided string

		#NOTE : the comparison is made first by comparing them for equality.
		# If so, 0 is returned. Then, the two strings are put in a list and
		# the list is sorted in ascending. Then first in the list is greater.

		# If you want to perform the comparison in a locale-sensitive way,
		# use ComapreInLocale() instead. WARRING: This function needs the
		# the support of the QCollator class in RingQt.

		if CheckingParams()
			if isList(pcOtherStr) and (pcOtherStr).IsWithOrToNamedParam()
				pcOtherStr = pcOtherStr[2]
	
				if NOT isString(pcOtherStr)
					StzRaise("Incorrect param type! pcOtherStr must be a string.")
				ok
			ok
		ok

		# Early check of equality

		if This.IsEqualToCS(pcOtherStr, pCaseSensitive)
			return 0
		ok

		cStr = This.Content()
		oList =  new stzList([ cStr, pcOtherStr ])
		oList.Sort()

		n = oList.FindFirstCS(cStr)

		if n = 1
			return -1
		else
			return 1
		ok

		#< @FunctionAlternativeForms

		def CompareWithCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def CompareToCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		#-- @FunctionPassiveForms

		def ComparedCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def ComparedWithCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def ComparedToCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		#>

	def Compare(pcOtherStr)
		return This.CompareCS(pcOtherStr, 1)

		#< @FunctionAlternativeForms

		def CompareWith(pcOtherStr)
			return This.Compare(pcOtherStr)

		def CompareTo(pcOtherStr)
			return This.Compare(pcOtherStr)

		#-- @FunctionPassiveForms

		def Compared(pcOtherStr)
			return This.Compare(pcOtherStr)

		def ComparedWith(pcOtherStr)
			return This.Compare(pcOtherStr)

		def ComparedTo(pcOtherStr)
			return This.Compare(pcOtherStr)

		#>
	
	  #-----------------------------------------------------------#
	 #     COMPARING THE STRING TO OTHER STRINGS USING UNICODE   #
	#===========================================================#
	#TODO // add Casesensitivity support

	# Compares the main string with an other string (based on the unicode code table)
	# --> Use this for internal string comparisons and sorting
	# --> For lists presented to the user, use SystemLocaleCompare()

	# 

	def UnicodeCompareWithCS(pcOtherStr, pCaseSensitive)
		#< QtBased | Uses QString.compare() >

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		nQtValue = This.QStringObject().compare(pcOtherStr, _bCase_)

		if nQtValue = 0
			return :equal
		but nQtValue < 0
			return :less
		else
			return :greater
		ok

	def UnicodeCompareWith(pcOtherStr)
		return This.CompareWithCS(pcOtherStr, 1)

	def UnicodeCompareWithInSystemLocale(pcOtherStr)
		_nQtResult_ = This.QStringObject().localeAwareCompare(pcOtherStr)

		if _nQtResult_ = 0
			return :equal

		but _nQtResult_ < 0
			return :less

		but _nQtResult_ > 0
			return :greater
		ok
		/*
		From Qt documentation:
	
		The comparison is performed in a locale- and also
		platform-dependent manner. Use this function to present
		sorted lists of strings to the user.

		NOTE:
		This works only for the current system locale.

		To compare for a defined locale, softanza should rely on
		the QCollator class in RingQt (which is not implemented yet)

		--> TODO: Add QCollator class to RingQt and make CompareWithInLocale()
		*/

	def UnicodeCompareWithInLocale(pcOtherStr, pLocale) #TODO
		// Needs the implementation of QCollator class in RingQt (read comment
		// in SystemLocaleCompareWith() methof above
		StzRaise("Feature unsupported yet!")

	def IsUnicodeEqualTo(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Equal

		def IsUnicodeEqualWith(pcOtherStr)
			return This.IsUnicodeEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsUnicodeDifferentFrom(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		#>

	def IsUnicodeEqualToInLocale(pcOtherStr, pLocale)
		return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Equal

		def IsUnicodeDifferentFromInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

		def IsNotUnicodeEqualToInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

	def IsUnicodeLessThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Less

		def IsUnicodeLessThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Less
	
	def IsUnicodeGreaterThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Greater

		def IsUnicodeGreaterThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Greater

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS STRICTLY EQUAL TO ANOTHER STRING  #
	#--------------------------------------------------------------#

	def IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
		if This.IsEqualToCS(pcOtherStr, pCaseSensitive) and
		   This.HasSameSortingOrderAs(pcOtherStr)

			return 1

		else
			return 0
		ok

		def IsStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsStrictlyDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(pcOtherStr)
		return This.IsStrictlyEqualToCS(pcOtherStr, 1)

		def IsStrictlyEqualWith(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualTo(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsNotStrictlyEqualWith(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentFrom(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)
	
		def IsStrictlyDifferentTo(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentOf(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS EQUAL TO ONE OF THE PROVIDED STRINGS  #
	#------------------------------------------------------------------#

	def IsEqualToOneOfTheseCS(pacOtherStr, pCaseSensitive)
		bResult = 1
		for str in pacOtherStr
			if NOT This.IsEqualToCS(str, pCaseSensitive)
				bResult = 0
				exit
			ok
		next
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def IsEqualToOneOfThese(pacOtherStr)
		return This.IsEqualToOneOfTheseCS(pacOtherStr, 1)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS NEITHER EQUAL TO A GIVEN STRING NOR TO AN OTHER  #
	#-----------------------------------------------------------------------------#

	def IsNeitherCS(pcStr1, pcStr2, pCaseSensitive)
		if CheckingParams()
			if isList(pcStr1) and StzListQ(pcStr1).IsEqualToNamedParam()
				pcStr1 = pcStr1[2]
			ok

			if isList(pcStr2) and StzListQ(pcStr2).IsNorNamedParam()
				pcStr2 = pcStr2[2]
			ok

			acStzTypes = [
				:String, :AString, :Char, :AChar, :Number,
				:ANumber, :List, :AList, :Object, :AnObject
			]
			#TODO // Add other stz types

			if isString(pcStr1) and isString(pcStr2) and
			   ring_find(acStzTypes, pcStr1) > 0 and
			   ring_find(acStzTypes, pcStr2) > 0

				return This.@IsNeither(pcStr1, pcStr2)
			ok

			if NOT @BothAreStrings(pcStr1, pcStr2)
				StzRaise("Incorrect param type! pcStr1 and pcStr2 must both be strings.")
			ok
		ok

		bEqualToStr1 = This.IsEqualToCS(pcStr1, pCaseSensitive)
		bEqualToStr2 = This.IsEqualToCS(pcStr2, pCaseSensitive)

		if NOT bEqualToStr1 and NOT bEqualToStr2
			return 1
		else
			return 0
		ok

		def IsNeitherEqualToCS(pcStr1, pcStr2, pCaseSensitive)
			return This.IsNeitherCS(pcStr1, pcStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVITY

	def IsNeither(pcStr1, pcStr2)
		return This.IsNeitherCS(pcStr1, pcStr2, 1)

		def IsNeitherEqualTo(pcStr1, pcStr2)
			return This.IsNeither(pcStr1, pcStr2)

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS SMALLER THAN THE PROVIDED STRING  #
	#--------------------------------------------------------------#

	def IsSmaller(pcOtherStr)

		if CheckingParams()

			if isList(pcOtherStr) and StzListQ(pcOtherStr).IsThanNamedParam()
				pcOtherStr = pcOtherStr[2]
			ok

			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok

		ok

		if This.NumberOfChars() < StzStringQ(pcOtherStr).NumberOfChars()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsSmallerThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def IsLessThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		#>

	def IsLarger(pcOtherStr)
		if CheckingParams()

			if isList(pcOtherStr) and StzListQ(pcOtherStr).IsThanNamedParam()
				pcOtherStr = pcOtherStr[2]
			ok

			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok

		ok

		if This.NumberOfChars() > StzStringQ(pcOtherStr).NumberOfChars()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsLargerThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		#>

	def IsQuietEqualTo(pcOtherStr)

		cThisStr = This.Lowercased()
		cOtherStr = lower(pcOtherStr)

		if cThisStr = cOtherStr
			return 1
		ok

		nDif = abs(This.NumberOfChars() - StzStringQ(cOtherStr).NumberOfChars())
		n = nDif / This.NumberOfChars()
		
		if n <= QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return 1
		ok

		return 0

		def IsQuietEqual(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

		def IsApproximativelyEqual(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

		def IsApproximativelyEqualTo(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

	  #-------------------------------------------------#
	 #     STRING IS A MULTIPLE OF AN OTHER STRING     #
	#-------------------------------------------------#

	def IsMultipleOfCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return 0
		ok

		_oCopy_ = This.Copy()
		_oCopy_.RemoveCS(pcSubStr, pCaseSensitive)

		if _oCopy_.Content() = ""
			return 1
		else
			return 0
		ok

	#-- WIHTOUT CASESENSITIVITY

	def IsMultipleOf(pcSubStr)
		return This.IsMultipleOfCS(pcSubStr, 1)

	  #--------------------------------------------------------------------#
	 #  CHECKING THAT THE STRING IS N TIMES MULTIPLE OF THE GIVEN STRING  #
	#--------------------------------------------------------------------#

	def IsNTimesMultipleOfCS(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return 0
		ok

		_oCopy_ = This.Copy()
		nOccurr = _oCopy_.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		if nOccurr != n
			return 0
		ok

		_oCopy_.RemoveCS(pcSubStr, pCaseSensitive)

		if _oCopy_.Content() = ""
			return 1
		else
			return 0
		ok

	def IsNTimesMultipleOf(n, pcSubStr)
		return This.IsNTimesMultipleOfCS(n, pcSubStr, 1)

	  #------------------------------------------------#
	 #     STRING IS A SPLITTER OF AN OTHER STRING    #
	#------------------------------------------------#

	def IsSplitterOfCS(pcOtherStr, pCaseSensitive)
		if Not isString(pcOtherStr)
			return 0
		ok

		bResult = StzStringQ(pcOtherStr).NumberOfOccurrenceCS( This.String(), pCaseSensitive ) > 1
		return bResult

	def IsSplitterOf(pcOtherStr)
		bResult = This.IsSplitterOfCS(pcOtherStr, 1)
		return bResult

	  #---------------------------------------------------#
	 #     STRING IS SPLITTABLE USING AN OTHER STRING    #
	#---------------------------------------------------#

	def IsSplittableUsingCS(pcSubStr)
		if Not isString(pcOtherStr)
			return 0
		ok

		return Q(pcSubStr).IsSplitterOfCS( This.String(), pCaseSensitive )

	def IsSplittableUsing(pcSubStr)
		return This.IsSplittableUsingCS(pcSubStr, pCaseSensitive)

	  #==============================#
	 #    REMOVING ALL SUBSTRINGS   # 
	#==============================#

	def RemoveCS(pSubStr, pCaseSensitive)
		if CheckingParams()
			if isList(pSubStr)

				oParam = new stzList(pSubStr)

				if oParam.IsListOfStrings()
					This.RemoveManyCS(pSubStr, pCaseSensitive)

				but oParam.IsListOfNumbers()
					This.ReloveCharsAtPositions(pSubStr)
				ok
				return
			ok
		ok

		This.ReplaceCS(pSubstr, "", pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveCSQ(pSubStr, pCaseSensitive)
			This.RemoveCS(pSubStr, pCaseSensitive)
			return This

		def RemoveCSQC(pcSubStr, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.RemoveCS(pcSubStr, pCaseSensitive)
			return _oCopy_

		#>

		#< @FunctionFutureForm

		def RemoveCSFF(pSubStr, pCaseSensitive)
			if _cFutureOrder = :Before
				This.RemoveCS(pSubStr, pCaseSensitive)
				@ExecuteActions(@FutureActions(), This)

			but _cFutureOrder = :After
				@ExecuteActions(@FutureActions(), This)
				This.RemoveCS(pSubStr, pCaseSensitive)
			ok

			@CleanFuture()

			def RemoveCSFFQ(pSubStr, pCaseSensitive)
				This.RemoveCSFF(pSubStr, pCaseSensitive)
				return This

		#>			

	def RemovedCS(pSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveCSQ(pSubStr, pCaseSensitive).Content()
		return cResult
		
	#-- WITHOUT CASESENSITIVITY

	def Remove(pcSubStr) # replace with QStringObject().remove() when added to RingQt
		This.ReplaceAll(pcSubStr , "")

		def RemoveQ(pcSubStr)
			This.Remove(pcSubStr)
			return This

		def RemoveQC(pcSubStr)
			_oCopy_ = This.Copy()
			_oCopy_.Remove(pcSubStr)
			return _oCopy_

		#< @FunctionFutureForm

		def RemoveFF(pSubStr)
			return This.RemoveCSFF(pSubStr, 1)

			def RemoveFFQ(pSubStr)
				return This.RemoveCSFFQ(pSubStr, 1)

		#>		

	#-- @FunctionPassiveForm

	def Removed(pSubStr)
		cResult = This.Copy().RemoveQ(pSubStr).Content()
		return cResult

	#== @FunctionPartialForm

	def @Remove()
		This.RemoveSections($TEMP_LIST)

		def @RemoveQ()
			This.@Remove()
			return This

		def @RemoveCS(pCaseSensitive) # CS has no effect
			This.@Remove()

		#--

		def @RemoveIt()
			This.@Remove()

			def @RemoveItQ()
				return This.@RemoveQ()

		def @RemoveThem()
			This.@Remove()

			def @RemoveThemQ()
				return This.@RemoveQ()

	def @Removed()
		_cResult_ = This.Copy().@RemoveQ().Content()
		return _cResult_

		def @RemovedCS(pCaseSensitive)
			return This.@Removed()

	  #----------------------------------------------#
	 #   REMOVING SOME OCCURRENCES OF A SUBSTRING   #
	#----------------------------------------------#

	def RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("ring __ ring __ ring __ ring")
		o1.RemoveOccurrences([2, 3], "ring")
		? o1.Content() #--> "ring __  __  __ ring"
		*/

		anPos = This.FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtPositionsCS(anPos, pcSubStr, pCaseSensitive)

		def RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This

		def RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

			def RemoveTheseOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
				This.RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

	def TheseOccurrencesRemovedCS(panOccurr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveOccurrences(panOccurr, pcSubStr)
		This.RemoveOccurrencesCS(panOccurr, pcSubStr, 1)

		def RemoveOccurrencesQ(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)
			return This

		def RemoveTheseOccurrences(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)

			def RemoveTheseOccurrencesQ(panOccurr, pcSubStr)
				This.RemoveTheseOccurrences(panOccurr, pcSubStr)

	def TheseOccurrencesRemoved(panOccurr, pcSubStr)
		return This.Copy().RemoveOccurrencesQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	  #-------------------------------------------------#
	 #   REMOVING FIRST N OCCURRENCES OF A SUBSTRING   #
	#-------------------------------------------------#

	def RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.RemoveTheseOccurrencesCS( 1 : n, pcSubStr, pCaseSensitive )

		def RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstNOccurrences(n, pcSubStr)
		This.RemoveFirstNOccurrencesCS(n, pcSubStr, 1)

		def RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemoved(n, pcSubStr)
			return This.FirstNOccurrencesRemoved(n, pcSubStr)

	  #------------------------------------------------#
	 #   REMOVING LAST N OCCURRENCES OF A SUBSTRING   #
	#------------------------------------------------#

	def RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		nNumberOfOccurr = This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
		n1 = nNumberOfOccurr - n + 1
		This.RemoveTheseOccurrencesCS( n1 : nNumberOfOccurr , pcSubStr, pCaseSensitive )

		def RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastNOccurrences(n, pcSubStr)
		This.RemoveLastNOccurrencesCS(n, pcSubStr, 1)

		def RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemoved(n, pcSubStr)
			return This.LastNOccurrencesRemoved(n, pcSubStr)

	  #----------------------------------------------#
	 #   REMOVING MANY SUBSTRING AT THE SAME TIME   #
	#----------------------------------------------#

	def RemoveManyCS(pacSubStr, pCaseSensitive)
		if CheckParams()
			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		_acSubStr_ = U(pacSubStr)
		_nLen_ = len(_acSubStr_)
		_oCopy_ = This.Copy()

		for @i = 1 to _nLen_
			_oCopy_.RemoveAllCS(_acSubstr_[@i], pCaseSensitive)
		next

		This.UpdateWith(_oCopy_.Content())


		def RemoveManyCSQ(pacSubStr, pCaseSensitive)
			This.RemoveManyCS(pacSubStr, pCaseSensitive)
			return This

		def RemoveAllOfTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)

		def RemoveTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveTheseCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)

		def RemoveManySubstringsCS(pcSubStr, pCaseSensitive)
			This.RemoveAllCS(pcSubStr, pCaseSensitive)

			def RemoveManySubstringsCSQ(pSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)


	def ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)
		return This.Copy().RemoveManySubstringsCS(pacSubStr, pCaseSensitive).Content()

		def SubstringsRemovedCS(pacSubStr, pCaseSensitive)
			return This.ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)

	#-- CASEèSENSITIVE

	def RemoveMany(pacSubStr)
		for cSubstr in paCsubstr
			This.RemoveAll(cSubstr)
		next

		def RemoveManyQ(pacSubStr)
			This.RemoveMany(pacSubstr)
			return This

		def RemoveAllOfThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseQ(pacSubstr)
				return This.RemoveManyQ(pacSubStr)

		def RemoveThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveTheseQ(pacSubstr)
				return This.RemoveManyQ(pacSubStr)

		def RemoveManySubstrings(pcSubStr)
			This.RemoveMany(pacSubStr)

			def RemoveManySubstringsQ(pSubStr)
				return This.RemoveManyQ(pacSubStr)

	def ManySubstringsRemoved(pacSubStr)
		return This.Copy().RemoveManySubstrings(pacSubStr).Content()

		def SubstringsRemoved(pacSubStr)
			return This.ManySubstringsRemoved(pacSubStr)

		def TheseRemoved(pacSubStr)
			return This.ManySubstringsRemoved(pacSubStr)

	  #-------------------------------------------------#
	 #  REMOVING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#=================================================#

	def RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("--Ring--&__Softanza__")

		o1.RemoveAllExcept([ "Ring", "&", "Softanza" ])
		? o1.Content()
		#--> Ring&Softanza

		*/

		if isString(pacSubStr)
			acTemp = [] + pacSubStr
			pacSubStr = acTemp
		ok

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringsExceptCSZ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsExceptCSZQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveSubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsOtherThanCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveSubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsOtherThanCSZQ(pacSubStr, pCaseSensitive)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveAllExceptCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveAllExceptCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveExceptCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveExceptCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveAllButCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveAllButCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		#>

	def SubStringsRemovedExceptCS(pacSubStr, pCaseSensitive)
		_cResult_ = This.Copy().RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive).Content()
		return _cResult_

		def AllStringsRemovedExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsRemovedExceptCS(pacSubStr, pCaseSensitive)

		def AllRemovedExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsRemovedExceptCS(pacSubStr, pCaseSensitive)

		def RemovedExceptCs(pacSubStr, pCaseSensitive)
			return This.SubStringsRemovedExceptCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringsExcept(pacSubStr)
		This.RemoveSubStringsExceptCS(pacSubStr, 1)

		#< @FunctionFluentForm

		def RemoveSubStringsExceptQ(pacSubStr)
			return This.RemoveSubStringsExceptCSQ(pacSubStr, 1)

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringsExceptZ(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveSubStringsExceptZQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveSubStringsOtherThan(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveSubStringsOtherThanQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveSubStringsOtherThanZ(pacSubStr)
			This.RemoveSubStringsExcep(pacSubStr)

			def RemoveSubStringsOtherThanZQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveAllExcept(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveAllExceptQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveExcept(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveExceptQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveAllBut(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveAllButQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		#>

	def SubStringsRemovedExcept(pacSubStr)
		return This.SubStringsRemovedExceptCS(pacSubStr, 1)

		def AllSubStringsRemovedExcept(pacSubStr)
			return This.SubStringsRemovedExcept(pacSubStr)

		def AllRemovedExcept(pacSubStr)
			return This.SubStringsRemovedExcept(pacSubStr)

		def RemovedExcept(pacSubStr)
			return This.SubStringsRemovedExceptCS(pacSubStr)


	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenCS(pcSubStr,pcBound1, pcBound2, 1)

		def SubStringBetweenRemoved(pcSubStr,pcBound1, pcBound2)
			return This.SubStringBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, 1)

	  #---------------------------------------------------------------------------------------#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#---------------------------------------------------------------------------------------#

	def RemoveSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindSubStringBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenCSIB(pcSubStr,pcBound1, pcBound2, 1)

		def SubStringBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)
			return This.SubStringBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, 1)

	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBoundedByRemovedCS(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveSubStringBoundedByCS(pcSubStr, pacBounds, 1)

		def SubStringBoundedByRemoved(pcSubStr, pacBounds)
			return This.SubStringBoundedByRemovedCS(pcSubStr, pacBounds, 1)

	  #===========================================================================#
	 #  REMOVING A SUBSTRING BOUNDED BY TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#===========================================================================#

	def RemoveSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		aSections = This.FindubStringBoundedByAsSectionsSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)

	def SubStringBoundedByRemovedSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedBySTCSQ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVE

	def RemoveSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		This.RemoveSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, 1)

	def SubStringBoundedByRemovedST(pcSubStr, pacBounds, pnStartingAt)
		cResult = This.Copy().RemoveSubStringBoundedBySTQ(pcSubStr, pacBounds, pnStartingAt).Content()
		return cResult

	  #--------------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#--------------------------------------------------------------------------------------#
	#NOTE: encolsing substrings (bounds) are also removed

	def RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)

		aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pacBounds[1]).NumberOfChars()
		nLen2 = Q(pacBounds[2]).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

	def SubStringBoundedByRemovedCSIB(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, 1)

	def SubStringBoundedByRemovedIB(pcSubStr, pcBound1, pcBound2)
		return This.RemoveSubStringBoundedByIB(pcSubStr, pacBounds, 1)

	  #-------------------------------------------------------#
	 #  REMOVING ANY BOUNDED SUSBSTRING BY THE GIVEN BOUNDS  #
	#=======================================================#

	def RemoveAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByCSZZ(pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveAnySubStringBoundedByCSQ(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This

		def RemoveSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCS(pacBounds, pCaseSensitive)

			def RemoveSubStringsBoundedByCSQ(pacBounds, pCaseSensitive)
				return This.RemoveAnySubStringBoundedByCSQ(pacBounds, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveAnySubStringBoundedBy(pacBounds)
		This.RemoveAnySubStringBoundedByCS(pacBounds, 1)

		def RemoveAnySubStringBoundedByQ(pacBounds)
			This.RemoveAnySubStringBoundedBy(pacBounds)
			return This

		def RemoveSubStringsBoundedBy(pacBounds)
			This.RemoveAnySubStringBoundedBy(pacBounds)

			def RemoveSubStringsBoundedByQ(pacBounds)
				return This.RemoveAnySubStringBoundedByQ(pacBounds)

	  #-----------------------------------------------------------------------#
	 #  REMOVING ANY BOUNDED SUSBSTRING BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#-----------------------------------------------------------------------#

	def RemoveAnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveAnySubStringBoundedByCSIBQ(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)
			return This

		def RemoveSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)

			def RemoveSubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
				return This.RemoveAnySubStringBoundedByCSIBQ(pacBounds, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveAnySubStringBoundedByIB(pacBounds)
		This.RemoveAnySubStringBoundedByCSIB(pacBounds, 1)

		def RemoveAnySubStringBoundedByIBQ(pacBounds)
			This.RemoveAnySubStringBoundedByIB(pacBounds)
			return This

		def RemoveSubStringsBoundedByIB(pacBounds)
			This.RemoveAnySubStringBoundedByIB(pacBounds)

			def RemoveSubStringsBoundedByIBQ(pacBounds)
				return This.RemoveAnySubStringBoundedByIBQ(pacBounds)

	  #-----------------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BOUNDED BY TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------------#

	def RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsSTCS(pacBounds, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveAnySubStringsBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
			This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)

		def RemoveSubStringsBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
			This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)

	def AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveAnySubStringBoundedBySTCSQ(pacBounds, pnStartingAt, pCaseSensitive).Content()
		return cResult

		def AnySubStringsBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)

		def SubStringsBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)
		This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, 1)

		def RemoveAnySubStringsBoundedByST(pacBounds, pnStartingAt)
			This.RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)

		def RemoveSubStringsBoundedByST(pacBounds, pnStartingAt)
			This.RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)

	def AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)
		cResult = This.Copy().RemoveAnySubStringBoundedBySTQ(pacBounds, pnStartingAt).Content()
		return cResult

		def AnySubStringsBoundedByRemovedST(pacBounds, pnStartingAt)
			return This.AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)

		def SubStringsBoundedByRemovedST(pacBounds, pnStartingAt)
			return This.AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)

	  #====================================#
	 #  REMOVING A SUBSTRING -- EXTENDED  #
	#====================================#

	def RemoveCSXT(p1, p2, pCaseSensitive)

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").RemoveXT("♥", [])
		if isString(p1) and

			( (isList(p2)   and len(p2) = 0) or
			  (isString(p2) and p2 = "") or
			  (isNumber(p2) and p2 = 0) )

			This.RemoveCS(p1, pCaseSensitive)
			return

		# Q("/♥♥♥\__/♥\/♥♥\__/♥\__").RemoveXT([], "♥")
		but isString(p2) and

			( (isList(p1)   and len(p1) = 0) or
			  (isString(p1) and p1 = "") or
			  (isNumber(p1) and p1 = 0) )

			This.RemoveCS(p2, pCaseSensitive)
			return

		# Q("/♥\__/♥\__/♥♥\__/♥\__").RemoveXT(:Nth = 4, "♥")
		but isString(p2) and

		    ( isList(p1) and len(p1) = 2 and
		      isString(p1[1]) and p1[1] = :Nth and
		      isNumber(p1[2]) )

			This.RemoveNthCS(p1[2], p2, pCaseSensitive)
		ok


		if isList(p1) and StzListQ(p1).IsEachNamedParam()
			p1 = p1[2]
		ok


		if isList(p2)
			oP2 = new stzList(p2)

			if oP2.IsAtNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				but isList(p2) and StzListQ(p2).IsListOfNumbers()
					This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number or a list of numbers.")
				ok
					
			# Q("^^♥^^").RemoveXT( "♥", :AtPosition = 4)
			but oP2.IsAtPositionNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number.")
				ok
	
			#-- Removing at many positions
			#TODO // Add example here for better readability
			but oP2.IsAtPositionsNamedParam()
				p2 = p2[2]
	
				if NOT ( isList(p2) and StzListQ(p2).IsListOfNumbers() )
					stzRaise("Incorrect param type! p2 must be a list of numbers.")
				ok
	
				This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

			# Removing from, Nth from, First from, Last from
			#TODO // Add examples here for better readability
			but oP2.IsFromNamedParam()
				p2 = p2[2]

				# Removing from

				if isString(p1)
					cNewSubStr =  Q(p2) - p1
	
				# Removing Nth from

				but isList(p1) and StzListQ(p1).IsNthNamedParam()
					n = p1[2][1]
					p1 = p1[2][2]

					cNewSubStr = Q(p2).
							RemoveNthCSQ(n, p1, pCaseSensitive).
							Content()

				# Removing first from

				but isList(p1) and StzListQ(p1).IsFirstNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveFirstCSQ(p1, pCaseSensitive).
							Content()

				but isList(p1) and StzListQ(p1).IslastNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveLastCSQ(p1, pCaseSensitive).
							Content()

				ok

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing after
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :After, :AfterEach  ])

				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing after nth
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterNth ])
				n = p2[2][1]
				p2 = p2[2][2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after first
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after last
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing Before
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Before, :BeforeEach  ])

				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before nth
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeNth ])
				n = p2[2][1]
				p2 = p1 + p2[2][2]
				
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing before first
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeFirst, :ToFirst ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before last
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeLast, :ToLast ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing around
			#TODO // Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				p2 = p2[2]

				if isList(p1) and StzListQ(p1).IsPairOfStrings()

					This.ReplaceCS(
						(p1[1] + p2 + p1[2]),
						p2,
						pCaseSensitive)

				else	
					This.ReplaceCS(
						(p1 + p2 + p1),
						p2,
						pCaseSensitive)
				ok

			# Removing around nth
			#TODO // Add example here for better readability
			but oP2.IsAroundNthNamedParam()
				
				n = p2[2][1]
				p2 = p2[2][2]

				if isString(n)
					if n = :First
						n = 1

					but n = :Last
						n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
					ok
				ok

				if NOT isNumber(n)
					StzRaise("Incorrect param! n must be a number.")
				ok

				if NOT isString(p2)
					StzRaise("Incorrect param! p2 must be a string.")
				ok

				# Forcing p1 to be a pair of lists

				if isString(p1)
					aTemp = []
					aTemp + p1 + p1
					p1 = aTemp	
				ok

				if NOT ( isList(p1) and @IsPairOfStrings(p1) )
					StzRaise("Incorrect param type! p1 must be a string or a pair of strings.")
				ok

				# Finding the section of the nth substring

				anSection = This.FindNthAsSection(n, p2)
				
				n1 = anSection[1] - Q(p1[1]).NumberOfChars()
				n2 = anSection[2] + Q(p1[2]).NumberOfChars()
				
				# If the substring is really bounded by the substrings to remove
				# then we make the necessary to remove them from the string

				if This.Section(n1, anSection[1] - 1) = p1[1] and
				   This.Section(anSection[2] + 1, n2) = p1[2]
				
					This.ReplaceSection(n1, n2, p2)
				ok

				# Otherwise, we do nothing.

			# Removing around first
			#TODO // Add example for better readability
			but oP2.IsAroundFirstNamedParam()
				RemoveXT(p1, :AroundNth = [1, p2[2]])

			# Removing around last

			but oP2.IsAroundLastNamedParam()
				RemoveXT(p1, :AroundNth = [:Last, p2[2]])

			#-- Removing between

			# Q("__/\/\__/♥\__").RemoveXT("♥", :Between = ["/","\"])
			# Q("__/\/\__/♥\__").RemoveXT("♥", :BetweenIB = ["/","\"])
			but oP2.IsOneOfTheseNamedParams([
				:Between, :BetweenIB, :BetweenS, :BetweenIBS ])

				cBetween = p2[1]
				p2  = p2[2]

				if isList(p2) and len(p2) = 2 and
				   isList(p2[2]) and p2[2][1] = :And

					p2[2] = p2[2][2]
				ok

				if NOT ( isList(p2) and StzListQ(p2).IsPairOfStrings() )
					stzRaise("Incorrect param type! p2 must be a pair of strings.")
				ok

				if isString(p1) and p1 != ""
					if cBetween = :Between
						This.RemoveSubStringBetweenCS(p1, p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveSubStringBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)
		
					ok

				but (isList(p1) and len(p1) = 0) or
				    (isString(p1) and p1 = "") or
				    (isNumber(p1) and p1 = 0)

					if cBetween = :Between
						This.RemoveAnyBetweenCS(p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveAnyBetweenCSIB(p2[1], p2[2], pCaseSensitive)
		
					ok
	
				ok

	
			# Q("__/\/\__^^♥^^__").RemoveXT("♥", :BoundedBy = "^^")
			# Q("__/\/\__^^♥^^__").RemoveXT("♥", :BoundedByIB = "^^")
			but oP2.IsBoundedByNamedParam() or
			    oP2.IsBoundedByIBNamedParam()

				cBounded = p2[1]

				cBound1 = ""
				cBound2 = ""

				if isString(p2[2])
					cBound1 = p2[2]
					cBound2 = p2[2]

				but isList(p2[2]) and StzListQ(p2[2]).IsPairOfStrings()
					cBound1 = p2[2][1]
					cBound2 = p2[2][2]

				but isList(p2[2]) and len(p2[2]) = 2 and
				    isString(p2[2][1]) and
				    isList(p2[2][2]) and StzListQ(p2[2][2]).IsAndNamedParam()

					cBound1 = p2[2][1]
					cBound2 = p2[2][2][2]

				ok

				if cBounded = :BoundedBy
					This.RemoveSubStringBoundedByCS( p1, [ cBound1, cBound2 ], pCaseSensitive)

				but cBounded = :BoundedByIB
					This.RemoveSubStringBoundedByCSIB( p1, [ cBound1, cBound2 ], pCaseSensitive)

				ok

			ok
		ok

		def RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.RemoveCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def RemovedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveXT(pcNewSubStr, pcSubStr)
		This.RemoveCSXTQ(pcNewSubStr, pcSubStr, 1)

		def RemoveXTQ(pcNewSubStr, pcSubStr)
			This.RemoveXT(pcNewSubStr, pcSubStr)
			return This

	def RemovedXT(pcNewSubStr, pcSubStr)
		return This.Copy().RemoveXTQ(pcNewSubStr, pcSubStr).Content()

	  #---------------------------------------#
	 #   REMOVING CHAR AT A GIVEN POSITION   #
	#---------------------------------------#

	def RemoveCharAtPosition(n)
		This.ReplaceNthChar(n, "")

		def RemoveCharAtPositionQ(n)
			This.RemoveCharAtPosition(n)
			return This

		def RemoveCharAt(n)
			This.RemoveCharAtPosition(n)

			def RemoveCharAtQ(n)
				This.RemoveCharAt(n)
				return This

		def RemoveNthChar(n)
			This.RemoveCharAtPosition(n)

			def RemoveNthCharQ(n)
				This.RemoveNthChar(n)
				return This

	def CharAtPositionNRemoved(n)
		return This.Copy().RemoveCharAtPositionQ(n).Content()

		def CharAtNPositionRemoved(n)
			return This.CharAtPositionRemoved(n)

		def NthCharRemoved(n)
			return This.CharAtPositionRemoved(n)

	  #=========================#
	 #   REMOVING FIRST CHAR   #
	#=========================#

	#TODO #DONE
	# Here, case sensitivity does not apply. But it would be more
	# flexible and permissive to add it, although it has no effect.

	#TODO #FUTURE
	# Add it in all the library functions (future)

	#TODO #DONE
	# Write a narration about it


	def RemoveFirstCharCS(pCaseSensitive)
		This.RemoveNthChar(1)

		def RemoveFirstCharCSQ(pCaseSensitive)
			This.RemoveFirstCharCS(pCaseSensitive)
			return This

	#-- @FunctionPassiveForm

	def FirstCharRemovedCS(pCaseSensitive)
		return This.Copy().RemoveFirstCharCSQ(pCaseSensitive).Content()

	#== WITHOUT CASESENSITIVITY

	def RemoveFirstChar()
		This.RemoveNthChar(1)

		def RemoveFirstCharQ()
			This.RemoveFirstChar()
			return This

	#-- @FunctionPassiveForm

	def FirstCharRemoved()
		return This.Copy().RemoveFirstCharQ().Content()

	  #-----------------------------------------------------------#
	 #  REMOVING ALL LEADING OCCURRENCES OF THE FIRST CHAR - XT  #
	#-----------------------------------------------------------#

	def RemoveFirstCharXT()
		This.RemoveAnyLeadingChar()

		def RemoveFirstCharXTQ()
			This.RemoveFirstCharXT()
			return This

	def FirstCharRemovedXT()
		return This.Copy().RemoveFirstCharXTQ().Content()

	  #-----------------------#
	 #   REMOVING LAST CHAR  #
	#=======================#

	def RemoveLastChar()
		This.RemoveNthChar(This.NumberOfChars())

		def RemoveLastCharQ()
			This.RemoveLastChar()
			return This

	def LastCharRemoved()
		return This.Copy().RemoveLastCharQ().Content()

	  #----------------------------------------------------------#
	 #  REMOVING ALL LEADING OCCURRENCES OF THE LAST CHAR - XT  #
	#----------------------------------------------------------#

	def RemoveLastCharXT()
		This.RemoveAnyTrailingChar()

		def RemoveLastCharXTQ()
			This.RemoveLastCharXT()
			return This

	def LastCharRemovedXT()
		return This.Copy().RemoveLastCharXTQ().Content()

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST CHARS  #
	#==================================#

	def RemoveFirstAndLastChars()
		This.RemoveFirstChar()
		This.RemoveLastChar()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsQ()
			This.RemoveFirstAndLastChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstChars()
			This.RemoveFirstAndLastChars()

			def RemoveLastAndFirstCharsQ()
				This.RemoveLastAndFirstChars()
				return This

		#--

		def RemoveFirstCharAndLastChar()
			This.RemoveFirstAndLastChars()

			def RemoveFirstCharAndLastCharQ()
				This.RemoveFirstCharAndLastChar()
				return This

		def RemoveLastCharAndFirstChar()
			This.RemoveFirstAndLastChars()

			def RemoveLastCharAndFirstCharQ()
				This.RemoveLastCharAndFirstChar()
				return This

		#>

	def FirstAndLastCharsRemoved()
		return This.Copy().RemoveFirstAndLastCharsQ().Content()

		def LastAndFirstCharsRemoved()
			return This.FirstAndLastCharsRemoved()

		#--

		def FirstCharAndLastCharRemoved()
			return This.FirstAndLastCharsRemoved()

		def LastCharAndFirstCharRemoved()
			return This.FirstAndLastCharsRemoved()

	  #---------------------------------------#
	 #   REMOVING FIRST AND LAST CHARS -- XT #
	#=======================================#

	def RemoveFirstAndLastCharsXT()
		This.RemoveFirstCharXT()
		This.RemoveLastCharXT()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsXTQ()
			This.RemoveFirstAndLastCharsXT()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstCharsXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveLastAndFirstCharsXTQ()
				This.RemoveLastAndFirstCharsXT()
				return This

		#--

		def RemoveFirstCharAndLastCharXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveFirstCharAndLastCharXTQ()
				This.RemoveFirstCharAndLastCharXT()
				return This

		def RemoveLastCharAndFirstCharXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveLastCharAndFirstCharXTQ()
				This.RemoveLastCharAndFirstCharXT()
				return This

		#>

	def FirstAndLastCharsRemovedXT()
		return This.Copy().RemoveFirstAndLastCharsXTQ().Content()

		def LastAndFirstCharsRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

		#--

		def FirstCharAndLastCharRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

		def LastCharAndFirstCharRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

	  #-----------------------#
	 #   REMOVING LEFT CHAR  #
	#=======================#

	def RemoveLeftChar()

		if This.IsLeftToRight()

			This.RemoveFirstChar()
		else
			This.RemoveLastChar()
		ok

		def RemoveLeftCharQ()
			This.RemoveLeftChar()
			return This

	def LeftCharRemoved()
		return This.Copy().RemoveLeftCharQ().Content()

	  #----------------------------#
	 #   REMOVING LEFT CHAR -- XT #
	#----------------------------#

	def RemoveLeftCharXT()

		if This.IsLeftToRight()
			This.RemoveFirstCharXT()
		else
			This.RemoveLastCharXT()
		ok

		def RemoveLeftCharXTQ()
			This.RemoveLeftCharXT()
			return This

	def LeftCharRemovedXT()
		return This.Copy().RemoveLeftCharXTQ().Content()

	  #------------------------#
	 #   REMOVING RIGHT CHAR  #
	#========================#

	def RemoveRightChar()

		if This.IsRightToLeft()
			This.RemoveFirstChar()
		else
			This.RemoveLastChar()
		ok

		def RemoveRightCharQ()
			This.RemoveRightChar()
			return This

	def RightCharRemoved()
		return This.Copy().RemoveRightCharQ().Content()

	  #-----------------------------#
	 #   REMOVING RIGHT CHAR -- XT #
	#-----------------------------#

	def RemoveRightCharXT()

		if This.IsRightToLeft()
			This.RemoveFirstCharXT()
		else
			This.RemoveLastCharXT()
		ok

		def RemoveRightCharXTQ()
			This.RemoveRightCharXT()
			return This

	def RightCharRemovedXT()
		return This.Copy().RemoveRightCharXTQ().Content()

	  #----------------------------------#
	 #   REMOVING LEFT AND RIGHT CHARS  #
	#==================================#

	def RemoveLeftAndRightChars()

		This.RemoveleftChar()
		This.RemoverightChar()

		def RemoveLeftAndRightCharsQ()
			This.RemoveLeftAndRightChars()
			return This

		def RemoveRightAndLeftChars()
			This.RemoveLeftAndRightChars()

			def RemoveRightAndLeftCharsQ()
				return This.RemoveLeftAndRightCharsQ()

	def LeftAndRightChardRemoved()
		return This.Copy().RemoveLeftAndRightChardQ().Content()

		def RightAndLeftCharsRemoved()
			return This.LeftAndRightChardRemoved()

	  #----------------------------------------#
	 #   REMOVING LEFT AND RIGHT CHARS -- XT  #
	#----------------------------------------#

	def RemoveLeftAndRightCharsXT()

		This.RemoveleftCharXT()
		This.RemoverightCharXT()

		def RemoveLeftAndRightCharsXTQ()
			This.RemoveLeftAndRightCharsXT()
			return This

		def RemoveRightAndLeftCharsXT()
			This.RemoveLeftAndRightCharsXT()

			def RemoveRightAndLeftCharsXTQ()
				return This.RemoveLeftAndRightCharsXTQ()

	def LeftAndRightChardRemovedXT()
		return This.Copy().RemoveLeftAndRightChardXTQ().Content()

		def RightAndLeftCharsRemovedXT()
			return This.LeftAndRightChardRemovedXT()

	  #-----------------------------------------------------------------------------#
	 #  REMOVING A GIVEN CHAR AT A GIVEN POSITION (IF ANY) WITH A GIVEN SUBSTRING  #
	#=============================================================================#

	def RemoveThisNthCharCS(n, cChar, pCaseSensitive)
		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.RemoveNthChar(n)
		ok

		def RemoveThisNthCharCSQ(n, cChar, pCaseSensitive)
			This.RemoveThisNthCharCS(n, cChar, pCaseSensitive)
			return This

	def ThisNthCharRemovedCS(n, cChar, pCaseSensitive)
		return This.Copy().RemoveThisNthCharCSQ(n, cChar, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthChar(n, cChar)
		This.RemoveThisNthCharCS(n, cChar, 1)

		def RemoveThisNthCharQ(n, cChar)
			This.RemoveThisNthChar(n, cChar)
			return This

	def ThisNthCharRemoved(n, cChar)
		return This.Copy().RemoveThisNthCharQ(n, cChar).Content()

	  #---------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR   #
	#=================================#

	def RemoveThisFirstCharCS(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstChar()
		ok

		def RemoveThisFirstCharCSQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCS(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstChar(c)
		This.RemoveThisFirstCharCS(c, 1)

		def RemoveThisFirstCharQ(c)
			This.RemoveThisFirstChar(c)
			return This

	def ThisFirstCharRemoved(c)
		return This.Copy().RemoveThisFirstCharQ(c).Content()

	  #--------------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR -- XT  #
	#--------------------------------------#

	def RemoveThisFirstCharCSXT(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstCharXT()
		ok

		def RemoveThisFirstCharCSXTQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCSXT(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCSXT(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSXTQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstCharXT(c)
		This.RemoveThisFirstCharCSXT(c, 1)

		def RemoveThisFirstCharXTQ(c)
			This.RemoveThisFirstCharXT(c)
			return This

	def ThisFirstCharRemovedXT(c)
		return This.Copy().RemoveThisFirstCharXTQ(c).Content()

	  #--------------------------------#
	 #   REMOVING A GIVEN LAST CHAR   #
	#================================#

	def RemoveThisLastCharCS(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastChar()
		ok

		def RemoveThisLastCharCSQ(c, pCaseSensitive)
			This.RemoveThisLastCharCS(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastChar(c)
		This.RemoveThisLastCharCS(c, 1)

		def RemoveThisLastCharQ(c)
			This.RemoveThisLastChar(c)
			return This

	def ThisLastCharRemoved(c)
		return This.Copy().RemoveThisLastCharQ(c).Content()

	  #-------------------------------------#
	 #   REMOVING A GIVEN LAST CHAR -- XT  #
	#-------------------------------------#

	def RemoveThisLastCharCSXT(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastCharXT()
		ok

		def RemoveThisLastCharCSXTQ(c, pCaseSensitive)
			This.RemoveThisLastCharCSXT(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCSXT(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSXTQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastCharXT(c)
		This.RemoveThisLastCharCSXT(c, 1)

		def RemoveThisLastCharXTQ(c)
			This.RemoveThisLastCharXT(c)
			return This

	def ThisLastCharRemovedXT(c)
		return This.Copy().RemoveThisLastCharXTQ(c).Content()


	  #-------------------------------#
	 #   REMOVING N CHARS FROM LEFT  #
	#===============================#

	def RemoveNCharsFromLeft(n)
		This.RemoveSection(1, n)

		def RemoveNCharsFromLeftQ(n)
			This.RemoveNCharsFromLeft(n)
			return This

		def RemoveNCharsLeft(n)
			This.RemoveNCharsFromLeft(n)

			def RemoveNCharsLeftQ(n)
				return This.RemoveNCharsFromLeftQ(n)

	def NCharsRemovedFromLeft(n)
		return This.Copy(n).RemoveNCharsFromLeftQ(n).Content()

		def NCharsRemovedLeft(n)
			return This.NCharsRemovedFromLeft(n)

	  #--------------------------------#
	 #   REMOVING N CHARS FROM RIGHT  #
	#--------------------------------#

	def RemoveNCharsFromRight(n)
		nLen = This.NumberOfChars()
		This.RemoveSection(nLen - n + 1, nLen)

		def RemoveNCharsFromRightQ(n)
			This.RemoveNCharsFromRight(n)
			return This

		def RemoveNCharsRight(n)
			This.RemoveNCharsFromRight(n)

			def RemoveNCharsRightQ(n)
				return This.RemoveNCharsFromRightQ(n)

	def NCharsRemovedFromRight(n)
		return This.Copy(n).RemoveNCharsFromRightQ(n).Content()

		def NCharsRemovedRight(n)
			return This.NCharsRemovedFromRight(n)

	  #--------------------------------#
	 #   REMOVING N CHARS FROM START  #
	#================================#

	def RemoveNCharsFromStart(n)
		if This.IsLeftToRight()
			This.RemoveSection(1, n)
		else
			nLen = This.NumberOfChars()
			This.RemoveSection(nLen- n + 1, nLen)
		ok

		def RemoveNCharsFromStartQ(n)
			This.RemoveNCharsFromStart(n)
			return This

		def RemoveNCharsStart(n)
			This.RemoveNCharsFromStart(n)

			def RemoveNCharsStartQ(n)
				return This.RemoveNCharsFromStartQ(n)

	def NCharsRemovedFromStart(n)
		return This.Copy(n).RemoveNCharsFromStartQ(n).Content()

		def NCharsRemovedStart(n)
			return This.NCharsRemovedFromStart(n)

	  #------------------------------#
	 #   REMOVING N CHARS FROM END  #
	#------------------------------#

	def RemoveNCharsFromEnd(n)
		if This.IsRightToLeft()
			This.RemoveSection(1, n)
		else
			nLen = This.NumberOfChars()
			This.RemoveSection(nLen- n + 1, nLen)
		ok

		def RemoveNCharsFromEndQ(n)
			This.RemoveNCharsFromEnd(n)
			return This

		def RemoveNCharsEnd(n)
			This.RemoveNCharsFromEnd(n)

			def RemoveNCharsEndQ(n)
				return This.RemoveNCharsFromEndQ(n)

	def NCharsRemovedFromEnd(n)
		return This.Copy(n).RemoveNCharsFromEndQ(n).Content()

		def NCharsRemovedEnd(n)
			return This.NCharsRemovedFromEnd(n)

	  #-------------------------------------------------#
	 #   REMOVING FIRST CHAR UNDER A GIVEN CONDITION   #
	#=================================================#

	def RemoveFirstCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindFirstCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveFirstCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveFirstCharWCS(pcCondition, pCaseSensitive)
			return This

	def FirstCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveFirstCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstCharW(pcCondition)
		This.RemoveFirstCharWCS(pcCondition, 1)

		def RemoveFirstCharWQ(pcCondition)
			This.RemoveFirstCharW(pcCondition)
			return This

	def FirstCharRemovedW(pcCondition)
		return This.Copy().RemoveFirstCharWQ(pcCondition).Content()

	  #------------------------------------------------------#
	 #   REMOVING FIRST CHAR UNDER A GIVEN CONDITION -- XT   #
	#-------------------------------------------------------#

	def RemoveFirstCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindFirstCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveFirstCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveFirstCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def FirstCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveFirstCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstCharWXT(pcCondition)
		This.RemoveFirstCharWCSXT(pcCondition, 1)

		def RemoveFirstCharWXTQ(pcCondition)
			This.RemoveFirstCharWXT(pcCondition)
			return This

	def FirstCharRemovedWXT(pcCondition)
		return This.Copy().RemoveFirstCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING LAST CHAR UNDER A GIVEN CONDITION   #
	#================================================#

	def RemoveLastCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindLastCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLastCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLastCharWCS(pcCondition, pCaseSensitive)
			return This

	def LastCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLastCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastCharW(pcCondition)
		This.RemoveLastCharWCS(pcCondition, 1)

		def RemoveLastCharWQ(pcCondition)
			This.RemoveLastCharW(pcCondition)
			return This

	def LastCharRemovedW(pcCondition)
		return This.Copy().RemoveLastCharWQ(pcCondition).Content()

	  #-----------------------------------------------------#
	 #   REMOVING LAST CHAR UNDER A GIVEN CONDITION -- XT  #
	#-----------------------------------------------------#

	def RemoveLastCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindLastCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLastCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLastCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def LastCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLastCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastCharWXT(pcCondition)
		This.RemoveLastCharWCSXT(pcCondition, 1)

		def RemoveLastCharWXTQ(pcCondition)
			This.RemoveLastCharWXT(pcCondition)
			return This

	def LastCharRemovedWXT(pcCondition)
		return This.Copy().RemoveLastCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING LEFT CHAR UNDER A GIVEN CONDITION   #
	#================================================#

	def RemoveLeftCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindLeftCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLeftCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLeftCharWCS(pcCondition, pCaseSensitive)
			return This

	def LeftCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLeftCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLeftCharW(pcCondition)
		This.RemoveLeftCharWCS(pcCondition, 1)

		def RemoveLeftCharWQ(pcCondition)
			This.RemoveLeftCharW(pcCondition)
			return This

	def LeftCharRemovedW(pcCondition)
		return This.Copy().RemoveLeftCharWQ(pcCondition).Content()

	  #-----------------------------------------------------#
	 #   REMOVING LEFT CHAR UNDER A GIVEN CONDITION -- XT  #
	#-----------------------------------------------------#

	def RemoveLeftCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindLeftCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLeftCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLeftCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def LeftCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLeftCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLeftCharWXT(pcCondition)
		This.RemoveLeftCharWCSXT(pcCondition, 1)

		def RemoveLeftCharWXTQ(pcCondition)
			This.RemoveLeftCharWXT(pcCondition)
			return This

	def LeftCharRemovedWXT(pcCondition)
		return This.Copy().RemoveLeftCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING RIGHT CHAR UNDER A GIVEN CONDITION  #
	#================================================#

	def RemoveRightCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindRightCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveRightCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveRightCharWCS(pcCondition, pCaseSensitive)
			return This

	def RightCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveRightCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveRightCharW(pcCondition)
		This.RemoveRightCharWCS(pcCondition, 1)

		def RemoveRightCharWQ(pcCondition)
			This.RemoveRightCharW(pcCondition)
			return This

	def RightCharRemovedW(pcCondition)
		return This.Copy().RemoveRightCharWQ(pcCondition).Content()

	  #------------------------------------------------------#
	 #   REMOVING RIGHT CHAR UNDER A GIVEN CONDITION -- XT  #
	#------------------------------------------------------#

	def RemoveRightCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindRightCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveRightCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveRightCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def RightCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveRightCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveRightCharWXT(pcCondition)
		This.RemoveRightCharWCSXT(pcCondition, 1)

		def RemoveRightCharWXTQ(pcCondition)
			This.RemoveRightCharWXT(pcCondition)
			return This

	def RightCharRemovedWXT(pcCondition)
		return This.Copy().RemoveRightCharWXTQ(pcCondition).Content()

	  #----------------------------#
	 #   REMOVING N FIRST CHARS   #
	#============================#

	def RemoveNFirstChars(n)
		if This.IsRightToLeft()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok
		
		#< @FunctionFluentForm

		def RemoveNFirstCharsQ(n)
			This.RemoveNFirstChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstNChars(n)
			This.RemoveNFirstChars(n)

			#< @FuncFluentForm
	
			def RemoveFirstNCharsQ(n)
				This.RemoveNFirstCharsQ(n)
	
			#>

		#>
	
	def NFirstCharsRemoved(n)
		cResult = This.Copy().RemoveNFirstCharsQ(n).Content()
		return cResult

		def FirstNCharsRemoved(n)
			return This.NFirstCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LAST CHARS   #
	#---------------------------#

	def RemoveNLastChars(n)

		if This.IsLeftToRight()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok	

		#< @FunctionFluentForm

		def RemoveNLastCharsQ(n)
			This.RemoveNLastChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastNChars(n)
			This.RemoveNLastChars(n)

			#< @FuncFluentForm
	
			def RemoveLastNCharsQ(n)
				This.RemoveNLastCharsQ(n)
	
			#>

		#>
	
	def NLastCharsRemoved(n)
		cResult = This.Copy().RemoveNLastCharsQ(n).Content()
		return cResult

		def LastNCharsRemoved(n)
			return This.NLastCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LEFT CHARS   #
	#---------------------------#

	def RemoveNLeftChars(n)
		if This.IsLeftToRight()
			This.RemoveSection( 1, n )

		else
			nLen = This.NumberOfChars()
			This.RemoveSection( This.NumberOfChars() - n + 1, nLen )
		ok

		#< @FunctionFluentForm

		def RemoveNLeftCharsQ(n)
			This.RemoveNLeftChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLeftNChars(n)
			This.RemoveNLeftChars(n)

			#< @FuncFluentForm
	
			def RemoveLeftNCharsQ(n)
				This.RemoveNLeftCharsQ(n)
	
			#>
		#>
	
	def NLeftCharsRemoved(n)
		cResult = This.Copy().RemoveNLeftCharsQ(n).Content()
		return cResult

		def LeftNCharsRemoved(n)
			return This.NLeftCharsRemoved(n)

	  #----------------------------#
	 #   REMOVING N RIGHT CHARS   #
	#----------------------------#

	def RemoveNRightChars(n)
		if This.IsRightToLeft()
			This.RemoveSection( 1, n)
		else
			nLen = This.NumberOfChars()
			This.RemoveSection( This.NumberOfChars() - n + 1, nLen )
		ok

		#< @FunctionFluentForm

		def RemoveNRightCharsQ(n)
			This.RemoveNRightChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveRightNChars(n)
			This.RemoveNRightChars(n)

			#< @FuncFluentForm
	
			def RemoveRightNCharsQ(n)
				This.RemoveNRightCharsQ(n)
	
			#>
		#>
	
	def NRightCharsRemoved(n)
		cResult = This.Copy().RemoveNRightCharsQ(n).Content()
		return cResult

		def RightNCharsRemoved(n)
			return This.NRightCharsRemoved(n)

	  #---------------------------------------------#
	 #    REMOVING A GIVEN CHAR FROM THE STRING    # 
	#---------------------------------------------#

	def RemoveCharCS(pcChar, pCaseSensitive)

		if CheckingParams()

			if NOT (isString(pcChar) and @IsChar(pcChar))
				stzRaise("Incorrect param type! You must provide a string containing a char.")
			ok
		ok

		This.RemoveCS(pcChar, pCaseSensitive)

		def RemoveCharCSQ(pcChar, pCaseSensitive)
			This.RemoveCharCS(pcChar, pCaseSensitive)
			return This

	def CharRemovedCS(pcChar, pCaseSensitive)
		cResult = This.Copy().RemoveCharCSQ(pcChar, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveChar(pcChar)
		This.RemoveCharCS(pcChar, 1)

		def RemoveCharQ(pcChar)
			This.RemoveChar(pcChar)
			return This

	def CharRemoved(pcChar)
		cResult = This.Copy().RemoveCharQ(pcChar).Content()
		return cResult

	  #---------------------------------------------------#
	 #    FILLING A SECTION OF CHARS WITH A GIVEN CHAR   # 
	#===================================================#
	
	// Fills a portion of the string defined by its start and end positions
	def FillSection(n1, n2, pcChar)
		#< @QtBased = 1 #>

		if CheckingParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isString(n1) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n1 ) = 0

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n2 ) = 0

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok

			if n2 = :LastChar or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

			#==

			if isList(pcChar) and StzListQ(pcChar).IsWithOrByOrUsingNamedParam()
				pcChar= pcChar[2]
			ok

			if NOT @IsChar(pcChar)
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok

		ok

		# Doing the job

		n = n2 - n1 + 1
		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, @Copy(pcChar, n))
		This.Update(cResult)

		def FillSectionQ(n1, n2, pcChar)
			This.FillSection(n1, n2, pcChar)
			return This

	def SectionFilled(n1, n2, pcChar)
		cResult = This.Copy().FillSectionQ(n1, n2, pcChar).Content()
		return cResult
	
	  #---------------------------------------------------------#
	 #    FILLING MANY SECTIONS OF CHARS WITH THE GIVEN CHAR   # 
	#---------------------------------------------------------#

	def FillManySections(paSections, pcChar)
 		/* EXAMPLE
		
		o1 = new stzString("**Word1***Word2**Word3***")

		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.FillSections([ 	[1,2], [8, 10], [16, 17], [23, 25] ], :With = "^")
		
		? o1.Content()
		#--> "^^Word1^^^Word2^^Word3^^^"

		*/

		if CheckParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		_nLen_ = len(paSections)
		if _nLen_ = 0
			return
		ok

		# Merging any inclusive or overlapping sections

		_aMerged_ = StzListOfSectionsQ(paSections).SortQ().Merged()
		_nLen_ = len(_aMerged_)

		# Doing the job

		_oCopy_ = This.Copy()

		# NOTE: Sections are not filled directly by altering the main object
		# to maintain a clean history, which is stored in @aHisto.
		# Instead, the history is updated only once after all 
		# sections have been filled, using the UpdateWith() method.

		for @i = _nLen_ to 1 step -1
			_oCopy_.FillSection(_aMerged_[@i][1], _aMerged_[@i][2], pcChar)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def FillManySectionsQ(paListOfSections, pcChar)
			This.FillManySections(paListOfSections, pcChar)
			return This

		#>

		#< @FunctionAlternativeForm

		def FillSections(paListOfSections, pcChar)
			This.FillManySections(paListOfSections, pcChar)

			def FillSectionsQ(paListOfSections, pcChar)
				This.FillSections(paListOfSections, pcChar)
				return This

		#>

	def ManySectionsFilld(paListOfSections, pcChar)
		cResult = This.Copy().FillManySectionsQ(paListOfSections, pcChar).Content()
		return This

		def SectionsFilld(paListOfSections, pcChar)
			return This.ManySectionsFilld(paListOfSections, pcChar)

	  #---------------------------------#
	 #    EARSING A SECTION OF CHARS   # 
	#================================#
	
	// Erases a portion of the string defined by its start and end positions
	def EraseSection(n1, n2)
		#< @QtBased = 1 #>

		if CheckingParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isString(n1) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n1 ) = 0

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n2 ) = 0

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok

			if n2 = :LastChar or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

		ok

		# Doing the job

		n = n2 - n1 + 1
		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, @Copy(" ", n))
		This.Update(cResult)

		def EraseSectionQ(n1, n2)
			This.EraseSection(n1, n2)
			return This

	def SectionErased(n1, n2)
		cResult = This.Copy().EraseSectionQ(n1, n2).Content()
		return cResult
	
	  #-------------------------------------------------------#
	 #    ERASING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#-------------------------------------------------------#

	def EraseManySections(paSections)
 		/* EXAMPLE
		
		o1 = new stzString("**Word1***Word2**Word3***")

		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.EraseSections([
			[1,2], [8, 10], [16, 17], [23, 25]
		])
		
		? o1.Content()
		#--> "  Word1   Word2  Word3   "

		*/
		if CheckParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		_nLen_ = len(paSections)
		if _nLen_ = 0
			return
		ok

		# Merging any inclusive or overlapping sections

		_aMerged_ = StzListOfSectionsQ(paSections).SortQ().Merged()
		_nLen_ = len(_aMerged_)

		# Doing the job

		_oCopy_ = This.Copy()

		# NOTE: Sections are not erased directly by altering the object
		# to maintain a clean history, which is stored in @aHisto.
		# Instead, the history is updated only once after all 
		# sections have been erased, using the UpdateWith() method.

		for @i = _nLen_ to 1 step -1
			_oCopy_.EraseSection(_aMerged_[@i][1], _aMerged_[@i][2])
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def EraseManySectionsQ(paListOfSections)
			This.EraseManySections(paListOfSections)
			return This

		#>

		#< @FunctionAlternativeForm

		def EraseSections(paListOfSections)
			This.EraseManySections(paListOfSections)

			def EraseSectionsQ(paListOfSections)
				This.EraseSections(paListOfSections)
				return This

		#>

	def ManySectionsErased(paListOfSections)
		cResult = This.Copy().EraseManySectionsQ(paListOfSections).Content()
		return This

		def SectionsErased(paListOfSections)
			return This.ManySectionsErased(paListOfSections)

	  #----------------------------------#
	 #    REMOVING A SECTION OF CHARS   # 
	#==================================#
	
	// Removes a portion of the string defined by its start and end positions
	def RemoveSection(n1, n2)
		#< @QtBased = 1 #>

		if CheckingParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isString(n1) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n1 ) = 0

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and
			   ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n2 ) = 0

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok

			if n2 = :LastChar or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

		ok

		# Doing the job

		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, "")
		This.Update(cResult)

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

	def SectionRemoved(n1, n2)
		cResult = This.Copy().RemoveSectionQ(n1, n2).Content()
		return cResult
	
	  #-------------------------------------------------------#
	 #    REMOVING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#-------------------------------------------------------#

	def RemoveManySections(paSections)
 		/* EXAMPLE
		
		o1 = new stzString("**Word1***Word2**Word3***")

		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.RemoveSections([
			[1,2], [8, 10], [16, 17], [23, 25]
		])
		
		? o1.Content()
		#--> "Word1Word2Word3"

		*/

		if isList(paSections)
			paSections = StzListQ(paSections).ItemRemoved([])
		ok

		if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		_nLen_ = len(paSections)
		if _nLen_ = 0
			return
		ok

		# Merging any inclusive or overlapping sections

		_aMerged_ = StzListOfSectionsQ(paSections).SortQ().Merged()
		_nLen_ = len(_aMerged_)

		# Doing the job

		_oCopy_ = This.Copy()

		# NOTE: Sections are not removed directly from the object
		# to maintain a clean history, which is stored in @aHisto.
		# Instead, the history is updated only once after all 
		# sections have been removed, using the UpdateWith() method.

		for @i = _nLen_ to 1 step -1
			_oCopy_.RemoveSection(_aMerged_[@i][1], _aMerged_[@i][2])
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveManySectionsQ(paListOfSections)
			This.RemoveManySections(paListOfSections)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSections(paListOfSections)
			This.RemoveManySections(paListOfSections)

			def RemoveSectionsQ(paListOfSections)
				This.RemoveSections(paListOfSections)
				return This

		#>

	def ManySectionsRemoved(paListOfSections)
		cResult = This.Copy().RemoveManySectionsQ(paListOfSections).Content()
		return This

		def SectionsRemoved(paListOfSections)
			return This.ManySectionsRemoved(paListOfSections)

	  #----------------------------------------------------------#
	 #   REMOVING THE OCCURRENCES OF A SUBSTRING IN A SECTION   # 
	#----------------------------------------------------------#

	def RemoveInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		aSections = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveInSectionCSQ(pcSubStr, n1, n2, pCaseSensitive)
			This.RemoveInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This

	def SubStringRemovedInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		cResult = This.Copy().RemoveInSectionCSQ(pcSubStr, n1, n2, pCaseSensitive).Content()
		return cResult

	#--

	def RemoveInSection(pcSubStr, n1, n2)
		This.RemoveInSectionCS(pcSubStr, n1, n2, 1)

		def RemoveInSectionQ(pcSubStr, n1, n2)
			return This.RemoveInSectionCSQ(pcSubStr, n1, n2, 1)

	def SubStringRemoveInSection(pcSubStr, n1, n2)
		return This.SubStringRemovedInSectionCS(pcSubStr, n1, n2, 1)

	  #--------------------------------------------------------------#
	 #   REMOVING THE OCCURRENCES OF A SUBSTRING IN MANY SECTIONS   # 
	#--------------------------------------------------------------#

	def RemoveInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		aSections = This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveInSectionsCSQ(pcSubStr, paSections, pCaseSensitive)
			This.RemoveInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This

	def SubStringRemovedInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		cResult = This.Copy().RemoveInSectionsCSQ(pcSubStr, paSections, pCaseSensitive).Content()
		return cResult

	#--

	def RemoveInSections(pcSubStr, paSections)
		This.RemoveInSectionsCS(pcSubStr, paSections, 1)

		def RemoveInSectionsQ(pcSubStr, paSections)
			return This.RemoveInSectionsCSQ(pcSubStr, paSections, 1)

	def SubStringRemoveInSections(pcSubStr, paSections)
		return This.SubStringRemovedInSectionCS(pcSubStr, paSections, 1)

	  #-------------------------------------#
	 #  REMOVING SPACES IN GIVEN SECTIONS  #
	#-------------------------------------#

	def RemoveSpacesInSections(paSections)

		# Getting the parts non concerned with the removal of spaces

		acAntiSections = This.AntiSections(paSections)
		nLenAntiSections = len(acAntiSections)

		# Getting the sections without spaces

		nLenSections = len(paSections)
		oaStzStr = This.SectionsQ(paSections).ToListOfStzStrings()

		acSections = []
		for i = 1 to nLenSections
			acSections + oaStzStr[i].WithoutSpaces()
		next

		# Constructing the string again

		cResult = ""

		if nLenAntiSections > nLenSections

			for i = 1 to nLenSections
				cResult += (acAntiSections[i] + acSections[i])
			next

			cResult += acAntiSections[nLenAntiSections]

		but nLenSections > nLenAntiSections

			for i = 1 to nLenAntiSections
				cResult += (acSections[i] + acAntiSections[i])
			next

			cResult += acSections[nLenSections]

		else // nLenSections = nLenAntiSections

			if paSections[1][1] = 1
	
				for i = 1 to nLenAntiSections
					cResult += (acSections[i] + acAntiSections[i])
				next

			else

				for i = 1 to nLenSections
					cResult += (acAntiSections[i] + acSections[i])
				next

			ok
		ok

		This.UpdateWith(cResult)


		def RemoveSpacesInSectionsQ(paSections)
			This.RemoveSpacesInSections()
			return This


	def SpacesInSectionsRemoved(paSections)
		cResult = This.Copy().RemoveSpacesInSectionsQ(paSections).Content()
		return cResult

	  #--------------------------------#
	 #    REMOVING A RANGE OF CHARS   # 
	#===============================#

	// Removes a portion of the string defined by a start position and
	// a range of n chars

	def RemoveRange(nStart, nRange)

		if CheckingParams()
			if NOT @IsNumberOrString(nStart)
				StzRaise("Incorrect param type! nStart must be a number or string.")
			ok

			if isString(nStart) and NOT ( nStart = :FirstChar or nStart = :Start or nStart = :StartOfString )
				StzRaise("Incorrect value! nStart can only be one of these strings: :FirstChar, :Start, :StartOfString.")
			ok

			if nStart = :FirstChar or nStart = :Start or nStart = :StartOfString
				nStart = 1
			ok

		ok

		This.RemoveSection(nStart, nStart + nRange - 1)

		def RemoveRangeQ(nStart, nRange)
			This.RemoveRange(nStart, nNumberOfChars)
			return This

	def RangeRemoved(nStart, nRange)
		cResult = This.RemoveRangeQ(nStart, nRange).Content()
		return cResult

	  #-----------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#-----------------------------------------------------#

	def RemoveManyRanges(paRanges)

		if NOT ( isList(paRanges) and StzListQ(paRanges).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManyRanges(paRanges)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paRanges) is not a list of pairs of numbers."
			])

		ok

		if isList(paRanges)
			oSections = new stzList(paRanges)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paRanges = oSections.Content()
			
		ok

		# Tranform ranges to sections and then use RemoveManySections()

		nLen = len(paRanges)
		aSections = []

		for i = 1 to nLen
			n1 = paRanges[i][1]
			n2 = paRanges[i][1] + paRanges[i][2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.RemoveManySections(aSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManySections(paRanges)

		def RemoveRanges(paRanges)
			This.RemoveManyRanges(paRanges)

			def RemoveRangesQ(paRanges)
				This.RemoveRanges(paRanges)
				return This

	def ManyRangesRemoved(paRanges)
		cResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return This

		def RangedRemoved(paRanges)
			return This.ManyRangesRemoved(paRanges)

	  #-------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION   # 
	#=================================================#

	def RemoveCharsWhereCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveCharsWhereCSQ(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharsWCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveCharsWCSQ(pcCondition, pCaseSensitive)
				This.RemoveCharsWCS(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWhereCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveAllcharsWhereCSQ(pcCondition, pCaseSensitive)
				This.RemoveAllcharsWhereCS(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveAllcharsWCSQ(pcCondition, pCaseSensitive)
				This.RemoveAllCharsWhereCS(pcCondition, pCaseSensitive)
				return This

		#>

	#-- @PassiveForm
	def CharsRemovedWCS(pcCondition, pCaseSensitive)
		aResult = This.Copy().RemoveCharsWCSQ(pcCondition, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveCharsWhere(pcCondition)
		This.RemoveCharsWhereCS(pcCondition, 1)

		#< @FunctionFluentForm

		def RemoveCharsWhereQ(pcCondition)
			This.RemoveCharsWhere(pcCondition)
			return This

		#>

		def RemoveCharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveCharsWQ(pcCondition)
				This.RemoveCharsW(pcCondition)
				return This

		def RemoveAllcharsWhere(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWhereQ(pcCondition)
				This.RemoveAllcharsWhere(pcCondition)
				return This

		def RemoveAllcharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWQ(pcCondition)
				This.RemoveAllCharsWhere(pcCondition)
				return This

	#-- @PassiveForm
	def CharsRemovedW(pcCondition)
		aResult = This.Copy().RemoveCharsWQ(pcCondition).Content()
		return aResult

	  #----------------------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  # 
	#----------------------------------------------------------------#

	def RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveCharsWhereCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharsWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereWCSXT(pcCondition, pCaseSensitive)

			def RemoveCharsWCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveCharsWCSXT(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWhereWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)

			def RemoveAllcharsWhereCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveAllcharsWhereCSXT(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)

			def RemoveAllcharsWCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveAllCharsWhereCSXT(pcCondition, pCaseSensitive)
				return This

		#>

	#-- @PassiveForm
	def CharsRemovedWCSXT(pcCondition, pCaseSensitive)
		aResult = This.Copy().RemoveCharsWCSXTQ(pcCondition, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveCharsWhereXT(pcCondition)
		This.RemoveCharsWhereCSXT(pcCondition, 1)

		#< @FunctionFluentForm

		def RemoveCharsWhereXTQ(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)
			return This

		#>

		def RemoveCharsWXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveCharsWXTQ(pcCondition)
				This.RemoveCharsWXT(pcCondition)
				return This

		def RemoveAllcharsWhereXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveAllcharsWhereXTQ(pcCondition)
				This.RemoveAllcharsWhereXT(pcCondition)
				return This

		def RemoveAllcharsWXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveAllcharsWXTQ(pcCondition)
				This.RemoveAllCharsWhereXT(pcCondition)
				return This

	#-- @PassiveForm
	def CharsRemovedWXT(pcCondition)
		aResult = This.Copy().RemoveCharsWXTQ(pcCondition).Content()
		return aResult

	  #-----------------------------------#
	 #    REPLACING A SECTION OF CHARS   # 
	#===================================#
	
	// Replaces a portion of the string defined by its start and end positions

	def ReplaceSection(n1, n2, pcNewSubStr)
		#< @MotherFunction = YES | @QtBased #>

		if CheckingParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok

			if NOT isString(pcNewSubStr)
				StzRaise("Incorrect param type! pcNewSubStr must be a string.")
			ok

			if isString(n1) and ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n1) = 0

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], n2) = 0

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			#--

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok
	
			if n2 = :LastChar  or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

		ok

		# Doing the job

		_nQtStart_ = n1 - 1
		_nQtRange_ = n2 - n1 + 1

		_cResult_ = This.QStringObject().replace( _nQtStart_, _nQtRange_, pcNewSubStr)
		This.UpdateWith( _cResult_ )

		#< @FunctionFluentForm

		def ReplaceSectionQ(n1, n2, pcNewSubStr)
			This.ReplaceSection(n1, n2, pcNewSubStr)
			return This

		#>

	def SectionReplaced(n1, n2, pcNewSubStr)
		cResult = This.Copy().ReplaceSectionQ(n1, n2, pcNewSubStr).Content()
		return cResult
	
	  #--------------------------------------------------------#
	 #    REPLACING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#--------------------------------------------------------#

	def ReplaceManySections(paListOfSections, pcNewSubStr)

		/* EXAMLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.ReplaceManySections([ [1,2], [8, 10], [16, 17], [23, 25] ], "_" )
		
		? o1.Content() #--> "_word1_word2_word3_"
		*/

		if NOT( isList(paListOfSections) and StzListQ(paListOfSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		aListOfSections = StzListOfPairsQ( paListOfSections ).SortedInAscending()

		n = 0
		nNumberOfSections = len(aListOfSections)
		
		for i = len(aListOfSections) to 1 step -1

			aSection = aListOfSections[i]

			n1 = aSection[1]
			n2 = aSection[2]

			This.ReplaceSection(n1, n2, pcNewSubStr)

		next

		def ReplaceManySectionsQ(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)
			return This


		def ReplaceSections(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)

			def ReplaceSectionsQ(paListOfSections, pcNewSubStr)
				This.ReplaceSections(paListOfSections, pcNewSubStr)
				return This

	def ManySectionsReplaced(paListOfSections, pcNewSubStr)
		cResult = This.Copy().ReplaceManySectionsQ(paListOfSections, pcNewSubStr).Content()
		return This

		def SectionsReplaced(paListOfSections, pcNewSubStr)
			return This.ManySectionsReplaced(paListOfSections, pcNewSubStr)

	  #----------------------------------------------#
	 #  REPLACING MANY SECTIONS BY MANY SUBSTRINGS  #
	#----------------------------------------------#

	def ReplaceSectionsByMany(paSections, pacSubStr)
		#WARNING // Assumes that paSections is sorted in ascending!
		# ~> The check is made automatically if CheckingParams() is enabled

		if CheckingParams()

			if NOT ( isList(paSections) and IsListOfPairsofNumbersSortedUp(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers sorted in ascending.")
			ok
	
			if NOT isList(pacSubStr)
					StzRaise("Incorrect param type! pacSubStr must be a list.")
			ok

		ok

		# Justifying the contents of the two params

		nLenSections = len(paSections)
		nLensubStr = len(pacSubStr)
		nMin = Min([ nLenSections, nLenSubStr ])

		aSections = []
		if nLenSections > nMin
			for i = 1 to nMin
				aSections + paSections[i]
			next
		else
			aSections = paSections
		ok

		acSubStr = []
		if nLenSubStr > nMin
			for i = 1 to nMin
				acSubStr + pacSubStr[i]
			next
		else
			acSubStr = pacSubStr
		ok	

		# Doing the job

		_oCopy_ = This.Copy()

		for i = nMin to 1 step - 1
			_oCopy_.ReplaceSection(aSections[i][1], aSections[i][2], acSubStr[i])
		next

		This.UpdateWith(_oCopy_.Content())


		def ReplaceSectionsByManyQ(paSections, pacSubStr)
			This. ReplaceSectionsByMany(paSections, pacSubStr)
			return This

	def SectionsRempalcedByMany(paSections, pacSubStr)
		cResult = This.ReplaceSectionsByManyQ(paSections, pacSubStr).Content()
		return cResult

	  #----------------------------------------------------------#
	 #  REPLACING MANY SECTIONS BY MANY SUBSTRINGS -- eXTended  # #TODO
	#----------------------------------------------------------#

	def ReplaceSectionsByManyXT(paSections, pacSubStr)
		StzRaise("Function not implemented yet!")

		def ReplaceSectionsByManyXTQ(paSections, pacSubStr)
			This. ReplaceSectionsByManyXT(paSections, pacSubStr)
			return This

	def SectionsRempalcedByManyXT(paSections, pacSubStr)
		cResult = This.ReplaceSectionsByManyXTQ(paSections, pacSubStr).Content()
		return cResult

	  #---------------------------------#
	 #    REPLACING A RANGE OF CHARS   # 
	#---------------------------------#

	// Replaces a portion of the string defined by a start position and
	// a range of n chars
	def ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)

		if CheckingParams()

			if NOT @IsNumberOrString(nStart)
				StzRaise("Incorrect param type! nStart must be a number or string.")
			ok

			if NOT isNumber(nNumberOfChars)
				StzRaise("Incorrect param type! nNumberOfChars must be a number.")
			ok

			if isString(nStart) and ring_find([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ], nStart) = 0

				StzRaise("Incorrect value! nStart can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			#--

			if nStart = :FirstChar or nStart = :StartOfString or nStart = :First
				nStart = 1

			but nStart = :LastChar  or nStart = :EndOfString or nStart = :Last
				n1 = This.NumberOfChars()
			ok

		ok

		# Doing the job

		This.ReplaceSection(nStart, nStart + nNumberOfChars - 1, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr)
			This.ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)
			return This

		#>

	def RangeReplaced(nStart, nNumberOfChars, pcNewSubStr)
		cResult = This.ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#------------------------------------------------------#

	def ReplaceManyRanges(paListOfRanges, pcNewSubStr)

		# Tranform ranges to sections and then use ReplaceManySections()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySections(aSections, pcNewSubStr)

		def ReplaceManyRangesQ(paListOfRanges, pcNewSubStr)
			This.ReplaceManySections(paListOfRanges, pcNewSubStr)

		def ReplaceRanges(paListOfRanges, pcNewSubStr)
			This.ReplaceManyRanges(paListOfRanges, pcNewSubStr)

			def ReplaceRangesQ(paListOfRanges, pcNewSubStr)
				This.ReplaceRanges(paListOfRanges, pcNewSubStr)
				return This

	def ManyRangesReplaced(paListOfRanges, pcNewSubStr)
		cResult = This.Copy().ReplaceManyRangesQ(paListOfRanges, pcNewSubStr).Content()
		return This

		def RangedReplaced(paListOfRanges, pcNewSubStr)
			return This.ManyRangesReplaced(paListOfRanges, pcNewSubStr)

	  #--------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#==============================================================#

	def ReplaceSectionsWCS(paSections, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(This[@i]).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindAsSectionsWCS(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceSectionsWQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedW(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhere(paSections, pcCondition)
			return This.ManySectionsReplacedW(paSections, pcCondition)

	  #--------------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#--------------------------------------------------------------------#

	def ReplaceSectionsWCSXT(paSections, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(@section).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindAsSectionsWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSectionsWXTQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhereXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhereXT(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWXT(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhereXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhereXT(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedWXT(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWXTQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhereXT(paSections, pcCondition)
			return This.ManySectionsReplacedWXT(paSections, pcCondition)

	  #------------------------------------------------------------#
	 #    REPLACING RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#============================================================#

	def ReplaceRangesWCS(paRanges, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceRangesW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(This[@i]).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindAsRangesWCS(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceRanges(aRanges, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRangesWQ(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)
			return This

		def ReplaceRangesWhere(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWhereQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesWhere(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesW(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)
	
			def ReplaceManyRangesWQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesW(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWhere(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)

			def ReplaceManyRangesWhereQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWhere(paRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedW(paRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWQ(paRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManyRangesReplacedWhere(paRanges, pcCondition)
			return This.ManyRangesReplacedW(paRanges, pcCondition)

	  #------------------------------------------------------------------#
	 #    REPLACING RANGES OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#------------------------------------------------------------------#

	def ReplaceRangesWCSXT(paRanges, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceRangesW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(@section).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindAsRangesWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceRanges(aRanges, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRangesWXTQ(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)
			return This

		def ReplaceRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWhereXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)
	
			def ReplaceManyRangesWXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWXT(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)

			def ReplaceManyRangesWhereXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedWXT(paRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWXTQ(paRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManyRangesReplacedWhereXT(paRanges, pcCondition)
			return This.ManyRangesReplacedWXT(paRanges, pcCondition)

	  #-----------------------------------------------------------#
	 #   REPLACING THE OCCURRENCES OF A SUBSTRING IN A SECTION   # 
	#===========================================================#

	def ReplaceInSectionCS(pcSubStr, pcNewSubStr, n1, n2, pCaseSensitive)
		cSection = This.SectionQ(n1, n2).ReplaceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		This.ReplaceSection(n1, n2, cSection)

		def ReplaceInSectionCSQ(pcSubStr, n1, n2, pCaseSensitive)
			This.ReplaceInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This

	def SubStringReplacedInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		cResult = This.Copy().ReplaceInSectionCSQ(pcSubStr, n1, n2, pCaseSensitive).Content()
		return cResult

	#--

	def ReplaceInSection(pcSubStr, pcNewSubStr, n1, n2)
		This.ReplaceInSectionCS(pcSubStr, pcNewSubStr, n1, n2, 1)

		def ReplaceInSectionQ(pcSubStr, pcNewSubStr, n1, n2)
			return This.ReplaceInSectionCSQ(pcSubStr, pcNewSubStr, n1, n2, 1)

	def SubStringReplaceInSection(pcSubStr, pcNewSubStr, n1, n2)
		return This.SubStringReplacedInSectionCS(pcSubStr, pcNewSubStr, n1, n2, 1)

	  #--------------------------------------------------------------#
	 #   REPLACING THE OCCURRENCES OF A SUBSTRING IN MANY SECTIONS   # 
	#--------------------------------------------------------------#

	def ReplaceInSectionsCS(pcSubStr, pcNewSubStr, paSections, pCaseSensitive)
		aoSections = This.SectionsQ(paSections).ToListOfStzStrings()
		nLen = len(aoSections)

		acReplaced = []

		for i = 1 to nLen
			aoSections[i].ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			acReplaced + aoSections[i].Content()
		next

		This.ReplaceSectionsByMany(paSections, acReplaced)

		def ReplaceInSectionsCSQ(pcSubStr, pcNewSubStr, paSections, pCaseSensitive)
			This.ReplaceInSectionsCS(pcSubStr, pcNewSubStr, paSections, pCaseSensitive)
			return This

	def SubStringReplacedInSectionsCS(pcSubStr, pcNewSubStr, paSections, pCaseSensitive)
		cResult = This.Copy().ReplaceInSectionsCSQ(pcSubStr, pcNewSubStr, paSections, pCaseSensitive).Content()
		return cResult

	#--

	def ReplaceInSections(pcSubStr, pcNewSubStr, paSections)
		This.ReplaceInSectionsCS(pcSubStr, pcNewSubStr, paSections, 1)

		def ReplaceInSectionsQ(pcSubStr, pcNewSubStr, paSections)
			return This.ReplaceInSectionsCSQ(pcSubStr, pcNewSubStr, paSections, 1)

	def SubStringReplaceInSections(pcSubStr, pcNewSubStr, paSections)
		return This.SubStringReplacedInSectionCS(pcSubStr, pcNewSubStr, paSections, 1)

	  #==========================================#
	 #    SWAPPING TWO SECTIONS OF THE STRING   # 
	#==========================================#

	def SwapSections( panSection1, panSection2 )

		if CheckingParam() = 1
			if isList(panSection2) and StzListQ(panSection2).IsWithOrAndNamedParams()
				panSection2 = panSection2[2]
			ok
	
			if NOT @BothArePairsOfNumbers(panSection1, panSection2)
				StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
			ok
		ok

		cSection1 = This.Section(panSection1[1], panSection1[2])
		cSection2 = This.Section(panSection2[1], panSection2[2])

		_oCopy_ = This.Copy()
		_oCopy_.ReplaceSection(panSection1[1], panSection1[2], cSection2)
		_oCopy_.ReplaceSection(panSection2[1], panSection2[2], cSection1)

		This.UpdateWith(_oCopy_.Content())


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2).Content()
		return cResult

	  #-----------------------------------#
	 #  SWAPPING MANY PAIRS OF SECTIONS  #
	#-----------------------------------#

	def SwapManyPairsOfSections(paPairsOfSections)
		if CheckingParam() = 1
			if NOT ( isList(paPairsOfSections) and StzListQ(paPairsOfSections).IsListOfPairsOfSections() )
				StzRaise("Incorrect param type! paPairsOfSections must be a list of pairs of sections, each section being a pair of numbers.")
			ok
		ok

		nLen = len(paPairsOfSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			_oCopy_.SwapSections(paPairsOfSections[i][1], paPairsOfSections[i][2])
		next

		This.UpdateWith(_oCopy_.Content())


		def SwapManyPairsOfSectionsQ(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)
			return This

		def SwapPairsOfSections(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)

			def SwapPairsOfSectionsQ(paPairsOfSections)
				This.SwapPairsOfSections(paPairsOfSections)
				return This

	def ManyPairsOfSectionsSwapped(paPairsOfSections)
		cResult = This.Copy().SwapManyPairsOfSectionsQ(paPairsOfSections).Content()
		return cResult

	  #========================================#
	 #    REMOVING NUMBERS FROM THE STRING    # 
	#========================================#

	def RemoveNumbers()
		cResult = ""
	
		anPos = This.FindNumbers()
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

		#>

	def NumbersRemoved()
		cResult = This.Copy().RemoveNumbersQ().Content()
		return cResult

	  #====================================================#
	 #     REMOVING THE NTH OCCURRENCE OF A SUBSTRING     #
	#====================================================#

	def RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if isList(n)
			This.RemoveOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return
		ok

		This.ReplaceNthOccurrenceCS(n, pcSubStr, "", pCaseSensitive)

		#< @FunctionFluentForm
	
		def RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def RemoveNthCS(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

			def RemoveNthCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNthCS(n, pcSubStr, pCaseSensitive)
				return This

		#>

	def NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def NthRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def SubStringNthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pcSubStr)
		This.RemoveNthOccurrenceCS(n, pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveNth(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)

			def RemoveNthQ(n, pcSubStr)
				This.RemoveNth(n, pcSubStr)
				return This

		#>

	def NthOccurrenceOfSubStringRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveNthOccurrenceQ(n, pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def NthRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def SubStringNthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		#>

	  #------------------------------------------------#
	 #    REMOVING FIRST OCCURRENCE OF A SUBSTRING    #
	#------------------------------------------------#

	def RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveFirstCS(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveFirstCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def FirstRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pcSubStr)
		This.RemoveFirstOccurrenceCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pcSubStr)
			This.RemoveFirstOccurrence(pcSubStr)
			return This
	
		#>

		#< @functionAlternativeForm

		def RemoveFirst(pcSubStr)
			This.RemoveFirstOccurrence(pcSubStr)

			def RemoveFirstQ(pcSubStr)
				This.RemoveFirst(pcSubStr)
				return This

		#>

	def FirstOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveFirstOccurrenceQ(pcSubStr).Content()

		def FirstRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringFirstOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	  #--------------------------------------------------#
	 #     REMOVING LAST OCCURRENCE OF A SUBSTRING      #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveLastCS(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveLastCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def LastRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringLastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pcSubStr)
		This.RemoveLastOccurrenceCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)
			return This
	
		#>

		#< @FunctionLastOccurrence

		def RemoveLast(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)

			def RemoveLastQ(pcSubStr)
				This.RemoveLast(pcSubStr)
				return This

		#>

	def LastOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveLastOccurrenceQ(pcSubStr).Content()

		def LastRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringLastOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	   #---------------------------------------------------#
	  #    REMOVING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                   #
	#---------------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if CheckingParams()
			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
		ok

		cPart1 = This.Section(1, nStart - 1)

		nLen = This.NumberOfChars()
		oPart2 = This.SectionQ(nStart, nLen)
		cPart2 = oPart2.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def RemoveNextNthOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNextNthOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		def RemoveNthNextOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def NextNthOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		def NthNextOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, 1)

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

		#--

		def RemoveNextNthOccurrenceST(n, pcSubStr, nStart)
			return This.RemoveNextNthOccurrence(n, pcSubStr, nStart)

			def RemoveNextNthOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemoveNextNthOccurrenceQ(n, pcSubStr, nStart)

		def RemoveNthNextOccurrenceST(n, pcSubStr, nStart)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart)

			def RemoveNthNextOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def NextNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceRemoved(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def NextNthOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart)

		def NthNextOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart)

		#>

	   #------------------------------------------------#
	  #    REMOVING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNextOccurrenceSTCS(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)

			def RemoveNextOccurrenceSTCSQ(pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NextOccurrenceRemovedSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, 1)

		#< @FunctionFluentForm

		def RemoveNextOccurrenceQ(pcSubStr, nStart)
			This.RemoveNextOccurrence(pcSubStr, nStart)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNextOccurrenceST(pcSubStr, nStart)
			This.RemoveNextOccurrence(pcSubStr, nStart)

			def RemoveNextOccurrenceSTQ(pcSubStr, nStart)
				return This.RemoveNextOccurrenceQ(pcSubStr, nStart)

		#>

	#-- @FunctionAlternativeForm

	def NextOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemoveNextOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

		def NextOccurrenceRemovedST(pcSubStr, nStart)
			return This.NextOccurrenceRemoved(pcSubStr, nStart)

	   #-------------------------------------------------------#
	  #    REMOVING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                       #
	#-------------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

		if CheckingParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok

		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		nLen = This.NumberOfChars()
		cPart2 = This.Section(nStart, nLen)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def RemovePreviousNthOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemovePreviousNthOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		def RemoveNthPreviousOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def PreviousNthOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		def NthPreviousOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, 1)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

		#--

		def RemovePreviousNthOccurrenceST(n, pcSubStr, nStart)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart)

			def RemovePreviousNthOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart)

		def RemoveNthPreviousOccurrenceST(n, pcSubStr, nStart)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart)

			def RemoveNthPreviousOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrenceRemoved(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		#--

		def PreviousNthOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		def NthPreviousOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		#>

	   #----------------------------------------------------#
	  #    REMOVING PREVIOUS OCCURRENCE OF A SUBSTRING     # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		#< @FunctionFluentForm

		def RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrenceSTCS(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)

			def RemovePreviousOccurrenceSTCSQ(pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def PreviousOccurrenceRemovedSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, 1)

		#< @FunctionFluentForm

		def RemovePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrenceST(pcSubStr, nStart)
			This.RemovePreviousOccurrence(pcSubStr, nStart)

			def RemovePreviousOccurrenceSTQ(pcSubStr, nStart)
				return This.RemovePreviousOccurrenceQ(pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def PreviousOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

		def PreviousOccurrenceRemovedST(pcSubStr, nStart)
			return This.PreviousOccurrenceRemoved(pcSubStr, nStart)

	  #-----------------------------------------------#
	 #    REMOVING LEFT OCCURRENCE OF A SUBSTRING    # 
	#-----------------------------------------------#

	def RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsRightToLeft()
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def LeftOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLeftOccurrence(pcSubStr)
		This.RemoveLeftOccurrenceCS(pcSubStr, 0)

		def RemoveLeftOccurrenceQ(pcSubStr)
			This.RemoveLeftOccurrence(pcSubStr)
			return This

	def LeftOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveLeftOccurrenceQ(pcSubStr).Content()
		return cResult

	  #---------------------------------------------#
	 #    REMOVING RIGHT OCCURRENCE OF SUBSTRING   # 
	#---------------------------------------------#

	def RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsRightToLeft()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsLeftToRight()

			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def RightOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveRightOccurrence(pcSubStr)
		This.RemoveRightOccurrenceCS(pcSubStr, 1)

		def RemoveRightOccurrenceQ(pcSubStr)
			This.RemoveRightOccurrence(pcSubStr)
			return This

	def RightOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveRightOccurrenceQ(pcSubStr).Content()
		return cResult

	  #===========================================================================#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE START OF THE STRING   #
	#===========================================================================#

	def NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)
		if This.IsLeftToRight()
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		else # IsRightToLeft()
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== TO THE START instead of ON THE START

		def CharOccurrenceToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== AT THE START instead of ON THE START

		def CharOccurrenceAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== STARTSIDE instead of ON THE START

		def CharOccurrenceStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheStart(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== TO THE START instead of ON THE START

		def CharOccurrenceToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== AT THE START instead of ON THE START

		def CharOccurrenceAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== STARTSIDE instead of ON THE START

		def CharOccurrenceStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrencesOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrenceOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrencesOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE END OF THE STRING    #
	#==========================================================================#

	def NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)
		if This.IsLeftToRight()
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		else # IsRightToLeft()
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== TO THE END instead of ON THE END

		def CharOccurrenceToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== AT THE END instead of ON THE END

		def CharOccurrenceAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== ENDSIDE instead of ON THE END

		def CharOccurrenceEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheEnd(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== TO THE END instead of ON THE END

		def CharOccurrenceToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== AT THE END instead of ON THE END

		def CharOccurrenceAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== ENDSIDE instead of ON THE END

		def CharOccurrenceEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrencesOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrenceOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrencesOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#>

	  #---------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE LEFT OF THE STRING    #
	#===========================================================================#

	def NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		if CheckingParams()
			if NOT ( isString(pcChar) and @IsChar(pcChar) )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		
		n = This.FindLastCS(pcChar, pCaseSensitive)

		if n = 0 or n = 1
			return n
		ok

		nResult = 0
		nTemp = n
		while 1
			nTemp--
			if nTemp = 0
				nResult = n
				exit
			ok

			if NOT This.CharQ(nTemp).IsEqualToCS(pcChar, pCaseSensitive)
				nResult = 0
				exit
			ok
		end
		
		return nResult

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheLeft(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrencesOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrenceOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrencesOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#>

	  #---------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE RIGHT OF THE STRING   #
	#---------------------------------------------------------------------------#

	def NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		if CheckingParams()
			if NOT ( isString(pcChar) and @IsChar(pcChar) )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		nLen = This.NumberOfChars()
		n = This.FindFirstCS(pcChar, pCaseSensitive)

		if n = 0
			return 0

		but n = nLen
			return 1
		ok

		nResult = 1
		for i = n + 1 to nLen
			if This.CharQ(i).IsEqualToCS(pcChar, pCaseSensitive)
				nResult++
			else
				nResult = 0
				exit
			ok
		next

		return nResult

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheRight(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, 1)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrencesOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrenceOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrencesOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM START   #
	#================================#

	#TODO // Add "Strip" as alternative of "Trim" all over the library

	def RemoveThisCharFromStartCS(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
		else
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromStartCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def RemoveCharFromStartCSQ(c, pCaseSensitive)
				This.RemoveCharFromStartCS(c, pCaseSensitive)
				return This

		def TrimCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def TrimCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		def TrimThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def TrimThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		#--

		def StripCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def StripCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		def StripThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def StripThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromStartCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromStartCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		def ThisCharTrimmedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)


		def CharStrippedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		def ThisCharStrippedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromStart(c)
		This.RemoveAnyCharFromStartCS(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def RemoveCharFromStartQ(c)
				This.RemoveCharFromStartCS(c)
				return This

		def TrimCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def TrimCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def TrimThisCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def TrimThisCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		#--

		def StripCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def StripCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def StripThisCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def StripThisCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		#>

	def CharRemovedFromStart(c)
		return This.CharRemovedFromStartCS(c, 1)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStart(c)
			return This.CharRemovedFromStart(c)

		def CharTrimmedFromStart(c)
			return This.CharRemovedFromStart(c)

		def ThisCharTrimmedFromStart(c)
			return This.CharRemovedFromStart(c)

		#--

		def CharStrippedFromStart(c)
			return This.CharRemovedFromStart(c)

		def ThisCharStrippedFromStart(c)
			return This.CharRemovedFromStart(c)

		#>

	  #-------------------------------#
	 #   REMOVING A CHAR FROM END    #
	#===============================#

	def RemoveThisCharFromEndCS(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
		else
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromEndCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def RemoveCharFromEndCSQ(c, pCaseSensitive)
				This.RemoveCharFromEndCS(c, pCaseSensitive)
				return This

		def TrimCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def TrimCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def TrimThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def TrimThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def StripCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def StripCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def StripThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def StripThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromEndCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromEndCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def ThisCharTrimmedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def CharStrippedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def ThisCharStrippedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromEnd(c)
		This.RemoveThisCharFromEndCS(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def RemoveCharFromEndQ(c)
				This.RemoveCharFromEnd(c)
				return This

		def TrimCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def TrimCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def TrimThisCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def TrimThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def StripCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def StripCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def StripThisCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def StripThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#>

	def CharRemovedFromEnd(c)
		return This.CharRemovedFromEndCS(c, 1)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def CharTrimmedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def ThisCharTrimmedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def CharStrippedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def ThisCharStrippedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM LEFT    #
	#================================#

	def RemoveThisCharFromLeftCS(c, pCaseSensitive)
		if CheckingParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		if This.LeftCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLeftChar()
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromLeftCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def RemoveCharFromLeftCSQ(c, pCaseSensitive)
				This.RemoveCharFromLeftCS(c, pCaseSensitive)
				return This

		def TrimCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def TrimCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def TrimThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def TrimThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def StripCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def StripCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def StripThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def StripThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromLeftCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromLeftCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def ThisCharTrimmedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def CharStrippedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def ThisCharStrippedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromLeft(c)
		This.RemoveThisCharFromLeftCS(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def RemoveCharFromLeftQ(c)
				This.RemoveCharFromLeft(c)
				return This

		def TrimCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def TrimCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def TrimThisCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def TrimThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def StripCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def StripCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def StripThisCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def StripThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		#>

	def CharRemovedFromLeft(c)
		return This.CharRemovedFromLeftCS(c, 1)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		#--

		def CharTrimmedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def ThisCharTrimmedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def CharStrippedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def ThisCharStrippedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		#>

	  #---------------------------------#
	 #   REMOVING A CHAR FROM RIGHT    #
	#---------------------------------#

	def RemoveThisCharFromRightCS(c, pCaseSensitive)
		if CheckingParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		if This.RightCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRightChar()
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromRightCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def RemoveCharFromRightCSQ(c, pCaseSensitive)
				This.RemoveCharFromRightCS(c, pCaseSensitive)
				return This

		def TrimCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def TrimCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def TrimThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def TrimThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def StrimCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def StripCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def StripThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def StripThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromRightCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromRightCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def ThisCharTrimmedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def CharStrippedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def ThisCharStrippedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromRight(c)
		This.RemoveAnyCharFromRightCS(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def RemoveCharFromRightQ(c)
				This.RemoveCharFromRight(c)
				return This

		def TrimCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def TrimCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def TrimThisCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def TrimThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def StripCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def StrimCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def StrimThisCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def StripThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		#>

	def CharRemovedFromRight(c)
		return This.CharRemovedFromRightCS(c, 1)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromRight(c)
			return This.CharRemovedFromRight(c)

		#--

		def CharTrimmedFromRight(c)
			return This.CharRemovedFromRight(c)

		def ThisCharTrimmedFromRight(c)
			return This.CharRemovedFromRight(c)

		def CharStrippedFromRight(c)
			return This.CharRemovedFromRight(c)

		def ThisCharStrippedFromRight(c)
			return This.CharRemovedFromRight(c)

		#>

	  #-----------------------------------------------------------------#
	 #   REMOVING ALL THE OCCURRENCES OF A CHAR FROM THE START -- XT   #
	#=================================================================#
	#TODO // Add Strip alternative

	def RemoveThisCharFromStartCSXT(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		else
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharstartSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharStartSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharStartSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharStartSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveCharFromStartCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromStartCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def TrimCharFromStartCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def TrimThisCharFromStartCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromStartCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromStartCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromStartRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromStartRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedStartSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedStartSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromStartXT(c)
		This.RemoveThisCharFromStartCSXT(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromStart(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def RemoveAnyOccurrenceOfThisCharFromStart(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfThisCharFromStartQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveAnyOccurrenceOfCharstartSide(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfCharStartSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharStartSide(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfThisCharStartSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveCharFromStartXTQ(c)
				This.RemoveCharFromStartCSXT(c)
				return This

		def TrimCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def TrimCharFromStartXTQ(c)
				return This.RemoveThisCharFromStartXTQ(c)

		def TrimThisCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def TrimThisCharFromStartXTQ(c)
				return This.RemoveThisCharFromStartXTQ(c)

		#>

	def CharRemovedFromStartXT(c)
		return This.CharRemovedFromStartCSXT(c, 1)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfCharRemovedFromStart(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharRemovedFromStart(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfCharFromStartRemoved(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharFromStartRemoved(c)
			return This.CharRemovedFromStartXT(c)

		#--

		def AnyOccurrenceOfCharRemovedStartSide(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharRemovedStartSide(c)
			return This.CharRemovedFromStartXT(c)

		#--

		def CharTrimmedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		def ThisCharTrimmedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		#>

	  #-------------------------------#
	 #   REMOVING A CHAR FROM END    #
	#-------------------------------#
	#TODO // Add Strip alternative

	def RemoveThisCharFromEndCSXT(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		else
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharEndSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharEndSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharEndSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharEndSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveCharFromEndCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromEndCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def TrimCharFromEndCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def TrimThisCharFromEndCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromEndCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromEndCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromEndRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromEndRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedEndSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedEndSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromEndXT(c)
		This.RemoveThisCharFromEndCSXT(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromEnd(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharFromEnd(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveAnyOccurrenceOfCharEndSide(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfCharEndSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharEndSide(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfThisCharEndSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveCharFromEndXTQ(c)
				This.RemoveCharFromEndCSXT(c)
				return This

		def TrimCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def TrimCharFromEndXTQ(c)
				return This.RemoveThisCharFromEndXTQ(c)

		def TrimThisCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def TrimThisCharFromEndXTQ(c)
				return This.RemoveThisCharFromEndXTQ(c)

		#>

	def CharRemovedFromEndXT(c)
		return This.CharRemovedFromEndCSXT(c, 1)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfCharRemovedFromEnd(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharRemovedFromEnd(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfCharFromEndRemoved(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharFromEndRemoved(c)
			return This.CharRemovedFromEndXT(c)

		#--

		def AnyOccurrenceOfCharRemovedEndSide(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharRemovedEndSide(c)
			return This.CharRemovedFromEndXT(c)

		#--

		def CharTrimmedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		def ThisCharTrimmedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM LEFT    #
	#================================#
	#TODO // Add Strip alternative

	def RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		if CheckingParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		acChars = This.Chars()
		nLen = len(acChars)
		if nLen = 0
			return
		ok

		if IsCaseSensitive(pCaseSensitive) = 0
			c = ring_lower(c)
			for i = 1 to nLen
				acChars[i] = ring_lower(acChars[i])
			next
		ok

		n = 0

		if This.IsLeftToRight()
			for i = 1 to nLen
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( 1, n )
			ok

		else
			for i = nLen to 1 step -1
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( nLen - n + 1, nLen )
			ok

		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharLeftSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharLeftSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharLeftSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharLeftSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveCharFromLeftCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromLeftCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def TrimCharFromLeftCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def TrimThisCharFromLeftCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromLeftCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromLeftCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromLeftRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromLeftRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedLeftSideCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedLeftSideCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromLeftXT(c)
		This.RemoveThisCharFromLeftCSXT(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromLeft(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		def RemoveAnyOccurrenceOfThisCharFromLeft(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#--

		def RemoveAnyOccurrenceOfCharLeftSide(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfCharLeftSideQ(c)
				return This.RemoveAnyCharFromLeftXTQ(c)

		def RemoveAnyOccurrenceOfThisCharLeftSide(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfThisCharLeftSideQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#--

		def RemoveCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveCharFromLeftXTQ(c)
				This.RemoveCharFromLeftXT(c)
				return This

		def TrimCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def TrimCharFromLeftXTQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		def TrimThisCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def TrimThisCharFromLeftXTQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#>

	def CharRemovedFromLeftXT(c)
		return This.CharRemovedFromLeftCSXT(c, 1)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfCharRemovedFromLeft(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharRemovedFromLeft(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfCharFromLeftRemoved(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharFromLeftRemoved(c)
			return This.CharRemovedFromLeftXT(c)

		#--

		def AnyOccurrenceOfCharRemovedLeftSide(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharRemovedLeftSide(c)
			return This.CharRemovedFromLeftXT(c)


		#--

		def CharTrimmedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		def ThisCharTrimmedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		#>


	  #-------------------------------------#
	 #   REMOVING A CHAR FROM RIGHT -- XT  #
	#-------------------------------------#
	#TODO // Add Strip alternative

	def RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		if CheckingParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		acChars = This.Chars()
		nLen = len(acChars)
		if nLen = 0
			return
		ok

		if IsCaseSensitive(pCaseSensitive) = 0
			c = ring_lower(c)
			for i = 1 to nLen
				acChars[i] = ring_lower(acChars[i])
			next
		ok

		n = 0

		if This.IsLeftToRight()
			for i = nLen to 1 step -1
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( nLen - n + 1, nLen )
			ok

		else
			for i = 1 to nLen
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( 1, n )
			ok

		ok


		#< @FunctionFluentFrom

		def RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharRightSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharRightSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharRightSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharRightSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveCharFromRightCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromRightCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def TrimCharFromRightCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def TrimThisCharFromRightCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromRightCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromRightCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromRightRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromRightRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedRightSideCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedRightSideCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromRightXT(c)
		This.RemoveThisCharFromRightCSXT(c, 1)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromRight(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfCharFromRightQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		def RemoveAnyOccurrenceOfThisCharFromRight(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#--

		def RemoveAnyOccurrenceOfCharRightSide(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfCharRightSideQ(c)
				return This.RemoveAnyCharFromRightXTQ(c)

		def RemoveAnyOccurrenceOfThisCharRightSide(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfThisCharRightSideQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#--

		def RemoveCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveCharFromRightXTQ(c)
				This.RemoveCharFromRightXT(c)
				return This

		def TrimCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def TrimCharFromRightXTQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		def TrimThisCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def TrimThisCharFromRightXTQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#>

	def CharRemovedFromRightXT(c)
		return This.CharRemovedFromRightCSXT(c, 1)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfCharRemovedFromRight(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharRemovedFromRight(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfCharFromRightRemoved(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharFromRightRemoved(c)
			return This.CharRemovedFromRightXT(c)

		#--

		def AnyOccurrenceOfCharRemovedRightSide(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharRemovedRightSide(c)
			return This.CharRemovedFromRightXT(c)


		#--

		def CharTrimmedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		def ThisCharTrimmedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		#>

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM LEFT    #
	#=====================================#

	def RemoveFromLeftCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NLeftCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsLeftToRight()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr
			ok

			This.RemoveSection(n1, n2)
		ok

		#< @FunctionFluentForm

		def RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromLeftCS(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromLeftCSQ(pcSubStr, pCaseSensitive)
				return This.RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)

		#>

	def RemovedFromLeftCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromLeftCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringRemovedFromLeftCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromLeftCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromLeft(pcSubStr)
		This.RemoveFromLeftCS(pcSubStr, 1)

		def RemoveFromLeftQ(pcSubStr)
			This.RemoveFromLeft(pcSubStr)
			return This

		def RemoveSubStringFromLeft(pcSubStr)
			This.RemoveFromLeft(pcSubStr)

			def RemoveSubStringFromLeftQ(pcSubStr)
				This.RemoveSubStringFromLeft(pcSubStr)
				return This

	def RemovedFromLeft(pcSubStr)
		cResult = This.Copy().RemoveFromLeftQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromLeft(pcSubStr)
			return This.RemovedFromLeft(pcSubStr)

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM RIGHT   #
	#-------------------------------------#

	def RemoveFromRightCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NRightCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsRightToLeft()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr

			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromRightCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
			return This

		def RemoveRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringFromRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromRightCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromRightCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromRightCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromRightCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromRightCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromRight(pcSubStr)
		This.RemoveFromRightCS(pcSubStr, 1)

		def RemoveFromRightQ(pcSubStr)
			This.RemoveFromRight(pcSubStr)
			return This

		def RemoveRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveRightQ(pcSubStr)
				This.RemoveRight(pcSubStr)
				return This

		def RemoveSubStringFromRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveSubStringFromRightQ(pcSubStr)
				This.RemoveSubStringFromRight(pcSubStr)
				return This

	def RemovedFromRight(pcSubStr)
		cResult = This.Copy().RemoveFromRightQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromRight(pcSubStr)
			return This.RemovedFromRight(pcSubStr)	

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM START   #
	#-------------------------------------#

	def RemoveFromStartCS(pcSubStr, pCaseSensitive)

		if This.IsLeftToRight()
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromStartCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromStartCS(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromStartCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromStartCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveStartCS(pcSubStr, pCaseSensittive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveStartCSQ(pcSubStr, pCaseSensittive)
				This.RemoveStartCS(pcSubStr, pCaseSensittive)
				return This

		#>

	def RemovedFromStartCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromStartCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromStartCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

		def StartRemovedCS(pcSubStr, pCaseSensittive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromStart(pcSubStr)
		This.RemoveFromStartCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveFromStartQ(pcSubStr)
			This.RemoveFromStart(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveSubStringFromStartQ(pcSubStr)
				This.RemoveSubStringFromStart(pcSubStr)
				return This

		def RemoveStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveStartQ(pcSubStr)
				This.RemoveStart(pcSubStr)
				return This

		#>

	def RemovedFromStart(pcSubStr)
		cResult = This.Copy().RemoveFromStartQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromStart(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

		def StartRemoved(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

	  #-----------------------------------#
	 #   REMOVING A SUBSTRING FROM END   #
	#-----------------------------------#

	def RemoveFromEndCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromEndCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromEndCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEndCS(pcSubStr, pCaseSensitive)
				return This
		#>

	def RemovedFromEndCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromEndCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromEndCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

		def EndRemovedCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromEnd(pcSubStr)
		This.RemoveFromEndCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def RemoveFromEndQ(pcSubStr)
			This.RemoveFromEnd(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveSubStringFromEndQ(pcSubStr)
				This.RemoveSubStringFromEnd(pcSubStr)
				return This

		def RemoveEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveEndQ(pcSubStr)
				This.RemoveEnd(pcSubStr)
				return This

		#>

	def RemovedFromEnd(pcSubStr)
		cResult = This.Copy().RemoveFromEndQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromEnd(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

		def EndRemoved(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)


	  #=================================#
	 #   TRIMMING & REMOVING SPACES    # 
	#=================================#
	#TODO // Add Trim functions to stzList

	def Trim()
		This.Update( This.QStringObject().trimmed() )

		def TrimQ()
			This.Trim()
			return This

	def Trimmed()
		cResult = This.Copy().TrimQ().Content()
		return cResult

		def WithoutLeadingAndTrailingSpaces()
			return This.Trimmed()

	def TrimStart()
		if This.HasRepeatedLeadingChars()	
			This.RemoveThisRepeatedLeadingChar(" ")
		ok

		if This.FirstChar() = " "
			This.RemoveFirst(" ")
		ok

		def TrimStartQ()
			This.TrimStart()
			return This

		def RemoveLeadingSpaces()
			This.TrimStart()

			def RemoveLeadingSpacesQ()
				This.RemoveLeadingSpaces()
				return This

	def TrimmedFromStart()
		cResult = This.Copy().TrimStartQ().Content()
		return cResult

		def LeadingSpacesRemoved()
			return This.TrimmedFromStart()

		def WithoutLeadingSpaces()
			return This.TrimmedFromStart()

		def TrimmedStart()
			return This.TrimmedFromStart()

	def TrimEnd()

		This.RemoveThisRepeatedTrailingChar(" ")

		if This.LastChar() = " "
			This.RemoveLast(" ")
		ok

		def TrimEndQ()
			This.TrimEnd()
			return This

		def RemoveTrailingSpaces()
			This.TrimEnd()

			def RemoveTrailingSpacesQ()
				This.RemoveTrailingSpaces()
				return This
	
	def TrimmedFromEnd()
		cResult = This.Copy().TrimEndQ().Content()
		return cResult

		def TrailingSpacesRemoved()
			return This.TrimmedFromEnd()

		def WithoutTrailingSpaces()
			return This.TrimmedFromEnd()

		def TrimmedEnd()
			return This.TrimmedFromEnd()

	def TrimLeft()
		if This.IsLeftToRight()
			This.TrimStart()

		else # IsRightToLeft
			This.TrimEnd()
		ok

		def TrimLeftQ()
			This.TrimLeft()
			return This

		def RemoveLeftSpaces()
			This.TrimeLeft()

			def RemoveLeftSpacesQ()
				This.RemoveLeftSpaces()
				return This

	def TrimmedFromLeft()
		cResult = This.Copy().TrimLeftQ().Content()
		return cResult

		def LeftSpacesRemoved()
			return This.TrimmedFromLeft()

		def WithoutLeftSpaces()
			return This.TrimmedFromLeft()

		def TrimmedLeft()
			return This.TrimmedFromLeft()

	def TrimRight()
		if This.IsRightToLeft()
			This.TrimStart()

		else # IsLeftToRight
			This.TrimEnd()
		ok

		def TrimRightQ()
			This.TrimRight()
			return This

		def RemoveRightSpaces()
			This.TrimRight()

			def RemoveRightSpacesQ()
				This.RemoveRightSpaces()
				return This

	def TrimmedFromRight()
		cResult = This.Copy().TrimRightQ().Content()
		return cResult

		def RightSpacesRemoved()
			return This.TrimmedFromRight()

		def WithoutRightSpaces()
			return This.TrimmedFromRight()

		def TrimmedRight()
			return This.TrimmedFromRight()

	#--

	def TrimCharCS(c, pCaseSensitive) #TODO : Add TrimSubString()
		/* Example

		o1 = new stzString("♥♥♥123♥♥♥")
		o1.TrimChar("♥")
		? o1.Content()
		#--> "♥♥♥123♥♥♥"

		*/

		This.RemoveThisCharFromStartCS(c, pCaseSensitive)
		This.RemoveThisCharFromEndCS(c, pCaseSensitive)

		def TrimCharCSQ(c, pCaseSensitive)
			This.TrimCharCS(c, pCaseSensitive)
			return This

	def CharTrimmedCS(c, pCaseSensitive)
		cResult = This.Copy().TrimCharCSQ(c, pCaseSensitive).Content()
		return cResult

	def TrimChar(c)
		This.TrimCharCS(c, 1)

		def TrimCharQ(c)
			return This.TrimCharCSQ(c, 1)

	def CharTrimmed(c)
		return This.CharTrimmedCS(c, 1)

	#--

	def RemoveSpaces()
		This.RemoveAll(" ")

		def RemoveSpacesQ()
			This.RemoveSpaces()
			return This

		def RemoveAllSpaces()
			This.RemoveSpaces()

			def RemoveAllspacesQ()
				This.RemoveSpaces()
				return This

	def SpacesRemoved()
		cResult = This.Copy().RemoveSpacesQ().Content()
		return cResult

		def WithoutSpaces()
			return This.SpacesRemoved()

		def WithoutSpacesQ()
			return new stzString(This.WithoutSpaces())

		#< @FunctionMisspelledForm

		def WithoutSapces()
			return This.WithoutSpaces()

		#>


	  #==========================================#
	 #  EXTRACTING A SUBSTRING FROM THE STRING  #
	#==========================================#

	def ExtractCS(pcSubStr, pCaseSensitive)
		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			StzRaise("Can't extract the substring It does not exist in the string.")
		ok

		This.RemoveCS(pcSubStr, pCaseSensitive)
		return pcSubStr

		def PopCS(pcSubStr, pCaseSensitive)
			return This.ExtractCS(pcSubStr, pCaseSensitive)

	def SubStringExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractCS(pcSubStr, pCaseSensitive)

		def SubStringPoppedCS(pcSubStr, pCaseSensitive)
			return This.SubStringExtractedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Extract(pcSubStr)
		return This.ExtractCS(pcSubStr, 1)

		def Pop(pcSubStr)
			return This.Extract(pcSubStr)

	def SubStringExtracted(pcSubStr)
		return This.Extract(pcSubStr)

		def SubStringPopped(pcSubStr)
			return This.SubStringExtracted(pcSubStr)

	  #----------------------------------------------#
	 #  EXTRACTING MANY SUBSTRINGS FROM THE STRING  #
	#----------------------------------------------#

	def ExtractManyCS(paSubStr, pCaseSensitive)
		if NOT This.ContainsManyCS(paSubStr, pCaseSensitive)
			StzRaise("Can't extract the substrings! SubStrings in paSubStr do not exist in the string.")
		ok

		This.RemoveManyCS(paSubStr, pCaseSensitive)
		return paSubStr

		#< @FunctionAlternativeForms

		def PopManyCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#--

		def ExtractTheseCS(aSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		def PopTheseCS(aSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#>

	def ManySubStringsExtractedCS(paSubStr, pCaseSensitive)
		return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ManySubStringsPoppedCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		def TheseSubStringsExtractedCS(paSubStr, pCaseSensitive)
			return This.ManySubStringsExtractedCS(paSubStr, pCaseSensitive)

		def TheseSubStringsPoppedCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(paSubStr)
		return This.ExtractManyCS(paSubStr, 1)

		#< @FunctionAlternativeForms

		def PopMany(paSubStr)
			return This.ExtractMany(paSubStr)

		#--

		def ExtractThese(aSubStr)
			return This.ExtractMany(paSubStr)

		def PopThese(aSubStr)
			return This.ExtractMany(paSubStr)

		#>

	def ManySubStringsExtracted(paSubStr)
		return This.ExtractMany(paSubStr)

		#< @FunctionAlternativeForms

		def ManySubStringsPopped(paSubStr)
			return This.ExtractMany(paSubStr)

		def TheseSubStringsExtracted(paSubStr)
			return This.ManySubStringsExtracted(paSubStr)

		def TheseSubStringsPopped(paSubStr)
			return This.ExtractMany(paSubStr)

		#>

	  #-------------------------------------------------#
	 #  EXTRACTING ALL THE SUBSTRINGS FROM THE STRING  #
	#-------------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

		def PopAll()
			return This.ExtractAll()

	def AllStringExtracted()
		return This.ExtractAll()

		def AllStringPopped()
			return This.ExtractAll()

	  #---------------------------#
	 #  EXTRACTING THE NTH CHAR  #
	#---------------------------#

	def ExtractAt(n)
		if isString(n) and ( n = :Last or n = :LastSubString )
			n = This.NumberOfSubStrings()
		ok

		TempcSubStr = This.NthChar(n)

		This.RemoveAt(n)

		return TempcSubStr

		#< @FunctionAlternativeForms

		def ExtractNthChar(n)
			return This.ExtractAt(n)

		def ExtractCharAtPosition(n)
			return This.ExtractAt(n)

		def ExtractCharAt(n)
			return This.ExtractAt(n)

		#--

		def PopAt(n)
			return This.ExtractAt(n)

		def PopNthChar(n)
			return This.ExtractAt(n)

		def PopCharAtPosition(n)
			return This.ExtractAt(n)

		def PopCharAt(n)
			return This.ExtractAt(n)

		#>

	def NthCharExtracted(n)
		return This.ExtractAt(n)

		def NthCharPopped(n)
			return This.ExtractAt(n)

		def ExtractedAt(n)
			return This.ExtractAt(n)

		def PoppedAt(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST CHAR  #
	#-----------------------------#

	def ExtractFirstChar()
		return This.ExtractAt(1)
 
		def PopFirstChar()
			return This.ExtractFirstChar()

	def FirstCharExtracted()
		return This.ExtractCharSubString()

		def FirstCharPopped()
			return This.ExtractFirstChar()

	  #----------------------------#
	 #  EXTRACTING THE LAST CHAR  #
	#----------------------------#

	def ExtractLastChar()
		return This.ExtractAt(This.NumberOfChars())

		def PopLastChar()
			return This.ExtractLastChar()

	def LastCharExtracted()
		return This.ExtractLastChar()

		def LastCharPopped()
			return This.ExtractLastChar()

	  #------------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF A SUBSTRING  #
	#------------------------------------------------#

	def ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive) > 0
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			StzRaise("Can't extract! The list does not contain n occurrences of pcSubStr.")
		ok

		#< @FunctionAlternativeFroms

		def ExtractNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		#>

	def NthOccurrenceExtractedCS(n, pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def NthOccurrencePoppedCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pcSubStr)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, 1)

		#< @FunctionAlternativeFroms

		def ExtractNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNthOccurrence(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		#>

	def NthOccurrenceExtracted(n, pcSubStr)
		return This.ExtractNthOccurrence(n, pcSubStr)

		def NthOccurrencePopped(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

	  #--------------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF A SUBSTRING  #
	#--------------------------------------------------#

	def ExtractFirstCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopFirstCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def ExtractFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def PopFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		#>

	def FirstOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pcSubStr)
		return This.ExtractFirstCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def PopFirst(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def ExtractFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def PopFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		#>

	def FirstOccurrenceExtracted(pcSubStr)
		return This.ExtractFirst(pcSubStr)

		def FirstOccurrencePopped(pcSubStr)
			return This.ExtractFirst(pcSubStr)

	  #-------------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF A SUBSTRING  #
	#-------------------------------------------------#

	def ExtractLastCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(This.NumberOfChars(), pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopLastCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def ExtractLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def PopLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		#>

	def LastOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pcSubStr)
		return This.ExtractLastCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def PopLast(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def ExtractLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def PopLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		#>

	def LastOccurrenceExtracted(pcSubStr)
		return This.ExtractLast(pcSubStr)

		def LastOccurrencePopped(pcSubStr)
			return This.ExtractLast(pcSubStr)

	  #------------------------------------------------#
	 #  EXTRACTING CHARS VERIFYING A GIVEN CONDITION  #
	#================================================#

	# Removes the chars from the string and returns them

	def ExtractCharsWCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)
		acResult = This.CharsAtPositions(anPos)
		return acResult

		def PopCharsWCS(pcCondition, pCaseSensitive)
			return This.ExtractCharsWCS(pcCondition, pCaseSensitive)

	def CharsExtractedWCS(pcCondition, pCaseSensitive)
		return This.ExtractCharsWCS(pcCondition, pCaseSensitive)

		def CharsPoppedWCS(pcCondition, pCaseSensitive)
			return This.CharsExtractedWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractCharsW(pcCondition)
		This.ExtractCharsWCS(pcCondition, 1)

		def PopCharsW(pcCondition)
			return This.ExtractCharsW(pcCondition)

	def CharsExtractedW(pcCondition)
		return This.ExtractCharsW(pcCondition)

		def CharsPoppedW(pcCondition)
			return This.CharsExtractedW(pcCondition)

	  #-----------------------------------------------------#
	 #  EXTRACTING CHARS VERIFYING A GIVEN CONDITION -- XT #
	#-----------------------------------------------------#

	def ExtractCharsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)
		acResult = This.CharsAtPositions(anPos)
		return acResult

		def PopCharsWCSXT(pcCondition, pCaseSensitive)
			return This.ExtractCharsWCSXT(pcCondition, pCaseSensitive)

	def CharsExtractedWCSXT(pcCondition, pCaseSensitive)
		return This.ExtractCharsWCSXT(pcCondition, pCaseSensitive)

		def CharsPoppedWCSXT(pcCondition, pCaseSensitive)
			return This.CharsExtractedWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractCharsWXT(pcCondition)
		This.ExtractCharsWCSXT(pcCondition, 1)

		def PopCharsWXT(pcCondition)
			return This.ExtractCharsWXT(pcCondition)

	def CharsExtractedWXT(pcCondition)
		return This.ExtractCharsWXT(pcCondition)

		def CharsPoppedWXT(pcCondition)
			return This.CharsExtractedWXT(pcCondition)

	  #-----------------------------------------------------#
	 #  EXTRACTING SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#=====================================================#

	# Removes the chars from the string and returns them

	def ExtractSubstringsWCS(pcCondition, pCaseSensitive)
		aSections = This.FindSubstringsWCSZZ(pcCondition, pCaseSensitive)
		This.RemoveSubstringsAtSections(aSections)
		acResult = This.Sections(aSections)
		return acResult

		def PopSubstringsWCS(pcCondition, pCaseSensitive)
			return This.ExtractSubstringsWCS(pcCondition, pCaseSensitive)

	def SubstringsExtractedWCS(pcCondition, pCaseSensitive)
		return This.ExtractSubstringsWCS(pcCondition, pCaseSensitive)

		def SubstringsPoppedWCS(pcCondition, pCaseSensitive)
			return This.SubstringsExtractedWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractSubstringsW(pcCondition)
		This.ExtractSubstringsWCS(pcCondition, 1)

		def PopSubstringsW(pcCondition)
			return This.ExtractSubstringsW(pcCondition)

	def SubstringsExtractedW(pcCondition)
		return This.ExtractSubstringsW(pcCondition)

		def SubstringsPoppedW(pcCondition)
			return This.SubstringsExtractedW(pcCondition)

	  #----------------------------------------------------------#
	 #  EXTRACTING SUBSTRINGS VERIFYING A GIVEN CONDITION -- XT #
	#----------------------------------------------------------#

	def ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)
		aSections = This.FindSubstringsWCSXTZZ(pcCondition, pCaseSensitive)
		This.RemoveSubstringsAtSections(aSections)
		acResult = This.Sections(aSections)
		return acResult

		def PopSubstringsWCSXT(pcCondition, pCaseSensitive)
			return This.ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)

	def SubstringsExtractedWCSXT(pcCondition, pCaseSensitive)
		return This.ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)

		def SubstringsPoppedWCSXT(pcCondition, pCaseSensitive)
			return This.SubstringsExtractedWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractSubstringsWXT(pcCondition)
		This.ExtractSubstringsWCSXT(pcCondition, 1)

		def PopSubstringsWXT(pcCondition)
			return This.ExtractSubstringsWXT(pcCondition)

	def SubstringsExtractedWXT(pcCondition)
		return This.ExtractSubstringsWXT(pcCondition)

		def SubstringsPoppedWXT(pcCondition)
			return This.SubstringsExtractedWXT(pcCondition)

	  #----------------------------------------#
	 #  EXTRACTING A SECTION FROM THE STRING  #
	#========================================#

	def ExtractSection(n1, n2)

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def PopSection(n1, n2)
			return This.ExtractSection(n1, n2)

		#>

	def SectionExtracted(n1, n2)
		return This.ExtractSection(n1, n2)

		#< @FunctionAlternativeForm

		def SectionPopped(n1, n2)
			return This.SectionExtracted(n1, n2)

		#>

	  #--------------------------------------#
	 #  EXTRACTING A RANGE FROM THE STRING  #
	#--------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

		def PopRange(nStart, nRange)
			return This.ExtractRange(nStart, nRange)

	def RangeExtracted(nStart, nRange)
		return This.ExtractRange(nStart, nRange)

		def RangePopped(nStart, nRange)
			return This.RangeExtracted(nStart, nRange)

	  #----------------------------------------------------------#
	 #  EXTRACTING NEXT SUBSTRING STARTING AT A GIVEN POSITION  #
	#----------------------------------------------------------#

	def ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		if This.FindNext(pcSubStr, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemoveSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return pcSubStr

		#< @FunctionAlternativeForms

		def ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
			This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractNextOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def NextExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrenceExtractedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractNextST(pcSubStr, pnStartingAt)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def ExtractNext(pcSubStr, pnStartingAt)
			This.ExtractNextST(pcSubStr, pnStartingAt)

		def ExtractNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#--

		def ExtractNextOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#>

	def NextOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def NextExtracted(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrenceExtractedST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrencePoppedST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#>

	  #--------------------------------------------------------------#
	 #  EXTRACTING PREVIOUS SUBSTRING STARTING AT A GIVEN POSITION  #
	#--------------------------------------------------------------#

	def ExtractPreviousSTCS(substring, pnStartingAt, pCaseSensitive)
		if This.FindPreviousCS(substring, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemovePreviousCS(substring, pnStartingAt, pCaseSensitive)
		return substring

		#< @FunctionAlternativeForms

		def ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
			This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractPreviousOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def PreviousOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PreviousExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrenceExtractedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractPreviousST(pcSubStr, pnStartingAt)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def ExtractPrevious(pcSubStr, pnStartingAt)
			This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def ExtractPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#--

		def ExtractPreviousOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#>

	def PreviousOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, 1)

		#< @FunctionAlternativeForms

		def PreviousExtracted(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrenceExtractedST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePoppedST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#>

	  #====================================#
	 #  FINDING OVERSPACES IN THE STRING  #
	#====================================#
	
	def FindOverSpaces()
		acChars = This.Chars()
		nLen = len(acChars)
	
		anResult = []
	
		if nLen < 2
			return anResult
		ok
	
		for i = 2 to nLen-1
			if acChars[i] = " " and acChars[i-1] = " "
				anResult + i
			ok
		next
	
		if acChars[nLen] = " " and acChars[nLen-1] = " "
			anResult + nLen
		ok
	
		return anResult
	
		def FindOverSpacesZ()
			return This.FindOverSpaces()
	
	def FindOverSpacesAsSections()
		anPos = This.FindOverSpaces() + 0
		nLen = len(anPos)
	
		if nLen < 2
			return []
		ok
	
		aResult = []
		n1 = anPos[1]
		
		for i = 2 to nLen - 1
			nCurrentPos = anPos[i]
			nPrevPos = anPos[i-1]
			nNextPos = anPos[i+1]
	
			if nCurrentPos = nPrevPos + 1
				if nNextPos = nCurrentPos + 1
				// Continue
		
				else
					aResult + [ n1, anPos[i] ]
					n1 = anPos[i+1]
				ok
			ok		
		next
	
	
		return aResult
	
		def FindOverSpacesZZ()
			return This.FindOverSpacesAsSections()
	
	def Overspaces()
		acResult = This.Sections( This.FindOverSpacesZZ() )
		return acResult
	
	def OverSpacesAndTheirsPositions()
		acSpaces = This.OverSpaces()
		anPos = This.FindOverSpaces()
		aResult = Association([ acSpaces, anPos ])
	
		return aResult
	
		def OverSpacesZ()
			return This.OverSpacesAndTheirPositions()
	
	def OverSpacesAndTheirSections()
		acSpaces = This.OverSpaces()
		aSections = This.FindOverSpacesAsSections()
		aResult = Association([ acSpaces, aSections ])
	
		return aResult
	
		def OverSpacesZZ()
			return This.OverSpacesAndTheirSections()
	
	def RemoveOverSpaces()
		This.RemoveSections( This.FindOverSpacesAsSections() )
	
		def RemoveOverSpacesQ()
			This.RemoveOverSpaces()
			return This
	
	def OverSpacesRemoved()
		cResult = This.Copy().RemoveOverSpacesQ().Content()
		return cResult
	
	def ReplaceOverSpaces(c)
		if isList(c) and StzListQ(c).IsWithOrByNamedParams()
			c = c[2]
		ok
	
		# Composing the substrings to rpelace the overspaces with
	
		aSections = This.FindOverSpacesAsSections()
		nLen = len(aSections)
	
		acSpaceSubStr = []
	
		for i = 1 to nLen
			cSubStr = ""
			nLenSubStr = len(aSections[i])
	
			for j = 1 to nLenSubStr
				cSubStr += c
			next
	
			acSpaceSubStr + cSubStr
		next
	
		# Doing the job
	
		This.ReplaceSectionsByMany(aSections, acSpaceSubStr)
	
		def ReplaceOverSpacesQ(c)
			This.ReplaceOverSpaces()
			return This
	
	def OverSpacesReplaced(c)
		cResult = This.Copy().ReplaceOverSpacesQ(c).Content()
		return cResult

	  #====================================#
	 #  REMOVING UPPON A GIVEN CONDITION  #
	#====================================#

	def RemoveWCS(pcCondition, pCaseSensitive)
		aSections = This.FindWCSZZ(pcCondition, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveWCSQ(pcCondition, pCaseSensitive)
			This.RemoveWCS(pcCondition, pCaseSensitive)
			return This

	def RemovedWCS(pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveW(pccondition)
		This.RemoveWCS(pcCondition, 1)

		def RemoveWQ(pcCondition)
			return This.RemoveWCSQ(pccondition, 1)

	def RemovedW(pcCondition)
		return This.RemovedWCS(pcCondition, 1)

	  #-------------------------------------------#
	 #  REMOVING UPPON A GIVEN CONDITION -- WXT  #
	#-------------------------------------------#

	def RemoveWCSXT(pcCondition, pCaseSensitive)
		aSections = This.FindWCSXTZZ(pcCondition, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveWCSXT(pcCondition, pCaseSensitive)
			return This

	def RemovedWCSXT(pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveWXT(pccondition)
		This.RemoveWCSXT(pcCondition, 1)

		def RemoveWXTQ(pcCondition)
			return This.RemoveWCSXTQ(pccondition, 1)

	def RemovedWXT(pcCondition)
		return This.RemovedWCSXT(pcCondition, 1)


	  #==========================================================#
	 #   SIMPLIFYING THE STRING BY REMOVING DUPLICATED SPACES   #
	#==========================================================#

	def Simplify()
		oQCopy = QStringObject()
		This.UpdateWith( oQCopy.simplified() )

		def SimplifyQ()
			This.Simplify()
			return This

	def Simplified()
		cResult = This.Copy().SimplifyQ().Content()
		return cResult

	  #-------------------------------------------------#
	 #   SIMPLIFYING THE STRING EXCEPT SOME SECTIONS   #
	#-------------------------------------------------#

	def SimplifyExcept(paSections)
		/* EXAMPLE

		o1 = new stzString(' this code:   txt1  = "    withspaces    "   and txt2="nospaces"  ')
		o1.SimplifyExcept( [ [], [] ] )

		#--> 'var txt = "    nice    "'

		*/

		if isList(paSections) and StzListQ(paSections).IsSectionsNamedParam()
			paSections = paSections[2]
		ok

		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aAntiSections = This.FindAntiSectionsZZ(paSections)
		nLen = len(aAntiSections)

		for i = nLen to 1 step -1

			n1 = aAntiSections[i][1]
			n2 = aAntiSections[i][2]

			cSection = This.Section(n1, n2)
			oSection = new stzString(cSection)

			cSectionSimplified = oSection.Simplified()
			oSectionSimplified = oSection.SimplifyQ()

			if (n2 - n1 + 1) > 2

				if oSection.LastChar() = " " and
				   oSectionSimplified.Last2CharsAsString() != "  "
	
					cSectionSimplified += " "
	
				but oSection.FirstChar() = " " and
				    oSectionSimplified.First2CharsAsString() != "  "
	
					cSectionSimplified = " " + cSectionSimplified
				ok
			ok

			This.ReplaceSection(n1, n2, cSectionSimplified)
		next

		This.Trim()

		def SimplifyExceptQ(paSections)
			This.SimplifyExcept(paSections)
			return This

	def SimplifiedExcept(paSections)
		cResult = This.Copy().SimplifyExceptQ().Content()
		return cResult

	  #==========================#
	 #  SPACIFYING THE STRING   #
	#==========================#

	def SpacifyXT(pcSeparator, pnStep, pcDirection)
		/* EXAMPLE

		Basic mode:

		o1 = new stzString("99999999999")
		? o1.SpacifiedXT(:Separator = "_", :Step = 3, :Direction = :Backward)
		#--> 99_999_999_999

		Advanced mode:
		
		o1 = new stzString("99999999999")
		o1.SpacifyXT(
			:Using    = [ ".", :AndThen = " " ],
			:Stepping = [ 2, :AndThen = 3],
			:Going    = :Backward
		)
		
		? o1.Content()
		#--> 99 999 999.99

		*/

		# Early check

		nLenStr = This.NumberOfChars()

		if nLenStr < 2
			return
		ok

		# Checking params

		if isList(pcSeparator) and StzListQ(pcSeparator).IsOneOfTheseNamedParams([ :Using, :Separator ])
			pcSeparator = pcSeparator[2]
		ok

		if isList(pnStep) and StzListQ(pnStep).IsOneOfTheseNamedParams([ :Step, :Stepping, :EachNChars ])
			pnStep = pnStep[2]
		ok

		if isList(pcDirection) and StzListQ(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		# Getting the mode

		if isString(pcSeparator) and isNumber(pnStep) and isString(pcDirection)
			cMode = :Basic

		else
			cMode = :Extended
		ok
		
		# doing the job

		if cMode = :Basic

			anPos = []

			if pcDirection = :Forward or pcDirection = :Default
				
				for i = 1 to nLenStr step pnStep
					anPos + i
				next

				This.InsertBeforeThesePositions(anPos, pcSeparator)
				return

			but pcDirection = :Backward
		
				for i = nLenStr to 1 step -pnStep
					anPos + i
				next

				This.InsertAfterThesePositions(anPos, pcSeparator)
				return
			ok

			StzRaise("Unsupported syntax!")
		ok

		# Case of Extended mode

		if cMode = :Extended

			# Setting the default params

			cSeparator1 = " "
			cSeparator2 = " "
			nLastChars = 0

			nStep1 = 1
			nStep2 = 1

			cDirection1 = :Forward
			cDirection2 = :Forward

			# Getting the separator params

			if isString(pcSeparator)
				cSeparator1 = pcSeparator

			but isList(pcSeparator) and len(pcSeparator) <= 3

				if isString(pcSeparator[1])
					cSeparator1 = pcSeparator[1]
				ok

				if isString(pcSeparator[2])
					cSeparator2 = pcSeparator[2]

				but isList(pcSeparator[2]) and
				    StzListQ(pcSeparator[2]).IsAndThenNamedParam() and
				    isString(pcSeparator[2][2])

					cSeparator2 = pcSeparator[2][2]
				ok

				if len(pcSeparator) = 3

					if isNumber(pcSeparator[3])
						nLastChars = pcSeparator[3]

					but isList(pcSeparator[3]) and
					    ( StzListQ(pcSeparator[3]).isNLastCharsNamedParam() or
					      StzListQ(pcSeparator[3]).IsLastCharsNamedParam() )					     						

						if isNumber(pcSeparator[3][2])
							nLastChars = pcSeparator[3][2]
						ok

					ok

				ok
			else
				StzRaise("Incorrect param type! Allowed format for extended pcSeparator is [ cSep1, cSep2, nLastChars ].")
			ok

			# Getting the stepping params

			if isNumber(pnStep)
				nStep1 = pnStep

			but isList(pnStep) and len(pnStep) <= 3

				if isNumber(pnStep[1])
					nStep1 = pnStep[1]
				ok

				nLenStep = len(pnStep)

				if nLenStep = 2

					if isNumber(pnStep[2])
						nStep2 = pnStep[2]
					
					else isList(pnStep[2]) and
				  	     StzListQ(pnStep[2]).IsAndThenNamedParam() and
				  	     isNumber(pnStep[2][2])

						nStep2 = pnStep[2][2]
					ok

				but nLenStep = 3

					if isNumber(pnStep[2])
						nStep2 = pnStep[2]
					
					else isList(pnStep[2]) and
				  	     StzListQ(pnStep[2]).IsAndThenNamedParam() and
				  	     isNumber(pnStep[2][2])

						nStep2 = pnStep[2][2]
					ok

					if isNumber(pnStep[3])
						nLastChars = pnStep[3]

					but isList(pnStep[3]) and

					    ( StzListQ(pnStep[3]).IsLastNCharsNamedParam() or
					      StzListQ(pnStep[3]).IsLastCharsNamedParam() )

						nLastChars = pnStep[3][2]

					ok

				ok
			
			else
				StzRaise("Incorrect param type! Allowed format for extended pnStep param is [ nStep1, nStep2, nLastNChars ].")
			ok

			# Getting the direction params

			if isString(pcDirection)
				cDirection1 = pcDirection

			but isList(pcDirection) and len(pcDirection) <= 2

				if isString(pcDirection[1])
					cDirection1 = pcDirection[1]
				ok

				if len(pcDirection) = 2

					if isString(pcDirection[2])
						cDirection2 = pcDirection[2]
					
					else isList(pcDirection[2]) and
				  	     StzListQ(pcDirection[2]).IsAndThenNamedParam() and
				  	     isNumber(pcDirection[2][2])

						cDirection2 = pcDirection[2][2]
					ok
				ok
			else
				StzRaise("Incorrect param type! Allowed format for extended pcDirection param is [ :Forward, :Backward ].")
			ok

			# Doing the job

			if nLastChars = 0 and nStep1 > 0

				anPos = []

				if cDirection1 = :Forward

					for i = 1 to nLenStr step nStep1
						anPos + i
					next
	
					This.InsertBeforeThesePositions(anPos, cSeparator1)
	
				but cDirection1 = :Backward
			
					for i = nLenStr to 1 step -nStep1
						anPos + i
					next
	
					This.InsertAfterThesePositions(anPos, cSeparator1)
				ok

			else

				# Spacifiying the first part of the string

				oPart1 = This.SectionQ(1, nLenStr - nLastChars)

				if nStep1 > 0
					nLenPart1 = oPart1.NumberOfChars()
	
					anPos = []
	
					if cDirection1 = :Forward
						
						for i = 1 to nLenPart1 step nStep1
							anPos + i
						next
		
						oPart1.InsertBeforeThesePositions(anPos, cSeparator1)
		
					but cDirection1 = :Backward
				
						for i = nLenPart1 to 1 step -nStep1
							anPos + i
						next
		
						oPart1.InsertAfterThesePositions(anPos, cSeparator1)
					ok
				ok

				# Spacifying the second part of the string

				oPart2 = This.SectionQ(nLenStr - nLastChars + 1, nLenStr)

				if nStep2 > 0
					nLenPart2 = oPart2.NumberOfChars()
	
					anPos = []
	
					if cDirection2 = :Forward
	
						for i = 1 to nLenPart2 step nStep2
							anPos + i
						next
		
						oPart2.InsertBeforeThesePositions(anPos, cSeparator1)
		
					but cDirection2 = :Backward
				
						for i = nLenPart2 to 1 step -nStep2
							anPos + i
						next
		
						oPart2.InsertAfterThesePositions(anPos, cSeparator1)
					ok
				ok

				# Composing the result and updating the string

				cResult = oPart1.Content() + cSeparator2 + oPart2.Content()
				This.UpdateWith(cResult)

			ok

		ok

		def SpacifyXTQ(pcSeparator, pnStep, pcDirection)
			This.SpacifyXT(pcSeparator, pnStep, pcDirection)
			return This

		def SpacifyCharsXT(pcSeparator, pnStep, pcDirection)
			This.SpacifyXT(pcSeparator, pnStep, pcDirection)

			def SpacifyCharsXTQ(pcSeparator, pnStep, pcDirection)
				return This.SpacifyXTQ(pcSeparator, pnStep, pcDirection)

	def SpacifiedXT(pcSeparator, pnStep, pcDirection)
		cResult = This.Copy().SpacifyXTQ(pcSeparator, pnStep, pcDirection).Content()
		return cResult

		def CharsSpacifiedXT(pcSeparator, pnStep, pcDirection)
			return This.SpacifiedXT(pcSeparator, pnStep, pcDirection)

	  #----------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING   #
	#----------------------------------------#

	def SpacifyEachNChars(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsQ(n)
			This.SpacifyEachNChars(n)
			return This

	def EachNCharsSpacified(n)
		return This.Copy().SpacifyEachNCharsQ(n).Content()

	#--

	def SpacifyEachNCharsForward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsForwardQ(n)
			This.SpacifyEachNCharsForward(n)
			return This

	def EachNCharsSpacifiedForward(n)
		return This.Copy().SpacifyEachNCharsForwardQ(n).Content()

	#--

	def SpacifyEachNCharsBackward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Backward)

		def SpacifyEachNCharsBackwardQ(n)
			This.SpacifyEachNCharsBackward(n)
			return This

	def EachNCharsSpacifiedBackward(n)
		return This.Copy().SpacifyEachNCharsBackwardQ(n).Content()

	#--

	def SpacifyChars()
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").Spacified()
		#--> R I N G O R I A L A N D

		*/

		_oQCopy_ = QStringObject()

		nLen = _oQCopy_.size()
		for i = nLen-1 to 1 step -1
			_oQCopy_.insert(i, " ")
		next

		This.UpdateWith( QStringToString(_oQCopy_) )

		def SpacifyCharsQ()
			This.SpacifyChars()
			return This

		def Spacify()
			This.SpacifyChars()

			def SpacifyQ()
				This.Spacify()
				return This

		def SpacifyIt()
			This.SpacifyChars()

			def SpacifyItQ()
				This.Spacify()
				return This

	#-- PASSIVE FORM : TODO - Add this title for each passive form in the library

	def CharsSpacified()
		cResult = This.Copy().SpacifyCharsQ().Content()
		return cResult

		def Spacified()
			return This.CharsSpacified()

		def SpacifyItR()
			return This.CharsSpacified()

		#< @FunctionFutureForm

		def SpacifiedFQ()
			@AddFutureXT(:Spacify, _cFutureOrder)
			return This

		#>

	#--

	def IsSpacified()
		if This.IsEqualTo(This.Spacified())
			return 1
		else
			return 0
		ok

		#< @FunctionFutureForm

		def IsSpacifiedF()
			@AddFutureXT(:Spacify, _cFutureOrder)

		def IsSpacifiedFQ()
			@AddFutureXT(:Spacify, _cFutureOrder)
			return This

		#>

	  #----------------------------------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------#

	def SpacifyCharsUsing(pcSep)
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").SpacifiedUsing("_")
		#--> R_I_N_G_O_R_I_A_L_A_N_D

		*/

		_oQCopy_ = QStringObject()
		nLen = _oQCopy_.size()

		for i = nLen-1 to 1 step -1
			_oQCopy_.insert(i, pcSep)
		next

		This.UpdateWith( QStringToString(_oQCopy_) )

		def SpacifyCharsUsingQ(pcSep)
			This.SpacifyCharsUsing(pcSep)
			return This

		def SpacifyUsing(pcSep)
			This.SpacifyCharsUsing(pcSep)

			def SpacifyUsingQ(pcSep)
				This.SpacifiyUsing(pcSep)
				return This

	def CharsSpacifiedUsing(pcSep)
		cResult = This.Copy().SpacifyCharsUsingQ(pcSep).Content()
		return cResult

		def SpacifiedUsing(pcSep)
			return CharsSpacifiedUsing(pcSep)

	  #--------------------------------------------------------------------------#
	 #  SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING USING A GIVEN SEPARATOR  #
	#--------------------------------------------------------------------------#

	def SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
		This.AddBoundsToSubStringCS(pcSubStr, pcSep, pcSep, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
			return This

		#>

	def SubStringSpacifiedUsingCS(pcSubStr, pcSep, pCaseSensitive)
		cResult = This.Copy().SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubstringUsing(pcSubStr, pcSep)
		This.SpacifySubStringUsingCS(pcSubStr, pcSep, 1)

		#< @FunctionFluentForm

		def SpacifySubStringUsingQ(pcSubStr, pcSep)
			This.SpacifySubstringUsing(pcSubStr, pcSep)
			return This

		#>

	def SubStringSpacifiedUsing(pcSubStr, pcSep)
		cResult = This.Copy().SpacifySubStringUsingQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	  #----------------------------------------------------#
	 #   SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#----------------------------------------------------#

	def SpacifySubstringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
		This.BoundSections(aSections, " ")


		def SpacifySubStringCSQ(pcSubStr, pCaseSensitive)
			This.SpacifySubStringCS(pcSubStr, pCaseSensitive)
			return This

		def SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
			This.SpacifySubstringCS(pcSubStr, pCaseSensitive)

			def SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

	def SubStringSpacifiedCS(pcSubStr, pCaseSensitive)
		return This.Copy().SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive).Content()

		def ThisSubStringSpacifiedCS(pcSubStr, pCaseSensitive)
			return This.SubStringSpacifiedCS(pcSubStr, pCaseSensitive)

	#-- CASE-SENSITIVE

	def SpacifySubstring(pcSubStr)
		This.SpacifySubstringCS(pcSubStr, 1)

		def SpacifySubstringQ(pcSubStr)
			This.SpacifySubstring(pcSubStr)
			return This

		def SpacifyThisSubString(pcSubStr)
			This.SpacifySubstring(pcSubStr)

			def SpacifyThisSubStringQ(pcSubStr)
				This.SpacifyThisSubString(pcSubStr)
				return This

	def SubStringSpacified(pcSubStr)
		return This.Copy().SpacifyThisSubStringQ(pcSubStr).Content()

		def ThisSubStringSpacified(pcSubStr)
			return This.SubStringSpacified(pcSubStr)

	  #----------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING   #
	#----------------------------------------------#

	def SpacifySubStringsCS(pacSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("IbelieveinRingfutureandengageforit!")

		o1.SpacifyTheseSubStrings([
			"believe", "in", "Ring", "future", "and", "engage", "for"
		])

		#--> I believe in Ring future and engage for it!

		*/

		This.SpacifySubStringsUsingCS(pacSubStr, " ", pCaseSensitive)

		#< @FuncionFluentForm

		def SpacifySubStringsCSQ(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def SpacifyTheseCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This


		#>

	def SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
		return This.Copy().SpacifySubStringsCSQ(pacSubStr, pCaseSensitive).Content()

		def TheseSubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

		def TheseSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStrings(pacSubStr)
		This.SpacifySubStringsCS(pacSubStr, 1)

		def SpacifySubStringsQ(pacSubStr)
			This.SpacifySubStrings(pacSubStr)
			return This

		def SpacifyTheseSubStrings(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseSubStringsQ(pacSubStr)
				This.SpacifyTheseSubStrings(pacSubStr)
				return This

		def SpacifyThese(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseQ(pacSubStr)
				This.SpacifyThese(pacSubStr)
				return This

	def SubStringsSpacified(pacSubStr)
		return This.Copy().SpacifySubStringsQ(pacSubStr).Content()

		def TheseSubStringsSpacified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

		def TheseSpaccified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

	  #----------------------------------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------------#

	def SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

		if CheckingParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				stzRaise("Incorrect param! pacSubStr must be a list of strings.")
			ok
	
	
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				stzRaise("Incorrect param! pacSubStr must be a list of strings.")
			ok

		ok

		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		nLen = len(aSections)

		if nLen = 0
			return

		but nLen = 1
			This.BoundSection(aSections[1][1], aSections[1][2], " ")
			return
		ok

		# If some sections are included in others then remove them

		#TODO
		# Turn this to a method RemoveIncluded() in stzListOfPairs

		aSectionsXT = [] + aSections[1]
		for i = 2 to nLen
			if ( aSections[i][1] > aSections[i-1][1] and aSections[i][1] < aSections[i-1][2] ) and
			   ( aSections[i][2] > aSections[i-1][1] and aSections[i][2] < aSections[i-1][2] )

				// do nothing
			else

				aSectionsXT + aSections[i]
			ok
		next

		# Inserting the bounds around the sections

		_oCopy_ = This.Copy()

		nLen = len(aSectionsXT)
		_oCopy_.InsertAfterPosition(aSectionsXT[nLen][2], " ")

		for i = nLen to 1 step -1
			n1 = aSectionsXT[i][1]
			_oCopy_.InsertBeforePosition(n1, " ")
		next

		This.UpdateWith(_oCopy_.Content())


		#< @FunctionFluentForm

		def SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseSubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		def SpacifyTheseUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		#>

	def SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
		return This.Copy().SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def TheseSubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		def TheseSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStringsUsing(pacSubStr, pcSep)
		This.SpacifySubStringsUsingCS(pacSubStr, pcSep, 1)

		#< @FunctionFluentForm

		def SpacifySubStringsUsingQ(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)
			return This

		def TheseSpacifiedUsingUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)

			def SpacifyTheseSubStringsUsingQ(pacSubStr, pcSep)
				This.SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
				return This

		#>

	def SubStringsSpacifiedUsing(pacSubStr, pcSep)
		return This.Copy().SpacifySubStringsUsingQ(pacSubStr, pcSep).Content()

		def TheseSubStringsSpacifiedUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

	  #------------------------------------------#
	 #   SPACIFITYING A SECTION OF THE STRING   #
	#------------------------------------------#

	def SpacifySection(n1, n2)

		cLeftSpace = ""
		if This.CharAt(n1) != " "
			cLeftSpace = " "
		ok

		cRightSpace = ""
		if This.CharAt(n2)
			cRightSpace = " "
		ok

		This.ReplaceSection(n1, n2, :By = (cLeftSpace + This.Section(n1, n2) + cRightSpace) )

		def SpacifySectionQ(n1, n2)
			This.SpacifySection(n1, n2)
			return This

	def SectionSpacified(n1, n2)
		cResult = This.Copy().SpacifySectionQ(n1, n2).Content()
		return cResult

	  #----------------------------------------------#
	 #   SPACIFITYING MANY SECTIONS OF THE STRING   #
	#----------------------------------------------#

	def SpacifySections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		anPos = []
		for i = 1 to nLen
			anPos + paSections[i][1]
			anPos + (paSections[i][2] + 1)
		next

		This.InsertBeforePositions(anPos, " ")

		def SpacifySectionsQ(paSections)
			This.SpacifySections(paSections)
			return This

	def SectionsSpacified(paSections)
		cResult = This.Copy().SpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #   UNSPACIFYING THE STRING --> REMOVING SPACES  #
	#================================================#

	def UnSpacify()

		This.Trim()
		anPos = This.FindThisDupSecutiveChar(" ")
		This.RemoveCharsAtPositions(anPos)


		def UnSpacifyQ()
			This.UnSpacify()
			return This

	def Unspacified()
		return This.Copy().UnSpacifyQ().Content()

	  #------------------------------------------------------#
	 #   UNSPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#------------------------------------------------------#

	def UnSpacifySubStringCS(pcSubStr, pCaseSensitive)

		if NOT ( isString(pcSubStr) and StzStringQ(pcSubStr).ContainsSpaces() )
			StzRaise("Incorrect param! pcSubStr must be a string containing spaces.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.ReplaceSections( aSections, Q(pcSubStr).Unspacified() )

	def UnSpacifySubString(pcSubStr)
		This.UnSpacifySubStringCS(pcSubStr, 1)

	  #--------------------------------------------#
	 #   UNSPACIFITYING A SECTION OF THE STRING   #
	#--------------------------------------------#

	def UnSpacifySection(n1, n2)
		This.ReplaceSection(n1, n2, :By = Q(This.SectionQ(n1, n2).Unspacified()) )

		def UnSpacifySectionQ(n1, n2)
			This.UnSpacifySection(n1, n2)
			return This

	def SectionUnSpacified(n1, n2)
		cResult = This.Copy().UnSpacifySectionQ(n1, n2).Content()
		return cResult

	  #------------------------------------------------#
	 #   UNSPACIFITYING MANY SECTIONS OF THE STRING   #
	#------------------------------------------------#

	def UnSpacifySections(paSections)
		if NOT ( isList(paSections) and StzListQ(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		paSections = @SortLists(paSections)
		nLen = len(paSections)

		for i = nLen to 1 step -1
			n1 = paSections[i][1]
			n2 = paSections[i][2]

			cSectionWithoutSpaces = This.SectionQ(n1, n2).Unspacified()
			This.ReplaceSection( n1, n2, cSectionWithoutSpaces )

		next

		def UnSpacifySectionsQ(paSections)
			This.UnSpacifySections(paSections)
			return This

	def SectionsUnSpacified(paSections)
		cResult = This.Copy().UnSpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #    GETTING POSITION AFTER A GIVEN SUBSTRING    #
	#================================================#

	def PositionAfterCS(cSubStr, pCaseSensitive)
		return This.PositionAfterNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionAfterNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		n = This.FindNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		oStr = new stzString(cSubStr)
		return n + oStr.NumberOfChars()

	def PositionAfter(cSubStr)
		return This.PositionAfterCS(cSubStr, 1)

	def PositionAfterNthOccurrence(n, cSubStr)
		return This.PositionAfterNthOccurrenceCS(n, cSubStr, 1)

	  #--------------------------------------------------#
	 #    GETTING POSITION BEFORE A GIVEN SUBSTRING     #
	#--------------------------------------------------#

	def PositionBeforeCS(cSubStr, pCaseSensitive)
		return This.PositionBeforeNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		return This.FindNthOccurrenceCS(cSubStr, pCaseSensitive)
	
	def PositionBefore(cSubStr)
		return This.PositionBeforeCS(cSubStr, 0)

	def PositionBeforeNthOccurrence(n, cSubStr)
		return This.PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)

	  #------------------------------#
	 #   FINDING THE CENTRAL CHAR   #
	#------------------------------#
	
	// Returns the position (if any) of the central Char in the string
	def FindCentralChar()
		nResult = 0

		oNumberOfChars = new stzNumber(This.NumberOfChars())
		if oNumberOfChars.IsOdd()
			nResult = ( This.NumberOfChars() + 1 ) / 2
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindMiddleChar()
			return This.FindCentralChar()

		def PositionOfCentralChar()
			return This.FindCentralChar()

		def CentralCharposition()
			return This.FindCentralChar()

		def PositionOfMiddleChar()
			return This.FindCentralChar()

		def MiddleCharposition()
			return This.FindCentralChar()


		#>

	  #------------------------------#
	 #   GETTING THE CENTRAL CHAR   #
	#------------------------------#

	def CentralChar()
		if This.CentralCharPosition() != ""
			return This.NthChar( This.CentralCharPosition() )
		ok

		def CentralCharQ()
			return This.CentralCharQRT(:stzChar)
	
		def CentralCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar( This.CentralChar() )
			on :stzString
				return new stzString( This.CentralChar() )
			on :stzListOfBytes
				return new stzListOfBytes( This.CentralChar() )
			off

		def MiddleChar()
			return This.CentralChar()

	  #-----------------------------------------------#
	 #   DOES THE STRING CONTAIN ANY CENTRAL CHAR?   #
	#-----------------------------------------------#

	def ContainsCentralChar()
		return This.NumberOfCharsQ().IsNotEven()

		def ContainsMiddleChar()
			return This.ContainsCentralChar()

		def HasCentralChar()
			return This.ContainsCentralChar()

		def HasMiddleChar()
			return This.ContainsCentralChar()

	  #---------------------------------------------------#
	 #   DOES THE STRING CONTAIN A GIVEN CENTRAL CHAR?   #
	#---------------------------------------------------#

	def ContainsThisCentralChar(c)
		return This.CentralChar() = c

		def HasThisCentralChar(c)
			return This.ContainsThisCentralChar(c)

	  #----------------------------------------------------#
	 #    DOES THE STRING CONTAIN ANY MIDDLE SUBSTRING?   #
	#----------------------------------------------------#

	def ContainsMiddleSubstring()
		if This.NumberOfCharsQ().IsOdd()
			return 1

		else
			return 0
		ok

		def HasMiddleSubstring()
			return This.ContainsMiddleSubstring()

		def ContainsCentralSubString()
			return This.ContainsMiddleSubstring()

		def HasCentralSubString()
			return This.ContainsMiddleSubstring()

	  #---------------------------------------------------------#
	 #    DOES THE STRING CONTAIN A GIVEN MIDDLE SUBSTRING?    #
	#---------------------------------------------------------#

	def ContainsSubstringInTheMiddle(pcSubStr)
		if ObjectIsStzString(pcSubStr)
			pcSubStr = pcSubStr.Content()
		ok

		if This.MiddleSubstring() = pcSubStr
			return 1
		else
			return 0
		ok

		def HasSubstringInTheCenter(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

		def ContainsSubstringInTheCenter(c)
			return This.ContainsSubstringInTheMiddle(c)

		def HasSubstringInTheMiddle(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

	  #---------------------------------------------------#
	 #    GETTING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def MiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		cResult = ""

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			n1 = nNumberOfCharsOfOnePart + 1
			n2 = nNumberOfChars - nNumberOfCharsOfOnePart

			cResult = This.Section( n1, n2 )
		ok

		return cResult

		#< @FunctionALternativeForms

		def CentralSubstringWithNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringN(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringN(n)
			return This.MiddleSubstringWithNChars(n)


		#>

	  #---------------------------------------------------#
	 #    FINDING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def FindMiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		nResult = 0

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			nResult = nNumberOfCharsOfOnePart + 1
		ok

		return nResult

		#< @FunctionALternativeForms

		def FindCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#--

		def PositionOfMiddleSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#>

	  #================================#
	 #   GETTING STRING ORIENTATION   #
	#================================#

	/*
	Note that we distinguish between string 'orientation', 
	char 'orientation', and char 'unicode direction'.

	The first says if a string is left-to-right or right-to-left oriented, and
	uses the Orientation() method, here, in stzString.

	The second says the same thing for the individual chars, and uses
	the Orientation() method on stzChar.

	While the third informs us about the technical direction of the char,
	in terms of UNICODE standard, and is returned using UnicodeDirection()
	method on stzChar.
	*/

	// Returns the orientation of the string (:RightToLeft OR :LeftToRight)
	def Orientation()
		if This.IsRightToLeft()
			return :RightToLeft
		else
			return :LeftToRight
		ok

	// Verifies if the string is right-to-left (like arabic) : SEE Orientation()
	def IsRightToleft()
		bResult = This.QStringObject().isRightToleft()
		return bResult

	// Verifies if the string is left-to-right (like english)
	def IsLeftToRight()
		IF NOT This.IsRightToLeft()
			return 1
		else
			return 0

		ok

	// Checks if the text is hybrid (containing :RightToLeft AND :LeftToRight" texts)
	def ContainsHybridOrientation()
		aStzChars = This.ToListOfStzChars()

		bIsHybrid = 0
		cFlag = aStzChars[1].Orientation()

		for i=2 to len(aStzChars)
			if aStzChars[i].Orientation() != cFlag
				bIsHybrid = 1
				exit
			ok
		next

		return bIsHybrid

	// Transforms the string to a list of chars with indication of their orientation
	def CharsWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)
			aResult + [ This.Char(i) , oTempChar.Orientation() ]
		next

		return aResult

	def CharsWithOrientationQ()
		return new stzList( This.CharsWithOrientation() )

	// Transforms the string to a list of letters with indication of their orientation
	def LettersWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)

			if oTempChar.isLetter()
				aResult + [ This.Char(i) , oTempChar.Orientation() ]
			ok
		next

		return aResult

	def LettersWithOrientationQ()
		return new stzList( This.LettersWithOrientation() )

	  #======================#
	 #     ONLY NUMBERS     #
	#======================#
		
	/* Returns (as a string) only the numbers contained in the string

	   Note: if the string contains "㊱", for example, then it is returned
	   as the number 36 contained in a string ("36")!

	   To return just numbers formed from decimal digits from 0 to 9,
	   use OnlyDecimalDigits()
	*/

	def OnlyNumbers()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsANumber()
				cResult += c
			ok
		next
		return cResult

		def OnlyNumbersQ()
			return new stzString( This.OnlyNumbers() )

	def OnlyDecimalDigits()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsDecimalDigit()
				cResult += c
			ok
		next
		return cResult

	def OnlyDecimalDigitsQ()
		return new stzList( This.OnlyDecimalDigits() )

	  #------------------------------------------#
	 #     ONLY LETTERS AND SPACES ANS CHARS    #
	#------------------------------------------#

	// Returns (as a string) only the letters contained in the string
	def OnlyLetters()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.isLetter()
				cResult += c
			ok
		next
		return cResult

	def OnlyLettersQ()
		return new stzList(This.OnlyLetters())

	#----

	def OnlyLettersAndSpaces()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			if StzCharQ(c).IsLetterOrSpace()

				cResult += c
			ok
		next

		return cResult

	def OnlyLettersAndSpacesQ()
		return new stzString( This.OnlyLettersAndSpaces() )

	#----

	def OnlyLettersAndSpacesAndChar(pcChar)

		# t0 = clock() # Takes almost 0.62s

		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsLetterOrSpaceOrChar(pcChar)
				cResult += c
			ok
		next

		# ? ( clock() - t0 ) / clockspersecond()

		return cResult

		def OnlyLettersAndSpacesAndThisChar(pcChar)
			return This.OnlyLettersAndSpacesAndChar(pcChar)

	def OnlyLettersAndSpacesAndCharQ(pcChar)
		return new stzString( This.OnlyLettersAndSpacesAndChar(pcChar) )

		def OnlyLettersAndSpacesAndThisCharQ(pcChar)
			return OnlyLettersAndSpacesAndCharQ(pcChar)

	#----

	def OnlyLettersAndSpacesAndChars(pacChars)
		return This.ItemsWhere('isLetter(@item) or isSpace(@item) or Q(@item).IsOneOfThese(pacChars)')

		def OnlyLettersAndSpacesAndCharsQ(paChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

		def OnlyLettersAndSpacesAndTheseChars(pacChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

	#--

	def IsLetterOrSpaceOrChar(pcChar)
		return This.IsLetterOrSpaceOrOneOfTheseChars([ pcChar ])

		def IsLetterOrSpaceOrThisChar(pcChar)
			return IsLetterOrSpaceOrChar(pcChar)

	def IsLetterOrSpaceOrChars(pacChar)
		bResult = 0

		if This.IsLetter() or This.IsSpace() or
		   ring_find(pacChars, This.Content()) > 0

			return 1
		else
			return 0
		ok

		def IsLetterOrSpaceOrOneOfTheseChars(pacChar)
			return This.IsLetterOrSpaceOreChars(pacChar)

	  #==========================#
	 #    ALIGNING THE STRING   #
	#==========================#

	def Align(pcDirection)
		This.AlignXT( :Max, " ", pcDirection )

		#< @FunctionFluentForms

		def AlignQ(pcDirection)
			This.Align(pcDirection)
			return This

		def AlignQC(pcDirection)
			return This.Copy().Align(pcDirection)

		#>

		#< @FunctionAlternativeForms

		def AlignTo(pcDirection)
			This.Align(pcDirection)

			def AlignToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AlignToQC(cDirection)
				return This.AlignQC(cDirection)

		def Adjust(pcDirection)
			This.Align(pcDirection)

			def AdjustQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustQC(cDirection)
				return This.AlignQC(cDirection)

		def AdjustTo(pcDirection)
			This.Align(pcDirection)

			def AdjustToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustToQC(cDirection)
				return This.AlignQC(cDirection)

		#>
		
	def Aligned(cDirection)
		return This.Copy().AlignQ(cDirection).Content()

		#< @FunctionAlternativeForms

		def AlignedTo(cDirection)
			return This.Aligned(cDirection)

		def Adjusted(cDirection)
			return This.Aligned(cDirection)

		def AdjustedTo(cDirection)
			return This.Aligned(cDirection)

		#>
	  #-----------------------------------#
	 #  ALIGNING THE STRING -- EXTENDED  #
	#-----------------------------------#

	// Aligns the text in a container of width nWidth
	// Note: if the width is smaller then the string, nothing is done!

	def AlignXT(nWidth, cChar, cDirection)
		# cChar is the char to fill the 'blanks" with.

		if isList(nWidth) and StzListQ(nWidth).IsWidthNamedParam()
			nWidth = nWidth[2]
		ok

		if isList(cChar) and ( Q(cChar).IsUsingNamedParam() or
			Q(cChar).IsCharNamedParam() )

			cChar = cChar[2]
		ok

		if isString(cChar) and cChar = ""
			cChar = " "
		ok

		if isList(cDirection) and ( Q(cDirection).IsOneOfTheseNamedParams([ :Direction, :Going ]) or
			Q(cDirection).IsToNamedParam() )

			cDirection = cDirection[2]
		ok

		switch cDirection

		on :Left
			return This.AlignLeftXT(nWidth, cChar)

		on :Right
			return This.AlignRightXT(nWidth, cChar)

		on :Center
			return This.AlignCenterXT(nWidth, cChar)

		on :Justified
			return This.JustifyXT(nWidth, cChar)

		other
			stzRaise(stzStringError(:UnsupportedStringJustificationDirection))
		end

		#< @FunctionFluentForm

		def AlignXTQ(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def AdjustXT(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)

			def AdjustXTQ(nWidth, cChar, cDirection)
				return This.AlignXTQ(nWidth, cChar, cDirection)

		#>

	def AlignedXT(nWidth, cChar, cDirection)
		cResult = This.Copy().AlignXTQ(nWidth, cChar, cDirection).Content()
		return cResult

		def AdjustedXT(nWidth, cChar, cDirection)
			return This.AlignedXT(nWidth, cChar, cDirection)

	  #-----------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT  #
	#-----------------------------------#

	def LeftAlign(nWidth)
		This.LeftAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def LeftAlignQ(nWidth)
			This.LeftAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AlignToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def LeftAdjust(nWidth)
			This.LeftAlign(nWidth)

			def LeftAdjustQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		#>

	def LeftAligned(nWidth)
		cResult = This.Copy().LeftAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		def LeftAdjusted(nWidth)
			return This.LeftAligned(nWidth)

		def AdjustedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		#>

	  #-----------------------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT -- EXTENDED  #
	#-----------------------------------------------#

	def LeftAlignXT(nWidth, cChar)

		/* NOTE

		Managing the special case of the arabic char (Shaddah)
		which can alter the justification of text, because Qt
		treats it as a spearate char with its own position in
		the resulting string, while it must set on top of chars!

		Note: The same case of arabic diacritics (7araket)
		is not managed in this version (In the future,
		an extended arabic library will manage those (and other)
		specificities of arabic language.

		~> #WARNING: In this version, if your arabic text contains
		arabic diactritics (7arakets), then the alignment
		won't be correct!

		Also, for this alignement to work as expected, the font
		you use in to display the text on the console must be
		of "fixed size".

 		*/

		if CheckingParams()
			if NOT isNumber(nWidth)
				StzRaise("Incorrect param type! nWidth must be a number.")
			ok

			if NOT ( isString(cChar) and @IsChar(cChar) )
				StzRaise("Incorrect param type! cChar must be a char.")
			ok
		ok

		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the alignment using Qt

		oQCopy = QStringObject()

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			// Take in account a logical error of Qt in aligning non
			// left-to-right strings (like arabic and hebrew)

			if This.IsRightToLeft()
				cJustified = oQCopy.rightJustified(nWidth, oQChar, 0)
			else
				cJustified = oQCopy.leftJustified(nWidth, oQChar, 0)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def LeftAlignXTQ(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeftXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def AlignLeftXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		def LeftAdjustXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def LeftAdjustXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		#>

	def LeftAlignedXT(nWidth, cChar)
		cResult = This.Copy().LeftAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeftXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		def LeftAdjustedXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		#>

	  #------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT  #
	#------------------------------------#

	def RightAlign(nWidth)
		This.RightAlignXT(nWidth, " ")

		#< @FunctioFluentForm

		def RightAlignQ(nWidth)
			This.RightAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRight(nWidth)
			This.RightAlign(nWidth)

			def AlignRightQ(nWidth)
				return This.RightAlignQ(nWidth)

		def AlignToRight(nWidth)
			This.RightAlign(nWidth)

			def AlignToRightQ(nWidth)
				return This.RightAlignQ(nWidth)
	
		def RightAdjust(nWidth)
			This.RightAlign(nWidth)

			def RightAdjustQ(nWidth)
				return This.RightAlignQ(nWidth)

		#>

	def RightAligned(nWidth)
		cResult = This.Copy().RightAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRight(nWidth)
			return This.RightAligned(nWidth)

		def RightAdjusted(nWidth)
			return This.RightAligned(nWidth)

		def AdjustedtoRight(nWidth)
			return This.RightAligned(nWidth)

		#>

	  #------------------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT -- EXTENDED  #
	#------------------------------------------------#

	def RightAlignXT(nWidth, cChar)
		if CheckingParams()
			if NOT isNumber(nWidth)
				StzRaise("Incorrect param type! nWidth must be a number.")
			ok

			if NOT ( isString(cChar) and @IsChar(cChar) )
				StzRaise("Incorrect param type! cChar must be a char.")
			ok
		ok

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification using Qt

		oQCopy = QStringObject()

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			if This.IsRightToLeft()
				cJustified = oQCopy.leftJustified(nWidth, oQChar, 0)
			else
				cJustified = oQCopy.rightJustified(nWidth, oQChar, 0)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def RightAlignXTQ(nWidth, cChar)
			
			This.RightAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRightXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def AlignRightXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		def RightAdjustXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def RightAdjustXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		#>

	def RightAlignedXT(nWidth, cChar)
		cResult = This.Copy().RightAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def RightAdjustedXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def AdjustedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		#>

	  #------------------------#
	 #  CENTERING THE STRING  #
	#------------------------#

	def CenterAlign(nWidth)
		This.CenterAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def CenterAlignQ(nWidth)
			This.CenterAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AlignCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def CenterAdjust(nWidth)
			This.CenterAlign(nWidth)

			def CenterAdjustQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def Center(nWidth)
			This.CenterAlign(nWidth)

			def CenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		#>

	def CenterAligned(nWidth)
		cResult = This.Copy().CenterAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def AdjustedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def CenterAdjusted(nWidth)
			return This.CenterAligned(nWidth)

		def Centered(nWidth)
			This.CenterAligned(nWidth)

		#>

	  #------------------------------------#
	 #  CENTERING THE STRING -- EXTENDED  #
	#------------------------------------#

	def CenterAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth > This.NumberOfChars()

			n = nWidth - This.NumberOfChars()
			n1 = 0
			n2 = 0

			oNumber = new stzNumber(n)
			if oNumber.IsEven()
				n1 = n / 2
				n2 = n1
			else
				n1 = (n - 1) / 2
				n2 = n1 + 1
			ok

			cResult = RepeatInString(cChar, n1) +
				  This.String() +
				  RepeatInString(cChar, n2)

			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def CenterAlignXTQ(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AlignToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterAdjustXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterAdjustXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		#>

	def CenterAlignedXT(nWidth, cChar)
		cResult = This.Copy().CenterAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenterAdjustedXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def AdjustedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenteredXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		#>

	  #-------------------------#
	 #  JUSTIFYING THE STRING  #
	#-------------------------#

	def Justify(nWidth)
		This.JustifyXT(nWidth, " ")

		def JustifyQ(nWidth)
			This.Justify(nWidth)
			return This

		// NEW: returns a jystified copy of the string object
		// --> Useful in copy-on-right (functional) programming
		def JustifyQC(nWith)
			return This.Copy().Justify(nWidth)

	def Justified(nWidth)
		return This.Copy().JustifyQ(nWidth).Content()

	  #-------------------------------------#
	 #  JUSTIFYING THE STRING -- EXTENDED  #
	#-------------------------------------#

	def JustifyXT(nWidth, pcChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth <= This.NumberOfChars()
			return ""
		ok

		nPoints = nWidth - This.NumberOfChars()
		aTemp = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen - 1

			cCurrentChar = This.Char(i)

			if NOT ( CharIsArabicShaddah(cCurrentChar) or CharIsArabic7arakah(cCurrentChar) )

				aTemp + cCurrentChar
			else
				if len(aTemp) != 0
					aTemp[ len(aTemp) ] = aTemp[ len(aTemp) ] + cCurrentChar
				ok
			ok
		next

		while nPoints > 0
			for i = 1 to len(aTemp)
				aTemp[i] = aTemp[i] + pcChar
				nPoints--
				if nPoints = 0 { exit }
			next
		end

		aTemp + This.LastChar()

		cResult = ""
		for str in aTemp
			cResult += str
		next

		cResult = Q(cResult).ReplaceQ(" ", pcChar).Content()
		This.Update( cResult )

		def JustifyXTQ(nWidth, pcChar)
			This.JustifyXT(nWidth, pcChar)
			return This

	def JustifiedXT(nWidth, pcChar)
		cResult = This.Copy().JustifyXTQ(nWidth, pcChar).Content()

	  #==================================#
	 #    TEXT ENCODING & CONVERTING    #
	#==================================#

	//Returns a UTF-8 representation of the string (using QByteArray)
	def ToUTF8()
		oQCopy = QStringObject()
		cResult = QByteArrayToListOfUnicodes(oQCopy.toUtf8())
		return cResult

	def ToUTF8Q()
		return new stzString( This.ToUTF8() )

	def FromUTF8(pcUTF8String)
		StzRaise("Function non implemented yet!")

	def ToLatin1()
		oQCopy = QStringObject()
		cResult = oQCopy.toLatin1()
		return oQCopy.toLatin1()

	def FromLatin1(pcLatin1String)
		StzRaise("Function non implemented yet!")

	def ToLocal8Bit()
		oQCopy = QStringObject()
		cResult = oQCopy.toLocal8bit()
		return cResult

	def ToBase64()
		cResult = This.ToStzListOfBytes().ToBase64()
		return cResult

		def ToBase64Q()
			return new stzString( This.ToBase64() )

	  #---------------------------#
	 #  URL-ENCODING THE STRING  #
	#---------------------------#

	#TODO // Support Unicode in this function
	#~> // Use QSrinng.toPercentencoding() when added to RingQt

	def UrlEncode()
		/* Example:
		o1 = new stzString("{a fishy string?}")
		? o1.ToPercentEncoding( "{}", "s" )

		--> {a%20fi%73hy%20%73tring%3F}
		*/

		result = ""
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen

			char = acChars[i]
			charCode = @Unicode(char)

			if (charCode >= ascii('a') and charCode <= ascii('z')) or
				(charCode >= ascii('A') and charCode <= ascii('Z')) or
				(charCode >= ascii('0') and charCode <= ascii('9')) or
				char = '-' or char = '_' or char = '.' or char = '~'

				result = result + char
			else
				hexStr = hex(charCode)

				if len(hexStr) = 1
					hexStr = "0" + hexStr
				ok

				result = result + "%" + hexStr
			end
		end

		This.UpdateWith( result )

		def UrlEncodeQ()
			This.UrlEncode()
			return This

	def UrlEncoded()
		cResult = This.Copy().UrlEncodeQ().Content()
		return cResult

		def ToUrlEncoded()
			return This.UrlEncoded()

	  #---------------------------#
	 #  URL-ENCODING THE STRING  #
	#---------------------------#

	#TODO // Support Unicode in this function
	#~> // Use QSrinng.toPercentencoding() when added to RingQt

	def UrlDecode()
		/* Example:
		o1 = new stzString("")
		o1.FromPercentEncoding( "{a%20fi%73hy%20%73tring%3F}", "%" )
		o1.Content()

		--> {a fishy string?}
		*/

		_cResult_ = ""
		@i = 1

		_acChars_ = This.Chars()
		_nLen_ = len( _acChars_ )

		while @i <= _nLen_

			if _acChars_[@i] = "%" and (@i + 2) <= _nLen_

				_cHexStr_ = This.QStringObject().mid(@i, 2)
				_nCharCode_ = @Unicode( hex2str(_cHexStr_) )

				_cResult_ += ( @Char(_nCharCode_) + " " )
				@i += 3

		        else

				_cResult_ += This.QStringObject().mid(@i-1, 1)
		            	@i = @i + 1
		        end
		end

		This.UpdateWith( _cResult_ )

		def UrlDecodeQ()
			This.UrlDecode()
			return This

	def UrlDecoded()
		cResult = This.Copy().UrlDecodeQ().Content()
		return cResult

		def ToUrlDecoded()
			return This.UrlDecoded()

	  #-----------------------------#
	 #  WORKING WITH THE HEX FORM  #
	#=============================#

	def ToHex()

		cResult = HexPrefix() + str2hex( This.String() )
		return cResult

		def ToHexQ()
			return new stzString( This.ToHex() )

	def ToHexWithoutPrefix()
		cResult = str2hex( This.String() )
		return cResult

		def ToHexWithoutPrefixQ()
			return new stzString( This.ToHexWithoutPrefix() )

	def FromHex(cHex)
		oQCode = new QString2()
		This.UpdateWith( oQCode.append(hex2str(cHex)) )

		def FromHexQ(cHex)
			This.FromHex(cHex)
			return This

	def Hexcodes()
		acResult = This.ToStzListOfBytes().HexCodes()
		return acResult

	def HexPerByte()
		aResult = This.ToStzListOfBytes().HexPerByte()

		def HexcodePerByte()
			return This.HexPerByte()

	def HexcodesWithoutPrefix()
		acResult = This.ToStzListOfBytes().HexCodesWithoutPrefix()
		return acResult

	def HexPerByteWithoutPrefix()
		aResult = This.ToStzListOfBytes().HexPerByteWithoutPrefix()

	def ToHexSeparated(pcSep)
		cResult = This.ToStzListOfBytes().ToHexSeparated(pcSep)

		#< @FunctionAlternativeForm

		def ToHexSeparatedBy(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		def ToHexSeparatedWith(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		def ToHexSeparatedUsing(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		#>

	def ToHexSpacified()
		return This.ToHexSeparatedBy(" ")

	#--

	def ToHexWithoutPrefixSeparated(pcSep)
		cResult = This.ToStzListOfBytes().ToHexWithoutPrefixSeparated(pcSep)

		#< @FunctionAlternativeForm

		def ToHexWithoutPrefixSeparatedBy(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		def ToHexWithoutPrefixSeparatedWith(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		def ToHexWithoutPrefixSeparatedUsing(pcSep)
			if CheckingParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		#>

	def ToHexWithoutPrefixSpacified()
		return This.ToHexWithoutPrefixSeparatedBy(" ")

	def ToHexUTF8()
		cResult = This.ToStzListOfBytes().ToHexUTF8()
		return cResult

	  #---------------------------------------------#
	 #  Escaping HTML special Chars in the string  #
	#=============================================#

	def EscapeHtml()
		oQCopy = QStringObject()
		This.UpdateWith( oQCopy.toHtmlEscaped() )

		def EscapeHtmlQ()
			This.EscapeHtml()
			return This

	def HtmlEscaped()
		cResult = This.Copy().EscapeHtmlQ().Content()
		return cResult

	  #=======================================#
	 #  TRANSFORMING THE STRING TO A NUMBER  #
	#=======================================#

	def ToNumber()
		if This.IsNumberInString()
			cNumber = This.Copy().RemoveQ("_").Content()
			nResult = 0+ cNumber
			return nResult

		else
			StzRaise("Incorrect value! The string does not contain a well formed number.")
		ok

	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// Transforms the string to a number based on the defined format
	// --> TODO: Use the ApplyFormat() method in the stzNumber class...
	// Rething the naming!

	def ToNumberFormatted(cFormat) // TODO
		/*
		o1 = new stzString("+12500,14")
		? o1.ToNumberFormatted( :As = "+99 999.99") --> 12 500.14
		*/

		stzRaise("Function unavailable in this version!")

		def ToNumberFormattedQ(cFormat)
			return new stzNumber( This.ToNumberFormatted() )

	  #================================================#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#================================================#

	// Returns a list of unicodes of all the Chars in the string

	def Unicodes()

		_nLen_ = This.NumberOfChars()
		_anResult_ = []
		
		for @i = 1 to _nLen_
			_anResult_ + This.UnicodeOfCharN(@i)
		next

		return _anResult_

		#< @FunctionFluentForms

		def UnicodesQ()
			return This.UnicodesQRT(:stzList)

		def UnicodesQRT(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Unicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Unicodes() )

			other
				stzRaise("Unsupported return type!")
			off

		#>


	def Unicode()
		if This.NumberOfChars() = 1
			return This.UnicodeOfCharN(1)

		else
			return This.Unicodes()
		ok

	def CharsAndUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.UnicodeOfCharN(i) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def CharsAndTheirUnicodes()
			return This.CharsAndUnicodes()

		def UnicodesPerChar()
			return This.CharsAndUnicodes()

		def UnicodePerChar()
			return This.CharsAndUnicodes()

		#>

	def CharsAndUnicodesU()
		aResult = U( This.CharsAndUnicodes() )
		return aResult

		#< @FunctionAlternativeForms

		def CharsAndTheirUnicodesU()
			return This.CharsAndUnicodesU()

		def UnicodesPerCharU()
			return This.CharsAndUnicodesU()

		def UnicodePerCharU()
			return This.CharsAndUnicodesU()

		#>

	def UnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.UnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UnicodesAndTheirChars()
			return This.UnicodesAndChars()

		def UnicodesXT()
			return This.UnicodesAndChars()

		def CharsPerUnicode()
			return This.UnicodesAndChars()

		def CharPerUnicode()
			return This.UnicodesAndChars()

		#>

	def UnicodesAndCharsU()
		aResult = U( This.UnicodesAndChars() )
		return aResult

		#< @FunctionAlternativeForms

		def UnicodesAndTheirCharsU()
			return This.UnicodesAndCharsU()

		def UnicodesXTU()
			return This.UnicodesAndCharsU()

		def CharsPerUnicodeU()
			return This.UnicodesAndCharsU()

		def CharPerUnicodeU()
			return This.UnicodesAndCharsU()

		#>

	// The following method is mainly used by stzChar class to
	// create a characrer object from text

	def UnicodeOfCharN(n)
		oTempQStr = new QString2()
		oTempQStr.append(This[n])
		return oTempQStr.unicode().unicode()
		/*
		The first unicode() on QString returns a QChar,
		while the seconde unicode() on this QChar returns
		the actual decimal unicode of the Char
		*/

		#< @FunctionAlternativeForms

		def UnicodeOfNthChar(n)
			return This.UnicodeOfCharN(n)

		def NthCharUnicode(n)
			return This.UnicodeOfCharN(n)

		#>

	  #-------------------------------------------------#
	 #   HEXUNICODE CODES OF THE CHARS OF THE STRING   #
	#-------------------------------------------------#

	// Returns a list of hexunicodes of all the Chars in the string

	def HexUnicodes()

		_nLen_ = This.NumberOfChars()
		_acResult_ = []

		for @i = 1 to _nLen_
			_acResult_ + This.HexUnicodeOfCharN(@i)
		next

		return _acResult_


		#< @FunctionFluentForms

		def HexUnicodesQ()
			return This.HexUnicodesQRT(:stzList)

		def HexUnicodesQRT(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.HexUnicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.HexUnicodes() )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	def HexUnicode()
		if This.NumberOfChars() = 1
			return This.HexUnicodeOfCharN(1)

		else
			return This.HexUnicodes()
		ok

	def CharsAndHexUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.HexUnicodeOfCharN(i) ]
		next

		return aResult

		def CharsAndTheirHexUnicodes()
			return This.CharsAndHexUnicodes()

		def HexUnicodesPerChar()
			return This.CharsAndHexUnicodes()

	def HexUnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.HexUnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		def HexUnicodesAndTheirChars()
			return This.HexUnicodesAndChars()

		def HexUnicodesXT()
			return This.HexUnicodesAndChars()

	
		def CharsPerHexUnicode()
			return This.HexUnicodesAndChars()

	def HexUnicodeOfCharN(n)
		cResult = StzCharQ(This.Char(n)).HexUnicode()
		return cResult

		#< @FunctionAlternativeForms

		def HexUnicodeOfNthChar(n)
			return This.HexUnicodeOfCharN(n)

		def NthCharHexUnicode(n)
			return This.HexUnicodeOfCharN(n)

		#>

	  #-------------------------------------#
	 #   GETTING CHARS NAME (IN UNICODE)   #
	#-------------------------------------#

	def CharsNames()

		acChars = This.Chars()
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			acResult + StzCharQ(acChars[i]).Name()
		next

		return acResult

		#< @FunctionFleuntForms

		def CharNamesQ()
			return This.CharNamesQRT(:stzList)

		def CharNamesQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.CharNames())

			on :stzListOfStrings
				return new stzListOfString(This.CharNames())

			else
				stzRaise("Unsupported return type!")
			off

		#>

	  #--------------------------------------------------#
	 #  GETTING THE NAME OF THE STRING IF IT IS A CHAR  #
	#--------------------------------------------------#
	# If the string contains more then 1 char, only the first is processed

	def CharName()
		if NOT This.IsEmpty()
			return This.CharsNames()[1]
		ok

		def CharNameQ()
			return new stzString(This.CharName())


	  #-----------------------------------#
	 #  REMOVING DOTS ON DOTTED LETTERS  #
	#-----------------------------------#

	def RemoveDots()
		#TODO // Needs a better data stracture to deal with some special cases

		acChars = This.Chars()
		anLettersPos = This.FindLetters()
		nLen = len(anLettersPos)

		for i = 1 to nLen
			n = anLettersPos[i]

			cDotless = DotlessLettersXT()[ acChars[n] ]

			if cDotless != ""
				This.ReplaceNthChar(n, cDotless)
			ok
		next

		#< @FunctionFluentForm

		def RemoveDotsQ()
			This.RemoveDots()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDotsOnLetters()
			This.RemoveDots()

			def RemoveDotsOnLettersQ()
				This.RemoveDotsQ()

		#>

	def DotsRemoved()
		cResult = This.Copy().RemoveDotsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def DotsOnLettersRemoved()
			return This.DotsRemoved()

		def WithoutDots()
			return This.DotsRemoved()

		def WithoutDotsOnLetters()
			return This.DotsRemoved()

		def Dotless()
			return This.DotsRemoved()

		#>

	  #===============================#
	 #    MULTINGUAL & LOCLAE INFO   #
	#===============================#

	/*
	In Softanza, a unicode code of a language, country or locale can be:
		* number : like "6" for arabic
		* name : like "arabic" for arabic
		* abbreviation : like "ar" (short form) and "ara" (long form) for arabic
	*/

	def IsLanguageIdentifier()
		return 	This.IsLanguageNumber() or
			This.IsLanguageAbbreviation() or
			This.IsLanguageName()

	def IsLanguageNumber()
		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if aLanguageInfo[1] = This.String()
				bResult = 1
				exit
			ok
		next
	
		return bResult

		def IsLanguageCode()
			return This.IsLanguageNumber()

	def IsShortLanguageAbbreviation()
		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsLongLanguageAbbreviation()
		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsLanguageAbbreviation()
		/* Could be written expressively like this:

		return This.IsLanguageShotAbbreviation() OR This.IsLanguageLongAbbreviation()

		but the following is mutch more efficient: */

		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()

			if lower(aLanguageInfo[3]) = lower(This.String()) OR
			   lower(aLanguageInfo[4]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsLanguageShortAbbreviation()
		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsLanguageLongAbbreviation()
		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def LanguageAbbreviationForm()

		if NOT This.IsLanguageAbbreviation()
			cForm = :NotLanguage
		
		else

			if This.IsLanguageShortAbbreviation()
				cForm = :Short

			but This.IsLanguageLongAbbreviation()
				cForm = :Long
			ok
		ok

		return cForm

	def IsLanguageName() # In english

		if This.IsEmpty() { return 0 }

		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[2]) = lower(This.String())
				bResult = 1
				exit
			ok
		next
	
		return bResult

		def IsNotLanguageName()
			return NOT This.IsLanguageName()

	def IsLanguageNameOrAbbreviation()
		if This.IsLanguageName() or This.IsLanguageAbbreviation()
			return 1
		else
			return 0
		ok

		def IsLanguageAbbreviationOrNames()
			return This.IsLanguageNameOrAbbreviation()

	def IsNativeLanguageName() # Locale-specific
		if This.IsEmpty() { return 0 }

		stzRaise(stzStringError(:UnsupportedFeatureInThisVersion)) #TODO

	def IsCountryIdentifier()
		return 	This.IsCountryNumber() or
			This.IsCountryAbbreviation() or
			This.IsCountryName() or
			This.IsCountryPhoneCode()

	def IsCountryAbbreviation()
		if This.IsEmpty() { return 0 }

		cAbbr = This.String()
		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr) OR
			   UPPER(aCountryInfo[4]) = UPPER(cAbbr)

				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsCountryName()
		if This.IsEmpty() { return 0 }

		cName = This.String()
		bResult = 0
		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[2]) = lower(cName)
				bResult = 1
				exit
			ok
		next

		return bResult

		def IsNotCountryName()
			return NOT This.IsCountryName()

	def IsNativeCountryName() # Locale-specific
		if This.IsEmpty() { return 0 }

		stzRaise(stzString(:UnsupportedFeatureInThisVersion))

	def IsCountryPhoneCode()
		if This.IsEmpty() { return 0 }

		cPhoneCode = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if aCountryInfo[5] = cPhoneCode
				bResult = 1
				exit
			ok
		next

		return bResult

	def IsCountryNumber()
		if This.IsEmpty() { return 0 }

		cNumber = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[1]) = lower(cNumber)
				bResult = 1
				exit
			ok
		next

		return bResult

		def IsCountryCode()
			return This.IsCountryNumber()

	def IsShortCountryAbbreviation()
		if This.IsEmpty() { return 0 }

		cAbbr = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr)

				bResult = 1
				exit
			ok
		next
	
		return bResult

		def IsCountryShortAbbreviation()
			return This.IsShortCountryAbbreviation()

	def IsLongCountryAbbreviation()
		if This.IsEmpty() { return 0 }

		cAbbr = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[4]) = UPPER(cAbbr)
				bResult = 1
				exit
			ok
		next
	
		return bResult

		def IsCountryLongAbbreviation()
			return This.IsLongCouontryAbbreviation()

	def IsCountryAbbreviationXT()
		/*
		Returns :
		[ 1, :Short ] or [ :TRUE, :Long ] or [ 0, "" ]
		*/

		if This.IsEmpty() { return 0 }

		bAbbr = This.IsCountryAbbreviation()
		ctype = :Nothing

		if This.IsShortCountryAbbreviation()
			cType = :Short
		but This.IsLongCountryAbbreviation()
			cType = :Long
		ok

		return [ bAbbr, cType ]
	
	def IsScriptIdentifier()
		return 	This.IsScriptNumber() or
			This.IsScriptAbbreviation() or
			This.IsScriptName()

	# Script abbreviation can't be short or long, it is always 4 chars long!
	def IsScriptAbbreviation()
		if This.IsEmpty() { return 0 }

		cAbbr = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[3]) = lower(cAbbr)
				bResult = 1
				exit
			ok
		next
	
		return bResult

	def IsScriptName()
		if This.IsEmpty() { return 0 }

		cScript = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[2]) = lower(cScript)
				bResult = 1
				exit
			ok
		next

		return bResult

		def IsScript()
			return This.IsScriptName()

		def IsNotScriptName()
			return NOT This.IsScriptName()

	def IsScriptNumber()
		if This.IsEmpty() { return 0 }

		cScript = This.String()
		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[1]) = lower(cScript)
				bResult = 1
				exit
			ok
		next

		return bResult

		def IsScriptCode()
			return This.IsScriptNumber()

	def IsLocaleAbbreviation()
		cThisString = ", " + This.Copy().ReplaceQ("_", "-").Content() + ","
		oLocalesInString = StzStringQ( ", " + LocaleAbbreviationsHostedInString() + "," )
		bResult = oLocalesInString.ContainsCS( cThisString, 0 )

		return bResult
	
	def ContainsLocaleSeparator()
		return This.Contains("_") or This.Contains("-")

	def ExtractLocaleSeparator()

		if This.ContainsLocaleSeparator()
			if This.Contains("_")
				return "_"

			but This.Contains("-")
				return "-"
			ok
		ok

	def ContainsNoLocaleSeparator()
		return NOT This.ContainsLocaleSeparator()

	def ContainsOneLocaleSeparator()
		return This.ContainsNTimes(1, "_") or
			This.ContainsNTimes(1, "_")

	def IsLocaleSeparator()
		return This.Content() = "_" or This.Content() = "-"

	def IsCurrencyName()
		if This.IsEmpty() { return 0 }

		bResult = 0

		#TODO // Replace for/in with for --> better performance
		for aCurrencyInfo in CurrenciesXT()
			if lower(aCurrencyInfo[1]) = This.Lowercased()
				bResult = 1
				exit
			ok
		next

		return bResult	

	def IsCurrencySymbol()	#TODO
		if This.IsEmpty() { return 0 }
		
	def IsBp64LocaleAbbreviation() # Like "ar-TN" for example
		if This.IsEmpty() { return 0 }

		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsDayName() # In english

		return This.IsDayNameIn(:English)

	def IsDayNameIn(pcLanguageName)
		if This.IsEmpty() { return 0 }

		return This.LowercaseQ().IsOnOfThese(NamesOfDaysIn(pcLanguageName))

	def IsNativeDayNameInLocale(pLocale) # Locale-specific
		if This.IsEmpty() { return 0 }

		return This.IsEqualToCS(StzLocaleQ(pLocale).NativeDayName(), 0)

	def IsMonthName() # In english
		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsNativeMonthName() # Locale-specific
		stzRaise(:UnsupportedFeatureInThisVersion)

	  #========================#
	 #    NUMBER IN STRING    #
	#========================#

	def NumberForm()
		if NOT This.RepresentsNumber()
			return :NotNumber

		else
 			if This.RepresentsNumberInDecimalForm()
				return :Decimal

		   	but This.RepresentsNumberInBinaryForm()
				return :Binary

		   	but This.RepresentsNumberInOctalForm()
				return :Octal

		   	but This.RepresentsNumberInHexForm()
				return :Hex

			but This.RepresentsNumberInScientificNotation()
				return :ScientificNotation
			ok
		ok

	def RepresentsDigit()
		bResult = 0

		if This.IsANumberInString()

			n = 0+ This.Content()
			if 0 <= n and n <= 9
				bResult = 1
			ok

		ok

		return bResult

		#< @FunctionAlternativeForms

		def RepresentsADigit()
			return This.RepresentsDigit()

		def IsDigit()
			return This.RepresentsDigit()

		def IsADigit()
			return This.RepresentsDigit()

		def IsDigitInString()
			return This.RepresentsDigit()

		def IsADigitInString()
			return This.RepresentsDigit()

		#>

	def RepresentsNumberOrListInString()
		if This.RepresentsNumberInString() or
		   This.RepresentsListInString()

			return 1
		else
			return 0
		ok

		#< @FunctionAlaternativeForms

		def RepresentsListOrNumberInString()
			return This.RepresentsNumberOrListInString()

		def IsNumberOrListInString()
			return This.RepresentsNumberOrListInString()

		def IsStringOrNumberInString()
			return This.RepresentsNumberOrListInString()

		#>

	def RepresentsNumber()

		oCopy = This.Copy()
		oCopy.RemoveSpaces()

		if oCopy.RepresentsNumberInDecimalForm() or
		   oCopy.RepresentsNumberInBinaryForm() or
		   oCopy.RepresentsNumberInOctalForm() or
		   oCopy.RepresentsNumberInHexForm() //or
		   //oCopy.RepresentsNumberInScientificNotation()
			
			return 1

		else

			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumber()
			return This.RepresentsNumber()

		def RepresentsNumberInString()
			return This.RepresentsNumber()

		def RepresentsANumberInString()
			return This.RepresentsNumber()

		def IsNumberInString()
			return This.RepresentsNumber()

		def IsANumberInString()
			return This.RepresentsNumber()

		#==

		def RepresentsReal()
			return This.RepresentsNumber()

		def RepresentsAReal()
			return This.RepresentsNumber()

		def RepresentsRealInString()
			return This.RepresentsNumber()

		def RepresentsARealInString()
			return This.RepresentsNumber()

		def IsRealInString()
			return This.RepresentsNumber()

		def IsARealInString()
			return This.RepresentsNumber()

		#--

		def RepresentsRealNumber()
			return This.RepresentsNumber()

		def RepresentsARealNumber()
			return This.RepresentsNumber()

		def RepresentsRealNumberInString()
			return This.RepresentsNumber()

		def RepresentsARealNumberInString()
			return This.RepresentsNumber()

		def IsRealNumberInString()
			return This.RepresentsNumber()

		def IsARealNumberInString()
			return This.RepresentsNumber()

		#>

	def RepresentsSignedNumber()
		if This.RepresentsNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedNumber()
			return This.RepresentsSignedNumber()

		def IsSignedNumber()
			return This.RepresentsSignedNumber()

		def IsASignedNumber()
			return This.RepresentsSignedNumber()

		def IsSignedNumberInString()
			return This.RepresentsSignedNumber()

		def IsASignedNumberInString()
			return This.RepresentsSignedNumber()

		#>

	def RepresentsUnsignedNumber()
		if This.RepresentsNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()	

		def IsUnsignedNumber()
			return This.RepresentsUnsignedNumber()

		def IsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()

		def IsUnsignedNumberInString()
			return This.RepresentsUnsignedNumber()

		def IsAnUnsignedNumberInString()
			return This.RepresentsUnsignedNumber()

		#>

	def RepresentsCalculableNumber() 

		if This.RepresentsCalculableInteger() or
		   This.RepresentsCalculableRealNumber()

			return 1

		else
			return 0
		ok
				 
		/* INFO
		Non calculable numbers are: 
		-  other numbers in Uniocde, like circled number icons,
		   roman and indian numbers and others

		- numbers in any form (decimal, binary, octal, hex, scientific)
		  that can not be calculated "precisily" with Ring, as defined by
		  MinCalculableNumber() and MaxCalculableNumber()
		*/

		#< @FunctionAlternativeForms

		def RepresentsACalculableNumber() 
			return This.RepresentsCalculableNumber()

		def IsCalculableNumber()
			return This.RepresentsCalculableNumber()

		def IsACalculableNumber()
			return This.RepresentsCalculableNumber()

		def IsCalculableNumberInString()
			return This.RepresentsCalculableNumber()

		def IsACalculableNumberInString()
			return This.RepresentsCalculableNumber()

		#>

	def RepresentsInteger()

		if This.RepresentsNumber() and This.ContainsNo(".")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnInteger()
			return This.RepresentsInteger()

		def IsInteger()
			return This.RepresentsInteger()

		def IsAnInteger()
			return This.RepresentsInteger()

		def IsIntegerInString()
			return This.RepresentsInteger()

		def IsAnIntegerInString()
			return This.RepresentsInteger()

		#>

	def RepresentsSignedInteger()
		if This.RepresentsInteger() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedInteger()
			return This.RepresentsSignedInteger()

		def IsSignedInteger()
			return This.RepresentsSignedInteger()

		def IsASignedInteger()
			return This.RepresentsSignedInteger()

		def IsSignedIntegerInString()
			return This.RepresentsSignedInteger()

		def IsASignedIntegerInString()
			return This.RepresentsSignedInteger()

		#>

	def RepresentsUnsignedInteger()
		if This.RepresentsInteger() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsUnsignedIntegerInString()
			return This.RepresentsUnsignedInteger()

		def IsAnUnsignedIntegerInString()
			return This.RepresentsUnsignedInteger()

		#>

	def RepresentsCalculableInteger()

		if This.representsInteger()

			# Step 1: we define the number of digits of
			# the integer and the maximum number of digits
			# allowed by Ring for integers
			
			if This.RepresentsSignedInteger()

				nNumberOfDigits = This.NumberOfChars() - 1
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedInteger()

			else

				nNumberOfDigits = This.NumberOfChars()
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedInteger()
			ok

			# Step 2: we compare between them to kwow if this
			# integer is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return 1
			else
				return 0
			ok

		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsACalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsCalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsACalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsCalculableIntegerInString()
			return This.RepresentsCalculableInteger()

		def IsACalculableIntegerInString()
			return This.RepresentsCalculableInteger()

		#>

	def RepresentsSignedRealNumber()
		if This.RepresentsRealNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsSignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsSignedRealNumberInString()
			return This.RepresentsSignedRealNumber()		

		def IsASignedRealNumberInString()
			return This.RepresentsSignedRealNumber()		

		#>

	def RepresentsUnsignedRealNumber()
		if This.RepresentsRealNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsUnsignedRealNumberInString()
			return This.RepresentsUnsignedRealNumber()		

		def IsAnUnsignedRealNumberInString()
			return This.RepresentsUnsignedRealNumber()		

		#>

	def RepresentsCalculableRealNumber()
		
		if This.RepresentsRealNumber()

			# Step1: We split the string to get integer and
			# decimal parts and calculate the number of
			# digits in the real number

			cIntegerPart = This.Split(".")[1]
			nNumberOfDigitsIncIntegerPart = len(cIntegerPart)

		 	if ring_left(cIntegerPart, 1) = "+" or
			   ring_left(cIntegerPart, 1) = "-"
				nNumberOfDigitsIncIntegerPart--
			ok

			cFractionalPart = This.Split(".")[2]
			nNumberInDigitsInFractionalPart = len(cFractionalPart)

			nNumberOfDigits = nNumberOfDigitsIncIntegerPart +
					  nNumberInDigitsInFractionalPart

			# Step 2: We compute the maximum number of digits allowed
			# depending on the real number being singed or unsigned

			nMaxNumberOfDigits = 0
			if This.RepresentsSignedRealNumber()
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedRealNumber()
			else
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedRealNumber()
			ok

			# Step 3: we compare between them to kwow if this real
			# number is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return 1
			else
				return 0
			ok

		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsCalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsCalculableRealNumberInString()
			return This.RepresentsCalculableRealNumber()

		def IsACalculableRealNumberInString()
			return This.RepresentsCalculableRealNumber()

		#>

	def RepresentsNumberInDecimalForm()

		# Rule 1: String shouldn't be null

		if This.Content() = ""
			return 0
		ok

		# Rule 2: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" or
		    This.Content() = " ")

			return 0
		ok

		# Rule 3: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return 0
		ok

		# Rule 4: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return 0
		ok

		# Rule 5: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return 0
		ok

		# Rule 6: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return 0
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		acPossibleChars = "0":"9" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)
		
		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return 0
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return 1

		#< @FunctionAlternativeForms

		def RepresentsANumberInDecimalForm()
			return This.RepresentsNumberInDecimalForm()

		def IsDecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def IsADecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def IsDecimalNumberInString()
			return This.RepresentsNumberInDecimalForm()

		def IsADecimalNumberInString()
			return This.RepresentsNumberInDecimalForm()

		#--

		def RepresentsDecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def RepresentsADecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		#>

	// Checks if the string corresponds to a binary number started by the
	// prefix defined in BinaryNumberPrefix() and composed of 0s and 1s

	def RepresentsNumberInBinaryForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return 0
		ok

		# Rule 2: String must contains 0s or 1s

		if This.ContainsNo("0") and This.ContainsNo("1")
			return 0
		ok

		# Rule 3: String should be prefixed with a binary prefix

		bTemp = 0

		#TODO // Replace for/in with for --> better performance

		acBinPref = BinaryPrefixes()
		nLen = len(acBinPref)

		for i = 1 to nLen
			cBinPrefix = acBinPref[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cBinPrefix, 0)
				bTemp = 1
				exit
			ok
		next
		if bTemp = 0
			return 0
		ok

		# Rule 4: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_")

			return 0
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return 0
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return 0
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return 0
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return 0
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		acPossibleChars = "0":"1" + "b" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return 0
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return 1

		#< @FunctionAlternativeForms

		def RepresentsANumberInBinaryForm()
			return This.RepresentsNumberInBinaryForm()

		def IsBinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		def IsABinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		def IsBinaryNumberInString()
			return This.RepresentsNumberInBinaryForm()

		def IsABinaryNumberInString()
			return This.RepresentsNumberInBinaryForm()

		#--

		def RepresentsBinayNumber()
			return This.RepresentsNumberInBinaryForm()

		def RepresentsABinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		#>

	// Checks if the string corresponds to a hex number form
	def RepresentsNumberInHexForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return 0
		ok

		# Rule 2: String must not contain just a hex prefix

		if This.IsEqualToOneOfTheseCS(HexPrefixes(),  0)
			return 0
		ok

		# Rule 3: String should be prefixed with a hex prefix

		bTemp = 0

		acHexPrefixes = HexPrefixes()
		nLen = len(acHexPrefixes)

		for i = 1 to nLen
			cHexPrefix = acHexPrefixes[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeft("-")
			oCopy.RemoveFromLeft("+")

			if oCopy.StartsWithCS(cHexPrefix, 0)
				bTemp = 1
				exit
			ok
		next
		if bTemp = 0
			return 0
		ok

		# Rule 4: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return 0
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return 0
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return 0
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return 0
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return 0
		ok

		# Now, let's check that chars correspond to digits, signs or separators

		acPossibleChars = HexChars() + "x" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return 0
			ok

		next

		# At this level, we can be sure the string is a hex number

		return 1

		#< @FunctionAlternativeForms

		def RepresentsANumberInHexForm()
			return This.RepresentsNumberInHexForm()

		def IsHexNumber()
			return This.RepresentsNumberInHexForm()

		def IsAHexNumber()
			return This.RepresentsNumberInHexForm()

		def IsHexNumberInString()
			return This.RepresentsNumberInHexForm()

		def IsAHexNumberInString()
			return This.RepresentsNumberInHexForm()

		#--

		def RepresentsHexNumber()
			return This.RepresentsNumberInHexForm()

		def RepresentsAHexNumber()
			return This.RepresentsNumberInHexForm()

		#>

	def RepresentsNumberInUnicodeHexForm()

		nLen = This.NumberOfChars()
		if NOT nLen > 2
			return 0
		ok

		if NOT This.SectionQ(1, 2).Uppercased() = "U+"
			return 0
		ok
	
		cNumber = This.Section(3, nLen)
	
		if StzStringQ( HexPrefix() + cNumber ).RepresentsNumberInHexForm()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumberInUnicodeHexForm()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsAHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsHexUnicodeInString()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsAHexUnicodeInString()
			return This.RepresentsNumberInUnicodeHexForm()

		#--

		def RepresentsHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def RepresentsAHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		#>

	// Checks if the string corresponds to an octal number
	def RepresentsNumberInOctalForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return 0
		ok

		# Rule 2: String must not contain only an octal prefix

		if This.IsEqualToOneOfTheseCS(OctalPrefixes(),  0)
			return 0
		ok

		# Rule 4: String should be prefixed with an octal prefix

		bTemp = 0

		acOctalPrefixes = OctalPrefixes()
		nLen = len(acOctalPrefixes)

		for i = 1 to nLen
			cOctalPrefix = acOctalPrefixes[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cOctalPrefix, 0)
				bTemp = 1
				exit
			ok
		next
		if bTemp = 0
			return 0
		ok

		# Rule 5: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return 0
		ok

		# Rule 6: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return 0
		ok

		# Rule 7: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return 0
		ok

		# Rule 8: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return 0
		ok

		# Rule 9: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return 0
		ok

		# Now, let's check that the chars correspond to digits, signs or separators

		acPossibleChars = OctalChars() + "o" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return 0
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return 1

		#< @FunctionAlternativeForms

		def RepresentsANumberInUnicodeOctalForm()
			return This.RepresentsNumberInOctalForm()

		def IsOctalUnicode()
			return This.RepresentsNumberInOctalForm()

		def IsAnOctalUnicode()
			return This.RepresentsNumberInOctalForm()

		def IsOctalUnicodeInString()
			return This.RepresentsNumberInOctalForm()

		def IsAnOctalUnicodeInString()
			return This.RepresentsNumberInOctalForm()

		#--

		def RepresentsOctalNumber()
			return This.RepresentsNumberInOctalForm()

		def RepresentsAnOctalNumber()
			return This.RepresentsNumberInOctalForm()


		#>

	def RepresentsNumberInScientificNotation()
		// TODO
		StzRaise("Unsupported feature yet!")

		#< @FunctionAlternativeForms

		def RepresentsANumberInScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsAScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificNotationInString()
			return This.RepresentsNumberInScientificNotation()

		def IsAnScientificNotationInString()
			return This.RepresentsNumberInScientificNotation()

		#--

		def RepresentsScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsAScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		#==

		def RepresentsNumberInScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsANumberInScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsAScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificFormInString()
			return This.RepresentsNumberInScientificNotation()

		def IsAnScientificFormInString()
			return This.RepresentsNumberInScientificNotation()

		#--

		def RepresentsScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsAScientificForm()
			return This.RepresentsNumberInScientificNotation()

		#>

	  #==============#
	 #    CHARS     #
	#==============#

	def ToStzChar()
		c = This.FirstChar()
		return new stzChar(c)

	def CharsCS(pCaseSensitive)
		bCaseSensitive = CaseSensitive(pCaseSensitive)

		_oQCopy_ = QStringObject()
		nLen = _oQCopy_.size()
		acResult = []

		if bCaseSensitive = 1
			for i = 1 to nLen
				acResult + _oQCopy_.mid(i-1, 1)
			next

		else
			for i = 1 to nLen
				c = lower( _oQCopy_.mid(i-1, 1) )
				if ring_find(acResult, c) = 0
					acResult + c
				ok
			next

		ok

		return acResult

		#< @FunctionFluentForms

		def CharsCSQ(pCaseSensitive)
			return This.CharsCSQRT(pCaseSensitive, :stzList)

		def CharsCSQRT(pCaseSensitive, pcReturnType)
			if CheckingParams()

				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

			ok

			switch pcReturnType

			on :stzList
				return new stzList( This.CharsCS(pCaseSensitive) )

			on :StzListOfChars
				return new stzListOfChars( This.CharsCS(pCaseSensitive) )

			on :StzListOfStrings
				return new stzListOfStrings( This.CharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def Chars()
		return This.CharsCS(1)

		#< @FunctionFluentForm

		def CharsQ()
			return new stzList(This.Chars())

		def CharsQRT(pcReturnType)
			return This.CharsCSQRT(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def ToListOfChars()
			return This.Chars()

			def ToListOfCharsQ()
				return This.ToListOfCharsQRT(:stzList)

			def ToListOfCharsQRT(pcReturnType)
				return This.CharsQRT(pcReturnType)
	
		#>

	  #------------------------------------------------#
	 #  GETTING THE LIST OF CHARS IN A GIVEN SECTION  #
	#------------------------------------------------#

	def CharsInSectionCS(n1, n2, pCaseSensitive)
		acResult = This.SectionCSQ(n1, n2, pCaseSensitive).Chars()
		return acResult

		#< @FunctionFluentForms

		def CharsInSectionCSQ(n1, n2, pCaseSensitive)
			return This.CharsInSectionCSQRT(n1, n2, pCaseSensitive, :stzList)

		def CharsInSectionCSQRT(n1, n2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SectionCharsCS(n1, n2, pCaseSensitive)
			return this.CharsInSectionCS(n1, n2, pCaseSensitive)

			def SectionCharsCSQ(n1, n2, pCaseSensitive)
				return This.CharsInSectionCSQ(n1, n2, pCaseSensitive)

			def SectionCharsCSQRT(n1, n2, pCaseSensitive, pcReturnType)
				return This.CharsInSectionCSQRT(n1, n2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsInSection(n1, n2)
		return This.CharsInSectionCS(n1, n2, 1)

		#< @FunctionFluentForms

		def CharsInSectionQ(n1, n2)
			return This.CharsInSectionCSQRT(n1, n2, :stzList)

		def CharsInSectionQRT(n1, n2, pcReturnType)
			return This.CharsInSectionQRT(n1, n2, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SectionChars(n1, n2)
			return this.CharsInSection(n1, n2)

			def SectionCharsQ(n1, n2)
				return This.CharsInSectionQ(n1, n2)

			def SectionCharsQRT(n1, n2, pcReturnType)
				return This.CharsInSectionQRT(n1, n2, pcReturnType)

		#>

	  #---------------------------------------------------------------------#
	 #  TRANSFORMING THE CHARS OF THE STRING TO A LIST OF stzChar OBJECTS  #
	#---------------------------------------------------------------------#

	def ToListOfStzChars()
		acChars = This.Chars()
		nLen = len(acChars)

		aResult = []

		for i = 1 to nLen
			#WARNing: Note that using 'for in' yields erronous
			# result for strings coded on more then 1 byte

			aResult + new stzChar(acChars[i])
		next

		return aResult

		#< @FunctionFluentForm

		def ToListOfStzCharsQ()
			return new stzList( This.ToListOfStzChars() )

		#>

	  #-------------------------------------------------------------------#
	 #  TRANSFORMING THE CHARS OF THE STRING TO A stzListOfChars OBJECT  #
	#-------------------------------------------------------------------#

	def ToStzListOfChars()
		return new stzListOfChars(This.Chars())

	  #=====================================================#
	 #  CHECKING IF THE STRING IS THE NAME OF A FUNCTION   #
	#=====================================================#
	/*
	TODO: Distinguish between Ring, Softanza, Qt, and other
	libraries functions, classes, and attributes.
	*/

	def IsAFunction()
		if ring_find( functions(), This.Lowercased() ) > 0
			return 1
		else
			return 0
		ok
 
		def IsAFunctionName()
			return This.IsAFunction()

		def IsFunction()
			return This.IsAFunction()

		def IsFunctionName()
			return This.IsAFunction()

		#--

		def IsFunc()
			return This.IsAFunction()

		def IsFunctName()
			return This.IsAFunction()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A CLASS   #
	#--------------------------------------------------#

	def IsAClass()
		if ring_find( classes(), This.Lowercased() ) > 0
			return 1
		else
			return 0
		ok

		def IsAClassName()
			return This.IsAClass()

		def IsClass()
			return This.IsAClass()

		def IsClassName()
			return This.IsAClass()

	  #------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF AN ATTRIBUTE  #
	#------------------------------------------------------#

	def IsAnAttributeOfClass(pcClass)
		acTheseAttributes = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Attributes )
		bResult = This.ExistsInCS( acTheseAttributes,  0 )
		return bResult

		def IsAnAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOfClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A METHOD  #
	#--------------------------------------------------#

	def IsAMethodOfClass(pcClass)
		acTheseMethods = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Methods )
		bResult = This.ExistsInCS( acTheseMethods,  0 )
		return bResult

		def IsAMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOfClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

	  #========================================#
	 #      CHECKING IF ALL CHARS ARE ...     #
	#========================================#

	def AllCharsAreNumbers()
		# EarlyCheck

		if This.IsEmpty() or NOT This.ContainsNumbers()
			return 0
		ok

		# Doing the job

		bResult = 0

		try
			if isNumber( 0+ This.Content() )
				bResult = 1
			ok
		catch
			// Do nothing
		done

		return bResult

		def IsMadeOfNumbers()
			return This.AllCharsAreNumbers()

	def AllCharsAre(pDescriptor)
		/* EXAMPLE

		? Q("248").AllCharsAre([ :Even, :Positive, :Numbers ])
		#--> TRUE

		? Q("248").AllCharsAre([ :Even, W('Q(@char).IsANumber()'), :Numbers ])
		#--> TRUE

		? Q(",:;").AllCharsAre(:Punctuations)

		*/

		if isString(pDescriptor)
			return This.AllCharsAreXT([ pDescriptor ], :EvalDirection = :Nothing)

		but isList(pDescriptor) and StzListQ(pDescriptor).IsListOfStrings()
			return This.AllCharsAreXT(pDescriptor, :EvalDirection = :Nothing)

		ok	

	def AllCharsAreXT(pacDescriptors, paEvalDirection)

		if NOT ( isList(pacDescriptors) and @IsListOfStrings(pacDescriptors) )
			stzRaise("Incorrect param type! pacDescriptors must be a list of strings.")
		ok

		oDesc = Q(pacDescriptors)
		oEvalDir = Q(paEvalDirection)

		if isList(paEvalDirection) and
		   oEvalDir.IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if ring_find([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], paEvalDirection) > 0

			stzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if paEvalDirection = :Default Or paEvalDirection = :Nothing
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		acDescriptors = pacDescriptors
		if oEvalDir.IsOneOfTheseCS([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			],  0)

			acDescriptors = oDesc.Reversed()
		ok

		if len(acDescriptors) = 1

			if acDescriptors[1] = :Number or acDescriptors[1] = :Numbers
				cMethod = :IsANumber

			but acDescriptors[1] = :String or acDescriptors[1] = :Strings
				cMethod = :IsAString

			but acDescriptors[1] = :List or acDescriptors[1] = :Lists
				Method = :IsAList

			but acDescriptors[1] = :Object or acDescriptors[1] = :Objects
				cMethod = :IsAnObject

			but Q(acDescriptors[1]).FirstChar() = "{" and
			    Q(acDescriptors[1]).LastChar() = "}"

				bResult = This.Check( :That = acDescriptors[1] )
				return bResult
			
			else

				cMethod = Q(acDescriptors[1]).InfereMethod(:From = :stzChar)

			ok

			#TODO // Replace the fellowing with Check() when reincluded

			oaStzChars = This.ToListOfStzChars()
			nLen = len(oaStzChars)

			cCode = 'bOk = oaStzChars[i].' + cMethod + '()'

			bResult = 1

			for i = 1 to nLen
				eval(cCode)
				if NOT bOk
					bResult = 0
					exit
				ok
			next

			return bResult

		else

			cType = Q(acDescriptors[1]).InfereType()
			if Q(cType).StartsWithCS("stz",  0)
				cType = Q(cType).FirstNCharsRemoved(3)
			ok

			bResult = 1
	
			for i = 2 to len(acDescriptors)

 				if Q(acDescriptors[i]).FirstChar() = "{" and
			   	   Q(acDescriptors[i]).LastChar() = "}"

					bOk = This.Check( :That = acDescriptors[i] )
				
				else

					cMethod = Q(acDescriptors[i]).InfereMethod( :From = 'stz' + cType )
					bOk = This.Check( :That = 'Stz' + cType + 'Q(@item).' + cMethod + "()" )
				ok

				if bOk = 0
					bResult = 0
					exit
				ok
			next
		ok

		return bResult

	  #========================================#
	 #   CHARS VERIFYING A GIVEN CONDITION    #
	#========================================#
	
	def CharsWCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.CharsAtPositions(anPos)

		return acResult

		#< @FunctionAlternativeForms

		def CharsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def AllCharsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def AllCharsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def OnlyWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def ItemsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsW(pcCondition)
		return This.CharsWCS(pcCondition, 1)

		#< @FunctionAlternativeForms

		def CharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsW(pcCondition)
			return This.CharsW(pcCondition)

		def OnlyW(pcCondition)
			return This.CharsW(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsW(pcCondition)
			return This.CharsW(pcCondition)

		def ItemsWhere(pcCondition)
			return This.CharsW(pcCondition)

		#>

	  #---------------------------------------------#
	 #   CHARS VERIFYING A GIVEN CONDITION -- WXT  #
	#---------------------------------------------#
	
	def CharsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.CharsAtPositions(anPos)

		return acResult

		#< @FunctionAlternativeForms

		def CharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def AllCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def AllCharsWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def OnlyWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def ItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsWXT(pcCondition)
		return This.CharsWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForms

		def CharsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def AllCharsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def AllCharsWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def OnlyWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def ItemsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		#>

	  #-------------------------------------------------#
	 #   NUMBER OF CHARS VERIFYING A GIVEN CONDITION   #
	#=================================================#

	def NumberOfCharsWCS(pcCondition, pCaseSensitive)
		return len( This.CharsWCS(pcCondition, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def CountCharsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def CountCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def NumberOfItemsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCharsW(pcCondition)
		return This.NumberOfCharsWCS(pcCondition, 1)

		#< @FunctionAlternativeForms

		def NumberOfCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def NumberOfItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		#>

	  #------------------------------------------------------#
	 #   NUMBER OF CHARS VERIFYING A GIVEN CONDITION -- XT  #
	#------------------------------------------------------#

	def NumberOfCharsWCSXT(pcCondition, pCaseSensitive)
		return len( This.CharsWCSXT(pcCondition, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def CountCharsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def CountCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def NumberOfItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCharsWXT(pcCondition)
		return This.NumberOfCharsWCSXT(pcCondition, 1)

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def CountCharsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def CountCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def NumberOfItemsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		#>

	  #=======================#
	 #   STRING IS A CHAR?   #
	#=======================#

	def IsChar()
		if This.NumberOfChars() = 1
			return 1
		else
				
			return 0
		ok

		def IsAChar()
			return This.IsChar()

	def IsNullOrChar()
		return isNull(This.Content()) or This.IsChar()

		def IsCharOrNull()
			return This.IsNullOrChar()

		def IsEmptyOrChar()
			return This.IsNullOrChar()

		def IsCharOrEmpty()
			return This.IsNullOrChar()

	def IsAsciiChar()
		if This.Unicode() <= 255
			return 1
		else
			return 0
		ok

		if oCopy.IsEmpty()
			return 1
		else
			return 0
		ok

		def IsAnAsciiChar()
			return This.IsAsciiChar()

	def IsCharName()
		return StzUnicodeDataQ().ContainsCharName( This.Uppercased() )

		def IsACharName()
			return This.IsCharName()

	  #---------------------------#
	 #   STRING MADE OF CHARS?   #
	#---------------------------#

	def IsMadeOfCharCS(c, pCaseSensitive)
		if isString(c) and  @IsChar(c)
			return This.IsMadeOfCS([ c ], pCaseSensitive)
		else
			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfChar(c)
		return This.IsMadeOfCharCS(c, 1)

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF SOME OF THE GIVEN SUBSTRINGS  #
	#------------------------------------------------------------------#

	def IsMadeOfSomeCS(acSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT (isList(acSubStr) and @IsListOfStrings(acSubStr))
				StzRaise("Incorrect param type! acSubStr must be a list of strings.")
			ok
		ok

		oCopy = This.Copy()
		nLen = len(acSubStr)


		for i = 1 to nLen
			if This.ContainsCS(acSubStr[i], pCaseSensitive)
				oCopy.RemoveAll(acSubStr[i])
			ok
		next

		if oCopy.IsEmpty()
			return 1
		else
			return 0
		ok

		return 0

		#< @FunctionAlternativeForms

		def IsMadeOfSomeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfSomeCS(acSubStr, pCaseSensitive)

		def IsMadeOfSomeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfSomeCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfSome(acSubStr)
		return This.IsMadeOfSomeCS(acSubStr, 1)

		#< @FunctionAlternativeForms

		def IsMadeOfSomeOfThese(acSubStr)
			return This.IsMadeOfSome(acSubStr)

		def IsMadeOfSomeOfTheseSubstrings(acSubStr)
			return This.IsMadeOfSome(acSubStr)

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF SOME OF THE GIVEN CHARS  #
	#-------------------------------------------------------------#

	def IsMadeOfSomeOfTheseCharsCS(acChars, pCaseSensitive)
		if CheckingParams()
			if NOT (isList(acChars) and @IsListOfChars(acChars))
				StzRaise("Incorrect param type! acChars must be a list of chars.")
			ok
		ok

		return This.IsMadeOfSomeCS(acChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def IsMadeOfSomeOfTheseChars(acChars)
		return This.IsMadeOfSomeOfTheseCharsCS(acChars, 1)

	  #-------------------------------------------------#
	 #   STRING IS A CHAR IN A COMPUTABLE FORM ("c")   #
	#-------------------------------------------------#

	def IsCharInComputableForm()
		if This.IsChar() and This.IsInComputableForm()
			return 1
		else
			return 0
		ok

	def IsAsciiCharInString()
		if This.NumberOfChars() = 3 and
		   (This.IsBoundedBy("'", "'") or
		   This.IsBoundedBy('"', '"'))
			return StzStringQ(This.Char(2)).IsAsciiChar()
		else
			return 0
		ok

	  #----------------------------#
	 #   NUMBER OF UNIQUE CHARS   #
	#----------------------------#

	def NumberOfCharsCSU(pCaseSensitive)
		nResult = len( This.CharsCSU(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfUniqueCharsCS(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		def HowManyCharsCSU(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		def HowManyUniqueCharsCS(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		#>

	#--

	def NumberOfCharsU()
		return This.NumberOfCharsCSU(1)

		#< @FunctionAlternativeForms

		def NumberOfUniqueChars()
			return This.NumberOfCharsU()

		def HowManyCharsU()
			return This.NumberOfCharsU()

		def HowManyUniqueChars()
			return This.NumberOfCharsU()

		#>

	  #------------------------------#
	 #   UNIQUE CHARS IN THE LIST   #
	#------------------------------#

	def UniqueCharsCS(pCaseSensitive)

		acChars = This.CharsCS(pCaseSensitive)
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			c = acChars[i]
			if ring_find(acResult, c) = 0
				acrEsult + c
			ok
		next

		return acResult

		#< @FunctionFluentForms

		def UniqueCharsCSQ(pCaseSensitive)
			return This.UniqueCharsCSQRT(pCaseSensitive, :stzList)

		def UniqueCharsCSQRT(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueCharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionALternativeForm

		def ToSetOfCharsCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)
	
			def ToSetOfCharsCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)
	
			def ToSetOfCharsCSQRT(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQRT(pCaseSensitive, pcReturnType)
	
		def CharsCSU(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsCSUQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsCSUQRT(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQRT(pCaseSensitive, pcReturnType)

		def CharsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicationCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicationCSQRT(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQRT(pCaseSensitive, pcReturnType)

		def CharsWithoutDuplicatesCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicatesCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicatesCSQRT(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQRT(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UniqueChars()
		return This.UniqueCharsCS(1)

		#< @FunctionFluentForms

		def UniqueCharsQ()
			return This.UniqueCharsCSQRT(TRUE, :stzList)

		def UniqueCharsQRT(pcReturnTyp)
			return This.UniqueCharsCSQRT(TRUE, pcReturnType)

		#>

		#< @FunctionALternativeForm

		def ToSetOfChars()
			return This.UniqueChars()
	
			def ToSetOfCharsQ()
				return This.UniqueCharsQ()
	
			def ToSetOfCharsQRT(pcReturnType)
				return This.UniqueCharsQRT(pcReturnType)
	
		def CharsU()
			return This.UniqueChars()

			def CharsUQ()
				return This.UniqueCharsQ()

			def CharsUQRT(pcReturnType)
				return This.UniqueCharsQRT(pcReturnType)

		def CharsWithoutDuplication()
			return This.UniqueChars()

			def CharsWithoutDuplicationQ()
				return This.UniqueCharsQ()

			def CharsWithoutDuplicationQRT(pcReturnType)
				return This.UniqueCharsQRT(pcReturnType)

		def CharsWithoutDuplicates()
			return This.UniqueChars()

			def CharsWithoutDuplicatesQ()
				return This.UniqueCharsQ()

			def CharsWithoutDuplicatesQRT(pcReturnType)
				return This.UniqueCharsQRT(pcReturnType)

		#>

	  #-----------------------------#
	 #  REMOVING DUPLICATED CHARS  #
	#-----------------------------#

	def RemoveDuplicatedCharsCS(pCaseSensitive)
		cNewString = This.UniqueCharsCSQRT(pCaseSensitive, :stzListOfStrings).Concatenated()
		This.Update(cNewString)

		def RemoveDuplicatedCharsCSQ(pCaseSensitive)
			This.RemoveDuplicatedCharsCS(pCaseSensitive)
			return This
	
	def DuplicatedCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatedCharsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatedChars()
		This.RemoveDuplicatedCharsCS(1)

		def RemoveDuplicatedCharsQ()
			This.RemoveDuplicatedChars()
			return This
	
	def DuplicatedCharsRemoved()
		cResult = This.Copy().RemoveDuplicatedCharsQ().Content()
		return cResult

	  #---------------------------------------#
	 #   GETTING CHAR AT A GIVEN POSITION    #
	#---------------------------------------#
	
	def NthChar(n)
		#< QtBased | Uses QString.mid() >

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		_oQCopy_ = QStringObject()
		nLen = _oQCopy_.size()
		cResult = _oQCopy_.mid(n-1, 1)
		return cResult

		#< @FunctionFluentForm
		
		def NthCharQ(n)
			return new stzString(This.NthChar(n))

		def NthCharQRT(n, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NthChar(n) )
			on :stzChar
				return new stzChar( This.NthChar(n) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
		#< @FunctionAlternativeForms

		def CharAt(n)
			return This.NthChar(n)

			def CharAtQRT(n, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.NthCharQRT(n, pcReturnType)
	
			def CharAtQ(n)
				return This.CharAtQRT(n, :stzString)

		def CharAtPosition(n)
			return This.NthChar(n)

			def CharAtPositionQRT(n, pcReturnType)
				return This.CharAtQRT(n, pcReturnType)

			def CharAtPositionQ(n)
				return This.CharAtPositionQRT(n, :stzString)

		def CharN(n)
			return This.NthChar(n)

			def CharNQRT(n, pcReturnType)
				return CharAtQRT(n, pcReturnType)
	
			def CharNQ(n)
				return This.CharAtQRT(n, :stzString)

		def Char(n)
			return This.NthChar(n)

			def CharQRT(n, pcReturnType)
				return CharAtQRT(n, pcReturnType)
	
			def CharQ(n)
				return This.CharAtQRT(n, :stzString)

		#>

	  #-------------------------------------------------#
	 #   NTH CHAR TO THE LAST (OR TO THE FIRST) CHAR   #
	#-------------------------------------------------#

	def NthToLast(n)
		return This.CharAtPosition( This.NumberOfChars() - n )

	def NthToFirst(n)
		return This.CharAtPosition(n + 1)

	  #--------------------------------#
	 #   CHARS AT A GIVEN POSITIONS   #
	#--------------------------------#
	
	def CharsAtPositions(panPos)
		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		acResult = []

		#TODO // Replace for/in with for --> better performance
		for n in panPos
			acResult + This.CharAt(n)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsAtPositionsQ(panPosirtions)
			return This.CharsAtPositionsQRT(panPos, :stzList)

		def CharsAtPositionsQRT(panPos, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.CharsAtPositionsQRT(panPos, pcReturnType) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsAtPositionsQRT(panPos, pcReturnType) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsAtPositionsQRT(panPos, pcReturnType) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def CharsAtThesePositions(panPos)
			return This.CharsAtPositions(panPos)

			def CharsAtThesePositionsQ(panPos)
				return This.CharsAtQRT(panPos, :stzList)

			def CharsAtThesePositionsQRT(panPos, pcReturnType)
				return This.CharsAtPositionsQRT(panPos, pcReturnType)

		def CharsAt(panPos)
			return This.CharsAtPositions(panPos)

			def CharsAtQ(panPos)
				return This.CharsAtQRT(panPos, :stzList)

			def CharsAtQRT(panPos, pcReturnType)
				return This.CharsAtPositionsQRT(panPos, pcReturnType)

		#>

	  #---------------------------#
	 #   FIRST AND LAST CHARS    #
	#---------------------------#

	def FirstChar()
 		return This.QStringObject().mid(0, 1)

		#< @FunctionFluentForm

		def FirstCharQ()
			return This.FirstCharQRT(:stzString)

		def FirstCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.FirstChar() )
			on :stzChar
				return new stzChar( This.FirstChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def SecondChar()
		return This.Char(2)

		def SecondCharQ()
			return This.SecondCharQRT(:stzString)

		def SecondCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNameSpace()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and StringQ(pcReturnType).IsAStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcreturnType
			on :stzString
				return new stzString( This.SecondChar() )

			on :stzChar
				return new stzChar( This.SecondChar() )

			other
				StzRaise("Unsupported return type!")
			off

	def LastChar()
		nLen = This.NumberOfChars()
		cResult = This.QStringObject().mid(nLen - 1, 1)
		return cResult

		#< @FunctionFluentForm

		def LastCharQ()
			return This.LastCharQRT(:stzString)

		def LastCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LastChar() )
			on :stzChar
				return new stzChar( This.LastChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForms

		def الحرف_الأخير()
			return This.LastChar()

			def oالحرف_الأخير()
				return This.LastChar()
	
		def DernierCaractère()
			return This.LastChar()


		def 字符数()
			return This.LastChar()

		#>

	  #---------------------------#
	 #   LEFT AND RIGHT CHARS    #
	#---------------------------#
		
	def LeftChar()
		if This.IsLeftToRight()
			return This.FirstChar()
		else
			return This.LastChar()
		ok

		#< @FunctionFluentForm

		def LeftCharQ()
			return This.LeftCharQRT(:stzString)

		def LeftCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LeftChar() )
			on :stzChar
				return new stzChar( This.LeftChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def RightChar()
		if This.IsLeftToRight()
			return This.LastChar()
		else
			return This.FirstChar()
		ok

		#< @FunctionFluentForm

		def RightCharQ()
			return This.RightCharQRT(:stzString)

		def RightCharQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.RightChar() )
			on :stzChar
				return new stzChar( This.RightChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

	  #-----------------------#
	 #   NUMBER OF CHARS     #
	#-----------------------#

	#TODO
	# Reimplement these functions using QTextBoundaryFinder
	# https://doc.qt.io/qt-5/qtextboundaryfinder.html#details

	def NumberOfCharsCS(pCaseSensitive)
		#< QtBased | Uses QString.size() >

		# Resolving pCaseSensitive

		_bCase_ = @CaseSensitive(pCaseSensitive)

		# Doing the job

		if _bCase_ = 1

			return This.QStringObject().size()
		else
			return len( This.UniqueChars() )
		ok

		#< @FunctionFluentForm

		def NumberOfCharsCSQ(pCaseSensitive)
			return new stzNumber(This.NumberOfCharsCS(pCaseSensitive))

		#>

		#< @FunctionBooleanForm

		def NumberOfcharsCSB(pCaseSensitive)
			if This.NumberOfCharsCS(pCaseSensitive) = LastValue()
				return 1
			else
				return 0
			ok

			def NumberOfCharCSBQ(pCaseSensitive)
				if This.NumberOfcharsCSB(pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def SizeCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def SizeCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def SizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def SizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def SizeInCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def SizeInCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def SizeInCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def NumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def NumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def NumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def NumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def LengthCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def LengthCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def LengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#-- Used in natural-coding

		def ANumberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ANumberOfCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ANumberOfCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ANumberOfCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ASizeCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ASizeCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ASizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ASizeInCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ASizeInCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ASizeInCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ANumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ANumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ANumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ANumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ALengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ALengthCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ALengthCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ALengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#--

		def CountCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def CountCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def CountCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def CountCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def HowManyCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def HowManyCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def HowManyCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyCharCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def HowManyCharCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def HowManyCharCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def HowManyCharCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NuberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#--

		def LenghtCS(pCaseSensitive)
			return This.Length(pCaseSensitive)

		def LenghtCSQ(pCaseSensitive)
			return This.NumberOfItemsCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfChars()
		return This.NumberOfCharsCS(1)

		#< @FunctionFluentForm

		def NumberOfCharsQ()
			return new stzNumber(This.NumberOfChars())

		#>

		#< @FunctionBooleanForm

		def NumberOfcharsB()
			if This.NumberOfChars() = LastValue()
				return 1
			else
				return 0
			ok

			def NumberOfCharBQ()
				if This.NumberOfcharsB()
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfChars()

			def SizeQ()
				return This.NumberOfCharsQ()

			def SizeB()
				return This.NumberOfCharsB()

			def SizeBQ()
				return This.NumberOfCharBQ()

		def SizeInChars()
			return This.NumberOfChars()

			def SizeInCharsQ()
				return This.NumberOfCharsQ()

			def SizeInCharsB()
				return This.NumberOfCharsB()

			def SizeInCharsBQ()
				return This.NumberOfCharBQ()

		def NumberOfItems()
			return This.NumberOfChars()

			def NumberOfItemsQ()
				return This.NumberOfCharsQ()

			def NumberOfItemsB()
				return This.NumberOfCharsB()

			def NumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def Length()
			return This.NumberOfChars()

			def LengthQ()
				return This.NumberOfCharsQ()

				def LengthQV()
					SetLastValue(This.Length())
					return This.LengthQ()

			def LengthB()
				return This.NumberOfCharsB()

			def LengthBQ()
				return This.NumberOfCharBQ()

				def LengthBQV()
					SetLastValue(This.Length())
					return This.LengthBQ()

		#-- Used in natural-coding

		def ANumberOfChars()
			return This.NumberOfChars()

			def ANumberOfCharsQ()
				return This.NumberOfCharsQ()

			def ANumberOfCharsB()
				return This.NumberOfCharsB()

			def ANumberOfCharsBQ()
				return This.NumberOfCharBQ()

		def ASize()
			return This.NumberOfChars()

			def ASizeQ()
				return This.NumberOfCharsQ()

			def ASizeB()
				return This.NumberOfCharsB()

			def ASizeBQ()
				return This.NumberOfCharBQ()

		def ASizeInChars()
			return This.NumberOfChars()

			def ASizeInCharsQ()
				return This.NumberOfCharsQ()

			def ASizeInCharsB()
				return This.NumberOfCharsB()

			def ASizeInCharsBQ()
				return This.NumberOfCharBQ()

		def ANumberOfItems()
			return This.NumberOfChars()

			def ANumberOfItemsQ()
				return This.NumberOfCharsQ()

			def ANumberOfItemsB()
				return This.NumberOfCharsB()

			def ANumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def ALength()
			return This.NumberOfChars()

			def ALengthQ()
				return This.NumberOfCharsQ()

			def ALengthB()
				return This.NumberOfCharsB()

			def ALengthBQ()
				return This.NumberOfCharBQ()

		#--

		def CountChars()
			return This.NumberOfChars()

			def CountCharsQ()
				return This.NumberOfCharsQ()

			def CountCharsB()
				return This.NumberOfCharsB()

			def CountCharsBQ()
				return This.NumberOfCharBQ()

		def HowManyChars()
			return This.NumberOfChars()

			def HowManyCharsQ()
				return This.NumberOfCharsQ()

			def HowManyCharsB()
				return This.NumberOfCharsB()

			def HowManyCharsBQ()
				return This.NumberOfCharBQ()

		def HowManyChar()
			return This.NumberOfChars()

			def HowManyCharQ()
				return This.NumberOfCharsQ()

			def HowManyCharB()
				return This.NumberOfCharsB()

			def HowManyCharBQ()
				return This.NumberOfCharBQ()

		#>

		#< @FunctionMisspelledForm

		def NuberOfChars()
			return This.NumberOfChars()

		#--

		def Lenght()
			return This.Length()

		def LenghtQ()
			return This.NumberOfItemsQ()

		#>

	  #-----------------------#
	 #   NUMBER OF LETTERS   #
	#-----------------------#

	def NumberOfLetters()
		return len(This.OnlyLetters())
	
		#< @FunctionFluentForm

		def NumberOfLettersQ()
			return new stzNumber(This.NumberOfLetters())

		#>

		#< @FunctionBooleanForm

		def NumberOfLettersB()
			if This.NumberOfLetters() = LastValue()
				return 1
			else
				return 0
			ok

		def NumberOfLettersBQ()
			if This.NumberOfLettersB() = 1
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def CountLetters()
			return This.NumberOfLetters()

			def CountLettersQ()
				This.NumberOfLettersQ()

			def CountLettersB()
				return This.NumberOfLettersB()

			def CountLettersBQ()
				return This.NumberOfLettersBQ()

		def HowManyLetters()
			return This.NumberOfLetters()

			def HowManyLettersQ()
				This.NumberOfLettersQ()

			def HowManyLettersB()
				return This.NumberOfLettersB()

			def HowManyLettersBQ()
				return This.NumberOfLettersBQ()

		def HowManyLetter()
			return This.NumberOfLetters()

			def HowManyLetterQ()
				This.NumberOfLettersQ()

			def HowManyLetterB()
				return This.NumberOfLettersB()

			def HowManyLetterBQ()
				return This.NumberOfLettersBQ()

		#>

	  #-----------------------#
	 #   NUMBER OF SPACES    #
	#-----------------------#

	def NumberOfSpaces()
		return len(This.FindAll(" "))

		#< @FunctionAlternativeForms

		def CountSpaces()
			return This.NumberOfSpaces()

		def HowManySpaces()
			return This.NumberOfSpaces()

		def HowManySpace()
			return This.NumberOfSpaces()

		#>

	  #---------------------------------------#
	 #   ِCHEKING IF THE STRING IS A LETTER   #
	#---------------------------------------#

	def IsLetter()
		if This.IsChar() and StzCharQ(This.Content()).IsLetter()
			return 1
		else
			return 0
		ok
		
		#< @FunctionAlternativeForms

		def IsALetter()
			return This.IsLetter()

		def ContainsJustALetter()
			return This.IsLetter()

		def ContainsOnlyALetter()
			return This.IsLetter()

		#>

		#< @FunctionNegativeForm

		def IsNotLetter()
			return NOT This.IsLetter()

		def IsNotALetter()
			return NOT This.IsLetter()

		#>

	  #----------------------------------------------------------#
	 #   ِCHEKING IF THE STRING IS A LETTER OF AN OTHER STRING   #
	#----------------------------------------------------------#

	def IsLetterOf(pcOtherStr)
		if This.IsLetter() and StzStringQ(pcOtherStr).ContainsLetter(This.Content())
			return 1
		else
			return 0
		ok

		def IsALetterOf(pcOtherStr)
			return This.IsLetterOf(pcOtherStr)

	  #-----------------------------------------------#
	 #   ِGETTING THE LIST OF LETTERS IN THE STRING   #
	#-----------------------------------------------#

	def FindLetters()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)
		anResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				anResult + i
			ok
		next

		return anResult

		def FindLettersZ()
			return This.FindLetters()

	def Letters()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)
		aResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				aResult + aoChars[i].Content()
			ok
		next

		return aResult

		def LettersQ()
			return This.LettersQRT(:stzList)

		def LettersQRT(pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.Letters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Letters() )

			on :stzListOfChars
				return new stzListOfChars( This.Letters() )
			off

		def LettersN()
			nResult = This.NumberOfLetters()
			return nResult

			def LettersNQ()
				return new stzNumber(This.LettersN())

		def LettersNB() # Used for natural-coding and chains of truth
			if This.NumberOfLetters() = LastValue()
				return 1
			else
				return 0
			ok

			def LettersNBQ()
				if This.LettersNB() = 1
					return This
				else
					return AFalseObject()
				ok

	def LettersZ()
		aResult = []
		aoChars = This.CharsQ().ToListOfStzStrings()
		nLen = len(acChars)
		anResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				anResult + [ aoChars[i].Content(), i ]
			ok
		next

		return aResult

		def LettersAndTheirPositions()

	  #----------------------------------------------------------------------#
	 #   ِGETTING THE LIST OF LETTERS IN THE STRING  -- WITHOUT DUPLICATION  #
	#----------------------------------------------------------------------#

	def UniqueLetters()
		acResult = This.LettersQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForms

		def UniqueLettersQ()
			return This.UniqueLettersQRT(:stzList)

		def UniqueLettersQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueLetters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueLetters() )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueLetters() )
			off

		#>

		#< @FunctionAlternativeForms

		def LettersU()
			return This.UniqueLetters()

			def LettersUQ()
				return This.LettersUQRT(:stzList)

			def LettersUQRT(pcReturnType)
				return This.UniqueLettersQRT(pcReturnType)
	
		def LettersWithoutDuplication()
			return This.UniqueLetters()

			def LettersWithoutDuplicationQ()
				return This.LettersWithoutDuplicationQRT(:stzList)

			def LettersWithoutDuplicationQRT(pcReturnType)
				return This.UniqueLettersQRT(pcReturnType)
		#

	  #----------------------------------------------------------------------#
	 #    CHECKING IF THE STRING IS IN A COMPUTABLE FORM ("str" or 'str')   #
	#----------------------------------------------------------------------#

	def IsInComputableForm()
		if This.NumberOfChars() > 2 and
		   (This.IsBoundedBy("'", "'") or
		    This.IsBoundedBy('"', '"'))

			return 1
		else
			return 0
		ok
	
		def IsWellFormed()
			return This.IsInComputableForm()

	  #------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN SUBSTRINGS   #
	#------------------------------------------------------------#

	def IsMadeOfCS(acSubStr, pCaseSensitive)

		if CheckingParams()

			if NOT (isList(acSubStr) or isString(acSubStr))
				StzRaise("Incorrect param type! acSubStr must be a list or a string.")
			ok

			if isString(acSubStr)
				acTemp = [] + acSubStr
				acSubStr = acTemp
			ok

			if isList(acSubStr)
				nLen = len(acSubStr)
				if nLen > 0
					if isList(acSubStr[nLen]) and len(acSubStr[nLen]) = 2 and
					   isString(acSubStr[nLen][1]) and acSubStr[nLen][1] = :And

						_tempVal_ = acSubStr[nLen][2]
						acSubStr[nLen] = _tempVal_
					ok
				ok

			ok

			IF NOT @IsListOfStrings(acsubStr)
				StzRaise("Incorrect param type! acSubStr must be a list of strings.")
			ok

		ok

		_oCopy_ = This.Copy()
		nLen = len(acSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(acSubStr[i], pCaseSensitive)
				return 0
			ok

			_oCopy_.RemoveAllCS(acSubStr[i], pCaseSensitive)
		next

		if _oCopy_.IsEmpty()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		def IsMadeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		def IsMadeOfManyCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOf(acSubStr)
		return This.IsMadeOfCS(acSubStr, 1)

		#< @FunctionAlternativeForms

		def IsMadeOfThese(acSubStr)
			return This.IsMadeOf(acSubStr)

		def IsMadeOfTheseSubstrings(acSubStr)
			return This.IsMadeOf(acSubStr)

		def IsMadeOfMany(acSubStr)
			return This.IsMadeOf(acSubStr)

		#>

	  #-------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN CHARS   #
	#-------------------------------------------------------#

	def IsMadeOfTheseCharsCS(acChars, pCaseSensitive)
		if @IsListOfChars(acChars)
			return This.IsMadeOfCS(acChars, pCaseSensitive)
		else
			stzRaise("You must provide a list of chars!")
		ok

		def ContainsOnlyTheseCharsCS(acChars, pCaseSensitive)
			return This.IsMadeOfTheseCharsCS(acChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfTheseChars(acChars)
		return This.IsMadeOfTheseCharsCS(acChars, 1)

		def ContainsOnlyTheseChars(acChars, pCaseSensitive)
			return This.IsMadeOfTheseChars(acChars)

	#TODO
	# Add ContainsOnly...() alternative to all IsMadeOf...() functions and vice versa

	  #-----------------#
	 #   MULTIPLY BY   #	TODO: reclassify it with other calculations
	#-----------------#

	def Multiply(pValue)
		if isList(pValue) and StzListQ(pValue).IsByNamedParam()
			pValue = pValue[2]
		ok

		This.MultiplyBy(pValue)

		def MultiplyQ(pValue)
			This.Multiply(pValue)
			return This

	def Multiplied(pValue)
		cResult = This.Copy().MultiplyQ(pValue).Content()
		return cResult

	  #--------------------------------------#
	 #  POLYVALENT MULTIPLICATION FUNCTION  #
	#--------------------------------------#

	def MultiplyBy(pValue)
		_cResult_ = ""

		if ring_type(pValue) = "NUMBER"
			_cResult_ = This.RepeatedNTimes(pValue)
		
		but ring_type(pValue) = "STRING"

			if pValue = ""
				return ""
			ok

			_cResult_ = ""
			_cTemp_ = ""
			_nLen_ = this.NumberOfChars()

			for @i = 1 to _nLen_
				_cTemp_ = This.QStringObject().mid(@i-1,1) + pValue
				_cResult_ += _cTemp_
			next
		
		but ring_type(pValue) = "LIST"

			_nLenValue_ = len(pValue)
			_nLen_ = This.NumberOfChars()

			_cResult_ = ""
			_cTemp_ = ""
				
			for @i = 1 to nLen
				
				for @v = 1 to _nLenValue_
					_cTemp_ = This.QStringObject().mid(i-1,1) + pValue[@v]
					_cResult_ += _cTemp _
				next
										
				_cResult_ += " "

			next

			_cResult_ = StzStringQ(_cResult_).RemovedFromEnd(" ")
		ok

		This.UpdateWith( _cResult_ )

		#< @FunctionFluentForm

		def MultiplyByQ(pValue)
			This.MultiplyBy(pValue)
			return This

		#>

	def MultipliedBy(pValue)
		cResult = This.Copy().MultiplyByQ(pValue).Content()
		return cResult

	  #-----------------------------------------#
	 #  MULTIPLYING NUMBERS INSIDE THE STRING  #
	#=========================================#

	def MultiplyByN(n)

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = len(acNumbers)

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) * n )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def MultiplyByNQ(n)
			This.MultiplyByN(n)
			return This
		#>

	def MultipliedByN(n)
		cResult = This.Copy().MultiplyByNQ(n).Content()
		return cResult

	#-- Multiplying each number by a different number

	def MultiplyByNXT(anNumbers)

		if CheckParams()
			if NOT ( isList(anNumbers) and IsListOfNumbers(anNumbers) )
				StzRaise("Incorrect param type! anNumbers must be a list of numbers.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = @Min([ len(acNumbers), len(anNumbers) ])

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) * anNumbers[i] )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def MultiplyByNXTQ(n)
			This.MultiplyByNXT(n)
			return This
		#>

	def MultipliedByNXT(n)
		cResult = This.Copy().MultiplyByNXTQ(n).Content()
		return cResult

	  #--------------------------------------#
	 #  DIVIDING NUMBERS INSIDE THE STRING  #
	#--------------------------------------#

	def DivideByN(n)

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = len(acNumbers)

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) / n )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def DivideByNQ(n)
			This.DivideByN(n)
			return This
		#>

	#-- Dividing each number by a different number

	def DivideByNXT(anNumbers)

		if CheckParams()
			if NOT ( isList(anNumbers) and IsListOfNumbers(anNumbers) )
				StzRaise("Incorrect param type! anNumbers must be a list of numbers.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = @Min([ len(acNumbers), len(anNumbers) ])

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) / anNumbers[i] )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def DivideByNXTQ(n)
			This.DivideByNXT(n)
			return This
		#>

	def DividedByNXT(n)
		cResult = This.Copy().DivideByNXTQ(n).Content()
		return cResult

	  #-------------------------------------#
	 #  SUMMING NUMBERS INSIDE THE STRING  #
	#-------------------------------------#

	def AddN(n)

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acNumbers = This.Numbers()

		acMultiplied = []
		nLen = len(acNumbers)

		for i = 1 to nLen
			acMultiplied + @string( @number(acNumbers[i]) + n )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acMultiplied)

		#< @FunctionFluentForm

		def AddNQ(n)
			This.AddN(n)
			return This
		#>

	#-- Summing each number with a different number

	def AddNXT(anNumbers)

		if CheckParams()
			if NOT ( isList(anNumbers) and IsListOfNumbers(anNumbers) )
				StzRaise("Incorrect param type! anNumbers must be a list of numbers.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = @Min([ len(acNumbers), len(anNumbers) ])

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) + anNumbers[i] )
		next

		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def AddNXTQ(n)
			This.AddNXT(n)
			return This
		#>

	def AddedNXT(n)
		cResult = This.Copy().AddNXTQ(n).Content()
		return cResult

	  #----------------------------------------#
	 #  RETRIEVING NUMBERS INSIDE THE STRING  #
	#----------------------------------------#

	def RetrieveN(n)

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acNumbers = This.Numbers()

		acMultiplied = []
		nLen = len(acNumbers)

		for i = 1 to nLen
			acMultiplied + @string( @number(acNumbers[i]) - n )
		next


		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acMultiplied)

		#< @FunctionFluentForm

		def RetrieveNQ(n)
			This.RetrieveN(n)
			return This
		#>

	#-- Retrieving each number from a different number

	def RetrieveNXT(anNumbers)

		if CheckParams()
			if NOT ( isList(anNumbers) and IsListOfNumbers(anNumbers) )
				StzRaise("Incorrect param type! anNumbers must be a list of numbers.")
			ok
		ok

		acNumbers = This.Numbers()

		acCaluclated = []
		nLen = @Min([ len(acNumbers), len(anNumbers) ])

		for i = 1 to nLen
			acCaluclated + @string( @number(acNumbers[i]) - anNumbers[i] )
		next

		aSections = This.FindNumbersZZ()

		This.ReplaceSectionsByMany(aSections, acCaluclated)

		#< @FunctionFluentForm

		def RetrieveNXTQ(n)
			This.RetrieveNXT(n)
			return This
		#>

	def RetrievedNXT(n)
		cResult = This.Copy().RetrieveNXTQ(n).Content()
		return cResult

	  #========================================#
	 #     BOXING THE STRING AND ITS CHARS    #
	#========================================#

	def Box() # Undersatnd it as a verb action on the string (boxing the string)

		This.BoxXT([])

		#< @FunctionFluentForm

		def BoxQ()
			This.Box()
			return This
		#>

		#< @FunctionAlternativeForm

		def Boxify()
			This.Box()

			def BoxifyQ()
				return This.BoxQ()

		#>

	def Boxed()
		return This.Copy().BoxQ().Content()

		def Boxified()
			return This.Boxed()

	#--

	def BoxDash()
		This.BoxXT([ :Line = :Dashed, :AllCorners = :Rectangular ])

		#< @FunctionFluentForm

		def BoxDashQ()
			This.BoxDash()
			return This
		#>

		#< @FunctionFluentForm

		def BoxifyDash()
			This.BoxDash()

			def BoxifyDashQ()
				return This.BoxDashQ()

		def BoxDashed()
			This.BoxDash()

			def BoxDashedQ()
				return This.BoxDashQ()

		#>

	def BoxedDashed()
		return This.Copy().BoxDashQ().Content()

		def BoxifiedDashed()
			return This.BoxedDashed()

	#--

	def BoxRound()
		This.BoxXT([ :Line = :Solid, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundQ()
			This.BoxRound()
			return This
		#>

		def BoxifyRound()
			This.BoxRound()

			def BoxifyRoundQ()
				return This.BoxRoundQ()


	def BoxedRounded()
		return This.Copy().BoxRoundQ().Content()

		def BoxifiedRounded()
			return This.BoxedRounded()

	def BoxedRound()
		return This.Copy().BoxRoundQ().Content()

		def BoxifiedRound()
			return This.BoxedRounded()

	#--

	def BoxRoundDash()
		This.BoxXT([ :Line = :Dashed, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundDashQ()
			This.BoxRoundDash()
			return This

		#>

		#< @FunctionAlternativeForms

		def BoxDashRound()
			This.BoxRoundDash()

			def BoxDashRoundQ()
				return This.BoxRoundDashQ()

		#--

		def BoxifyRoundDash()
			This.BoxRoundDash()

			def BoxifyRoundDashQ()
				return This.BoxRoundDashQ()

		def BoxifyDashRound()
			This.BoxRoundDash()

			def BoxifyDashRoundQ()
				return This.BoxRoundDashQ()

		#>

	def BoxedRoundedDashed()
		return This.Copy().BoxRoundDashQ().Content()

		def BoxededDashedRound()
			return This.BoxedRoundedDashed()

		def BoxifiedDashedRounded()
			return This.BoxedRoundedDashed()

		def BoxifiedRoundedDashed()
			return This.BoxedRoundedDashed()

		def BoxedDashedRounded()
			return This.BoxedRoundedDashed()


	#--

	def BoxEachChar()

		This.BoxXT([ :Line = :Solid, :EachChar = 1 ])

		#< @FunctionFluentForm

		def BoxEachCharQ()
			This.BoxEachChar()
			return This

		#>

		#< @FunctionAlternativeForm

		def BoxChars()
			This.BoxEachChar()

			def BoxCharQ()
				return This.BoxEachCharQ()

		#--

		def BoxifyEachChar()
			This.BoxEachChar()

			def BoxifyEachCharQ()
				return This.BoxEachCharQ()

		def BoxifyChars()
			This.BoxEachChar()

			def BoxifyCharQ()
				return This.BoxEachCharQ()

		#>

	def EachCharBoxed()
		return This.Copy().BoxEachCharQ().Content()

		def CharsBoxed()
			return This.EachCharBoxed()

		def EachCharBoxified()
			return This.EachCharBoxed()

		def CharsBoxified()
			return This.EachCharBoxed()

	#--

	def BoxRoundEachChar()
		This.BoxXT( [ :AllCorners = :Round, :EachChar = 1 ])

		#< @FunctionFluentForm

		def BoxRoundEachCharQ()
			This.BoxRoundEachChar()
			return This

		#>

		#< @FunctionAlternativeForms

		def BoxRoundChars()
			This.BoxRoundEachChar()

			def BoxRoundCharsQ()
				return This.BoxRoundEachCharQ()

		def BoxEachCharRound()
			This.BoxRoundEachChar()

			def BoxEachCharRoundQ()
				return This.BoxRoundEachCharQ()

		#--

		def BoxifyRoundEachChar()
			This.BoxRoundEachChar()

			def BoxifyRoundEachCharQ()
				return This.BoxRoundEachCharQ()

		def BoxifyRoundChars()
			This.BoxRoundEachChar()

			def BoxifyRoundCharsQ()
				return This.BoxRoundEachCharQ()

		#>

	def EachCharBoxedRounded()
		return This.Copy().BoxRoundEachCharQ().Content()

		def EachCharBoxifiedRounded()
			return This.EachCharBoxedRounded()

		def EachCharBoxRounded()
			return This.EachCharBoxedRounded()

		def CharsBoxedRounded()
			return This.EachCharBoxedRounded()

		def CharsBoxifiedRounded()
			return This.EachCharBoxedRounded()

	#--

	def BoxEachCharXT(paBoxOptions)
		cResult = This.ToStzListOfChars().BoxedXT(paBoxOptions)
		This.Update(cResult)


		#< @FunctionFluentForm

		def BoxEachCharXTQ(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoxCharsXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxCharsXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)

		#--

		def BoxifyEachCharXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxifyEachCharXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)

		def BoxifyCharsXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxifyCharsXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)
	
		#>

	def EachCharBoxedXT(paBoxOptions)
		return This.Copy().BoxEachCharXTQ(paBoxOptions).Content()

		def CharsBoxedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

		def EachCharBoxifiedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

		def CharsBoxifiedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

	#--

def BoxXT(paBoxOptions)
	/*
	Enhanced version that supports nested boxing with corrected line widths,
	proper initialization of cTextAdjustedTo, and fixed :Rounded option handling
	to ensure [ :Rounded = 1 ] produces rounded corners as in the original.

	Examples:
	- Box("SOFTANZA") creates a simple box
	- Box(Box("SOFTANZA")) creates a box around an already boxed string
	- Box(Box(Box("SOFTANZA"))) creates triple-nested boxes
	- BoxXT("SOFTANZA", [ :Rounded = 1 ]) creates a rounded box
	*/

	# Normalize input if a single string option is provided
	if isString(paBoxOptions)
		paBoxOptions = [ [ paBoxOptions, 1 ] ]
	ok

	if isList(paBoxOptions) and len(paBoxOptions) = 2 and isString(paBoxOptions[1])
		paBoxOptions = [ paBoxOptions ]
	ok

	if NOT isList(paBoxOptions)
		StzRaise("Incorrect param type! paBoxOptions must be a list.")
	ok

	# Convert string options to hashlist format
	aTemp = []
	nLenTemp = len(paBoxOptions)
	for i = 1 to nLenTemp
		if isString(paBoxOptions[i])
			aTemp + [ paBoxOptions[i], 1 ]
		else
			aTemp + paBoxOptions[i]
		ok
	next
	paBoxOptions = aTemp

	# Validate options
	if StzListQ(paBoxOptions).IsTextBoxedOptionsNamedParam()

		# Reading the type of line (thin or dashed)
		cLine = :Solid # By default
		if paBoxOptions[:Line] = :Dashed
			cLine = :Dashed
		ok

		# Reading if the box is rounded
		bRounded = "" # By default
		if isNumber(paBoxOptions[:Rounded])
			if paBoxOptions[:Rounded] = 1
				bRounded = 1
			but paBoxOptions[:Rounded] = 0
				bRounded = 0
			ok
		ok

		# Reading the type of corners (rectangular or round)
		cAllCorners = :Rectangular # By default
		if paBoxOptions[:AllCorners] = :Round or
		   paBoxOptions[:AllCorners] = :Rounded

			if isString(bRounded) and bRounded = ""
				bRounded = 1
			ok
			cAllCorners = :Round
		ok

		aCorners = []
		if cAllCorners = :Rectangular or cAllCorners = :Rect
			if isString(bRounded) and bRounded = ""
				bRounded = 0
			ok
			# By default
			aCorners = [ :Rectangular, :Rectangular, :Rectangular, :Rectangular ]

		but cAllCorners = :Round or cAllCorners = :Rounded
			if isString(bRounded) and bRounded = ""
				bRounded = 1
			ok
			aCorners = [ :Round, :Round, :Round, :Round ]
		ok

		if len(paBoxOptions[:Corners]) = 4 and
		   StzListQ(paBoxOptions[:Corners]).IsMadeOfSome([ :Rectangular, :Round ])

			if isString(bRounded) and bRounded = ""
				bRounded = 1
			ok
			aCorners = paBoxOptions[:Corners]
		ok

		if len(aCorners) = 0 and bRounded = ""
			if isString(bRounded) and bRounded = ""
				bRounded = 0
			ok
		ok

		if bRounded = 1 and ring_find(aCorners, :Round) = 0
			aCorners = [ :Round, :Round, :Round, :Round ]
		ok

		# If the boxing happens at the char level, delegate it
		# to the stzListOfChars class

		if paBoxOptions[:EachChar] = 1
			cResult = This.ToStzListOfChars().BoxedXT(paBoxOptions)
			This.UpdateWith(cResult)
			return
		ok

		# If the boxing happens at the word level, delegate it
		# to the stzListOfStrings class

		if paBoxOptions[:EachWord] = 1
			cResult = This.ToListOfStringsQ().Boxed(paBoxOptions)
			This.UpdateWith(cResult)
			return
		ok

		# Reading the width of the box in number of chars
		nWidth = This.NumberOfChars() + 2 # By default
		if isNumber(paBoxOptions[:Width]) and
		   paBoxOptions[:Width] > This.NumberOfChars() + 2
			nWidth = paBoxOptions[:Width]
		ok

		# Reading the text adjustment option
		cTextAdjustedTo = :Center # By default
		if ring_find([ :Left, :Center, :Centered, :Right, :Justified ],
			paBoxOptions[:TextAdjustedTo]) > 0
			cTextAdjustedTo = paBoxOptions[:TextAdjustedTo]
		ok

		# Check if the string is already boxed
		bIsBoxed = This.ContainsAny([ "┌", "┐", "└", "┘", "╭", "╮", "╯", "╰" ])

		if bIsBoxed
			# Split the content into lines to determine the max width
			aLines = StzStringQ(This.Content()).Split(NL)
			nMaxLineWidth = 0
			for cLine in aLines
				nLineWidth = StzStringQ(cLine).NumberOfChars()
				if nLineWidth > nMaxLineWidth
					nMaxLineWidth = nLineWidth
				ok
			next

			# Adjust width to accommodate the inner box plus padding
			nWidth = nMaxLineWidth + 4 # 2 for borders, 2 for padding spaces
			if isNumber(paBoxOptions[:Width]) and paBoxOptions[:Width] > nMaxLineWidth + 4
				nWidth = paBoxOptions[:Width]
			ok

			# Prepare the box characters
			cVTrait = iff(cLine = :Dashed, "┊", "│")
			cHTrait = iff(cLine = :Dashed, "╌", "─")
			cCorner1 = iff(aCorners[1] = :Round, "╭", "┌")
			cCorner2 = iff(aCorners[2] = :Round, "╮", "┐")
			cCorner3 = iff(aCorners[3] = :Round, "╯", "┘")
			cCorner4 = iff(aCorners[4] = :Round, "╰", "└")

			# Construct the box
			cUpLine = cCorner1 + StzStringQ(cHTrait).RepeatedNTimes(nWidth - 2) + cCorner2 + NL

			# Adjust each line of the content
			cMidLines = ""
			for cLine in aLines
				cAdjustedLine = StzStringQ(cLine).AlignXTQ(nWidth - 4, " ", cTextAdjustedTo).Content()
				cMidLines += cVTrait + " " + cAdjustedLine + " " + cVTrait + NL
			next

			cDownLine = cCorner4 + StzStringQ(cHTrait).RepeatedNTimes(nWidth - 2) + cCorner3

			This.UpdateWith(cUpLine + cMidLines + cDownLine)
		else
			# Boxing logic for non-boxed strings
			# Prepare the box characters
			cVTrait = iff(cLine = :Dashed, "┊", "│")
			cHTrait = iff(cLine = :Dashed, "╌", "─")
			cCorner1 = iff(aCorners[1] = :Round, "╭", "┌")
			cCorner2 = iff(aCorners[2] = :Round, "╮", "┐")
			cCorner3 = iff(aCorners[3] = :Round, "╯", "┘")
			cCorner4 = iff(aCorners[4] = :Round, "╰", "└")

			# Construct the box
			cUpLine = cCorner1 + StzStringQ(cHTrait).RepeatedNTimes(nWidth) + cCorner2
			cMidLine = cVTrait + " " + This.AlignXTQ(nWidth - 2, " ", cTextAdjustedTo).Content() + " " + cVTrait
			cDownLine = cCorner4 + StzStringQ(cHTrait).RepeatedNTimes(nWidth) + cCorner3

			This.UpdateWith(cUpLine + NL + cMidLine + NL + cDownLine)
		ok

	but isList(paBoxOptions) and len(paBoxOptions) = 0
		# Do nothing, takes default options for boxing

	else
		StzRaise("Invalid boxing options provided!")
	ok

		#< @FunctionFluentForm

		def BoxXTQ(paBoxOptions)
			This.BoxXT(paBoxOptions)
			return This

		#>

		def BoxifyXT(paBoxOptions)
			This.BoxXT(paBoxOptions)

			def BoxifyXTQ(paBoxOptions)
				return This.BoxXTQ(paBoxOptions)

	def BoxedXT(paBoxOptions)
		cResult = This.Copy().BoxXTQ(paBoxOptions).Content()
		return cResult

		def BoxifiedXT(paBoxOptions)
			return This.BoxedXT(paBoxOptions)

	  #=================================================#
	 #   STRING EXISTENCE AS AN ITEM IN A GIVEN LIST   #
	#=================================================#

	def ExistsInListCS(paList, pCaseSensitive)

		if NOT isList(paList)
			stzRaise("Incorrect param! paList must be a list.")
		ok

		bResult = 0
		nLen = len(paList)

		for i = 1 to nLen
			item = paList[i]
			if isString(item) and StzStringQ(item).IsEqualToCS( This.String(), pCaseSensitive )
				bResult = 1
				exit
			ok
		next

		return bResult

		def ExistsAsItemInListCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheseCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

	#--

	def ExistsInList(paList)
		return This.ExistsInListCS(paList, 1)

		def ExistsAsItemInList(paList)
			return This.ExistsInList(paList)

		def IsOneOfThese(paList)
			return This.ExistsInList(paList)

		def IsOneOf(paList)
			return This.ExistsInList(paList)

		def IsOneOfThe(paList)
			return This.ExistsInList(paList)

	  #====================================================#
	 #  CHECHKING IF THE STRING IS EQUAL TO VAL1 OR VAL2  #
	#====================================================#
	// TODO: Add same function to other classes

	def IsEitherCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and StzListQ(pcStr2).IsOrNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.IsOneOfTheseCS([ pcStr1, pcStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsEither(pcStr1, pcStr2)
		return This.IsEitherCS(pcStr1, pcStr2, 1)

	  #=============================================#
	 #  MOVING CHAR AT POSITION N1 TO POSITION N2  #
	#=============================================#
	#TODO // Should be generalized to move hole substrings not only chars

	def Move(n1, n2)

		# Checking params correctness

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedParams([
			:From, :FromPosition,
			:At, :AtPosition,
			:Char, :CharAt, :CharAtPosition,
			:FromCharAt, :FromCharAtPosition,
			:CharFrom, :CharFromPosition
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToChar, :ToPosition, :ToPositionOfChar,
				:ToCharAt, :ToCharAtPosition ])

			n2 = n2[2]
		ok

		if isString(n1) and
		   ring_find([ :First, :FirstPosition, :FirstChar ], n1) > 0
				    
			n1 = 1
		ok

		if isString(n2) and
		   ring_find([ :Last, :LastPosition, :LastChar ], n1) > 0

			n2 = This.NumberOfItems()
		ok

		if NOT ( isNumber(n1) and isNumber(n2) )
			stzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		# Doing the job
		
		if n1 > n2
		# . . . 2 . . 1 . .
		#       ^     |
		#       |_____|

			cTempChar = This[n1]

			_oCopy_ = This.Copy()
			_oCopy_.RemoveCharAtPosition(n1)
			_oCopy_.InsertBefore(n2, cTempChar)

			This.UpdateWith(_oCopy_.Content())

		but n1 < n2
		# . . . 1 . . 2 . .
		#       |     ^
		#       |_____|

			cTempChar = This[n1]
			_oCopy_ = This.Copy()

			if n2 = This.NumberOfItems()
				_oCopy_.AddChar(cTempChar)
			else
				_oCopy_.InSertAfter(n2, cTempChar)
			ok

			_oCopy_.RemoveCharAt(n1)
			This.UpdateWith(_oCopy_.Content())

		ok

		#< @FunctionAlternativeForm

		def MoveChar(n1, n2)
			This.Move(n1, n2)

		#>

	  #=========================================#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if BothAreStrings(n1, n2)
			This.SwapSubStrings(n1, n2)
			return
		ok

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedPArams([
			:Between, :BetweenPosition, :BetweenPositions,
			:BetweenChar, :BetweenChars,
			:BetweenCharAt, :BetweenCharAtPosition, :BetweenCharAtPositions,
			:Position, :Positions, :CharAt, :CharAtPosition, :CharAtPositions,
			:CharsAt, :CharsAtPosition, :CharAtPositions
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedPArams([
			:And, :AndPosition, :AndCharAt, :AndCharAtPosition, :AndChar ])

			n2 = n2[2]
		ok

		_oStrCopy_ = This.Copy()

		copy = This[n2]
		_oStrCopy_.ReplaceCharAtPosition(n2, :By = This[n1])
		_oStrCopy_.ReplaceCharAtPosition(n1, :By = copy)

		_oStrCopy_.UpdateWith(_oStrCopy_.Content())


		#< @FunctionFluentForm

		def SwapQ(n1, n2)
			This.Swap(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenQ(n1, n2)
				This.SwapBetween(n1, n2)
				return This

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenPositionsQ(n1, n2)
				This.SwapBetweenPositions(n1, n2)
				return This

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapItemsQ(n1, n2)
				This.SwapItems(n1, n2)
				return This

		def SwapChar(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndCharAt, :AndCharAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapCharQ(n1, n2)
				This.SwapChar(n1, n2)
				return This

		def SwapChars(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsQ(n1, n2)
				This.SwapChars(n1, n2)
				return This

		def SwapCharsAtPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsAtPositionsQ(n1, n2)
				This.SwapCharsAtPositions(n1, n2)
				return This

		#>

	  #-----------------------------------------#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TWO, ONE, THREE!")
		o1.SwapSubStrings("TWO", "ONE")

		? o1.Content()
		#--> ONE, TWO, THREE!

		*/

		if isList(pcSubStr2) and StzListQ(pcSubStr2).IsOneOfTheseNamedParams([ :And, :With, :By ])
			pcSubStr2 = pcSubStr2[2]
		ok

		if NOT This.ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			StzRaise("Incorrect param types! Both pcSubStr1 and pcSubStr2 must be strings.")
		ok

		#NOTE // if the string contains more then one occurrence form a substring,
		# then only the first Occurrence is considered

		aSectionSubStr1 = This.FindAsSectionsCS(pcSubStr1, pCaseSensitive)[1]
		aSectionSubStr2 = This.FindAsSectionsCS(pcSubStr2, pCaseSensitive)[1]

		This.ReplaceSection(aSectionSubStr1[1], aSectionSubStr1[2], pcSubStr2)
		This.ReplaceSection(aSectionSubStr2[1], aSectionSubStr2[2], pcSubStr1)

		#< @FunctionFluentForm

		def SwapSubStringsCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			This.SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

		#>

	def SubStringsSwappedCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		cResult = This.Copy().SwapSubStringsCSQ(pcSubStr1, pcSubStr2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStrings(pcSubStr1, pcSubStr2)
		This.SwapSubStringsCS(pcSubStr1, pcSubStr2, 1)

		def SwapSubStringsQ(pcSubStr1, pcSubStr2)
			This.SwapSubStrings(pcSubStr1, pcSubStr2)
			return This

	def SubStringsSwapped(pcSubStr1, pcSubStr2)
		return This.SubStringsSwappedCS(pcSubStr1, pcSubStr2, 1)

	  #==================================#
	 #   REVERSING THE ORDER OF CHARS   #
	#==================================#

	def ReverseCharsOrder()

		_acChars_ = This.Chars()
		_nLen_ = len(_acChars_)

		_cInversed_ = ""

		for @i = _nLen_ to 1 step -1
			_cInversed_ += _acChars_[@i]
		next

		This.UpdateWith(_cInversed_)

		#< @FunctionFluentForm

		def ReverseCharsOrderQ()
			This.ReverseCharsOrder()
			return This
	
		#>

		#< @FunctionAlternativeForm

		def Reverse() # To stay consistent with Ring that has reverse() function
			This.ReversecharsOrder()

			def ReverseQ()
				This.Reverse()
				return This

		def ReverseOrder()
			This.ReversecharsOrder()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		#--

		def InverseCharsOrder()
			return This.ReverseCharsOrder()

		def Inverse()
			This.InversecharsOrder()

			def InverseQ()
				This.Inverse()
				return This

		def InverseOrder()
			This.InversecharsOrder()

			def InverseOrderQ()
				This.InverseOrder()
				return This

		#--

		def InvertCharsOrder()
			return This.ReverseCharsOrder()

		def Invert()
			This.InversecharsOrder()

			def InvertQ()
				This.Invert()
				return This

		def InvertOrder()
			This.InversecharsOrder()

			def InvertOrderQ()
				This.InvertOrder()
				return This

		#>

	def CharsOrderReversed()
		_cResult_ = This.Copy().ReverseCharsOrderQ().Content()
		return _cResult_

		#< @FunctionAlternativeForm

		def Reversed()
			return This.CharsOrderReversed()

		def OrderReversed()
			return This.CharsOrderReversed()

		#--

		def CharsOrderInversed()
			return This.CharsOrderReversed()

		def Inversed()
			return This.CharsOrderReversed()

		def OrderInversed()
			return This.CharsOrderReversed()

		#--

		def CharsOrderInverted()
			return This.CharsOrderReversed()

		def Inverted()
			return This.CharsOrderReversed()

		def OrderInverted()
			return This.CharsOrderReversed()

		#>

	  #---------------------------------------------------------#
	 #   TUENING CHARS OF THE STRING (IF POSSIBLE IN UNICODE)  #
	#=========================================================#

	def Turnchars()
		/*
		Example:
		? StzStringQ("LIFE").CharsTurned()
		#--> ƎℲI⅂
		*/

		#NOTE // Applies to latin script only

		_cResult_ = ""

		_aoStzChars_ = This.ToListOfStzChars()
		_nLen_ = len(_aoStzChars_)

		for @i = 1 to _nLen_
			_cResult_ += _aoStzChars_[@i].Turned()
		next

		This.UpdateWith(_cResult_)

		#< @FunctionFluentForm

		def TurnCharsQ()
			This.TurnChars()
			return This
		#>

		#< @FunctionAlternativeForms

		def ReverseChars()
			This.Turnchars()

			def ReverseCharsQ()
				return This.TurnCharsQ()

		def InverseChars()
			This.Turnchars()

			def InverseCharsQ()
				return This.TurnCharsQ()

		def InvertChars()
			This.Turnchars()

			def InvertCharsQ()
				return This.TurnCharsQ()

		#>

	def CharsTurned()
		return This.Copy().TurnCharsQ().Content()

		#< @FunctionAlternativeForms

		def CharsReversed()
			return This.CharsTurned()

		def CharsInversed()
			return This.CharsTurned()

		def CharsInverted()
			return This.CharsTurned()

		#>

	  #----------------------#
	 #  TURNING THE STRING  #
	#----------------------#

	def Turn()
		_cResult_ = This.Copy().TurnCharsQ().Reversed()
		This.UpdateWith(_cResult_)

		def TurnQ()
			This.Turn()
			return This

	def Turned()
		_cResult_ = This.Copy().TurnQ().Content()
		return _cResult_

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS A REVERSED COPY OF AN OTHER STRING  #
	#----------------------------------------------------------------#

	def IsReverseOf(pcOtherStr)

		if This.Reversed() = pcOtherStr
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def IsReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsInverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)
		
		def IsInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAnInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAnInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#==

		def IsTheReverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsTheReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsTheInverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)
		
		def IsTheInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsTheInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def ReverseOfB(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF INVERTED (TURNED) CHARS  #
	#-------------------------------------------------------------#

	def IsTurned()

		aoChars = This.ToListOfStzChars()
		nLen = len(aoChars)

		bResult = 1


		for i = 1 to nLen
			if NOT aoChars[i].IsTurned()
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def CharsAreTurned()
			return This.IsTurned()

		def AllCharsAreTurned()
			return This.IsTurned()

		#>

	  #========================#
	 #   HASHING THE STRING   #
	#========================#
	
	# Currently we use the native hashing functions of Ring StdLib
	#TODO // other algortithms can be added through RingQt

	def Hash(pcHashingAlgo)
		if isList(pcHashingAlgo) and StzListQ(pcHashingAlgo).IsWithOrUsingOrByNamedParam()
			pcHashingAlgo = pcHashingAlgo[2]
		ok

		if NOT isString(pcHashingAlgo)
			StzRaise("Incorrect param type! pcHashingAlgo must be a string.")
		ok

		if ring_find([ :MD5, :SHA1, :SHA256, :SHA512, :SHA384, :SHA224 ], pcHashingAlgo) = 0
			StzRaise("Unsupported hashing algorithm! Allowed values are :MD5, :SHA1, :SHA256, :SHA512, :SHA384 and :SHA224.")
		ok

		cHashed = ""

		switch pcHashingAlgo

		on :MD5
			cHashed = md5( This.String() )

		on :SHA1
			cHashed = sha1( This.String() )

		on :SHA256
			cHashed = sha256( This.String() )

		on :SHA512
			cHashed = sha512( This.String() )

		on :SHA384
			cHashed = sha384( This.String() )

		on :SHA224
			cHashed = sha224( This.String() )

		other
			stzRaise("syntax error or unsupported hashing algorithm!")
		off

		This.Update( cHashed )

		#< @FunctionFluentVersion

		def HashQ(pcHashingAlgo)
			return new stzString( This.Hash(pcHashingAlgo) )

		#>

		#< @FunctionAlternativeForms

		def HashWithAlgo(pcHashingAlgo)
			return This.Hash(pcHashingAlgo)

			def HashWithAlgoQ(pcHashingAlgo)
				return new stzString( This.HashWithAlgo(pcHashingAlgo) )
		#>

	def HashWithMD5()
		This.Hash(:MD5)

		def HashWithMD5Q()
			This.HashWithMD5()
			return This

	def HashWithSHA1()
		This.Hash(:SHA1)

		def HashWithSHA1Q()
			This.HashWithSHA1()
			return This

	def HashWithSHA256()
		This.Hash(:SHA256)

		def HashWithSHA256Q()
			This.HashWithSHA256()
			return This

	def HashWithSHA384()
		This.Hash(:SHA384)

		def HashWithSHA384Q()
			This.HashWithSHA384()
			return This

	def HashWithSHA224()
		This.Hash(:SHA224)

		def HashWithSHA224Q()
			This.HashWithSHA224()
			return This

	  #------------------------------------------#
	 #   ENCRYPTING AND DECRYPTING THE STRING   #
	#------------------------------------------#
	
	# Encrypts the string using the blowfish algorithm:
	#--> returns what's called a cipher in a binary string

	#--> TODO: - what the cIV param means?
	# 	    - check: key must be between 4 and 56 bytes long 

	def EncryptWithBlowfish(cSecretKey, cIV)
		cEncrypted = encrypt( This.String(), cSecretKey, cIV)
		This.Update( cEncrypted )

		#< @FunctionAlternativeForms

		def EncryptWithBlowfishQ(cSecretKey, cIV)
			return new stzListOfBytes( This.EncryptWithBlowfish(cSecretKey, cIV) )

		#>

	# Updates the string from a cipher encrypted with the blowfish algorithm
	#--> cCypher should be in binary form (list of bytes)
	def FromDecryptedWithBlowfish(cCypher, cSecret, cIV)
		This.Update( decrypt(cCypher, cSecret, cIV) )

		#< @FunctionAlternativeForms

		def FromBlowfishCipher(cCypher, cSecret, cIV)
			This.FromDecryptedWithBlowfish(cCypher, cSecret, cIV)

		#>

	  #==============================#
	 #   GETTING TEXT FROM A URL    #
	#==============================#

	def UpdateFromURL(cURL)
		This.Update( download(cURL) )

		def UpdateFromURLQ(cURL)
			This.UpdateFromURLL(cURL)
			return This

		def FromURL(cURL)
			This.UpdateFromURL(cURL)

			def FromURLQ(cURL)
				This.FromURL(cURL)
				return This

	def UpdatedFromURL(cURL)
		cResult = This.Copy().UpdateFromURLQ(cURL).Content()
		return cResult

	  #====================================================#
	 #     WALKING THE STRING AND RETURNING SOMETHING     #
	#====================================================#

	def AddWalker(pcWalkerName, nStart, nEnd, nStep)
		@aWalkers + new stzWalker(nStart, nEnd, nStep)

		def AddWalkerST(pcWalkerName, nStart, nEnd, nStep)
			This.AddWalker(pcWalkerName, nStart, nEnd, nStep)

	def Walker(pcWalkerName)
		oResult = @aWalkers[pcWalkerName]
		if oResult = ""
			StzRaise("Incorrect param value! pcWalkerName must be a valid walker name.")
		else
			return @aWalkers[pcWalkerName].Walkables()
		ok

		def WalkerPositions(pcWalkerName)
			return new stzList(This.Walker(pcWalkerName))

		def WalkedPositionsBy(pcWalkerName)
			return new stzList(This.Walker(pcWalkerName))

	def WalkerQ(pcwalkerName)
		oResult = @aWalkers[pcWalkerName]
		if oResult = ""
			StzRaise("Incorrect param value! pcWalkerName must be a valid walker name.")
		else
			return @aWalkers[pcWalkerName]
		ok

	def Walkers()
		return @aWalkers

	def RemoveWalker(pcWalkerName)
		nLen = len(@aWalkers)
		nPos = 0
		for i = 1 to nLen
			if @aWalkers[i][1] = pcWalkerName
				nPos = i
				exit
			ok
		next

		if nPos > 0
			ring_remove(@aWalkers, nPos)
		ok

	def RemoveWalkers(pcWalkerName)
		@aWalkers = []

	#TODO // Add other feature from stzWalker

	  #=================================#
	 #  REPEATING THE STRING N TIMES   #
	#=================================#

	def RepeatNTimes(n)
		/* NOTE

		This method exists already in the parent stzObject.
		Here we make it specific to strings.

		In fact, Q("Hi!").RepeatNTimes(3) when applied to
		the string "Hi!" will update it to become "Hi!Hi!Hi!".

		In all other types (stzList, stzNumber, and stzObject)
		Q(5).RepeatNTimes(3) will produce the list [5, 5, 5],
		and Q(1:3).RepeatNTimes(3) will produce the list
		[ 1:3, 1:3, 1:3 ].

		You may ask why we opted for a different behavior for
		strings compared to other types?

		Well, because I think it's more obvious to update the
		string when we ask to repeat it, and have a string as a
		result not a list!

		If you want to avoid any confusion due to this choice,
		use RproduceIn() instead, and specify explicitly what
		you hant to have, like this:

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InString)
		#--> "Hi!Hi:Hi!

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InList)
		"--> [ "Hi!", "Hi!", "Hi!" ]

		*/

		# Checking params

		if CheckingParams()
			if isList(n) and len(n) = 2
	
				# ~> Case: Repeat(:NTimes = 3)
	
				if isString(n[1]) n[1] = :NTimes and isNumber(n[2])
					n = n[2]
				
				# ~> Case: Repeat([ 3, :Times ])
				but isNumber(n[1]) and isString(n[2]) and n[2] = :Times
					n = n[1]
				ok
			ok
		ok

		# Doing the job

		cResult = ""
		for i = 1 to n
			cResult += This.Content()
		next
		This.Update( cResult )

		#< @FunctionFluentForms

		def RepeatNTimesQ(n)
			This.RepeatNTimes(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def Repeat(n)
			This.RepeatNTimes(n)

			def RepeatQ(n)
				This.Repeat(n)
				return This

		def Reproduce(n)
			This.RepeatNTimes(n)

			def ReproduceQ(n)
				This.Reproduce(n)
				return This

		def ReproduceNTimes(n)
			This.RepeatNTimes(n)

			def ReproduceNTimesQ(n)
				This.ReproduceNTimes(n)
				return This

		def CopyNTimes(n)
			This.RepeatNTimes(n)

			def copyNTimesQ(n)
				This.copyNTimes(n)
				return This
		#>


	# RETURNING THE OUTPUT DATA

	def RepeatedNTimes(n)
		return This.Copy().RepeatNTimesQ(n).Content()

		#< @FunctionAlternativeForms

		def Repeated(n)
			return This.RepeatedNTimes(n)

		def ReproducedNTimes(n)
			return This.RepeatedNTimes(n)

		def Reproduced(n)
			return This.RepeatedNTimes(n)

		def CopiedNTimes(n)
			return This.RepeatedNTimes(n)

		def Copied(n)
			return This.RepeatedNTimes(n)

		#>

	  #---------------------------------#
	 #  REPEATING THE STRING N TIMES   #
	#---------------------------------#

	def Repeat3Times()
		This.RepeatNTimes(3)

		#< @FunctionFluentForms

		def Repeat3TimesQ()
			This.Repeat3Times()
			return This

		#>

		#< @FunctionAlternativeForms

		def Reproduce3Times()
			This.Repeat3Times()

			def Reproduce3TimesQ()
				This.Reproduce3Times()
				return This

		def Copy3Times()
			This.Repeat3Times()

			def Copy3TimesQ()
				This.Copy3Times()
				return This

		#>

	# RETURNING THE OUTPUT DATA

	def Repeated3Times()
		return This.Copy().Repeat3TimesQ().Content()

		#< @FunctionAlternativeForms

		def Reproduced3Times()
			return This.Repeated3Times()

		def Copied3Times()
			return This.Repeated3Times()

		#>

	  #====================================================#
	 #     COMPRESSING THE STRING WITH A BINARY SCHEMA    #
	#====================================================#

	// Example : ABCDEFGH > 10011011 => ADEGH
	def CompressUsingBinary(cBinary)

		oBinary = new stzString(cBinary)
		if NOT oBinary.IsMadeOf(["0", "1"])
			stzRaise(stzStringError(:CanNotCompressStringUsingBinary))
		ok

		cCompressed = ""
		nLenBinary = len(cBinary)
		nLen = This.NumberOfChars()

		for i = 1 to nLenBinary
			if cBinary[i] = "1" and i <= nLen					
				cCompressed += This.Char(i)
			ok
		next
			
		if nLen > nLenBinary
			for i = NLenBinary + 1 to nLen
				cCompressed += This.CHar(i) 
			next
		ok

		This.Update( cCompressed )

		#< @FunctionFluentForm

		def CompressUsingBinaryQ(cBinary)
			This.CompressUsingBinary(cBinary)
			return This

		#>

	def CompressedUsingBinary(cBinary)
		_cResult_ = This.Copy().CompressUsingBinaryQ(cBinary).Content()
		return _cResult_

	  #=================================#
	 #    CHECKING A LIST IN STRING    #
	#=================================#

	def IsListInString()
		/* EXAMPLES

		o1 = new stzString('[]')
		? o1.IsListInString()

		o1 = new stzString('[2]')
		? o1.IsListInString()

		o1 = new stzString('[ "A","B", "C", "D" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "A":"D" ')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString('[ "ا", "ب", "ج" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "ا" : "ج" ')
		? o1.IsListInString() #--> TRUE

		o1 = new stzString("10 : 15")
		? o1.IsListInString() #--> TRUE

		*/

		_cContent_ = This.Content()
		cTrimmed = @trim(_cContent_)

		if NOT cTrimmed[1] = "["
			_cContent_ = @@(This.Content())
		ok
		
		cCode = 'bOk = isList(' + _cContent_ + ')'

		try
			eval(cCode)
			if bOk
				return 1
			ok
		catch
			# Continue to next part of the code
		done

		# Checking special case of unicode chars in short list form
		# Example: ' "ا" : "ج" '


		oCopy = This.RemoveSpacesQ()

		# Early check: A list can not be written with less then 2 chars

		if oCopy.NumberOfChars() < 2
			return 0
		ok

		bResult = 0

		# Doing the job

		if oCopy.ContainsOneOccurrence(":")

			# the : separator in _:_ can not be at the
			# beginning or the end of the list in string

			n = oCopy.FindFirst(":")
			if NOT ( n > 1 and n < oCopy.NumberOfChars() )

				bResult = 0

			ok

			# The list is in short form, let's analyze it
			# and tranform it to a normal syntax

			aListMembers = QStringListToList( oCopy.QStringObject().split( ":", 0, 0 ) )
			#NOTE: could be written { aListMembers = oCopy.Split( :Using = ":" ) } after
			# terminating Split() funtion in Softanza.

			cMember1 = aListMembers[1]
			cMember2 = aListMembers[2]

			cCode = "pMember1 = " + cMember1
			eval(cCode)

			cCode = "pMember2 = " + cMember2
			eval(cCode)

			cNormalSyntax = "[ "

			if ( isString(pMember1) and @IsChar(pMember1) ) and
			   ( isString(pMember2) and @IsChar(pMember2) )
				
				n1 = CharUnicode(pMember1)
				n2 = CharUnicode(pMember2)
	
				if n1 <= n2
					for n = n1 to n2
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n < n2
							cNormalSyntax += ", "
						ok
					next
	
				but n1 > n2
					for n = n1 to n2 step -1
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n > n2
							cNormalSyntax += ", "
						ok
					next
				ok
	
				cNormalSyntax += " ]"

			but isNumber(pMember1) and isNumber(pMember2)

				n1 = pMember1
				n2 = pMember2
	
				if n1 <= n2

					for n = n1 to n2
						cNormalSyntax += (""+ n)
						if n < n2
							cNormalSyntax += ", "
						ok
					next
	
				but n1 > n2

					for n = n1 to n2 step -1
						cNormalSyntax += (""+ n)
						if n > n2
							cNormalSyntax += ", "
						ok
					next
	
				ok
	
			ok

			cNormalSyntax = StzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()

			if Q(cNormalSyntax).LastChar() != "]"
				cNormalSyntax += " ]"
			ok

			cCode = "aTempList = " + cNormalSyntax
			eval(cCode)

			bResult = isList(aTempList)

		ok  

		return bResult

		def RepresentsListInString()
			return This.IsListInString()

	def IsListInNormalForm()
		if NOT This.IsListInString()
			return 0
		ok

		if This.TrimQ().IsBoundedBy([ "[","]" ])
			return 1
		else
			return 0
		ok

		def RepresentsListInNormalForm()
			return This.IsListInNormalForm()

	def IsListInShortForm()
		if This.IsListInString() and
		  ( NOT This.IsListInNormalForm() )

			return 1
		else
			return 0
		ok

		def RepresentsListInShortForm()
			return This.IsListInShortForm()

	  #--------------------------------------------#
	 #    CHECKING A CONTIGUOUS LIST IN STRING    #
	#--------------------------------------------#

	def IsContiguousListInString()

		cCode = "aTempList = " + This.ToListInNormalForm()
		eval(cCode)
		bResult = StzListQ(aTempList).IsContiguous()

		return bResult

		def IsContinuousListInString()
			return This.IsContiguousListInString()

	def IsContiguousListInNormalForm()
	
		if This.IsContiguousListInString() and
		   This.IsListInNormalForm()
		  
			return 1
		else
			return 0
		ok

		def IsContinuousListInNormalForm()
			return This.IsContiguousListInNormalForm()

	def IsContiguousListInShortForm()

		if This.IsContiguousListInString() and
		   This.IsListInShortForm()
		   
			return 1
		else
			return 0
		ok

		def IsContinuousListInShortForm()
			return This.IsContiguousListInShortForm()

	  #------------------------------------------------------------#
	 #  TRANSFORMING THE LIST INTO RING CODE IN SHORT FORM (_:_)  #
	#------------------------------------------------------------#

	def ToListInShortForm()
	
		if NOT This.IsContiguousListInString()
			stzRaise([
				:Where = "stzString > ToListInShortForm()",
				:What  = "Can't convert the list in string to short form!",
				:Why   = "The list in string is not contiguous list."
			])
		ok

		cResult = ""

		if This.IsListInShortForm()
			cResult  =  This.Copy().
					RemoveSpacesQ().
					ReplaceQ(":", " : ").
					Content()

		but This.IsListInNormalForm()

			cCode = "aTempList = " + This.String()
			eval(cCode)

			if StzListQ(aTempList).IsContiguous()

				oCopy = This.Copy()
				oCopy.Trim()
				oCopy.RemoveFirstAndLastChars()

				acMembers = oCopy.QStringObject().split(",", 0, 0)
				acMembers = QStringListToList(acMembers)
				acMembers = StzListQ(acMembers).FirstAndLastItems()

				/*
				TODO : replace with this when Split() is finished.

				acMembers = This.TrimQ().
						RemoveTheeBoundsQ("[","]").
						SplitQ(",").
						FirstAndLastItems()
				*/

						
				cMember1 = StzStringQ(acMembers[1]).Simplified()
				cMember2 = StzStringQ(acMembers[len(acMembers)]).Simplified()

				cResult = cMember1 + ":" + cMember2

			else
				cResult = This.Simplified()
			ok
		ok

		return cResult

		def ToListInShortFormQ()
			return new stzString( This.ToListInShortForm() )

		def ToListInStringInShortForm()
			return This.ToListInShortForm()

			def ToListInStringInShortFormQ()
				return new stzString( This.ToListInStringInShortForm() )

	  #-----------------------------------------------------------------#
	 #  TRANSFORMING THE LIST INTO RING CODE IN NORMAL FORM ([_,_,_])  #
	#-----------------------------------------------------------------#

	def ToListInNormalForm()

		If NOT This.IsListInString()
			stzRaise([
				:Where = "stzString > ToListInNormalForm()",
				:What  = "Can't convert the string to short form list!",
				:Why   = "The string is not a list in string."
			])
		ok

		if This.IsListInNormalForm()
			cResult = This.Simplified()

		but This.IsListInShortForm()

			# The list is in short form, let's analyze it
			# and tranform it to a normal syntax

			aListMembers = QStringListToList( This.QStringObject().split( ":", 0, 0 ) )
			#NOTE: could be written { aListMembers = This.Split( :Using = ":" ) } after
			# terminating Split() funtion in Softanza.
					
			cMember1 = aListMembers[1]
			cMember2 = aListMembers[2]

			cCode = "pMember1 = " + cMember1
			eval(cCode)
		
			cCode = "pMember2 = " + cMember2
			eval(cCode)
	
			cNormalSyntax = "[ "
	
			if ( isString(pMember1) and @IsChar(pMember1) ) and
			   ( isString(pMember2) and @IsChar(pMember2) )
						
				n1 = CharUnicode(pMember1)
				n2 = CharUnicode(pMember2)
		
				if n1 <= n2
					for n = n1 to n2
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2
					for n = n1 to n2 step -1
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n > n2
							cNormalSyntax += ", "
						ok
					next
				ok
		
				cNormalSystax = stzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()
				cNormalSyntax += " ]"
		
			but isNumber(pMember1) and isNumber(pMember2)

				n1 = pMember1
				n2 = pMember2
		
				if n1 <= n2

					for n = n1 to n2
						cNormalSyntax += (""+ n)
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2

					for n = n1 to n2 step -1
						cNormalSyntax += (""+ n)
						if n > n2
							cNormalSyntax += ", "
						ok
					next
		
				ok
		
				cNormalSystax = StzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()
				cNormalSyntax += " ]"
			ok

			cResult = StzStringQ(cNormalSyntax).ReplaceLastQ(",  ]", " ]").Content()

		ok  

		return cResult

		def ToListInNormalFormQ()
			return new stzString( This.ToListInNormalForm() )

		def ToListInStringInNormalForm()
			return This.ToListInNormalForm()

			def ToListInStringInNormalFormQ()
				return new stzString( This.ToListInStringInNormalForm() )

	def ToListInString()
		return This.ToListInNormalForm()

		def ToListInStringQ()
			return new stzString( This.ToListInString() )

	def ToListInStringSF()
		return This.ToListInShortForm()

		def ToListInStringSFQ()
			return new stzString( This.ToListInStringSF() )


	def ToList()
		cStr = @trim(This.Content())

		# Case 1: String is already in Ring list format

		if Rx(pat(:RingList)).Match(cStr)
			eval('aResult = ' + cStr)
			return aResult
		ok

		# Case 2: String is in range format (e.g., "1:3", "A:C", "#1:#3", "day1:day3")

		if @Contains(cStr, ":")
   
			# Split by colon and trim quotes

			aMatches = @Split(cStr, ":")
			cStart = @trim(aMatches[1])
			cEnd = @trim(aMatches[2])

			# Handle quoted values

			oStart = new stzString(cStart)
			cFirstChar = oStart.FirstChar()
			cLastChar = oStart.LastChar()

			if (cFirstChar = '"' and
			   cLastChar = '"') or

			   (cFirstChar = "'" and
			   cLastChar = "'")

				oStart.RemoveFirstAndLastChars()
			ok

			nLenStart = oStart.NumberOfChars()
			cStart = oStart.Content()

			#--

			oEnd = new stzString(cEnd)
			cFirstChar = oEnd.FirstChar()
			cLastChar = oEnd.LastChar()

			if (cFirstChar = '"' and
			   cLastChar = '"') or

			   (cFirstChar = "'" and
			   cLastChar = "'")

				oEnd.RemoveFirstAndLastChars()
			ok

			nLenEnd = oEnd.NumberOfChars()
			cEnd = oEnd.Content()

			# Case 2.1: Numeric range (e.g., "1:3")
			if oStart.IsNumberInString() and oEnd.IsNumberInString()
				nStart = 0 + cStart
				nEnd = 0 + cEnd
				aResult = []

				for i = nStart to nEnd
					aResult + i
				next

				return aResult

			# Case 2.2: Single character range (e.g., "A:C", "ا:ج")
			but nLenStart = 1 and nLenEnd = 1

				cStartChar = cStart
				cEndChar = cEnd
				nStart = @Unicode(cStartChar)
				nEnd = @Unicode(cEndChar)
				aResult = []

				for i = nStart to nEnd
					aResult + @Char(i)
				next

				return aResult

			# Case 2.3: Prefix with numbers (e.g., "#1:#3", "day1:day3")
			else

				# Extract the prefix and the numeric part

				oRegexStart = Rx(pat(:textWithNumberSuffix))
				oRegexEnd = Rx(pat(:textWithNumberSuffix))

				if oRegexStart.Match(cStart) and oRegexEnd.Match(cEnd)

					# Getting the parts of start string

					oStart = new stzString(cStart)
					n = nLenStart + 1

					while TRUE
 						n--
						if n = 0
							exit
						ok

						cChar = oStart.NthChar(n)

						if NOT @IsNumberInString(cChar)
							exit
						ok
					end

					aStartMatches = oStart.SplitAfterPosition(n)

					# Getting the parts of the end string

					oEnd = new stzString(cEnd)
					n = nLenEnd + 1

					while TRUE
						n--
						if n = 0
							exit
						ok

						cChar = oEnd.NthChar(n)
						if NOT @IsNumberInString(cChar)
							exit
						ok
					end

					aEndMatches = oEnd.SplitAfterPosition(n)
                
					# Check if prefixes match

					cPrefix = aStartMatches[1]

					if cPrefix = aEndMatches[1]

						nStart = 0+ aStartMatches[2]
						nEnd = 0 + aEndMatches[2]
						acResult = []

						for i = nStart to nEnd
							acResult + (cPrefix + i)
						next

						return acResult
					ok
				ok
			ok
		ok

		# If none of the patterns match, return a list containing the string

		return [ This.Content() ]

		def ToListQ()
			return new stzList( This.ToList() )

	  #==================================================#
	 #  CHECKING IF THE STRING IS MADE OF PUNCTUATIONS  #
	#==================================================#

	def IsPunctuation()
		aoChars = U( This.ToListOfStzChars() )
		nLen = len(aoChars)

		bResult = 1

		for i = 1 to nLen
			if NOT aoChars[i].IsPunct()
				bResult = 0
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfPunctuations()
			return This.IsPunctuation()

		def CharsArePunctuations()
			return This.IsPunctuation()

		def ArePunctuations()
			return This.IsPunctuation()

		#--

		def IsPunct()
			return This.IsPunctuation()

		def IsMadeOfPunct()
			return This.IsPunctuation()

		def CharsArePunct()
			return This.IsPunctuation()

		def ArePunct()
			return This.IsPunctuation()

		#>

	  #===============================#
	 #  FINDING PUNCTUATIONS CHARS   #
	#===============================#

	def FindPunctuations()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)

		anResult = []

		for i = 1 to nLen
			if aoChars[i].IsPunctuation()
				anResult + i
			ok
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindPunctionChars()
			return This.FindPunctuations()

		def FindPunct()
			return This.FindPunctuations()

		def FindPunctChars()
			return This.FindPunctuations()

		#--

		def FindPunctuationsZ()
			return This.FindPunctuations()

		def FindPunctionCharsZ()
			return This.FindPunctuations()

		def FindPunctZ()
			return This.FindPunctuations()

		def FindPunctCharsZ()
			return This.FindPunctuations()

		#>

	  #------------------------------#
	 #  REMOVING PUNCTUATION CHARS  #
	#------------------------------#

	def RemovePunctuations()
		anPos = This.FindPunctuations()
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemovePunctuationsQ()
			This.RemovePunctuations()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePunctuation()
			This.RemovePunctuations()
	
			def RemovePunctuationQ()
				return This.RemovePunctuationsQ()

		#>

	#-- @PassiveForm
	def PunctuationsRemoved()
		cResult = This.Copy().RemovePunctuationsQ().Content()
		return cResult

		def PunctuationRemoved()
			return This.PunctuationsRemoved()

	  #============================#
	 #  OPERATORS OVERLOADING     #
	#============================#

	#TODO // Operators should carry same semantics in all classes...
	#UPDATE // Largely done

	def operator(pOp,pValue)

		#WARNING // DON'T ADD = OPERATOR
		# Because it causes semantic conflict with
		# feature in stzExtCode (see CREATE_TABLE sql function)

		// string access : str[n]
		// string search : str[substr]

		if pOp = "[]"
			
			if isString(pValue)
				if pValue = :First or pValue = :FirsChar
					pValue = 1

				but pValue = :Last or pValue = :LastChar
					pValue = This.NumberOfChars()
				ok
			ok

			if isNumber(pValue)

				return This.NthChar(pValue)
							
			but isString(pValue)
				if StzStringQ(pValue).TrimQ().IsBoundedBy(["{","}"])
					pcCondition = StzStringQ(pValue).TrimQ().TheseBoundsRemoved("{","}")
					anResult = []

					@char = ""
					nLen = This.NumberOfChars()

					for @i = 1 to nLen
						@char = This.Char(@i)
						cCode = 'bOk = ( ' + pcCondition + ' )'

						eval(cCode)
						if bOk
							anResult + @i
						ok
					next

					return anResult
				else
					return This.FindAll(pValue)
				ok	
			ok
				// Add an item at the beginning of the list
		but pOp = "<<"
			This.Prepend(1)

		// Add an item at the end of the list
		but pOp = ">>"
			This.Append(value)

		// oString < str

		but pOp = "<"
			return This.IsSmallerThan(pValue)
		
		// compare : oString > str

		but pOp = ">"
			return This.IsLargerThan(pValue)
	
		// add : string + string | string + ListOfStrings

		but pOp = "+"
			if ring_type(pValue) = "STRING"
				return This.AppendedWith(pValue)

			but @IsStzString(pValue)
				This.AppendWith(pValue.Content())
				return This
		
			but isList(pValue) and StzListQ(pValue).IsListOfStrings()
				cExtension = QRT(pValue, :stzListOfStrings).Concatenated()
				cResult = This.Content() + cExtension
				return cResult

			but @IsStzListOfStrings(pValue)
				cResult = This.Content() + pValue.Concatenated()
				retur new stzString(cResult)
			ok

		// Multiply: string * n | string * string | string * list
	
		but pOp = "*"
			if @IsStzString(pValue)
				This.MultiplyBy(pValue.Content())
				return This

			but @IsStzNumber(pValue)
				This.MultiplyBy(pValue.NumericValue())
				return This

			but isList(pValue) and StzListQ(pValue).IsListOfStrings()
				nLen = len(pValue)
				cResult = ""

				for i = 1 to nLen
					cResult += (This.Content() + pValue[i])
				next

				return cResult

			but @IsStzListOfStrings(pValue)
				nLen = len(pValue)
				cResult = ""

				for i = 1 to nLen
					cResult += (This.Content() + pValue[i])
				next

				return new stzString(cResult)

			else
				return This.MultipliedBy(pValue)
			ok

		// Split: String / n  | String / str	| String / list

		but pOp = "/"
			# Native Ring string
			if isString(pValue)
				if Q(pValue).IsBoundedBy([ "{", "}" ])
					acSplitted = This.SplitW(pValue)
				else
					acSplitted = This.Split(pValue)
				ok
				return acSplitted
		
			# Softanza string object
			but @IsStzString(pValue)
				if pValue.IsBoundedBy([ "{", "}" ])
					acSplitted = This.SplitW(pValue.Content())
				else
					acSplitted = This.Split(pValue.Content())
				ok
				return Q(acSplitted)
		
			# Native Ring number
			but isNumber(pValue)
				return This.SplitToNParts(pValue)
		
			# Softanza number object
			but @IsStzNumber(pValue)
				return Q(This.SplitToNParts(pValue.NumericValue()))
		
			# Native Ring list with numbers
			but isList(pValue) and StzListQ(pValue).IsListOfNumbers()
				acSplitted = This.SplitToPartsOfSizes(pValue)
				return acSplitted
		
			# Softanza list object with numbers
			but @IsStzList(pValue) and pValue.IsListOfNumbers()
				acSplitted = This.SplitAtPositions(pValue.Content())
				return Q(acSplitted)
		
			# Native Ring list with where condition
			but isList(pValue) and StzListQ(pValue).IsPairOfStrings() and
			    pValue[1] = :where

				acSplitted = This.SplitW(pValue[2])
				return acSplitted
		
			# Softanza list object with where condition
			but @IsStzList(pValue) and pValue.IsPairOfStrings() and
			    pValue.Content()[1] = :where

				acSplitted = This.SplitW(pValue.Content()[2])
				return Q(acSplitted)
		
			# Native Ring list with wherext condition
			but isList(pValue) and StzListQ(pValue).IsPairOfStrings() and
			    pValue[1] = :wherext

				acSplitted = This.SplitWXT(pValue[2])
				return acSplitted
		
			# Softanza list object with wherext condition
			but @IsStzList(pValue) and pValue.IsPairOfStrings() and
			    pValue.Content()[1] = :wherext

				acSplitted = This.SplitWXT(pValue.Content()[2])
				return Q(acSplitted)
		
			# Native Ring list of strings
			but isList(pValue) and StzListQ(pValue).IsListOfStrings()
				nLen = len(pValue)
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue, acSplitted ])
				return aResult
		
			# Softanza list object of strings
			but @IsStzList(pValue) and pValue.IsListOfStrings()
				nLen = len(pValue.Content())
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue.Content(), acSplitted ])
				return Q(aResult)
		
			# Native Ring hash list
			but isList(pValue) and StzListQ(pValue).IsHashList()
				oHashList = new stzHashList(pValue)
				aValuesExceptLast = oHashList.ValuesQ().LastItemRemoved()
		
				if NOT Q(aValuesExceptLast).IsListOfNumbers()
					stzRaise("Incorrect values! All the values except the last, must be numbers.")
				ok
		
				if NOT ( isNumber(oHashList.LastValue()) or
					 ( isString(oHashList.LastValue()) and
					   ring_find([ :Remaining, :RemainingChars ], oHashList.LastValue()) > 0 ) )
		
					stzRaise("Incorrect value! The last value must be a number or a string (:Remaining or :RemainingChars).")
				ok
		
				if isString(oHashList.LastValue()) and
				   ring_find([ :Remaining, :RemainingChars ], oHashList.LastValue()) > 0
		
					n = 0
					nLenTemp = len(aValuesExceptLast)
					for i = 1 to nLenTemp
						n += aValuesExceptLast[i]
					next
		
					nRemainingChars = This.NumberOfChars() - n
					pValue[ len(pValue) ][2] = nRemainingChars
				ok
		
				if NOT StzHashListQ(pValue).ValuesQRT(:stzListOfNumbers).Sum() = This.NumberOfChars()
					stzRaise("Incorrect values! The sum of numbers must be equal to the number of chars!")
				ok
		
				nLenValue = len(pValue)
				aResult = []
				n = 1
				for i = 1 to nLenValue
					aPair = pValue[i]
					cShare = This.Range(n, aPair[2])
					n += aPair[2]
					aResult + [ aPair[1], cShare ]
				next
		
				return aResult
		
			# Softanza hash list object
			but @IsStzList(pValue) and pValue.IsHashList()
				acResult = This / pValue.Content()
				return Q(acResult)
			ok


		// string - string | string - .25 | string - 3
		but pOp = "-"
			cResult = ""
						
			if isString(pValue)

				cResult = This.Copy().Removed(pValue)
				return cResult

			but @IsStzString(pValue)

				oResult = This.Copy().RemoveQ(pValue.Content())
				return oResult

			but isList(pValue)

				cResult = This.RemoveManyQ(pValue).Content()
				return cResult

			but @IsStzList(pValue)

				cResult = This.RemoveManyQ(pValue.Content()).Content()
				return new stzString(cResult)

			ok

		// String % n : returns the rest of letters after dividing String / n

		but pOp = "%"

			if ring_type(pValue) = "NUMBER"

				_cResult_ = ""
				_aParts_ = []
				_nLen_ = This.NumberOfChars()

				_nParts_ = ceil( _nLen_ / pValue )

				for @i = 1 to _nLen_ step _nParts_
					_cTemp_ = This.QStringObject().mid(@i-1, _nParts_)
					_aParts_ + _cTemp_	
				next

				_nLenParts_ = len(_aParts_)

				if _nLenParts_ < pValue
					for @i = _nLenParts_ to pValue-1
						_aParts_ + "_"
					next
				ok

				_nLenParts_ = len(_aParts_)

				if _aParts[ _nLenParts_ ] != "_"
					return _aParts_[ _nLenParts_ ]
				ok

				return _cResult_

			but @IsStzNumber(pValue)
				cResult = This % pValue.NumericValue()
				return new stzString(cResult)

			ok

		ok // --- End of operator overloading section

	  #=====================================================#
	 #  METHODS USED FOR CAMPATIBILITY WITH EXTERNAL CODE  #
	#=====================================================#

	def join(pacItems)
		/* EXAMPLE

		In Python: ' + '.join([ "a", "b", "c" ])
		#--> a + b + c

		# In Ring, with Softanza:

		? Q(' + ').join([ "a", "b", "c" ])
		#--> a + b + c

		*/

		if NOT ( isList(pacItems) and StzListQ(pacItems).IsListOfStrings() )
			StzRaise("Incorrect param type! pacItems must be a list of strings.")
		ok

		cResult = QRT(pacItems, :stzListOfStrings).ConcatenatedUsing(This.String())
		return cResult

	  #==========================================#
	 #   METHODS USED FOR NEAR-NATURAL-CODING   #
	#==========================================#

	def IsAlmostAFunctionCall()
		# Why almost? Because it doesn't analyse the correctness of the params
		# which we should do in the future, but this is sufficient for our
		# current needs in stzChainOfTruth and other classes of natural-coding

		# PS: if you you don't like sutch a precison, use the alternative name
		# IsFunctionCall() instead.

		if This.NumberOfOccurrence("(") = 1 and
		   This.NumberOfOccurrence(")") = 1 and
		   This.FindFirst("(") > 1 and
		   This.FindFirst("(") < This.FindFirst(")") and
		   This.LastChar() = ")" // and #TODO // complete this and remove "Almost" from the function name!
		   //This.SectionQ(1,  This.FindFirst("(") - 1).ContainsOnly(:CompterCodeChars)
		
			return 1
		else
			return 0
		ok

		#< FunctionAlternativeForms >

		def IsFunctionCall()
			return This.IsAlmostAFunctionCall()
		#>

	def IsAMethodOfThisObject(pObject)
		return This.String().ExistsIn( classes(pObject) )

		def IsMethodOfObject(pObject)
			return IsAMethodOfThisObject(pObject)

	def IsAnAttributeOfThisObject(pObject)
		return This.String().ExistsIn( attributes(pObject) )

		def IsAttributeOfObject(pObject)
			return IsAnAttributeOfThisObject(pObject)		 

	#-----------------

	def IsStzString()
		return 1

	def StzType()
		return :stzString

	def IsANumber()
		return 0

		def IsNotANumber()
			return 1

	def IsAString()
		return 1

		def IsNotAString()
			return 0

	def IsAList()
		return 0

		def IsNotAList()
			return 1

	def IsAnObject()
		return 1

		def IsAObject()
			return 1

		def IsNotAnObject()
			return 0

	  #=====================================================#
	 #  CHECKING IF THE STRING STARTS WITH A GIVEN NUMBER  #
	#=====================================================#

	def StartsWithThisNumber(n)
		
		if NOT (isNumber(n) or ( isString(n) and @IsNumberInString(n) ) )
			StzRaise("Incorrect param type! n must be a number or number in string.")
		ok

		cNumber = ""

		if isString(n)
			if n = ""
				return 0
			ok
			cNumber = n

		but isNumber(n)
			cNumber = ""+ n
		ok

		nLen = StzStringQ(cNumber).NumberOfChars()

		if This.FirstNCharsAsString(nLen) = cNumber
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def StartsWithThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def ContainsThisStartingNumber(n)
			return This.StartsWithThisNumber(n)

		def ContainsThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def HasThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def HasThisStartingNumber(n)
			return This.StartsWithThisNumber(n)

		#--

		def StartsWithNumberN(n)
			return This.StartsWithThisNumber(n)

		def StartsWithLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def ContainsStartingNumberN(n)
			return This.StartsWithThisNumber(n)

		def ContainsLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def HasLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def HasStartingNumberN(n)
			return This.StartsWithThisNumber(n)

		#>
		
	  #-------------------------------------------------#
	 #  CHECKING IF THE STRING STARTS WITH ANY NUMBER  #
	#-------------------------------------------------#

	def StartsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.StartsWithANumber()
		#--> TRUE
		*/

		nLen = This.NumberOfChars()
		if nLen = 0
			return 0
		ok

		cFirst = This.Char(1)
		if cFirst = "+" or cFirst = "-"
			cFirst = This.Char(2)
		ok

		oChar = new stzChar(cFirst)
		if oChar.IsANumber()
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingNumber()
			return This.StartsWithANumber()

		def ContainsAStartingNumber()
			return This.StartsWithANumber()

		def ContainsALeadingNumber()
			return This.StartsWithANumber()

		def HasALeadingNumber()
			return This.StartsWithANumber()

		def HasAStartingNumber()
			return This.StartsWithANumber()

		#--

		def StartsWithNumber()
			return This.StartsWithANumber()

		def BeginsWithNumber()
			return This.StartsWithANumber()

		def BeginsWithANumber()
			return This.StartsWithANumber()

		#>

	  #-----------------------------------------------------#
	 #  GETTING THE LEADING NUMBER (IF ANY) IN THE STRING  #
	#-----------------------------------------------------#

	def StartingNumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		o1.StartingNumber()
		#--> 23
		*/

		cResult = ""
		bContinue = 1

		acChars = This.Chars()
		nLen = len(acChars)
		i = 0

		while bContinue
			i++

			if i = 0
				bContinue = 0

			else

				if NOT ( @IsNumberInString(acChars[i]) or
					 ring_find([ "+", "-", "." ], acChars[i]) > 0 )

					bContinue = 0

				ok

			ok
		end

		cResult = This.Section(1, i-1)
		return cResult

		#< @FunctionAlternativeForm

		def LeadingNumber()
			return This.StartingNumber()

		def BeginningNumber()
			return This.StartingNumber()

		#>
	
  	  #---------------------------------------------------#
	 #  CHECKING IF THE STRING ENDS WITH A GIVEN NUMBER  #
	#===================================================#

	def EndsWithThisNumber(n)

		if NOT (isNumber(n) or ( isString(n) and @IsNumberInString(n) ) )
			StzRaise("Incorrect param type! n must be a number or number in string.")
		ok

		cNumber = ""

		if isString(n)
			if n = ""
				return 0
			ok
			cNumber = n

		but isNumber(n)
			cNumber = ""+ n
		ok

		nLen = StzStringQ(cNumber).NumberOfChars()

		if This.LastNCharsAsString(nLen) = cNumber
			return 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def EndsWithThisTrailingNumber(n)
			return This.EndsWithThisNumber(n)

		def EndsWithThisFinalNumber(n)
			return This.EndsWithThisNumber(n)

		def ContainsThisTrailingNumber(n)
			return This.EndsWiththisNumber(n)

		def ContainsThisFinalNumber(n)
			return This.EndsWithThisNumber(n)

		def ContainsThisEndingNumber(n)
			return This.EndsWithThisNumber(n)

		#--

		def EndsWithNumberN(n)
			return This.EndsWithThisNumber(n)

		def EndsWithTrailingNumberN(n)
			return This.EndsWithThisNumber(n)

		def EndsWithFinalNumberN(n)
			return This.EndsWithThisNumber(n)

		def ContainsTrailingNumberN(n)
			return This.EndsWiththisNumber(n)

		def ContainsFinalNumberN(n)
			return This.EndsWithThisNumber(n)

		def ContainsEndingNumberN(n)
			return This.EndsWithThisNumber(n)

		#>
		
	  #---------------------------------------------#
	 #  CHECKING IF THE STRING ENDS WITH A NUMBER  #
	#---------------------------------------------#

	def EndsWithANumber()
		nResult = This.LastCharQRT(:stzChar).IsANumber()
		return nResult

		#< @FunctionAlternativeForms

		def EndsWithATrailingNumber()
			return This.EndsWithNumber()

		def EndsWithAFinalNumber()
			return This.EndsWithNumber()

		def ContainsATrailingNumber()
			return This.EndsWithNumber()

		def ContainsAFinalNumber()
			return This.EndsWithNumber()

		def ContainsAnEndingNumber()
			return This.EndsWithNumber()

		#--

		def EndsWithNumber()
			return This.EndsWithNumber()

		#>

	  #------------------------------------------------------#
	 #  GETTING THE TRAILING NUMBER (IF ANY) IN THE STRING  #
	#------------------------------------------------------#

	def TrailingNumber()
		/* EXAMPLE
		o1 = new stzString("Age: 48")
		o1.TrailingNumber()
		#--> 48
		*/

		cResult = ""
		bContinue = 1

		acChars = This.Chars()
		nLen = len(acChars)
		i = len(acChars) + 1

		while bContinue
			i--

			if i = 0
				bContinue = 0

			else

				if NOT ( @IsNumberInString(acChars[i]) or
					 ring_find([ "+", "-", "." ], acChars[i]) > 0 )

					bContinue = 0

				ok

			ok
		end

		cResult = This.Section(i+1, nLen)
		return cResult

		#< @FunctionAlternativeForm

		def FinalNumber()
			return This.StartingNumber()

		def EndingNumber()
			return This.StartingNumber()

		#>

	  #==============================================================#
	 #  GETTING ALL THE (DECIMAL) NUMBERS THAT EXIST IN THE STRING  #
	#==============================================================#
 
	def Numbers() #ai // Made in collaboration with ClaudeAI
		/* EXAMPLE

		o1 = new stzString("book: 12.34, watch: -56.30, glasses: 77.")
		? o1.Numbers()
		#--> [ "13.34", "-56.30",  "77" ]

		*/

		acResult = []
		acChars = This.Chars()
		nLen = len(acChars)
		cCurrentNum = ""
		bInNumber = 0
    
		nLenCurrentNum = 0
		nLenTemp = 0

		for i = 1 to nLen

			nLenCurrentNum = len(cCurrentNum) 
			# Check if char is digit, decimal point, or negative sign
	

			if ring_find(["0","1","2","3","4","5","6","7","8","9"], acChars[i]) > 0 or 
				(acChars[i] = "." and nLenCurrentNum > 0) or
				(acChars[i] = "-" and nLenCurrentNum = 0)
            
				cCurrentNum += acChars[i]
				bInNumber = 1
            
			else
				if bInNumber

					nLenTemp = len(acResult)

					if nLenTemp > 0 and acResult[nLenTemp] = "-"
						acResult[nLenTemp] = "-" + cCurrentNum
					else
						acResult + cCurrentNum
					ok

					cCurrentNum = ""
					bInNumber = 0
				ok
			ok
		next
    
		# Add final number if string ends with a number

		if cCurrentNum != ""
			nLen = len(acResult)
			if nLen > 0 and acResult[nLen] = "-"
				acResult[nLen] = "-" + cCurrentNum
			else
				acResult + cCurrentNum
			ok
		ok
    
		return acResult


		#< @FunctionFluentForms

		def NumbersQ()
			return This.NumbersQRT(:stzList)

		def NumbersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfStrings
				return new stzList( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #--------------------------------------#
	 #  EXTRACTING NUMBERS FROM THE STRING  #
	#--------------------------------------#

	def ExtractNumbers()
		acNumbers = This.Numbers()
		This.RemoveMany(acNumbers)
		return acNumbers

	  #------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF (DECIMAL) NUMBERS INCLUDED IN THE STRING  #
	#------------------------------------------------------------------#

	def NumberOfNumbers()
		return len( This.Numbers() )

		#< @FunctionAlternativeForms

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumbers()
			return This.NumberOfNumbers()

		def HowManyNumber()
			return This.NumberOfNumbers()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------#

	def NumbersAndTheirPositions() #TODO // Check performance!
		anResult = []
		acNumbersU = This.UniqueNumbers()
		nLen = len(acNumbersU)

		for i = 1 to nLen
			anResult + [ acNumbersU[i], This.Find(acNumbersU[i]) ]
		next

		return anResult

		def NumbersZ()
			return This.NumbersAndTheirPositions()

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR SECTIONS  #
	#------------------------------------------------------------------------#

	def NumbersAndTheirSections() #TODO // chek performance!
		aResult = []
		acNumbersU = This.UniqueNumbers()
		nLen = len(acNumbersU)

		for i = 1 to nLen
			aResult + [ acNumbersU[i], This.FindAsSections(acNumbersU[i]) ]
		next

		return aResult


		def NumbersZZ()
			return This.NumbersAndTheirSections()

	  #----------------------------------------------------#
	 #  GETTING THE LIST OF UNIQUE NUMBERS IN THE STRING  #
	#----------------------------------------------------#

	def UniqueNumbers()
		return This.NumbersQ().DuplicatesRemoved()

		#< @FunctionAlternativeForms

		def NumbersU()
			return This.UniqueNumbers()

		def NumbersWithoutDuplication()
			return This.UniqueNumbers()

		#>

	  #-------------------------------------------------------#
	 #  GETTTING THE NUMBER OF UNIQUE NUMBERS IN THE STRING  #
	#-------------------------------------------------------#

	def NumberOfUniqueNumbers()
		return len( This.UniqueNumbers() )

		#< @FunctionAlternativeForms

		def CountUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def NumberOfNumbersU()
			return This.NumberOfUniqueNumbers()

		def CountNumbersU()
			return This.NumberOfUniqueNumbers()

		#--

		def HowManyUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersU()
			return This.NumberOfUniqueNumbers()

		def HowManyUniqueNumber()
			return This.NumberOfUniqueNumbers()

		def HowManyNumberU()
			return This.NumberOfUniqueNumbers()

		#--

		def NumberOfNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (POSITIONS RETURNED)  #
	#----------------------------------------------------------------#

	def FindNumbers()
		anResult = This.FindMany( This.Numbers() )
		return anResult

		def FindNumbersZ()
			return This.FindNumbers()

	  #---------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (SECTIONS RETURNED)  #
	#---------------------------------------------------------------#

	def FindNumbersAsSections()
		return This.FindManyAsSections( This.Numbers() )

		def FindNumbersZZ()
			return This.FindNumbersAsSections()

	  #--------------------------------------------------------------#
	 #  GETTING THE NTH (DECIMAL) NUMBER THAT EXISTS IN THE DTRING  #
	#--------------------------------------------------------------#

	def NthNumber(n)
		if isString(n)
			if n = :First or n = :FirstNumber
				n = 1

			but n = :Last or n = :LastNumber
				n = len( This.Numbers() )
			ok
		ok

		return This.Numbers()[n]

	  #------------------------------------------------------#
	 #  GETTING THE FIRST NUMBER THAT EXISTS IN THE DTRING  #
	#------------------------------------------------------#

	def FirstNumber(n)
		return This.NthNumber(1)

	  #-----------------------------------------------------#
	 #  GETTING THE LAST NUMBER THAT EXISTS IN THE DTRING  #
	#-----------------------------------------------------#

	def LastNumber(n)
		return This.NthNumber(This.NumberOfNumbers())

	  #==========================================#
	 #  NUMBERS COMING AFTER A GIVEN SUBSTRING  #
	#==========================================#

	def NumbersComingAfterCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("This[@i-1] = This[@i+3]")
		? o1.NumbersComingAfter("@i")
		#--> [ "-1", "3" ]

		? o1.NumberComingAfter("@i+")
		#--> 3
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		cPatt = "(?<=" + pcSubStr + ")(\s*[+-]\s*\d*\.?\d+)"

		rx = new stzRegex(cPatt)
		rx.Match(This.WithoutSpaces())
		acResult = rx.Matches()

		return acResult

		#< @FunctionFluentForm

		def NumbersComingAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCSQRT(pcSubStr, pCaseSensitive, :stzList)

		def NumbersComingAfterCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and StzListQ(pcReturnType).IsStzClassName() )
				stzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NumbersComingAfterCS(pcSubStr, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NumbersComingAfterCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NumbersComingAfterCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NumbersAfterCS(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCS(pcSubStr, pCaseSensivitive)

		def NumbersAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbesrAfterCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		def NumbersAfterCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return NumbersComingAfterCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumbersComingAfter(pcSubStr)
		return This.NumbersComingAfterCS(pcSubStr, 1)

		#< @FunctionFluentForm

		def NumbersComingAfterQ(pcSubStr)
			return This.NumbersComingAfterQRT(pcSubStr, :stzList)

		def NumbersComingAfterQRT(pcSubStr, pcReturnType)
			return This.NumbersComingAfterCSQRT(pcSubStr, 1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NumbersAfter(pcSubStr)
			return This.NumbersComingAfter(pcSubStr)

		def NumbersAfterQ(pcSubStr)
			return This.NumbesrAfterQRT(pcSubStr, pcReturnType)

		def NumbersAfterQRT(pcSubStr, pcReturnType)
			return NumbersComingAfterQRT(pcSubStr, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  NTH NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#---------------------------------------------#

	def NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)
		#TODO // Re-implement it for better performance
		# No need to parse all the numbers and then get the nth

		if CheckParams()
			if NOT isNumber(n)
				stzraise("Incorrect param type! n must be a number.")
			ok
		ok

		acResult = This.NumbersComingAfterCS(pcSubStr, pCaseSensitive)
		nLen = len(acResult)

		if n <= nLen
			return acResult[n]
		ok

		#< @FunctionAlternativeForm

		def NthNumberAfterCS(n, pcSubStr, pCaseSensitive)
			return This.NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthNumberComingAfter(n, pcSubStr)
		return This.NthNumberComingAfterCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForm

		def NthNumberAfter(n, pcSubStr)
			return This.NthNumberComingAfter(n, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #  FIRST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(1, pcSubStr, pCaseSensitive)

		def NumbeComingAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FirstNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FirstNumberComingAfter(pcSubStr)
		return This.FirstNumberComingAfterCS(pcSubStr, 1)

		def NumberComingAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#< @FunctionAlternativeForm

		def FirstNumberAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#>

	  #----------------------------------------------#
	 #  LAST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def LastNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(:Last, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.LastNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def LastNumberComingAfter(pcSubStr)
		return This.LastNumberComingAfterCS(pcSubStr, 1)

		#< @FunctionAlternativeForm

		def LastNumberAfter(pcSubStr)
			return This.LastNumberComingAfter(pcSubStr)

		#>

	  #============================================#
	 #  GETTING THE LIST OF DIGITS IN THE STRING  #
	#============================================#

	def Digits()

		rx = new stzRegex(pat(:Digit))
		rx.Match(This.Content())
		return rx.Matches()

		def DigitsQ()
			return new stzList(This.Digits())

	  #====================================#
	 #  BISECTING THE STRING INTO HALVES  #
	#====================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

		def FirstHalfZ()
			return This.FirstHalfAndPosition()

	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()

		def FirstHalfZZ()
			return This.FirstHalfAndSection()

	def FirstHalfXT()

		nPos = ceil(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult
		

	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

		def FirstHalfXTZ()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

		def FirstHalfXTZZ()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

		def SecondHalfZ()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

		def SecondHalfZZ()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

		def SecondHalfXTZ()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

		def SecondHalfXTZZ()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
			return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

		def HalvesZ()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

		def HalvesXTZ()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

		def HalvesZZ()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

		def HalvesXTZZ()
			return This.HalvesAndSectionsXT()

	  #==========================================#
	 #   STRINGIFY(), TOSTRING(), AND TOCODE()  #
	#==========================================#

	def Stringify()
		# Do nothing, the object is naturally stringified
		# becauses it is already a string

		def StringifyQ()
			return new stzString(This.Content())

		def DeepStringify()
			This.Stringify()

			def DeepStringifyQ()
				return This.StringifyQ()

	def Stringified()
		return This.Content()

		def DeepStringified()
			return This.Stringified()

	def ToString()
		return This.Content()

		def ToStringQ()
			return new stzString( This.Content() )
	
	def ToCode()
		cResult = ""

		cQuote = "'"
		cDoubleQuote = '"'

		if This.IsBoundedBy(cDoubleQuote)
			cResult = cQuote + This.String() + cQuote

		but This.IsBoundedBy(cQuote)
			cResult = cDoubleQuote + This.String() + cDoubleQuote

		else
			cResult = This.String()
		ok

		return cResult

		def ToCodeQ()
			return new stzString( This.ToCode() )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE COMMON SUBSTRINGS BETWEEN THIS STRING AND AN OTHER STRING  #
	#-------------------------------------------------------------------------#

	def CommonSubStringsCS(pcOtherStr, pCaseSensitive)

		if CheckingParams()

			if isList(pcOtherStr) and StzListQ(pcOtherStr).IsWithNamedParam()
				pcOtherStr = pcOtherStr[2]
			ok
	
			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok

		ok

		# Doing the job

		aTempList = [
			This.SubStringsCS(pCaseSensitive),
			Q(pcOtherStr).SubStringsCS(pCaseSensitive)
		]

		acResult = StzListOfListsQ(aTempList).CommonItemsCS(pCaseSensitive)
		
		return acResult

		def IntersectionCS(pcOtherStr, pCaseSensitive)
			return This.CommonSubStringsCS(pcOtherStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CommonSubStrings(pcOtherStr)
		return This.CommonSubStringsCS(pcOtherStr, 1)

		def Intersection(pcOtherStr)
			return This.CommonSubStrings(pcOtherStr)

	  #======================#
	 #  SHOWING THE STRING  #
	#======================#

	def Show()
		? @@( This.Content() )

		#< @FuntionMisspelledForm

		def Shwo()
			This.Show()

		#>

	def ShowShort()
		? @@( This.Shortened() )

		def ShowShortCopy()
			This.ShowShort()

		#< @FuntionMisspelledForm

		def ShwoShort()
			This.ShowShort()

		def ShwoShortCopy()
			This.ShowShort()

		#>

	def ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		? @@( This.ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart) )

		def ShowShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		#< @FuntionMisspelledForm

		def ShwoShortXT(nMinStrSize, oNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		def ShwoShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		#>

	def ShowShortN(n)
		? @@( This.ShortenedN(n) )

		#< @FuntionMisspelledForm

		def ShwoShortN(n)
			This.ShowShortN(n)

		#>

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortUsing(pcMiddlePart)
			This.ShowShortUsing(pcMiddlePart)

		#>

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortNUsing(n, pcMiddlePart)
			This.ShowShortNUsing(n, pcMiddlePart)

		#>

	  #-------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING  #
	#===========================================#

	def ToShort()
		return This.ToShortXT(10, 3, " (...) ")

	  #-----------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING WITH N ITEMS FROM EACH SIDE  #
	#-----------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, " (...) ")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USiNG A GIVEN MIDDLE PART  #
	#---------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #--------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#--------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #------------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE STRING -- EXTENDED  #
	#------------------------------------------------------#

	def ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		# nMinStrSize : the minimum size to start shprtening
		# --> if the size of the string is less than this value,
		#     the string will not be shortened (returned as is)

		# pNumberOfCharsToShow: the number of chars to show from
		# both the beginning and end of the string
		# --> the other part of the string (coming in the middle)
		#     will be hide and replaced by pcMiddlePart

		/* EXAMPLES

		? Q("1234567890987654321").Shortened()
		#--> 123 ... 321
		
		? Q("1234567890987654321").ShortenedN(5)
		#--> 12345 ... 54321
		
		? Q("1234567890987654321").ShortenedXT(0, 3, " ... ")
		#--> 123 ... 321

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinStrSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfCharsToShow)
			n1 = pNumberOfCharsToShow
			n2 = pNumberOfCharsToShow

		but isList(p) and StzListQ(pNumberOfCharsToShow).IsPairOfNumbers()
			n1 = pNumberOfCharsToShow[1]
			n2 = pNumberOfCharsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfCharsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of chars to show must be different of zero.")
		ok

		# Doing the job

		cPart1 = This.Section(1, n1)
		cPart2 = This.Section(nLen - n2 + 1, nLen)

		cResult = cPart1 + pcMiddlePart + cPart2

		return cResult

	  #-------------------------#
	 #  SHORTENING THE STRING  #
	#=========================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #---------------------------------------------------#
	 #  SHORTENING THE STRING TO N CHARS FROM EACH SIDE  #
	#---------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNChars(n)
			This.ShortenN(n)

			def ShortenToNICharsQ(n)
				This.ShortenToNChars(n)
				return This

		def ShortenToNCharsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsInEachSideQ(n)
				This.ShortenToNCharsInEachSide(n)
				return This

		def ShortenToNCharsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsFromEachSideQ(n)
				This.ShortenToNCharsFromEachSide(n)
				return This

		def ShortenToNCharsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsAtEachSideQ(n)
				This.ShortenToNCharsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNChars(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNICharsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #-----------------------------------------------------------------#
	 #  SHORTENING THE STRING USING THE GIVEN STRING AS A MIDDLE PART  #
	#-----------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE STRING -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart).Content()
		return cResult

	  #===========================================#
	 #  GETTING THE LIST OF WORDS IN THE STRING  #
	#===========================================#

	#NOTE: stzString has a limited understanding of what a word is.
	# In fact, i't just a substring bounded by two spaces (or one space
	# if it is at the start or the end of the substring.

	# To get a more appealling meaning of Word(), use stzText instead.

	def WordsCS(pCaseSensitive)
		acResult = This.RemovePunctuationsQ().SplitQ(" ").ToSetCS(pCaseSensitive)
		return acResult

		def WordsCSQ(pCaseSensitive)
			return WordsCSQRT(pCaseSensitive, :stzList)

		def WordsCSQRT(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.WordsCS(pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.WordsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

	#-- WITHOUT CASESENSITIVITY

	def Words()
		return This.WordsCS(1)

		def WordsQ()
			return This.WordsQRT(:stzList)

		def WordsQRT(pcReturnType)
			return This.WordsCSQRT(TRUE, pcReturnType)

	  #---------------------------------------------------#
	 #   GETTING THE LIST OF WORDS WITHOUT DUPPLICATION  #
	#---------------------------------------------------#

	def WordsCSU(pCaseSensitive)
		acResult = This.WordsCSQ(pCaseSensitive).ToSet()
		return acResult

		#< @FunctionFulentForms

		def WordsCSUQ(pCaseSensitive)
			return WordsCSUQRT(pCaseSensitive, :stzList)

		def WordsCSUQRT(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.WordsCSu(pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.WordsCSU(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def UniqueWordsCS(pCaseSensitive)
			return This.WordsCSU(pCaseSensitive)

		def UniqueWordsCSQ(pCaseSensitive)
			return This.WordsCSUQ(pCaseSensitive)

		def UniqueWordsCSQRT(pCaseSensitive, pcReturnType)
			return ThisWordsCSUQRT(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def WordsU()
		return This.WordsCSU(1)

		#< @FunctionAlternativeForms

		def WordsUQ()
			return This.WordsUQRT(:stzList)

		def WordsUQRT(pcReturnType)
			return This.WordsCSUQRT(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def UniqueWords()
			return This.WordsU()

		def UniqueWordsQ()
			return This.WordsUQ()

		def UniqueWordsQRT(pcReturnType)
			return ThisWordsUQRT(pcReturnType)

		#>
		
	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRING CORRESPONDS TO A WORD OF THE STRING  #
	#========================================================================#

	def SubStringIsWordCS(pcSubStr, pCaseSensitive) #TODO // Check for performance!
		bResult = This.WordsCSQ(pCaseSensitive).ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForm

		def SubStringIsAWordCS(pcSubStr, pCaseSensitive)
			return This.SubStringIsWordCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsWord(pcSubStr)
		return This.SubStringIsWordCS(pcSubStr, 1)

		#< @FunctionAlternativeForms

		def SubStringIsAWord(pcSubStr)
			return SubStringIsWord(pcSubStr)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRINGS CORRESPOND TO A WORDS OF THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringsAreWordsCS(acSubStr, pCaseSensitive) #TODO // check for performance!

		if CheckingParams() = 1
			if NOT (isList(acSubStr) and StzListQ(acSubStr).IsLIstOfStrings())
				StzRaise("Incorrect param type! acSubStr must be a list pf strings.")
			ok
		ok

		bResult = 1

		nLen = len(acSubStr)
		for i = 1 to nLen
			if NOT This.SubStringIsWordCS(acSubStr[i], pCaseSensitive)
				bResult = 0
				exit
			ok

		next

		return bResult
		
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringsAreWords(acSubStr)
		return This.SubStringsAreWordsCS(acSubStr, 1)

	  #-----------------------------------#
	 #  FINDING THE WORDS IN THE STRING  #
	#===================================#

	def FindWordsCS(pCaseSensitive)

		acSplittedZ = This.SplitCSZ(" ", pCaseSensitive)
		anResult = U( QRT(acSplittedZ, :stzListOfPairs).SecondItems() )

		return anResult

		def PositionsOfWordsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

		def WordsPositionsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWords()
		return This.FindWordsCS(1)

		def PositionsOfWords()
			return This.FindWords()

		def WordsPositions()
			return This.FindWords()

	  #-----------------------------------------------------------------------------#
	 #  FINDING THE WORDS IN THE STRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-----------------------------------------------------------------------------#

	def FindWordsAsSectionsCS(pCaseSensitive)

		acSplittedZZ = This.SplitCSZZ(" ", pCaseSensitive)
		aResult = QRT(acSplittedZZ, :stzListOfPairs).SecondItems()

		return aResult

		def SectionsOfWordsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

		def WordsSectionsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWordsAsSections()
		return This.FindWordsAsSectionsCS(1)

		def SectionsOfWords()
			return This.FindWordsAsSections()

		def WordsSections()
			return This.FindWordsAsSections()

	  #--------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def WordsCSZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirPositionsCS(pCaseSensitive)
			return This.WordsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZ()
		return This.WordsCSZ(1)

		def WordsAndTheirPositions()
			return This.WordsZ()

	  #-------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------#

	def WordsCSZZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirSectionsCS(pCaseSensitive)
			return This.WordsCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZZ()
		return This.WordsCSZZ(1)

		def WordsAndTheirSections()
			return This.WordsZZ()

	  #=========================================#
	 #  A GENERAL EXTENDED SUBSTRING FUNCTION  #
	#=========================================#

	def SubStringCSXT(pcSubStr, p, pCaseSensitive)

		if isList(p)

			oParam = StzListQ(p)

			if oParam.IsIsBoundedByNamedParam()
				# Q(".. ♥♥ring♥♥ ..").SubStringXT("ring", :IsBoundedBy = "♥♥")
				return This.SubStringIsBoundedByCS(pcSubStr, p[2], pCaseSensitive)

			but oPAram.IsIsBoundOfNamedParam()
				# Q(".. ♥♥ring♥♥ ..").SubStringXT("♥♥", :IsBoundOf = "ring")
				return This.SubStringIsBoundOfCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsIsFirstBoundOfNamedParam()
				# Q(".. <<ring>> ..").SubStringXT("<<", :IsFirstBoundOf = "ring")
				return This.SubStringIsFirstBoundOfCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsIsLastBoundOfNamedParam()
				# Q(".. <<ring>> ..").SubStringXT("<<", :IsLastBoundOf = "ring")
				return This.SubStringIsLastBoundOfCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsIsLeftBoundOfNamedParam()
				# Q(".. <<ring>> ..").SubStringXT("<<", :IsLeftBoundOf = "ring")
				return This.SubStringIsLeftBoundOfCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsIsRightBoundOfNamedParam()
				# Q(".. <<ring>> ..").SubStringXT("<<", :IsRightBoundOf = "ring")
				return This.SubStringIsRightBoundOfCS(pcSubStr, p[2], pCaseSensitive)

			ok
		ok

		StzRaise("Unsupported syntax!")

	def SubStringXT(pcSubStr, p)
		return This.SubStringCSXT(pcSubStr, p, 1)

	  #--------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING IS THE BOUND OF AN OTHER SUBSTRING  #
	#--------------------------------------------------------------#

	def SubStringIsBoundOfCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		# EXAMPLE
		# Q(".. ♥♥ring♥♥ ..").SubStringIsBoundOf("♥♥", "ring")

		# The two params must be strings

		if NOT (isString(pcSubStr) and isString(pcOtherSubStr))
			return 0
		ok

		# The two substrings must exist in the string

		if NOT (This.ContainsCS(pcSubStr, pCaseSensitive) and
			This.ContainsCS(pcOtherSubStr, pCaseSensitive) )

			return 0
		ok

		bResult =  This.BoundsOfCSQ(pcOtherSubStr, pCaseSensitive).
				ContainsCS(pcSubStr, pCaseSensitive)

		return bResult

	def SubStringIsBoundOf(pcsubStr, pcOtherSubStr)
		return This.SubStringIsBoundOfCS(pcSubStr, pcOthersubStr, 1)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING IS THE FIRST BOUND OF AN OTHER SUBSTRING  #
	#--------------------------------------------------------------------#

	def SubStringIsFirstBoundOfCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		# EXAMPLE
		# ? Q(".. <<ring>> ..").SubStringXT("<<", :IsFirstBoundOf = "ring")

		# The two params must be strings

		if NOT (isString(pcSubStr) and isString(pcOtherSubStr))
			return 0
		ok

		# The two substrings must exist in the string

		if NOT (This.ContainsCS(pcSubStr, pCaseSensitive) and
			This.ContainsCS(pcOtherSubStr, pCaseSensitive) )

			return 0
		ok

		bResult =  Q( This.FirstBoundsOfCS(pcOtherSubStr, pCaseSensitive) ).
				ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	def SubStringIsFirstBoundOf(pcsubStr, pcOtherSubStr)
		return This.SubStringIsFirstBoundOfCS(pcSubStr, pcOthersubStr, 1)

	  #-------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING IS THE LAST BOUND OF AN OTHER SUBSTRING  #
	#-------------------------------------------------------------------#

	def SubStringIsLastBoundOfCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		# EXAMPLE
		# ? Q(".. <<ring>> ..").SubStringXT(">>", :IsLastBoundOf = "ring")

		# The two params must be strings

		if NOT (isString(pcSubStr) and isString(pcOtherSubStr))
			return 0
		ok

		# The two substrings must exist in the string

		if NOT (This.ContainsCS(pcSubStr, pCaseSensitive) and
			This.ContainsCS(pcOtherSubStr, pCaseSensitive) )

			return 0
		ok

		bResult =  Q( This.LastBoundsOfCS(pcOtherSubStr, pCaseSensitive) ).
				ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	def SubStringIsLastBoundOf(pcsubStr, pcOtherSubStr)
		return This.SubStringIsLastBoundOfCS(pcSubStr, pcOthersubStr, 1)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING IS THE LEFT BOUND OF AN OTHER SUBSTRING  #
	#--------------------------------------------------------------------#

	def SubStringIsLeftBoundOfCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		# EXAMPLE
		# ? Q(".. <<ring>> ..").SubStringXT("<<", :IsLeftBoundOf = "ring")

		# The two params must be strings

		if NOT (isString(pcSubStr) and isString(pcOtherSubStr))
			return 0
		ok

		# The two substrings must exist in the string

		if NOT (This.ContainsCS(pcSubStr, pCaseSensitive) and
			This.ContainsCS(pcOtherSubStr, pCaseSensitive) )

			return 0
		ok

		bResult =  Q( This.LeftBoundsOfCS(pcOtherSubStr, pCaseSensitive) ).
				ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	def SubStringIsLeftBoundOf(pcsubStr, pcOtherSubStr)
		return This.SubStringIsLeftBoundOfCS(pcSubStr, pcOthersubStr, 1)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING IS THE RIGHT BOUND OF AN OTHER SUBSTRING  #
	#--------------------------------------------------------------------#

	def SubStringIsRightBoundOfCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		# EXAMPLE
		# ? Q(".. <<ring>> ..").SubStringXT(">>", :IsRightBoundOf = "ring")

		# The two params must be strings

		if NOT (isString(pcSubStr) and isString(pcOtherSubStr))
			return 0
		ok

		# The two substrings must exist in the string

		if NOT (This.ContainsCS(pcSubStr, pCaseSensitive) and
			This.ContainsCS(pcOtherSubStr, pCaseSensitive) )

			return 0
		ok

		bResult =  Q( This.RightBoundsOfCS(pcOtherSubStr, pCaseSensitive) ).
				ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	def SubStringIsRightBoundOf(pcsubStr, pcOtherSubStr)
		return This.SubStringIsRightBoundOfCS(pcSubStr, pcOthersubStr, 1)

	   #=====================================================#
	  #   CHECKING IF STRING OCCURES BEFORE/AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST              #
	#=====================================================#

	#NOTE
	# These functions have been abstracted in stzObject so
	# we can use them with any type not only a string

	# Here is the list of those functions:
	# 	Occurs(pValue, pIn)
	# 	OccursBefore(pValue, pIn)
	# 	OccursAfter(pValue, pIn)
	# 	OccursBetween(pValue1, pValue2, pIn)
	# 	OccursNTimes( n, pIn )
	# 	OccursForTheNthTimeAt(n, pIn, pnAt)

	  #===========#
	 #   MISC.   #
	#===========#
		
	def HasSameTypeAs(p)
		return isString(p)

	def IsAnagramOfCS(pcOtherStr, pCaseSensitive)

		bCase = @CaseSensitive(pCaseSensitive)

		_cStr_ = This.Content()
		_cOther_ = pcOtherStr

		if bCase = 0
			_cStr_ = lower(_cStr_)
			_cOther_ = lower(pcOtherStr)
		ok

		_cInversed_ = ring_reverse(_cOther_)

		if _cStr_ = _cInversed_
			return 1
		else
			return 0
		ok

	def IsAnagramOf(pcOtherStr)
		return This.IsAnagramOfCS(pcOtherStr, 1)

	def UpTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() < CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar)
				acResult + StzCharQ(n).Content()
			next
			return acResult
		ok

	def DownTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() > CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar) step -1 
				acResult + StzCharQ(n).Content()
			next

			return acResult
		ok

	def FirstAndLastChars()
		aResult = [ This.FirstChar(), This.LastChar() ]
		return aResult

	def LastAndFirstChars()
		aResult = [ This.LastChar(), FirstChar() ]
		return aResult
		
	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzstring"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	def IsLatinScript()
		return This.ToStzText().IsLatinScript()

		def IsLatin()
			return This.IsLatinScript()

	def IsArabicScript()
		return This.ToStzText().IsArabicScript()

		def IsArabic()
			return This.IsArabicScript()

	def IsText()
		return 1

	def ToStzCCode()
		return new stzCCode(This.String())

		def ToStzCCodeObject()
			return This.ToStzCCode()

		def ToStzCCodeQ()
			return This.ToStzCCode()
 
	#===

	def SubStringCS(pcSubStr, pCaseSensitive)
		if This.ContainsCS(pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			return ""
		ok

		def SubStringCSQ(pcSubStr, pCaseSensitive)
			if This.ContainsCS(pcSubStr, pCaseSensitive)
				return StzSubStringCS(pcSubStr, This.Content(), pcCaseSensitive)

			else
				return ANullObject()
			ok

	def SubString(pcSubStr)
		return This.SubStringCS(pcSubStr, 1)

		def SubStringQ(pcSubStr)
			return StzSubStringQ(pcSubStr, This.Content())

	#==

	def @CS(pSubStr, pCaseSensitive)
		if NOT ( isString(pSubStr) or (isList(pSubStr) and @IsListOfStrings(pSubStr)) )
			StzRaise("Incorrect param type! pSubStr must be astring or list of strings.")
		ok

		_aSections_ = This.FindCSZZ(pSubStr, pCaseSensitive)
		SetTempList(_aSections_)

		return This

		def @AllCS(pSubStr, pCaseSensitive)
			return This.@CS(pSubStr, pCaseSensitive)

		def @TakeCS(pSubStr, pCaseSensitive)
			return This.@CS(pSubStr, pCaseSensitive)

	#-- PARTIAL

	def @(pSubStr)
		return This.@CS(pSubStr, 1)

		def @All(pSubStr)
			return This.@(pSubStr)

		def @Take(pSubStr)
			return This.@(pSubStr)


	# NEUTRAL


	def @0(p)
		return This.Content()

	#===

	def InCS(p, pCaseSensitive)
		if NOT (isString(p) or isList(p))
			StzRaise("Incorrect param type! p must be string or list.")
		ok

		if isString(p)
			return This.SubStringInCS(p, pCaseSensitive)

		but isList(p)
			return This.ItemInCS(p, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def InCSQ(p, pCaseSensitive)
			if NOT (isString(p) or isList(p))
				StzRaise("Incorrect param type! p must be string or list.")
			ok
	
			if isString(p)
				return SubStringInCSQ(p, pCaseSensitive)
	
			but isList(p)
				return ItemInCSQ(p, pCaseSensitive)
			ok

		#>

		#< @FunctionAlternativeForm

		def _In(p)
			return InCS(p, 1)

			def InQ(p)
				return InCSQ(p, 1)

		#>

	#--

	def SubStringInCS(pcStr, pCaseSensitive)
		if THis.ExistsInCS(pcStr, pCaseSensitive)
			return This.Content()
		else
			return ""
		ok

		def SubStringInCSQ(pcStr, pCaseSensitive)
			if This.ExistsInCS(pcStr, pCaseSensitive)
				return new stzSubStringCS(This.Content(), pcStr, pCaseSensitive)
			else
				return ANullObject()
			ok

	def SubStringIn(pcStr)
		return This.SubStringInCS(pcStr, 1)

		def SubStringInQ(pcStr)
			return This.SubStringInCSQ(pcStr, 1)

	#--

	def ItemInCS(paList, pCaseSensitive)
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if This.ExistsInCS(paList, pCaseSensitive)
			return This.Content()
		else
			return ""
		ok

		def ItemInCSQ(paList, pCaseSensitive)
			if This.ExistsInCS(paList, pCaseSensitive)
				return new stzItemCS(This.Content(), paList, pCaseSensitive)
			else
				return ANullObject()
			ok

	def ItemIn(paList)	
		return This.ItemInCS(paList, 1)

	# Swapping the content of the stzString with an other stzString

	def SwapWith(pOtherStzString)

		if CheckingParams()

			if NOT @IsStzString(pOtherStzString)
				StzRaise("Incorrect param type! pOtherStzString must be a stzString object.")
			ok
	
		ok

		cThis = This.Content()
		cOther = pOtherStzString.Content()

		This.UpdateWith(cOther)
		pOtherStzString.UpdateWith(cThis)

		def SwapWithQ(pOtherStzString)
			This.SwapWith(pOtherStzString)
			return This

		def SwapContentWith(pOtherStzString)
			This.SwapWith(pOtherStzString)

			def SwapContentWithQ(pOtherStzString)
				return This.SwapWithQ(pOtherStzString)

                 ///////////////////////////////////////////////
                //                              ///////////////
      ///////////      ALTERNATIVE FORMS       /////////////
 ///////////////                              //
///////////////////////////////////////////////

	  #--------------------------#
	 #  ALTERNATIVES OF Find()  #
	#--------------------------#

	def FindAllOccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllOccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllOccurrencesCSQRT(pcSubStr, pCaseSensitive, :stzList)
						
		def FFindAllOccurrencesCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
	
	def FindAllCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def FindAllCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

	def FindSubstringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindSubstringCSQ(pcSubStr, pCaseSensitive)
			return This.FindSubstringCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def FindSubstringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

	def OccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def OccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.OccurrencesCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def OccurrencesCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsOfSubStringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsOfSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsOfSubStringCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsOfSubStringCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)

	def FindPositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindPositionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindPositionsCSQRT(pcSubStr, pCaseSensitive, :stzList)
					
		def FindPositionsCSQRT(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQRT(pcSubStr, pCaseSensitive, pcReturnType)


	#-- WITHOUT CASESENSITIVITY

	def FindAll(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindAllQ(pcSubStr)
			return This.FindAllQRT(pcSubStr, :stzList)
				
		def FindAllQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)

	def FindSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindSubStringQ(pcSubStr)
			return This.FindSubStringQRT(pcSubStr, :stzList)
				
		def FindSubStringQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)

	def Occurrences(pcSubStr)
		return This.Find(pcSubStr)
	
		def OccurrencesQ(pcSubStr)
			return This.OccurrencesQRT(pcSubStr, :stzList)
				
		def OccurrencesQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)

	def Positions(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsQ(pcSubStr)
			return This.PositionsQRT(pcSubStr, :stzList)
				
		def PositionsQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)
	
	def PositionsOfSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsOfSubStringQ(pcSubStr)
			return This.PositionsOfSubStringQRT(pcSubStr, :stzList)
				
		def PositionsOfSubStringQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)

	def FindPositions(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindPositionsQ(pcSubStr)
			return This.FindPositionsQRT(pcSubStr, :stzList)
				
		def FindPositionsQRT(pcSubStr, pcReturnType)
			return This.FindQRT(pcSubStr, pcReturnType)

	  #-------------------------------------------#
	 #  FINDING A SUBSTRING AT A GIVEN POSITION  #
	#-------------------------------------------#

	def FindAtCS(n, pcSubStr, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		if ring_find(anPos, n)
			return 1
		else
			return 0
		ok

		#< @FunctionFluentForm

		def FindAtCSQ(n, pcSubStr, pCaseSensitive)
			This.FindAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def FindSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindASubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindASubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#==

		def FindSubStringAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindASubStringAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAt(n, pcSubStr)
		return This.FindAtCS(n, pcSubStr, 1)

		#< @FunctionAlternativeForms

		def FindSubStringAt(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindSubStringAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#--

		def FindASubStringAt(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindASubStringAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#==

		def FindSubStringAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#--

		def FindASubStringAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A CHAR INSIDE THE STING  #
	#======================================================#

	def FindCharCS(c, pCaseSensitive)
		anResult = This.FindCS(c, pCaseSensitive)
		return anResult

		def FindCharCSZ(c, pCaseSensitive)
			return This.FindCharCS(c, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def FindChar(c)
		return This.FindCharCS(c, 1)

		def FindCharZ(c)
			return This.FindChar(c)

	  #---------------------------------------------------------#
	 #  FINDING THE NTH OCCURRENCE OF A CHAR INSIDE THE STING  #
	#---------------------------------------------------------#

	def FindNthCharCS(n, cChar, pCaseSensitive)
		nResult = This.FindNthCS(n, cChar, pCaseSensitive)
		return nResult

		#< @FunctiionAlternativeForms

		def FindNthCharCSZ(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		#--

		def FindNthOccurrenceOfCharCS(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		def FindNthOccurrenceOfCharCSZ(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthChar(n, cChar)
		return This.FindNthCharCS(n, cChar, 1)

		#< @FunctionAlternativeForms

		def FindNthCharZ(n, cChar)
			return This.FindNthChar(n, cChar)

		#--

		def FindNthOccurrenceOfChar(n, cChar)
			return This.FindNthChar(n, cChar)

		def FindNthOccurrenceOfCharZ(n, cChar)
			return This.FindNthChar(n, cChar)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING THE FIRST OCCURRENCE OF A CHAR INSIDE THE STING  #
	#-----------------------------------------------------------#

	def FindFirstCharCS(cChar, pCaseSensitive)

		nResult = This.FindNthOccurrenceOfCharCS(1, cChar, pCaseSensitive)
		return nResult

		#< @FunctiionAlternativeForms

		def FindFirstCharCSZ(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		#--

		def FindFirstOccurrenceOfCharCS(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		def FindFirstOccurrenceOfCharCSZ(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstChar(cChar)
		return This.FindFirstCharCS(cChar, 1)

		#< @FunctiionAlternativeForms

		def FindFirstCharZ(cChar)
			return This.FindFirstChar(cChar)

		#--

		def FindFirstOccurrenceOfChar(cChar)
			return This.FindFirstChar(cChar)

		def FindFirstOccurrenceOfCharZ(cChar)
			return This.FindFirstChar(cChar)

		#>

	  #----------------------------------------------------------#
	 #  FINDING THE LAST OCCURRENCE OF A CHAR INSIDE THE STING  #
	#----------------------------------------------------------#

	def FindLastCharCS(cChar, pCaseSensitive)

		n = This.NumberOfOccurrenceCS(c, pCaseSensitive)
		nResult = This.FindNthOccurrenceOfCharCS(n, cChar, pCaseSensitive)

		return nResult

		#< @FunctiionAlternativeForms

		def FindLastCharCSZ(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		#--

		def FindLastOccurrenceOfCharCS(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		def FindLastOccurrenceOfCharCSZ(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastChar(cChar)
		return This.FindLastCharCS(cChar, 1)

		#< @FunctiionAlternativeForms

		def FindLastCharZ(cChar)
			return This.FindLastChar(cChar)

		#--

		def FindLastOccurrenceOfChar(cChar)
			return This.FindLastChar(cChar)

		def FindLastOccurrenceOfCharZ(cChar)
			return This.FindLastChar(cChar)

		#>

	  #============================================#
	 #  GETTING THE LIST OF VOWELS IN THE STRING  #
	#============================================#

	#TODO
	# Add case sensitivity

	def Vowels()
		nLen = This.NumberOfChars()
		aoChars = This.ToListOfStzChars()
		
		acResult = []

		for i = 1 to nLen
			if aoChars[i].IsVowel()
				acResult + aoChars[i].Content()
			ok
		next

		return acResult

		def VowelsQ()
			return new stzList(This.Vowels())

		def VowelsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.Vowels())

			on :stzListOfChars
				return new stzList(This.Vowels())

			on :stzListOfStrings
				return new stzListOfStrings(This.Vowels())

			other
				StzRaise("Unsupported return type!")
			off

		#-- @MisspelledForm

		def Vowyels()
			return This.Vowels()

		def VowyelsQ()
			return This.VowelsQ()

		def VowyelsQRT(pcReturnType)
			return This.VowelsQ(pcReturnType)

		#-- @BooleanForm

		def VowelsB()
			if This.VowelsQ().IsEqualTo(LastValue())
				return 1
			else
				return 0
			ok

		def VowelsBQ()
			if This.VowelsB()
				return This
			else
				return AFalseObject()
			ok

	def NumberOfVowels()
		nResult = len( This.Vowels() )
		return nResult

		#-- @Misspelled

		def NumberOfVowyels()
			return This.NumberOfVowels()

	def Vowel() # a random vowel from the string
		cResult = ARandomItemIn( This.Vowels() )
		return cResult

		def VowelQ()
			return new stzString(This.Vowel())

		def VowelQRT(pcReturnType)
			switch pcReturnType
			on :stzString
				return new stzString(This.Vowel())

			on :stzChar
				return new stzChar(This.Vowel())

			other
				StzRaise("Unsuppprted return type!")
			off

		#-- @Misspelled

		def Vowyel()
			return This.Vowel()

			def VowyelQ()
				return This.VowelQ()

			def VowyelQRT(pcReturnType)
				return This.VowelQRT(pcReturnType)

	def VowelN()
		return This.NumberOfVowels()

		def VowelNQ()
			return new stzNumber(This.vowelN())

		#-- @Misspelled

		def VowyelN()
			return This.VowelN()

			def VowyelNQ()
				return This.VowelNQ()

	def VowelNB()
		if This.NumberOfVowels() = LastValue()
			return 1
		else
			return 0
		ok

		def VowelNBQ()
			if This.NumberOfVowels() = LastValue()
				return This
			else
				return AFalseObject()
			ok

		#-- @Misspelled

		def VowyelNB()
			return This.VowelNB()

			def VowyelNBQ()
				return This.VowelNBQ()



	  ///////////////////////////////////
	 //  ALTERNATIVES OF SubStrings() //
	///////////////////////////////////

	def AllSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllSubStringsCSQRT(pCaseSitive, pcReturnType)
			return This.SubStringsCSQRT(pCaseSitive, pcReturnType)

	def AllPossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllPossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllPossibleSubStringsCSQRT(pCaseSitive, pcReturnType)
			return This.SubStringsCSQRT(pCaseSitive, pcReturnType)

	def PossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def PossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def PossibleSubStringsCSQRT(pCaseSitive, pcReturnType)
			return This.SubStringsCSQRT(pCaseSitive, pcReturnType)

	#-- WITHOUT CASESENSITIVE

	def AllSubStrings()
		return This.SubStrings()

		def AllSubStringsQ()
			return This.SubStringsQ()

		def AllSubStringsQRT(pcReturnType)
			return This.SubStringsQRT(pcReturnType)

	def AllPossibleSubStrings()
		return This.SubStrings()

		def AllPossibleSubStringsQ()
			return This.SubStringsQ()

		def AllPossibleSubStringsQRT(pcReturnType)
			return This.SubStringsQRT(pcReturnType)

	def PossibleSubStrings()
		return This.SubStrings()

		def PossibleSubStringsQ()
			return This.SubStringsQ()

		def PossibleSubStringsQRT(pcReturnType)
			return This.SubStringsQRT(pcReturnType)

	  #----------------------------#
	 #  ALTERNATIVES OF Append()  #
	#----------------------------#

	def Add(pcOtherStr)
		This.Append(pcOtherStr)

		def AddQ(pcOtherStr)
			This.Add(pcOtherStr)
			return This

	def AddToEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddToEndQ(pcOtherStr)
			This.AddToEnd(pcOtherStr)
			return This

	def AddEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddEndQ(pcOtherStr)
			This.AddEnd(pcOtherStr)
			return This

	#--

	def AppendEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendEndQ(pcOtherStr)
			This.AppendEnd(pcOtherStr)
			return This

	def AppendFromEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendFromEndQ(pcOtherStr)
			This.AppendFromEnd(pcOtherStr)
			return This

	def AppendAtEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendAtEndQ(pcOtherStr)
			This.AppendAtEnd(pcOtherStr)
			return This

	  #-------------------------------#
	 #   ALTERNATIVES OF Appended()  #
	#-------------------------------#

	def Added(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AddedToEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedFromEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedAtEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Prepend()  #
	#----------------------------#

	def AddStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddStartQ(pcOtherStr)
			This.AddStart(pcOtherStr)
			return This

	def AddToStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddToStartQ(pcOtherStr)
			This.AddToStart(pcOtherStr)
			return This

	def AddAtStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddAtStartQ(pcOtherStr)
			This.AddAtStart(pcOtherStr)
			return This

	def AddFromStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddFromStartQ(pcOtherStr)
			This.AddFromStart(pcOtherStr)
			return This

	  #--------------------------------#
	 #   ALTERNATIVES OF Prepended()  #
	#--------------------------------#

	def AddedToStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedFromStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedAtStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	  #----------------------------------------#
	 #  ALTERNATIVES OF FindManyAsSections()  #
	#----------------------------------------#

	def FindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringsAsSections(pacSubStr)
		return This.FindManyAsSections(pacSubStr)

	  #---------------------------------------#
	 #  ALTERNATIVES OF FindAnySplittedBy()  #
	#---------------------------------------#

	def FindAnySeparatedByCS(pcSeparator, pCaseSensitive)
		return This.FindAnySplittedByCS(pcSeparator, pCaseSensitive)

		#< @FunctionFluentForms

		def FindAnySeparatedByCSQ(pcSeparator, pCaseSensitive)
			return This.FindAnySplittedByCSQRT(pcSeparator, pCaseSensitive, :stzList)

		def FindAnySeparatedByCSQRT(pcSeparator, pCaseSensitive, pcReturnType)
			return This.FindanySplittedByCSQRT(pcSeparator, 1, pcReturnType)				
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySeparatedBy(pcSeparator)
		return This.FindAnySplittedBy(pcSeparator)			

		#< @FunctionFluentForms

		def FindAnySeparatedByQ(pcSeparator)
			return This.FindAnySeparatedByQRT(pcSeparator, :stzList)

		def FindAnySeparatedByQRT(pcSeparator, pcReturnType)
			return This.FindAnySplittedByCSQRT(pcSeparator, 1, pcReturnType)				

		#>

	  #------------------------------#
	 #  ALTERNATIVES OF FindNext()  #
	#------------------------------#

	def FindNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)

	def FirstNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextFirstOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FirstNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	  #----------------------------------#
	 #  ALTERNATIVES OF FindPrevious()  #
	#----------------------------------#

	def FindPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FirstPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousFirstOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FirstPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	  #-----------------------------#
	 #  ALTERNATIVES OF FindNth()  #
	#-----------------------------#

	def FindNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def PositionOfNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrencePositionCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def SubStringPositionByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def FindSubStringByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def PositionOfNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrencePosition(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def SubStringPositionByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def FindSubStringByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def Nth(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrence(n, pcSubStr)
		return This.FindNthC(n, pcSubstr)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindNthNext()  #
	#---------------------------------#

	def FindNthNextOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
		
	def PositionOfNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNext(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pcSubStr, nStart )
		return This.FindNthNext( n, pcSubStr, nStart )

	def FindNthNextOccurrenceST(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def PositionOfNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
		
	def NthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def NextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	  #------------------------------------------#
	 #  ALTERNATIVES OF FindNthNextAsSection()  #
	#------------------------------------------#

	def FindNthNextOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthNextAsSection( n, pcSubStr, nStart )

	def FindNthNextOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNthNextAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def PositionOfNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def NthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def NextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindNthPrevious()  #
	#-------------------------------------#

	def FindNthPreviousOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceSTCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
			
	def PositionOfNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence( n, pcSubStr, nStart )
		return This.FindNthPrevious( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceST(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PositionOfPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def NthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindNthPreviousAsSection()  #
	#----------------------------------------------#

	def FindNthPreviousOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthPreviousAsSection( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindPreviousNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindNthPreviousAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PositionOfPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def NthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	  #-----------------------------------------#
	 #  ALTERNATIVES OF FindNextOccurrences()  #
	#-----------------------------------------#

	def FindNextOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def NextPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindNextOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrenceST(pcSubStr, pnStartingAt)
		return This.FindNextOccurrences(pcSubStr, pnStartingAt)

	def NextOccurrences(pcSubStr, pnStartingAt)
		return This.FindNextOccurrences(pcSubStr, pnStartingAt)
	
	def NextPositions(pcSubStr, pnStartingAt)
		return This.FindNextOccurrences(pcSubStr, pnStartingAt)
	
	def FindNextOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindNextOccurrences(pcSubStr, pnStartingAt)

	def NextPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindNextOccurrences(pcSubStr, pnStartingAt)

	  #---------------------------------------------#
	 #  ALTERNATIVES OF FindPreviousOccurrences()  #
	#---------------------------------------------#

	def FindPreviousOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def PreviousPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindPreviousOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrenceST(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)

	def PreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)
	
	def PreviousPositions(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)
	
	def FindPreviousOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)

	def PreviousPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)

	  #------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceXT()  #
	#------------------------------------------#

	def NumberOfOccurrencesCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrenceOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrencesOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def CountCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def HowManyCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrenceOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrencesOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def CountXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def HowManyXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	  #-----------------------------#
	 #  ALTERNATIVES OF Replace()  #
	#-----------------------------#

	def ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllOccurrencesCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAllOccurrencesOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This		

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceAll(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllQ(pcSubStr, pcNewSubStr)
			This.ReplaceAll(pcSubStr, pcNewSubStr)
			return This

	def ReplaceSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceSubstring(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrencesOfSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesOfSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr)
			return This		

	  #----------------------------#
	 #  ALTERNATIVES OF Remove()  #
	#----------------------------#

	def RemoveAllCS(pSubStr, pCaseSensitive)
		This.RemoveCS(pSubStr, pCaseSensitive)

		def RemoveAllCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllCS(pSubStr, pCaseSensitive)
			return This

	def RemoveSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveSubstringCS(pSubStr, pCaseSensitive)
			return This

	def RemoveAllOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveAllOccurrencesOfSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllOccurrencesOfSubstringCS(pSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAll(pSubStr)
		This.Remove(pSubStr)

		def RemoveAllQ(pSubStr)
			This.RemoveAll(pSubStr)
			return This

	def RemoveSubstring(pcSubStr, pCaseSensitive)
		This.Remove(pcSubStr)

		def RemoveSubstringQ(pSubStr)
			This.RemoveSubstring(pSubStr)
			return This

	def RemoveAllOccurrencesOfSubstring(pcSubStr)
		This.Remove(pcSubStr)

		def RemoveAllOccurrencesOfSubstringQ(pSubStr)
			This.RemoveAllOccurrencesOfSubstring(pSubStr)
			return This


	  #===========================================#
	 #  CHECKING IF THE STRING IS IN JSON FORMAT  #
	#===========================================#

	def IsJson()
		return @IsJsonString(This.Content())

	#TODO // Implement these methods

	def ContainsJson()
		raise("Not yet implemented!")

	def Jsons()
		raise("Not yet implemented!")

		def JsonSubStrings()
			return This.Jsons()

	  #=====================================================#
	 #  DETECTING, FINDING AND READING HTML TABLE STRINGS  #
	#=====================================================#

	def IsHtmlTable()
		#NOTE
		# The method follows these key steps:
		# - Basic tag presence check (bounded by <table and </table>)
		# - Proper structure validation (contains <tr> and </tr>)
		# - Cell content validation (contains <td> or <th>)
		# - Normalized HTML processing
		# - Row extraction using FindSubStringsBoundedByZZ
		# - Validation of cell-to-row relationships
		# - Comprehensive position checking for all elements

		#TODO
		# Document the method limitations

	    if This.TrimQ().IsBoundedBy(["<table", "</table>"])
   
	        # Check if it has proper table structure (at least one row)
	        if not ( This.Contains("<tr") and This.Contains("</tr>") )
	            return FALSE
	        ok

	        # Check for cell content
	        if not ( This.Contains("<td") or This.Contains("<th") )
	            return FALSE
	        ok

	        # Normalize the HTML tags for better detection
	        oHTML = This.Copy()
	        oHTML.Trim()

	        # IMPORTANT: First find all rows before modifying the HTML structure
	        aRowSections = oHTML.FindSubStringsBoundedByZZ([ "<tr", "</tr>" ])

	        # Now let's check the proper nesting and structure

	        # 1. Get positions of all important elements
	        aTableSection = [1, oHTML.NumberOfChars()]
	        aTDSections = oHTML.FindSubStringsBoundedByZZ([ "<td", "</td>" ])
	        aTHSections = oHTML.FindSubStringsBoundedByZZ([ "<th", "</th>" ])

	        # Check if we have at least one row
	        if len(aRowSections) < 1
	            return FALSE
	        ok

	        # Check if we have at least one cell
	        if len(aTDSections) + len(aTHSections) < 1
	            return FALSE
	        ok

	        # Alternative approach: Check if each cell is inside at least one row by checking content
	        bAllCellsValid = TRUE

	        # Create a temporary string object for each row to check if it contains cells
	        for i = 1 to len(aRowSections)
	            aRowSection = aRowSections[i]
	            nRowStart = aRowSection[1]
	            nRowEnd = aRowSection[2]

	            # Extract the row content
	            cRowContent = oHTML.Section(nRowStart, nRowEnd - nRowStart + 1)

	            # Check if this row has at least one cell
	            if not ( ring_substr1(cRowContent, "<td") or  ring_substr1(cRowContent, "<th") )
	               // ? "Row without cells: " + @@(aRowSection)
	                bAllCellsValid = FALSE
	                exit
	            ok
	        next

	        if not bAllCellsValid
	            return FALSE
	        ok

	        # If we reached here, table structure is valid
	        return TRUE
	    ok

	    return FALSE

	#==

	def ContainsHTMLTable()

		# Early check

		if NOT This.Contains([ "<table", "</table>"])
			return FALSE
		ok

		# Getting the table strings into a list of stzString objects

		acSubStr = This.SubStringsBoundedByIB([ "<table", "</table>"])
		nLen = len(acSubStr)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(acSubStr[i])
		next

		# Checking for the existence of a html table

		for i = 1 to nLen
			if aoSubStr[i].IsHtmlTable()
				return TRUE
			ok
		next

		return FALSE

	#==

	def NumberOfHTMLTables()
		if not This.ContainsHTMLTable()
			return 0
		ok

		# Getting the table strings into a list of stzString objects

		acSubStr = This.SubStringsBoundedByIB([ "<table", "</table>"])
		nLen = len(acSubStr)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(acSubStr[i])
		next

		# Counting the valid html tables

		nResult = 0

		for i = 1 to nLen
			if aoSubStr[i].IsHtmlTable()
				nResult++
			ok
		next

		return nResult

	#==

	def HTMLTables()

		if not This.ContainsHTMLTable()
			return 0
		ok

		# Getting the table strings into a list of stzString objects

		acSubStr = This.SubStringsBoundedByIB([ "<table", "</table>"])
		nLen = len(acSubStr)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(acSubStr[i])
		next

		# Counting the valid html tables

		acResult = []

		for i = 1 to nLen
			if aoSubStr[i].IsHtmlTable()
				acResult + aoSubStr[i].Content()
			ok
		next

		return acResult


	#== FIRST AND LAST NON SPACE CHARS

	def FindFirstNonSpaceChar()

		cFirstNonSpaceChar = This.Copy().TrimQ().Char(1)
		nResult = ring_substr1(This.Content(), cFirstNonSpaceChar)

		return nResult

	def FirstNonSpaceChar()
		return This.Copy().TrimQ().Char(1)

	def FindLastNonSpaceChar()

		cFirstNonSpaceChar = This.Copy().TrimQ().LastChar()
		nPosRev = ring_substr1(@reverse(This.Content()), cFirstNonSpaceChar)
		nResult = This.NumberOfChars() - nPosRev + 1

		return nResult

	def LastNonSpaceChar()
		return This.Copy().TrimQ().LastChar()

	#==

	def FindFirstHTMLTableZZ()
		if This.IsHtmlTable()
			return This.FindFirstNonSpaceChar()
		ok

		# Early check

		if NOT This.Contains([ "<table", "</table>"])
			return FALSE
		ok

		# Getting the table strings into a list of stzString objects

		acSubStrZZ = This.SubStringsBoundedByIBZZ([ "<table", "</table>"])
		nLen = len(acSubStrZZ)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(acSubStrZZ[i][1])
		next

		# Checking for the existence of a html table

		for i = 1 to nLen
			if aoSubStr[i].IsHtmlTable()
				return acSubStrZZ[i][2]
			ok
		next

		return []

	def FirstHtmlTable()
		if This.IsHtmlTable()
			return @trim(This.Content())
		ok

		aSection = This.FindFirstHtmlTableZZ()
		if len(aSection) = 0
			return ""
		else
			This.Section(aSection[1], aSection[2])
		ok

		def FirstHtmlTableQ()
			return new stzString(This.FirstHtmlTable())

	def FindHTMLTablesZZ()

		if not This.ContainsHTMLTable()
			return []
		ok

		if This.IsHtmlTable()
			return [ [This.FindFirstNonSpaceChar(), This.FindLastNonSpaceChar()] ]
		ok

		aSections = This.FindSubStringsBoundedByIBZZ([ "<table", "</table>"])
		nLen = len(aSections)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(This.Section(aSections[i][1], aSections[i][2]))
		next

		aResult = []

		for i = 1 to nLen
			if aoSubStr[i].IsHtmlTable()
				aResult + aSections[i]
			ok
		next

		return aResult

		def FindHTMLTablesAsSections()
			return This.FindHTMLTablesZZ()


	#==

	def HtmlToDataTable()

		# First, validate that we have a valid HTML table

		if not This.IsHTMLTable()
			return NULL
		ok

		# Getting the column names

		acSubStr = This.SubStringsBoundedBy([ "<th ", "/th" ])
		nLen = len(acSubStr)

		aoSubStr = []
		for i = 1 to nLen
			aoSubStr + new stzString(acSubStr[i])
		next

		acColNames = []

		for i = 1 to nLen
			nPos = ring_substr1(acSubStr[i], ">")
			cColName = aoSubStr[i].Section( nPos+1, aoSubStr[i].NumberOfChars()-1 )
			acColNames + cColName
		next
		nLenCols = len(acColNames)

		# Preparing the table container (in the stzTable format)

		aDataTable = []
		for i = 1 to nLenCols
			aDataTable + [ acColNames[i], [] ]
		next

		# Getting the rows

		oTable = StzStringQ( This.SubStringsBoundedBy([ "<tbody>", "</tbody>" ])[1] )
		oTable.Remove('<tr class="row">')
		oTable.remove("<tr>")

		acBlocks = oTable.SplitAt("</tr>")

		aoBlocks = []
		nLenBlocks = len(acBlocks)
		for i = 1 to nLenBlocks
			aoBlocks + new stzString(acBlocks[i])
		next

		for i = 1 to nLenBlocks

			acItems = aoBlocks[i].SubStringsBoundedBy([ "<td>", "</td>" ])
			nLenItems = len(acItems)

			for j = 1 to nLenItems
				aDataTable[j][2] + acItems[j]
			next

		next

		return aDataTable

		def HtmlToDataTableQ()
			return new stzList(This.HtmlToDataTable())

		def HtmlToDataTableQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.HtmlToDataTable())

			on :stzHashList
				return new stzHashList(This.HtmlToDataTable())

			on :stzTable
				return new stzTable(This.HtmlToDataTable())

			other
				StzRaise("Unsupported return type!")
			off

		def HtmlToTable()
			return This.HtmlToDataTable()

			def HtmlToTableQ()
				return This.HtmlToDataTableQ()

			def HtmlToTableQRT(pcReturnType)
				return This.HtmlToDataTableQRT(pcReturnType)

	#==

	def HtmlToDataTables()

		aSections = This.FindHtmlTablesZZ()
		nLen = len(aSections)

		aoTables = []
		for i = 1 to nLen
			aoTables + new stzString(This.Section(aSections[i][1], aSections[i][2]))
		next

		aResult = []

		for i = 1 to nLen
			aResult + aoTables[i].HtmlToDataTable()
		next

		return aResult


		def HtmlToDataTablesQ()
			return new stzList(This.HtmlToDataTables())

		def HtmlToDataTablesQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.HtmlToDataTables())

			on :stzListOfHashLists
				return new stzListOfHashLists(This.HtmlToDataTables())

			on :stzListOfTables
				return new stzListOfTables(This.HtmlToDataTables())

			other
				StzRaise("Unsupported return type!")
			off

		def HtmlToTables()
			return This.HtmlToDataTables()

			def ToHtmlTablesQ()
				return This.ToHtmlDataTablesQ()

			def ToHtmlTablesQR(pcReturnType)
				return This.ToHtmlDataTablesQR(pcReturnType)

	  #=====================================================#
	 #  DETECTING, FINDING AND READING CSV STRING CONTENT  #
	#=====================================================#

	def IsCSV()
		return @IsCSV(This.Content()) # From stzCSV.ring

		def IsCSVTable()
			return This.IsCSV()

	def CsvToDataTable()
		return @CSVTolist(This.Content())

		def CsvToDataTableQ()
			return new stzList(This.CsvToDataTable())
		
		def CsvToDataTableQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.CsvToDataTable())
			
			on :stzHashList
				return new stzHashList(This.CsvToDataTable())
			
			on :stzTable
				return new stzTable(This.CsvToDataTable())
			
			other
				StzRaise("Unsupported return type!")
			off
