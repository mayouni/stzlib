#---------------------------------------------------------------------------#
# 		   SOFTANZA LIBRARY (V1.0) - STZLIST			    #
#	An accelerative library for Ring applications, and more!	    #
#---------------------------------------------------------------------------#
#									    #
# 	Description	: The class for managing lists in Softanza          #
#	Version		: V1.0 (2020-2024)				    #
#	Author		: Mansour Ayouni (kalidianow@gmail.com)		    #
#									    #
#---------------------------------------------------------------------------#

#TODO Centralise all updading features in update() method
# ~> It's important to have a single entry for simplifying
# a feature like Undo/Redo (currently scattered over many
# places in the code.

#NOTE ~> Same #TODO applies to stzString and stzNumber

# Loading the functions for managing paths in list

load "stzListPaths.ring"

  /////////////////////
 ///   FUNCTIONS   ///
/////////////////////

func StzListQ(paList)
	return new stzList(paList)

#===

func ListEqualsCS(paList1, paList2, pCaseSensitive)
	return StzListQ(paList1).IsEqualToCS(paList2, pCaseSensitive)

	func ListEquals(paList1, paList2)
		return StzListQ(paList1).IsEqualTo(paList2)

func Listify(cStrInList)
	if isList(cStrInlist)
		return StzListQ(cStrInlist).Listified()
	ok

	oTempStr = new stzString(cStrInList)
	if oTempStr.IsListInString()
		cCode = 'aResult = ' + oTempStr.Content()
		eval(ccode)
		return aResult
	ok

	StzRaise("Can't proceed! cStrInList must be a string containing a well formatted Ring list.")

	func @Listify(cStrInList)
		return Listify(cStrInList)

	func StringToList(cstrInList)
		if NOT isString(cStrInList)
			StzRaise("Incorrect param type! cStrInList must be a string.")
		ok

		return Listify(cStrInList)

#===

func Slice(pStrOrList, n1, n2)
	if CheckParams()
		if NOT (isString(pStrOrList) or isList(pStrOrList))
			StzRaise("Incorrect param type! pStrOrList must be a string or list.")
		ok
	ok

	if isString(pStrOrList)
		return StkStringQ(pStrOrList).section(n1, n2)
	else
		_aResult_ = []
		_nLen_ = len(pStrOrList)

		for @i = n1 to n2
			_aResult_ + pStrOrList[@i]
		next

		return _aResult_
	ok

//	func Section(pStrOrList, n1, n2) #TODO // Used in stzSection.ring!
//		return Slice(pStrOrList, n1, n2)

func Repeat(value, nTimes)
	if CheckParams()
		if NOT isNumber(nTimes)
			StzRaise("Incorrect param type! nTimes must be a number.")
		ok
	ok

	aResult = []

	for i = 1 to nTimes
		aResult + value
	next

	return aResult

	#< @FunctionAlternativeForms

	func @Repeat(value, nTimes)
		return Repeat(value, nTimes)

	func RepeatInList(value, nTimes)
		return Repeat(value, nTimes)

	func RepeatInAList(value, nTimes)
		return Repeat(value, nTimes)

	func @RepeatInList(value, nTimes)
		return StzRepeat(value, nTimes)

	func @RpeatInAList(value, nTimes)
		return Repeat(value, nTimes)

	#>


func SortingOrder(p)
	return Q(p).SortingOrder()

func SortingOrders(paListOfThings)
	if NOT isList(paListOfThings)
		StzRaise("Incorrect param type! paListOfThings must be a list.")
	ok

	acResult = []

	nLen = len(paListOfThings)
	for i = 1 to nLen
		acResult + Q(paListOfThings[i]).SortingOrder()
	next

	return acResult

func HaveSameSortingOrder(p1, p2)
	return Q(p1).HasSameSortingOrderAs(p2)

	func HaveSameSortingOrders(p1, p2)
		return HaveSameSortingOrder(p1, p2)

func SortListsBySize(paLists)
	if CheckingParam()
		if NOT ( isList(paLists) and @IsListOfLists(paLists) )
			StzRaise("Incorrect param type! paLists must be a list of lists.")
		ok
	ok

	nLen = len(paLists)

	for i = 1 to nLen
		ring_insert(paLists[i], len(paLists[i]), 1)
	next

	SortListsOn(paLists, 1)

	for i = 1 to nLen
		ring_remove(paLists[i], 1)
	next

	return paLists

	func @SortListsBySize(paLists)
		return nSortListsBySize(paLists)

func SortLists(paLists)
	return SortListsOn(palists, 1)

	func @SortLists(paList)
		return SortLists(paList)

func ListsStringifyXT(paListOfLists)
	if CheckingParams()
		if NOT ( isList(paListOfLists) and @IsListOfLists(paListOfLists) )
			StzRaise("Incorrect param type! paListOfLists must be a list of Lists.")
		ok
	ok

	if len(paListOfLists) = 0
		return [ "" ]
	ok

	aCols = StzListOfListsQ(paListOfLists).Cols()
	nLen = len(aCols)

	acColsStringified = []
	for i = 1 to nLen
		acColsStringified + ListStringifyXT(aCols[i])
	next

	oLoL = StzListOfListsQ([])

	for i = 1 to nLen
		oLoL.AddCol(acColsStringified[i])
	next

	aResult = oLoL.Content()

	return aResult


	func @ListsStringifyXT(paListOfLists)
		return ListsStringifyXT(paListOfLists)

func ListStringifyXT(paList)
	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	# If list contains numbers then we adjust
	# them before we stringify them

	# We start by getting the max left and right
	# number of digits (integer and decimal parts)

	nLen = len(paList)

	nMaxSize = 0
	nMaxLeft = 0
	nMaxRight = 0

	anNumbersPos = []

	for i = 1 to nLen
		if isNumber(paList[i])

			anNumbersPos + i

			cNumber = ""+ paList[i]

			nSize = len(cNumber)
			if nSize > nMaxSize
				nMaxSize = nSize
			ok

			nDotPos = ring_substr1( cNumber, "." )

			if nDotPos = 0
				nLenLeft = nSize
				nLenRight = 0

			else
				nLenLeft = nDotPos - 1
				nLenRight = nSize - nDotPos

			ok

			if nLenLeft > nMaxLeft
				nMaxLeft = nLenLeft
			ok

			if nLenRight > nMaxRight
				nMaxRight = nLenRight
			ok
		ok
	next

	nHowManyNumbers = len(anNumbersPos)

	# The numbers without decimal part are adjusted
	# first, by adding a dot and some 0s to them,
	# and then the numbers with dots are adjusted

	for i = 1 to nHowManyNumbers
		nPos = anNumbersPos[i]

		# Early check

		if paList[nPos] = 0
			paList[nPos] = "0."
			loop
		ok

		# In case where the number is not a zero

		cNumber = ""+ paList[nPos]
		nLenNumber = len(cNumber)
		nPosDot = ring_substr1(cNumber, ".")
			
		if nPosDot = 0
				
			nAddLeft = nMaxLeft - nLenNumber
			nAddRight = nMaxRight

			cExtLeft = ""
			cExtRight = ""

			for j = 1 to nAddLeft
				cExtLeft += "0"
			next

			for j = 1 to nAddRight
				cExtRight += "0"
			next

			cNumber = cExtLeft + cNumber + "." + cExtRight

		else
			nAddLeft = nMaxLeft - (nPosDot - 1)
			nAddRight = nMaxRight - (nLenNumber - nPosDot)

			cExtLeft = ""
			cExtRight = ""

			for j = 1 to nAddLeft
				cExtLeft += "0"
			next

			for j = 1 to nAddRight
				cExtRight += "0"
			next

			cNumber = cExtLeft + cNumber + cExtRight

		ok

		paList[nPos] = cNumber

	next

	# Now we stringify the items of the column that
	# are not numbers (usning @@() ~> ComputableForm())

	for i = 1 to nLen
		if NOT isNumber(paList[i])
			paList[i] = @@(paList[i])
			loop
		ok

	next

	return paList

	func @ListStringifyXT(paList)
		return ListStringifyXT(paList)

func SortListsOn(paLists, n)

	# Sorts a list of lists on a given column by justifying
	# all the lists and stringifying any list item inf the
	# nth column ~> Makes it possible to internally use the
	# standard Ring sort(aListOfLits, ncol) function.

	if CheckingParam()

		# Swich params if necessary

		if isNumber(paLists) and isList(n)
			temp = paLists
			paLists = n
			n = temp
		ok

		if NOT ( isList(paLists) and @IsListOfLists(paLists) )
			StzRaise("Incorrect param type! paList must be a list of lists.")
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok
	ok

	# Early check 1 : If there is no lists or only one list

	nLen = len(paLists)
	if nLen = 0
		return []

	but nLen = 1
		return paLists
	ok

	# Early check 2 : If One of the lists is empty

	for i = 1 to nLen
		if len(paLists[i]) = 0
			return @SortList(paLists)
		ok
	next

	# Early check 3 : Using Ring sort() in priority

	if IsRingSortableOn(paLists, n)
		return ring_sort2(paLists, n)
	ok

	# if the nth column contains an object, interrupt the operation

	for i = 1 to nLen
		nLenList = len(paLists[i])

		if nLenList >= n
			if isObject(paLists[i][n])
				StzRaise("Can't proceed! Nth column must not contain objects.")
			ok
		ok
	next

	# In all other cases:

	# Adjust the lists to the largest size using _NULL_s

	oLoL = new stzListOfLists(paLists)
	oLoL.Adjust()

	aColNXT = oLoL.ColXT(n)

	# Ring can't sort on the nth column unless it is made
	# completely either of numbers or strings

	# Check this case and stringify the column

	if NOT ( IsListOfNumbers(aColNXT) or IsListOfStrings(aColNXT) )
		for i = 1 to nLen
			if NOT isString(aColNXT[i])
				aColNXT[i] = @@(aColNXT[i])
			ok
		next
	ok

	# Update the adjusted lists of lists object with
	# the stringified n column

	oLol.ReplaceCol(n, aColNXT)

	# Sort the adjusted lists using Ring native sort()

	aSorted = ring_sort2(oLol.content(), n)
	return aSorted


	#< @FunctionAlternativeForms

	func @SortListsOn(paLists, n)
		return SortListsOn(paLists, n)

	func SortOn(paLists, n)
		return SortListsOn(paLists, n)

	func @SortOn(paLists, n)
		return SortListsOn(paLists, n)

	#>

func @SortList(paList)

	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	# The idea is to separate the items by type
	# and then sort them

	nLen = len(paList)

	if nLen = 0
		return []
	ok
	
	anNumbers = []

	acStrings = []
	nLenNull = 0
	# Null strings are counted and will be put first in the sort

	aaLists   = []
	nLenEmptyLists = 0
	# Empty lists are counted and will be added at the top
	# of sorted lists (there is no need to sort them)

	aoObjects = []

	for i = 1 to nLen
		if isNumber(paList[i])
			anNumbers + paList[i]

		but isString(paList[i])
			if paList[i] = ""
				nLenNull++
			else
				acStrings + paList[i]
			ok

		but isList(paList[i])
			if len(paList[i]) = 0
				nLenEmptyLists++
			else
				aaLists + paList[i]
			ok

		else // isObject()
			aoObjects + paList[i]
		ok
	next

	aResult = []

	nLenNumbers = len(anNumbers)
	nLenStrings = len(acStrings)
	nLenLists = len(aaLists)
	nLenObjects = len(aoObjects)

	# Adding the null values on the top of the result

	for i = 1 to nLenNull
		aResult + ""
	next

	# Sorting the numbers and adding them to the result

	anNumbersSorted = ring_sort(anNumbers)
	for i = 1 to nLenNumbers
		aResult + anNumbersSorted[i]
	next

	# Sorting the (non-null) strings and adding them to the result

	acStringsSorted = ring_sort(acStrings)
	for i = 1 to nLenStrings
		aResult + acStringsSorted[i]
	next

	# Adding the empty lists to the result

	for i = 1 to nLenEmptyLists
		aResult + []
	next

	# Sorting the (other non-empty) lists and adding them to the result

	aaListsSorted = @SortListsOn(aaLists, 1)
	for i = 1 to nLenLists
		aResult + aaListsSorted[i]
	next

	# Sorting the objects and adding them to the result

	for i = 1 to nLenObjects
		aResult + aoObjects[i]
	next

	return aResult


	func SortList(paList)
		return @SortList(paList)

func @Sort(p)
	if NOT (isString(p) or isList(p))
		StzRaise("Incorrect param type! p must be a string or list.")
	ok

	if isString(p)
		return ring_sort(p)

	else // isList()

		if @IsListOfNumbers(p) or @IsListOfStrings(p)
			return ring_sort(p)
		ok

		if @IsListOfLists(p)
			
			# Case where one list is empty

			nLen = len(p)
			for i = 1 to nLen
				if len(p[i]) = 0
					return @SortList(p)
				ok

			next

			# Other cases

			return @SortListsOn(p, 1)

		else
			return @SortList(p)
		ok
	ok

func SortListBy(paList, pcExpr)
	return StzListQ(paList).SortedBy(pcExpr)

	func @SortListBy(paList, pcExpr)
		return SortListBy(paList, pcExpr)

func SortBy(paList, pcExpr)
	if CheckingParams()
		if NOT isList(paList)
			Stzraise("Incorrect param type! paList must be a list.")
		ok
	ok

	return StzListQ(paList).SortedBy(pcExpr)


	func @SortBy(paList, pcExpr)
		return SortBy(paList, pcExpr)

#==========

func Types(paValues)

	if CheckParams()
		if NOT isList(paValues)
			StzRaise("Incorrect param type! paValues must be a list.")
		ok
	ok

	_nLen_ = len(paValues)
	_acResult_ = []

	for @i = 1 to _nLen_
		_acResult_ + type(paValues[@i])
	next

	return _acResult_
	
func TypesXT(paValues)

	if CheckParams()
		if NOT isList(paValues)
			StzRaise("Incorrect param type! paValues must be a list.")
		ok
	ok

	_nLen_ = len(paValues)
	_aResult_ = []

	for @i = 1 to _nLen_
		_aResult_ + [ paValues[@i], type(paValues[@i]) ]
	next

	return _aResult_


#---

func IsSortedList(paList)
	if IsSortedListInAscending(paList) or IsSortedListInDescending(paList)
		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func IsListSorted(paList)
		return IsSortedList(paList)

	#--

	func @IsSortedList(paList)
		return IsSortedList(paList)

	func @IsListSorted(paList)
		return IsSortedList(paList)

	#>

func IsSortedListInAscending(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(palist).IsSortedInAscending()

	#< @FunctionAlternativeForms

	func IsListSortedInAscending(paList)
		return IsSortedListInAscending(paList)

	#--

	func IsSortedListUp(paList)
		return IsSortedListInAscending(paList)

	func IsSortedUpList(paList)
		return IsSortedListInAscending(paList)

	func IsListSortedUp(paList)
		return IsSortedListInAscending(paList)

	#==

	func @IsSortedListInAscending(paList)
		return IsSortedListInAscending(paList)

	func @IsListSortedInAscending(paList)
		return IsSortedListInAscending(paList)

	#--

	func @IsSortedListUp(paList)
		return IsSortedListInAscending(paList)

	func @IsSortedUpList(paList)
		return IsSortedListInAscending(paList)

	func @IsListSortedUp(paList)
		return IsSortedListInAscending(paList)

	#>

func IsSortedListInDescending(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(palist).IsSortedInDescending()

	#< @FunctionAlternativeForms

	func IsListSortedInDescending(paList)
		return IsSortedListInDescending(paList)

	#--

	func IsSortedListDown(paList)
		return IsSortedListInDescending(paList)

	func IsSortedDownList(paList)
		return IsSortedListInDescending(paList)

	func IsListSortedDown(paList)
		return IsSortedListInDescending(paList)

	#==

	func @IsSortedListInDescending(paList)
		return IsSortedListInDescending(paList)

	func @IsListSortedInDescending(paList)
		return IsSortedListInDescending(paList)

	#--

	func @IsSortedListDown(paList)
		return IsSortedListInDescending(paList)

	func @IsSortedDownList(paList)
		return IsSortedListInDescending(paList)

	func @IsListSortedDown(paList)
		return IsSortedListInDescending(paList)

	#>

func IsSortedListOfPairsOfNumbers(paList)
	if NOT IsListOfPairsOfNumbers(paList) and IsSortedList(paList)
		return _FALSE_
	ok

	nLen = len(paList)

	anFirst = []
	for i = 1 to nLen
		anFirst + paList[i][1]
	next

	anSecond = []
	for i = 1 to nLen
		anSecond + paList[i][2]
	next

	oList1 = new stzList(anFirst)
	oList2 = new stzList(anSecond)

	if ( oList1.IsSortedInAscending() and oList2.IsSortedInAscending() ) or
	   ( oList2.IsSortedInDescending() and oList2.IsSortedInDescending() )

		return _TRUE_
	else
		return _FALSE_
	ok

	func @IsSortedListOfPairsOfNumbers(paList)
		return IsSortedListOfPairsOfNumbers(paList)

func IsSortedUpListOfPairsOfNumbers(paList)
	if NOT IsListOfPairsOfNumbers(paList) and IsSortedInAscending(paList)
		return _FALSE_
	ok

	nLen = len(paList)

	anFirst = []
	for i = 1 to nLen
		anFirst + paList[i][1]
	next

	anSecond = []
	for i = 1 to nLen
		anSecond + paList[i][2]
	next

	oList1 = new stzList(anFirst)
	oList2 = new stzList(anSecond)

	if oList1.IsSortedInAscending() and oList2.IsSortedInAscending()
		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func IsSortedInAscendingListOfPairsOfNumbers(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	func IsListOfPairsOfNumbersSortedInAscending(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	func IsListOfPairsOfNumbersSortedUp(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	#==

	func @IsSortedUpListOfPairsOfNumbers(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	func @IsSortedInAscendingListOfPairsOfNumbers(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	func @IsListOfPairsOfNumbersSortedInAscending(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	func @IsListOfPairsOfNumbersSortedUp(paList)
		return IsSortedUpListOfPairsOfNumbers(paList)

	#>

func IsSortedDownListOfPairsOfNumbers(paList)

	if NOT IsListOfPairsOfNumbers(paList) and IsSortedInDescending(paList)
		return _FALSE_
	ok

	nLen = len(paList)

	anFirst = []
	for i = 1 to nLen
		anFirst + paList[i][1]
	next

	anSecond = []
	for i = 1 to nLen
		anSecond + paList[i][2]
	next

	oList1 = new stzList(anFirst)
	oList2 = new stzList(anSecond)

	if oList1.IsSortedInDescending() and oList2.IsSortedInDescending()
		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func IsSortedInDescendingListOfPairsOfNumbers(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	func IsListOfPairsOfNumbersSortedInDescending(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	func IsListOfPairsOfNumbersSortedDown(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	#==

	func @IsSortedDownListOfPairsOfNumbers(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	func @IsSortedInDescendingListOfPairsOfNumbers(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	func @IsListOfPairsOfNumbersSortedInDescending(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	func @IsListOfPairsOfNumbersSortedDown(paList)
		return IsSortedDownListOfPairsOfNumbers(paList)

	#>

func IsListOfNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfNumbers(paList)
		return IsListOfNumbers(paList)

	func IsAListOfNumbers(paList)
		return IsListOfNumbers(paList)

	func @IsAListOfNumbers(paList)
		return IsListOfNumbers(paList)

	#>

func IsSortedListOfNumbers(paList)
	if IsListOfNumbers(paList) and IsSorted(paList)
		return _TRUE_
	else
		return _FALSE_

	ok

func IsListOfNumbersSortedInAscending(paList)
	if IsListOfNumbers(paList) and IsSortedInAscending(paList)
		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func IsListOfNumbersSortedUp(paList)
		return IsListOfNumbersSortedInAscending(paList)

	func IsSortedUpListOfNumbers(paList)
		return IsListOfNumbersSortedInAscending(paList)

	func IsSortedInAscendingListOfNumbers(paList)
		return IsListOfNumbersSortedInAscending(paList)

	#>

func IsListOfNumbersSortedInDesending(paList)
	if IsListOfNumbers(paList) and IsSortedInDescending(paList)
		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func IsListOfNumbersSortedDown(paList)
		return IsListOfNumbersSortedInDescending(paList)

	func IsSortedDownListOfNumbers(paList)
		return IsListOfNumbersSortedInDescending(paList)

	func IsSortedInDescendingListOfNumbers(paList)
		return IsListOfNumbersSortedInDescending(paList)

	#>

func IsListOfListsOfNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	func IsAListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	func @IsAListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	#>

func IsListOfDecimalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	func IsAListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	func @IsAListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	#>

func IsListOfListsOfDecimalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	func IsAListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	func @IsAListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	#>

func IsListOfBinaryNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	func IsAListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	func @IsAListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	#>

func IsListOfListsOfBinaryNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	func IsAListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	func @IsAListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	#>

func IsListOfOctalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	func IsAListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	func @IsAListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	#>

func IsListOfListsOfOctalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	func IsAListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	func @IsAListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	#>

func IsListOfHexNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	func IsAListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	func @IsAListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	#>

func IsListOfListsOfHexNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	func IsAListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	func @IsAListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	#>

func IsListOfStrings(paList)
	#TODO
	# Use this implementation of all IsListOf...() functions
	# ~> More performant then usign stzObjects
	
	if NOT isList(paList)
		return _FALSE_
	ok

	bResult = _TRUE_
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isString(paList[i])
			bResult = _FALSE_
			exit
		ok
	next

	return bResult

	#< @FunctionAlternativeForms

	func @IsListOfStrings(paList)
		return IsListOfStrings(paList)

	func IsAListOfStrings(paList)
		return IsListOfStrings(paList)

	func @IsAListOfStrings(paList)
		return IsListOfStrings(paList)

	#>

	#< @FunctionMisspelledForm

	func @IsListOfSttrings(paList)
		return IsListOfStrings(paList)

	#>

func IsListOfListsOfStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	func IsAListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	func @IsAListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	#>

func IsListOfLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	bResult = _TRUE_
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isList(paList[i])
			bResult = _FALSE_
			exit
		ok
	next

	return bResult

	#< @FunctionAlternativeForms

	func @IsListOfLists(paList)
		return IsListOfLists(paList)

	func IsAListOfLists(paList)
		return IsListOfLists(paList)

	func @IsAListOfLists(paList)
		return IsListOfLists(paList)

	#>

func IsListOfHybridLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfHybridLists()

	#< @FunctionAlternativeForms

	func @IsListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	func IsAListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	func @IsAListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	#>

func IsListOfListsOfHybridLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfHybridLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	func IsAListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	func @IsAListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	#>

func IsListOfListsOfLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	func IsAListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	func @IsAListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	#>

func IsListOfObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	bResult = _TRUE_
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isObject(paList[i])
			bResult = _FALSE_
			exit
		ok
	next

	return bResult

	return StzListQ(paList).IsListOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfObjects(paList)
		return IsListOfObjects(paList)

	func IsAListOfObjects(paList)
		return IsListOfObjects(paList)

	func @IsAListOfObjects(paList)
		return IsListOfObjects(paList)

	#>

func IsListOfListsOfObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	func IsAListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	func @IsAListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	#>

func IsListOfChars(pacList)
	if NOT isList(pacList)
		return _FALSE_
	ok

	return StzListQ(pacList).IsListOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfChars(paList)
		return IsListOfChars(paList)

	func IsAListOfChars(paList)
		return IsListOfChars(paList)

	func @IsAListOfChars(paList)
		return IsListOfChars(paList)

	#>

func IsListOfListsOfChars(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	func IsAListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	func @IsAListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	#>

func IsListOfPairs(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairs()

	#< @FunctionAlternativeForms

	func @IsListOfPairs(paList)
		return IsListOfPairs(paList)

	func IsAListOfPairs(paList)
		return IsListOfPairs(paList)

	func @IsAListOfPairs(paList)
		return IsListOfPairs(paList)

	#>

func IsListOfListsOfPairs(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfPairs()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	func IsAListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	func @IsAListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	#>

func IsListOfSets(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfSets()

	#< @FunctionAlternativeForms

	func @IsListOfSets(paList)
		return IsListOfSets(paList)

	func IsAListOfSets(paList)
		return IsListOfSets(paList)

	func @IsAListOfSets(paList)
		return IsListOfSets(paList)

	#>

func IsListOfListsOfSets(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfSets()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	func IsAListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	func @IsAListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	#>

func IsListOfHashLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfHashLists(paList)
		return IsListOfHashLists(paList)

	func IsAListOfHashLists(paList)
		return IsListOfHashLists(paList)

	func @IsAListOfHashLists(paList)
		return IsListOfHashLists(paList)

	#>

func IsListOfListsOfHashLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	func IsAListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	func @IsAListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	#>

func IsListOfGrids(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfGrids()

	#< @FunctionAlternativeForms

	func @IsListOfGrids(paList)
		return IsListOfGrids(paList)

	func IsAListOfGrids(paList)
		return IsListOfGrids(paList)

	func @IsAListOfGrids(paList)
		return IsListOfGrids(paList)

	#>

func IsListOfListsOfGrids(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfGrids()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	func IsAListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	func @IsAListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	#>

func IsListOfTables(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfTables()

	#< @FunctionAlternativeForms

	func @IsListOfTables(paList)
		return IsListOfTables(paList)

	func IsAListOfTables(paList)
		return IsListOfTables(paList)

	func @IsAListOfTables(paList)
		return IsListOfTables(paList)

	#>

func IsListOfListsOfTables(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfTables()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	func IsAListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	func @IsAListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	#>

func IsListOfTrees(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfTrees()

	#< @FunctionAlternativeForms

	func @IsListOfTrees(paList)
		return IsListOfTrees(paList)

	func IsAListOfTrees(paList)
		return IsListOfTrees(paList)

	func @IsAListOfTrees(paList)
		return IsListOfTrees(paList)

	#>

func IsListOfListsOfTrees(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfTrees()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	func IsAListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	func @IsAListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	#>

func IsListOfStzNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	func IsAListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	func @IsAListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	#>

func IsListOfListsOfStzNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	func IsAListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	func @IsAListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	#>

func IsListOfStzDecimalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	func IsAListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	func @IsAListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	#>

func IsListOfListsOfStzDecimalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	func IsAListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	func @IsAListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	#>

func IsListOfStzBinaryNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	func IsAListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	func @IsAListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	#>

func IsListOfListsOfStzBinaryNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	func IsAListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	func @IsAListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	#>

func IsListOfStzOctalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	func IsAListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	func @IsAListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	#>

func IsListOfListsOfStzOctalNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	func IsAListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	func @IsAListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	#>

func IsListOfStzHexNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	func IsAListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	func @IsAListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	#>

func IsListOfListsOfStzHexNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	func IsAListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	func @IsAListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	#>

func IsListOfStzStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	func IsAListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	func @IsAListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	#>

func IsListOfListsOfStzStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	func IsAListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	func @IsAListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	#>

func IsListOfStzLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok
	return StzListQ(paList).IsListOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfStzLists(paList)
		return IsListOfStzLists(paList)

	func IsAListOfStzLists(paList)
		return IsListOfStzLists(paList)

	func @IsAListOfStzLists(paList)
		return IsListOfStzLists(paList)

	#>

func IsListOfListsOfStzLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	func IsAListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	func @IsAListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	#>

func IsListOfStzObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	func IsAListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	func @IsAListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	#>

func IsListOfListsOfStzObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	func IsAListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	func @IsAListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	#>

func IsListOfStzChars(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzChars()

	#< @FunctionAlternativeForms

	func @IsListOfStzChars(paList)
		return IsListOfStzChars(paList)

	func IsAListOfStzChars(paList)
		return IsListOfStzChars(paList)

	func @IsAListOfStzChars(paList)
		return IsListOfStzChars(paList)

	#>

func IsListOfListsOfStzChars(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzChars()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	func IsAListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	func @IsAListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	#>

func IsListOfStzPairs(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzPairs()

	#< @FunctionAlternativeForms

	func @IsListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	func IsAListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	func @IsAListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	#>

func IsListOfListsOfStzPairs(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzPairs()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	func IsAListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	func @IsAListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	#>

func IsListOfStzSets(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzSets()

	#< @FunctionAlternativeForms

	func @IsListOfStzSets(paList)
		return IsListOfStzSets(paList)

	func IsAListOfStzSets(paList)
		return IsListOfStzSets(paList)

	func @IsAListOfStzSets(paList)
		return IsListOfStzSets(paList)

	#>

func IsListOfListsOfStzSets(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzSets()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	func IsAListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	func @IsAListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	#>

func IsListOfStzHashLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	func IsAListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	func @IsAListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	#>

func IsListOfListsOfStzHashLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	func IsAListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	func @IsAListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	#>

func IsListOfStzGrids(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzGrids()

	#< @FunctionAlternativeForms

	func @IsListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	func IsAListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	func @IsAListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	#>

func IsListOfListsOfStzGrids(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzGrids()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	func IsAListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	func @IsAListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	#>

func IsListOfStzTables(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzTables()

	#< @FunctionAlternativeForms

	func @IsListOfStzTables(paList)
		return IsListOfStzTables(paList)

	func IsAListOfStzTables(paList)
		return IsListOfStzTables(paList)

	func @IsAListOfStzTables(paList)
		return IsListOfStzTables(paList)

	#>

func IsListOfListsOfStzTables(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzTables()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	func IsAListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	func @IsAListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	#>

func IsListOfStzTrees(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzTrees()

	#< @FunctionAlternativeForms

	func @IsListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	func IsAListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	func @IsAListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	#>

func IsListOfListsOfStzTrees(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfStzTrees()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	func IsAListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	func @IsAListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	#>

#===

func IsUniformList(paList) # Is made of the same item
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsUniform()

func IsDeepList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsDeep()

	#< @FunctionAlternativeForms

	func @IsDeepList(paList)
		return IsDeepList(paList)

	func IsADeepList(paList)
		return IsDeepList(paList)

	func @IsADeepList(paList)
		return IsDeepList(paList)

	#>

func IsHybridList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsHybridList()

	#< @FunctionAlternativeForms

	func @IsHybridList(paList)
		return IsHybridList(paList)

	func IsAHybridList(paList)
		return IsHybridList(paList)

	func @IsAHybridList(paList)
		return IsHybridList(paList)

	#>

func IsPureList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsPureList()

	#< @FunctionAlternativeForms

	func @IsPureList(paList)
		return IsPureList(paList)

	func IsAPureList(paList)
		return IsPureList(paList)

	func @IsAPureList(paList)
		return IsPureList(paList)

	#>

func IsOddList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsOdd()

	#< @FunctionAlternativeForms

	func @IsOddList(paList)
		return IsOddList(paList)

	func IsAOddList(paList)
		return IsOddList(paList)

	func @IsAOddList(paList)
		return IsOddList(paList)

	#--

	func IsFardiList(paList)
		return IsOddList(paList)

	func IsAFardiList(paList)
		return IsOddList(paList)

	func @IsFardiList(paList)
		return IsOddList(paList)

	func @IsAFardiList(paList)
		return IsOddList(paList)

	#>

func IsEvenList()
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsEven()

	#< @FunctionAlternativeForms

	func @IsEvenList(paList)
		return IsEvenList(paList)

	func IsAEvenList(paList)
		return IsEvenList(paList)

	func @IsAEvenList(paList)
		return IsEvenList(paList)

	#--

	func IsZawjiList(paList)
		return IsOddList(paList)

	func IsAZawjiList(paList)
		return IsOddList(paList)

	func @IsZawjiList(paList)
		return IsOddList(paList)

	func @IsAZawjiList(paList)
		return IsOddList(paList)

	#>

func IsListOfBits(paLists)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfBits()

	#< @FunctionAlternativeForms

	func @IsListOfBits(paList)
		return IsListOfBits(paList)

	func IsAListOfBits(paList)
		return IsListOfBits(paList)

	func @IsAListOfBits(paList)
		return IsListOfBits(paList)

	#>

func IsListOfZerosAndOnes(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfZerosAndOnes()

	#< @FunctionAlternativeForms

	func @IsListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	func IsAListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	func @IsAListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	#>


#===

func IsListOfLetters(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfLetters()

	#< @FunctionAlternativeForms

	func @IsListOfLetters(paList)
		return IsListOfLetters(paList)

	func IsAListOfLetters(paList)
		return IsListOfLetters(paList)

	func @IsAListOfLetters(paList)
		return IsListOfLetters(paList)

	#>

func IsListOfQBytesLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfQBytesLists()

	#< @FunctionAlternativeForms

	func @IsListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	func IsAListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	func @IsAListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	#>

func IsListOfStzListOfBytes(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStzListOfBytes()

	#< @FunctionAlternativeForms

	func @IsListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	func IsAListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	func @IsAListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	#>

func IsListOfNumbersInStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	_nLen_ = len(paList)

	for @i = 1 to _nLen
		if NOT isString(paList[@i])
			return _FALSE_
		ok

		if NOT @IsNumberInString(paList[@i])
			return _FALSE_
		ok
	next

	return _TRUE_

	#NOTE // Make all functions independent form Softanza classes

	#< @FunctionAlternativeForms

	func @IsListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	func IsAListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	func @IsAListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	#>

func IsListOfNumbersOrStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNumbersOrStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	func IsAListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	func @IsAListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	#>

func IsListOfNumbersAndStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNumbersAndStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	func IsAListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	func @IsAListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	#>

func IsListOfNumbersOrListOfStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNumbersOrListOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	func IsAListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	func @IsAListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	#--

	func IsListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func @IsListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func IsAListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func @IsAListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	#>

func IsListOfStringsAndPairsOfStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfStringsAndPairsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	func IsAListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	func @IsAListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	#>

func IsListOfNumbersAndPairsOfNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNumbersAndPairsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	func IsAListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	func @IsAListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	#>

func IsListOfListsAndPairsOfLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsAndPairsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	func IsAListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	func @IsAListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	#>

func IsListOfObjectsAndPairsOfObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfObjectsAndPairsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	func IsAListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	func @IsAListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	#>

func IsPairOfStrings(paPair)
	if isList(paPair) and len(paPair) = 2 and
	   isString(paPair[1]) and isString(paPair[2])

		return _TRUE_
	else
		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	func IsAPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	func @IsAPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	#>

func IsListOfPairsOfStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	func IsAListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	func @IsAListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	#>

func IsPairOfNumbers(paPair)
	if isList(paPair) and len(paPair) = 2 and
	   isNumber(paPair[1]) and isNumber(paPair[2])

		return _TRUE_
	else

		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	func IsAPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	func @IsAPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	#>

func IsListOfPairsOfNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	func IsAListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsAListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	#--

	func IsListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func IsAListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsAListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	#>

func IsPairOfSections(paPair)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzPairQ(paPair).IsPairOfSections()

	#< @FunctionAlternativeForms

	func @IsPairOfSections(paPair)
		return IsPairOfSections(paPair)

	func IsAPairOfSections(paPair)
		return IsPairOfSections(paPair)

	func @IsAPairOfSections(paPair)
		return IsPairOfSections(paPair)

	#>

func IsListOfPairsOfSections(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfSections()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	func IsAListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	func @IsAListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	#>

func IsPairOfLists(paPair)
	if isList(paList) and len(paList) = 2 and
	   isList(paList[1]) and isList(paList[2])

		return _TRUE_
	else

		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfLists(paPair)
		return IsPairOfLists(paPair)

	func IsAPairOfLists(paPair)
		return IsPairOfLists(paPair)

	func @IsAPairOfLists(paPair)
		return IsPairOfLists(paPair)

	#>

func IsListOfPairsOfLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	func IsAListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	func @IsAListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	#>

func IsPairOfObjects(paPair)
	if isList(paList) and len(paList) = 2 and
	   isObject(paList[1]) and isObject(paList[2])

		return _TRUE_
	else

		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	func IsAPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	func @IsAPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	#>

func IsListOfPairsOfObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	func IsAListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	func @IsAListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	#>

func IsPairAndKeyIsString(paList)
	if isList(paList) and len(paList) = 2 and
	   isString(paList[1])

		return _TRUE_
	else

		return _FALSE_
	ok

	#< @FunctionAlternativeForms

	func @IsPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	func IsAPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	func @IsAPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	#>

func IsPairOfStzObjects(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	func IsAPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	func @IsAPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	#>

func IsListOfPairsOfStzObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	func IsAListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	func @IsAListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	#>

func IsPairOfStzNumbers(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	func IsAPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	func @IsAPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	#>

func IsListOfPairsOfStzNumbers(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	func IsAListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	func @IsAListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	#>

func IsPairOfStzStrings(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	func IsAPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	func @IsAPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	#>

func IsListOfPairsOfStzStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	func IsAListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	func @IsAListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	#>

func IsPairOfStzLists(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStzLists()

	#< @FunctionAlternativeForms

	func @IsPairOfStzLists(paList)
		return IsPairOfStzLists(paList)

	func IsAPairOfStzLists(paList)
		return IsPairOfStzLists(paPair)

	func @IsAPairOfStzLists(paPair)
		return IsPairOfStzLists(paList)

	#>

func IsListOfPairsOfStzLists(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	func IsAListOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	func @IsALitsOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	#>

func IsPairOfNumberAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfNumberAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	func IsAPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	func @IsAPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	#>

func IsListOfPairsOfNumberAndString(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	func IsAListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	func @IsAListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	#>

func IsPairOfStringAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStringAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	func IsAPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	func @IsAPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	#>

func IsListOfPairsOfStringAndNumber(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	func IsAListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	func @IsAListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	#>

func IsPairOfNumberAndList(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfNumberAndList()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	func IsAPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	func @IsAPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	#>

func IsListOfPairsOfNumberAndList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndList()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	func IsAListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	func @IsAListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	#>

func IsPairOfListAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfListAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	func IsAPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	func @IsAPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	#>

func IsListOfPairsOfListAndNumber(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfListAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	func IsAListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	func @IsAListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	#>

func IsPairOfNumberAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfNumberAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	func IsAPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	func @IsAPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	#>

func IsListOfPairsOfNumberAndObject(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	func IsAListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	func @IsAListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	#>

func IsPairOfObjectAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfObjectAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	func IsAPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	func @IsAPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	#>

func IsListOfPairsOfObjectAndNumber(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfObjectAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	func IsAListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	func @IsAListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	#>

func IsPairOfStringAndList(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStringAndList()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndList(paList)
		return IsPairOfStringAndList(paList)

	func IsAPairOfStringAndList(paList)
		return IsPairOfStringAndList(paList)

	func @IsAPairOfStringAndList(paPair)
		return IsPairOfStringAndList(paPair)

	#>

func IsListOfPairsOfStringAndList(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndList()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	func IsAListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	func @IsAListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	#>

func IsPairOfListAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfListAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	func IsAPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	func @IsAPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	#>

func IsListOfPairsOfListAndString(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfListAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	func IsAListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	func @IsAListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	#>

func IsPairOfStringAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfStringAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	func IsAPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	func @IsAPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	#>

func IsListOfPairsOfStringAndObject(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	func IsAListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	func @IsAListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	#>

func IsPairOfObjectAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfObjectAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	func IsAPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	func @IsAPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	#>

func IsListOfPairsOfObjectAndString(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfObjectAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	func IsAListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	func @IsAListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	#>

func IsPairOfListAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzListQ(paList).IsPairOfListAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	func IsAPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	func @IsAPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	#>

func IsListOfPairsOfListAndObject(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfPairsOfListAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndObject(paList)
		return IsListOfPairsOfListAndObject(paList)

	func IsAListOfPairsOfListAndObject(paList)
		return IsListOfPairsOfListAndObject(paList)

	func @IsAListOfPairsOfListAndObject(paPair)
		return IsListOfPairsOfListAndObject(paList)

	#>

func IsPairOfChars(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return _FALSE_
	ok

	return StzPairQ(paList).IsPairOfChars()

	#< @FunctionAlternativeForms

	func @IsPairOfChars(paList)
		return IsPairOfChars(paList)

	func IsAPairOfChars(paList)
		return IsPairOfChars(paList)

	func @IsAPairOfChars(paList)
		return IsPairOfChars(paList)

	#>

func IsListOfPairsOfChars(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzPairQ(paList).IsListOfPairsOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfChars(paList)
		return IsListOfPairsOfChars(paList)

	func IsAListOfPairsOfChars(paList)
		return IsListOfPairsOfChars(paList)

	func @IsAListOfPaisrOfChars(paList)
		return IsListOfPairsOfChars(paList)

	#>

func IsPairOfEmptyLists(paList)
	if isList(paList) and len(paList) = 2 and
	   isList(paList[1]) and len(paList[1]) = 0 and
	   isList(paList[2]) and len(paList[2]) = 0

		return _TRUE_
	else
		return _FALSE_
	ok

	func IsAPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

	func @IsPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

	func @IsAPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

func IsPairOf(pcType, paPair)
	if NOT ( isList(paPair) and len(paPair) = 2 )
		return _FALSE_
	ok

	return StzPairQ(paPair).IsPairOf(pcType)

	#< @FunctionAlternativeForms

	func @IsPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	func IsAPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	func @IsAPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	#>

func IsListOf(pcType, paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOf(pcType)

	#< @FunctionAlternativeForms

	func @IsListOf(pcType, paList)
		return IsListOf(pcType, paList)

	func IsAListOf(pcType, paList)
		return IsListOf(pcType, paList)

	func @IsAListOf(pcType, paList)
		return IsListOf(pcType, paList)

	#>

func IsListOfNamedObjects(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfNamedObjects()

	#< @FunctionAlternativeForms

	func @IsListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	func IsAListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	func @IsAListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	#>

func IsHashListOrListOfStrings(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsHashListOrListOfStrings()

	#< @FunctionAlternativeForms

	func @IsHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	func IsAHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	func @IsAHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	#>

func IsListOfStringsOrPairsOfStrings(paList)

	if NOT isList(paList)
		StzRaise("Incorrect param type! paList must be a list.")
	ok

	nLen = len(paList)
	if nLen = 0
		return _FALSE_
	ok

	bResult = _TRUE_

	for i = 1 to nLen
		if NOT ( isString(paList[i]) or @IsPairOfStrings(paList[i]) )
			bResult = _FALSE_
			exit
		ok
	next

	return bResult

	func @IsListOfStringsOrPairsOfStrings(paList)
		return IsListOfStringsOrPairsOfStrings(paList)

func IsListOfListsOfSameSize(paList)
	if NOT isList(paList)
		return _FALSE_
	ok

	return StzListQ(paList).IsListOfListsOfSameSize()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	func IsAListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	func @IsAListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	#>

func IsListInString(cStr)
	bResult = StzStringQ(cStr).IsListInString()
	return bResult

	func IsAListInString(cStr)
		return IsListInString(cStr)

	func @IsListInString(cStr)
		return IsListInString(cStr)

	func @IsAListInString(cStr)
		return IsListInString(cStr)


#===

func ListStringify(paList)
	return StzListQ(paList).Stringified()

func Stringify(p)
	return Q(p).Stringified()

	func @Stringify(p)
		return Stringify(p)

	func @string(p)
		return Stringify(p)

func Spacify(str)
	cResult = StzStringQ(str).Spacified()
	return cResult

	func @Spacify(str)
		return Spacify(str)

func SpacifyXT(str, pSep, pStep, pDirection)
	cResult = StzStringQ(str).SpacifyXTQ(pSep, pStep, pDirection).Content()
	return cResult

	func @SpacifyXT(str, pSep, pStep, pDirection)
		return SpacifyXT(str, pSep, pStep, pDirection)

#===

func StzNamedList(paNamed)
	if CheckingParams()
		if NOT (isList(paNamed) and Q(paNamed).IsPairOfStringAndList())
			StzRaise("Incorrect param type! paNamed must be a pair of string and list.")
		ok
	ok

	oList = new stzList(paNamed[2])
	oList.SetName(paNamed[1])
	return oList

	func StzNamedListQ(paNamed)
		return StzNamedList(paNamed)

	func StzNamedListXTQ(paNamed)
		return StzNamedList(paNamed)

func StzListMethods()
	return Stz(:List, :Methods)

func StzListAttributes()
	return Stz(:List, :Attributes)

func StzListClassName()
	return "stzlist"

	func StzListClass()
		return "stzlist"

func OnlyNumbers(paList)
	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	anResult = []

	for i = 1 to nLen
		if isNumber(paList[i])
			anResult + paList[i]
		ok
	next

	return anResult


	func @OnlyNumbers(paList)
		return OnlyNumbers(paList)

	func OnlyNumbersIn(paList)
		return OnlyNumbers(paList)

	func @OnlyNumbersIn(paList)
		return OnlyNumbers(paList)

#TODO // Add OnlyStrings() and cie...

def Flatten(paList)
	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []
	aTemp = []

	for i = 1 to nLen
		if isList(paList[i])
			aTemp = Flatten(paList[i]) # A recursive call
			nLenTemp = len(aTemp)

			for j = 1 to nLenTemp
				aResult + aTemp[j]
			next
		else
			aResult + paList[i]
		ok
	next

	return aResult

	func ListFlatten(paList)
		return Flatten(paList)

	func @Flatten(paList)
		return Flatten(paList)

func ListReverse(paList)
	return reverse(paList) # Here we rely on the native Ring reverse() function

	func ListInverse(paList)
		return reverse(paList)

	#NOTE // we have a more general function called @Reverse()
	# that reverses strings and lists. We made it because Ring
	# standard reverse() is not UNICODE-aware.

func @Reverse(p)
	if isString(p)
		if NOT @IsPalindrome(p)
			p = StzStringQ(p).Reversed()
		ok

		return p

	but isList(p)

		if NOT isPalindrom(p)
			p = ring_reverse(p)
		ok

		return p
		
	else
		StzRaise("Incorrect param type! p must be a string or list.")
	ok

func ListFirstItem(paList)
	return paList[1]

	#< @AlternativeFunctionNames

	func FirstItem(paList)
		return ListFirstItem(paList)

	func FirstItemIn(paList)
		return ListFirstItem(paList)

	func FirstItemInList(paList)
		return ListFirstItem(paList)

	#---

	func @FirstItem(paList)
		return ListFirstItem(paList)

	func @FirstItemIn(paList)
		return ListFirstItem(paList)

	func @FirstItemInList(paList)
		return ListFirstItem(paList)

	#>

func ListLastItem(paList)
	return paList[ len(paList) ]

	#< @AlternativeFunctionNames

	func LastItem(paList)
		return ListLastItem(paList)

	func LastItemIn(paList)
		return ListLastItem(paList)

	func LastItemInList(paList)
		return ListLastItem(paList)

	#---

	func @LastItem(paList)
		return ListLastItem(paList)

	func @LastItemIn(paList)
		return ListLastItem(paList)

	func @LastItemInList(paList)
		return ListLastItem(paList)

	#>

func UpdateLastItem(paList, pValue)
	oTempList = new stzList(paList)
	return oTempList.UpdateLastItem(pValue)

func FirstListIn(paList)
	oTempList = new stzList(paList)
	return LastItemIn( oTempList.WalkUntilItemIsList() )

func GenerateListAccessCode_FromNameAndPath(pcListName, paPath)
	// Warining: aPath must contain only numbers!!!
	cCode = pcListName
	for n in paPath
		cCode += ("["+ n + ']')
	next

	return cCode

func ListItemsAreAllStrings(paList)
	oTempList = new stzList(paList)
	return oTempList.ItemsAreAllStrings()

	func ItemsAreAllStrings(paList)
		return ListItemsAreAllStrings()

	func @ItemsAreAllStrings(paList)
		return ListItemsAreAllStrings()

	func AllItemsAreStrings(paList)
		return ListItemsAreAllStrings(paList)

	func @AllItemsAreStrings(paList)
		return ListItemsAreAllStrings(paList)

func IsLocaleList(paList)
	return StzListQ(paList).IsLocaleList()

	def @IsLocaleList(paList)
		return This.StzListQ(paList).IsLocaleList()

#===

# Calling a given method on many objects and get their output in a list

func CallMethod( pcMethod, paOnObjects )

	if NOT ( paOnObjects[1] = "on" and StzListQ(paOnObjects[2]).IsListOfStrings() )
		StzRaise(stzObjectError(:CanNotProcessMethodCall))
	ok

	aResult = []
	for cObjName in paOnObjects[2]
		cCode = "aResult + " + cObjName + "." + pcMethod
		eval(cCode)
	next
	return aResult

#====

func AreBothEqualCS(p1, p2, pCaseSensitive)

	if NOT type(p1) = type(p2)
		return _FALSE_
	ok

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
		StzRaise("Incorrect param! pCaseSensitive must be _TRUE_ or _FALSE_.")
	ok

	if isNumber(p1)
		return p1 = p2

	but isString(p1)

		if pCaseSensitive = _FALSE_
			p1 = lower(p1)
			p2 = lower(p2)
		ok

		return p1 = p2

	else
		return Q(p1).IsEqualToCS(p2, pCaseSensitive)
	ok

	#< @FunctionAlternativeForms

	func BothAreEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	func @AreBothEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	func @BothAreEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	#>

	#< @FunctionNegativeForms

	func BothAreNotEqualCS(p1, p2, pCaseSensitive)
		return NOT AreBothEqualCS(p1, p2, pCaseSensitive)

	func @AreNotBothEqualCS(p1, p2, pCaseSensitive)
		return BothAreNotEqualCS(p1, p2, pCaseSensitive)

	func @BothAreNotEqualCS(p1, p2, pCaseSensitive)
		return BothAreNotEqualCS(p1, p2, pCaseSensitive)

	#>

#-- WITHOUT CASESENSITIVITY

func AreBothEqual(p1, p2)
	return AreBothEqualCS(p1, p2, _TRUE_)

	#< @FunctionAlternativeForms

	func BothAreEqual(p1, p2)
		return AreBothEqual(p1, p2)

	func @AreBothEqual(p1, p2)
		return AreBothEqual(p1, p2)

	func @BothAreEqual(p1, p2)
		return AreBothEqual(p1, p2)

	#>

	#< @FunctionNegativeForms

	func BothAreNotEqual(p1, p2)
		return NOT AreBothEqual(p1, p2)

	func @AreNotBothEqual(p1, p2)
		return BothAreNotEqual(p1, p2)

	func @BothAreNotEqual(p1, p2)
		return BothAreNotEqual(p1, p2)

	#>


#===

func AreEqualCS(paValues, pCaseSensitive)
	if NOT isList(paValues)
		StzRaise("Incorrect param type! paValues must be a list.")
	ok

	#NOTE
	# A beautiful way to solve it the Softanza way:

	if StzListQ(paValues).
	   RemoveDuplicatesCSQ(pCaseSensitive).
	   NumberOfItems() = 1

		return _TRUE_
	else
		return _FALSE_
	ok

	#NOTE //~> I left the old code commented so you can see
	# how mutch Softanza can optimise the codebase
	# at each refactoring

	/*--- START OF OLD UNUSED CODE

	if NOT isList(paValues)
		return _FALSE_
	ok

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
		StzRaise("Incorrect param! pCaseSensitive must be _TRUE_ or _FALSE_.")
	ok

	# Early checks

	nLen = len(paValues)
	if nLen = 0
		return _FALSE_
	but nLen = 1
		return _TRUE_
	ok

	# Doing the job

	bResult = _TRUE_

	if IsNumber(paValues[1])

		for i = 2 to nLen
			if paValues[i] != paValues[1]
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

	but isString(paValues[1])
		if pCaseSensitive = _FALSE_
			for i = 1 to nLen
				paValues[i] = lower(paValues[i])
			next
		ok

		for i = 2 to nLen
			if paValues[i] != paValues[1]
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

	but isObject(paValues[1])
		return @AreEqualObjects(paValues)

	else

		for i = 2 to nLen

			if NOT Q(paValues[i]).IsEqualToCS(paValues[1], pCaseSensitive)
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

	ok

	--- END OF OLD UNUSED CODE
	*/

	#< @FunctionAlternativeForms

	func @AreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func AreAllEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func @AreAllEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func AllAreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func @AllAreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	#>

	#< @FunctionNegativeForms

	func AreNotEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AreNotEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	func AreNotAllEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AreNotAllEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	func AllAreNotEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AllAreNotEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	#>

#-- WITHOUT CASESENSITIVITY

func AreEqual(paValues)
	return AreEqualCS(paValues, _TRUE_)

	#< @FunctionAlternativeForm

	func @AreEqual(paValues)
		return AreEqual(paValues)

	func AreAllEqual(paValues)
		return AreEqual(paValues)

	func @AreAllEqual(paValues)
		return AreEqual(paValues)

	func AllAreEqual(paValues)
		return AreEqual(paValues)

	func @AllAreEqual(paValues)
		return AreEqualCS(paValues)

	#>

	#< @FunctionNegativeForms

	func AreNotEqual(paValues)
		return NOT AreEqual(paValues)

	func @AreNotEqual(paValues)
		return AreNotEqual(paValues)

	func AreNotAllEqual(paValues)
		return AreNotEqual(paValues)

	func @AreNotAllEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	func AllAreNotEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	func @AllAreNotEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	#>

#===

func HaveSameType(paItems)
	if NOT isList(paItems)
		StzRaise("Incorrect param type! paItems must be a list.")
	ok

	nLen = len(paItems)
	if nLen = 0
		return _FALSE_
	but nLen = 1
		return _TRUE_
	ok

	# Case nLen >= 2

	bResult = _TRUE_
	for i = 2 to nLen
		if ring_type( paItems[1] ) != ring_type( paItems[i] )
			bResult = _FALSE_
			exit
		ok
	next
	return bResult

	func @HaveSameType(paItems)
		return HaveSameType(paItems)

	func AllHaveSameType(paItems)
		return HaveSameType(paItems)

	func @AllHaveSameType(paItems)
		return HaveSameType(paItems)

func BothHaveSameType(p1, p2)
	return ring_type(p1) = ring_type(p2)

func HaveSameContent(paItems)
	/* Two items have same content when:
	 if they are stringified they are equal strings.

	Stringifying number 12 generate string "12"
	*/
	if NOT isList(paItems)
		StzRaise("Incorrect param type! paItems must be a list.")
	ok

	if len(paItems) = 1
		return _TRUE_
	ok

	bResult = _TRUE_
	for i = 2 to len(paItems)
		bOk = Q( @@( paItems[i] ) ).IsEqualTo( @@( paItems[1] ) )
		if NOT bOk
			bResult = _FALSE_
			exit
		ok
	next
	return bResult

	func @HaveSameContent(paItems)
		return HaveSameContent(paItems)

func HaveBothSameType(p1, p2)
	return ring_type(p1) = ring_type(p2)

	func @HaveBothSameType(p1, p2)
		return HaveBothSameType(p1, p2)

func IsEmptyList(paList)
	return StzListQ(paList).IsEmpty()
		
	func IsAnEmptyList(paList)
		return IsEmptyList(paList)

	func @IsEmptyList(paList)
		return IsEmptyList(paList)

	func @IsAnEmptyList(paList)
		return IsEmptyList(paList)

#===

func ListShow(paList)
	StzListQ(paList).Show()

func AreNumbers(paList)
	return StzListQ(paList).ContainsOnlyNumbers()

	#< @FunctionAlternativeForms

	func AllAreNumbers(paList)
		return AreNumbers(paList)

	func AreAllNumbers(paList)
		return AreNumbers(paList)

	func TheseAreNumbers(paList)
		return AreNumbers(paList)

	func AllTheseAreNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfOnlyNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfJustNumbers(paList)
		return AreNumbers(paList)

	func ContainsOnlyNumbers(paList)
		return AreNumbers(paList)

	func ContainsJustNumbers(paList)
		return AreNumbers(paList)

	#--

	func @AreNumbers(paList)
		return AreNumbers(paList)

	func @AllAreNumbers(paList)
		return AreNumbers(paList)

	func @AreAllNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfOnlyNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfJustNumbers(paList)
		return AreNumbers(paList)

	func @ContainsOnlyNumbers(paList)
		return AreNumbers(paList)

	func @ContainsJustNumbers(paList)
		return AreNumbers(paList)

	#TODO : Add these alternatives to other similar functions
	#>

func AreStrings(paList)
	return StzListQ(paList).ContainsOnlyStrings()

	#< @FuncctionAlternativeForms

	func AllAreStrings(paList)
		return AreStrings(paList)

	func AreAllStrings(paList)
		return AreStrings(paList)

	func TheseAreStrings(paList)
		return AreStrings(paList)

	func AllTheseAreStrings(paList)
		return AreStrings(paList)

	#--

	func @AreStrings(paList)
		return AreStrings(paList)

	func @AllAreStrings(paList)
		return AreStrings(paList)

	func @AreAllStrings(paList)
		return AreStrings(paList)

	#>

func AreLists(paList)
	return StzListQ(paList).ContainsOnlyLists()

	#< @FunctionAlternativeForms

	func AllAreLists(paList)
		return AreLists(paList)

	func AreAllLists(paList)
		return AreLists(paList)

	func TheseAreLists(paList)
		return AreLists(paList)

	#--

	func @AreLists(paList)
		return AreLists(paList)

	func @AllAreLists(paList)
		return AreLists(paList)

	func @AreAllLists(paList)
		return AreLists(paList)

	#>

func AreObjects(paList)
	return StzListQ(paList).ContainsOnlyObjects()

	#< @FunctionAlternativeForms

	func AllAreObjects(paList)
		return AreObjects(paList)

	func AreAllObjects(paList)
		return AreObjects(paList)

	func TheseAreObjects(paList)
		return AreObjects(paList)

	#--

	func @AreObjects(paList)
		return AreObjects(paList)

	func @AllAreObjects(paList)
		return AreObjects(paList)

	func @AreAllObjects(paList)
		return AreObjects(paList)

	#>

func IsRangeNamedParamList(paList)
	return StzListQ(paList).IsRangeNamedParam()

	func @IsRangeNamedParamList(paList)
		return IsRangeNamedParamList(paList)

func ListToCode(paList)
	return StzListQ(paList).ToCode()


func AllTheseAreNull(paList)
	return StzListQ(paList).AllItemsAreNull()

	func AllOfTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func TheseAreNull(paList)
		return AllTheseAreNull(paList)

	#--

	func @AllTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func @AllOfTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func @TheseAreNull(paList)
		return AllTheseAreNull(paList)

func AllOfTheseAreNotNull(paList)
	bResult = _TRUE_
	for item in paList
		if isString(item) and isNull(item)
			bResult = _FALSE_
			exit
		ok
	next

	return bResult

	func NoOneOfTheseIsNull(paList)
		return AllOfTheseAreNotNull(paList)

	func TheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

	#--

	func @AllOfTheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

	func @NoOneOfTheseIsNull(paList)
		return AllOfTheseAreNotNull(paList)

	func @TheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

func BothAreNull(p1, p2)
	return TheseAreNull([ p1, p2 ])

	func @BothAreNull(p1, p2)
		return BothAreNull(p1, p2)

func BothAreNotNull(p1, p2)
	return TheseAreNotNull([ p1, p2 ])

	func @BothAreNotNull(p1, p2)
		return BothAreNotNull(p1, p2)

func NoOneOfTheseIsAString(paList)
	bResult = _TRUE_
	for item in paList
		if isString(item)
			bResult = _FALSE_
			exit
		ok
	next
	
	return bResult

	func @NoOneOfTheseIsAString(paList)
		return NoOneOfTheseIsAString(paList)

func List@(paList)
	if isList(paList)
		return ComputableForm(paList)
	ok

func ListFindAll(paList, p)
	return StzListQ(paList).FindAll(p)

func ListOfNTimes(n, pItem)
	aResult = []
	for i = 1 to n
		aResult + pItem
	next
	return aResult

#--

func WithoutDuplication(paList)
	return StzListQ(paList).WithoutDuplication()

	func @WithoutDuplication(paList)
		return WithoutDuplication(paList)

	#-- @Misspelled (two p instead of one)

	func WithoutDupplication(paList)
		return WithoutDuplication(paList)

	func @WithoutDupplication(paList)
		return WithoutDuplication(paList)

func StringsIn(paList)
	if CheckingParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isString(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForm

	func @StringsIn(paList)
		return Strings(paList)

	#>

func ListsIn(paList)
	if CheckingParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isList(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForm

	func @ListsIn(paList)
		return Lists(paList)

	#>

func ObjectsIn(paList)
	if CheckingParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isObject(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForms

	func @ObjectsIn(paList)
		return Objects(paList)

	#>

#===

func StzListContainsCS(paList, pItem, pCaseSensitive)
	nPos = @FindFirstCS(paList, pItem, pCaseSensitive)
	if nPos > 0
		return _TRUE_
	else
		return _FALSE_
	ok

	func ListContainsCS(paList, pItem, pCaseSensitive)
		return StzListContainsCS(paList, pItem, pCaseSensitive)

	func @ListContainsCS(paList, pItem, pCaseSensitive)
		return StzListContainsCS(paList, pItem, pCaseSensitive)

func StzListContains(paList, pItem)
	return StzListContainsCS(paList, pItem, _TRUE_)

	func ListContains(paList, pItem)
		return StzListContains(paList, pItem)

	func @ListContains(paList, pItem)
		return StzListContains(paList, pItem)
#--

func StzListCountCS(aList, pItem, pCaseSensitive)
	nResult = StzListQ(aList).FindAllCS(aList, pItem, pCaseSensitive)

	func ListCountCS(aList, pItem, pCaseSensitive)
		return StzListCountCS(aList, pItem, pCaseSensitive)

func StzListCount(aList, pItem)
	return StzListCountCS(aList, pItem, pCaseSensitive)

	func ListCount(aList, pItem)
		return StzListCount(aList, pItem)

#=== Enhance Ring+Softanza finding functions #todo #narration

#NOTE
# ~> These functions are based on Ring native find() function.
# ~> They can deal only with finding numbers or strings.
# ~> They are used used internally by stzList finding functions

# When searching for elements in a list, always start by
# checking if you can use these global @Find...() functions
# before using an stzList object.

# These functions can be used when the items youre looking for
# are either numbers or lists. Otherwise, the use of stzList is necessary.

# The option for the right approach can lead to significant performance gains.
# ~> See example in stzListTest.ring file

#WARNING Very important! Read the warning in @FindNthOccurrenceCS() function

func @FindAllCS(paList, pItem, pCaseSensitive)

	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if NOT (isString(pItem) or isNumber(pItem))
			return -1
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok
	ok

	_aList_ = paList
	_nLen_ = len(_aList_)

	if _nLen_ = 0
		return []
	ok

	_item_ = pItem

	if pCaseSensitive = _FALSE_ 
		if isString(_item_)
			pItem = lower(_item_)
		ok

		_aList_ = StzListQ(_aList_).Lowercased()
	ok

	#TODO #IMPORTANT // protect all local variables that are modified
	# by any Softanza function or method, by enclosing them between
	# two _s, like in _nPos_ in the fellowing code.

	#~> // That's because when the calling Ring programm has also a
	# gloabl variable of the same name, this will be accidently
	# modified by the local Softanza code, and the user won't understand why!

	_anResult_ = []
	_nPos_ = -1

	while _TRUE_

		# Trying to find the item using Ring find()

		try
			_nPos_ = find(_aList_, _item_)

		catch
			return -1
		done

		if _nPos_ = 0
			exit
		ok

		_anResult_ + _nPos_

		# A touch of magic: to allow Ring's find() method
		# in the try block above to continue searching
		# through the remaining part of the list, we modify
		# the item at the position it just found to ensure
		# it is skipped.
		
		_aList_[ _nPos_ ] += (""+ _aList_[ _nPos_ ] + 1)
	end

	return _anResult_

	func FindAllCS(aList, pItem, pCaseSensitive)
		return @FindAllCS(aList, pItem, pCaseSensitive)

func @FindAll(aList, pItem)
	return @FindAllCS(aList, pItem, _TRUE_)

	func FindAll(aList, pItem)
		return @FindAll(aList, pItem)

#---

func @FindFirstCS(aList, pStrOrNbr, pCaseSensitive)
	nResult = @FindNthSTCS(aList, 1, pStrOrNbr, 1, pCaseSensitive)
	return nResult

	#< @FunctionAlternativeForms

	func FindFirstCS(aList, pStrOrNbr, pCaseSensitive)
		return @FindFirstCS(aList, pStrOrNbr, pCaseSensitive)

	func @FindCS(aList, pStrOrNbr, pCaseSensitive)
		return @FindFirstCS(aList, pStrOrNbr, pCaseSensitive)

	#>

func @FindFirst(aList, pStrOrNbr)
	return @FindFirstCS(aList, pStrOrNbr, _TRUE_)

	#< @FunctionAlternativeForms

	func FindFirst(aList, pStrOrNbr)
		return @FindFirst(aList, pStrOrNbr)

	func @Find(aList, pStrOrNbr)
		return @FindFirst(aList, pStrOrNbr)

	#>

#--

func @FindLastCS(aList, pStrOrNbr, pCaseSensitive)
	nResult = len(aList) - @FindFirstCS( reverse(aList), pStrOrNbr, pCaseSensitive) + 1
	return nResult

	#< @FunctionAlternativeForms

	func FindLastCS(aList, pStrOrNbr, pCaseSensitive)
		return @FindLastCS(aList, pStrOrNbr, pCaseSensitive)

	#>

func @FindLast(aList, pStrOrNbr)
	return @FindLastCS(aList, pStrOrNbr, _TRUE_)

	#< @FunctionAlternativeForms

	func FindLast(aList, pStrOrNbr)
		return @FindLast(aList, pStrOrNbr)

	#>

#--

func @FindNthOccurrenceCS(paList, nth, pItem, pCaseSensitive)

	#WARNING // Be careful! When using this function inside a stzList object,
	# dont' send directly the content of the object like this:

	#    @FindNthOccurrence(This.Content(), ...; ...)

	# because the content of the object can be modified by this function.

	# Instead of that you should protect the content by taking a copy first
	# and then sendng it to this function, like this:

	#    aTempContent = This.Content()
	#    @FindNthOccurrence(TaTempContent, ...; ...)

	# Same thing applies to simular functions in this section!

	#UPDATE // This should not be the case! This function itself should
	# be safe and work on a copy of the paList sent, and paList itself.
	#~> DONE
	# So we should not care anymore.

	#TODO // Check that all the global functions in the library are safe
	# and never alter the values of their params!

	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if NOT isNumber(nth)
			StzRaise("Incorrect param type! nth must be a number.")
		ok

		if NOT (isString(pItem) or isNumber(pItem))
			return -1
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok
	ok

	if pCaseSensitive = _FALSE_ 

		if isString(pItem)
			pItem = lower(pItem)
		ok

		paList = StzListQ(paList).Lowercased()

	ok

	_aListCopy_ = paList

	nLen = len(_aListCopy_)
	nPos = -1
	n = 0

	while _TRUE_
		try
			nPos = find(_aListCopy_, pItem)
		catch
			return -1
		done

		if nPos = 0
			return 0
		ok

		n++
		if n = nth
			exit
		ok

		_aListCopy_[nPos] += (""+ _aListCopy_[nPos]+1)
		
	end

	return nPos


	func @FindNthCS(aList, nth, pItem, pCaseSensitive)
		return @FindNthOccurrenceCS(aList, nth, pItem, pCaseSensitive)

func @FindNthOccurrence(aList, nth, pItem)
	return @FindNthOccurrenceCS(aList, nth, pItem, _TRUE_)

	func @FindNth(aList, nth, pItem)
		return @FindNthOccurrence(aList, nth, pItem)

#--

func @FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)

	if CheckingParams()
		if NOT isList(aList)
			StzRaise("Incorrect param type! aList must be a list.")
		ok

		if NOT isNumber(nth)
			StzRaise("Incorrect param type! nth must be a number.")
		ok

		if NOT (isString(pItem) or isNumber(pItem))
			return -1
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if NOT isNumber(nStart)
			StzRaise("Incorrect param type! nStart must be a number.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok
	ok

	if pCaseSensitive = _FALSE_ 
		if isString(pItem)
			pItem = lower(pItem)
		ok

		aList = StzListQ(aList).Lowercased()
	ok

	nLen = len(aList)
	aContent = []

	for i = nStart to nLen
		aContent + aList[i]
	next

	nPos = -1
	n = 0

	while _TRUE_
		try
			nPos = find(aContent, pItem)
		catch
			return -1
		done

		if nPos = 0
			exit
		ok

		n++
		if n = nth
			exit
		ok

		aContent[nPos] += (""+ aContent[nPos]+1)
		
	end

	nResult = 0

	if nPos > 0

		nResult = nPos + nStart - 1
	ok

	return nResult

	#< @FunctionAlternativeForms

	func FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)

	#--

	func FindNthCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)

	#>

#-- CS

func @FindNthST(aList, nth, pItem, nStart)
	return @FindNthSTCS(aList, nth, pItem, nStart, _TRUE_)

	#< @FunctionAlternativeForms

	func FindNthST(aList, nth, pItem, nStart)
		return @FindNthST(aList, nth, pItem, nStart)

	func FindNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthST(aList, nth, pItem, nStart)

	func @FindNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthST(aList, nth, pItem, nStart)

	#--

	func FindNth(aList, nth, pItem, nStart)
		return @FindNthST(aList, nth, pItem, nStart)

	#>

#===

func FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	if CheckingParams() = _TRUE_
		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok
	ok

	return @FindNthSTCS(aList, nth, pItem, nStart+1, pCaseSensitive)

	#< @FunctionAlternativeForms

	def FindNextNthCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	def @FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	def @FindNextNthCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNthNextSTCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNextNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNextNthSTCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNthNextSTCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNthNextStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNextNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNextNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNthNextStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return FindNthNextCS(aList, nth, pItem, nStart, pCaseSensitive)

	#>

#-- CS

func FindNthNext(aList, nth, pItem, nStart)
	return FindNthNextCS(aList, nth, pItem, nStart, _TRUE_)

	#< @FunctionAlternativeForms

	def FindNextNth(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	def @FindNthNext(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	def @FindNextNth(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func @FindNthNextST(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func @FindNextNthST(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func FindNextNthST(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func FindNthNextST(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func FindNthNextStartingAt(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func FindNextNthStartingAt(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func @FindNextNthStartingAt(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	func @FindNthNextStartingAt(aList, nth, pItem, nStart)
		return FindNthNext(aList, nth, pItem, nStart)

	#>

#==

func @FindNextCS(aList, pItem, nStart, pCaseSensitive)
	return @FindNthNextSTCS(aList, 1, pItem, nStart, pCaseSensitive)

	func FindNextCS(aList, pItem, nStart, pCaseSensitive)
		return @FindNextCS(aList, pItem, nStart, pCaseSensitive)

	func FindNextSTCS(aList, pItem, nStart, pCaseSensitive)
		return @FindNextCS(aList, pItem, nStart, pCaseSensitive)

	func @FindNextSTCS(aList, pItem, nStart, pCaseSensitive)
		return @FindNextCS(aList, pItem, nStart, pCaseSensitive)

func @FindNext(aList, pItem, nStart)
	return @FindNextCS(aList, pItem, nStart, _TRUE_)

	func FindNext(aList, pItem, nStart)
		return @FindNext(aList, pItem, nStart)

	func FindNextST(aList, pItem, nStart)
		return @FindNext(aList, pItem, nStart)

	func @FindNextST(aList, pItem, nStart)
		return @FindNext(aList, pItem, nStart)

# Functions used internally with DeepFind method

func FindNumberOrStringInNestedList(pNbrOrStr, paList) #ai #claude #chat-gpt

    if CheckParams()
        if NOT ( isNumber(pNbrOrStr) or isString(pNbrOrStr) )
            StzRaise("Incorrect param type! pNbrOrStr must be a number or string.")
        ok

        if NOT isList(paList)
            StzRaise("Incorrect param type! paList must be a list.")
        ok
    ok

    _nLen_ = len(paList)
    _aPositions_ = []
    _nRootPos_ = 1

    for @i = 1 to _nLen_

        if isNumber(paList[@i]) or isString(paList[@i])
            if paList[@i] = pNbrOrStr
                _aPositions_ + [ _nRootPos_ ]
            ok

        but isList(paList[@i])

            _aSubPositions_ = FindNumberOrStringInNestedList(pNbrOrStr, paList[@i])
            _nLenPos_ = len(_aSubPositions_)

            # Process nested positions

            for @j = 1 to _nLenPos_
                if isList(_aSubPositions_[@j])
                    _aNewPath_ = [ _nRootPos_ ]
                    _nLenNewPath_ = len(_aSubPositions_[@j])

                    for @k = 1 to _nLenNewPath_
                        _aNewPath_ + _aSubPositions_[@j][@k]
                    next

                    _aPositions_ + _aNewPath_
                else
                    _aPositions_ + [ _nRootPos_, _aSubPositions_[@j] ]
                ok
            next
        ok

        _nRootPos_++

    next

    return _aPositions_

func FindStrListInNestedStrList(pcItemProvidedAsStr, pcListProvidedAsStr) #ai #claude
	if CheckParams()
		if NOT ( isString(pcItemProvidedAsStr) and isString(pcItemProvidedAsStr) )
			StzRaise("Incorrect param type! pcItemProvidedAsStr and pcItemProvidedAsStr must both be strings.")
		ok
	ok

	_aPositions_ = []
	_nLenItemProvidedAsStr_ = stzlen(pcItemProvidedAsStr)
	_nLenListProvidedAsStr_ = stzlen(pcListProvidedAsStr)

	# Main parsing loop

	_nRootPos_ = 1  # Track position at current depth
	_nCurrentIndex_ = 1
    
	while _nCurrentIndex_ <= _nLenListProvidedAsStr_

		# Check for direct match at current position

		if ExistsAt(pcItemProvidedAsStr, pcListProvidedAsStr, _nCurrentIndex_)

			_aPositions_ + [ _nRootPos_ ]  # Simply add current position
			_nCurrentIndex_ += _nLenItemProvidedAsStr_

		else
			# Check for nested lists

			if ring_substr2(pcListProvidedAsStr, _nCurrentIndex_, 1) = "["

				_nSubEndPos_ = FindMatchingBracket(pcListProvidedAsStr, _nCurrentIndex_)

				if _nSubEndPos_ > _nCurrentIndex_ + 1

					_cSubStr_ = ring_substr2( pcListProvidedAsStr, (_nCurrentIndex_ + 1), (_nSubEndPos_ - _nCurrentIndex_ - 1) )
					_aSubPositions_ = FindStrListInNestedStrList(pcItemProvidedAsStr, _cSubStr_)

					_nLenSubPos_ = len(_aSubPositions_)

					# Only handle nesting for non-root positions

					if _nRootPos_ != 1

						for @i = 1 to _nLenSubPos_

							if isList(_aSubPositions_[@i])

								_aNewPath_ = [ _nRootPos_ ]
								_nLenInnerSubPos_ = len(_aSubPositions_[@i])

								for @j = 1 to _nLenInnerSubPos_
									_aNewPath_ + _aSubPositions_[@i][@j]
								next

								_aPositions_ + _aNewPath_

							else
								_aPositions_ + [ _nRootPos_, _aSubPositions_[@i] ]
							ok
						next

					else
						# At root level, add positions as-is

						for @i = 1 to _nLenSubPos_
							_aPositions_ + _aSubPositions_[@i]
						next
					ok
				ok

				_nCurrentIndex_ = _nSubEndPos_

			ok

			_nCurrentIndex_++
		ok
        
		# Move to next item at current level

		if _nCurrentIndex_ <= _nLenListProvidedAsStr_ and 
		   ring_substr2(pcListProvidedAsStr, _nCurrentIndex_, 1) = ","

			_nRootPos_++
			_nCurrentIndex_++
		ok

	end
    
	return _aPositions_

	func FindMatchingBracket(cStr, nStartPos)

		_nOpenCount_ = 1
		@i = nStartPos + 1
		_nLenStr_ = stzlen(cStr)
	
		while @i <= _nLenStr_

			if ring_substr2(cStr, @i, 1) = "["
				_nOpenCount_++

			but ring_substr2(cStr, @i, 1) = "]"

				_nOpenCount_--

				if _nOpenCount_ = 0
					return @i
				ok
			ok

			@i++
		end
	    
		return _nLenStr_
	
	func ExistsAt(pcSearchStr, pcMainStr, pnStartPos)
		if pnStartPos + stzlen(pcSearchStr) - 1 > stzlen(pcMainStr)
			return _FALSE_
		ok
	    
		return ring_substr2(pcMainStr, pnStartPos, stzlen(pcSearchStr)) = pcSearchStr

		func @ExistsAt(pcSearchStr, pcMainStr, pnStartPos)
			return ExistsAt(pcSearchStr, pcMainStr, pnStartPos)

//func FindStrListInNestedStrList(pcItemProvidedAsStr, pcListProvidedAsStr) #ai #claude
//	positions = []
//	nLenItemProvidedAsStr = stzlen(pcItemProvidedAsStr)
//	nLenListProvidedAsStr = stzlen(pcListProvidedAsStr)
//	# Main parsing loop
//	rootPos = 1  # Track position at current depth
//	currentIndex = 1
//    
//	while currentIndex <= nLenListProvidedAsStr
//		# Check for direct match at current position
//		if ExistsAt(pcItemProvidedAsStr, pcListProvidedAsStr, currentIndex)
//			positions + [rootPos]  # Simply add current position
//			currentIndex += nLenItemProvidedAsStr
//		else
//			# Check for nested lists
//			if ring_substr2(pcListProvidedAsStr, currentIndex, 1) = "["
//				subEnd = FindMatchingBracket(pcListProvidedAsStr, currentIndex)
//				if subEnd > currentIndex + 1
//					subStr = ring_substr2(pcListProvidedAsStr, currentIndex + 1, subEnd - currentIndex - 1)
//					subPositions = FindStrListInNestedStrList(pcItemProvidedAsStr, subStr)
//					
//					# Only handle nesting for non-root positions
//					if rootPos != 1
//						for pos in subPositions
//							if isList(pos)
//								newPath = [rootPos]
//								for p in pos
//									newPath + p
//								next
//								positions + newPath
//							else
//								positions + [rootPos, pos]
//							ok
//						next
//					else
//						# At root level, add positions as-is
//						for pos in subPositions
//							positions + pos
//						next
//					ok
//				ok
//				currentIndex = subEnd
//			ok
//			currentIndex++
//		ok
//        
//		# Move to next item at current level
//		if currentIndex <= nLenListProvidedAsStr and 
//		   ring_substr2(pcListProvidedAsStr, currentIndex, 1) = ","
//			rootPos++
//			currentIndex++
//		ok
//	end
//    
//	return positions
//
//	func FindMatchingBracket(pcStr, startPos)
//		openCount = 1
//		i = startPos + 1
//		nLenStr = stzlen(pcStr)
//	
//		while i <= nLenStr
//			if ring_substr2(pcStr, i, 1) = "["
//				openCount++
//			but ring_substr2(pcStr, i, 1) = "]"
//				openCount--
//				if openCount = 0
//					return i
//				ok
//			ok
//			i++
//		end
//	    
//		return nLenStr
//	
//	func ExistsAt(pcSearchStr, pcMainStr, pnStartPos)
//		if pnStartPos + stzlen(pcSearchStr) - 1 > stzlen(pcMainStr)
//			return false
//		ok
//	    
//		return ring_substr2(pcMainStr, pnStartPos, stzlen(pcSearchStr)) = pcSearchStr
//

#=====

func IsRingSortable(pListOrString)

	# Ring can sort string ans lists.

	# In the case of lists, only lists made of numbers and strings
	# can be sorted. There is a special case though...

	# If the list is a list of lists, then Ring can sort it on
	# a given column, using ring(aList, nCol), but under a condition:

	# the column must be made of numbers and/or strings and must not
	# contain dupplicated items (because in this case, the output
	# is not accurate, at a hiher level, and should be managed by Softanza)

	if CheckingParams()
		if NOT ( isString(pListOrString) or isList(pListOrString) )
			StzRaise("Incorrect param type! pListOrString must be a list or string.")
		ok
	ok

	if isString(pListOrString)
		return _TRUE_
	ok

	# Case of a list

	if IsListOfNumbers(pListOrString) or
	   IsListOfStrings(pListOrString) or
	   IsListOfNumbersAndStrings(pListOrString)

		return _TRUE_

	but IsListOfLists(pListOrString)

		# Early check: case where one of the lists is empty

		nLen = len(pListOrString)

		for i = 1 to nLen
			if len(pListOrString[i]) = 0
				return _FALSE_
			ok
		next

		# Checking the columns one by one, and when we
		# find a column that is made of numbers and/or
		# strings and containing no dupplications, then
		# that column make the list of lists sortable

		oLoL = new stzListOfLists(pListOrString)
		nCols = oLoL.NumberOfCols()

		# Parsing all the columns one by one

		for i = 1 to nCols

			# Assuming the current column is Ring sortable

			bColSortable = _TRUE_

			# the column must contain only numbers and strings
			# and should not contain dupplicated items

			aCol = oLoL.Col(i)

			nLenCol = len(aCol)
			aSeen = []

			for j = 1 to nLenCol

				if NOT ( isString(aCol[j]) or isNumber(aCol[j]) )
					bColSortable = _FALSE_
					exit
				else
					if ring_find(aSeen, aCol[j]) = 0
						aSeen + aCol[j]
					else
						bColSortable = _FALSE_
						exit
					ok
				ok
			next

			if bColSortable # We've got a ring-sortable column!
				return _TRUE_
			ok

		next

		# We parsed all the list of lists, column by column, and
		# we did not find any ring-sortable column, so:

		return _FALSE_

	ok

	# In any other case

	return _FALSE_

	func @IsRingSortable(pListOrString)
		return IsRingSortable(pListOrString)

func IsRingSortableOn(paListOfLists, n)

	# In Ring, with the standard ring() function, to sort a list of
	# lists on a given column, that column must:

	# 1. the column of sort should have size as the first column
	# 2. be made of numbers or strings only (no lists or objects),
	# 3. must not contain dupllicated items (because in this case,
	#    the sorting result is not accurate - from Softanza point of view)

	if NOT ( isList(paListOfLists) and IsListOfLists(paListOfLists) )
		return _FALSE_
	ok

	if NOT isNumber(n)
		StzRaise("Incorrect param type! n must be a number.")
	ok

	# Early check : case where at least one list is empty

	nLen = len(paListOfLists)

	for i = 1 to nLen
		if len(paListOfLists[i]) = 0
			return _FALSE_
		ok
	next

	# getting the items in the column n

	oLoL = StzListOfListsQ(paListOfLists)
	aCol = oLoL.Col(n)
	nLen = len(aCol)

	# Early check: the column of sort should have
	# the same number of items as the first column

	if n > 1
		aCol1 = oLoL.Col(1)
		nLen1 = len(aCol1)

		if nLen != nLen1
			return _FALSE_
		ok
	ok

	aSeen = []

	for i = 1 to nLen
		if NOT ( isNumber(aCol[i]) or isString(aCol[i]) )
			return _FALSE_
		ok

		if ring_find(aSeen, aCol[i]) = 0
			aSeen + aCol[i]
		else
			return _FALSE_
		ok
	next

	return _TRUE_

	func @IsRingSortableOn(paListOfLists, n)
		return IsRingSortableOn(paListOfLists, n)
	
func Move(paList, n1, n2)

	if CheckingParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if NOT isNumber(n1)
			StzRaise("Incorrect param type! n1 must be a number.")
		ok

		if NOT isNumber(n2)
			StzRaise("Incorrect param type! n2 must be a number.")
		ok
	ok

	item = paList[n1]
	ring_remove(paList, n1)
	n = n2
	if n1 > n2
		n++
	ok
	ring_insert(paList, n2, item)
	return paList


	#< @FunctionAlternativeForms

	func @Move(paList, n1, n2)
		return Move(paList, n1, n2)

	func MoveItems(paList, n1, n2)
		return Move(paList, n1, n2)

	func @MoveItems(paList, n1, n2)
		return Move(paList, n1, n2)

	#>

#NOTE: the mother function of the fellowing fluent forms
# is hosted in the stzDisplaySystem.ring file. They are
# put here because they are specific to Softanza classes,
# while all softanza systems files are can be used independently.

func ComputableShortFormQ(paList)
	return new stzString(ComputableShortForm(paList))

	func @@SFQ(paList)
		return ComputableShortFormQ(paList)

	func @@SQ(paList)
		return ComputableShortFormQ(paList)

	func ShortFormQ(paList)
		return ComputableShortFormQ(paList)

func ComputableFormXTQ(pValue, cSep1, cSep2)
	return new stzString( ComputableFormXT(pValue, c) )

	func @@XTQ(pValue, cSep1, cSep2)
		return new stzString( @@XT(pValue, cSep1, cSep2) )

	func CFXTQ(pValue, cSep1, cSep2)
		return new stzString( CFXT(pValue, cSep1, cSep2) )

	func @ComputableFormXTQ(pValue, cSep1, cSep2)
		return new stzString( @ComputableFormXT(pValue, cSep1, cSep2) )

func ComputableShortFormXTQ(paList, p)
	return new stzString(ComputableShortFormXT(paList, p))

	func ShortFormXTQ(paList, p)
		return new stzString(ShortFormXT(paList, p))

	func @@SFXTQ(paList, p)
		return new stzString(@@SFXT(paList, p))

	func @@SXTQ(paList, p)
		return new stzString(@@SFXT(paList, p))

func ComputableFormQ(pValue)
	return new stzString( ComputableForm(pValue) )

	func @@Q(pValue)
		return new stzString( @@(pValue) )

	func CFQ(pValue)
		return new stzString( CF(pValue) )

	func @ComputableFormQ(pValue)
		return new stzString( @ComputableForm(pValue) )

func ComputableFormNLQ(pValue)
	return new stzString( ComputableFormNL(pValue) )

	func @@NLQ(pValue)
		return ComputableFormNLQ(pValue)

	func @ComputableFormNLQ(pValue)
		return ComputableFormNLQ(pValue)

	func CFNLQ(pValue)
		return ComputableFormNLQ(pValue)

	func @@SPQ(pValue)
		return ComputableFormNLQ(pValue)

	func ComputableFormSPQ(pValue)
		return ComputableFormNLQ(pValue)

	func @ComputableFormSPQ(pValue)
		return ComputableFormNLQ(pValue)

	func ComputableFormSpacifiedQ(pValue)
		return ComputableFormNLQ(pValue)

	func @ComputableFormSpacifiedQ(pValue)
		return ComputableFormNLQ(pValue)

	func CFSPQ(pValue)
		return ComputableFormNLQ(pValue)

	func @CFSPQ(pValue)
		return ComputableFormNLQ(pValue)

#---

func IsContiguous(paList)
	return StzListQ(paList).IsContiguous()

	func IsContinuous()
		return IsContiguous()

	func IsConsecutive()
			return IsContiguous()

	#--

	func @IsContiguous(paList)
		return IsContiguous()

	func @IsContinuous()
		return IsContiguous()

	func @IsConsecutive()
			return IsContiguous()

#== Combinations functions by ClaudeAI #ai

# Helper function to generate combinations recursively
Func generateCombinationsXT(paList, nLen, nDepth, aCurrent, aResult)
	if len(aCurrent) = nDepth
		aResult + aCurrent
		return
	ok
	
	for i = 1 to nLen
		aCurrent + paList[i]
		generateCombinationsXT(paList, nLen, nDepth, aCurrent, aResult)
		del(aCurrent, len(aCurrent))
	next

# Function to generate all possible combinations including duplicates and inversions

Func CombinationsXT(aList, n)
	if CheckParams()
		if NOT isList(aList)
			StzRaise("Incorrect param type! aList must be a list.")
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok
	ok

	# Early check

	_nLen_ = len(aList)
	if _nLen_ = 0 or n = 0
		return []

	but _nLen_ = 1 or n = 1
		return aList
	ok

	# doing the job

	if n > _nLen_
		StzRaise("Can't proceed! n must be lesser than the size of the list.")
	ok

	_aResult_ = []
	_aCurrent_ = []
	
	if n > 0 and n <= _nLen_
		generateCombinationsXT(aList, _nLen_, n, _aCurrent_, _aResult_)
	ok
	
	return _aResult_

	func @CombinationsXT(paList, n)
		return CombinationsXT(paList, n)

# Function to generate combinations without duplicates or inversions

func Combinations(aList, n)
	if CheckParams()
		if NOT isList(aList)
			StzRaise("Incorrect param type! aList must be a list.")
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok
	ok

	# Early check

	_nLen_ = len(aList)
	if _nLen_ = 0 or n = 0
		return []

	but _nLen_ = 1 or n = 1
		return aList
	ok

	# doing the job

	if n > _nLen_
		StzRaise("Can't proceed! n must be lesser than the size of the list.")
	ok

	_aList_ = aList
	_aResult_ = []

	# Main loop for first element

	for @i = 1 to _nLen_ - n + 1

		# Inner loop for remaining elements

		for @j = @i + 1 to _nLen_ - n + 2
			_aCombination_ = []
			add(_aCombination_, _aList_[@i])

			# Additional loops for n > 2
			if n > 2
				for @k = @j + 1 to _nLen_
					_aTempComb_ = _aCombination_
					add(_aTempComb_, _aList_[@j])
					add(_aTempComb_, _aList_[@k])
					add(_aResult_, _aTempComb_)
				next
			else
				add(_aCombination_, _aList_[@j])
				add(_aResult_, _aCombination_)
			ok
		next
	next

	return _aResult_


	func @Combinations(aList, n)
		return Combinations(aList, n)

  /////////////////
 ///   CLASS   ///
/////////////////

class TempAndDumpyThing

class stzList from stzObject
	@aContent = []

	@aWalkers = []

	These
	Those

	  #--------------#
	 #     INIT     #
	#--------------#

	def init(paList)
		if CheckingParams()

			if NOT isList(paList)
				StzRaise("Can't create the stzList object! paList must be a list.")
			ok
		ok

		@aContent = paList
		These = This
		Those = This

		# Adding the first entry in the object history

		StartObjectTime()
		TraceObjectHistory(This)

	  #---------------------#
	 #     CONSTRAINTS     #
	#---------------------#
	// TODO: Finish stzConstraint --> Finsh Constraints section here and
	// in other classes (StzString...)

	//def MustBe(pcIsMethod)


	//def CanNotBe(pcIsMethod)


	  #-----------------------------------#
	 #  GETTING THE CONTENT OF THE LIST  #
	#-----------------------------------#

	def ContentCS(pCaseSensitive)
		
		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok
	
		if NOT (pCaseSensitive = 0 or pCaseSensitive = 1)
			StzRaise("Incorrect param type! pCaseSensitive must be 1 (_TRUE_) or 0 (_FALSE_).")
		ok

		aResult = []

		if pCaseSensitive = _TRUE_
			aResult = @aContent

		else
			aResult = This.WithoutDuplicationCS(_FALSE_)
		
		ok

		return aResult

		#< @FunctionAlternativeForm

		def ContentCSQ(pCaseSensitive)
			return new stzList(This.Content())

		#>

		#< @FunctionAlternativeForms

		def ValueCS(pCaseSensitive)
			return This.ContentCS(pCaseSensitive)

			def ValueCSQ(pCaseSensitive)
				return This.ContentCSQ(pCaseSensitive)

		def ListCS(pCaseSensitive)
			return This.ContentCS(pCaseSensitive)

			def ListCSQ(pCaseSensitive)
				return This.ContentCSQ(pCaseSensitive)

		def TheListCS(pCaseSensitive)
			return This.ContentCS(pCaseSensitive)

			def TheListCSQ(pCaseSensitive)
				return This.ContentCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Content()
		return @aContent

		#< @FunctionAlternativeForm

		def ContentQ()
			return new stzList(This.Content())

		#>

		#< @FunctionAlternativeForms

		def Value()
			return This.Content()

			def ValueQ()
				return This.ContentQ()

		def List()
			return This.Content()

			def ListQ()
				return This # Returns the object not a new one!

		def TheList()
			return This.Content()

			def TheListQ()
				return This # Returns the object not a new one!

		#>

	  #--------------------------------------------------------#
	 #  GETTING THE CONTENT OF THE LIST WITHOUT DUPPLICATION  #
	#--------------------------------------------------------#

	def ContentCSU(pCaseSensitive)
		return This.WithoutDuplicationCS(_FALSE_)


		#< @FunctionAlternativeForm

		def ContentCSUQ(pCaseSensitive)
			return new stzList(This.ContentU())

		#>

		#< @FunctionAlternativeForms

		def ValueCSU(pCaseSensitive)
			return This.ContentCSU(pCaseSensitive)

			def ValueCSUQ(pCaseSensitive)
				return This.ContentCSUQ(pCaseSensitive)

		def ListCSU(pCaseSensitive)
			return This.ContentCSU(pCaseSensitive)

			def ListCSUQ(pCaseSensitive)
				return This.ContentCSUQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContentU()
		return This.WithoutDuplication()

		#< @FunctionAlternativeForm

		def ContentUQ()
			return new stzList(This.ContentU())

		#>

		#< @FunctionAlternativeForms

		def ValueU()
			return This.ContentU()

			def ValueUQ()
				return This.ContentUQ()

		def ListU()
			return This.ContentU()

			def ListUQ()
				return This.ContentUQ()

		#>

	  #------------------------------#
	 #  GETTING A COPY OF THE LIST  #
	#------------------------------#

	def Copy()
		return new stzList( This.List() )

	def ReversedCopy()
		return This.ReverseQ()

	  #-------------------------------------------#
	 #  GETTING THE NUMBER OF ITEMS OF THE LIST  #
	#-------------------------------------------#

	def NumberOfItemsCS(pCaseSensitive)
		nResult = len( This.ContentCS(pCaseSensitive) )
		return nResult

		#< @FuntionFluentForm

		def NumberOfItemsCSQ(pCaseSensitive)
			return new stzNumber( This.NumberOfItemsCS(pCaseSensitive) )

		#>

		#< @FunctionBooleanForm

		def NumberOfItemsCSB(pCaseSensitive)
			if This.NumberOfItemsCS(pCaseSensitive) = LastValue()
				return _TRUE_
			else
				return _FALSE_
			ok

			def NumberOfItemsCSBQ(pCaseSensitive)
				if This.NumberOfItemsCSB(pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def SizeCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def SizeCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def SizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def LengthCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def LengthCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def LengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#-- Used in natural-coding

		def ANumberOfItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ANumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ANumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ANumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ASizeCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ASizeCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ASizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ALengthCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ALengthCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ALengthCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ALengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#--

		def CountItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def CountItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def CountItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def CountItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def HowManyItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def HowManyItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def HowManyItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def NuberOfItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

		#--

		def LenghtCS(pCaseSensitive)
			return This.LengthCS(pCaseSensitive)

		def LenghtCSQ(pCaseSensitive)
			return This.NumberOfItemsCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfItems()
		nResult = len(@aContent)
		return nResult

		#< @FuntionFluentForm

		def NumberOfItemsQ()
			return new stzNumber( This.NumberOfItems() )

		#>

		#< @FunctionBooleanForm

		def NumberOfItemsB()
			if This.NumberOfItems() = LastValue()
				return _TRUE_
			else
				return _FALSE_
			ok

			def NumberOfItemsBQ()
				if This.NumberOfItemsB()
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfItems()

			def SizeQ()
				return This.NumberOfItemsQ()

			def SizeB()
				return This.NumberOfItemsB()

			def SizeBQ()
				return This.NumberOfCharBQ()

		def Length()
			return This.NumberOfItems()

			def LengthQ()
				return This.NumberOfItemsQ()

			def LengthB()
				return This.NumberOfItemsB()

			def LengthBQ()
				return This.NumberOfCharBQ()

		#-- Used in natural-coding

		def ANumberOfItems()
			return This.NumberOfItems()

			def ANumberOfItemsQ()
				return This.NumberOfItemsQ()

			def ANumberOfItemsB()
				return This.NumberOfItemsB()

			def ANumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def ASize()
			return This.NumberOfItems()

			def ASizeQ()
				return This.NumberOfItemsQ()

			def ASizeB()
				return This.NumberOfItemsB()

			def ASizeBQ()
				return This.NumberOfCharBQ()

		def ALength()
			return This.NumberOfItems()

			def ALengthQ()
				return This.NumberOfItemsQ()

			def ALengthB()
				return This.NumberOfItemsB()

			def ALengthBQ()
				return This.NumberOfCharBQ()

		#--

		def CountItems()
			return This.NumberOfItems()

			def CountItemsQ()
				return This.NumberOfItemsQ()

			def CountItemsB()
				return This.NumberOfItemsB()

			def CountItemsBQ()
				return This.NumberOfCharBQ()

		def HowManyItems()
			return This.NumberOfItems()

			def HowManyItemsQ()
				return This.NumberOfItemsQ()

			def HowManyItemsB()
				return This.NumberOfItemsB()

			def HowManyItemsBQ()
				return This.NumberOfCharBQ()

		#>

		#< @FunctionMisspelledForms

		def NuberOfItems()
			return This.NumberOfItems()

		#--

		def Lenght()
			return This.Length()

		def LenghtQ()
			return This.NumberOfItemsQ()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF ITEMS OF THE LIST -- U/Extended FORM  #
	#--------------------------------------------------------------#

	def NumberOfItemsU()
		return len( Q(This.Content()).WithoutDuplicates() )

		def NumberOfItemsUQ()
			return new stzNumber(This.NumberOfItemsU())

		def SizeU()
			return This.NumberOfItemsU()

		def LengthU()
			return This.NumberOfItemsU()

			#-- @Misspelled

			def LenghtU()
				return This.NumberOfItemsU()

		def CountItemsU()
			return This.NumberOfItemsU()

		def HowManyItemsU()
			return This.NumberOfItemsU()
	
		def HowManyItemU()
			return This.NumberOfItemsU()

	  #-----------------------------#
	 #  GETTING THE LIST OF ITEMS  #
	#-----------------------------#

	def Items()
		return This.Content()

		#< @FunctionFluentForm

		def ItemsQ()
			return This

		#>

	  #------------------------------------#
	 #  GETTING THE NTH ITEM IN THE LIST  #
	#------------------------------------#

	def Item(n)

		if CheckingParams()

			if isString(n)
				if n = "first"
					n = 1
	
				but n = "last"
					n = This.NumberOfItems()
	
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n should be a number.")
			ok
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if n < 0
			n = nLen + n + 1
		ok

		return @aContent[n]

		def ItemQ(n)
			return Q(This.Item(n))

		#< @AlternativeFunctionNames

		def NthItem(n)
			return This.Item(n)

			def NthItemQ(n)
				return This.ItemQ(n)

		def ItemAtPosition(n)
			return This.Item(n)

			def ItemAtPositionQ(n)
				return This.ItemQ(n)

		def ItemAt(n)
			return This.Item(n)

			def ItemAtQ(n)
				return This.ItemQ(n)

		#>

	  #--------------------------------------#
	 #  GETTING THE FIRST ITEM IN THE LIST  #
	#--------------------------------------#

	def FirstItem()
		return This.NthItem(1)

		def FirstItemQ()
			return Q(This.FirstItem())

		#-- MISSPELLED

		def FristItem()
			return This.FirstItem()

			def FristItemQ()
				return This.FirstItemQ()

	  #-------------------------------------#
	 #  GETTING THE LAST ITEM IN THE LIST  #
	#-------------------------------------#

	def LastItem()
		return This.NthItem( This.NumberOfItems() )

		def LastItemQ()
			return Q(This.LastItem())

	  #------------------------------------------------#
	 #  GETTING THE FIRST AND LAST ITEMS IN THE LIST  #
	#------------------------------------------------#

	def FirstAndLastItems()
		aResult = [ This.FirstItem(), This.LastItem() ]
		return aResult

		#-- MISSPELLED

		def FristAndLastItems()
			return This.FirstAndLastItems()

	def LastAndFirstItems()
		aResult = [ This.LastItem(), FirstItem() ]
		return aResult

		#-- MISSPELLED

		def LastAndFristItems()
			return This.LastAndFirstItems()

	  #--------------------------------------------#
	 #  GETTING THE CENTRAL POSITION IN THE LIST  #
	#--------------------------------------------#

	def CentralPosition()
		oTemp = new stzNumber( (This.NumberOfItems()/2) )
		n = oTemp.IntegerPartValue()
		return n

		def CentralItemPosition()
			return This.CentralPosition()

	  #----------------------------------------#
	 #  GETTING THE CENTRAL ITEM IN THE LIST  #
	#----------------------------------------#

	def CentralItem()
		return This[CentralPosition()]

		def CentralItemQ()
			return Q(This.CentralItem())

	  #---------------------------------------------#
	 #  CHECKING IF THE STRING HAS A CENTRAL ITEM  #
	#---------------------------------------------#

	def HasCentralItem()
		return This.NumberOfItemsQ().IsNotEven()

		def ContainsCentralItem()
			return This.HasCentralItem()

	  #-------------------------------------#
	 #  GETTING THE LIST OF N FIRST ITEMS  #
	#-------------------------------------#

	def NFirstItems(n)
		aContent = This.Content()
		aResult = []

		for i = 1 to n
			aResult + aContent[i]
		next

		return aResult
		
		#< @FunctionFluentForms

		def NFirstItemsQ(n)
			return NFirstItemsQRT(n, :stzList)

		def NFirstItemsQRT(n, pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstItems(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstItems(n) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NFirstItems(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def FirstNItems(n)
			return This.NFirstItems(n)

			def FirstNItemsQ(n)
				return This.NFirstItemsQ(n)

			def FirstNItemsQRT(n, pcReturnType)
				return This.NFirstItemsQRT(n, pcReturnType)

		#>

		#< @FunctionSpecieficForms

		def First2Items()
			return This.FirstNItems(2)
	
			def 2FirstItems()
				return This.First2Items()
	
			def FirstTwoItems()
				return This.First2Items()
	
			def TwoFirstItems()
				return This.First2Items()
	
		def First3Items()
			return This.FirstNItems(3)
	
			def 3FirstItems()
				return This.First3Items()
	
			def FirstThreeItems()
				return This.First2Items()
	
			def ThreeFirstItems()
				return This.First3Items()
	
		def First4Items()
			return This.FirstNItems(4)
	
			def 4FirstItems()
				return This.First4Items()
	
			def FirstFourItems()
				return This.First4Items()
	
			def FourFirstItems()
				return This.First4Items()
	
		def First5Items()
			return This.FirstNItems(5)
	
			def 5FirstItems()
				return This.First5Items()
	
			def FirstFiveItems()
				return This.First5Items()
	
			def FiveFirstItems()
				return This.First5Items()
	
		def First6Items()
			return This.FirstNItems(6)
	
			def 6FirstItems()
				return This.First6Items()
	
			def FirstSixItems()
				return This.First6Items()
	
			def SixFirstItems()
				return This.First6Items()
	
		def First7Items()
			return This.FirstNItems(7)
	
			def 7FirstItems()
				return This.First7Items()
	
			def FirstSevenItems()
				return This.First7Items()
	
			def SevenFirstItems()
				return This.First7Items()
	
		def First8Items()
			return This.FirstNItems(8)
	
			def 8FirstItems()
				return This.First8Items()
	
			def FirstEightItems()
				return This.First8Items()
	
			def EightFirstItems()
				return This.First8Items()
	
		def First9Items()
			return This.FirstNItems(9)
	
			def 9FirstItems()
				return This.First9Items()
	
			def FirstNineItems()
				return This.First9Items()
	
			def NineFirstItems()
				return This.First9Items()
	
		def First10Items()
			return This.FirstNItems(10)
	
			def 10FirstItems()
				return This.First10Items()
	
			def FirstTenItems()
				return This.First10Items()
	
			def TenFirstItems()
			return This.First10Items()

		#>

		#< @FunctionAMisspelledForms

		def NFristItems(n)
			return This.NFirstItems(n)

			def NFristItemsQ(n)
				return This.NFirstItemsQ(n)

			def NFristItemsQRT(n, pcReturnType)
				return This.NFirstItemsQRT(n, pcReturnType)

		def FristNItems(n)
			return This.NFirstItems(n)

			def FristNItemsQ(n)
				return This.NFirstItemsQ(n)

			def FristNItemsQRT(n, pcReturnType)
				return This.NFirstItemsQRT(n, pcReturnType)

		#--

		def Frist2Items()
			return This.FirstNItems(2)
	
			def 2FristItems()
				return This.First2Items()
	
			def FristTwoItems()
				return This.First2Items()
	
			def TwoFristItems()
				return This.First2Items()
	
		def Frist3Items()
			return This.FirstNItems(3)
	
			def 3FristItems()
				return This.First3Items()
	
			def FristThreeItems()
				return This.First2Items()
	
			def ThreeFristItems()
				return This.First3Items()
	
		def Frist4Items()
			return This.FirstNItems(4)
	
			def 4FristItems()
				return This.First4Items()
	
			def FristFourItems()
				return This.First4Items()
	
			def FourFristItems()
				return This.First4Items()
	
		def Frist5Items()
			return This.FirstNItems(5)
	
			def 5FristItems()
				return This.First5Items()
	
			def FristFiveItems()
				return This.First5Items()
	
			def FrieFirstItems()
				return This.First5Items()
	
		def Frist6Items()
			return This.FirstNItems(6)
	
			def 6FristItems()
				return This.First6Items()
	
			def FristSixItems()
				return This.First6Items()
	
			def SixFristItems()
				return This.First6Items()
	
		def Frist7Items()
			return This.FirstNItems(7)
	
			def 7FristItems()
				return This.First7Items()
	
			def FristSevenItems()
				return This.First7Items()
	
			def SevenFristItems()
				return This.First7Items()
	
		def Frist8Items()
			return This.FirstNItems(8)
	
			def 8FristItems()
				return This.First8Items()
	
			def FristEightItems()
				return This.First8Items()
	
			def EightFristItems()
				return This.First8Items()
	
		def Frist9Items()
			return This.FirstNItems(9)
	
			def 9FristItems()
				return This.First9Items()
	
			def FristNineItems()
				return This.First9Items()
	
			def NineFristItems()
				return This.First9Items()
	
		def Frist10Items()
			return This.FirstNItems(10)
	
			def 10FristItems()
				return This.First10Items()
	
			def FristTenItems()
				return This.First10Items()
	
			def TenFristItems()
			return This.First10Items()

		#>

	  #------------------------------------#
	 #  GETTING THE LIST OF N LAST ITEMS  #
	#------------------------------------#

	def NLastItems(n)
		aContent = This.Content()
		nLen = len(aContent)
		n1 = nLen - n + 1
		n2 = nLen

		aResult = []

		for i = n1 to n2
			aResult + aContent[i]
		next

		return aResult

		#< @FunctionFluentForms

		def NLastItemsQ(n)
			return NLastItemsQRT(n, :stzList)

		def NLastItemsQRT(n, pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NLastItems(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastItems(n) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NLastItems(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNItems(n)
			return This.NLastItems(n)

			def LastNItemsQ(n)
				return This.NLastItemsQ(n)

			def LastNItemsQRT(n, pcReturnType)
				return This.NLastItemsQRT(n, pcReturnType)

		#>

		#< @FunctionSpecieficForms

		def Last2Items()
			return This.LastNItems(2)
	
			def 2LastItems()
				return This.Last2Items()
	
			def LastTwoItems()
				return This.Last2Items()
	
			def TwoLastItems()
				return This.Last2Items()
	
		def Last3Items()
			return This.LastNItems(3)
	
			def 3LastItems()
				return This.Last3Items()
	
			def LastThreeItems()
				return This.Last2Items()
	
			def ThreeLastItems()
				return This.Last3Items()
	
		def Last4Items()
			return This.LastNItems(4)
	
			def 4LastItems()
				return This.Last4Items()
	
			def LastFourItems()
				return This.Last4Items()
	
			def FourLastItems()
				return This.Last4Items()
	
		def Last5Items()
			return This.LastNItems(5)
	
			def 5LastItems()
				return This.Last5Items()
	
			def LastFiveItems()
				return This.Last5Items()
	
			def FiveLastItems()
				return This.Last5Items()
	
		def Last6Items()
			return This.LastNItems(6)
	
			def 6LastItems()
				return This.Last6Items()
	
			def LastSixItems()
				return This.Last6Items()
	
			def SixLastItems()
				return This.Last6Items()
	
		def Last7Items()
			return This.LastNItems(7)
	
			def 7LastItems()
				return This.Last7Items()
	
			def LastSevenItems()
				return This.Last7Items()
	
			def SevenLastItems()
				return This.Last7Items()
	
		def Last8Items()
			return This.LastNItems(8)
	
			def 8LastItems()
				return This.Last8Items()
	
			def LastEightItems()
				return This.Last8Items()
	
			def EightLastItems()
				return This.Last8Items()
	
		def Last9Items()
			return This.LastNItems(9)
	
			def 9LastItems()
				return This.Last9Items()
	
			def LastNineItems()
				return This.Last9Items()
	
			def NineLastItems()
				return This.Last9Items()
	
		def Last10Items()
			return This.LastNItems(10)
	
			def 10LastItems()
				return This.Last10Items()
	
			def LastTenItems()
				return This.Last10Items()
	
			def TenLastItems()
				return This.Last10Items()
	
		#>

	  #---------------------------------------------#
	 #  NEXT N ITEMS STARTING AT A GIVEN POSITION  #
	#=============================================#

	def NextNItems(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtOrStartingAtPositionNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstItem
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastItem
				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfItems() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		aResult = This.SectionQ(pnStartingAt + 1, pnStartingAt + n).Items()

		return aResult

		#< @FunctionFluentForm

		def NextNItemsQ(n, pnStartingAt)
			return This.NextNItemsQRT(n, pnStartingAt, :stzList)

		def NextNItemsQRT(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNItems(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNItems(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNItems(n, pnStartingAt) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NextNItems(n, pnStartingAt) )

			on :stzListOfLists
				return new stzListOfLists( This.NextNItems(n, pnStartingAt) )

			on :stzListOfPairs
				return new stzListOfPairs( This.NextNItems(n, pnStartingAt) )

			on :stzListOfObjects
				return new stzListOfObjects( This.NextNItems(n, pnStartingAt) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def NextNItemsST(n, pnStartingAt)
			return This.NextNItems(n, pnStartingAt)

			def NextNItemsSTQ(n, pnStartingAt)
				return This.NextNItemsQ(n, pnStartingAt)

			def NextNItemsSTQRT(n, pnStartingAt, pcReturnType)
				return This.NextNItemsQRT(n, pnStartingAt, pcReturnType)

		#>

	  #-------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------#

	def PreviousNItems(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtOrStartingAtPositionNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstItem
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastItem
				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfItems() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		aResult = This.SectionQ(pnStartingAt - n, pnStartingAt - 1).Items()

		return aResult


		#< @FunctionFluentForm

		def PreviousNItemsQ(n, pnStartingAt)
			return This.PreviousNItemsQRT(n, pnStartingAt, :stzList)

		def PreviousNItemsQRT(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfLists
				return new stzListOfLists( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfPairs
				return new stzListOfPairs( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfObjects
				return new stzListOfObjects( This.PreviousNItems(n, pnStartingAt) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def PreviousNItemsST(n, pnStartingAt)
			return This.PreviousNItems(n, pnStartingAt)

			def PreviousNItemsSTQ(n, pnStartingAt)
				return This.PreviousNItemsQ(n, pnStartingAt)

			def PreviousNItemsSTQRT(n, pnStartingAt, pcReturnType)
				return This.PreviousNItemsQRT(n, pnStartingAt, pcReturnType)

		#>

	  #--------------------#
	 #      UPDATING      #
	#--------------------#

	/*
	Semantic Note:
		Update	-> Assigning a hole new list to the list
		Replace	-> Replacing items or sections of items
	*/

	def Update(paNewList)
		if CheckingParams() = _TRUE_
			if isList(paNewList) and Q(paNewList).IsWithOrByOrUsingNamedParam()
				paNewList = paNewList[2]
			ok

			if NOT isList(paNewList)
				StzRaise("Incorrect param type! paNewList must be a list.")
			ok
		ok

		@aContent = paNewList

		# Tracing object history

		@TraceObjectHistory(This)

		# Checking object constraints (#TODO)

		#< ... >


		#< @FunctionFluentForm

		def UpdateQ(paNewList)
			This.Update(paNewList)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(paNewList)
			This.Update(paNewList)

			def UpdateWithQ(paNewList)
				return This.UpdateQ(paNewList)
	
		def UpdateBy(paNewList)
			This.Update(paNewList)

			def UpdateByQ(paNewList)
				return This.UpdateQ(paNewList)

		def UpdateUsing(paNewList)
			This.Update(paNewList)

			def UpdateUsingQ(paNewList)
				return This.UpdateQ(paNewList)

		#--

		def Fill(paNewList)
			This.Update(paNewList)

			def FillQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillWith(paNewList)
			This.Update(paNewList)

			def FillWithQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillBy(paNewList)
			This.Update(paNewList)

			def FillByQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillUsing(paNewList)
			This.Update(paNewList)

			def FillUsingQ(paNewList)
				return This.UpdateQ(paNewList)

		#>

	def Updated(paNewList)
		return paNewList

		#< @FunctionAlternativeForms

		def UpdatedWith(paNewList)
			return This.Updated(paNewList)

		def UpdatedBy(paNewList)
			return This.Updated(paNewList)

		def UpdatedUsing(paNewList)
			return This.Updated(paNewList)

		#--

		def Filled(paNewList)
			return paNewList

		def FilledWith(paNewList)
			return paNewList
	
		def FilledBy(paNewList)
			return paNewList

		def FilledUsing(paNewList)
			return paNewList

		#>

	  #----------------------#
	 #     ADDING ITEMS     #
	#----------------------#

	def AddItem(pItem)
		aCopy = This.Content()
		aCopy + pItem
		This.UpdateWith(aCopy)

		#< @FunctionFluentForm

		def AddItemQ(pItem)
			This.AddItem(pItem)
			return This
		
		#

		#< @FunctionAlternativeForm

		def Add(pItem)
			This.AddItem(pItem)

			def AddQ(pItem)
				This.Add(pItem)
				return This

		def AppendWith(pItem)
			This.AddItem(pItem)

			def AppendWithQ(pItem)
				This.AppendWithQ(pItem)
				return This

		def Append(pItem)
			if isList(pItem) and Q(pItem).IsWithOrUsingOrByNamedParam()
				pItem = pItem[2]
			ok

			This.AddItem(pItem)

			def AppendQ(pItem)
				This.Append(pItem)
				return This

		#>

	def ItemAdded(pItem)
		aResult = This.Copy().AddItemQ(pItem).Content()
		return aResult

		def Added(pItem)
			return This.ItemAdded(pItem)

		def AppendedWith(pItem)
			return This.ItemAdded(pItem)

		def Appended(pItem)
			return This.ItemAdded(pItem)

	  #-----------------------------------------------------------#
	 #  ADDING AN ITEM AT A GIVEN POSITION --> INSERT OR EXTEND  #
	#-----------------------------------------------------------#

	def AddItemAt(n, pItem) #TODO // Test it!

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n <= This.NumberOfItems()
			This.InsertAt(n, pItem)

		else
			This.ExtendToPositionXT(n - 1, :With = _NULL_)
			This.Add(pItem)
		ok

		#< @FunctionFluentForm

		def AddItemAtQ(n, pItem)
			This.AddItem(n, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddItemAtPosition(n, pItem)
			This.AddItemAt(n, pItem)

			def AddItemAtPositionQ(n, pItem)
				This.AddItemAtPosition(n, pItem)
				return This

		def AddAt(n, pItem)
			This.AddItem(n, pItem)

			def AddAtQ(n, pItem)
				This.AddAt(n, pItem)
				return This
	
		def AddAnNthItem(n, pItem)
			This.AddItem(n, pItem)

			def AddAnNthItemQ(n, pItem)
				This.AddAnNthItem(n, pItem)
				return This

		#>

	  #---------------------------------#
	 #  ADDING MANY ITEMS TO THE LIST  #
	#---------------------------------#

	def AddMany(paItems)
		if CheckingParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)
		aContent = This.Content()

		for i = 1 to nLen
			aContent + paItems[i]
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def AddManyQ(paItems)
			This.AddMany(paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def AddManyItems(paItems)
			This.AddMany(paItems)

			def AddManyItemsQ(paItems)
				This.AddManyItems(paItems)

		def AddEach(paItems)
			This.AddMany(paItems)

			def AddEachQ(paItems)
				This.AddEach(paItems)
				return This

		def AddTheseItems(paItems)
			This.AddMany(paItems)

			def AddTheseItemsQ(paItems)
				This.AddTheseItems(paItems)
				return This

		def AddThese(paItems)
			This.AddMany(paItems)

			def AddTheseQ(paItems)
				This.AddThese(paItems)
				return This
		#>

	def ManyAdded(paItems)
		aResult = This.Copy().AddManyQ(paItems).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ManyItemsAdded(paItems)
			return This.ManyAdded(paItems)

		def EachAdded(paItems)
			return This.ManyAdded(paItems)

		def EachItemAdded(paItems)
			return This.ManyAdded(paItems)

		def TheseItemsAdded(paItems)
			return This.ManyAdded(paItems)

		def TheseAdded(paItems)
			return This.ManyAdded(paItems)

		#>

	  #===================================================#
	 #     INSERTING AN ITEM BEFORE A GIVEN POSITION     #
	#===================================================#

	def Insert(pItem, pWhere)

		if isList(pItem) and Q(pItem).IsItemNamedParam()
			pItem = pItem[2]
		ok

		if isList(pWhere)

			oParam = Q(pWhere)

			if oParam.IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pWhere[2], pItem)
				return

			but oParam.IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pWhere[2], pItem)
				return
			ok
		else
			This.InsertBefore(pWhere, pItem)
		ok

		#< @FunctionFluentForm

		def InsertQ(pItem, pWhere)
			This.Insert( pItem, pWhere )
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertItem(pItem, pWhere)
			This.Insert(pItem, pWhere)

			def InsertItemQ(pItem, pWhere)
				This.InsertItem(pItem, pWhere)
				return This
		#>

	def InsertBeforePosition(n, pItem)
		if isList(n) and Q(n).IsPositionNamedParam()
			n = n[2]
		ok

		if isList(n) and Q(n).IsListOfNumbers()
			This.InsertBeforePositions(n, pItem)
			return
		ok

		if isList(pItem) and Q(pItem).IsItemNamedParam()
			pItem = pItem[2]
		ok

		if n >= 1 and n <= This.NumberOfItems()
			ring_insert(This.List(), n-1, pItem)

		but n > This.NumberofItems()
			This.ExtendToN(n)
			ring_insert(This.List(), n-1, pItem)
			# Using Ring native insert function here

		ok

		#< @FunctionFluentForm

		def InsertBeforePositionQ(n, pItem)
			This.InsertBeforePosition(n, pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAt(n, pItem)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :ItemAt, :ItemAtPosition ])
				n = n[2]
			ok

			aContent = @aContent
			ring_insert(aContent, n, pItem)
			This.UpdateWith(aContent)

			def InsertAtQ(n, pItem)
				This.InsertAt(n, pItem)
				return This

		#>
		
	  #----------------------------------------------------#
	 #     INSERTING AN ITEM AFTER A GIVEN POSITION      #
	#----------------------------------------------------#

	def InsertAfterPosition(n, pItem)

		if isList(n) and Q(n).IsListOfNumbers()
			This.InsertAfterPositions(n, pItem)
			return
		ok

		if n > 0 and n < This.NumberOfItems()
			ring_insert(This.List(), n, pItem)

		ok

		#< @FunctionFluentForm

		def InserAfterPositionQ(n, pItem)
			This.InsertAfterPosition(n, pItem)
			return This

		#>

	  #-------------------------------------------------------------#
	 #  INSERTING A NEW ITEM BEFORE THE POSITIONS OF A GIVEN ITEM  #
	#-------------------------------------------------------------#

	def InsertBeforeItemCS(pItem, pNewItem, pCaseSensitive)
		anPos = This.FindCS(pItem, pCaseSensitive)
		This.InsertBeforePositions(anPos, pNewItem, pCaseSensitive)

		def InsertBeforeItemCSQ(pItem, pNewItem, pCaseSensitive)
			This.InsertBeforeItemCS(pItem, pNewItem, pCaseSensitive)
			return This

		def InsertBeforeCS(pItem, pNewItem, pCaseSensitive)
			This.InsertBeforeItemCS(pItem, pNewItem, pCaseSensitive)

			def InsertBeforeCSQ(pItem, pNewItem, pCaseSensitive)
				return This.InsertBeforeCS(pItem, pNewItem, pCaseSensitive)

	def ItemInsertedBeforeCS(pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().InsertBeforeItemCSQ(pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		def InsertedBeforeCS(pItem, pNewItem, pCaseSensitive)
			return This.ItemInsertedBeforeCS(pItem, pNewItem, pCaseSensitive)

	  #---------------------------------------------------#
	 #  INSERTING MANY ITEMS BEFORE THE GIVEN POSITIONS  #
	#---------------------------------------------------#

	#TODO		
	def InsertManyBeforePositions(panPos, paItems)
		StzRaise("Not yet immplemented!")

		def InsertManyBeforePositionsQ(panPos, paItems)
			This.InsertManyBeforePositions(panPos, paItems)
			return This

		def InsertManyItemsBeforePositions(panPos, paItems)
			This.InsertManyBeforePositions(panPos, paItems)

			def InsertManyItemsBeforePositionsQ(panPos, paItems)
				return This.InsertManyBeforePositions(panPos, paItems)

	  #----------------------------------------------#
	 #  INSERTING MANY ITEMS BEFORE THE GIVEN ITEM  #
	#----------------------------------------------#

	#TODO		
	def InsertManyBeforeItem(pItem, paItems)
		StzRaise("Not yet immplemented!")

		def InsertManyBeforeItemQ(pItem, paItems)
			This.InsertManyBeforeItem(pItem, paItems)
			return This

		def InsertManyItemsBeforeItem(pItem, paItems)
			This.InsertManyBeforeItem(pItem, paItems)

			def InsertManyItemsBeforeItemQ(pItem, paItems)
				return This.InsertManyBeforeItem(pItem, paItems)

	  #------------------------------------------------------------#
	 #  INSERTING A NEW ITEM AFTER THE POSITIONS OF A GIVEN ITEM  #
	#------------------------------------------------------------#

	def InsertAfterItemCS(pItem, pNewItem, pCaseSensitive)
		anPos = This.FindCS(pItem, pCaseSensitive)
		This.InsertAfterPositions(anPos, pNewItem, pCaseSensitive)

		def InsertAfterItemCSQ(pItem, pNewItem, pCaseSensitive)
			This.InsertAfterItemCS(pItem, pNewItem, pCaseSensitive)
			return This

		def InsertAfterCS(pItem, pNewItem, pCaseSensitive)
			This.InsertAfterItemCS(pItem, pNewItem, pCaseSensitive)

			def InsertAfterCSQ(pItem, pNewItem, pCaseSensitive)
				return This.InsertAfterCS(pItem, pNewItem, pCaseSensitive)

	def ItemInsertedAfterCS(pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().InsertAfterItemCSQ(pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		def InsertedAfterCS(pItem, pNewItem, pCaseSensitive)
			return This.ItemInsertedAfterCS(pItem, pNewItem, pCaseSensitive)

	  #--------------------------------------------------#
	 #  INSERTING MANY ITEMS AFTER THE GIVEN POSITIONS  #
	#--------------------------------------------------#

	#TODO		
	def InsertManyAfterPositions(panPos, paItems)
		StzRaise("Not yet immplemented!")

		def InsertManyAfterPositionsQ(panPos, paItems)
			This.InsertManyAfterPositions(panPos, paItems)
			return This

		def InsertManyItemsAfterPositions(panPos, paItems)
			This.InsertManyAfterPositions(panPos, paItems)

			def InsertManyItemsAfterPositionsQ(panPos, paItems)
				return This.InsertManyAfterPositions(panPos, paItems)

	  #---------------------------------------------#
	 #  INSERTING MANY ITEMS AFTER THE GIVEN ITEM  #
	#---------------------------------------------#

	#TODO		
	def InsertManyAfterItem(pItem, paItems)
		StzRaise("Not yet immplemented!")

		def InsertManyAfterItemQ(pItem, paItems)
			This.InsertManyAfterItem(pItem, paItems)
			return This

		def InsertManyItemsAfterItem(pItem, paItems)
			This.InsertManyAfterItem(pItem, paItems)

			def InsertManyItemsAfterItemQ(pItem, paItems)
				return This.InsertManyAfterItem(pItem, paItems)

	  #---------------------------------------#
	 # TODO: Add same functions as stzString #
	#---------------------------------------#
	
	/*
	INSERTING BEFORE/AFTER THE NTH OCCURRENCE OF AN ITEM
		INSERTING BEFORE/AFTER THE FIRST OCCURRENCE OF AN ITEM
		INSERTING BEFORE/AFTER THE LAST OCCURRENCE OF AN ITEM
	
	INSERTING BEFORE THE NEXT NTH OCCURRENCE OF AN ITEM STARTING AT
		INSERTING BEFORE/AFTER THE NEXT OCCURRENCE OF AN ITEM STARTING AT
	
	INSERTING BEFORE THE PREVIOUS NTH OCCURRENCE OF AN ITEM STARTING AT
		INSERTING BEFORE/AFTER THE PREVIOUS OCCURRENCE OF AN ITEM STARTING AT
	*/

	  #--------------------------------#
	 #     OTHER INSERTING FORMS      #TODO
	#--------------------------------#

	def InsertAfterEachNumberOfSteps(n, pItem) // TODO
		/* Example : InsertAfterEachNumberOfSteps(2, "*")
		a = [ "A" , "B" , "C"  , "D" , "E" , "F" , "G" ]
		-->
		a = [ "A" , "B" , "*" , "D" , "E" , "*" , "F" , "G" ]
		*/

	def InsertAfterEachSequenceOfSteps(paSteps, pItem) // TODO
		/* Example : InsertAfterEachSequenceOfSteps([2,1], pcStr)
		a = [ "A" , "B" , "C"  , "D" , "E" , "F" , "G" ]
		-->
		a = [ "A" , "B" , "*" , "D" , "*" "E" , "F" , "*" , "G" , "*" ]
		*/

	def InsertRandomlyBefore(pItem)
		n = random( This.NumberOfItems() )
		This.InsertBefore(n, pItem)

		#< @FunctionFluentForm

		def InsertRandomlyBeforeQ(pItem)
			This.InsertRandomlyBefore(pItem)
			return This

		#>

	def InsertRandomlyAfter(pItem)
		n = random( This.NumberOfItems() )
		This.InsertAfter(n, pItem)

		#< @FunctionFluentForm

		def InsertRandomlyAfterQ(pItem)
			This.InsertRandomlyAfter(pItem)
			return This

		#>

	  #=============================================#
	 #  MOVING ITEM AT POSITION N1 TO POSITION N2  #
	#=============================================#

	def Move(n1, n2)

		# Checking params correctness

		if CheckingParams()

			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([
				:From, :FromPosition,
				:At, :AtPosition,
				:Item, :ItemAt, :ItemAtPosition,
				:FromItemAt, :FromItemAtPosition,
				:ItemFrom, :ItemFromPosition
			   ])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToPosition, :ToItem, :ToItemAt,
				:ToItemAtPosition, :ToPositionOfItem ])
	
				n2 = n2[2]
			ok
	
			if isString(n1) and
			   ring_find([ :First, :FirstPosition, :FirstItem ], n1) > 0
				n1 = 1
			ok
	
			if isString(n2) and
			   ring_find([ :Last, :LastPosition, :LastItem ], n2)
				n2 = This.NumberOfItems()
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

		ok

		# Doing the job

		aContent = This.Content()

		item = aContent[n1]
		ring_remove(aContent, n1)

		n = n2
		if n1 > n2
			n++
		ok

		ring_insert(aContent, n2, item)
		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def MoveQ(n1, n2)
			This.Move(n1, n2)
			return This

		#>

	  #-------------------------------------------#
	 #  MOVING A GIVEN ITEM TO A GIVEN POSITION  #
	#-------------------------------------------#
	#NOTE
	# Only the first position of pItem in the list is moved

	def MoveItemCS(pItem, n, pCaseSensitive)
		if CheckingParams()
			if isList(n) and Q(n).IsToOrToPositionNamedParam()
				n = n[2]
			ok

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		if n < 1 or n > len(@aContent)
			return
		ok

		n1 = This.FindFirstCS(pItem, pCaseSensitive)
		if n1 = 0
			return
		ok

		This.Move(n1, n)

		def MoveItemCSQ(pItem, n, pCaseSensitive)
			This.MoveItemCS(pItem, n, pCaseSensitive)
			return This

	def ItemMovedCS(pItem, n, pCaseSensitive)
		aResult = This.Copy().MoveItemCSQ(pItem, n, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def MoveItem(pItem, n)
		return This.MoveItemCS(pItem, n, _TRUE_)

		def MoveItemQ(pItem, n)
			This.MoveItem(pItem, n)
			return This

	  #=========================================#
	 #  SWAPPING ITEMS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if CheckingParams()

			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedPArams([
				:Between, :BetweenPosition, :BetweenPositions,
				:BetweenItem, :BetweenItems,
				:BetweenItemAt, :BetweenItemAtPosition, :BetweenItemAtPositions,
				:Position, :Positions, :ItemAt, :ItemAtPosition, :ItemAtPositions,
				:Items, :ItemsAt, :ItemsAtPosition, :ItemsAtPositions
			   ])
	
				n1 = n1[2]
			ok
	
			if NOT isNumber(n1)
				n1 = This.FindFirst(n1)
			ok

			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedPArams([
				:And, :AndPosition, :AndItemAt, :AndItemAtPosition, :AndItem ])
	
				n2 = n2[2]
			ok

			if NOT isNumber(n2)
				n2 = This.FindFirst(n2)
			ok
		ok

		_oList_ = This.Copy()

		copy = This[n2]
		_oList_.ReplaceItemAtPosition(n2, :By = This[n1])
		_oList_.ReplaceItemAtPosition(n1, :By = copy)

		This.UpdateWith(_oList_.Content())


		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

		def SwapItem(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndItemAt, :AndItemAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)
		#>

	  #=========================================#
	 #   REPLACING ALL ITEMS WITH A NEW ITEM   #
	#=========================================#

	def ReplaceAllItems(pNewItem)

		_nLen_ = This.NumberOfItems()
		_aContent_ = This.Content()

		for @i = 1 to _nLen_
			_aContent_[@i] = pNewItem
		next

		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def ReplaceAllItemsQ(pNewItem)
			This.ReplaceAllItems(pNewItem)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceEachItem(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachOccurrenceOfItem(pNewItem)
			This.ReplaceAllItems(pNewItem)

		#--

		def ReplaceAllItemsWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachItemWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachOccurrenceOfItemWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		#>

	  #-------------------------------------------#
	 #   REPLACING ALL OCCURRENCES OF AN ITEM    #
	#-------------------------------------------#

	def ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

		if CheckingParams()

			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceAnyItemAtPositionCS(anPos[i], pNewItem, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAllOccurrencesCSQ(pItem, pNewItem, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)
			return This

		def ReplaceAllOccurrencesCSQC(pItem, pNewIteme, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)
			return _oCopy_

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceItemCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceItemCS(pItem, pNewItem, pCaseSensitive)
				return This

			def ReplaceItemCSQC(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceAllOccurrencesCSQC(pItem, pNewIteme, pCaseSensitive)

		def ReplaceAllCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceAllCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceAllCS(pItem, pNewItem, pCaseSensitive)
				return This

			def ReplaceAllCSQC(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceAllOccurrencesCSQC(pItem, pNewIteme, pCaseSensitive)

		def ReplaceCS(pItem, pNewItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceCS(pItem, pNewItem, pCaseSensitive)
				return This

			def ReplaceCSQC(pItem, pNewItem, pCaseSensitive)
				_oCopy_ = This.Copy()
				_oCopy_.ReplaceCS(pItem, pNewItem, pCaseSensitive)
				return _oCopy_

		#--

		def ReplaceAnyCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceAnyCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceAnyCS(pItem, pNewItem, pCaseSensitive)
				return This

			def ReplaceAnyCSQC(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceAllOccurrencesCSQC(pItem, pNewIteme, pCaseSensitive)

		def ReplaceThisItemCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceThisItemCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceThisItemCS(pItem, pNewItem, pCaseSensitive)
				return This

			def ReplaceThisItemCSQC(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceAllOccurrencesCSQC(pItem, pNewIteme, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceItemCSQ(pItem, pNewItem, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOccurrencesOfItemReplacedByCS(pItem, pNewItem, pCaseSensitive)
			return ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		def ItemReplacedCS(pItem, pNewItem, pCaseSensitive)
			return ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedCS(pItem, pNewItem, pCaseSensitive)
			return ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedByCS(pItem, pNewItem, pCaseSensitive)
			return ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAllOccurrences(pItem, pNewItem)
		This.ReplaceAllOccurrencesCS(pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAllOccurrencesQ(pItem, pNewIteme)
			This.ReplaceAllOccurrences(pItem, pNewItem)
			return This

		def ReplaceAllOccurrencesQC(pItem, pNewIteme)
			return This.ReplaceAllOccurrencesQC(pItem, pNewIteme, _TRUE)

		#>

		#< @FunctionAlternativeForms

		def ReplaceItem(pItem, pNewItem)
			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceItemQ(pItem, pNewItem)
				This.ReplaceItem(pItem, pNewItem)
				return This

			def ReplaceItemQC(pItem, pNewItem)
				return This.ReplaceAllOccurrencesQC(pItem, pNewItem)

		def ReplaceAll(pItem, pNewItem)
			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceAllQ(pItem, pNewItem)
				This.ReplaceAll(pItem, pNewItem)
				return This

			def ReplaceAllQC(pItem, pNewItem)
				return This.ReplaceAllOccurrencesQC(pItem, pNewIteme)

		def Replace(pItem, pNewItem)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceQ(pItem, pNewItem)
				This.Replace(pItem, pNewItem)
				return This

			def ReplaceQC(pItem, pNewItem)
				return This.ReplaceQC(pItem, pNewItem, _TRUE_)

		#--

		def ReplaceAny(pItem, pNewItem)
			This.Replace(pItem, pNewItem)

			def ReplaceAnyQ(pItem, pNewItem)
				This.ReplaceAny(pItem, pNewItem)
				return This

			def ReplaceAnyQC(pItem, pNewItem)
				return This.ReplaceAllQC(pItem, pNewItem)

		def ReplaceThisItem(pItem, pNewItem)
			This.Replace(pItem, pNewItem)

			def ReplaceThisItemQ(pItem, pNewItem)
				This.ReplaceThisItem(pItem, pNewItem)
				return This

			def ReplaceThisItemQC(pItem, pNewItem)
				return This.ReplaceThisItemQC(pItem, pNewItem, _TRUE_)

		#>

	#-- @FunctionPassiveForms

	def ItemReplacedBy(pItem, pNewItem)

		aResult =  This.Copy().
				ReplaceItemQ(pItem, pNewItem).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOccurrencesOfItemReplacedBy(pItem, pNewItem)
			return ItemReplacedBy(pItem, pNewItem)

		def ItemReplaced(pItem, pNewItem)
			return ItemReplacedBy(pItem, pNewItem)

		def ThisItemReplaced(pItem, pNewItem)
			return ItemReplacedBy(pItem, pNewItem)

		def ThisItemReplacedBy(pItem, pNewItem)
			return ItemReplacedBy(pItem, pNewItem)

		#>

	  #----------------------------------------------#
	 #   REPLACING FIRST N OCCURRENCES OF AN ITEM   #
	#==============================================#

	def ReplaceFirstNOccurrences(n, pItem, pNewItem)
		This.ReplaceTheseOccurrences( 1 : n, pItem, pNewItem )

		def ReplaceFirstNOccurrencesQ(n, pItem, pNewItem)
			This.ReplaceFirstNOccurrences(n, pItem, pNewItem)
			return This

		def ReplaceNFirstOccurrences(n, pItem, pNewItem)
			This.ReplaceFirstNOccurrences(n, pItem, pNewItem)

			def ReplaceNFirstOccurrencesQ(n, pItem, pNewItem)
				This.ReplaceNFirstOccurrences(n, pItem, pNewItem)

	def FirstNOccurrencesReplaced(n, pItem, pNewItem)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pItem, pNewItem).Content()

		def NFirstOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

		#-- MISSPELLED

		def FristNOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

		def NFristOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

	  #---------------------------------------------#
	 #   REPLACING LAST N OCCURRENCES OF AN ITEM   #
	#---------------------------------------------#

	def ReplaceLastNOccurrences(n, pItem, pNewItem)
		nNumberOfOccurr = This.NumberOfOccurrences(pItem)
		n1 = nNumberOfOccurr - n + 1
		This.ReplaceTheseOccurrences( n1 : nNumberOfOccurr, pItem, pNewItem )

		def ReplaceLastNOccurrencesQ(n, pItem, pNewItem)
			This.ReplaceLastNOccurrences(n, pItem, pNewItem)
			return This

		def ReplaceNLastOccurrences(n, pItem, pNewItem)
			This.ReplaceLastNOccurrences(n, pItem, pNewItem)

			def ReplaceNLastOccurrencesQ(n, pItem, pNewItem)
				This.ReplaceNLastOccurrences(n, pItem, pNewItem)

	def LastNOccurrencesReplaced(n, pItem, pNewItem)
		return This.Copy().ReplaceLastNOccurrencesQ(n, pItem, pNewItem).Content()

		def NLastOccurrencesReplaced(n, pItem, pNewItem)
			return This.LastNOccurrencesReplaced(n, pItem, pNewItem)


	  #--------------------------------------#
	 #     REPLACING MANY ITEMS AT ONCE     #
	#======================================#

	def ReplaceManyCS(paItems, pNewItem, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzList([ "a", "+", "b", "-", "c", "/", "d", "=", "0" ])
		o1.ReplaceMany( ["+", "-", "/" ], :By = "*" )
		? o1.Content()
	
		#--> [ "a", "*", "b", "*", "c", "*", "d", "=", "0" ]
	
		*/

		if CheckingParams()

			if NOT isList(paItems)
				stzRaise("Incorrect param type! paItems must be a list.")
			ok
	
			if isList(pNewItem) and Q(pNewItem).IsWithOrByNamedParam()
				pNewItem = pNewItem[2]
			ok

		ok

		# Doing the job

		paItems = Q(paItems).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(paItems)

		oCopy = This.Copy()

		for i = 1 to nLen
			oCopy.ReplaceCS( paItems[i], pNewItem, pCaseSensitive )
		next

		This.UpdateWith(oCopy.Content())

		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceAllOfTheseCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceManyItemsCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceManyItemsCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceItemsCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceItemsCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseItemsCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		#>

	def ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
		acResult = This.Copy().ReplaceManyItemsCSQ(paItems, pNewItem, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def ItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def TheseReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(paItems, pNewItem)
		This.ReplaceManyCS( paItems, pNewItem, _TRUE_ )

		#< @FunctionFluentFormn

		def ReplaceManyQ(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForm

		def ReplaceThese(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceTheseQ(paItems, pItem)
				This.ReplaceThese(paItems, pItem)
				return This

		def ReplaceTheseItems(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceTheseItemsQ(paItems, pItem)
				This.ReplaceTheseItems(paItems, pItem)
				return This

		def ReplaceAllOfThese(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceAllOfTheseQ(paItems, pItem)
				This.ReplaceAllOfThese(paItems, pItem)
				return This

		def ReplaceManyItems(paItems, pNewItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceManyItemsQ(paItems, pNewItem)
				This.ReplaceManyItems(paItems, pNewItem)
				return This

		def ReplaceItems(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceItemsQ(paItems, pItem)
				return This.ReplaceManyQ(paItems, pNewItem)

		#>

	def ManyItemsReplaced(paItems, pNewItem)
		acResult = This.Copy().ReplaceManyItemsQ(paItems, pNewItem).Content()
		return acResult

		#< @FunctionAlternativeForms

		def TheseReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def TheseItemsReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def ManyReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def ItemsReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		#>

	  #---------------------------------------------------#
	 #     REPLACING MANY ITEMS BY THE ITEM PRIVIDED     #
	#---------------------------------------------------#

	def ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

		if CheckingParams()

			if NOT isList(paItems)
				stzRaise("Incorrect param type! paItems must be a list.")
			ok

		ok

		# Doing the job

		paItems = Q(paItems).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(paItems)
		
		for i = 1 to nLen
			This.ReplaceCS( paItems[i], pNewItem, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseItemsByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceAllOfTheseByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceAllOfTheseByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceManyItemsByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceManyItemsByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceItemsByCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceItemsByCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		#>

	def ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
		acResult = This.Copy().ReplaceManyItemsByCSQ(paItems, pNewItem, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		def ItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceManyBy(paItems, pNewItem)
		This.ReplaceManyByCS( paItems, pNewItem, _TRUE_ )

		#< @FunctionFluentFormn

		def ReplaceManyByQ(paItems, pItem)
			This.ReplaceManyBy(paItems, pNewItem)
			return This
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceTheseByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceTheseItemsBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceTheseItemsByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceAllOfTheseBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceAllOfTheseByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceManyItemsBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceManyItemsByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceItemsBy(paItems, pItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceItemsByQ(paItems, pItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		#>

	def ManyItemsReplacedBy(paItems, pNewItem)
		acResult = This.Copy().ReplaceManyItemsByQ(paItems, pNewItem).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		def ItemsReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		def TheseItemsReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		#>

	  #---------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY ITEMS  #
	#---------------------------------------#

	def ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ruby", "ring", "python", "ring" ])
		o1.ReplaceByMany("ring", [ "", "", "" ])
	
		? o1.Content() #--> [ "", "php", "ruby", "", "python", "" ]

		*/

		anPos = This.FindCS(pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemByManyCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByManyCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByManyCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByManyCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemReplacedByManyCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ReplacedByTheseItemsCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplaceByManyCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplaceByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByTheseItemsCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pItem, paNewItems)
		This.ReplaceByManyCS(pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceByManyQ(pItem, paNewItems)
			return This.ReplaceByManyCSQ(pItem, paNewItems, _TRUE_)

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByMany(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceItemByManyQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceItemByThese(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceItemByTheseQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceThisItemByMany(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceThisItemByManyQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceThisItemByThese(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceThisItemByTheseQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		#>

	#-- @FunctionPassiveForms

	def ReplacedByMany(pItem, paNewItems)
		return This.ReplacedByManyCS(pItem, paNewItems, _TRUE_)

		#< @FunctionAlternativeForms

		def ItemReplacedByMany(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ReplacedByTheseItems(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplaceByMany(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ItemReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplaceByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplacedByTheseItems(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		#>



	  #---------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY ITEMS -- EXTENDED (RETURN TO FIRST)  #
	#---------------------------------------------------------------------#

	def ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "ring" ])
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> [ "#1", "php", "#2", "ruby", "#1", "python", "#2" ]

		*/

		if isList(paNewItems) and StzListQ(paNewItems).IsWithOrByNamedParam()
			paNewItems = paNewItems[2]
		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCSXT(anPos, pItem, paNewItems, pCaseSensitive)


		#< @FunctionFluentForm

		def ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ReplacedByThesesCSXT(pITem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ReplacedByThesesItemsCSXT(pITem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)



	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pItem, paNewItems)
		This.ReplaceByManyCSXT(pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceByManyXTQ(pItem, paNewItems)
			return This.ReplaceByManyCSXTQ(pItem, paNewItems, _TRUE_)

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByManyXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByManyXT(pItem, paNewItems)
			This.ReplaceByManyCXT(pItem, paNewItems)

			def ReplaceThisItemByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByManyXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceItemByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisItemByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceItemByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisItemByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		#>

	#-- @FunctionPassiveForms

	def ReplacedByManyXT(pItem, paNewItems)
		cResult = This.Copy().ReplaceByManyXTQ(pItem, paNewItems).Content()
		return cResult

		def ItemReplacedByManyXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ThisItemReplacedByManyXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ItemReplacedByTheseXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ItemReplacedByTheseItemsXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ReplacedByThesesXT(pITem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ReplacedByThesesItemsXT(pITem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)



	  #--------------------------------------------#
	 #  REPLACING MANY ITEMS BY MANY OTHER ITEMS  #
	#--------------------------------------------#

	def ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "ring" ])
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "", "", "" ])

		? o1.Content() #--> [ "", "qt", "", "pyhton", "", "csharp", "" ]
		*/

		if CheckingParams()
	
			if isList(paNewItems) and Q(paNewItems).IsWithOrByNamedParam()
				paNewItems = paNewItems[2]
			ok

		ok

		# Doing the job

		paItems = StzListQ(paItems).WithoutDuplication()	
		nLenItems = len(paItems)
		nLenNewItems = len(paNewItems)

		if nLenItems = 0 or nLenNewItems = 0
			return
		ok

		if NOT ( nLenItems = nLenNewItems )
			StzRaise("Incorrect values! nLenItems and nLenNewItems must have the same size.")
		ok

		for i = 1 to nLenItems
			This.ReplaceCS(paItems[i], paNewItems[i], pCaseSensitive)
		next


		#< @FunctionFluentForm

		def ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByManyCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseItemsCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		#--

		def ReplaceTheseByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceTheseItemsByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive).Content()
		return cResult

		def ItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ManyReplacedByManyCS(paItems, paNewItems, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(paItems, paNewItems)
		This.ReplaceManyByManyCS(paItems, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceManyByManyQ(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByMany(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByManyQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		def ReplaceManyItemsByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByTheseQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseItems(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByTheseItemsQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		#--

		def ReplaceTheseByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceTheseByTheseQ(paItems, paNewItems)
				This.ReplaceTheseByThese(paItems, paNewItems)
				return This

		def ReplaceTheseItemsByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceTheseItemsByTheseQ(paItems, paNewItems)
				This.ReplaceTheseByThese(paItems, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def ManyItemsReplacedByMany(paItems, paNewItems)
		cResult = This.Copy().ReplaceManyByManyQ(paItems, paNewItems).Content()
		return cResult

		def ItemsReplacedByMany(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def TheseItemsReplacedByThese(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def ItemsReplacedByThese(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def TheseItemsReplacedByTheseItems(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def ItemsReplacedByTheseItems(paItems, paNewItems)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems)

		def ManyReplacedByMany(paItems, paNewItems)
			return This.ManySubStringsReplacedByMany(paItems, paNewItems)


	  #--------------------------------------------------#
	 #  REPLACING MANY ITEMS BY MANY OTHER ITEMS -- XT  #
	#--------------------------------------------------#
	# XT ~> Return to beginning if all the other items are replaced

	def ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "zai" ])
		o1.ReplaceManyByManyXT([ "ring", "softanza", "kandaji", "zai" ], :By = [ "", "" ])
		
		? o1.Content()
		#--> [ "", "qt", "", "pyhton", "", "csharp", "" ]

		*/

		if CheckingParams()
	
			if isList(paNewItems) and Q(paNewItems).IsWithOrByNamedParam()
				paNewItems = paNewItems[2]
			ok

		ok

		# Doing the job

		aItems = StzListQ(paItems).WithoutDupplication()
		nLenItems = len(paItems)
		nLenNewItems = len(paNewItems)

		if nLenItems = 0 or nLenNewItems = 0
			return
		ok

		# Extending or shrinking aNewItems, if necessary, so it has
		# the same size as aItems

		if nLenNewItems < nLenItems
			aNewItems = paNewItems
			n = 0
			for i = nLenNewItems + 1 to nLenItems # ~> for i = 2 to 4
				n++
				if n > nLenNewItems
					n = 1
				else
					aNewItems + paNewItems[n]
				ok
			next
		else
			aNewItems = []
			for i = 1 to nLenItems
				aItems + paNewItems[i]
			next
		ok

		# Calling the normal function

		This.ReplaceManyByManyCS(aItems, aNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByManyCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseItemsCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		#--

		def ReplaceTheseByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceTheseItemsByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive).Content()
		return cResult

		def ItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def ManyReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManySubStringsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByManyXT(paItems, paNewItems)
		This.ReplaceManyByManyCSXT(paItems, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceManyByManyXTQ(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByManyXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByTheseXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseItemsXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByTheseItemsXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		#--

		def ReplaceTheseByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceTheseByTheseXTQ(paItems, paNewItems)
				This.ReplaceTheseByTheseXT(paItems, paNewItems)
				return This

		def ReplaceTheseItemsByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceTheseItemsByTheseXTQ(paItems, paNewItems)
				This.ReplaceTheseByTheseXT(paItems, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def ManyItemsReplacedByManyXT(paItems, paNewItems)
		cResult = This.Copy().ReplaceManyByManyXTQ(paItems, paNewItems).Content()
		return cResult

		def ItemsReplacedByManyXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def TheseItemsReplacedByTheseXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def ItemsReplacedByTheseXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def TheseItemsReplacedByTheseItemsXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def ItemsReplacedByTheseItemsXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems)

		def ManyReplacedByManyXT(paItems, paNewItems)
			return This.ManySubStringsReplacedByManyXT(paItems, paNewItems)


	  #----------------------------------------------------------------------------------#
	 #  REPLACING ANY ITEM AT GIVEN POSITION (OR POSITIONS) WITH THE NEW ITEM PROVIDED  #
	#==================================================================================#

	def ReplaceAnyAtCS(pPos, pNewItem, pCaseSensitive)
		if isNumber(pPos)
			This.ReplaceAnyItemAtPosition(pPos, pNewItem)

		but isList(pPos)
			This.ReplaceAnyItemAtPositions(pPos, pNewItem)

		else
			StzRaise("Incorrect param type! pPos must be number or list of numbers.")
		ok

		#< @FunctionFluentForm

		def ReplaceanyAtCSQ(pPos, pNewItem, pCaseSensitive)
			This.ReplaceanyAtCS(pPos, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemAtCS(pPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyAtCS(pPos, pNewItem, pCaseSensitive)
	
			def ReplaceAnyItemAtCSQ(pPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyAtCSQ(pPos, pNewItem, pCaseSensitive)
	
		def ReplaceAtCS(pPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyAtCS(pPos, pNewItem, pCaseSensitive)

			def ReplaceAtCSQ(pPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyAtCSQ(pPos, pNewItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def AnyItemReplacedAtCS(pPos, pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceAnyItemAtCSQ(pPos, pNewItem, pCaseSensitive).Content()
		return aResult

		def ReplacedAtCS(pPos, pNewItem, pCaseSensitive)
			return This.AnyItemReplacedAtCS(pPos, pNewItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyAt(pPos, pNewItem)
		This.ReplaceAnyAtCS(pPos, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAnyAtQ(pPos, pNewItem)
			This.ReplaceAnyAt(pPos, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemAt(pPos, pNewItem)
			This.ReplaceAnyAt(pPos, pNewItem)
	
			def ReplaceAnyItemAtQ(pPos, pNewItem)
				return This.ReplaceAnyAtQ(pPos, pNewItem)

		def ReplaceAt(pPos, pNewItem)
			This.ReplaceAnyAt(pPos, pNewItem)

			def ReplaceAtQ(pPos, pNewItem)
				return This.ReplaceAnyAtQ(pPos, pNewItem)

		#>

	#-- @FunctionPassiveForm

	def AnyItemReplacedAt(pPos, pNewItem)
		aResult = This.Copy().ReplaceAnyItemAtQ(pPos, pNewItem).Content()
		return aResult

		def ReplacedAt(pPos, pNewItem)
			return This.AnyItemReplacedAt(pPos, pNewItem)

	  #---------------------------------------------------------------#
	 #  REPLACING ANY ITEM AT POSITION N WITH THE NEW ITEM PROVIDED  #
	#===============================================================#

	def ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)
		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		aContent = This.Content()
		aContent[n] = pNewItem

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtPositionNCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceItemAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceItemAtPositionCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceAnyItemAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyItemAtPositionCSQ(n, pNewItem, pCaseSensitive)
				This.ReplaceAnyItemAtPositionCS(n, pNewItem, pCaseSensitive)
				return This

		def ReplaceAnyAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionCSQ(n, pNewItem, pCaseSensitive)

		#--

		def ReplaceAnyAtPositionNCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionNCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSXTQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	def AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def ItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		def AnyItemAtPositionReplacedCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		def AnyReplacedAtPositionCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		def AnyItemReplacedAtPositionCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionN(n, pNewItem)
		return This.ReplaceAnyItemAtPositionNCS(n, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionNQ(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtPositionN(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceItemAtPositionNQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceItemAt(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceItemAtQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAtPositionQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceItemAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceItemAtPositionQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceAnyItemAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyItemAtPositionQ(n, pNewItem)
				This.ReplaceAnyItemAtPosition(n, pNewItem)
				return This

		def ReplaceAnyAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyAtPositionQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionQ(n, pNewItem)

		#--

		def ReplaceAnyAtPositionN(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyAtPositionNQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNXTQ(n, pItem, pNewItem)

		#>

	#-- @FunctionPassiveForms

	def AnyItemAtPositionNReplaced(n, pNewItem)
		cResult = This.Copy().ReplaceAnyItemAtPositionNQ(n, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeforms

		def ItemAtPositionNReplaced(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		def AnyItemAtPositionReplaced(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		def AnyReplacedAtPosition(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		def AnyItemReplacedAtPosition(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		#>



	  #-----------------------------------------------------------------------#
	 #  REPLACING ANY ITEMS AT THE GIVEN POSITIONS BY THE NEW ITEM PROVIDED  #
	#-----------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)
		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		aContent = This.Content()
		nLen = len(panPos)

		for i = 1 to nLen
			aContent[ panPos[i] ] = pNewItem
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
				return This

		def ReplaceAnyAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		def ReplaceAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				This.ReplaceAtPositionsCS(panPos, pNewItem, pCaseSensitive)
				return This

		def ReplaceItemsAtCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceItemsAtCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		def ReplaceItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsCSQ(panPos, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		def ReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		def ItemsReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositions(panPos, pNewItem)
		return This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsQ(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemsAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)
				This.ReplaceAnyItemsAtPositions(panPos, pNewItem)
				return This

		def ReplaceAnyAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAnyAtPositionsQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		def ReplaceAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAtPositionsQ(panPos, pNewItem)
				This.ReplaceAtPositions(panPos, pNewItem)
				return This

		def ReplaceItemsAt(panPos, pNewItem)
			This.ReplaceAnyItemsAtPositions(panPos, pNewItem)

			def ReplaceItemsAtQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		def ReplaceItemsAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemsAtPositions(panPos, pNewItem)

			def ReplaceItemsAtPositionsQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		def ReplaceItemsAtThesePositions(panpos, paNewItems)
			This.ReplaceAnyItemsAtPositions(panPos, paNewItems)

			def ReplaceItemsAtThesePositionsQ(panpos, paNewItems)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplaced(panPos, pNewItem)
		cResult = This.Copy().ReplaceAnyItemAtPositionsQ(panPos, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeform

		def AnyItemReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		def ReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		def ItemsReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		def ItemsReplacedAtThesePositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		#>
	  #----------------------------------------------------------------------------#
	 #  REPLACING A GIVEN ITEM (IF IT EXISTS) AT THE GIVEN POSITION OR POSITIONS  #
	#============================================================================#

	def ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)

		if isNumber(n)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

		but isList(n) and @IsListOfNumbers(n)
			This.ReplaceThisItemAtPositionsCS(n, pItem, pNewItem, pCaseSensitive)

		else
			StzRaise("Incorrect param type! n must be a number or list of numbers.")
		ok

		#< @FunctionFluentForm

		def ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisAtCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisNthItemCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceItemAtCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisNthItemCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ThisReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisNthItemReplacedCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAt(n, pItem, pNewItem)
		This.ReplaceThisItemAtCS(n, pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceThisItemAtQ(n, pItem, pNewItem)
			This.ReplaceThisItemAt(n, pItem, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisAt(n, pItem, pNewItem)
			This.ReplaceThisItemAt(n, pItem, pNewItem)

			def ReplaceThisAtQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtQ(n, pItem, pNewItem)

		def ReplaceThisNthItem(n, pItem, pNewItem)
			This.ReplaceItemAt(n, pItem, pNewItem)

			def ReplaceThisNthItemQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtQ(n, pItem, pNewItem)

		#>

	#-- @FunctionPassiveForm

	def ThisItemReplacedAt(n, pItem, pNewItem)
		return This.ThisItemReplacedAtCS(n, pItem, pNewItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ThisReplacedAt(n, pItem, pNewItem)
			return This.ThisItemReplacedAt(n, pItem, pNewItem)

		def ThisNthItemReplaced(n, pItem, pNewItem)
			return This.ThisItemReplacedAt(n, pItem, pNewItem)

		#>

	  #--------------------------------------------------------#
	 #  REPLACING AN ITEM IF IT EXISTS AT THE GIVEN POSITION  #
	#========================================================#

	def ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		aContent = This.Content()
		anPos = This.FindCS(pItem, pCaseSensitive)

		if len(anPos) > 0 and ring_find(anPos, n) > 0
			aContent[n] = pNewItem
		ok

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisItemAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisItemAtPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		#--

		def ReplaceThisItemAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisItemAtThisPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtThisPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtThisPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisItemReplacedAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#--

		def ThisItemAtThisPositionReplacedCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAtPosition(n, pItem, pNewItem)
		This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionQ(n, pItem, pNewItem)
			return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, _TRUE_)

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisItemAtPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisItemAtPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtPosition(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtPositionQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		#--

		def ReplaceThisItemAtThisPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisItemAtThisPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtThisPosition(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtThisPositionQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtThisPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtThisPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		#>

	#-- @FunctionPassiveForms

	def ThisItemAtPositionNReplaced(n, pItem, pNewItem)
		cResult = This.Copy().ReplaceThisItemAtPositionNCSQ(n, pItem, pNewItem, _TRUE_).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisItemReplacedAtPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		#--

		def ThisItemAtThisPositionReplaced(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtThisPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtThisPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtThisPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtThisPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		#>
			
	  #-----------------------------------------------------------------------------------------#
	 #   REPLACING A GIVEN ITEM AT THE GIVEN POSITIONS (IF THE ITEM EXIST) BY AN OTHER ITEM    #
	#-----------------------------------------------------------------------------------------#

	def ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzList([ "ring", "ruby", "ring", "php", "ring" ])
		o1.ReplaceThisItemAtPositions([ 1, 5 ], "ring", :By = "")

		? o1.Content()
		#--> [ "", "ruby", "ring", "php", "" ]
		*/

		if CheckingParams()
			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			
			if isList(pNewItem)

				oNewItem = StzListQ(pNewItem)

				if oNewItem.IsOneOfTheseNamedParams([ :ByMany, :WithMany, :UsingMany ])
					This.ReplaceThisItemAtPositionsByManyCS(panPos, pItem, pNewItem[2], pCaseSensitive)
					return

				but oNewItem.IsOneOfTheseNamedParams([ :ByManyXT, :WithManyXT, :UsingManyXT ])
					This.ReplaceThisItemAtPositionsByManyCSXT(panPos, pItem, pNewItem[2], pCaseSensitive)
					return

				but oNewItem.IsByOrWithOrUsingNamedParam()
					pNewItem = pNewItem[2]
				ok
			ok

		ok

		nLen = len(panPos)
		anPosAll = This.FindAllCS(pItem, pCaseSensitive)
		
		aContent = This.Content()
		anPos = []

		for i = 1 to nLen
			if ring_find(anPosAll, panPos[i])
				aContent[ panPos[i] ] = pNewItem
			ok
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)
			return This

		#>

	def ThisItemAtPositionsReplacedCS(panPos, pItem, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceThisItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAtPositions(panPos, pItem, pNewItem)
		This.ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsQ(panPos, pItem, pNewItem)
			This.ReplaceThisItemAtPositions(panPos, pItem, pNewItem)
			return This

		#>

	def ThisItemAtPositionsReplaced(panPos, pItem, pNewItem)
		cResult = This.Copy().ReplaceThisItemAtPositionsQ(panPos, pItem, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositions(panPos, pItem, pNewItem)
			return This.ThisItemAtPositionsReplaced(n, pItem, pNewItem)

		#>

	  #--------------------------------------------------------------------------------------#
	 #   REPLACING THE GIVEN ITEMS AT THE GIVEN POSITIONS (IF THEY EXIST) BY AN OTHER ITEM  #
	#--------------------------------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "ruby", "softanza", "ring", "php", "softanza" ])
		o1.ReplaceTheseItemsAtPositions([ 1, 3, 4, 5 ], [ "ring", "softanza" ] , :By = "")
		
		? o1.Content()
		#--> [ "", "ruby", "", "", "php", "softanza" ]

		*/

		if CheckingParams()
			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(pNewItem)
				oNewItem = StzListQ(pNewItem)

				if oNewItem.IsOneOfTheseNamedParams([ :ByMany, :WithMany, :UsingMany ])
					This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
					return

				but oNewItem.IsOneOfTheseNamedParams([ :ByManyXT, :WithManyXT, :UsingManyXT ])
					This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
					return

				but oNewItem.IsByOrWithOrUsingNamedParam()
					pNewItem = pNewItem[2]
				ok
			ok

		ok

		nLen = len(panPos)
		anPosAll = This.FindManyCS(paItems, pCaseSensitive)
		
		anPos = []
		aContent = This.Content()

		for i = 1 to nLen
			if ring_find(anPosAll, panPos[i])
				aContent[ panPos[i] ] = pNewItem
			ok
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsCSQ(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This

		#>

	def TheseItemsAtPositionsReplacedCS(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsCSQ(panPos, paItems, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeform

		def TheseItemsReplacedAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedCS(n, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositions(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, _TRUE_)

	def TheseItemsAtPositionsReplaced(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsQ(panPos, paItems, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositions(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplaced(n, paItems, pNewItem)

		#>

	  #---------------------------------------------------------------#
	 #   REPLACING ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS  #
	#---------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "ruby", "softanza", "ring", "php", "softanza" ])
		o1.ReplaceTheseItemsAtPositionsByMany([ 1, 3, 4, 6 ], [ "ring", "softanza" ] , [ "", "" ])
				
		? @@( o1.Content() )
		#--> [ "", "ruby", "", "", "php", "" ]

		*/

		if CheckingParams()
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(paNewItems) and Q(paNewItems).IsRespectivelyNamedParam()
				This.ReplaceTheseItemsAtPositionsByManyRespectivelyCS(panPos, paItems, paNewItems[2], pCaseSensitive)
				return
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return
		ok

		# Doing the job

		nLenItems = len(paItems)

		for i = 1 to nLenItems
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems[i], paNewItems, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsAtPositionsByTheseCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseAtByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseAtByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseAtPositionsByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseItemsAtByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsAtByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		#>

	def TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeform

		def TheseItemsReplacedAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#--

		def TheseItemsAtPositionsReplacedByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedAtPositionsByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#--

		def TheseReplacedAtByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedAtByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseReplacedAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositionsByMany(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, _TRUE_)

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByThese(panPos, paItems, paNewItems)
			This.ReplaceTheseItemsAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceTheseItemsAtPositionsByTheseQ(panPos, paItems, paNewItems)
				This.ReplaceTheseItemsAtPositionsByThese(panPos, paItems, paNewItems)
				return This

		def ReplaceTheseAtByMany(panPos, paItems, paNewItems)
			This.ReplaceTheseItemsAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceTheseAtByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceTheseItemsAtPositionsByManyQ(panPos, paItems, pNewItem)

		def ReplaceTheseAtPositionsByMany(panPos, paItems, paNewItems)
			This.ReplaceTheseItemsAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceTheseAtPositionsByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceTheseItemsAtPositionsByManyQ(panPos, paItems, pNewItem)

		def ReplaceTheseItemsAtByMany(panPos, paItems, paNewItems)
			This.ReplaceTheseItemsAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceTheseItemsAtByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceTheseItemsAtPositionsByManyQ(panPos, paItems, pNewItem)

		#>

	def TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyQ(panPos, paItems, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByMany(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(n, paItems, pNewItem)

		#--

		def TheseItemsAtPositionsReplacedByThese(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def TheseItemsReplacedAtPositionsByThese(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(n, paItems, pNewItem)

		#--

		def TheseReplacedAtByMany(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def TheseItemsReplacedAtByMany(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def TheseReplacedAtPositionsByMany(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		#>

	  #-----------------------------------------------------------------#
	 #   REPLACING AN ITEM AT THE GIVEN POSITIONS BY MANY OTHER ITEMS  #
	#-----------------------------------------------------------------#

	def ReplaceThisItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		# Quick-checking the positions provided

		nLenPos = len(panPos)
		if nLenPos = 0
			return
		ok

		# Quick-checking the actual positions of pItem

		anPosItem = This.FindAllCS(pItem, pCaseSensitive)
		nLen = len(anPosItem)

		if nLen = 0
			return
		ok

		# Taking the positions at which pItem exists

		anPos = @Intersection([ panPos, anPosItem ])
		nLen = len(anPos)
		if nLen = 0
			return
		ok

		# Doing the job by the fellowing function whic cares only
		# about positions (and is not aware of pItem)

		This.ReplaceAnyAtPositionsByManyCS(anPos, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisItemAtPositionsByTheseCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtPositionsByTheseCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceThisAtByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceThisAtByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceThisAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceThisAtPositionsByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		def ReplaceThisItemAtByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceThisItemAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtByManyCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				return This.ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)

		#>

	def ThisItemAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceThisItemAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#--

		def ThisItemAtPositionsReplacedByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtPositionsByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#--

		def ThisReplacedAtByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def ThisReplacedAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAtPositionsByMany(panPos, pItem, paNewItems)
		ReplaceThisItemAtPositionsByManyCS(panPos, pItem, paNewItems, _TRUE_)
	
		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem)
			This.ReplaceThisItemAtPositionsByMany(panPos, paItems, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisItemAtPositionsByThese(panPos, paItems, paNewItems)
			This.ReplaceThisItemAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceThisItemAtPositionsByTheseQ(panPos, paItems, paNewItems)
				return This.ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem)

		def ReplaceThisAtByMany(panPos, paItems, paNewItems)
			This.ReplaceThisItemAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceThisAtByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem)

		def ReplaceThisAtPositionsByMany(panPos, paItems, paNewItems)
			This.ReplaceThisItemAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceThisAtPositionsByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem)

		def ReplaceThisItemAtByMany(panPos, paItems, paNewItems)
			This.ReplaceThisItemAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceThisItemAtByManyQ(panPos, paItems, paNewItems)
				return This.ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem)

		#>

	def ThisItemAtPositionsReplacedByMany(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceThisItemAtPositionsByManyQ(panPos, paItems, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositionsByMany(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(n, paItems, pNewItem)

		#--

		def ThisItemAtPositionsReplacedByThese(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def ThisItemReplacedAtPositionsByThese(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(n, paItems, pNewItem)

		#--

		def ThisReplacedAtByMany(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def ThisItemReplacedAtByMany(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def ThisReplacedAtPositionsByMany(panPos, paItems, pNewItem)
			return This.ThisItemAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		#>

	  #----------------------------------------------------------------------------------------#
	 #   REPLACING ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- XT (RESTART AT FIRST)  #
	#----------------------------------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([
			"ring", "ruby", "softanza",
			"ring", "ring", "php",
			"softanza", "ring", "softanza"
		])
		
		o1.ReplaceTheseItemsAtPositionsByManyXT( [ 1, 4, 5, 8, 9 ],
			[ "ring", "softanza" ], [ "", "" ] )
						
		? @@( o1.Content() )
		#       1    2       3     4    5     6      7    8     9
		#--> [ "", "ruby", "", "", "", "php", "", "", "" ]
		#	^                  ^    ^                 ^
		#                    ^                       ^          ^

		*/

		if CheckingParams()
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(paNewItems) and Q(paNewItems).IsRespectivelyNamedParam()
				This.ReplaceTheseItemsAtPositionsByManyRespectivelyCS(panPos, paItems, paNewItems[2], pCaseSensitive)
				return
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			return
		ok

		# Doing the job

		nLenItems = len(paItems)

		for i = 1 to nLenItems
			This.ReplaceThisItemAtPositionsByManyCSXT(panPos, paItems[i], paNewItems, pCaseSensitive)
		next


		#< @FunctionFluentForm

		def ReplaceThisItemsAtPositionsByManyCSXTQ(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsAtPositionsByTheseCSXTQ(panPos, paItems, pNewItem, pCaseSensitive)
				This.ReplaceTheseItemsAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
				return This
		#>


	def TheseItemsAtPositionsReplacedByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyCSXTQ(panPos, paItems, pNewItem, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(n, paItems, pNewItem, pCaseSensitive)

		#--

		def TheseItemsAtPositionsReplacedByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(n, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsByManyXTQ(panPos, paItems, pNewItem)
			This.ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseXT(panPos, paItems, pNewItem)
			This.ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)

			def ReplaceTheseItemsAtPositionsByTheseXTQ(panPos, paItems, pNewItem)
				This.ReplaceTheseItemsAtPositionsByTheseXT(panPos, paItems, pNewItem)
				return This
		#>

	def TheseItemsAtPositionsReplacedByManyXT(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyXTQ(panPos, paItems, pNewItem).Content()
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByManyXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(n, paItems, pNewItem)

		#--

		def TheseItemsAtPositionsReplacedByTheseXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(panPos, paItems, pNewItem)

		def TheseItemsReplacedAtPositionsByTheseXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(n, paItems, pNewItem)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #   REPLACING ANY ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- XT (RESTART AT FIRST)  #
	#--------------------------------------------------------------------------------------------#

	def ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([
			"ring", "ruby", "softanza",
			"ring", "ring", "php",
			"softanza", "ring", "softanza"
		])
		
		o1.ReplaceAnyItemsAtPositionsByManyXT( [ 1, 4, 5, 8, 9 ], [ "", "" ] )
						
		? @@( o1.Content() )
		#       1    2       3     4    5     6      7          8     9
		#--> [ "", "ruby", "", "", "", "php", "softanza", "", "" ]
		#	^                  ^    ^                        ^    ^

		*/

		if CheckingParams()
			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			return
		ok

		# Computing nPos and aNewItems

		anPos = @WithoutDuplicates(panPos)
		nLenPos = len(anPos)

		aNewItems = []

		if nLenNewItems >= nLenPos
 			anNewItems = Q(paNewItems).Section(1, nLenPos)
		else
			aNewItems = paNewItems
			n = 0
			for j = 1 to nLenPos - nLenNewItems
				n++
				if n > nLenNewItems
					n = 1
				ok

				aNewItems + paNewItems[n]
			next
		ok

		# Doing the replacement

		for i = 1 to nLenPos
			This.ReplaceAnyItemAtPositionCS(anPos[i], aNewItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceanyItemsAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAtByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAtByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		#--

		def ReplaceItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceItemsAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAnyAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)

		#>

	def AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemsReplacedAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemsAtPositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemsReplacedAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemsAtPositionsByManyXT(panPos, paNewItems)
		This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, _TRUE_)

		#< @FunctionAlternativeForm

		def ReplaceAnyItemsAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceanyItemsAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceanyItemsAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByManyXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtPositionsByManyXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByManyXT(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAtByManyXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtByManyXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByManyXT(panPos, paNewItems)
				return This

		def ReplaceAtByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtByTheseXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByTheseXT(panPos, paNewItems)
				return This

		#--

		def ReplaceItemsAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceItemsAtPositionsByTheseXTQ(panPos, paNewItems)
				return This.ReplaceAnyItemsAtPositionsByManyXTQ(panPos, paNewItems)

		def ReplaceAnyAtPositionsByManyXT(panPos, paNewItems)
			This.ReplaceAnyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAnyAtPositionsByManyXTQ(panPos, paNewItems)
				return This.ReplaceAnyItemsAtPositionsByManyXTQ(panPos, paNewItems)

		def ReplaceItemsAtPositionsByManyXT(panPos, paNewItems)
			This.ReplaceAnyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceItemsAtPositionsByManyXTQ(panPos, paNewItems)
				return This.ReplaceAnyItemsAtPositionsByManyXTQ(panPos, paNewItems)

		#>

	def AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)
		cResult = This.Copy().ReplaceAnyItemsAtPositionsByManyXTQ(panPos, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemsReplacedAtPositionsByManyXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(n, paNewItems)

		#--

		def AnyItemsAtPositionsReplacedByTheseXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemsReplacedAtPositionsByTheseXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)

		#>

	  #---------------------------------------------------------------#
	 #   REPLACING AN ITEM AT GIVEN POSITIONS BY MANY OTHER ITEMS    #
	#===============================================================#

	def ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceItemAtPositionsByMany([ 3, 5, 7], "ring", :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! panNewItems must be a list.")
			ok

		ok

		# Early check

		nLenItems = len(paNewItems)

		if nLenItems = 0
			return
		ok

		# Managing the positions

		anPosItem = This.FindAllCS(pItem, pCaseSensitive)
		anPos = @Intersection([ panPos, anPosItem ])
		nLen = len(anPos)

		# Doing the job

		aContent = This.Content()

		for i = 1 to nLen
			aContent[ anPos[i] ] = paNewItems[i]
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtThesePositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#--

		def ReplaceItemAtPositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtPositionsByTheseCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtPositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		def ReplaceItemAtThesePositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByTheseCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtThesePositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceItemAtPositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ItemAtPositionsReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtThesePositionsReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)
		This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyQ(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByMany(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByManyQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtThesePositionsByMany(panPos, pItem, paNewItems)
				return This

		#--

		def ReplaceItemAtPositionsByThese(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtPositionsByTheseQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtPositionsByThese(panPos, pItem, paNewItems)
				return This

		def ReplaceItemAtThesePositionsByThese(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByTheseQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtThesePositionsByThese(panPos, pItem, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceItemAtPositionsByManyQ(panPos, pItem, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByMany(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		#--

		def ItemAtPositionsReplacedByThese(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		def ItemAtThesePositionsReplacedByThese(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		#>

	  #------------------------------------------------------------------#
	 #  REPLACING THE ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS  #
	#------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceAnyItemsAtPositionsByMany([ 3, 5, 7], :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if isList(paNewItems) and StzListQ(paNewItems).IsWithOrByOrUsingNamedParam()
				paNewItems = paNewItems[2]
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Keeping only the adequate number of positions and new items
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new items

		nLenPos = len(panPos)
		nLenNewItems = len(paNewItems)

		nMin = Min([ nLenPos, nLenNewItems ])

		anPos = []
		if nLenPos > nMin
			for i = 1 to nMin
				anPos + panPos[i]
			next
		else
			anPos = panPos
		ok

		aNewItems = []
		if nLenPos > nMin
			for i = 1 to nMin
				aNewItems + paNewItems[i]
			next
		else
			aNewItems = paNewItems
		ok

		# Doing the job

		aContent = This.Content()

		for i = 1 to nMin
			aContent[anPos[i]] = aNewItems[i]
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAtByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		#--	

		def ReplaceAnyItemsAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtPositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		#--

		def ReplaceItemsAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceItemsAtPositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceAnyAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)

		def ReplaceItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceItemsAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemsAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemAtThesePositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtPositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
		This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyQ(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAtByManyQ(panPos, paNewItems)
				This.ReplaceAtByManyCS(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAtPositionsByManyQ(panPos, paNewItems)
				This.ReplaceAtPositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtPositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByMany(panPos, paNewItems)
				return This

		#--	

		def ReplaceAnyItemsAtPositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtPositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByThese(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByThese(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByThese(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByThese(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByThese(panPos, paNewItems)
				return This

		#--

		def ReplaceItemsAtPositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)

			def ReplaceItemsAtPositionsByTheseQ(panPos, paNewItems)
				return This.ReplaceAnyItemAtPositionsByManyQ(panPos, paNewItems)

		def ReplaceAnyAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)

			def ReplaceAnyAtPositionsByManyQ(panPos, paNewItems)
				return This.ReplaceAnyItemAtPositionsByManyQ(panPos, paNewItems)

		def ReplaceItemsAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)

			def ReplaceItemsAtPositionsByManyQ(panPos, paNewItems)
				return This.ReplaceAnyItemAtPositionsByManyQ(panPos, paNewItems)

		#>


	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByMany(panPos, paNewItems)
		return This.AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, _TRUE_)

		#< @FunctionAlternativeForms

		def ItemsReplaceAtThesePositions(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtPositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtPositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		#--

		def AnyItemAtThesePositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtPositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		#>

	  #--------------------------------------------------------------------------#
	 #   REPLACING AN ITEM AT GIVEN POSITIONS BY MANY OTHER ITEMS -- EXTENDED   #
	#==========================================================================#

	def ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceItemAtPositionsByManyXT([ 3, 5, 7, 9], "ring", :By = [ "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "" ]

		*/

		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early Checkbox()

		nLenNewItems = len(paNewItems)
		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		paNewItems = @WithoutDuplicates(paNewItems)
		nLenNewItems = len(paNewItems)

		# Cleaning the positions by leaving only those related to pItem

		anPosItem = This.FindAllCS(pItem, pCaseSensitive)

		nLenPos   = len(panPos)
		anPos = []

		for i = 1 to nLenPos
			if ring_find(anPosItem, panPos[i]) > 0 and
			   ring_find(anPos, panPos[i]) = 0

				anPos + panPos[i]
			ok
		next

		nLenPos = len(anPos)

		# Doing the job

		if nLenNewItems >= nLenPos
			This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		# Case :  nLenItems < nLenPos

		aItems = paNewItems
		j = 0
		for i = 1 to nLenPos - nLenNewItems
			j++
			if j > nLenNewItems
				j = 1
			ok
			aItems + paNewItems[j]
		next

		for i = 1 to nLenPos
			This.ReplaceThisItemAtPositionCS(anPos[i], pItem, aItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceItemAtPositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtPositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceItemAtThesePositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ReplaceThisItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtPositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtPositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtThesePositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtThesePositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtPositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtThesePositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ThisItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtThesePositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtPositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtThesePositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)
		This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceItemAtPositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtPositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceItemAtThesePositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		#--

		def ReplaceThisItemAtPositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtThesePositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtThesePositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtPositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtPositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtThesePositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtThesePositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ItemAtPositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ItemAtThesePositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		#--

		def ThisItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtThesePositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtPositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtThesePositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		#>

	  #------------------------------------------------------------------------------#
	 #  REPLACING THE ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- EXTENDED  #
	#------------------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceAnyItemsAtPositionsByManyXT([ 3, 5, 7], :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckingParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		nLenPos   = len(panPos)
		nLenItems = len(paNewItems)

		if nLenItems >= nLenPos
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		# Case :  nLenItems < nLenPos

		aItems = paNewItems
		j = 0
		for i = 1 to nLenPos - nLenItems
			j++
			if j > nLenItems
				j = 1
			ok
			aItems + paNewItems[j]
		next

		for i = 1 to nLenPos
			This.ReplaceAnyItemAtPositionNCS(panPos[i], aItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnyItemAtThesePositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#--	

		def ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForms

	def AnyItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemAtThesePositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemAtPositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemAtThesePositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
		This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyXTQ(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnyItemAtThesePositionsByManyXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByManyXTQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByManyXT(panPos, paNewItems)
				return This

		#--	

		def ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
			
			def ReplaceAnyItemAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByTheseXT(panPos, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByManyXT(panPos, paNewItems)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyXTQ(panPos, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemAtThesePositionsReplacedByManyXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		#--

		def AnyItemAtPositionsReplacedByTheseXT(panPos, paNewItems)
			return This.AnyItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemAtThesePositionsReplacedByTheseXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByTheseXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		#>

 	  #-------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF AN ITEM BY MANY OTHER SUBSTRINGS  #
	#===================================================================#

	def ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsCS(anPos, pItem, pNewItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesCSQ(panPos, pItem, pNewItem, pCaseSensitive)
			This.ReplaceItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)

			def ReplaceTheseOccurrencesCSQ(panOccurr, pItem, pNewItem, pCaseSensitive)
				This.ReplaceTheseOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
				return This

		#>

	def OccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceOccurrencesCSQ(panPos, pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		def TheseOccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)
			return This.OccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurr, pItem, pNewItem)
		This.ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceOccurrencesQ(panPos, pItem, pNewItem)
			This.ReplaceSubStringAtPositionsQ(panPos, pItem, pNewItem)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrences(panOccurr, pItem, pNewItem)
			This.ReplaceOccurrences(panOccurr, pItem, pNewItem)

			def ReplaceTheseOccurrencesQ(panOccurr, pItem, pNewItem)
				This.ReplaceTheseOccurrences(panOccurr, pItem, pNewItem)
				return This

		#>

	def OccurrencesReplaced(panOccurr, pItem, pNewItem)
		aResult = This.Copy().ReplaceOccurrencesQ(panPos, pItem, pNewItem).Content()
		return aResult

		def TheseOccurrencesReplaced(panOccurr, pItem, pNewItem)
			return This.OccurrencesReplaced(panOccurr, pItem, pNewItem)

	  #------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER ITEMS  #
	#------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, pCaseSensitive)
		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseCS(panOccurr, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, pCaseSensitive)

			def ReplaceOccurrencesByTheseCSQ(panOccurr, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def OccurrencesReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		def OccurrencesReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByMany(panOccurr, pItem, paNewItems)
		this.ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems)
			This.ReplaceOccurrencesByMany(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByThese(panOccurr, pItem, paNewItems)
			This.ReplaceOccurrencesByMany(panOccurr, pItem, paNewItems)

			def ReplaceOccurrencesByTheseQ(panOccurr, pItem, paNewItems)
				return This.ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems)

		#>

	#-- @FunctionPassiveForm

	def OccurrencesReplacedByMany(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems).Content()
		return cResult 

		def OccurrencesReplacedByThese(panPos, pItem, paNewItems)
			return This.OccurrencesReplacedByMany(panPos, pItem, paNewItems)

	  #-------------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER ITEMS -- XT  #
	#------------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "*", "*", "*", "*",  "*" ])
		o1.ReplaceOccurrencesByManyXT([ 3, 4, 5, 6, 7 ], [ "#1", "#2" ])
		? @@( o1.Content() )
		#--> [ "A", "B", "#1", "#2", "#1", "#2", "#1" ]
		*/

		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCSXT(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)

			def ReplaceOccurrencesByTheseCSXTQ(panOccurr, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	def OccurrencesReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		def OccurrencesReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.OccurrencesReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByManyXT(panOccurr, pItem, paNewItems)
		this.ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems)
			This.ReplaceOccurrencesByManyXT(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseXT(panOccurr, pItem, paNewItems)
			This.ReplaceOccurrencesByManyXT(panOccurr, pItem, paNewItems)

			def ReplaceOccurrencesByTheseXTQ(panOccurr, pItem, paNewItems)
				return This.ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems)

		#>

	def OccurrencesReplacedByManyXT(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems).Content()
		return cResult 

		def OccurrencesReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.OccurrencesReplacedByManyXT(panPos, pItem, paNewItems)

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "pyhton", "ring" ])
		o1.ReplaceItem@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content()
		#--> [ "#1", "php", "#2", "ruby", "#3", "pyhton", "#4" ]

		*/

		if isList(pDynamicItem) and Q(pDynamicItem).IsWithOrByNamedParam()
			pDynamicItem = pDynamicItem[2]
		ok

		anPos = This.FindAllCSQ(pItem, pCaseSensitive).SortedInDescending()


		@Item = pItem

		@NumberOfOccurrences = len(anPos)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfItems  = @NumberOfOccurrences
		@NumberOfItems  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		aitem = []

		for @Position in anPos

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPos[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPos[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicItem = @@Q(pDynamicItem).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempItem = ( ' + cDynamicItem + ' )'
			eval(cCode)

			aitem + cTempStr

		next

		aItems = StzListQ(aItems).SortedInDescending()
	
		i = 0
		for @Position in anPos
			i++
			item = aItems[i]
			This.ReplaceItemAtPositionNCS(@Position, pItem, item, pCaseSensitive)
		next

		def ReplaceItemCS@Q(pItem, pDynamicItem, pCaseSensitive)
			This.ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)
			return This

		def ReplaceCS@(pItem, pDynamicItem, pCaseSensitive)
			This.ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)

			def ReplaceCS@Q(pItem, pDynamicItem, pCaseSensitive)
				This.ReplaceCS@(pItem, pDynamicItem, pCaseSensitive)
				return This

	def ItemReplacedCS@(pItem, pDynamicItem, pCaseSensitive)
		aResult = This.Copy().ReplaceItemCS@Q(pItem, pDynamicItem, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItem@(pItem, pDynamicItem)
		This.ReplaceItemCS@(pItem, pDynamicItem, _TRUE_)

		def ReplaceItem@Q(pItem, pDynamicItem)
			This.ReplaceItem@(pItem, pDynamicItem)
			return This

		def Replace@(pItem, pDynamicItem)
			This.ReplaceItem@(pItem, pDynamicItem)

			def Replace@Q(pItem, pDynamicItem)
				This.Replace@(pItem, pDynamicItem)
				return This

	def ItemReplaced@(pItem, pcDynamicStr)
		aResult = This.Copy().ReplaceItem@Q(pItem, pcDynamicStr).Content()
		return aResult

	   #------------------------------------------------#
	  #   REPLACING THE NEXT OCCURRENCES OF AN ITEM    #
         #   STARTING AT A GIVEN POSITION                 #
	#================================================#

	def ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		anPos = This.FindNextOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAllNextCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceAllNextCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def ReplaceAllNextSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceAllNextSTCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def ReplaceNextOccurrencesSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceNextOccurrencesSTCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		acResult = This.Copy().
				ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive).
				Content()
		return acResult

		#< @FunctionAlternativeForms

		def AllNextReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def AllNextReplacedSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def NextOccurrencesReplacedSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)
		This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAllNext(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplaceAllNextQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		def ReplaceAllNextST(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplaceAllNextSQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		def ReplaceNextOccurrencesST(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		#>

	def NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		acResult = This.Copy().
				ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt).
				Content()

		return acResult

		#< @FunctionAlternativeForms

		def AllNextReplaced(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		def AllNextReplacedST(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		def NextOccurrencesReplacedST(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplacedQ(pItem, pOtherItem, pnStartingAt)

		#>

	   #--------------------------------------------------#
	  #   REPLACING THE PREVIOUS OCCURRENCES OF AN ITEM  #
         #   STARTING AT A GIVEN POSITION                   #
	#--------------------------------------------------#

	def ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		anPos = This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplacePreviousCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pStartingAt, pCaseSensitive)

		#--

		def ReplacePreviousOccurrencesSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousOccurrencesSTCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def ReplacePreviousSTCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousSTCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def PreviousOccurrencesReplacedCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		acResult = This.Copy().
				ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive).
				Content()
		return acResult

		def PreviousOccurrencesReplacedSTCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.PreviousOccurrencesReplacedCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)
		This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ReplacePreviousOccurrencesQ(pItem, pOtherItem, pStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplacePrevious(pItem, pOtherItem, pnStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplacePreviousQ(pItem, pOtherItem, pnStartingAt)
				This.ReplacePrevious(pItem, pOtherItem, pnStartingAt)
				return This

		#--

		def ReplacePreviousOccurrencesST(pItem, pOtherItem, pnStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplacePreviousOccurrencesSTQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplacePreviousOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		def ReplacePreviousST(pItem, pOtherItem, pnStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplacePreviousSTQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplacePreviousOccurrencesQ(pItem, pOtherItem, pStartingAt)

		#>

	def PreviousOccurrencesReplacedQ(pItem, pOtherItem, pnStartingAt)

		acResult = This.Copy().
				ReplacePreviousOccurrencesQ(pItem, pOtherItem, pnStartingAt).
				Content()
		return acResult

		def PreviousOccurrencesReplacedSTQ(pItem, pOtherItem, pnStartingAt)
			return This.PreviousOccurrencesReplacedQ(pItem, pOtherItem, pnStartingAt)

	  #-----------------------------------------#
	 #   REPLACING NTH OCCURRENCE OF AN ITEM   #
	#-----------------------------------------#

	def ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pOtherItem) and
		   StzListQ(pOtherItem).IsWithOrByNamedParam()
		
			pOtherItem = pOtherItem[2]
		ok

		nItemPosition = This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		This.ReplaceAtCS(nItemPosition, pOtherItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceCSQ(n, pItem, pOtherItem, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthCS(n, pItem, pOtherItem, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)

			def ReplaceNthCSQ(n, pItem, pOtherItem, pCaseSensitive)
				This.ReplaceNthCS(n, pItem, pOtherItem, pCaseSensitive)
				return This
			
		#>

	def NthOccurrenceReplacedCS(n, pItem, pOtherItem, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceNthOccurrenceCSQ(n, pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def NthReplacedCS(n, pItem, pOtherItem, pCaseSensitive)
			return This.NthOccurrenceReplacedCS(n, pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pItem, pOtherItem)
		This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ReplaceNth(n, pItem, pOtherItem)
			This.ReplaceNthOccurrence(n, pItem, pOtherItem)

			def ReplaceNthQ(n, pItem, pOtherItem)
				This.ReplaceNth(n, pItem, pOtherItem)
				return This
			
		#>

	def NthOccurrenceReplaced(n, pItem, pOtherItem)

		aResult  = This.Copy().
				ReplaceNthOccurrenceQ(n, pItem, pOtherItem).
				Content()

		return aResult

		def NthReplaced(n, pItem, pOtherItem)
			return This.NthOccurrenceReplaced(n, pItem, pOtherItem, pCaseSensitive)

	  #--------------------------------------------#
	 #   REPLACING FIRST OCCURRENCE OF AN ITEM    #
	#--------------------------------------------#

	def ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pItem, pOtherItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFirstCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
				return This
		#>

		#< @FunctionMisspelledForms

		def ReplaceFristOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFristOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
				return This.ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)

		#--

		def ReplaceFristCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFristCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)
		aResult  = This.Copy().
				ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def FirstReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		def FristReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pItem, pOtherItem)
		This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceFirst(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFirstQ(pItem, pOtherItem)
				This.ReplaceFirst(pItem, pOtherItem)
				return This
		#>

		#< @FunctionMisspelledForms

		def ReplaceFristOccurrence(pItem, pOtherItem)
			return This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFristOccurrenceQ(pItem, pOtherItem)
				return This.ReplaceFirstOccurrenceQ(pItem, pOtherItem)

		#--

		def ReplaceFrist(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFristQ(pItem, pOtherItem)
				This.ReplaceFirst(pItem, pOtherItem)
				return This

		#>

	def FirstOccurrenceReplaced(pItem, pOtherItem)
		aResult  = This.Copy().
				ReplaceFirstOccurrenceQ(pItem, pOtherItem).
				Content()

		return aResult

		def FirstReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplaced(pItem, pOtherItem)

		#-- MISSPELLED

		def FristOccurrenceReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem)

		def FristReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplaced(pItem, pOtherItem)

	  #-----------------------------------------#
	 #   REPLACING LAST OCCURRENCE OF AN ITEM  #
	#-----------------------------------------#

	def ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
		n = This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		This.ReplaceAt(n, pOtherItem)

		def ReplaceLastOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This

		#< @FunctionAlternativeForms

		def ReplaceLastCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceLastCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceLastCS(pItem, pOtherItem, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceLastOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def LastReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.LastOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pItem, pOtherItem)
		n = This.FindLastOccurrence(pItem)
		This.ReplaceAt(n, pOtherItem)

		def ReplaceLastOccurrenceQ(pItem, pOtherItem)
			This.ReplaceLastOccurrence(pItem, pOtherItem)
			return This

		#< @FunctionAlternativeForms

		def ReplaceLast(pItem, pOtherItem)
			This.ReplaceLastOccurrence(pItem, pOtherItem)

			def ReplaceLastQ(pItem, pOtherItem)
				This.ReplaceLast(pItem, pOtherItem)
				return This

		#>

	def LastOccurrenceReplaced(pItem, pOtherItem)

		aResult  = This.Copy().
				ReplaceLastOccurrenceQ(pItem, pOtherItem).
				Content()

		return aResult

		def LastReplaced(pItem, pOtherItem)
			return This.LastOccurrenceReplaced(pItem, pOtherItem)

	   #-----------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST   #
	#-----------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		# Checking params correctness

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   StzListQ(pNewItem).IsWithOrByNamedParam()

			if Q(pNewItem[1]).LastChar() = "@"
				
				cCode = 'pNewtItem = ' +
					Q(pNewItem[2]).
					RemoveSpacesQ().
					RemoveTheseBoundsQ("{","}").
					Content()

				eval(cCode)
			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)

			if ring_find([
				:First, :FirstPosition, :FirstItem ], pnStartingAt) > 0

				pnStartingAt = 1
			
			but ring_find([
				:Last, :LastPosition, :LastItem ], pnStartingAt)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		# Doing the job

		oSection   = This.SectionQ(pnStartingAt, This.NumberOfItems())
		anPos = oSection.FindAllCS(pItem, pCaseSensitive)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt - 1).Content()
			nPos = anPos[n]
	
			This.ReplaceAt(nPos, pNewItem)
		ok
	
		#< @FunctionFluentForm

		def ReplaceNextNthOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthNextOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This

		#--

		def ReplaceNextNthOccurrenceSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNextNthOccurrenceSTCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextNthOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNthNextOccurrenceSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthNextOccurrenceSTCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextNthOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	# @FunctionPassiveForm

	def NextNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceNthNextOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive).
				Content()
		return aResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def NextNthOccurrenceReplacedSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def NthNextOccurrenceReplacedSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt)
		This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceNextNthOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthNextOccurrence(n, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthNextOccurrence(n, pItem, pNewItem, pnStartingAt)
				return This

		#--

		def ReplaceNextNthOccurrenceST(n, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplaceNextNthOccurrenceSTQ(n, pItem, pNewItem, pnStartingAt)
				return This.ReplaceNextNthOccurrenceQ(n, pItem, pNewItem, pnStartingAt)

		def ReplaceNthNextOccurrenceST(n, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrenceSTQ(n, pItem, pNewItem, pnStartingAt)
				return This.ReplaceNextNthOccurrenceQ(n, pItem, pNewItem, pnStartingAt)

		#>

	def NextNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		aResult  = This.Copy().
				ReplaceNthNextOccurrenceQ(n, pItem, pNewItem, pnStartingAt).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		def NextNthOccurrenceReplacedST(n, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		def NthNextOccurrenceReplacedST(n, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		#>

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF AN ITEM        #
	 #    STARTING AT A GIVEN POSITION IN THE LIST    #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		def ReplaceNextOccurrenceSTCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNextOccurrenceSTCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)

	def NextOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceNextOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive).
				Content()

		return aResult

		def NextOccurrenceReplacedSTCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pItem, pNewItem, pnStartingAt)
		This.ReplaceNextNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, _TRUE_)

		def ReplaceNextOccurrenceQ(pItem, pNewItem, pnStartingAt)
			This.ReplaceNextOccurrence(pItem, pNewItem, pnStartingAt)
			return This

		def ReplaceNextOccurrenceST(pItem, pNewItem, pnStartingAt)
			This.ReplaceNextOccurrence(pItem, pNewItem, pnStartingAt)

			def ReplaceNextOccurrenceSTQ(pItem, pNewItem, pnStartingAt)
				return This.ReplaceNextOccurrenceQ(pItem, pNewItem, pnStartingAt)

	def NextOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

		aResult  = This.Copy().
				ReplaceNextOccurrenceQ(pItem, pNewItem, pnStartingAt).
				Content()

		return aResult

		def NextOccurrenceReplacedST(pItem, pNewItem, pnStartingAt)
			return This.NextOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

	   #-----------------------------------------------------#
	  #    REPLACING MANY NEXT NTH OCCURRENCES OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST         #
	#-----------------------------------------------------#

	def ReplaceNextNthOccurrencesSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListOfQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			ReplaceNextNthOccurrences([2, 3], :of = "A", :with = "*",  :StartingAt = 3)
			? Content() # !--> [ "A" , "B", "A", "C", "*", "D", "*" ]
		}		

		*/

		anPosToBeReplaced = This.FindNextNthOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtThesePositions(anPosToBeReplaced, pNewItem)


		#< @FunctionFluentForm

		def ReplaceNextNthOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrencesSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNextNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNextNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextNthOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNthNextOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextNthOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	def NextNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult = This.
			  ReplaceNextNthOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive).
			  Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthNextOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def NextNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def NthNextOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)
		This.ReplaceNextNthOccurrencesSTCS(panList, pItem, pNewItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceNextNthOccurrencesSTQ(panList, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNextNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNextNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
				return This.ReplaceNextNthOccurrencesSTQ(panList, pItem, pNewItem, pnStartingAt)

		def ReplaceNthNextOccurrences(panList, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
				return This.ReplaceNextNthOccurrencesSTQ(panList, pItem, pNewItem, pnStartingAt)

		#>

	def NextNthOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)
		return This.NextNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def NthNextOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)

		def NextNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)

		def NthNextOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)

		#>

	   #---------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST       #
	#---------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   StzListQ(pNewItem).IsWithOrByNamedParam()

			if Q(pNewItem[1]).LastChar() = "@"
				cCode = 'pNewtItem = ' + pNewItem[2]
				eval(cCode)

			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)

			if ring_find([
				:First, :FirstPosition, :FirstItem ], pnStartingAt) > 0

				pnStartingAt = 1
			
			but ring_find([
				:Last, :LastPosition, :LastItem ], pnStartingAt) > 0

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection   = This.SectionQ(1, pnStartingAt)
		aPositions = oSection.FindAllCS(pItem, pCaseSensitive)

		nPosition = aPositions[ len(aPositions) - n + 1 ]

		This.ReplaceAtCS(nPosition, pNewItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplacePreviousNthOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthPreviousOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This

		def ReplacePreviousNthOccurrenceSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousNthOccurrenceSTCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNthPreviousOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def NthPreviousOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceNthPreviousOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, _TRUE_).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def PreviousNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceReplacedCS(n, pItem, pnStartingAt, pCaseSensitive)

		def NthPreviousOccurrenceReplacedSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def PreviousNthOccurrenceReplacedSTCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceReplacedCS(n, pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)
		This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, _TRUE_)

		#< @FunctionFuentForm

		def ReplacePreviousNthOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthPreviousOccurrence(n, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplaceNthPreviousOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthPreviousOccurrence(n, pItem, pNewItem, pnStartingAt)
				return This

		def ReplacePreviousNthOccurrenceST(n, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplacePreviousNthOccurrenceSTQ(n, pItem, pNewItem, pnStartingAt)
				return This.ReplaceNthPreviousOccurrenceQ(n, pItem, pNewItem, pnStartingAt)

		#>

	#-- @FunctionPassiveForm

	def NthPreviousOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		aResult =  This.Copy().
				ReplaceNthPreviousOccurrenceQ(n, pItem, pNewItem, pnStartingAt).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def PreviousNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)
			return This.NthPreviousOccurrenceReplaced(n, pItem, pnStartingAt)

		def NthPreviousOccurrenceReplacedST(n, pItem, pNewItem, pnStartingAt)
			return This.NthPreviousOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		def PreviousNthOccurrenceReplacedST(n, pItem, pNewItem, pnStartingAt)
			return This.NthPreviousOccurrenceReplaced(n, pItem, pnStartingAt)

		#>

	   #-----------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST   #
	#-----------------------------------------------#

	def ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		def ReplacePreviousOccurrenceSTCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousOccurrenceSTCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)

	def PreviousOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplacePreviousOccurrenceCSQ(pItem, pNewItem, pnStartingAt, _TRUE_).
				Content()
		return aResult

		def PreviousOccurrenceReplacedSTCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.PreviousOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pItem, pNewItem, pnStartingAt)
		This.ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, _TRUE_)

		def ReplacePreviousOccurrenceQ(pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousOccurrence(pItem, pNewItem, pnStartingAt)
			return This

		def ReplacePreviousOccurrenceST(pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousOccurrence(pItem, pNewItem, pnStartingAt)

			def ReplacePreviousOccurrenceSTQ(pItem, pNewItem, pnStartingAt)
				return This.ReplacePreviousOccurrenceQ(pItem, pNewItem, pnStartingAt)

	def PreviousOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

		aResult =  This.Copy().
				ReplacePreviousOccurrenceQ(pItem, pNewItem, pnStartingAt).
				Content()
		return aResult

		def PreviousOccurrenceReplacedST(pItem, pNewItem, pnStartingAt)
			return This.PreviousOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

	   #---------------------------------------------------------#
	  #     REPLACING MANY PREVIOUS NTH OCCURRENCES OF AN ITEM  #
	 #    STARTING AT A GIVEN POSITION IN THE LIST             #
	#---------------------------------------------------------#

	def ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			ReplacePreviousNthOccurrences([2, 3], :of = "A", :with = "*",  :StartingAt = 5)
			? Content() # !--> [ "*" , "B", "*", "C", "A", "D", "A" ]
		}		

		*/

		anPosToBeReplaced = This.FindPreviousNthOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtThesePositions(anPosToBeReplaced, pNewItem)


		#< @FunctionFluentForm

		def ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthPreviousOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthPreviousOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#--

		def ReplacePreviousNthOccurrencesSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousNthOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNthPreviousOccurrencesSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthPreviousOccurrencesSTCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This.ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		aResult =  This.
			   ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, _TRUE_).
			   Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#--

		def PreviousNthOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def NthPreviousOccurrencesReplacedSTCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
		This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNthPreviousOccurrences(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthPreviousOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthPreviousOccurrences(panList, pItem, pNewItem, pnStartingAt)
				return This

		#--

		def ReplacePreviousNthOccurrencesST(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplacePreviousNthOccurrencesSTQ(panList, pItem, pNewItem, pnStartingAt)
				return This.ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)

		def ReplaceNthPreviousOccurrencesST(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthPreviousOccurrencesSTQ(panList, pItem, pNewItem, pnStartingAt)
				return This.ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)

		#>

	#-- @FunctionPassiveForms

	def PreviousNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

		aResult =  This.
			   ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt).
			   Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)
			return This.PreviousNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

		#--

		def PreviousNthOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)
			return This.PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt)

		def NthPreviousOccurrencesReplacedST(panList, pItem, pNewItem, pnStartingAt)
			return This.PreviousNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

		#>

	  #------------------------------#
	 #   REPLACING THE FIRST ITEM   #
	#------------------------------#

	def ReplaceFirstItem(pOtherItem)
		aContent = This.Content()
		aContent[1] = pOtherItem
		This.UpdateWith(aContent)

		def ReplaceFirstItemQ(pOtherItem)
			This.ReplaceFirstItem(pOtherItem)
			return This

	def FirstItemReplaced(pOtherItem)
		aResult = This.Copy().ReplaceFirstItemQ(pOtherItem).Content()
		return aResult

		def FirstItemReplacedWith(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

		#-- MISSPELLED

		def FristItemReplaced(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

		def FristItemReplacedWith(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

	  #-----------------------------#
	 #   REPLACING THE LAST ITEM   #
	#-----------------------------#

	def ReplaceLastItem(pOtherItem)
		aContent = This.Content()
		aContent[ len(aContent) ] = pOtherItem
		This.UpdateWith(aContent)

		def ReplaceLastItemQ(pOtherItem)
			This.ReplaceLastItem(pOtherItem)
			return This

	def LastItemReplaced(pOtherItem)
		aResult = This.Copy().ReplaceLastItemQ(pOtherItem).Content()
		return aResult

		def LastItemReplacedWith(pOtherItem)
			return This.LastItemReplaced(pOtherItem)

	  #---------------------------------------------------#
	 #    REPLACING A SECTION OF ITEMS BY A GIVEN ITEM   #
	#===================================================#

	def ReplaceSection(n1, n2, pNewItem)
		/* EXAMPLE 1

		o1 = new stzList([ "A", "B", "_", "_", "_", "D" ])
		o1.ReplaceSection(3, 5, "C")
		? o1.Content() #--> [ "A", "B", "C", "D" ]

		EXAMPLE 2 (Using :By@)

		o1 = new stzList([ "A", "B", "c", "d", "e", "F" , "G" ])
		
		o1.ReplaceSection(3, 5, :By@ = '{ @EachItemQ.Uppercased() }')
		? o1.Content()
		#--> [ "A", "B", "C", "D", "E", "F", "G" ]

		*/

		if CheckingParam()
			if isList(pNewItem) and StzListQ(pNewItem).IsWithOrByNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		This.RemoveSection(n1, n2)

		aContent = This.Content()
		ring_insert( aContent, n1, pNewItem )

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceSectionQ(n1, n2, pNewItem)
			This.ReplaceSection(n1, n2, pNewItem)
			return This

		#>

	def SectionReplaced(n1, n2, pNewItem)
		aResult = This.Copy().ReplaceSectionQ(n1, n2, pNewItem).Content()
		return aResult

		def SectionReplacedWith(n1, n2, pNewItem)
			return This.SectionReplaced(n1, n2, pNewItem)
	
	  #----------------------------------------------#
	 #    REPLACING MANY SECTIONS BY A GIVEN ITEM   #
	#----------------------------------------------#

	def ReplaceManySections(paSections, pNewItem)
		if CheckingParams() = _TRUE_
			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			_oCopy_.ReplaceSection(paSections[i], pNewItem)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def ReplaceManySectionsQ(paSections, pNewItem)
			This.ReplaceManySections(paSections, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseSections(paSections, pNewItem)
			This.ReplaceManySections(paSections, pNewItem)

			def ReplaceTheseSectionsQ(paSections, pNewItem)
				return This.ReplaceManySectionsQ(paSections, pNewItem)
		#>

	#-- @FunctionPasssiveForm

	def ManySectionsReplaced(paSections, pNewItem)
		aResult = This.Copy().ReplaceManySectionsQ(paSections, pNewItem).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ManySectionsReplacedWith(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

		def TheseSectionsReplaced(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

		def TheseSectionsReplacedWith(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

		#>

	  #------------------------------------------------------#
	 #   REPLACING EACH ITEM IN SECTION BY ONE GIVEN ITEM   #
	#------------------------------------------------------#

	def ReplaceEachItemInSection(n1, n2, pNewItem)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "_", "_", "_", "D" ])
		o1.ReplaceEachItemInSection(3, 5, "C")
		? o1.Content() #--> [ "A", "B", "C", "C", "C", "D" ]

		*/

		This.ReplaceItemsAtThesePositions(n1 : n2, pNewItem)

		def ReplaceEachItemInSectionQ(n1, n2, pNewItem)
			This.ReplaceEachItemInSection(n1, n2, pNewItem)
			return This

	def EachItemInSectionReplaced(n1, n2, pNewItem)
		acResult = This.Copy().ReplaceEachItemInSectionQ(n1, n2, pNewItem).Content()
		return acResult

		def EachItemInSectionReplacedWith(n1, n2, pNewItem)
			return This.EachItemInSectionReplaced(n1, n2, pNewItem)

		def EachItemReplacedInSection(n1, n2, pNewItem)
			return This.EachItemInSectionReplaced(n1, n2, pNewItem)

		def EachItemReplacedInSectionWith(n1, n2, pNewItem)
			return This.EachItemReplacedInSection(n1, n2, pNewItem)
	
	  #----------------------------------------------------------#
	 #   REPLACING EACH ITEM IN MANY SECTIONS BY A GIVEN ITEM   #
	#----------------------------------------------------------#

	def ReplaceEachItemInManySections(paSections, pNewItem)
		if CheckingParams() = _TRUE_
			if NOT (isList(paSections) and @IsListOfPairsOfNumbers(paSections))
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			_oCopy_.ReplaceEachItemInSection(paSections[i][1], paSections[i][2], pNewItem)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def ReplaceEachItemInManySectionsQ(paSections, pNewItem)
			This.ReplaceEachItemInManySections(paSections, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForm

		def ReplaceEachItemInTheseSections(paSections, pNewItem)
			This.ReplaceEachItemInManySections(paSections, pNewItem)

			def ReplaceEachItemInTheseSectionsQ(paSections, pNewItem)
				return This.ReplaceEachItemInManySectionsQ(paSections, pNewItem)
		#>

	#-- @FunctionPassiveForm

	def EachItemInManySectionsReplaced(paSections, pNewItem)

		acResult = This.Copy().
				ReplaceEachItemInManySectionsQ(paSections, pNewItem).
				Content()

		return acResult

		def EachItemInTheseSectionsReplaced(paSections, pNewItem)
			return This.EachItemInManySectionsReplaced(paSections, pNewItem)

	   #-----------------------------------------------#
	  #   REPLACING A SECTION OF ITEMS IN THE LIST    #
	 #   BY MANY ITEMS ONE BY ONE    	         #
	#-----------------------------------------------#

	def ReplaceSectionByMany(n1, n2, paOtherListOfItems)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "_", "_", "_", "F" ])
		o1.ReplaceSectionByMany(3, 5, [ "C", "D", "F" ])
		? o1.Content() #--> [ "A", "B", "C", "D", "E", "F" ]

		*/

		if CheckingParams()
	
			if NOT isList(paOtherListOfItems)
				StzRaise("Incorrect param type! paOtherListOfItems must be a list.")
			ok

		ok

		This.RemoveSection(n1, n2)

		nLen = len(paOtherListOfItems)
		aContent = This.Content()

		for i = nLen to 1 step -1
			ring_insert( aContent, n1, paOtherListOfItems[i] )
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ReplaceSectionByManyQ(n1, n2, paOtherListOfItems)
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSectionByThese(n1, n2, pOtherListOfItems)
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)

			def ReplaceSectionByTheseQ(n1, n2, pOtherListOfItems)
				return This.ReplaceSectionByManyQ(n1, n2, paOtherListOfItems)

		#>

	#-- @FunctionPassiveForm

	def SectionReplacedByMany(n1, n2, paOtherListOfItems)
		aResult = This.ReplaceSectionByManyQ(n1, n2, paOtherListOfItems).Content()
		return aResult

		def SectionReplacedByThese(n1, n2, paOtherListOfItems)
			return This.SectionReplacedByMany(n1, n2, paOtherListOfItems)

	   #---------------------------------------------------#
	  #   REPLACING MANY SECTIONS OF ITEMS IN THE LIST    #
	 #   BY MANY ITEMS ONE BY ONE                        #
	#---------------------------------------------------#

	def ReplaceManySectionsByMany(paSections, paOtherListOfItems)
		for anSection in paSections
			n1 = paSections[1]
			n2 = paSections[2]
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)
		next

		def ReplaceManySectionsByManyQ(paSections, paOtherListOfItems)
			This.ReplaceManySectionsByMany(paSections, paOtherListOfItems)
			return This

		def ReplaceTheseSectionsByThese(paSections, paOtherListOfItems)
			This.ReplaceManySectionsByMany(paSections, paOtherListOfItems)

			def ReplaceTheseSectionsByTheseQ(paSections, paOtherListOfItems)
				This.ReplaceTheseSectionsByThese(paSections, paOtherListOfItems)

	def ManySectionsReplacedByMany(paSections, paOtherListOfStr)
		acResult = This.Copy().
				ReplaceManySectionsByManyQ(paSections, paOtherListOfItems).
				Content()

		return acResult

		def TheseSectionsReplacedByThese(paSections, paOtherListOfStr)
			return This.ManySectionsReplacedByMany(paSections, paOtherListOfStr)

	  #--------------------------------------------#
	 #   REPLACING A RANGE OF ITEMS IN THE LIST   #
	#--------------------------------------------#

	def ReplaceRange(n, nRange, pNewItem)

		anSection = @RangeToSection(n, nRange)
		n1 = anSection[1]
		n2 = anSection[2]

		This.ReplaceSection(n1, n2, pNewItem)

		def ReplaceRangeQ(n, nRange, pNewItem)
			This.ReplaceRange(n, nRange, pNewItem)
			return This

	def RangeReplaced(n, nRange, pNewItem)
		acResult = This.Copy().ReplaceRangeQ(n, nRange, pNewItem).Content()
		return acResult

	  #------------------------------------------------#
	 #   REPLACING MANY RANGES OF ITEMS IN THE LIST   #
	#------------------------------------------------#

	def ReplaceRanges(panRanges, pNewItem)
		#TODO // Add params check
		#TODO // Change for/in loop by for loop

		_oCopy_ = This.Copy()

		for anRange in panRanges
			n = anRange[1]
			nRange = anRange[2]
			_oCopy_.ReplaceRange(n, nRange, pNewItem)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def ReplaceRangesQ(panRanges, pNewItem)
			This.ReplaceManyRanges(panRanges, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceManyRanges(panRanges, pNewItem)
			This.ReplaceRanges(panRanges, pNewItem)

			def ReplaceManyRangesQ(panRanges, pNewItem)
				return This.ReplaceRangesQ(panRanges, pNewItem)

		def ReplaceTheseRanges(panRanges, pNewItem)
			This.ReplaceRanges(panRanges, pNewItem)

			def ReplaceTheseRangesQ(panRanges, pNewItem)
				return This.ReplaceRangesQ(panRanges, pNewItem)
		#>

	#-- @FunctionPassiveForms

	def RangesReplaced(panRanges, pNewItem)
		acResult = This.Copy().ReplaceManyRangesQ(panRanges, pNewItem).Content()
		return acResult

		def ManyRangesReplaced(panRanges, pNewItem)
			return This.RangesReplaced(panRanges, pNewItem)

		def TheseRangesReplaced(panRanges, pNewItem)
			return This.RangesReplaced(panRanges, pNewItem)

	  #-----------------------------------------------------------#		
	 #   REPLACING EACH ITEM IN A RANGE BY THE SAME GIVEN ITEM   #
	#-----------------------------------------------------------#

	def ReplaceEachItemInRange(n, nRange, pNewItem)

		anSection = @RangeToSection(n, nRange)
		anPos = ring_sort( StzListOfPairsQ(anSection).ExpandedIfPairsOfNumbers() )

		This.ReplaceItemsAtThesePositions(anPos, pNewItem)

		def ReplaceEachItemInRangeQ(n, nRange, pNewItem)
			This.ReplaceEachItemInRange(n, nRange, pNewItem)
			return This

	def EachItemInRangeReplaced(n, nRange, pNewItem)

		acResult = This.Copy().ReplaceEachItemInRangeQ(n, nRange, pNewItem).Content()
		return acResult

		def EachItemReplacedInRange(n, nRange, pNewItem)
			return This.EachItemInRangeReplaced(n, nRange, pNewItem)
		
	  #---------------------------------------------------------------#		
	 #   REPLACING EACH ITEM IN MANY RANGES BY THE SAME GIVEN ITEM   #
	#---------------------------------------------------------------#

	def ReplaceEachItemInManyRanges(panRanges, pNewItem)
		#TODO // Add params check
		#TODO // Change for/in loop by for loop

		_oCopy_ = This.Copy()

		for anRange in panRanges
			anSection = @RangeToSection(anRange[1], anRanges[2])
			n1 = anSection[1]
			n2 = anSection[2]
			_oCopy_.ReplaceEachItemInSection(n1, n2, pNewItem)
		next
		This.UpdateWith(_oCopy_.Content())


		def ReplaceEachItemInManyRangesQ(panRanges, pNewItem)
			This.ReplaceEachItemInManyRanges(panRanges, pNewItem)
			return This

		def ReplaceEachItemInTheseRanges(panRanges, pNewItem)
			This.ReplaceEachItemInManyRanges(panRanges, pNewItem)

			def ReplaceEachItemInTheseRangesQ(panRanges, pNewItem)
				return This.ReplaceEachItemInManyRangesQ(panRanges, pNewItem)

	def EachItemInManyRangesReplaced(panRanges, pNewItem)

		acResult =  This.Copy().
				ReplaceEachItemInManyRangesQ(panRanges, pNewItem).
				Content()

		return acResult

		def EachItemReplacedInManyRanges(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)
	
		def EachItemInTheseRangesReplaced(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)

		def EachItemReplacedInTheseRanges(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)

	   #--------------------------------------------#
	  #   REPLACING A RANGE OF ITEMS IN THE LIST   #
	 #   WITH MANY ITEMS ONE BY ONE               #
	#--------------------------------------------#

	def ReplaceRangeByMany(n, nRange, paOtherListOfItems)
		#TODO // Add params check

		anSection = @RangeToSection(n, nRange)
		n1 = anSection[1]
		n2 = anSection[2]

		_oCopy_ = This.Copy()

		i = 0
		for n = n1 to n2
			i++
			if i <= len(paOtherListOfItems)
				item = paOtherListOfItems[i]
			else
				item = _NULL_
			ok

			_oCopy_.ReplaceAt(n, item)
		next

		This.UpdateWith(_oCopy_.Content())


		def ReplaceRangeByManyQ(n, nRange, paOtherListOfItems)
			This.ReplaceRangeByMany(n, nRange, paOtherListOfItems)
			return This

		def ReplaceRangeByThese(n, nRange, paOtherListOfItems)
			This.ReplaceRangeByMany(n, nRange, paOtherListOfItems)

			def ReplaceRangeByTheseQ(n, nRange, paOtherListOfItems)
				return This.ReplaceRangeByManyQ(n, nRange, paOtherListOfItems)

	def RangeReplacedByMany(n, nRange, paOtherListOfItems)
		aResult = This.ReplaceRangeByManyQ(n, nRange, paOtherListOfItems).Content()
		return aResult

		def RangeReplacedByThese(n, nRange, paOtherListOfItems)
			return This.RangeReplacedByMany(n, nRange, paOtherListOfItems)

	   #------------------------------------------------#
	  #   REPLACING MANY RANGES OF ITEMS IN THE LIST   #
	 #   WITH MANY ITEMS ONE BY ONE                   #
	#------------------------------------------------#

	def ReplaceManyRangesByMany(panRanges, paOtherListOfItems)

		_oCopy_ = This.Copy()

		for anRange in panRanges
			anSection = @RangeToSection(anRange[1], anRange[2])
			n1 = anSections[1]
			n2 = anSections[2]
			_oCopy_.ReplaceRangeByMany(n, nRange, paOtherListOfItems)
		next

		This.UpdateWith(_oCopy_.Content())


		def ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems)
			This.ReplaceManyRangesByMany(panRanges, paOtherListOfItems)
			return This

		def ReplaceTheseRangesByThese(panRanges, paOtherListOfItems)
			This.ReplaceManyRangesByMany(panRanges, paOtherListOfItems)

			def ReplaceTheseRangesByTheseQ(panRanges, paOtherListOfItems)
				return This.ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems)

	def RangesReplacedByMany(panRanges, paOtherListOfItems)
		
		acResult = This.Copy().
				ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems).
				Content()

		return acResult

		def RangesReplacedByThese(panRanges, paOtherListOfItems)
			return This.RangesReplacedByMany(panRanges, paOtherListOfItems)

	  #----------------------------------------------#
	 #   REPLACING ITEMS UNDER A GIVEN CONDITION    #
	#==============================================#

	def ReplaceItemsW(pCondition, pOtherItem)

		anPos = This.FindItemsW(pCondition)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplaceItemsWQ(pCondition, pOtherItem)
			This.ReplaceItemsW(pCondition, pOtherItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceW(pCondition, pOtherItem)
			This.ReplaceItemsW(pCondition, pOtherItem)

			def ReplaceWQ(pCondition, pOtherItem)
				This.ReplaceW(pCondition, pOtherItem)
				return This

		#>

	def ItemsReplacedW(pCondition, pOtherItem)
		aResult = This.Copy().ReplaceItemsWQ(pCondition, pOtherItem).Content()
		return aResult

	  #--------------------------------------------------------#
	 #   REPLACING ITEMS UNDER A GIVEN CONDITION -- WXTended  #
	#========================================================#

	def ReplaceItemsWXT(pCondition, pOtherItem)

		anPos = This.FindItemsWXT(pCondition)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplaceItemsWXTQ(pCondition, pOtherItem)
			This.ReplaceItemsWXT(pCondition, pOtherItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceWXT(pCondition, pOtherItem)
			This.ReplaceItemsWXT(pCondition, pOtherItem)

			def ReplaceWXTQ(pCondition, pOtherItem)
				This.ReplaceWXT(pCondition, pOtherItem)
				return This

		#>

	def ItemsReplacedWXT(pCondition, pOtherItem)
		aResult = This.Copy().ReplaceItemsWQ(pCondition, pOtherItem).Content()
		return aResult

	  #----------------------------------#
	 #  REPLACING AN ITEM AT ANY LEVEL  #
	#==================================#

	// Replaces an item at any nested level of the list by a new value
	def DeepReplaceCS(pItem, pByValue, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([
			"me",
			"other",
			[ "other", "me", [ "me" ], "other" ],
			"other"
		])
		
		o1.DeepReplace("me", :By = "you")
		? o1.Content()
		#--> [
		#	"you",
		#	"other",
		#	[ "other", "me", [ "you" ], "other" ],
		#	"other"
		#    ]
		
		*/

		if isList(pByValue) and Q(pByValue).IsByOrWithNamedParam()
			pByValue = pByValue[2]
		ok

		_cValue_ = @@(pItem)
		_cByValue_ = @@(pByValue)

		_cCode_ = This.ToCodeQ().ReplaceCSQ( _cValue_, _cByValue_, pCaseSensitive ).Content()
		_cCode_ = ' _aResult_ = ' + _cCode_

		eval(_cCode_)
		This.Update(_aResult_)

		def DeepReplaceCSQ(pItem, pByValue, pCaseSensitive)
			This.DeepReplaceCS(pItem, pByValue, pCaseSensitive)
			return This

	def DeepReplacedCS(pItem, pByValue, pCaseSensitive)
		_cResult_ = This.Copy().DeepReplaceCSQ(pItem, pByValue, pCaseSensitive)
		return _cResult_

	#-- WITHOUT CASESENSITIVITY

	def DeepReplace(pItem, pByValue)
		This.DeepReplaceCS(pItem, pByValue, _TRUE_)

		def DeepReplaceQ(pItem, pByValue)
			This.DeepReplace(pItem, pByValue)
			return This

	def DeepReplaced(pItem, pByValue)
		_cResult_ = This.Copy().DeepReplaceCSQ(pItem, pByValue).Content()
		return _cResult_

	  #=================================================================#
	 #  TRIMMING THE LIST (REMOVING LEADING AND TRAILING EMPRY ITEMS)  #
	#=================================================================#

	def TrimCS(pCaseSensitive)

		_oCopy_ = This.Copy()

		_oCopy_.TrimLeftCS(pCaseSensitive)
		_oCopy_.TrimRightCS(pCaseSensitive)
	
		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def TrimCSQ(pCaseSensitive)
			This.TrimCS(pCaseSensitive)
			return This
		#>

	def TrimmedCS(pCaseSensitive)
		aResult = This.Copy().TrimCSQ(pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def Trim()
		This.TrimCS(_TRUE_)

		def TrimQ()
			return This.TrimCSQ(_TRUE_)

	def Trimmed()
		return This.TrimmedCS(_TRUE_)

	  #---------------------------------------------------------------#
	 #  TRIMMING THE LIST FROM START (REMOVING LEADING EMPTY ITEMS)  #
	#---------------------------------------------------------------#

	def TrimLeftCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 1
			return
		ok

		# Leading

		i = 0

		while _TRUE_
			i++
			if i = nLen
				exit
			ok

			bEmptyItem = ( isNumber(aContent[i]) and aContent[i] = 0 ) or
			   ( isString(aContent[i]) and aContent[i] = "" ) or
			   ( isList(aContent[i]) and len(aContent[i]) = 0 ) or
			   ( isObject(aContent[i]) and @IsFalseObject(aContent[i]) )
	
			if NOT bEmptyItem
				exit
					
			ok

		end

		if i > 1
			This.RemoveSection(1, i-1)
		ok

		#< @FunctionFluentForm

		def TrimLeftCSQ(pCaseSensitive)
			This.TrimLeftCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def TrimFromLeftCS(pCaseSensitive)
			This.TrimLeftCS(pCaseSensitive)

			def TrimFromLeftCSQ(pCaseSensitive)
				return This.TrimLeftCSQ(pCaseSensitive)

		def TrimStartCS(pCaseSensitive)
			This.TrimLeftCS(pCaseSensitive)

			def TrimStartCSQ(pCaseSensitive)
				return This.TrimLeftCSQ(pCaseSensitive)

		def TrimFromStartCS(pCaseSensitive)
			This.TrimLeftCS(pCaseSensitive)

			def TrimFromStartCSQ(pCaseSensitive)
				return This.TrimLeftCSQ(pCaseSensitive)

		#>


	def TrimmedLeftCS(pCaseSensitive)
		aResult = This.Copy().TrimLeftCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def TrimmedFromLeftCS(pCaseSensitive)
			return This.TrimmedLeftCS(pCaseSensitive)

		def TrimmedStartCS(pCaseSensitive)
			return This.TrimmedLeftCS(pCaseSensitive)

		def TimmedFromStartCS(pCaseSensitive)
			return This.TrimmedLeftCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def TrimLeft()
		This.TrimLeftCS(_TRUE_)

		#< @FunctionAlternativeForm

		def TrimFromLeft()
			This.TrimLeft()

			def TrimFromLeftQ()
				return This.TrimLeftQ()

		def TrimStart()
			This.TrimLeft()

			def TrimStartQ()
				return This.TrimLeftQ()

		def TrimFromStart()
			This.TrimLeft()

			def TrimFromStartQ()
				return This.TrimLeftQ()

		#>

	def TrimmedLeft()
		aResult = This.Copy().TrimLeftQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def TrimmedFromLeft()
			return This.TrimmedLeft()

		def TrimmedStart()
			return This.TrimmedLeft()

		def TimmedFromStart()
			return This.TrimmedLeft()

		#>

	  #--------------------------------------------------------------#
	 #  TRIMMING THE LIST FROM END (REMOVING TRAILING EMPTY ITEMS)  #
	#--------------------------------------------------------------#

	def TrimRightCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 1
			return
		ok

		# Leading

		i = 0

		while _TRUE_
			i++
			if i = nLen
				exit
			ok

			n = nLen - i + 1

			bEmptyItem = ( isNumber(aContent[n]) and aContent[n] = 0 ) or
			   ( isString(aContent[n]) and aContent[n] = "" ) or
			   ( isList(aContent[n]) and len(aContent[n]) = 0 ) or
			   ( isObject(aContent[n]) and @IsFalseObject(aContent[n]) )
	
			if NOT bEmptyItem
				exit
					
			ok

		end

		if i > 1
			This.RemoveSection(n + 1, nLen)
		ok

		#< @FunctionFluentForm

		def TrimRightCSQ(pCaseSensitive)
			This.TrimRightCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def TrimFromRightCS(pCaseSensitive)
			This.TrimRightCS(pCaseSensitive)

			def TrimFromRightCSQ(pCaseSensitive)
				return This.TrimRightCSQ(pCaseSensitive)

		def TrimEndCS(pCaseSensitive)
			This.TrimRightCS(pCaseSensitive)

			def TrimEndCSQ(pCaseSensitive)
				return This.TrimRightCSQ(pCaseSensitive)

		def TrimFromEndCS(pCaseSensitive)
			This.TrimRightCS(pCaseSensitive)

			def TrimFromEndCSQ(pCaseSensitive)
				return This.TrimRightCSQ(pCaseSensitive)

		#>


	def TrimmedRightCS(pCaseSensitive)
		aResult = This.Copy().TrimRightCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def TrimmedFromrightCS(pCaseSensitive)
			return This.TrimmedrightCS(pCaseSensitive)

		def TrimmedEndCS(pCaseSensitive)
			return This.TrimmedRightCS(pCaseSensitive)

		def TimmedFromEndCS(pCaseSensitive)
			return This.TrimmedRightCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def TrimRight()
		This.TrimRightCS(_TRUE_)

		#< @FunctionAlternativeForm

		def TrimFromRight()
			This.TrimRight()

			def TrimFromRightQ()
				return This.TrimRightQ()

		def TrimEnd()
			This.TrimRight()

			def TrimEndQ()
				return This.TrimRightQ()

		#>

	def TrimmedRight()
		aResult = This.Copy().TrimRightQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def TrimmedFromRight()
			return This.TrimmedRight()

		def TrimmedEnd()
			return This.TrimmedRight()

		def TimmedFromEnd()
			return This.TrimmedRight()

		#>

	  #=====================================#
	 #  DEEP-REMOVING AN ITEM IN THE LIST  #
	#=====================================#

	// Removes an item at any nested level of the list

	def DeepRemoveCS(pItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([
			"me",
			"other",
			[ "other", "me", [ "other" ], "other" ],
			"other"
		])
		
		o1.DeepRemove("other)
		? o1.Content()
		#--> [
		#	"you",
		#	[ "me", [ ] ],
		#    ]
		
		*/

		_cValue_ = @@(pItem)

		_cCode_ =  This.ToCodeQ().
				RemoveManyCSQ([

					( _cValue_ + "," ),
					( _cValue_ )

				], pCaseSensitive ).

				Content()

		_cCode_ = ' _aResult_ = ' + _cCode_

		eval(_cCode_)
		This.Update(_aResult_)

		def DeepRemoveCSQ(pItem, pCaseSensitive)
			This.DeepRemoveCS(pItem, pCaseSensitive)
			return This

	def DeepRemovedCS(pItem, pCaseSensitive)
		_cResult_ = This.Copy().DeepRemoveCSQ(pItem, pCaseSensitive)
		return _cResult_

	#-- WITHOUT CASESENSITIVITY

	def DeepRemove(pItem)
		This.DeepRemoveCS(pItem, _TRUE_)

		def DeepRemoveQ(pItem)
			This.DeepRemove(pItem)
			return This

	def DeepRemoved(pItem)
		_cResult_ = This.Copy().DeepRemoveCSQ(pItem).Content()
		return _cResult_

	  #=========================================================#
	 #   REMOVING ALL OCCURRENCE OF A GIVEN ITEM IN THE LIST   #
	#=========================================================#

	def RemoveAllCS(pItem, pCaseSensitive)
		if CheckingParams()
			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLenPos = len(anPos)

		_oCopy_ = This.Copy()

		for i = nLenPos to 1 step -1
			_oCopy_.RemoveItemAtPosition(anPos[i])
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveAllCSQ(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)
			return This

		def RemoveAllCSQC(pItem, pCaseSensitive)
			_oCopy_ = This.Copy()
			_oCopy_.RemoveAllCSQ(pItem, pCaseSensitive)
			return _oCopy_

		#>

		#< @FunctionAlternativeForms

		def RemoveAllOccurrencesCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveAllOccurrencesCSQ(pItem, pCaseSensitive)
				This.RemoveAllOccurrencesCS(pItem, pCaseSensitive)
				return This

			def RemoveAllOccurrencesCSQC(pItem, pCaseSensitive)
				return This.RemoveAllCSQC(pItem, pCaseSensitive)

		def RemoveCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveCSQ(pItem, pCaseSensitive)
				This.RemoveCS(pItem, pCaseSensitive)
				return This

			def RemoveCSQC(pItem, pCaseSensitive)
				return This.RemoveAllCSQC(pItem, pCaseSensitive)

		def RemoveItemCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveItemCSQ(pItem, pCaseSensitive)
				This.RemoveItemCS(pItem, pCaseSensitive)
				return This

			def RemoveItemCSQC(pItem, pCaseSensitive)
				return This.RemoveAllCSQC(pItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveAllOccurrencesCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def AllOccurrencesRemovedCS(pItem, pCaseSensitive)
			return This.AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)

		def ItemRemovedCS(pItem, pCaseSensitive)
			return This.AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)

	#== WITHOUT CASESENSITIVITY

	def RemoveAll(pItem)
		This.RemoveAllCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def RemoveAllQ(pItem)
			This.RemoveAll(pItem)
			return This

		def RemoveAllQC(pItem)
			_oCopy_ = This.Copy()
			_oCopy_.RemoveAll(pItem)
			return _oCopy_
	
		#>

		#< @FunctionAlternativeForms

		def RemoveAllOccurrences(pItem)
			This.RemoveAll(pItem)

			def RemoveAllOccurrencesQ(pItem)
				This.RemoveAllOccurrences(pItem)
				return This

			def RemoveAllOccurrencesQC(pItem)
				return This.RemoveAllQC(pItem)

		def Remove(pItem)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.RemoveAll(pItem)

			def RemoveQ(pItem)
				This.Remove(pItem)
				return This

			def RemoveQC(pItem)
				return This.RemoveAllQC(pItem)

		def RemoveItem(pItem)
			This.RemoveAll(pItem)

			def RemoveItemQ(pItem)
				This.RemoveItem(pItem)
				return This

			def RemoveItemQC(pItem)
				return This.RemoveAllQC(pItem)

	#-- @FunctionPassiveForm

	def AllOccurrencesOfThisItemRemoved(pItem)
		aResult = This.Copy().RemoveAllOccurrencesQ(pItem).Content()
		return aResult

		def AllOccurrencesRemoved(pItem)
			return This.AllOccurrencesOfThisItemRemoved(pItem)

		def ItemRemoved(pItem)
			return This.AllOccurrencesOfThisItemRemoved(pItem)

	#-- @FunctionRandomForm

	def rndRemove()
		_anPos_ = RandomNumbersIn(1:This.NumberOfItems())
		This.RemoveItemsAtPositions(_anPos_)

		#< @FunctionAlternativeForms

		def rndRemoveQ()
			This.rndRemove()
			return This

			def rndRemoveQC()
				return This.Copy().rndRemoveQ()

		def RemoveRandomly()
			This.rndRemove()

			def RemoveRandomlyQ()
				return This.rndRemoveQ()

			def RemoveRandomlyQC()
				return This.Copy().rndRemoveQ()

		def RandomRemove()
			This.rndRemove()

			def RandomRemoveQ()
				return This.rndRemoveQ()

			def RandomRemoveQC()
				return This.Copy().rndRemoveQ()

		def RandomlyRemove()
			This.rndRemove()

			def RandomlyRemoveQ()
				return This.rndRemoveQ()

			def RandomlyRemoveQC()
				return This.Copy().rndRemoveQ()

		#--

		def rndRemoveItems()
			This.rndRemove()

			def rndRemoveItemsQ()
				return This.rndRemoveItemsQ()

			def rndRemoveItemsQC()
				return This.Copy().rndRemoveQ()

		def RemoveItemsRandomly()
			This.rndRemove()

			def RemoveItemsRandomlyQ()
				return This.rndRemoveQ()

			def RemoveItemsRandomlyQC()
				return This.Copy().rndRemoveQ()

		def RandomRemoveItems()
			This.rndRemove()

			def RandomRemoveItemsQ()
				return This.rndRemoveQ()

			def RandomRemoveItemsQC()
				return This.Copy().rndRemoveQ()

		def RandomlyRemoveItems()
			This.rndRemove()

			def RandomlyRemoveItemsQ()
				return This.rndRemoveQ()

			def RandomlyRemoveItemsQC()
				return This.Copy().rndRemoveQ()

		#>

		#< @FunctionPassiveRandomForms

		def rndRemoved()
			_aResult_ = This.Copy().rndRemoveQ().Content()
			return _aResult_

			def RandomRemoved()
				return This.rndRemoved()

			def RandomyRemoved()
				return This.rndRemoved()

			def RemovedRandomly()
				return This.rndRemoved()

			def RemovedRandom()
				return This.rndRemoved()

		#--

		def rndItemsRemoved()
			_aResult_ = This.Copy().rndRemoveQ().Content()
			return _aResult_

			def RandomItemsRemoved()
				return This.rndRemoved()

			def RandomyRemovedItems()
				return This.rndRemoved()

			def ItemsRemovedRandomly()
				return This.rndRemoved()

			def ItemsRemovedRandom()
				return This.rndRemoved()

		#>

	  #-------------------------------------------------------#
	 #   REMOVING GIVEN OCCURRENCES OF AN ITEM IN THE LIST   #TODO // Add CASESENSITIVITY
	#-------------------------------------------------------#

	def RemoveOccurrences(panOccurr, pItem)
		if CheckingParams()
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and
			   Q(panOccurr[i]).IsAndNamedParam()

				panOccurr[i] = panOccurr[i][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrences(pItem)
					ok
				ok
			next
		ok

		if NOT ( isList(panOccurr) and @IsListOfNumbers(panOccurr) )
			StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
		ok

		anPos = This.FindTheseOccurrences(panOccurr, pItem)
		This.RemoveItemsAtPositions(anPos)


		#< @FunctionFluentForm

		def RemoveOccurrencesQ(panOccurr, pItem)
			This.RemoveOccurrences(panOccurr, pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveManyOccurrences(paOccurrences, pItem)
			This.RemoveOccurrences(panOccurr, pItem)

			def RemoveManyOccurrencesQ(paOccurrences, pItem)
				This.RemoveManyOccurrences(paOccurrences, pItem)
				return This

		def RemoveTheseOccurrences(panOccurr, pItem)
			This.RemoveOccurrences(panOccurr, pItem)

			def RemoveTheseOccurrencesQ(panOccurr, pItem)
				This.RemoveTheseOccurrences(panOccurr, pItem)
				return This

		#>

	def OccurrencesRemoved(panOccurr, pItem)
		aResult = This.Copy.RemoveOccurrencesQ(panOccurr, pItem).Content()
		return aResult

		def TheseOccurrencesRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def TheseOccurrencesOfThisItemRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def ManyOccurrencesOfThisItemRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def ManyOccurrencesRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

	  #------------------------------------------#
	 #   REMOVING MANY ITEMS AT THE SAME TIME   #
	#------------------------------------------#

	def RemoveManyCS(paItems, pCaseSensitive)
		if CheckingParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)
		_oCopy_ = This.Copy()

		for i = 1 to nLen
			_oCopy_.RemoveAllCS(paItems[i], pCaseSensitive)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveManyCSQ(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAllOfTheseCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveAllOfTheseCSQ(paItems, pCaseSensitive)
				This.RemoveAllOfTheseCS(paItems, pCaseSensitive)
				return This

		def RemoveTheseCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveTheseCSQ(paItems, pCaseSensitive)
				This.RemoveTheseCS(paItems, pCaseSensitive)
				return This

		def RemoveTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveTheseItemsCS(paItems, pCaseSensitive)
				return This

		#>

	def TheseItemsRemovedCS(paItems, pCaseSensitive)

		aResult =  This.Copy().
				RemoveTheseItemsCSQ(paItems, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		def ManyItemsRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		def ManyRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveMany(paItems)
		This.RemoveManyCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def RemoveAllOfThese(paItems)
			This.RemoveMany(paItems)

			def RemoveAllOfTheseQ(paItems)
				This.RemoveAllOfThese(paItems)
				return This

		def RemoveThese(paItems)
			This.RemoveMany(paItems)

			def RemoveTheseQ(paItems)
				This.RemoveThese(paItems)
				return This

		def RemoveTheseItems(paItems)
			This.RemoveMany(paItems)

			def RemoveTheseItemsQ(paItems)
				This.RemoveTheseItems(paItems)
				return This

		#>

	def TheseItemsRemoved(paItems)

		aResult =  This.Copy().
				RemoveTheseItemsQ(paItems).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOfTheseItemsRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		def ManyItemsRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		def ManyRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		#>

	  #--------------------------------------------#
	 #  REMOVING ITEMS OTHER THAN THOSE PROVIDED  #
	#--------------------------------------------#

	def RemoveItemsOtherThanCS(paItems, pCaseSensitive)
		anPos = This.FindItemsOtherThanCS(paItems, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveItemsOtherThanCSQ(paItems, pCaseSensitive)
			This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsOtherThanTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def RemoveItemsExceptCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def RemoveAllExceptCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveAllExceptTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveAllButCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#>

	def ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)
		aResult = This.Copy().RemoveItemsOtherThanCSQ(paItems, pCaseSensitive).Content()
		return aResult

		def ItemsRemovedExceptCS(paItems, pCaseSensitive)
			return This.ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)

		def AllRemovedButCS(paItems, pCaseSensitive)
			return This.ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemsOtherThan(paItems)
		return This.RemoveItemsOtherThanCS(paItems, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemsOtherThanQ(paItems)
			This.RemoveItemsOtherThan(paItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsOtherThanThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#--

		def RemoveItemsExcept(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveItemsExceptThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#--

		def RemoveAllExcept(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveAllExceptThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveAllBut(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#>

	def ItemsOtherThanTheseRemoved(paItems)
		aResult = This.Copy().RemoveItemsOtherThanQ(paItems).Content()
		return aResult

		def ItemsRemovedExcept(paItems)
			return This.ItemsOtherThanTheseRemoved(paItems)

		def AllRemovedBut(paItems)
			return This.ItemsOtherThanTheseRemoved(paItems)

	  #-------------------------------------------------#
	 #   REMOVING THE NTH OCCURRENCE OF A GIVEN ITEM   #
	#-------------------------------------------------#

	def RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)
		nPos = This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		This.RemoveItemAtPosition( nPos )

		#< @FunctionFluentForm

		def RemoveNthOccurrenceCSQ(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveNthCS(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)

			def RemoveNthCSQ(n, pItem, pCaseSensitive)
				This.RemoveNthCS(n, pItem, pCaseSensitive)
				return This

		def RemoveOccurrenceCS(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)

			def RemoveOccurrenceCSQ(n, pItem, pCaseSensitive)
				This.RemoveOccurrenceCS(n, pItem, pCaseSensitive)
				return This

		#>

	def NthOccurrenceRemovedCS(n, pItem, pCaseSensitive)
		aResult = This.Copy().RemoveNthOccurrencesCSQ(n, pItem, pCaseSensitive).Content()
		return aResult

		def NthRemovedCS(n, pItem, pCaseSensitive)
			return This.NthOccurrenceRemovedCS(n, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pItem)
		This.RemoveNthOccurrenceCS(n, pItem, _TRUE_)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pItem)
			This.RemoveNthOccurrence(n, pItem)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveNth(n, pItem)
			This.RemoveNthOccurrence(n, pItem)

			def RemoveNthQ(n, pItem)
				This.RemoveNth(n, pItem)
				return This

		def RemoveOccurrence(n, pItem)
			This.RemoveNth(n, pItem)

			def RemoveOccurrenceQ(n, pItem)
				This.RemoveOccurrence(n, pItem)
				return This
		#>

	def NthOccurrenceRemoved(n, pItem)
		aResult = This.Copy().RemoveNthOccurrencesQ(n, pItem).Content()
		return aResult

		def NthRemoved(n, pItem)
			return This.NthOccurrenceRemoved(n, pItem)

	  #----------------------------------------------#
	 #   REMOVING THE FIRST OCCURRENCE OF AN ITEM   #
	#----------------------------------------------#

	def RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

		This.RemoveItemAtPosition( This.FindFirstOccurrenceCS(pItem, pCaseSensitive) )


		#< @FunctionFluentForm

		def RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFirstCSQ(pItem, pCaseSensitive)
				This.RemoveFirstCS(pItem, pCaseSensitive)
				return This

		#>

		#< @FunctionMisspelledForms

		def RemoveFristOccurrenceCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFristOccurrenceCSQ(pItem, pCaseSensitive)
				return RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive)

		#--

		def RemoveFristCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFristCSQ(pItem, pCaseSensitive)
				return This.RemoveFirstCSQ(pItem, pCaseSensitive)

		#>

	def FirstOccurrenceRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def FirstRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)

		def FristRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pItem)
		This.RemoveFirstOccurrenceCS(pItem, _TRUE_)


		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pItem)
			This.RemoveFirstOccurrence(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirst(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFirstQ(pItem)
				This.RemoveFirst(pItem)
				return This

		#>

		#< @FunctionMisspelledForms

		def RemoveFristOccurrence(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFristOccurrenceQ(pItem)
				return RemoveFirstOccurrenceQ(pItem)

		#--

		def RemoveFrist(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFristQ(pItem)
				return This.RemoveFirstQ(pItem)

		#>

	def FirstOccurrenceRemoved(pItem)
		aResult = This.Copy().RemoveFirstOccurrenceQ(pItem).Content()
		return aResult

		def FirstRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

		#-- MISSPELLED

		def FristOccurrenceRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

		def FristRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

	  #--------------------------------------------------#
	 #   REMOVING THE LAST OCCURRENCE OF A GIVEN ITEM   #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pItem, pCaseSensitive)
		n = This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		if n <= This.NumberOfItems()
			This.RemoveItemAtPosition( n )
		ok

		#< @FunctionFluentForm

		def RemoveLastOccurrenceCSQ(pItem, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastCS(pItem, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pItem, pCaseSensitive)

			def RemoveLastCSQ(pItem, pCaseSensitive)
				This.RemoveLastCS(pItem, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveLastOccurrenceCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def LastRemovedCS(pItem, pCaseSensitive)
			return This.LastOccurrenceRemovedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pItem)
		n = This.FindLastOccurrence(pItem)

		if n <= This.NumberOfItems()
			This.RemoveItemAtPosition( n )
		ok

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pItem)
			This.RemoveLastOccurrence(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLast(pItem)
			This.RemoveLastOccurrence(pItem)

			def RemoveLastQ(pItem)
				This.RemoveLast(pItem)
				return This

		#>

	def LastOccurrenceRemoved(pItem)
		aResult = This.Copy().RemoveLastOccurrenceQ(pItem).Content()
		return aResult

		def LastRemoved(pItem)
			return This.LastOccurrenceRemoved(pItem)

	   #----------------------------------------------#
	  #   REMOVING NEXT NTH OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST   #
	#----------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
		nPos = This.FindNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
		This.RemoveItemAtPosition(nPos)

		#< @FuntionFluentForm

		def RemoveNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This

		#<

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)

		#--

		def RemoveNextNthOccurrenceSTCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextNthOccurrenceSTCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthNextOccurrenceSTCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrenceSTCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		aResult  = This.Copy().
				RemoveNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def NextNthOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		#--

		def NthNextOccurrenceRemovedSTCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		def NextNthOccurrenceRemovedSTCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pItem, pnStartingAt)
		This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, _TRUE_)

		#< @FuntionFluentForm

		def RemoveNextNthOccurrenceQ(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)
			return This

		#<

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrence(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNthNextOccurrenceQ(n, pItem, pnStartingAt)
				This.RemoveNthNextOccurrence(n, pItem, pnStartingAt)
				return This

		#--

		def RemoveNextNthOccurrenceST(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNextNthOccurrenceSTQ(n, pItem, pnStartingAt)
				return This.RemoveNextNthOccurrenceQ(n, pItem, pnStartingAt)

		def RemoveNthNextOccurrenceST(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNthNextOccurrenceSTQ(n, pItem, pnStartingAt)
				return This.RemoveNextNthOccurrenceQ(n, pItem, pnStartingAt)

		#>

	def NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

		aResult  = This.Copy().
				RemoveNthNextOccurrenceQ(n, pItem, pnStartingAt).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def NextNthOccurrenceRemoved(n, pItem, pnStartingAt)
			return This.NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

		#--

		def NthNextOccurrenceRemovedST(n, pItem, pnStartingAt)
			return This.NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

		def NextNthOccurrenceRemovedST(n, pItem, pnStartingAt)
			return This.NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

		#>

	   #-----------------------------------------------#
	  #   REMOVING NEXT OCCURRENCE OF AN ITEM         #
	 #   STARTING AT A GIVEN POSITION IN THE LIST    #
	#-----------------------------------------------#

	def RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pItem, pnStartingAt, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitiy)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveNextCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)

		def RemoveNextSTCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)

		def RemoveNextOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextOccurrenceSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)
		aResult =  This.Copy().
				RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive).
				Content()
		return aResult

		#< @FunctionAlternativeForms

		def NextRemovedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def NextRemovedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

		def NextOccurrenceRemovedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pItem, pnStartingAt)
		This.RemoveNextNthOccurrence(1, pItem, pnStartingAt)

		#< @FunctionAlternativeForms

		def RemoveNext(pItem, pnStartingAt)
			This.RemoveNextOccurrence(pItem, pnStartingAt)

			def RemoveNextQ(pItem, pnStartingAt)
				return This.RemoveNextOccurrenceQ(pItem, pnStartingAt)

		def RemoveNextST(pItem, pnStartingAt)
			This.RemoveNextOccurrence(pItem, pnStartingAt)

			def RemoveNextSTQ(pItem, pnStartingAt)
				return This.RemoveNextOccurrenceQ(pItem, pnStartingAt)

		def RemoveNextOccurrenceST(pItem, pnStartingAt)
			This.RemoveNextOccurrence(pItem, pnStartingAt)

			def RemoveNextOccurrenceSTQ(pItem, pnStartingAt)
				return This.RemoveNextOccurrenceQ(pItem, pnStartingAt)

		#>

	#-- @FunctionPassiveForm

	def NextOccurrenceRemoved(pItem, pnStartingAt)
		aResult =  This.Copy().
				RemoveNextOccurrenceQ(pItem, pnStartingAt).
				Content()
		return aResult

		#< @FunctionAlternativeForms

		def NextRemoved(pItem, pnStartingAt)
			return This.NextOccurrenceRemoved(pItem, pnStartingAt)

		#--

		def NextRemovedST(pItem, pnStartingAt)
			return This.NextOccurrenceRemoved(pItem, pnStartingAt)

		def NextOccurrenceRemovedST(pItem, pnStartingAt)
			return This.NextOccurrenceRemoved(pItem, pnStartingAt)

		#>

	   #----------------------------------------------------#
	  #   REMOVING MANY NEXT NTH OCCURRENCES OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST         #
	#----------------------------------------------------#

	def RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			RemoveNextNthOccurrences([2, 3], :of = "A", :StartingAt = 3)
			? Content() # !--> [ "A" , "B", "A", "C", "D" ]
		}		

		*/

		anPos = This.FindNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		#--

		def RemoveNextNthOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextNthOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthNextOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNextOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		#>

	def NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		aResult =  This.
			   RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive).
			   Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthNextOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		#--

		def NextNthOccurrencesRemovedSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		def NthNextOccurrencesRemovedSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextNthOccurrences(panList, pItem, pnStartingAt)
		This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthNextOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
				return This

		def RemoveNextOccurrences(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNextOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
				return This

		#--

		def RemoveNextNthOccurrencesST(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNextNthOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt)

		def RemoveNthNextOccurrencesST(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthNextOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt)

		def RemoveNextOccurrencesST(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNextOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt)

		#>

	def NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		aResult =  This.
			   RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt).
			   Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthNextOccurrencesRemoved(panList, pItem, pnStartingAt)
			return This.NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		#--

		def NextNthOccurrencesRemovedST(panList, pItem, pnStartingAt)
			return This.NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		def NthNextOccurrencesRemovedST(panList, pItem, pnStartingAt)
			return This.NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		#>

	   #--------------------------------------------------#
	  #   REMOVING PREVIOUS NTH OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST       #
	#--------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)

			if ring_find([
				:First, :FirstPosition, :FirstItem, :FirstItem ], pnStartingAt) > 0

				pnStartingAt = 1
			
			but ring_find([
				:Last, :LastPosition, :LastItem, :LastItem ], pnStartingAt) > 0

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection   = This.SectionQ(1, pnStartingAt)
		aPositions = oSection.FindAllCS(pItem, pCaseSensitive)

		nPosition = aPositions[ len(aPositions) - n + 1 ]

		This.RemoveItemAtPosition(nPosition)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthPreviousOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
				return This
		#>

	def NthPreviousOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				RemoveNthPreviousOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive).
				Content()

		return This

		def PreviousNthOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pItem, pnStartingAt)
		This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, _TRUE_)

		def RemovePreviousNthOccurrenceQ(n, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrence(n, pItem, pnStartingAt)
			return This

		def RemoveNthPreviousOccurrence(n, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNthPreviousOccurrenceQ(n, pItem, pnStartingAt)
				This.RemoveNthPreviousOccurrence(n, pItem, pnStartingAt)
				return This

	def NthPreviousOccurrenceRemoved(n, pItem, pnStartingAt)

		aResult =  This.Copy().
				RemoveNthPreviousOccurrenceQ(n, pItem, pnStartingAt).
				Content()

		return This

		def PreviousNthOccurrenceRemoved(n, pItem, pnStartingAt)
			return This.NthPreviousOccurrenceRemoved(n, pItem, pnStartingAt)

	   #----------------------------------------------#
	  #   REMOVING PREVIOUS OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST   #
	#----------------------------------------------#

	def RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pItem, pnStartingAt, pCaseSensitive)

		def RemovePreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This

		def RemovePreviousCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

	def PreviousOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)
		aResult =  This.Copy().
				RemovePreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive).
				Content()
		return This

		def PreviousRemovedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

	# WITHOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pItem, pnStartingAt)
		This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, _TRUE_)

		def RemovePreviousOccurrenceQ(pItem, pnStartingAt)
			This.RemovePreviousOccurrence(pItem, pnStartingAt)
			return This

		def RemovePrevious(pItem, pnStartingAt)
			This.RemovePreviousOccurrence(pItem, pnStartingAt)

	def PreviousOccurrenceRemoved(pItem, pnStartingAt)
		aResult =  This.Copy().
				RemovePreviousOccurrenceQ(pItem, pnStartingAt).
				Content()
		return This

		def PreviousRemoved(pItem, pnStartingAt)
			return This.PreviousOccurrenceRemoved(pItem, pnStartingAt)

	   #--------------------------------------------------------#
	  #   REMOVING MANY PREVIOUS NTH OCCURRENCES OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST             #
	#--------------------------------------------------------#

	def RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			RemovePreviousNthOccurrences([2, 3], :of = "A", :StartingAt = 5)
			? Content() #--> [ "A" , "B", "C", "D", "A" ]
		}		

		*/

		anPos = This.FindPreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemovePreviousOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthPreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthPreviousOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		#--

		def RemovePreviousNthOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemovePreviousNthOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)


		def RemovePreviousOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemovePreviousOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthPreviousOccurrencesSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthPreviousOccurrencesSTCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		#>

	def PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		aResult = This.
			  RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive).
			  Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		#--

		def PreviousNthOccurrencesRemovedSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		def NthPreviousOccurrencesRemovedSTCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)
		This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrences(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemovePreviousOccurrencesQ(panList, pItem, pnStartingAt)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthPreviousOccurrences(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthPreviousOccurrencesQ(panList, pItem, pnStartingAt)
				return This.RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)


		#--

		def RemovePreviousNthOccurrencesST(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemovePreviousNthOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt)

		def RemovePreviousOccurrencesST(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemovePreviousOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNthPreviousOccurrencesST(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthPreviousOccurrencesSTQ(panList, pItem, pnStartingAt)
				return This.RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt)

		#>

	def PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		aResult = This.
			  RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt).
			  Content()

		return aResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrencesRemoved(panList, pItem, pnStartingAt)
			return This.PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		#--

		def PreviousNthOccurrencesRemovedST(panList, pItem, pnStartingAt)
			return This.PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		def NthPreviousOccurrencesRemovedST(panList, pItem, pnStartingAt)
			return This.PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		#>

	  #--------------------------------------------------#
	 #   REMOVING AN ITEM BY SPECIFYING ITS POSITION    #
	#--------------------------------------------------#

	def RemoveItemAtPosition(n)

		# Checking param correctness

		if isString(n)

			if ring_find([
				:First, :FirstPosition,
			      	:FirstItem, :FirstItem ], n) > 0
				  
				n = 1

			but ring_find([
				:Last, :LastPosition,
			     	:LastItem, :LastItem ], n) > 0

				n = This.NumberOfItems()
			ok
		ok

		if NOT (isNumber(n) and n != 0 )
			StzRaise("Incorrect param! n must be a number different from zero.")
		ok

		# Doing the job

		if n <= This.NumberOfItems()
			aContent = This.Content()
			ring_del( aContent, n )
			This.UpdateWith(aContent)
		ok


		#< @FunctionFluentForm

		def RemoveItemAtPositionQ(n)
			This.RemoveItemAtPosition(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAt(n)
			This.RemoveItemAtPosition(n)

			def RemoveAtQ(n)
				This.RemoveAt(n)
				return This

		def RemoveAtPosition(n)
			This.RemoveItemAtPosition(n)

			def RemoveAtPositionQ(n)
				This.RemoveAtPosition(n)
				return This

		def RemoveItemAt(n)
			This.RemoveItemAtPosition(n)

			def RemoveItemAtQ(n)
				This.RemoveItemAt(n)
				return This

		#--

		def RemoveNthItem(n)
			This.RemoveItemAtPosition(n)

			def RemoveNthItemQ(n)
				This.RemoveNthItem(n)
				return This

		#>

	def ItemAtPositionNRemoved(n)
		aResult = This.Copy().RemoveItemAtPositionQ(n).Content()
		return This

		def NthItemRemoved(n)
			return This.ItemAtPositionNRemoved(n)

	  #--------------------------------------#
	 #    REMOVING FIRST ITEM IN THE LIST   #
	#--------------------------------------#

	def RemoveFirstItem()
		This.RemoveItemAtPosition(1)

		#< @FunctionFluentForm

		def RemoveFirstItemQ()
			This.RemoveFirstItem()
			return This

		#>

		#< @FunctionMisspelledForm

		def RemoveFristItem()
			This.RemoveFirstItem()

			def RemoveFristItemQ()
				return This.RemoveFirstItemQ()

		#>

	def FirstItemRemoved()
		aResult = This.Copy().RemoveFirstItemQ().Content()
		return aResult

		#-- MISSPELLED

		def FristItemRemoved()
			return This.FirstItemRemoved()

	  #-------------------------------------#
	 #    REMOVING LAST ITEM IN THE LIST   #
	#-------------------------------------#

	def RemoveLastItem()
		This.RemoveItemAtPosition( This.NumberOfItems() )

		#< @FunctionFluentForm

		def RemoveLastItemQ()
			This.RemoveLastItem()
			return This

		#>

	def LastItemRemoved()
		aResult = This.Copy().RemoveLastItemQ().Content()
		return aResult

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST ITEMS  #
	#----------------------------------#

	def RemoveFirstAndLastItems()

		_oCopy_ = This.Copy()

		_oCopy_.RemoveFirstItem()
		_oCopy_.RemoveLastItem()

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveFirstAndLastItemsQ()
			This.RemoveFirstAndLastItems()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstItems()
			This.RemoveFirstAndLastItems()

			def RemoveLastAndFirstItemsQ()
				This.RemoveLastAndFirstItems()
				return This

		def RemoveFirstAndLast()
			This.RemoveFirstAndLastItems()

			def RemoveFirstAndLastQ()
				This.RemoveFirstAndLast()

		def RemoveLastAndFirst()
			This.RemoveFirstAndLastItems()

			def RemoveLastAndFirstQ()
				This.RemoveFirstAndLast()

		#--

		def RemoveFirstItemAndLastItem()
			This.RemoveFirstAndLastItems()

			def RemoveFirstItemAndLastItemQ()
				This.RemoveFirstItemAndLastItem()
				return This

		def RemoveLastItemAndFirstItem()
			This.RemoveFirstAndLastItems()

			def RemoveLastItemAndFirstItemQ()
				This.RemoveLastItemAndFirstItem()
				return This

		#>

	def FirstAndLastItemsRemoved()
		aResult = This.Copy().RemoveFirstAndLastItemsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def LastAndFirstItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def FirstAndLastRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFirstRemoved()
			return This.FirstAndLastItemsRemoved()

		#--

		def FirstItemAndLastItemRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastItemAndFirstItemRemoved()
			return This.FirstAndLastItemsRemoved()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFristItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def FristAndLastRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFristRemoved()
			return This.FirstAndLastItemsRemoved()

		#--

		def FristItemAndLastItemRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastItemAndFristItemRemoved()
			return This.FirstAndLastItemsRemoved()

		#>

	  #---------------------------------------------#
	 #  REMOVING A GiVEN ITEM AT A GIVEN POSITION  #
	#---------------------------------------------#

	def RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)
		if This.ItemAtPositionQ(n).IsEqualToCS(pItem, pCaseSensitive)
			This.RemoveItemAtPosition(n)
		ok

		#< @FunctionFluentForm

		def RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive)
			This.RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveThisItemAtCS(pItem, n, pCaseSensitive)
			if isList(n)
				This.RemoveThisItemAtPositionsCS(pItem, n, pCaseSensitive)
				return
			ok

			This.RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)

			def RemoveThisItemAtCSQ(pItem, n, pCaseSensitive)
				return This.RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive)

		def RemoveItemAtPositionCS(pItem, n, pCaseSensitive)
			This.RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)

			def RemoveItemAtPositionCSQ(pItem, n, pCaseSensitive)
				return This.RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive)

		def RemoveThisAtPositionCS(pItem, n, pCaseSensitive)
			This.RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)

			def RemoveThisAtPositionCSQ(pItem, n, pCaseSensitive)
				return This.RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive)

		def RemoveThisAtCS(pItem, n, pCaseSensitive)
			if isList(n)
				This.RemoveThisItemAtPositionsCS(pItem, n, pCaseSensitive)
				return
			ok

			This.RemoveThisItemAtPositionCS(pItem, n, pCaseSensitive)

			def RemoveThisAtCSQ(pItem, n, pCaseSensitive)
				return This.RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive)
		#>

	def ThisItemAtPositionRemovedCS(pItem, n, pCaseSensitive)
		_aResult_ = This.Copy().RemoveThisItemAtPositionCSQ(pItem, n, pCaseSensitive).Content()
		return _aResult_

		def ItemAtPositionRemovedCS(pItem, n, pCaseSensitive)
			return This.ThisItemAtPositionRemovedCS(pItem, n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisItemAtPosition(pItem, n)
		This.RemoveThisItemAtPositionCS(pItem, n, _TRUE_)

		#< @FunctionFluentForm

		def RemoveThisItemAtPositionQ(pItem, n)
			This.RemoveThisItemAtPosition(pItem, n)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveThisItemAt(pItem, n)
			if isList(n)
				This.RemoveThisItemAtPositions(pItem, n)
				return
			ok

			This.RemoveThisItemAtPosition(pItem, n)

			def RemoveThisItemAtQ(pItem, n)
				return This.RemoveThisItemAtPositionQ(pItem, n)

		def RemoveThisAtPosition(pItem, n)
			This.RemoveThisItemAtPosition(pItem, n)

			def RemoveThisAtPositionQ(pItem, n)
				return This.RemoveThisItemAtPositionQ(pItem, n)

		def RemoveThisAt(pItem, n)
			if isList(n)
				This.RemoveThisItemAtPositions(pItem, n)
				return
			ok

			This.RemoveThisItemAtPosition(pItem, n)

			def RemoveThisAtQ(pItem, n)
				return This.RemoveThisItemAtPositionQ(pItem, n)
		#>

	def ThisItemAtPositionRemoved(pItem, n)
		_aResult_ = This.Copy().RemoveThisItemAtPositionQ(pItem, n).Content()
		return _aResult_

	  #--------------------------------------------#
	 #  REMOVING A GiVEN ITEM AT GIVEN POSITIONS  #
	#--------------------------------------------#

	def RemoveThisItemAtPositionsCS(pItem, panPos, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
		ok


		_anPos_ = u( ring_sort(panPos) )
		_nLen_ = len(_anPos_)

		_oCopy_ = This.Copy()

		for @i = _nLen_ to 1 step -1
			_oCopy_.RemoveThisItemAtPositionCS(pItem, _anPos_[@i], pCaseSensitive)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveThisItemAtPositionsCSQ(pItem, panPos, pCaseSensitive)
			This.RemoveThisItemAtPositionsCS(pItem, panPos, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveItemAtPositionsCS(pItem, panPos, pCaseSensitive)
			This.RemoveThisItemAtPositionsCS(pItem, panPos, pCaseSensitive)

			def RemoveItemAtPositionsCSQ(pItem, panPos, pCaseSensitive)
				return This.RemoveThisItemAtPositionsCSQ(pItem, panPos, pCaseSensitive)

		def RemoveThisAtPositionsCS(pItem, panPos, pCaseSensitive)
			This.RemoveThisItemAtPositionsCS(pItem, panPos, pCaseSensitive)

			def RemoveThisAtPositionsCSQ(pItem, panPos, pCaseSensitive)
				return This.RemoveThisItemAtPositionsCSQ(pItem, panPos, pCaseSensitive)

		#>

	def ThisItemAtPositionsRemovedCS(pItem, panPos, pCaseSensitive)
		_aResult_ = This.Copy().RemoveThisItemAtPositionsCSQ(pItem, panPos, pCaseSensitive).Content()
		return _aResult_

		def ItemAtPositionsRemovedCS(pItem, panPos, pCaseSensitive)
			return This.ThisItemAtPositionsRemovedCS(pItem, panPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisItemAtPositions(pItem, panPos)
		This.RemoveThisItemAtPositionsCS(pItem, panPos, _TRUE_)

		#< @FunctionFluentForm

		def RemoveThisItemAtPositionsQ(pItem, panPos)
			This.RemoveThisItemAtPositions(pItem, panPos)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveThisAtPositions(pItem, panPos)
			This.RemoveThisItemAtPositions(pItem, panPos)

			def RemoveThisAtPositionsQ(pItem, panPos)
				return This.RemoveThisItemAtPositionsQ(pItem, panPos)

		#>

	def ThisItemAtPositionsRemoved(pItem, panPos)
		_aResult_ = This.Copy().RemoveThisItemAtPositionsQ(pItem, panPos).Content()
		return _aResult_

	  #-----------------------------------------------#
	 #  REMOVING THE GiVEN ITEMS AT GIVEN POSITIONS  #
	#-----------------------------------------------#

	def RemoveTheseItemsAtPositionsCS(paItems, panPos, pCaseSensitive)

		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
		ok

		_oCopy_ = This.Copy()
		_anPos_ = @Intersection([ This.FindManyCS(paItems, pCaseSensitive), panPos ])
		_oCopy_.RemoveAtPositions(_anPos_)

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveTheseItemsAtPositionsCSQ(paItems, panPos, pCaseSensitive)
			This.RemoveTheseItemsAtPositionsCS(paItems, panPos, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveItemsAtPositionsCS(paItems, panPos, pCaseSensitive)
			This.RemoveTheseItemsAtPositionsCS(paItems, panPos, pCaseSensitive)

			def RemoveItemsAtPositionsCSQ(paItems, panPos, pCaseSensitive)
				return This.RemoveTheseItemsAtPositionsCSQ(paItems, panPos, pCaseSensitive)

		def RemoveTheseAtPositionsCS(paItems, panPos, pCaseSensitive)
			This.RemoveTheseItemsAtPositionsCS(paItems, panPos, pCaseSensitive)

			def RemoveTheseAtPositionsCSQ(paItems, panPos, pCaseSensitive)
				return This.RemoveTheseItemsAtPositionsCSQ(pItem, panPos, pCaseSensitive)

		def RemoveTheseItemsAtCS(paItems, panPos, pCaseSensitive)
			This.RemoveTheseItemsAtPositionsCS(paItems, panPos, pCaseSensitive)

			def RemoveTheseItemsAtCSQ(paItems, panPos, pCaseSensitive)
				return This.RemoveTheseItemsAtPositionsCSQ(pItem, panPos, pCaseSensitive)

		#>

	def TheseItemsAtPositionsRemovedCS(paItems, panPos, pCaseSensitive)
		_aResult_ = This.Copy().RemoveTheseItemsAtPositionsCSQ(paItems, panPos, pCaseSensitive).Content()
		return _aResult_

		def ItemsAtPositionsRemovedCS(paItems, panPos, pCaseSensitive)
			return This.TheseItemsAtPositionsRemovedCS(paItems, panPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseItemsAtPositions(paItems, panPos)
		This.RemoveTheseItemsAtPositionsCS(paItems, panPos, _TRUE_)

		#< @FunctionFluentForm

		def RemoveTheseItemsAtPositionsQ(paItems, panPos)
			This.RemoveTheseItemsAtPositions(paItems, panPos)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveTheseAtPositions(paItems, panPos)
			This.RemoveTheseItemsAtPositions(paItems, panPos)

			def RemoveTheseAtPositionsQ(paItems, panPos)
				return This.RemoveTheseItemsAtPositionsQ(paItems, panPos)

		def RemoveTheseItemsAt(paItems, panPos)
			This.RemoveTheseItemsAtPositions(paItems, panPos)

			def RemoveTheseItemsAtQ(paItems, panPos)
				return This.RemoveTheseItemsAtPositionsQ(pItem, panPos)

		#>

	def TheseItemsAtPositionsRemoved(paItems, panPos)
		_aResult_ = This.Copy().RemoveTheseItemsAtPositionsQ(paItems, panPos).Content()
		return _aResult_

	  #--------------------------------------#
	 #  REMOVING A GIVEN NTH ITEM (IF ANY)  #
	#--------------------------------------#

	def RemoveThisNthItemCS(n, pItem, pCaseSensitive)
		NthItem = This.NthItem(n)
		bItemExists = _FALSE_

		if isString( pItem )
			if Q(NthItem).IsEqualToCS(pItem, pCaseSensitive)
				bItemExists = _TRUE_
			ok

		else
			if Q(NthItem).IsEqualTo(pItem)
				bItemExists = _TRUE_
			ok
		ok

		if bItemExists
			This.RemoveNthItem(n)
		ok

		def RemoveThisNthItemCSQ(n, pItem, pCaseSensitive)
			This.RemoveThisNthItemCS(n, pItem, pCaseSensitive)
			return This

	def ThisNthItemRemovedCS(n, pItem, pCaseSensitive)
		return This.RemoveThisNthItemCSQ(n, pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthItem(n, pItem)
		This.RemoveThisNthItemCS(n, pItem, _TRUE_)
			
		def RemoveThisNthItemQ(n, pItem)
			This.RemoveThisNthItemCS(n, pItem)
			return This

	def ThisNthItemRemoved(n, pItem)
		return This.RemoveThisNthItemQ(n, pItem).Content()

	  #------------------------------------------------------#
	 #  REMOVING THE GIVEN FIRST ITEM (IA ANY) IN THE LIST  #
	#------------------------------------------------------#

	def RemoveThisFirstItemCS(pItem, pCaseSensitive)
		This.RemoveThisNthItemCS(1, pItem, pCaseSensitive)

		def RemoveThisFirstItemCSQ(pItem, pCaseSensitive)
			This.RemoveThisFirstItemCS(pItem, pCaseSensitive)
			return This

	def ThisFirstItemRemovedCS(pItem, pCaseSensitive)
		return This.Copy().RemoveThisFirstItemCSQ(pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstItem(pItem)
		This.RemoveThisNthItemCS(1, pItem, _TRUE_)

		def RemoveThisFirstItemQ(pItem)
			This.RemoveThisFirstItem(pItem)
			return This

	def ThisFirstItemRemoved(pItem)
		return This.Copy().RemoveThisFirstItemQ(pItem, pCaseSensitive).Content()

	  #-----------------------------------------------------#
	 #  REMOVING THE GIVEN LAST ITEM (IA ANY) IN THE LIST  #
	#-----------------------------------------------------#

	def RemoveThisLastItemCS(pItem, pCaseSensitive)
		This.RemoveThisNthItemCS(This.NumberOfItems(), pItem, pCaseSensitive)

		def RemoveThisLastItemCSQ(pItem, pCaseSensitive)
			This.RemoveThisLastItemCS(pItem, pCaseSensitive)
			return This

	def ThisLastItemRemovedCS(pItem, pCaseSensitive)
		return This.Copy().RemoveThisLastItemCSQ(pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastItem(pItem)
		This.RemoveThisNthItemCS(1, pItem, _TRUE_)

		def RemoveThisLastItemQ(pItem)
			This.RemoveThisLastItem(pItem)
			return This

	def ThisLastItemRemoved(pItem)
		return This.Copy().RemoveThisLastItemQ(pItem, pCaseSensitive).Content()

	  #=====================================================#
	 #  REMOVING MANY ITEMS BY SPECIFYING THEIR POSITIONS  #
	#=====================================================#

	def RemoveItemsAtPositions(panPos)

		_anPos_ = panPos

		# Early chekcs

		_nLenPos_ = len(_anPos_)
		if _nLenPos_ = 0
			return
		ok

		_aContent_ = This.Content()
		if len(_aContent_) = 0
			return
		ok

		# Checking params

		if CheckingParams()

			if NOT isList(_anPos_)
				StzRaise("Incorrect pram! panPos must be a list.")
			ok
	
			for @i = 1 to _nLenPos_
				if isString(_anPos_[@i])
					if _anPos_[@i] = :First or _anPos_[@i] = :FirstPosition
						_anPos_[@i] = 1
	
					but _anPos_[@i] = :Last or _anPos_[@i] = :LastPosition
						_anPos_[@i] = This.NumberOfItems()
					ok
				ok
			next

		ok

		# Doing the job

		_anPosSorted_ = ring_sort(_anPos_)
		_aContent_ = This.Content()

		for @i = _nLenPos_ to 1 step -1
			ring_remove(_aContent_, _anPosSorted_[@i])
		next

		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def RemoveItemsAtPositionsQ(panPos)
			This.RemoveItemsAtPositions(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveItemsAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		#--

		def RemoveItemsAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveItemsAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		#>
		
	def ItemsAtThesePositionsRemoved(panPos)
		aResult = This.Copy().RemoveItemsAtThesePositionsQ(panPos).Content()
		return aResult

		def ItemsAtPositionsRemoved(panPos)
			return This.ItemsAtThesePositionsRemoved(panPos)

	  #-------------------------------------------#
	 #  RANDOMLY REMOVING N ITEMS FROM THE LIST  #
	#-------------------------------------------#

	def rndRemoveNItems(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		_anPos_ = NRandomNumbersIn(n, 1:This.NumberOfItems())
		This.RemoveItemsAtPositions(_anPos_)

		#< @FunctionFluentForm

		def rndRemoveNItemsQ(n)
			This.rndRemoveNItems(n)
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomlyRemoveNItems(n)
			This.rndRemoveNItems(n)

			def RandomlyRemoveNItemsQ(n)
				return This.rndRemoveNItemsQ(n)

		def RemoveNItemsRandomly(n)
			This.rndRemoveNItems(n)

			def RemoveNItemsRandomlyQ(n)
				return This.rndRemoveNItemsQ(n)

		#>

	#-- @functionPassiveForm

	def rndNItemsRemoved(n)
		_aResult_ = This.Copy().rndRemoveNItemsQ(n).Content()
		return _aResult_

		def NItemsRemovedRandomly(n)
			return This.rndNItemsRemoved(n)

		def NITemsRandomlyRemoved(n)
			return This.rndNItemsRemoved(n)

	  #-------------------------------#
	 #   REMOVING A RANGE OF ITEMS   #
	#-------------------------------#

	def RemoveRange(pnStart, pnRange)
	
		# Checking the correctness of the pnStart param

		if isList(pnStart) and Q(pnStart).IsFromNamedParam()
			pnStart = pnStart[2]
		ok

		if isString(pnStart)

			if ring_find([
					:First, :FirstPosition,
				      	:FirstItem, :FirstItem ], pnStart) > 0
				  
				pnStart = 1

			but ring_find([
					:Last, :LastPosition,
				      	:LastItem, :LastItem ], pnStart) > 0

				n = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStart)
			StzRaise("Incorrect param! n must be a number.")
		ok

		# Checking the correctness of the pnRange param

		if isList(pnRange) and
		   isString(pnRange[1]) and

		   ring_find([ :UpToN, :UpToNItems, :UpToNItems ], pnRange[1]) > 0

		   	pnRange = pnRange[2]
		ok
	
		if NOT isNumber(pnRange)
			StzRaise("Incorrect param type! pnRange must be a number.")
		ok

		# Doing the job

		This.RemoveSection( pnStart, (pnStart + pnRange - 1) )

		#< @FunctionFluentForm

		def RemoveRangeQ(pnStart, pnRange)
			This.RemoveRange(pnStart, pnRange)
			return This
		#>

	def RangeRemoved(pnStart, pnRange)
		aResult = This.Copy().RemoveRangeQ(pnStart, pnRange).Content()
		return aResult

	  #-----------------------------------#
	 #   REMOVING MANY RANGES OF ITEMS   #
	#-----------------------------------#

	def RemoveManyRanges(panRanges)

		anSections = []
		for anRange in panRanges
			anSections + @RangeToSection(anRange[1], anRange[2])
		next

		This.RemoveManySections(anSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManyRanges(paRanges)
			return This

	def ManyRangesRemoved(paRanges)
		aResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return aResult

	  #---------------------------------#
	 #   REMOVING A SECTION OF ITEMS   #
	#---------------------------------#

	def RemoveSection(n1, n2)

		nLen = len(@aContent)

		# Checking params correctness

		if CheckingParams() = _TRUE_
			if isList(n1) and
				( Q(n1).IsFromNamedParam() or Q(n1).IsFromNamedParam()  or
				  Q(n1).IsFromPositionNamedParam() )
	
				n1 = n1[2]
			ok
	
			if isList(n2) and ( Q(n2).IsToNamedParam() or Q(n2).IsToPositionNamedParam() )
				n2 = n2[2]
			ok
	
			if isString(n1) and
				ring_find([
					:First, :FirstPosition,
					:FirstItem, :FirstItem ], n1) > 0
	
				n1 = 1
			ok
	
			if isString(n2) and
				ring_find([
					:Last, :LastPosition,
					:LastItem, :LastItem ], n2) > 0
	 
				n2 = This.NumberOfItems()
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

			if (n1 < 1 or n1 > nLen)
				StzRaise("Incorrect param value! n1 is out of range.")
			ok

			if (n2 < 1 or n2 > nLen)
				StzRaise("Incorrect param value! n2 is out of range.")
			ok

			if n2 < n1
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

		ok

		# Doing the job

		if EarlyCheck()
			if nLen = 0
				return
			ok
		
			if (n1 = 1 and n2 = nLen) or (n1 = nLen and n2 = 1)
				This.UpdateWith([])
				return
			ok
	
			if n1 = n2
				This.removeItemAtPosition(n1)
				return
			ok
		ok

		aContent = This.Content()
		aResult = []

		for i = 1 to n1 - 1
			aResult + aContent[i]
		next

		for i = n2 + 1 to nLen
			aResult + aContent[i]
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

		#>

	def SectionRemoved(n1, n2)
		aResult = This.Copy().RemoveSectionQ(n1, n2).Content()
		return aResult

	  #-------------------------------------#
	 #   REMOVING MANY SECTIONS OF ITEMS   #
	#-------------------------------------#

	def RemoveManySections(paSections)

		if isList(paSections)
			oSections = new stzList(paSections)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paSections = oSections.Content()
			
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzList > RemoveManySections(paSections)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paSections) is not a list of pairs of numbers."
			])

		ok

		nLen = len(paSections)
		if nLen = 0
			return
		ok

		# Merging any inclusive or overlapping sections

		aMerged = StzListOfSectionsQ(paSections).SortQ().Merged()
		nLen = len(aMerged)

		# Doing the job

		_oCopy_ = This.Copy()

		for i = nLen to 1 step -1
			_oCopy_.RemoveSection(aMerged[i][1], aMerged[i][2])
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveManySectionsQ(paSections)
			This.RemoveManySections(paSections)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSections(paSections)
			This.RemoveManySections(paSections)

			def RemoveSectionsQ(paSections)
				return This.RemoveManySectionsQ(paSections)

		#>

	def ManySectionsRemoved(paSections)
		aResult = This.Copy().RemoveManySectionsQ(paSections).Content()
		return aResult

		def SectionsRemoved(paSections)
			return This. ManySectionsRemoved(paSections)

	  #----------------------------------#
	 #   REMOVING ANY ITEM FROM START   #
	#==================================#

	def RemoveAnyItemFromStartCS(pItem, pCaseSensitive)

		aItems = This.Items()
		nLen = len(aItems)
		if nLen = 0
			return
		ok

		n = 0

		for i = 1 to nLen
			if Q(aItems[i]).IsEqualToCS(pItem, pCaseSensitive)
				n++
			else
				exit
			ok
		next i

		if n > 0
			This.RemoveSection( 1, n )
		ok


		def RemoveAnyItemFromStartCSQ(c, pCaseSensitive)
			This.RemoveAnyItemFromStartCS(c, pCaseSensitive)
			return This

	def AnyItemFromStartRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveAnyItemFromStartCSQ(c, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyItemFromStart(c)
		This.RemoveAnyItemFromStartCS(c, _TRUE_)
		return This

		def RemoveAnyItemFromStartQ(c)
			This.RemoveAnyItemFromStart(c)
			return This

	def AnyItemFromStartRemoved(c)
		return This.AnyItemFromStartRemovedCS(c, _TRUE_)

	  #---------------------------------#
	 #   REMOVING ANY ITEM FROM END    #
	#---------------------------------#

	def RemoveAnyItemFromEndCS(c, pCaseSensitive)

		aItems = This.Items()
		nLen = len(aItems)
		if nLen = 0
			return
		ok

		n = 0

		for i = nLen to 1 step -1
			if Q(aItems[i]).IsEqualToCS(c, pCaseSensitive)
				n++
			else
				exit
			ok
		next i

		if n > 0
			This.RemoveSection( nLen - n + 1, nLen )
		ok


		def RemoveAnyItemFromEndCSQ(c, pCaseSensitive)
			This.RemoveAnyItemFromEndCS(c, pCaseSensitive)
			return This

	def AnyItemFromEndRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveAnyItemFromEndCSQ(c, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyItemFromEnd(c)
		This.RemoveAnyItemFromEndCS(c, _TRUE_)
		return This

		def RemoveAnyItemFromEndQ(c)
			This.RemoveAnyItemFromEnd(c)
			return This

	def AnyItemFromEndRemoved(c)
		return This.AnyItemFromEndRemovedCS(c, _TRUE_)

	  #========================================#
	 #    SWAPPING TWO SECTIONS OF THE LIST   # 
	#========================================#

	def SwapSections( panSection1, panSection2 )
		if isList(panSection2) and Q(panSection2).IsWithOrAndNamedParams()
			panSection2 = panSection2[2]
		ok

		if NOT @BothArePairsOfNumbers(panSection1, panSection2)
			StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
		ok

		aSorted = QRT([ panSection1, panSection2 ], :stzListOfPairs).Sorted()

		anFirstSection = []
		anLastSection  = []

		if Q(aSorted[1]).IsEqualTo(panSection1)
			anFirstSection = panSection1
			anLastSection  = panSection2

		else
			anFirstSection = panSection2
			anLastSection  = panSection1
		ok

		aResult = ListsMerge([
			This.Section(anLastSection[1], anLastSection[2]),
			This.Section(anFirstSection[2] + 1, anLastSection[1] - 1),
			This.Section(anFirstSection[1], anFirstSection[2])
		])

		This.UpdateWith(aResult)


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2).Content()
		return cResult

	  #------------------------------------#
	 #   REMOVING ALL ITEMS IN THE LIST   #
	#------------------------------------#
	
	def RemoveAllItems()
		This.UpdateWith([])

		#< @FunctionFluentForm

		def RemoveAllItemsQ()
			This.RemoveAllItems()
			return This

		#>

		#< @FunctionAlternativeForm

		def Clear()
			This.RemoveAllItems()

			def ClearQ()
				This.Clear()
				return This

		#>

	def AllItemsRemoved()
		return []

	  #--------------------------------------------#
	 #   REMOVING ITEMS UNDER A GIVEN CONDITION   #
	#============================================#

	def RemoveWCS(pCondition, pCaseSensitive)
		/*
		Example:

		o1 = new stzList([ "1", "a", "2", "b", "3", "c" ])
		o1.RemoveItemsW(:Where = '{ StzCharQ(This[@i]).IsANumber() }')
		? o1.Content()

		#--> Gives: [ "a", "b", "c" ]
		*/

		# Checking the provided param for the pCondition

		anPos = This.FindWCS(pCondition, pCaseSensitive)
		This.RemoveItemsAtThesePositions(anPos)

		#< @FunctionFluentForm

		def RemoveWCSQ(pCondition, pCaseSensitive)
			This.RemoveWCS(pCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsWCS(pCondition, pCaseSensitive)
			This.RemoveWCS(pCondition, pCaseSensitive)

			def RemoveItemsWCSQ(pCondition, pCaseSensitive)
				return This.RemoveWCSQ(pCondition, pCaseSensitive)

		def RemoveItemWCS(pCondition, pCaseSensitive)
			This.RemoveWCS(pCondition, pCaseSensitive)

			def RemoveItemWCSQ(pCondition, pCaseSensitive)
				return This.RemoveWCSQ(pCondition, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ItemsRemovedWCS(pCondition, pCaseSensitive)
		aResult = This.Copy().RemoveItemsWCSQ(pCondition, pCaseSensitive).Content()
		return aResult

		def ItemRemovedWCS(pCondition, pCaseSensitive)
			return This.ItemsRemovedWCS(pCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIviTY

	def RemoveW(pCondition)
		This.RemoveWCS(pCondition, _TRUE_)

		#< @FunctionFluentForm

		def RemoveWQ(pCondition)
			This.RemoveW(pCondition)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsW(pCondition)
			This.RemoveW(pCondition)

			def RemoveItemsWQ(pCondition)
				return This.RemoveWQ(pCondition)

		def RemoveItemW(pCondition)
			This.RemoveW(pCondition)

			def RemoveItemWQ(pCondition)
				return This.RemoveWQ(pCondition)

		#>

	#-- @FunctionPassiveForm

	def ItemsRemovedW(pCondition)
		aResult = This.Copy().RemoveItemsWQ(pCondition).Content()
		return aResult

		def ItemRemovedW(pCondition)
			return This.ItemsRemovedW(pCondition)

	  #------------------------------------------------------------#
	 #   REMOVING ITEMS UNDER A GIVEN CONDITION -- WXT/EXTENDED   #
	#------------------------------------------------------------#

	def RemoveWCSXT(pCondition, pCaseSensitive)
		/*
		Example:

		o1 = new stzList([ "1", "a", "2", "b", "3", "c" ])
		o1.RemoveItemsWXT(:Where = '{ StzCharQ(@item).IsANumber() }')
		? o1.Content()

		#--> Gives: [ "a", "b", "c" ]
		*/

		# Checking the provided param for the pCondition

		anPos = This.FindWCSXT(pCondition, pCaseSensitive)
		This.RemoveItemsAtThesePositions(anPos)

		#< @FunctionFluentForm

		def RemoveWCSXTQ(pCondition, pCaseSensitive)
			This.RemoveWCSXT(pCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsWCSXT(pCondition, pCaseSensitive)
			This.RemoveWCSXT(pCondition, pCaseSensitive)

			def RemoveItemsWCSXTQ(pCondition, pCaseSensitive)
				return This.RemoveWCSXTQ(pCondition, pCaseSensitive)

		def RemoveItemWCSXT(pCondition, pCaseSensitive)
			This.RemoveWCSXT(pCondition, pCaseSensitive)

			def RemoveItemWCSXTQ(pCondition, pCaseSensitive)
				return This.RemoveWCSXTQ(pCondition, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ItemsRemovedWCSXT(pCondition, pCaseSensitive)
		aResult = This.Copy().RemoveItemsWCSXTQ(pCondition, pCaseSensitive).Content()
		return aResult

		def ItemRemovedWCSXT(pCondition, pCaseSensitive)
			return This.ItemsRemovedWCSXT(pCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIviTY

	def RemoveWXT(pCondition)
		This.RemoveWCSXT(pCondition, _TRUE_)

		#< @FunctionFluentForm

		def RemoveWXTQ(pCondition)
			This.RemoveWXT(pCondition)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsWXT(pCondition)
			This.RemoveWXT(pCondition)

			def RemoveItemsWXTQ(pCondition)
				return This.RemoveWXTQ(pCondition)

		def RemoveItemWXT(pCondition)
			This.RemoveWXT(pCondition)

			def RemoveItemWXTQ(pCondition)
				return This.RemoveWXTQ(pCondition)

		#>

	#-- @FunctionPassiveForm

	def ItemsRemovedWXT(pCondition)
		aResult = This.Copy().RemoveItemsWXTQ(pCondition).Content()
		return aResult

		def ItemRemovedWXT(pCondition)
			return This.ItemsRemovedWXT(pCondition)

	  #====================================#
	 #  EXTRACTING AN ITEM FROM THE LIST  #
	#====================================#

	def ExtractCS(pItem, pCaseSensitive)
		if NOT This.ContainsCS(pItem, pCaseSensitive)
			StzRaise("Can't extract the item! It does not exist in the list.")
		ok

		This.RemoveCS(pItem, pCaseSensitive)
		return pItem

		def PopCS(pItem, pCaseSensitive)
			return This.ExtractCS(pItem, pCaseSensitive)

	def ItemExtractedCS(pItem, pCaseSensitive)
		return This.ExtractCS(pItem, pCaseSensitive)

		def ItemPoppedCS(pItem, pCaseSensitive)
			return This.ItemExtractedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Extract(pItem)
		return This.ExtractCS(pItem, _TRUE_)

		def Pop(pItem)
			return This.Extract(pItem)

	def ItemExtracted(pItem)
		return This.Extract(pItem)

		def ItemPopped(pItem)
			return This.ItemExtracted(pItem)

	  #---------------------------------------#
	 #  EXTRACTING MANY ITEMS FROM THE LIST  #
	#---------------------------------------#

	def ExtractManyCS(paItems, pCaseSensitive)
		anPos = This.FindManyCS(paItems, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)
		return paItems

		#< @FunctionAlternativeForms

		def PopManyCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#--

		def ExtractTheseCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		def PopTheseCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#>

	def ManyItemsExtractedCS(paItems, pCaseSensitive)
		return This.ExtractManyCS(paItems, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ManySubStringsPoppedCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		def TheseSubStringsExtractedCS(paItems, pCaseSensitive)
			return This.ManySubStringsExtractedCS(paItems, pCaseSensitive)

		def TheseSubStringsPoppedCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(paItems)
		return This.ExtractManyCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def PopMany(paItems)
			return This.ExtractMany(paItems)

		#--

		def ExtractThese(paItems)
			return This.ExtractMany(paItems)

		def PopThese(paItems)
			return This.ExtractMany(paItems)

		#>

	def ManyItemsExtracted(paItems)
		return This.ExtractMany(paItems)

		#< @FunctionAlternativeForms

		def ManySubStringsPopped(paItems)
			return This.ExtractMany(paItems)

		def TheseSubStringsExtracted(paItems)
			return This.ManySubStringsExtracted(paItems)

		def TheseSubStringsPopped(paItems)
			return This.ExtractMany(paItems)

		#>

	  #------------------------------------------#
	 #  EXTRACTING ALL THE ITEMS FROM THE LIST  #
	#------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

		#< @FunctionAlternativeForms

		def ExtractList()
			return This.ExtractAll()

		def ExtractAllList()
			return This.ExtractAll()

		#--

		def PopAll()
			return This.ExtractAll()

		def PopList()
			return This.ExtractAll()

		def PopAllList()
			return This.ExtractAll()

		#>

	def AllItemsExtracted()
		return This.ExtractAll()

		#< @FunctionAlternativeForms

		def ListExtracted()
			return This.ExtractAll()

		def AllListExtracted()
			return This.ExtractAll()

		#--

		def AllItemsPopped()
			return This.ExtractAll()

		def ListPopped()
			return This.ExtractAll()

		def AllListPopped()
			return This.ExtractAll()
		#>

	  #---------------------------#
	 #  EXTRACTING THE NTH ITEM  #
	#---------------------------#

	def ExtractAt(n)
		TempItem = This.ItemAt(n)
		This.RemoveAt(n)

		return TempItem

		#< @FunctionAlternativeForms

		def ExtractNthItem(n)
			return This.ExtractAt(n)

		def ExtractItemAtPosition(n)
			return This.ExtractAt(n)

		def ExtractItemAt(n)
			return This.ExtractAt(n)

		#--

		def PopAt(n)
			return This.ExtractAt(n)

		def PopNthItem(n)
			return This.ExtractAt(n)

		def PopItemAtPosition(n)
			return This.ExtractAt(n)

		def PopItemAt(n)
			return This.ExtractAt(n)

		#>

	def NthItemExtracted(n)
		return This.ExtractAt(n)

		def NthItemPopped(n)
			return This.ExtractAt(n)

		def ExtractedAt(n)
			return This.ExtractAt(n)

		def PoppedAt(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST ITEM  #
	#-----------------------------#

	def ExtractFirstItem()
		return This.ExtractAt(1)
 
		def PopFirstItem()
			return This.ExtractFirstItem()

	def FirstItemExtracted()
		return This.ExtractFirstItem()

		def FirstItemPopped()
			return This.ExtractFirstItem()

		#-- MISSPELLED

		def FristItemExtracted()
			return This.FirstItemExtracted()

		def FristItemPopped()
			return This.ExtractFirstItem()

	  #----------------------------#
	 #  EXTRACTING THE LAST ITEM  #
	#----------------------------#

	def ExtractLastItem()
		return This.ExtractAt(This.NumberOfItems())

		#TODO // The line above was:

		# return This.ExtractAt(:Last)

		# but since CheckParams() is used in ExtractAt(),
		# the special value :Last will not be recognosed.
		# That's why I changed it to its actual value NumberOfItems()
		#--> Do the same all over the library!

		#UPDATE // I remove the use of :First and :Last as
		# params values all over the library.
		# ~> They are intended to final users (programmers) and
		# not for the library codebase!

		def PopLastItem()
			return This.ExtractLastItem()

	def LastItemExtracted()
		return This.ExtractLastItem()

		def LastItemPopped()
			return This.ExtractLastItem()

	  #--------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF AN ITEM  #
	#--------------------------------------------#

	def ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		nPos = This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		This.RemoveItemAtPosition(nPos)
		return pItem

		#< @FunctionAlternativeFroms

		def ExtractNthCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def PopNthCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def PopNthOccurrenceCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		#>

	def NthOccurrenceExtractedCS(n, pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthOccurrencePoppedCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pItem)
		return This.ExtractNthOccurrenceCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeFroms

		def ExtractNth(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		def PopNth(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		def PopNthOccurrence(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		#>

	def NthOccurrenceExtracted(n, pItem)
		return This.ExtractNthOccurrence(n, pItem)

		def NthOccurrencePopped(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

	  #----------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF AN ITEM  #
	#----------------------------------------------#

	def ExtractFirstCS(pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pItem, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopFirstCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def ExtractFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ExtractFristCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFristCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def ExtractFristOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFristOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#>

	def FirstOccurrenceExtractedCS(pItem, pCaseSensitive)
		return This.ExtractFirstCS(pItem, pCaseSensitive)

		def FirstOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceExtractedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceExtractedCS(pItem, pCaseSensitive)

		def FristOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pItem)
		return This.ExtractFirstCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def PopFirst(pItem)
			return This.ExtractFirst(pItem)

		def ExtractFirstOccurrence(pItem)
			return This.ExtractFirst(pItem)

		def PopFirstOccurrence(pItem)
			return This.ExtractFirst(pItem)

		#>

		#< @FunctionMisspelledForms

		def ExtractFrist(pItem)
			return This.ExtractFirst(pItem)

		def PopFrist(pItem)
			return This.ExtractFirst(pItem)

		def ExtractFristOccurrence(pItem)
			return This.ExtractFirst(pItem)

		def PopFristOccurrence(pItem)
			return This.ExtractFirst(pItem)

		#>

	def FirstOccurrenceExtracted(pItem)
		return This.ExtractFirst(pItem)

		def FirstOccurrencePopped(pItem)
			return This.ExtractFirst(pItem)

		#-- MISSPELLED

		def FristOccurrenceExtracted(pItem)
			return This.FirstOccurrenceExtracted(pItem)

		def FristOccurrencePopped(pItem)
			return This.ExtractFirst(pItem)

	  #---------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF AN ITEM  #
	#---------------------------------------------#

	def ExtractLastCS(pItem, pCaseSensitive)
		nLast = This.NumberOfOccurrencesCS(pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(nLast, pItem, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopLastCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		def ExtractLastOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		def PopLastOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		#>

	def LastOccurrenceExtractedCS(pItem, pCaseSensitive)
		return This.ExtractLastCS(pItem, pCaseSensitive)

		def LastOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pItem)
		return This.ExtractLastCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def PopLast(pItem)
			return This.ExtractLast(pItem)

		def ExtractLastOccurrence(pItem)
			return This.ExtractLast(pItem)

		def PopLastOccurrence(pItem)
			return This.ExtractLast(pItem)

		#>

	def LastOccurrenceExtracted(pItem)
		return This.ExtractLast(pItem)

		def LastOccurrencePopped(pItem)
			return This.ExtractLast(pItem)

	  #------------------------------------------------#
	 #  EXTRACTING ITEMS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------#

	def ExtractW(pcCondition)
		anPos = This.FindW(pccondition)
		aResult = This.ItemsAtPositions(anPos)
		This.RemoveItemsAtPositions(anPos)
		return aResult

		def PopW(pcCondition)
			return This.ExtractW(pcCondition)

	def ItemsExtractedW(pcCondition)
		return This.ExtractW(pcCondition)

		def ItemsPoppedW(pcCondition)
			return This.ItemsExtractedW(pcCondition)

	#-- eXTendForm

	def ExtractWXT(pcCondition)

		anPos = This.FindWXT(pccondition)
		aResult = This.ItemsAtPositions(anPos)
		This.RemoveItemsAtPositions(anPos)
		return aResult

		def PopWXT(pcCondition)
			return This.ExtractWXT(pcCondition)

	def ItemsExtractedWXT(pcCondition)
		return This.ExtractWXT(pcCondition)

		def ItemsPoppedWXT(pcCondition)
			return This.ItemsExtractedWXT(pcCondition)

	  #--------------------------------------#
	 #  EXTRACTING A SECTION FROM THE LIST  #
	#--------------------------------------#

	def ExtractSection(n1, n2)

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def PopSection(n1, n2)
			return This.ExtractSection(n1, n2)

		#>

	def SectionExtracted(n1, n2)
		return This.ExtractSection(n1, n2)

		#< @FunctionAlternativeForm

		def SectionPopped(n1, n2)
			return This.SectionExtracted(n1, n2)

		#>

	  #------------------------------------#
	 #  EXTRACTING A RANGE FROM THE LIST  #
	#------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

		def PopRange(nStart, nRange)
			return This.ExtractRange(nStart, nRange)

	def RangeExtracted(nStart, nRange)
		return This.ExtractRange(nStart, nRange)

		def RangePopped(nStart, nRange)
			return This.RangeExtracted(nStart, nRange)

	  #-----------------------------------------------------#
	 #  EXTRACTING NEXT ITEM STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------#

	def ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

		nPos = This.FindNextSTCS(pItem, pnStartingAt, pCaseSensitive)
		if nPos = 0
			return
		ok

		This.RemoveItemAtPosition(nPos)
		return pItem

		#< @FunctionFluentForm

		def ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtractNextCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractNextCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def ExtractNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopNextSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		#--

		def ExtractNextOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractNextOccurrenceSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopNextOccurrenceSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractNextSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def NextOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)
		return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def NextExtractedCS(pItem, pnStartedAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def NextOccurrenceExtractedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def NextOccurrenceExtractedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)

		def NextExtractedSTCS(pItem, pnStartedAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
		
		def NextOccurrencePoppedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractNextST(item, pnStartingAt)
		return This.ExtractNextSTCS(item, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ExtractNextSTQ(pItem, pnStartingAt)
			This.ExtractNextST(pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtractNext(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def ExtractNextQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		def ExtractNextOccurrence(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def ExtractNextOccurrenceQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		def PopNextST(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def PopNextSTQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		def PopNextOccurrence(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def PopNextOccurrenceQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		#--

		def ExtractNextOccurrenceST(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def ExtractNextOccurrenceSTQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		def PopNextOccurrenceST(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

			def PopNextOccurrenceSTQ(pItem, pnStartingAt)
				return This.ExtractNextSTQ(pItem, pnStartingAt)

		#>

	#-- @FunctionPassiveForms

	def NextOccurrenceExtracted(pItem, pnStartingAt)
		return This.ExtractNextS(pItem, pnStartingAt)

		#< @FunctionAlternativeForms

		def NextExtracted(pItem, pnStartedAt)
			return This.ExtractNextST(pItem, pnStartingAt)
	
		def NextOccurrenceExtractedS(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)
	
		def NextOccurrencePopped(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)
	
		def NextOccurrencePoppedS(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)

		#--

		def NextOccurrenceExtractedST(pItem, pnStartingAt)
			return This.NextOccurrenceExtracted(pItem, pnStartingAt)

		def NextExtractedST(pItem, pnStartedAt)
			return This.ExtractNextST(pItem, pnStartingAt)
		
		def NextOccurrencePoppedST(pItem, pnStartingAt)
			return This.ExtractNextST(pItem, pnStartingAt)
	
		#>

	  #---------------------------------------------------------#
	 #  EXTRACTING PREVIOUS ITEM STARTING AT A GIVEN POSITION  #
	#---------------------------------------------------------#

	def ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

		nPos = This.FindPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
		if nPos = 0
			return
		ok

		This.RemoveItemAtPosition(nPos)
		return pItem

		#< @FunctionFluentForm

		def ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractPreviousCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def ExtractPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractPreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopPreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		#--

		def ExtractPreviousOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def ExtractPreviousOccurrenceSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

			def PopPreviousOccurrenceSTCSQ(pItem, pnStartingAt, pCaseSensitive)
				return This.ExtractPreviousSTCSQ(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def PreviousOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)
		return This.ExtractPreviousSCS(pItem, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PreviousExtractedCS(pItem, pnStartedAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrenceExtractedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def PreviousOccurrenceExtractedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)

		def PreviousExtractedSTCS(pItem, pnStartedAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
		
		def PreviousOccurrencePoppedSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pItem, pnStartingAt, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractPreviousST(item, pnStartingAt)
		return This.ExtractPreviousSTCS(item, pnStartingAt, _TRUE_)

		#< @FunctionFluentForm

		def ExtractPreviousSTQ(pItem, pnStartingAt)
			This.ExtractPreviousST(pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtractPrevious(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def ExtractPreviousQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		def ExtractPreviousOccurrence(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def ExtractPreviousOccurrenceQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		def PopPreviousST(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def PopPreviousSTQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		def PopPreviousOccurrence(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def PopPreviousOccurrenceQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		#--

		def ExtractPreviousOccurrenceST(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def ExtractPreviousOccurrenceSTQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		def PopPreviousOccurrenceST(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

			def PopPreviousOccurrenceSTQ(pItem, pnStartingAt)
				return This.ExtractPreviousSTQ(pItem, pnStartingAt)

		#>

	#-- @FunctionPassiveForms

	def PreviousOccurrenceExtracted(pItem, pnStartingAt)
		return This.ExtractPreviousS(pItem, pnStartingAt)

		#< @FunctionAlternativeForms

		def PreviousExtracted(pItem, pnStartedAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)
	
		def PreviousOccurrenceExtractedS(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)
	
		def PreviousOccurrencePopped(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)
	
		def PreviousOccurrencePoppedS(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)

		#--

		def PreviousOccurrenceExtractedST(pItem, pnStartingAt)
			return This.PreviousOccurrenceExtracted(pItem, pnStartingAt)

		def PreviousExtractedST(pItem, pnStartedAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)
		
		def PreviousOccurrencePoppedST(pItem, pnStartingAt)
			return This.ExtractPreviousST(pItem, pnStartingAt)
	
		#>

	  #===================================================================================#
	 #  CHECKING IF THE 2 ITEMS OF THE LIST ARE BOUNDS OF A SUBSTRING IN A GIVEN STRING  #
	#===================================================================================#

	#TODO // Unify the bounds functions in stzString and stzList

	def AreBoundsOfCS(pcSubStr, pIn, pCaseSensitive)
		# Supports only strings in pIn
		#TODO // lists will be also supported

		/* EXAMPLE 1

		o1 = new stzList([ "<<", ">>" ])
		? o1.AreBoundsOf("word", :In = "<<word>> and __word__")
		#--> _TRUE_

		EXAMPLE 2

		o1 = new stzList([ [ "<<", ">>" ], [ "__", "__" ] ])
		? o1.AreBoundsOf("word", :In = "<<word>> and __word__")
		#--> _TRUE_

		*/

		# Checking the params

		if CheckingParams() = _TRUE_

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if NOT ( This.IsPair() or This.IsListOfPairs() )
				StzRaise("Can't check bounds! List must be a pair or a list of pairs.")
			ok
	
			if isList(pIn) and Q(pIn).IsInNamedParam()
				pIn = pIn[2]
			ok
	
			if NOT isString(pIn)
				StzRaise("Incorrect param type! pIn must be a string.")
			ok

		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		oSubStr = new stzString(pcSubStr)
		bResult = _FALSE_

		if This.IsListOfPairs()
			bResult = _TRUE_

			for i = 1 to nLen
				bResult = oSubStr.IsBoundedByIn(aContent[i], pIn)
				if bResult = _FALSE_
					exit
				ok
			next
		else
			bResult = oSubStr.IsBoundedByIn(aContent, pIn)
		ok

		return bResult

		def AreBoundsOfCSXT(pItem, pIn, pCaseSensitive)
			return This.AreBoundsOfCS(pItem, pIn, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AreBoundsOf(pItem, pIn)
		return This.AreBoundsOfCS(pItem, pIn, _TRUE_)

		def AreBoundsOfXT(pItem, pIn)
			return This.AreBoundsOf(pItem, pIn)

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST IS BOUNDED BY THE GIVEN TWO ITEMS  #
	#----------------------------------------------------------#

	def IsBoundedByCS(paBounds, pCaseSensitive)
		if isList(paBounds) and Q(paBounds).IsPair()
			pItem1 = paBounds[1]
			pItem2 = paBounds[2]

		else
			pItem1 = paBounds
			pItem2 = paBounds
		ok
	
		if This.FirstItemQ().IsEqualToCS(pItem1, pCaseSensitive) and
		   This.LastItemQ().IsEqualToCS(pItem2, pCaseSensitive)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedBy(paBounds)
		return This.IsBoundedByCS(paBounds, _TRUE_)

	  #--------------------------------------------#
	 #  GETTING BOUNDS OF THE LIST UP TO N ITEMS  #
	#--------------------------------------------#

	def BoundsUpToNItems(n)

		aFirst = This.NFirstItems(n)
		aLast  = This.NLastItems(n)

		if len(aFirst) = 1
			aFirst = aFirst[1]
		ok

		if len(aLast) = 1
			aLast = aLast[1]
		ok

		aResult = [ aFirst, aLast ]

		return aResult

		#< @FunctionFluentForm
	
		def BoundsUpToNItemsQ(n)
			return new stzList( This.BoundsUpToNItems(n) )

		#>

	  #-----------------------------------------------#
	 #  GETTING THE N BOUNING ITEMS OF A GIVEN ITEM  #
	#-----------------------------------------------#

	def BoundsCS(pItem, pUpTo, pCaseSensitive)

		if CheckingParams()
			if isList(pItem) and StzListQ(pItem).isOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pUpTo) and StzListQ(pUpTo).IsUpToOrUptoNItemsNamedParam()
				pUpTo = pUpTo[2]
			ok
	
			if NOT ( isNumber(pUpTo) or @IsPairOfNumbers(pUpTo))
				StzRaise("Incorrect param type! pnUpTo must be a number or pair of numbers.")
			ok
		ok

		# Preparing the lenghts and bounds values

		nLenList = len(@aContent)

		anPos = This.FindCS(pItem, pCaseSensitive)
		nLenPos = len(anPos)

		if isNumber(pUpTo)
			nLenBound1 = pUpTo
			nLenBound2 = pUpTo
		else
			nLenBound1 = pUpTo[1]
			nLenBound2 = pUpTo[2]
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLenPos
			aBounds = []

			if anPos[i] - nLenBound1 > 0
				aBounds + This.Section(anPos[i] - nLenBound1, anPos[i] - 1)
			else
				aBounds + []
			ok

			if nLenList - anPos[i] >= nLenBound2
				aBounds + This.Section(anPos[i] + 1, anPos[i] + nLenBound2)
			else
				aBounds + []
			ok

			aResult + aBounds
		next

		return aResult

		#< @FunctionAlternativeForms

		def NBoundsCS(pItem, pUpTo)
			return This.BoundsCS(pItem, pUpTo, pCaseSensitive)

		def BoundsOfCS(pItem, pUpTo)
			return This.BoundsCS(pItem, pUpTo, pCaseSensitive)

		def NBoundsOfCS(pItem, pUpTo)
			return This.BoundsCS(pItem, pUpTo, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Bounds(pItem, pUpTo)
		return This.BoundsCS(pItem, pUpTo, _TRUE_)

		#< @FunctionAlternativeForms

		def NBounds(pItem, pUpTo)
			return This.Bounds(pItem, pUpTo)

		def BoundsOf(pItem, pUpTo)
			return This.Bounds(pItem, pUpTo)

		def NBoundsOf(pItem, pUpTo)
			return This.Bounds(pItem, pUpTo)

		#>

	  #-------------------------#
	 #     REMOVING BOUNDS     #
	#-------------------------#

	def RemoveTheseBoundsCS(pBound1, pBound2, pCaseSensitive)
		if This.IsBoundedByCS([ pBound1, pBound2], pCaseSensitive)
			This.RemoveFirstItem()
			This.RemoveLastItem()
		ok

		def RemoveTheseBoundsCSQ(pBound1, pBound2, pCaseSensitive)
			This.RemoveTheseBoundsCS(pBound1, pBound2, pCaseSensitive)
			return This

	def TheseBoundsRemovedCS(pBound1, pBound2, pCaseSensitive)

		aResult = This.Copy().RemoveTheseBoundsCSQ(pBound1, pBound2, pCaseSensitive).Content()
		return aResult

		/* WARNING: Subtle bug in Ring in Ring 1.18 (Show to Mahmoud)

		In the function above, if we write the expression that returns
		the result directly after the keyword 'return', like this:

		return This.Copy().RemoveTheseBoundsQ(pItem1, pItem2).Content()

		Then nothing is returned, altough the result should be a list!

		I don't know why this happens. But I found that the solution is
		to avoid writing any expression after return. Instead, let's always
		compute the result in a variable, and then return it (see code above).

		--> TODO: Check the occurrence this pattern all over the library!
		#UPDATE: This behaviour dissepeard in later Ring versions. So it's ok for now.

		*/
		
	#-- WIHTOUT CASESENSITIVITY

	def RemoveTheseBounds(pBound1, pBound2)
		This.RemoveTheseBoundsCS(pBound1, pBound2, _TRUE_)

		def RemoveTheseBoundsQ(pBound1, pBound2)
			This.RemoveTheseBounds(pBound1, pBound2)
			return This

	def TheseBoundsRemoved(pBound1, pBound2)

		aResult = This.Copy().RemoveTheseBoundsQ(pBound1, pBound2).Content()
		return aResult

	  #------------------------------#
	 #     REMOVING MANY BOUNDS     #
	#------------------------------#

	def RemoveManyBoundsCS(paPairsOfBounds, pCaseSensitive)
		nLen = len(paPairsOfBounds)
		for i = 1 to nLen
			This.RemoveTheseBoundsCS(paPairsOfBounds[i][1], paPairsOfBounds[i][2], pCaseSensitive)
		next

		def RemoveManyBoundsCSQ(paPairsOfBounds, pCaseSensitive)
			This.RemoveManyBoundsCS(paPairsOfBounds, pCaseSensitive)
			return This

	def ManyBoundsRemovedCS(paPairsOfBounds, pCaseSensitive)
		aResult = This.Copy().RemoveManyBoundsCSQ(paPairsOfBounds, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveManyBounds(paPairsOfBounds)
		This.RemoveManyBoundsCS(paPairsOfBounds, _TRUE_)

		def RemoveManyBoundsQ(paPairsOfBounds)
			This.RemoveManyBounds(paPairsOfBounds)
			return This

	def ManyBoundsRemoved(paPairsOfBounds)
		aResult = This.Copy().RemoveManyBoundsQ(paPairsOfBounds).Content()
		return aResult

	  #==================================#
	 #   REMOVING ZEROS FROM THE LIST   #
	#==================================#

	def RemoveZeros()
		This.RemoveItem(0)

		def RemoveZerosQ()
			This.RemoveZeros()
			return This

	def ZerosRemoved()
		aResult = This.Copy().RemoveZerosQ().Content()
		return aResult

	  #--------------------------------------#
	 #  CHECKING IF ALL THE ITEMS ARE _NULL_  #
	#--------------------------------------#

	def AllItemsAreNull()

		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT isString(@aContent[i])
				return _FALSE_
			ok
			if @aContent[i] != _NULL_
				return _FALSE_
			ok
		next

		return _TRUE_

	  #-------------------------------------#
	 #    CHECKINK LIST CHARACTERISTICS    #
	#-------------------------------------#

	def IsUniformCS(pCaseSensitive)
		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 2
			return _TRUE_
		ok

		if This.NumberOfOccurrenceCS(aContent[1], pCaseSensitive) = nLen
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfSameItemCS(pCaseSensitive)
			return This.IsUniformCS(pCaseSensitive)

		def ItemsAreSameCS(pCaseSensitive)
			return This.IsUniformCS(pCaseSensitive)

		#>

	def IsUniform()
		return This.IsUniformCS(_TRUE_)

		#< @FunctionAlternativeForms

		def IsMadeOfSameItem()
			return This.IsUniform()

		def ItemsAreSame()
			return This.IsUniform()

		#>

	#--

	def IsUnary()
		if This.NumberOfItems() = 1
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUnaryList()
			return This.IsUnary()

		def IsAUnaryList()
			return This.IsUnary()

	def IsEmpty()
		if This.NumberOfItems() = 0
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsEmptyList()
			return This.IsEmpty()

		def IsAnEmptyList()
			return This.IsEmpty()

	def IsDeepList()	// Contains at least an inner list
		If This.Depth() > 1
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsADeepList()
			return This.ISDeepList()

		def IsDeep()
			return This.ISDeepList()

	def IsHybridList()	// Contains items of different types
		if This.ContainsOnlyNumbers() or
		   This.ContainsOnlyStrings() or
		   This.ContainsOnlyLists() or
		   This.ContainsOnlyObjects()

			return _FALSE_
		else
			return _TRUE_
		ok

		def IsAHybridList()
			return This.IsHybridList()

	def IsPureList()	// Contains items of the same type
		if This.ContainsOnlyNumbers() or
		   This.ContainsOnlyStrings() or
		   This.ContainsOnlyLists() or
		   This.ContainsOnlyObjects()

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAPureList()
			return This.IsPureList()

	def IsOddList()
		oTempNumber = new stzNumber( This.NumberOfItems() )
		if oTempNumber.IsOdd()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAnOddList()
			return This.IsOddList()

	def IsEvenList()
		if NOT This.IsOddList()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAnEvenList()
			return This.IsEvenList()

	// TODO: Maybe we should design a stzListOfBits class...
	def IsListOfBits()
		if This.NumberOfItems() = 0
			return _FALSE_
		ok

		if This.IsListOfNumbers()
			for n in This.List()
				if NOT IsBit(n)
					return _FALSE_
				ok
			end
		ok

		return _TRUE_

		def IsAListOfBits()
			return This.IsListOfBits()

	def IsListOfZerosAndOnes()
		if This.NumberOfItems() = 0
			return _FALSE_
		ok

		return This.IsListOfBits()

		def IsAListOfZerosAndOnes()
			return This.IsListOfZerosAndOnes()

	def IsGrid()
		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 2
			return _FALSE_
		ok

		if NOT This.AllItemsAreLists()
			return _FALSE_
		ok

		nLen1 = len(aContent[1])
		bResult = _TRUE_

		for i = 2 to nLen
			if len(aContent[i]) != nLen1
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def IsAGrid()
			return This.IsGrid


	def IsHashList()
		/*
		A hash list is a grid of 2 vlines.

		The items of the 1st vline are all strings.
		And they are all unique (form a Set).

		When stzGrid class is fully tested we can use this code:	
		
		oTempGrid = new stzGrid( This.List() )
		bResult = _FALSE_

		if oTempGrid.NumberOfVLines() = 2

			aFirstVLine = oTempGrid.VLine(1)

			if @IsSet(aFirstVLine) and ListItemsAreAllStrings(aFirstVLine)
				bResult = _TRUE_
			ok
		ok
		return bResult
		*/

		# All items are list of 2 items, where the 1st beeing string
		#TODO // The strings in the 1st column (keys of the hashlist) must be unique

		bResult = _TRUE_
		aTempKeys = []

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isString(aContent[i][1]) )

				bResult = _FALSE_
				exit
			else
				if ring_find(aTempKeys, aContent[i][1]) > 0
					bResult = _FALSE_
					exit
				ok

				aTempKeys + aContent[i][1]
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAHashList()
			return This.IsHashList()

		def IsNotHashList()
			return NOT This.IsHashList()

		def IsNotAHashList()
			return This.IsHashList()
	
		#>


	def IsHashListOrListOfStrings()
		if This.IsListOfStrings() or This.IsHashList()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsListOfStringsOrHashList()
			return This.IsHashListOrListOfStrings()

	def IsListOfListsOfSameSize()

		_nLen_ = This.NumberOfItems()

		if _nLen_ = 0
			return _FALSE_
		ok

		_bResult_ = _FALSE_

		if This.AllItemsAreLists()

			_bSame_ = _TRUE_

			for @i = 2 to _nLen_
				if len(@aContent[@i]) != len(@aContent[@i-1])
					_bSame_ = _FALSE_
				ok
			next

			if _bSame_ = _TRUE_
				_bResult_ = _TRUE_
			ok
		ok

		return _bResult_

		#< @FunctionAlternativeForms

		def ItemsAreListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def ItemsAreAllListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def ContainsListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		#--

		def IsListOfListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def ItemsAreListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def ContainsListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		#=

		def ItemsAreListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ContainsListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		#--

		def IsListOfListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ItemsAreListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ContainsListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		#>

	  #----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HYBRID LISTS  #
	#====================================================#

	def IsListOfHybridLists()
		if NOT This.IsListOfLists()
			return _FALSE_
		ok

		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsHybridList(aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHybridLists()
			return This.IsListOfHybridLists()

		def ItemsAreHybridLists()
			return This.IsListOfHybridLists()

		def ItemsAreAllHybridLists()
			return This.IsListOfHybridLists()

		def AllItemsAreHybridLists()
			return This.IsListOfHybridLists()

		def ContainsOnlyHybridLists()
			return This.IsListOfHybridLists()

		def ContainsHybridListsOnly()
			return This.IsListOfHybridLists()

		def IsMadeOfHybridLists()
			return This.IsListOfHybridLists()

		def IsMadeOfOnlyHybridLists()
			return This.IsListOfHybridLists()

		def IsMadeOfHybridListsOnly()
			return This.IsListOfHybridLists()

		def IsMadeOnlyOfHybridLists()
			return This.IsListOfHybridLists()

		def IsOnlyMadeOfHybridLists()
			return This.IsListOfHybridLists()

		#--

		def AreHybridLists()
			return This.IsListOfHybridLists()

		def AreAllHybridLists()
			return This.IsListOfHybridLists()

		def AllAreHybridLists()
			return This.IsListOfHybridLists()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS MADE OF LISTS OF HYBRID LISTS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfHybridLists(paList)
		aContent = This.Content()
		nLen = len(aContent)

		aoStzLists = This.ToStzlists()

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT aoStzLists.IsHybridList()
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ItemsAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ItemsAreAllListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AllItemsAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ContainsOnlyListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ContainsListsOfHybridListsOnly()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfOnlyListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfListsOfHybridListsOnly()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOnlyOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsOnlyMadeOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		#--

		def AreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AreAllListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AllAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		#>


	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF NUMBERS  #
	#===============================================#

	def IsListOfNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbers()
			return This.IsListOfNumbers()

		def ItemsAreNumbers()
			return This.IsListOfNumbers()

		def ItemsAreAllNumbers()
			return This.IsListOfNumbers()

		def AllItemsAreNumbers()
			return This.IsListOfNumbers()

		def ContainsOnlyNumbers()
			return This.IsListOfNumbers()

		def ContainsNumbersOnly()
			return This.IsListOfNumbers()

		def IsMadeOfNumbers()
			return This.IsListOfNumbers()

		def IsMadeOfOnlyNumbers()
			return This.IsListOfNumbers()

		def IsMadeOfNumbersOnly()
			return This.IsListOfNumbers()

		def IsMadeOnlyOfNumbers()
			return This.IsListOfNumbers()

		def IsOnlyMadeOfNumbers()
			return This.IsListOfNumbers()

		#--

		def AreNumbers()
			return This.IsListOfNumbers()

		def AreAllNumbers()
			return This.IsListOfNumbers()

		def AllAreNumbers()
			return This.IsListOfNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF NUMBERS  #
	#--------------------------------------------------------#

	def IsListOfListsOfNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ItemsAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ItemsAreAllListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AllItemsAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ContainsOnlyListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ContainsListsOfNumbersOnly()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfOnlyListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfListsOfNumbersOnly()
			return This.IsListOfListsOfNumbers()

		def IsMadeOnlyOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsOnlyMadeOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		#--

		def AreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AreAllListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AllAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF DECIMAL NUMBERS  #
	#=======================================================#

	def IsListOfDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsDecimalNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ItemsAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ItemsAreAllDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AllItemsAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ContainsOnlyDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ContainsDecimalNumbersOnly()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfOnlyDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfDecimalNumbersOnly()
			return This.IsListOfDecimalNumbers()

		def IsMadeOnlyOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsOnlyMadeOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		#--

		def AreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AreAllDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AllAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF DECIMAL NUMBERS  #
	#----------------------------------------------------------------#

	def IsListOfListsOfDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfDecimalNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ItemsAreListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ItemsAreAllListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AllItemsAreListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ContainsOnlyListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ContainsListsOfDecimalNumbersOnly()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfOnlyListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfListsOfDecimalNumbersOnly()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOnlyOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsOnlyMadeOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		#--

		def ArelistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AreAlllistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AllArelistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF BINARY NUMBERS  #
	#======================================================#

	def IsListOfBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsBinaryNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ItemsAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ItemsAreAllBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AllItemsAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ContainsOnlyBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ContainsBinaryNumbersOnly()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfOnlyBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfBinaryNumbersOnly()
			return This.IsListOfBinaryNumbers()

		def IsMadeOnlyOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsOnlyMadeOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		#--

		def AreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AreAllBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AllAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF BINARY NUMBERS  #
	#---------------------------------------------------------------#

	def IsListOfListsOfBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfBinaryNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ItemsAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ItemsAreAllListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AllItemsAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ContainsOnlyListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ContainsListsOfBinaryNumbersOnly()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfOnlyListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfListsOfBinaryNumbersOnly()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOnlyOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsOnlyMadeOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		#--

		def AreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AreAllListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AllAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF OCTAL NUMBERS  #
	#=====================================================#

	def IsListOfOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsOctalNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ItemsAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ItemsAreAllOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AllItemsAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ContainsOnlyOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ContainsOctalNumbersOnly()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOnlyOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOctalNumbersOnly()
			return This.IsListOfOctalNumbers()

		def IsMadeOnlyOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsOnlyMadeOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		#--

		def AreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AreAllOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AllAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF OCTAL NUMBERS  #
	#--------------------------------------------------------------#

	def IsListOfListsOfOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfOctalNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ItemsAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ItemsAreAllListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AllItemsAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ContainsOnlyListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ContainsListsOfOctalNumbersOnly()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfOnlyListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfListsOfOctalNumbersOnly()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOnlyOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsOnlyMadeOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		#--

		def AreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AreAllListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AllAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		#>

	  #---------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HEX NUMBERS  #
	#===================================================#

	def IsListOfHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsHexNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHexNumbers()
			return This.IsListOfHexNumbers()

		def ItemsAreHexNumbers()
			return This.IsListOfHexNumbers()

		def ItemsAreAllHexNumbers()
			return This.IsListOfHexNumbers()

		def AllItemsAreHexNumbers()
			return This.IsListOfHexNumbers()

		def ContainsOnlyHexNumbers()
			return This.IsListOfHexNumbers()

		def ContainsHexNumbersOnly()
			return This.IsListOfHexNumbers()

		def IsMadeOfHexNumbers()
			return This.IsListOfHexNumbers()

		def IsMadeOfOnlyHexNumbers()
			return This.IsListOfHexNumbers()

		def IsMadeOfHexNumbersOnly()
			return This.IsListOfHexNumbers()

		def IsMadeOnlyOfHexNumbers()
			return This.IsListOfHexNumbers()

		def IsOnlyMadeOfHexNumbers()
			return This.IsListOfHexNumbers()

		#--

		def AreHexNumbers()
			return This.IsListOfHexNumbers()

		def AreAllHexNumbers()
			return This.IsListOfHexNumbers()

		def AllAreHexNumbers()
			return This.IsListOfHexNumbers()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF HEX NUMBERS  #
	#------------------------------------------------------------#

	def IsListOfListsOfHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfHexNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ItemsAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ItemsAreAllListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AllItemsAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ContainsOnlyListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ContainsListsOfHexNumbersOnly()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfOnlyListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfListsOfHexNumbersOnly()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOnlyOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsOnlyMadeOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		#--

		def AreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AreAllListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AllAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		#>
	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF QBYTESLIST OBJECTS  #
	#==========================================================#

	def IsListOfQBytesLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsQBytesListObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfQBytesLists()
			return This.IsListOfQBytesLists()

		def ItemsAreQBytesLists()
			return This.IsListOfQBytesLists()

		def ItemsAreAllQBytesLists()
			return This.IsListOfQBytesLists()

		def AllItemsAreQBytesLists()
			return This.IsListOfQBytesLists()

		def ContainsOnlyQBytesLists()
			return This.IsListOfQBytesLists()

		def ContainsQBytesListsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesLists()
			return This.IsListOfQBytesLists()

		def IsMadeOfOnlyQBytesLists()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOnlyOfQBytesLists()
			return This.IsListOfQBytesLists()

		def IsOnlyMadeOfQBytesLists()
			return This.IsListOfQBytesLists()

		#--

		def IsListOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsAListOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ItemsAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ItemsAreAllQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AllItemsAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ContainsOnlyQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ContainsQBytesListObjectsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsMadeOfOnlyQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListObjectsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOnlyOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsOnlyMadeOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		#--

		def AreQBytesList()
			return This.IsListOfQBytesLists()

		def AreAllQBytesList()
			return This.IsListOfQBytesLists()

		def AllAreQBytesList()
			return This.IsListOfQBytesLists()

		def AreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AreAllQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AllAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STRINGS  #
	#===============================================#

	def IsListOfStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStrings()
			return This.IsListOfStrings()

		def ItemsAreStrings()
			return This.IsListOfStrings()

		def ItemsAreAllStrings()
			return This.IsListOfStrings()

		def AllItemsAreStrings()
			return This.IsListOfStrings()

		def ContainsOnlyStrings()
			return This.IsListOfStrings()

		def ContainsStringsOnly()
			return This.IsListOfStrings()

		def IsMadeOfStrings()
			return This.IsListOfStrings()

		def IsMadeOfOnlyStrings()
			return This.IsListOfStrings()

		def IsMadeOfStringsOnly()
			return This.IsListOfStrings()

		def IsMadeOnlyOfStrings()
			return This.IsListOfStrings()

		def IsOnlyMadeOfStrings()
			return This.IsListOfStrings()

		#--

		def AreStrings()
			return This.IsListOfStrings()

		def AreAllStrings()
			return This.IsListOfStrings()

		def AllAreStrings()
			return This.IsListOfStrings()

		#>

	  #-------------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STRINGS OR PAIRS OF STRINGS  #
	#-------------------------------------------------------------------#

	def IsListOfStringsOrPairsOfStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT ( isString(@aContent[i]) or @IsPairOfStrings(@aContent[i]) )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def ItemsAreStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def ItemsAreAllStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def AllItemsAreStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def ContainsOnlyStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def ContainsStringsAndPairsOfStringsOnly()
			return This.IsListOfStringsOrPairsOfStrings()

		def IsMadeOfStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def IsMadeOfOnlyStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def IsMadeOfStringsOrPairsOfStringsOnly()
			return This.IsListOfStringsOrPairsOfStrings()

		def IsMadeOnlyOfStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def IsOnlyMadeOfStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		#--

		def AreStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def AreAllStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		def AllAreStringsOrPairsOfStrings()
			return This.IsListOfStringsOrPairsOfStrings()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STRINGS  #
	#--------------------------------------------------------#

	def IsListOfListsOfStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStrings(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ItemsAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ItemsAreAllListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AllItemsAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ContainsOnlyListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ContainsListsOfStringsOnly()
			return This.IsListOfListsOfStrings()

		def IsMadeOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsMadeOfOnlyListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsMadeOfListsOfStringsOnly()
			return This.IsListOfListsOfStrings()

		def IsMadeOnlyOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsOnlyMadeOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		#--

		def AreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AreAllListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AllAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS  #
	#=============================================#

	def IsListOfLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT isList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfLists()
			return This.IsListOfLists()

		def ItemsAreLists()
			return This.IsListOfLists()

		def ItemsAreAllLists()
			return This.IsListOfLists()

		def AllItemsAreLists()
			return This.IsListOfLists()

		def ContainsOnlyLists()
			return This.IsListOfLists()

		def ContainsListsOnly()
			return This.IsListOfLists()

		def IsMadeOfLists()
			return This.IsListOfLists()

		def IsMadeOfOnlyLists()
			return This.IsListOfLists()

		def IsMadeOfListsOnly()
			return This.IsListOfLists()

		def IsMadeOnlyOfLists()
			return This.IsListOfLists()

		def IsOnlyMadeOfLists()
			return This.IsListOfLists()

		#--

		def AreLists()
			return This.IsListOfLists()

		def AreAllLists()
			return This.IsListOfLists()

		def AllAreLists()
			return This.IsListOfLists()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF LISTS  #
	#------------------------------------------------------#

	def IsListOfListsOfLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfLists(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfLists()
			return This.IsListOfListsOfLists()

		def ItemsAreListsOfLists()
			return This.IsListOfListsOfLists()

		def ItemsAreAllListsOfLists()
			return This.IsListOfListsOfLists()

		def AllItemsAreListsOfLists()
			return This.IsListOfListsOfLists()

		def ContainsOnlyListsOfLists()
			return This.IsListOfListsOfLists()

		def ContainsListsOfListsOnly()
			return This.IsListOfListsOfLists()

		def IsMadeOfListsOfLists()
			return This.IsListOfListsOfLists()

		def IsMadeOfOnlyListsOfLists()
			return This.IsListOfListsOfLists()

		def IsMadeOfListsOfListsOnly()
			return This.IsListOfListsOfLists()

		def IsMadeOnlyOfListsOfLists()
			return This.IsListOfListsOfLists()

		def IsOnlyMadeOfListsOfLists()
			return This.IsListOfListsOfLists()

		#--

		def AreListsOfLists()
			return This.IsListOfListsOfLists()

		def AreAllListsOfLists()
			return This.IsListOfListsOfLists()

		def AllAreListsOfLists()
			return This.IsListOfListsOfLists()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF OBJECTS  #
	#===============================================#

	def IsListOfObjects()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfObjects()
			return This.IsListOfObjects()

		def ItemsAreObjects()
			return This.IsListOfObjects()

		def ItemsAreAllObjects()
			return This.IsListOfObjects()

		def AllItemsAreObjects()
			return This.IsListOfObjects()

		def ContainsOnlyObjects()
			return This.IsListOfObjects()

		def ContainsObjectsOnly()
			return This.IsListOfObjects()

		def IsMadeOfObjects()
			return This.IsListOfObjects()

		def IsMadeOfOnlyObjects()
			return This.IsListOfObjects()

		def IsMadeOfObjectsOnly()
			return This.IsListOfObjects()

		def IsMadeOnlyOfObjects()
			return This.IsListOfObjects()

		def IsOnlyMadeOfObjects()
			return This.IsListOfObjects()

		#--

		def AreObjects()
			return This.IsListOfObjects()

		def AreAllObjects()
			return This.IsListOfObjects()

		def AllAreObjects()
			return This.IsListOfObjects()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF OBJECTS  #
	#--------------------------------------------------------#

	def IsListOfListsOfObjects()

		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfObjects(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ItemsAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ItemsAreAllListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AllItemsAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ContainsOnlyListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ContainsListsOfObjectsOnly()
			return This.IsListOfListsOfObjects()

		def IsMadeOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsMadeOfOnlyListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsMadeOfListsOfObjectsOnly()
			return This.IsListOfListsOfObjects()

		def IsMadeOnlyOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsOnlyMadeOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		#--

		def AreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AreAllListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AllAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF CHARS  #
	#=============================================#

	def IsListOfChars()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsChar(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfChars()
			return This.IsListOfChars()

		def ItemsAreChars()
			return This.IsListOfChars()

		def ItemsAreAllChars()
			return This.IsListOfChars()

		def AllItemsAreChars()
			return This.IsListOfChars()

		def ContainsOnlyChars()
			return This.IsListOfChars()

		def ContainsCharsOnly()
			return This.IsListOfChars()

		def IsMadeOfChars()
			return This.IsListOfChars()

		def IsMadeOfOnlyChars()
			return This.IsListOfChars()

		def IsMadeOfCharsOnly()
			return This.IsListOfChars()

		def IsMadeOnlyOfChars()
			return This.IsListOfChars()

		def IsOnlyMadeOfChars()
			return This.IsListOfChars()

		#--

		def AreChars()
			return This.IsListOfChars()

		def AreAllChars()
			return This.IsListOfChars()

		def AllAreChars()
			return This.IsListOfChars()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF CHARS  #
	#------------------------------------------------------#

	def IsListOfListsOfChars()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfChars(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfChars()
			return This.IsListOfListsOfChars()

		def ItemsAreListsOfChars()
			return This.IsListOfListsOfChars()

		def ItemsAreAllListsOfChars()
			return This.IsListOfListsOfChars()

		def AllItemsAreListsOfChars()
			return This.IsListOfListsOfChars()

		def ContainsOnlyListsOfChars()
			return This.IsListOfListsOfChars()

		def ContainsListsOfCharsOnly()
			return This.IsListOfListsOfChars()

		def IsMadeOfListsOfChars()
			return This.IsListOfListsOfChars()

		def IsMadeOfOnlyListsOfChars()
			return This.IsListOfListsOfChars()

		def IsMadeOfListsOfCharsOnly()
			return This.IsListOfListsOfChars()

		def IsMadeOnlyOfListsOfChars()
			return This.IsListOfListsOfChars()

		def IsOnlyMadeOfListsOfChars()
			return This.IsListOfListsOfChars()

		#--

		def AreListsOfChars()
			return This.IsListOfListsOfChars()

		def AreAllListsOfChars()
			return This.IsListOfListsOfChars()

		def AllAreListsOfChars()
			return This.IsListOfListsOfChars()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LETTERS  #
	#-----------------------------------------------#

	def IsListOfLetters()
		_nLen_ = len(@aContent)
		if _nLen_ = 0
			return _FALSE_
		ok

		_bResult_ = _TRUE_

		for @i = 1 to _nLen_
			if NOT @IsLetter(@aContent[@i])
				_bResult_ = _FALSE_
				exit
			ok
		next

		return _bResult_

		#< @FunctionAlternativeForms

		def IsAListOfLetters()
			return This.IsListOfLetters()

		def ItemsAreLetters()
			return This.IsListOfLetters()

		def ItemsAreAllLetters()
			return This.IsListOfLetters()

		def AllItemsAreLetters()
			return This.IsListOfLetters()

		def ContainsOnlyLetters()
			return This.IsListOfLetters()

		def ContainsLettersOnly()
			return This.IsListOfLetters()

		def IsMadeOfLetters()
			return This.IsListOfLetters()

		def IsMadeOfOnlyLetters()
			return This.IsListOfLetters()

		def IsMadeOfLettersOnly()
			return This.IsListOfLetters()

		def IsMadeOnlyOfLetters()
			return This.IsListOfLetters()

		def IsOnlyMadeOfLetters()
			return This.IsListOfLetters()

		#--

		def AreLetters()
			return This.IsListOfLetters()

		def AreAllLetters()
			return This.IsListOfLetters()

		def AllAreLetters()
			return This.IsListOfLetters()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF PAIRS  #
	#=============================================#

	def IsListOfPairs()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsPair(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfPairs()
			return This.IsListOfPairs()

		def ItemsArePairs()
			return This.IsListOfPairs()

		def ItemsAreAllPairs()
			return This.IsListOfPairs()

		def AllItemsArePairs()
			return This.IsListOfPairs()

		def ContainsOnlyPairs()
			return This.IsListOfPairs()

		def ContainsPairsOnly()
			return This.IsListOfPairs()

		def IsMadeOfPairs()
			return This.IsListOfPairs()

		def IsMadeOfOnlyPairs()
			return This.IsListOfPairs()

		def IsMadeOfPairsOnly()
			return This.IsListOfPairs()

		def IsMadeOnlyOfPairs()
			return This.IsListOfPairs()

		def IsOnlyMadeOfPairs()
			return This.IsListOfPairs()

		#--

		def ArePairs()
			return This.IsListOfPairs()

		def AreAllPairs()
			return This.IsListOfPairs()

		def AllArePairs()
			return This.IsListOfPairs()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF PAIRS  #
	#------------------------------------------------------#

	def IsListOfListsOfPairs()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfPairs(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ItemsAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ItemsAreAllListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AllItemsAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ContainsOnlyListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ContainsListsOfPairsOnly()
			return This.IsListOfListsOfPairs()

		def IsMadeOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsMadeOfOnlyListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsMadeOfListsOfPairsOnly()
			return This.IsListOfListsOfPairs()

		def IsMadeOnlyOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsOnlyMadeOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		#--

		def AreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AreAllListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AllAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		#>

	  #--------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF SETS  #
	#============================================#

	def IsListOfSets()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsSet(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfSets()
			return This.IsListOfSets()

		def ItemsAreSets()
			return This.IsListOfSets()

		def ItemsAreAllSets()
			return This.IsListOfSets()

		def AllItemsAreSets()
			return This.IsListOfSets()

		def ContainsOnlySets()
			return This.IsListOfSets()

		def ContainsSetsOnly()
			return This.IsListOfSets()

		def IsMadeOfSets()
			return This.IsListOfSets()

		def IsMadeOfOnlySets()
			return This.IsListOfSets()

		def IsMadeOfSetsOnly()
			return This.IsListOfSets()

		def IsMadeOnlyOfSets()
			return This.IsListOfSets()

		def IsOnlyMadeOfSets()
			return This.IsListOfSets()

		#--

		def AreSets()
			return This.IsListOfSets()

		def AreAllSets()
			return This.IsListOfSets()

		def AllAreSets()
			return This.IsListOfSets()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF SETS  #
	#-----------------------------------------------------#

	def IsListOfListsOfSets()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfSets(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfSets()
			return This.IsListOfListsOfSets()

		def ItemsAreListsOfSets()
			return This.IsListOfListsOfSets()

		def ItemsAreAllListsOfSets()
			return This.IsListOfListsOfSets()

		def AllItemsAreListsOfSets()
			return This.IsListOfListsOfSets()

		def ContainsOnlyListsOfSets()
			return This.IsListOfListsOfSets()

		def ContainsListsOfSetsOnly()
			return This.IsListOfListsOfSets()

		def IsMadeOfListsOfSets()
			return This.IsListOfListsOfSets()

		def IsMadeOfOnlyListsOfSets()
			return This.IsListOfListsOfSets()

		def IsMadeOfListsOfSetsOnly()
			return This.IsListOfListsOfSets()

		def IsMadeOnlyOfListsOfSets()
			return This.IsListOfListsOfSets()

		def IsOnlyMadeOfListsOfSets()
			return This.IsListOfListsOfSets()

		#--

		def AreListsOfSets()
			return This.IsListOfListsOfSets()

		def AreAllListsOfSets()
			return This.IsListOfListsOfSets()

		def AllAreListsOfSets()
			return This.IsListOfListsOfSets()

		#>

	  #-------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HASHLISTS  #
	#=================================================#

	def IsListOfHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsHashList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHashLists()
			return This.IsListOfHashLists()

		def ItemsAreHashLists()
			return This.IsListOfHashLists()

		def ItemsAreAllHashLists()
			return This.IsListOfHashLists()

		def AllItemsAreHashLists()
			return This.IsListOfHashLists()

		def ContainsOnlyHashLists()
			return This.IsListOfHashLists()

		def ContainsHashListsOnly()
			return This.IsListOfHashLists()

		def IsMadeOfHashLists()
			return This.IsListOfHashLists()

		def IsMadeOfOnlyHashLists()
			return This.IsListOfHashLists()

		def IsMadeOfHashListsOnly()
			return This.IsListOfHashLists()

		def IsMadeOnlyOfHashLists()
			return This.IsListOfHashLists()

		def IsOnlyMadeOfHashLists()
			return This.IsListOfHashLists()

		#--

		def AreHashLists()
			return This.IsListOfHashLists()

		def AreAllHashLists()
			return This.IsListOfHashLists()

		def AllAreHashLists()
			return This.IsListOfHashLists()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF HASHLISTS  #
	#----------------------------------------------------------#

	def IsListOfListsOfHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfHashLists(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ItemsAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ItemsAreAllListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AllItemsAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ContainsOnlyListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ContainsListsOfHashListsOnly()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfOnlyListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfListsOfHashListsOnly()
			return This.IsListOfListsOfHashLists()

		def IsMadeOnlyOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsOnlyMadeOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		#--

		def AreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AreAllListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AllAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF GRIDS  #
	#=============================================#

	def IsListOfGrids()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsGrid(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfGrids()
			return This.IsListOfGrids()

		def ItemsAreGrids()
			return This.IsListOfGrids()

		def ItemsAreAllGrids()
			return This.IsListOfGrids()

		def AllItemsAreGrids()
			return This.IsListOfGrids()

		def ContainsOnlyGrids()
			return This.IsListOfGrids()

		def ContainsGridsOnly()
			return This.IsListOfGrids()

		def IsMadeOfGrids()
			return This.IsListOfGrids()

		def IsMadeOfOnlyGrids()
			return This.IsListOfGrids()

		def IsMadeOfGridsOnly()
			return This.IsListOfGrids()

		def IsMadeOnlyOfGrids()
			return This.IsListOfGrids()

		def IsOnlyMadeOfGrids()
			return This.IsListOfGrids()

		#--

		def AreGrids()
			return This.IsListOfGrids()

		def AreAllGrids()
			return This.IsListOfGrids()

		def AllAreGrids()
			return This.IsListOfGrids()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF GRIDS  #
	#------------------------------------------------------#

	def IsListOfListsOfGrids()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfGrids(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ItemsAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ItemsAreAllListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AllItemsAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ContainsOnlyListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ContainsListsOfGridsOnly()
			return This.IsListOfListsOfGrids()

		def IsMadeOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsMadeOfOnlyListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsMadeOfListsOfGridsOnly()
			return This.IsListOfListsOfGrids()

		def IsMadeOnlyOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsOnlyMadeOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		#--

		def AreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AreAllListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AllAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		#>

	  #----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF TABLES  #
	#==============================================#

	def IsListOfTables()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsTable(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfTables()
			return This.IsListOfTables()

		def ItemsAreTables()
			return This.IsListOfTables()

		def ItemsAreAllTables()
			return This.IsListOfTables()

		def AllItemsAreTables()
			return This.IsListOfTables()

		def ContainsOnlyTables()
			return This.IsListOfTables()

		def ContainsTablesOnly()
			return This.IsListOfTables()

		def IsMadeOfTables()
			return This.IsListOfTables()

		def IsMadeOfOnlyTables()
			return This.IsListOfTables()

		def IsMadeOfTablesOnly()
			return This.IsListOfTables()

		def IsMadeOnlyOfTables()
			return This.IsListOfTables()

		def IsOnlyMadeOfTables()
			return This.IsListOfTables()

		#--

		def AreTables()
			return This.IsListOfTables()

		def AreAllTables()
			return This.IsListOfTables()

		def AllAreTables()
			return This.IsListOfTables()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF TABLES  #
	#-------------------------------------------------------#

	def IsListOfListsOfTables()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfTables(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfTables()
			return This.IsListOfListsOfTables()

		def ItemsAreListsOfTables()
			return This.IsListOfListsOfTables()

		def ItemsAreAllListsOfTables()
			return This.IsListOfListsOfTables()

		def AllItemsAreListsOfTables()
			return This.IsListOfListsOfTables()

		def ContainsOnlyListsOfTables()
			return This.IsListOfListsOfTables()

		def ContainsListsOfTablesOnly()
			return This.IsListOfListsOfTables()

		def IsMadeOfListsOfTables()
			return This.IsListOfListsOfTables()

		def IsMadeOfOnlyListsOfTables()
			return This.IsListOfListsOfTables()

		def IsMadeOfListsOfTablesOnly()
			return This.IsListOfListsOfTables()

		def IsMadeOnlyOfListsOfTables()
			return This.IsListOfListsOfTables()

		def IsOnlyMadeOfListsOfTables()
			return This.IsListOfListsOfTables()

		#--

		def AreListsOfTables()
			return This.IsListOfListsOfTables()

		def AreAllListsOfTables()
			return This.IsListOfListsOfTables()

		def AllAreListsOfTables()
			return This.IsListOfListsOfTables()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF TREES  #
	#=============================================#

	def IsListOfTrees()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsTree(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfTrees()
			return This.IsListOfTrees()

		def ItemsAreTrees()
			return This.IsListOfTrees()

		def ItemsAreAllTrees()
			return This.IsListOfTrees()

		def AllItemsAreTrees()
			return This.IsListOfTrees()

		def ContainsOnlyTrees()
			return This.IsListOfTrees()

		def ContainsTreesOnly()
			return This.IsListOfTrees()

		def IsMadeOfTrees()
			return This.IsListOfTrees()

		def IsMadeOfOnlyTrees()
			return This.IsListOfTrees()

		def IsMadeOfTreesOnly()
			return This.IsListOfTrees()

		def IsMadeOnlyOfTrees()
			return This.IsListOfTrees()

		def IsOnlyMadeOfTrees()
			return This.IsListOfTrees()

		#--

		def AreTrees()
			return This.IsListOfTrees()

		def AreAllTrees()
			return This.IsListOfTrees()

		def AllAreTrees()
			return This.IsListOfTrees()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF TREES  #
	#------------------------------------------------------#

	def IsListOfListsOfTrees()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfTrees(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ItemsAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ItemsAreAllListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AllItemsAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ContainsOnlyListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ContainsListsOfTreesOnly()
			return This.IsListOfListsOfTrees()

		def IsMadeOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsMadeOfOnlyListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsMadeOfListsOfTreesOnly()
			return This.IsListOfListsOfTrees()

		def IsMadeOnlyOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsOnlyMadeOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		#--

		def AreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AreAllListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AllAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZNUMBERS  #
	#==================================================#

	def IsListOfStzNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzNumbers()
			return This.IsListOfStzNumbers()

		def ItemsAreStzNumbers()
			return This.IsListOfStzNumbers()

		def ItemsAreAllStzNumbers()
			return This.IsListOfStzNumbers()

		def AllItemsAreStzNumbers()
			return This.IsListOfStzNumbers()

		def ContainsOnlyStzNumbers()
			return This.IsListOfStzNumbers()

		def ContainsStzNumbersOnly()
			return This.IsListOfStzNumbers()

		def IsMadeOfStzNumbers()
			return This.IsListOfStzNumbers()

		def IsMadeOfOnlyStzNumbers()
			return This.IsListOfStzNumbers()

		def IsMadeOfStzNumbersOnly()
			return This.IsListOfStzNumbers()

		def IsMadeOnlyOfStzNumbers()
			return This.IsListOfStzNumbers()

		def IsOnlyMadeOfStzNumbers()
			return This.IsListOfStzNumbers()

		#--

		def AreStzNumbers()
			return This.IsListOfStzNumbers()

		def AreAllStzNumbers()
			return This.IsListOfStzNumbers()

		def AllAreStzNumbers()
			return This.IsListOfStzNumbers()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZNUMBERS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ItemsAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ItemsAreAllListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AllItemsAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ContainsOnlyListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ContainsListsOfStzNumbersOnly()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfOnlyListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfListsOfStzNumbersOnly()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOnlyOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsOnlyMadeOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		#--

		def AreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AreAllListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AllAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZDECIMALNUMBERS  #
	#=========================================================#

	def IsListOfStzDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzDecimalNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ItemsAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ItemsAreAllStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AllItemsAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ContainsOnlyStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ContainsStzDecimalNumbersOnly()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfOnlyStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfStzDecimalNumbersOnly()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOnlyOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsOnlyMadeOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		#--

		def AreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AreAllStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AllAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZDECIMALNUMBERS  #
	#------------------------------------------------------------------#

	def IsListOfListsOfStzDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzDecimalNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ItemsAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ItemsAreAllListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AllItemsAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ContainsOnlyListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ContainsListsOfStzDecimalNumbersOnly()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfOnlyListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfListsOfStzDecimalNumbersOnly()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOnlyOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsOnlyMadeOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		#--

		def AreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AreAllListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AllAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZBINARYNUMBERS  #
	#========================================================#

	def IsListOfStzBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzBinaryNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ItemsAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ItemsAreAllStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllItemsAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ContainsOnlyStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ContainsStzBinaryNumbersOnly()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfOnlyStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfStzBinaryNumbersOnly()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOnlyOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsOnlyMadeOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#--

		def AreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AreAllStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZBINARYNUMBERS  #
	#-----------------------------------------------------------------#

	def IsListOfListsOfStzBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzBinaryNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ItemsAreListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ItemsAreAllListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def AllItemsAreListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ContainsOnlyListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ContainsListsOfStzBinaryNumbersOnly()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfOnlyListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfListsOfStzBinaryNumbersOnly()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOnlyOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsOnlyMadeOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		#--

		def AreListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AreAllListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllAreListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZOCTALNUMBERS  #
	#=======================================================#

	def IsListOfStzOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzOctalNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ItemsAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ItemsAreAllStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AllItemsAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ContainsOnlyStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ContainsStzOctalNumbersOnly()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfOnlyStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfStzOctalNumbersOnly()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOnlyOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsOnlyMadeOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		#--

		def AreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AreAllStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AllAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZOCTALNUMBERS  #
	#----------------------------------------------------------------#

	def IsListOfListsOfStzOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzOctalNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ItemsAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ItemsAreAllListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AllItemsAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ContainsOnlyListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ContainsListsOfStzOctalNumbersOnly()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfOnlyListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfListsOfStzOctalNumbersOnly()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOnlyOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsOnlyMadeOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		#--

		def AreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AreAllListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AllAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZHEXNUMBERS  #
	#=====================================================#

	def IsListOfStzHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzHexNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ItemsAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ItemsAreAllStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AllItemsAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ContainsOnlyStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ContainsStzHexNumbersOnly()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfOnlyStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfStzHexNumbersOnly()
			return This.IsListOfStzHexNumbers()

		def IsMadeOnlyOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsOnlyMadeOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		#--

		def AreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AreAllStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AllAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZHEXNUMBERS  #
	#--------------------------------------------------------------#

	def IsListOfListsOfStzHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzHexNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ItemsAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ItemsAreAllListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AllItemsAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ContainsOnlyListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ContainsListsOfStzHexNumbersOnly()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfOnlyListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfListsOfStzHexNumbersOnly()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOnlyOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsOnlyMadeOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		#--

		def AreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AreAllListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AllAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		#>
	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZLISTOFBYTES  #
	#======================================================#

	def IsListOfStzListsOfBytes()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzListOfBytes(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzListOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ItemsAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ItemsAreAllStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def AllItemsAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ContainsOnlyStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ContainsStzListsOfBytesOnly()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfOnlyStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfStzListsOfBytesOnly()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOnlyOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsOnlyMadeOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		#--

		def AreStzListsOfBytes()
			return This.IsListOfStzNumbers()

		def AreAllStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def AllAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZSTRINGS  #
	#==================================================#

	def IsListOfStzStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzStrings()
			return This.IsListOfStzStrings()

		def ItemsAreStzStrings()
			return This.IsListOfStzStrings()

		def ItemsAreAllStzStrings()
			return This.IsListOfStzStrings()

		def AllItemsAreStzStrings()
			return This.IsListOfStzStrings()

		def ContainsOnlyStzStrings()
			return This.IsListOfStzStrings()

		def ContainsStzStringsOnly()
			return This.IsListOfStzStrings()

		def IsMadeOfStzStrings()
			return This.IsListOfStzStrings()

		def IsMadeOfOnlyStzStrings()
			return This.IsListOfStzStrings()

		def IsMadeOfStzStringsOnly()
			return This.IsListOfStzStrings()

		def IsMadeOnlyOfStzStrings()
			return This.IsListOfStzStrings()

		def IsOnlyMadeOfStzStrings()
			return This.IsListOfStzStrings()

		#--

		def AreStzStrings()
			return This.IsListOfStzStrings()

		def AreAllStzStrings()
			return This.IsListOfStzStrings()

		def AllAreStzStrings()
			return This.IsListOfStzStrings()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZSTRINGS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzStrings(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ItemsAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ItemsAreAllListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AllItemsAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ContainsOnlyListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ContainsListsOfStzStringsOnly()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfOnlyListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfListsOfStzStringsOnly()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOnlyOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsOnlyMadeOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		#--

		def AreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AreAllListsofStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AllAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZLISTS  #
	#================================================#

	def IsListOfStzLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzLists()
			return This.IsListOfStzLists()

		def ItemsAreStzLists()
			return This.IsListOfStzLists()

		def ItemsAreAllStzLists()
			return This.IsListOfStzLists()

		def AllItemsAreStzLists()
			return This.IsListOfStzLists()

		def ContainsOnlyStzLists()
			return This.IsListOfStzLists()

		def ContainsStzListsOnly()
			return This.IsListOfStzLists()

		def IsMadeOfStzLists()
			return This.IsListOfStzLists()

		def IsMadeOfOnlyStzLists()
			return This.IsListOfStzLists()

		def IsMadeOfStzListsOnly()
			return This.IsListOfStzLists()

		def IsMadeOnlyOfStzLists()
			return This.IsListOfStzLists()

		def IsOnlyMadeOfStzLists()
			return This.IsListOfStzLists()

		#--

		def AreStzLists()
			return This.IsListOfStzLists()

		def AreAllStzLists()
			return This.IsListOfStzLists()

		def AllAreStzLists()
			return This.IsListOfStzLists()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZLISTS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzLists(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ItemsAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ItemsAreAllListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AllItemsAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ContainsOnlyListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ContainsListsOfStzListsOnly()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfOnlyListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfListsOfStzListsOnly()
			return This.IsListOfListsOfStzLists()

		def IsMadeOnlyOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsOnlyMadeOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		#--

		def AreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AreAllListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AllAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZOBJECTS  #
	#==================================================#

	def IsListOfStzObjects()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzObjects()
			return This.IsListOfStzObjects()

		def ItemsAreStzObjects()
			return This.IsListOfStzObjects()

		def ItemsAreAllStzObjects()
			return This.IsListOfStzObjects()

		def AllItemsAreStzObjects()
			return This.IsListOfStzObjects()

		def ContainsOnlyStzObjects()
			return This.IsListOfStzObjects()

		def ContainsStzObjectsOnly()
			return This.IsListOfStzObjects()

		def IsMadeOfStzObjects()
			return This.IsListOfStzObjects()

		def IsMadeOfOnlyStzObjects()
			return This.IsListOfStzObjects()

		def IsMadeOfStzObjectsOnly()
			return This.IsListOfStzObjects()

		def IsMadeOnlyOfStzObjects()
			return This.IsListOfStzObjects()

		def IsOnlyMadeOfStzObjects()
			return This.IsListOfStzObjects()

		#--

		def AreStzObjects()
			return This.IsListOfStzObjects()

		def AreAllStzObjects()
			return This.IsListOfStzObjects()

		def AllAreStzObjects()
			return This.IsListOfStzObjects()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZOBJECTS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzObjects()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzObjects(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ItemsAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ItemsAreAllListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AllItemsAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ContainsOnlyListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ContainsListsOfStzObjectsOnly()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfOnlyListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfListsOfStzObjectsOnly()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOnlyOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsOnlyMadeOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		#--

		def AreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AreAllListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AllAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZCHARS  #
	#================================================#

	def IsListOfStzChars()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzChar(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzChars()
			return This.IsListOfStzChars()

		def ItemsAreStzChars()
			return This.IsListOfStzChars()

		def ItemsAreAllStzChars()
			return This.IsListOfStzChars()

		def AllItemsAreStzChars()
			return This.IsListOfStzChars()

		def ContainsOnlyStzChars()
			return This.IsListOfStzChars()

		def ContainsStzCharsOnly()
			return This.IsListOfStzChars()

		def IsMadeOfStzChars()
			return This.IsListOfStzChars()

		def IsMadeOfOnlyStzChars()
			return This.IsListOfStzChars()

		def IsMadeOfStzCharsOnly()
			return This.IsListOfStzChars()

		def IsMadeOnlyOfStzChars()
			return This.IsListOfStzChars()

		def IsOnlyMadeOfStzChars()
			return This.IsListOfStzChars()

		#--

		def AreStzChars()
			return This.IsListOfStzChars()

		def AreAllStzChars()
			return This.IsListOfStzChars()

		def AllAreStzChars()
			return This.IsListOfStzChars()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZCHARS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzChars()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzChars(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ItemsAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ItemsAreAllListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AllItemsAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ContainsOnlyListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ContainsListsOfStzCharsOnly()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfOnlyListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfListsOfStzCharsOnly()
			return This.IsListOfListsOfStzChars()

		def IsMadeOnlyOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsOnlyMadeOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		#--

		def AreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AreAllListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AllAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZPAIRS  #
	#================================================#

	def IsListOfStzPairs()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzPair(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzPairs()
			return This.IsListOfStzPairs()

		def ItemsAreStzPairs()
			return This.IsListOfStzPairs()

		def ItemsAreAllStzPairs()
			return This.IsListOfStzPairs()

		def AllItemsAreStzPairs()
			return This.IsListOfStzPairs()

		def ContainsOnlyStzPairs()
			return This.IsListOfStzPairs()

		def ContainsStzPairsOnly()
			return This.IsListOfStzPairs()

		def IsMadeOfStzPairs()
			return This.IsListOfStzPairs()

		def IsMadeOfOnlyStzPairs()
			return This.IsListOfStzPairs()

		def IsMadeOfStzPairsOnly()
			return This.IsListOfStzPairs()

		def IsMadeOnlyOfStzPairs()
			return This.IsListOfStzPairs()

		def IsOnlyMadeOfStzPairs()
			return This.IsListOfStzPairs()

		#--

		def AreStzPairs()
			return This.IsListOfStzPairs()

		def AreAllStzPairs()
			return This.IsListOfStzPairs()

		def AllAreStzPairs()
			return This.IsListOfStzPairs()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZPAIRS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzPairs()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzPairs(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ItemsAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ItemsAreAllListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AllItemsAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ContainsOnlyListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ContainsListsOfStzPairsOnly()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfOnlyListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfListsOfStzPairsOnly()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOnlyOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsOnlyMadeOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		#--

		def AreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AreAllListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AllAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZSETS  #
	#===============================================#

	def IsListOfStzSets()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzSet(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzSets()
			return This.IsListOfStzSets()

		def ItemsAreStzSets()
			return This.IsListOfStzSets()

		def ItemsAreAllStzSets()
			return This.IsListOfStzSets()

		def AllItemsAreStzSets()
			return This.IsListOfStzSets()

		def ContainsOnlyStzSets()
			return This.IsListOfStzSets()

		def ContainsStzSetsOnly()
			return This.IsListOfStzSets()

		def IsMadeOfStzSets()
			return This.IsListOfStzSets()

		def IsMadeOfOnlyStzSets()
			return This.IsListOfStzSets()

		def IsMadeOfStzSetsOnly()
			return This.IsListOfStzSets()

		def IsMadeOnlyOfStzSets()
			return This.IsListOfStzSets()

		def IsOnlyMadeOfStzSets()
			return This.IsListOfStzSets()

		#--

		def AreStzSets()
			return This.IsListOfStzNumbers()

		def AreAllStzSets()
			return This.IsListOfStzNumbers()

		def AllAreStzSets()
			return This.IsListOfStzNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZSETS  #
	#--------------------------------------------------------#

	def IsListOfListsOfStzSets()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzSets(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ItemsAreListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ItemsAreAllListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def AllItemsAreListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ContainsOnlyListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ContainsListsOfStzSetsOnly()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfOnlyListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfListsOfStzSetsOnly()
			return This.IsListOfListsOfStzSets()

		def IsMadeOnlyOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsOnlyMadeOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		#--

		def AreListsOfStzSets()
			return This.IsListOfStzNumbers()

		def AreAllListsOfStzSets()
			return This.IsListOfStzNumbers()

		def AllAreListsOfStzSets()
			return This.IsListOfStzNumbers()

		#>

	  #----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZHASHLISTS  #
	#====================================================#

	def IsListOfStzHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzHashList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzHashLists()
			return This.IsListOfStzHashLists()

		def ItemsAreStzHashLists()
			return This.IsListOfStzHashLists()

		def ItemsAreAllStzHashLists()
			return This.IsListOfStzHashLists()

		def AllItemsAreStzHashLists()
			return This.IsListOfStzHashLists()

		def ContainsOnlyStzHashLists()
			return This.IsListOfStzHashLists()

		def ContainsStzHashListsOnly()
			return This.IsListOfStzHashLists()

		def IsMadeOfStzHashLists()
			return This.IsListOfStzHashLists()

		def IsMadeOfOnlyStzHashLists()
			return This.IsListOfStzHashLists()

		def IsMadeOfStzHashListsOnly()
			return This.IsListOfStzHashLists()

		def IsMadeOnlyOfStzHashLists()
			return This.IsListOfStzHashLists()

		def IsOnlyMadeOfStzHashLists()
			return This.IsListOfStzHashLists()

		#--

		def AreStzHashLists()
			return This.IsListOfStzHashLists()

		def AreAllStzHashLists()
			return This.IsListOfStzHashLists()

		def AllAreStzHashLists()
			return This.IsListOfStzHashLists()

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZHASHLISTS  #
	#-------------------------------------------------------------#

	def IsListOfListsOfStzHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzHashLists(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ItemsAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ItemsAreAllListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AllItemsAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ContainsOnlyListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ContainsListsOfStzHashListsOnly()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfOnlyListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfListsOfStzHashListsOnly()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOnlyOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsOnlyMadeOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		#--

		def AreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AreAllListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AllAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZGRIDS  #
	#================================================#

	def IsListOfStzGrids()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzGrid(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzGrids()
			return This.IsListOfStzGrids()

		def ItemsAreStzGrids()
			return This.IsListOfStzGrids()

		def ItemsAreAllStzGrids()
			return This.IsListOfStzGrids()

		def AllItemsAreStzGrids()
			return This.IsListOfStzGrids()

		def ContainsOnlyStzGrids()
			return This.IsListOfStzGrids()

		def ContainsStzGridsOnly()
			return This.IsListOfStzGrids()

		def IsMadeOfStzGrids()
			return This.IsListOfStzGrids()

		def IsMadeOfOnlyStzGrids()
			return This.IsListOfStzGrids()

		def IsMadeOfStzGridsOnly()
			return This.IsListOfStzGrids()

		def IsMadeOnlyOfStzGrids()
			return This.IsListOfStzGrids()

		def IsOnlyMadeOfStzGrids()
			return This.IsListOfStzGrids()

		#--

		def AreStzGrids()
			return This.IsListOfStzGrids()

		def AreAllStzGrids()
			return This.IsListOfStzGrids()

		def AllAreStzGrids()
			return This.IsListOfStzGrids()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZGRIDS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzGrids()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzGrids(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ItemsAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ItemsAreAllListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AllItemsAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ContainsOnlyListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ContainsListsOfStzGridsOnly()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfOnlyListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfListsOfStzGridsOnly()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOnlyOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsOnlyMadeOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		#--

		def AreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AreAllListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AllAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		#>

	  #-------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZTABLES  #
	#=================================================#

	def IsListOfStzTables()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzTable(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzTables()
			return This.IsListOfStzTables()

		def ItemsAreStzTables()
			return This.IsListOfStzTables()

		def ItemsAreAllStzTables()
			return This.IsListOfStzTables()

		def AllItemsAreStzTables()
			return This.IsListOfStzTables()

		def ContainsOnlyStzTables()
			return This.IsListOfStzTables()

		def ContainsStzTablesOnly()
			return This.IsListOfStzTables()

		def IsMadeOfStzTables()
			return This.IsListOfStzTables()

		def IsMadeOfOnlyStzTables()
			return This.IsListOfStzTables()

		def IsMadeOfStzTablesOnly()
			return This.IsListOfStzTables()

		def IsMadeOnlyOfStzTables()
			return This.IsListOfStzTables()

		def IsOnlyMadeOfStzTables()
			return This.IsListOfStzTables()

		#--

		def AreStzTables()
			return This.IsListOfStzTables()

		def AreAllStzTables()
			return This.IsListOfStzTables()

		def AllAreStzTables()
			return This.IsListOfStzTables()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZTABLES  #
	#----------------------------------------------------------#

	def IsListOfListsOfStzTables()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzTables(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ItemsAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ItemsAreAllListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AllItemsAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ContainsOnlyListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ContainsListsOfStzTablesOnly()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfOnlyListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfListsOfStzTablesOnly()
			return This.IsListOfListsOfStzTables()

		def IsMadeOnlyOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsOnlyMadeOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		#--

		def AreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AreAllListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AllAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZTREES  #
	#================================================#

	def IsListOfStzTrees()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsStzTree(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzTrees()
			return This.IsListOfStzTrees()

		def ItemsAreStzTrees()
			return This.IsListOfStzTrees()

		def ItemsAreAllStzTrees()
			return This.IsListOfStzTrees()

		def AllItemsAreStzTrees()
			return This.IsListOfStzTrees()

		def ContainsOnlyStzTrees()
			return This.IsListOfStzTrees()

		def ContainsStzTreesOnly()
			return This.IsListOfStzTrees()

		def IsMadeOfStzTrees()
			return This.IsListOfStzTrees()

		def IsMadeOfOnlyStzTrees()
			return This.IsListOfStzTrees()

		def IsMadeOfStzTreesOnly()
			return This.IsListOfStzTrees()

		def IsMadeOnlyOfStzTrees()
			return This.IsListOfStzTrees()

		def IsOnlyMadeOfStzTrees()
			return This.IsListOfStzTrees()

		#--

		def AreStzTrees()
			return This.IsListOfStzTrees()

		def AreAllStzTrees()
			return This.IsListOfStzTrees()

		def AllAreStzTrees()
			return This.IsListOfStzTrees()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZTREES  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzTrees()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsListOfStzTrees(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ItemsAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ItemsAreAllListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AllItemsAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ContainsOnlyListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ContainsListsOfStzTreesOnly()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfOnlyListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfListsOfStzTreesOnly()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOnlyOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsOnlyMadeOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		#--

		def AreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AreAllListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AllAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		#>

	#==

	def IsListOfNumbersInStrings()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT @IsNumberInString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ItemsAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ItemsAreAllNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AllItemsAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ContainsOnlyNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ContainsNumbersInStringsOnly()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfOnlyNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfNumbersInStringsOnly()
			return This.IsListOfNumbersInStrings()

		#--

		def AreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AreAllNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AllAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		#>

	def IsListOfNumbersOrStrings()
		if This.IsListOfNumbers() or
		   This.IsListOfStrings() or
		   This.ISListOfNumbersAndStrings()

			return _TRUE_
		else
			return _FALSE_
		ok
		#< @FunctionAlternativeForms

		def IsAListOfNumberOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreAllListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def AllItemsAreListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ContainsOnlyListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ContainsListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfOnlyListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfNumbersOrStringsOnly()
			return This.IsListOfNumbersOrStrings()

		#--

		def IsListOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsAListOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreAllListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def AllItemsAreListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ContainsOnlyListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ContainsListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfOnlyListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfStringsOrNumbersOnly()
			return This.IsListOfNumbersOrStrings()

		#>

	def IsListOfNumbersAndStrings()
		bResult = _TRUE_
		for item in This.List()
			if NOT (isString(item) or isNumber(item))
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumberAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreAllListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AllItemsAreListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ContainsOnlyListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ContainsListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfOnlyListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfNumbersAndStringsOnly()
			return This.IsListOfNumbersAndStrings()

		#--

		def IsListOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsAListOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreAllListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def AllItemsAreListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ContainsOnlyListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ContainsListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfOnlyListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfStringsAndNumbersOnly()
			return This.IsListOfNumbersAndStrings()

		#--

		def AreNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AreAllNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AllAreNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		#>

	def IsListOfNumbersOrListOfStrings()
		if This.IsListOfNumbers() or This.IsListOfStrings()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsListOfStringsOrListOfNumbers()
			return This.IsListOfNumbersOrListOfStrings()

		def AreOnlyNumbersOrOnlyStrings()
			return This.IsListOfNumbersOrListOfStrings()

		def AreOnlyStringsOrOnlyNumbers()
			return This.IsListOfNumbersOrListOfStrings()

	def IsListOfStringsAndPairsOfStrings()
		bResult = _TRUE_

		for item in This.List()
			if NOT 	( isString(item) or
					( isList(item) and Q(item).IsPairOfStrings() ) )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStringsAndPairsOfStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def IsListOfPairsOfstringsAndStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def IsAListOfPairsOfStringsAndstrings()
			return This.IsListOfStringsAndPairsOfStrings()

		#--

		def AreStringsAndPairsOfStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def ArePairsOfStringsAndStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		#>

	def IsListOfNumbersAndPairsOfNumbers()
		bResult = _TRUE_

		for item in This.List()
			if NOT 	( isNumber(item) or
					( isList(item) and Q(item).IsPairOfNumbers() ) )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbersAndPairsOfNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def IsListOfPairsOfNumbersAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def IsAListOfPairsOfNumbersAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		#--

		def AreNumbersAndPairsOfStrings()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def ArePairsOfStringsAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		#>

	def IsListOfListsAndPairsOfLists()
		bResult = _TRUE_

		for item in This.List()
			if NOT 	( isList(item) or
					( isList(item) and Q(item).IsPairOfLists() ) )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsAndPairsOfLists()
			return This.IsListOfListsAndPairsOfLists()

		def IsListOfPairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		def IsAListOfPairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		#--

		def AreListsAndPairsOfLists()
			return This.IsListOfListsAndPairsOfLists()

		def ArePairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		#>

	def IsListOfObjectsAndPairsOfObjects()
		bResult = _TRUE_

		for item in This.List()
			if NOT 	( isNumber(item) or
					( isObject(item) and Q(item).IsPairOfObjects() ) )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfObjectsAndPairsOfObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def IsListOfPairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def IsAListOfPairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		#--

		def AreObjectsAndPairsOfObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def ArePairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		#>

	def IsPair()
		return This.NumberOfItems() = 2

		def IsPairQ()
			if This.IsPair()
				return This
			else
				return StzFalseObjectQ()
			ok

		def IsAPair()
			return This.IsPair()

			def IsAPairQ()
				return This.IsPairQ()

	def IsPairOfStrings()
		return This.IsPair() and This.IsListOfStrings()

		def IsAPairOfStrings()
			return This.IsPairOfStrings()

	def IsListOfPairsOfStrings()
		/*
		Coud be solved nicely like this:

			if This.IsListOfPairs() and
			   Check('Q(@EachItem).IsPairOfStrings()' ) = _TRUE_
	
				return _TRUE_
			else
				return _FALSE_
			ok

		But the following solution is more performant...
		*/

		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isString(aContent[i][1]) and isString(aContent[i][2]) )

					bResult = _FALSE_
					exit
			ok
		next

		return bResult


		def IsAListOfPairsOfStrings()
			return This.IsListOfPairsOfStrings()

		def ArePairsOfStrings()
			return This.IsListOfPairsOfStrings()

	def IsPairOfNumbers()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isNumber(aContent[1]) and isNumber(aContent[2])
			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsOnlyPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsOnlyAPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfOnlyPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfOnlyAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfPairOfNumbersOnly()
			return This.IsPairOfNumbers()

		def IsMadeOfAPairOfNumbersOnly()
			return This.IsPairOfNumbers()

		#--

		def IsSection()
			return This.IsPairOfNumbers()

		def IsASection()
			return This.IsPairOfNumbers()

		def ContainsSection()
			return This.IsPairOfNumbers()

		def ContainsASection()
			return This.IsPairOfNumbers()

		def ContainsOnlySection()
			return This.IsPairOfNumbers()

		def ContainsOnlyASection()
			return This.IsPairOfNumbers()

		def ContainsSectionOnly()
			return This.IsPairOfNumbers()

		def ContainsASectionOnly()
			return This.IsPairOfNumbers()

		#>

	def IsListOfPairsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isNumber(aContent[i][1]) and isNumber(aContent[i][2]) )

					bResult = _FALSE_
					exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfPairsOfNumbers()
			return This.IsListOfPairsOfNumbers()

		def IsListOfSections()
			return This.IsListOfPairsOfNumbers()

		def IsAListOfSections()
			return This.IsListOfPairsOfNumbers()

		#--

		def ArePairsOfNumbers()
			return This.IsListOfPairsOfNumbers()

		def AreSections()
			IsListOfPairsOfNumbers

		#>

	def IsPairOfSections()
		aContent = This.Content()
		nLen = len(aContent)

		if isList(aContent[1]) and
		   isList(aContent[2]) and
		   Q(aContent[1]).IsPairOfNumbers() and
		   Q(aContent[2]).IsPairOfNumbers()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfSections()
			return This.IsPairOfSections()

		def ContainsOnlyPairOfSections()
			return This.IsPairOfSections()

		def ContainsOnlyAPairOfSections()
			return This.IsPairOfSections()

		def ContainsPairOfSections()
			return This.IsPairOfSections()

		def ContainsAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfOnlyPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfOnlyAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfPairOfSectionsOnly()
			return This.IsPairOfSections()

		def IsMadeOfAPairOfSectionsOnly()
			return This.IsPairOfSections()

		#>

	def IsListOfPairsOfSections()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT (isList(aContent[i]) and Q(aContent[i]).IsPairOfSections())
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def IsAListOfPairsOfSections()
			return This.IsListOfPairsOfSections

		def ArePairsOfSections()
			return This.IsListOfPairsOfSections()

	def IsPairOfLists()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isList(aContent[1]) and isList(aContent[2])
			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfLists()
			return This.IsPairOfLists()

		def ContainsOnlyPairOfLists()
			return This.IsPairOfLists()

		def ContainsOnlyAPairOfLists()
			return This.IsPairOfLists()

		def ContainsPairOfLists()
			return This.IsPairOfLists()

		def ContainsAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfOnlyPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfOnlyAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfPairOfListsOnly()
			return This.IsPairOfLists()

		def IsMadeOfAPairOfListsOnly()
			return This.IsPairOfLists()

		#>

	def IsPairOfEmptyLists()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and
		   isList(aContent[1]) and len(aContent[1]) = 0 and
		   isList(aContent[2]) and len(aContent[2]) = 0

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsOnlyPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsOnlyAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfOnlyPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfOnlyAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfPairOfEmptyListsOnly()
			return This.IsPairOfEmptyLists()

		def IsMadeOfAPairOfEmptyListsOnly()
			return This.IsPairOfEmptyLists()

		#>

	def IsListOfPairsOfLists()

		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isList(aContent[i][1]) and isList(aContent[i][2]) )

					bResult = _FALSE_
					exit
			ok
		next

		return bResult

		def IsAListOfPairsOfLists()
			return This.IsListOfPairsOfLists()

		def ArePairsOfLists()
			return This.IsListOfPairsOfLists()

	def IsPairOfObjects()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isObject(aContent[1]) and isObject(aContent[2])
			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsOnlyPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsOnlyAPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfOnlyPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfOnlyAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfPairOfObjectsOnly()
			return This.IsPairOfObjects()

		def IsMadeOfAPairOfObjectsOnly()
			return This.IsPairOfObjects()

		#>

	def IsListOfPairsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isObject(aContent[i][1]) and isObject(aContent[i][2]) )

					bResult = _FALSE_
					exit
			ok
		next

		return bResult

		def IsAListOfPairsOfObjects()
			return This.IsListOfPairsOfObjects()

		def ArePairsOfObjects()
			return This.IsListOfPairsOfObjects()

	def IsPairAndKeyIsString()
		return This.IsPair() and isString(This.Item(1))

		#< @FunctionAlternativeForms

		def IsAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def IsPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def IsAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#--

		def IsMadeOfAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def IsMadeOfPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def IsMAdeOfAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#--

		def ContainsAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def ContainsPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def containsAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#>

	def IsPairOfStzObjects()
		return This.IsPair() and This.IsListOfStzObjects()

		#< @FunctionAlternativeForms

		def IsAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsOnlyPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsOnlyAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfOnlyPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfOnlyAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfPairOfStzObjectsOnly()
			return This.IsPairOfStzObjects()

		def IsMadeOfAPairOfStzObjectsOnly()
			return This.IsPairOfStzObjects()

		#>

	def IsPairOfStzNumbers()
		return This.IsPair() and This.IsListOfStzNumbers()

		#< @FunctionAlternativeForms

		def IsAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsOnlyPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsOnlyAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfOnlyPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfOnlyAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfPairOfStzNumbersOnly()
			return This.IsPairOfStzNumbers()

		def IsMadeOfAPairOfStzNumbersOnly()
			return This.IsPairOfStzNumbers()

		#>

	def IsPairOfStzStrings()
		return This.IsPair() and This.IsListOfStzStrings()

		#< @FunctionAlternativeForms

		def IsAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsOnlyPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsOnlyAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfOnlyPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfOnlyAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfPairOfStzStringsOnly()
			return This.IsPairOfStzStrings()

		def IsMadeOfAPairOfStzStringsOnly()
			return This.IsPairOfStzStrings()

		#>

	def IsPairOfStzLists()
		return This.IsPair() and This.IsListOfStzLists()

		#< @FunctionAlternativeForms

		def IsAPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsOnlyPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsOnlyAPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfOnlyPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfOnlyAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfPairOfStzListsOnly()
			return This.IsPairOfStzLists()

		def IsMadeOfAPairOfStzListsOnly()
			return This.IsPairOfStzLists()

		#>

	def IsListOfEmptyLists()
		aContent = This.Content()
		nlen = len(aContent)

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT isList(aContent[i])
				bResult = _FALSE_
				exit
			ok

			if NOT len(aContent[i]) = 0
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsOnlyEmptyLists()
			return This.IsListOfEmptyLists()

		def IsMadeOfEmptyLists()
			return This.IsListOfEmptyLists()

		def IsMadeOfOnlyEmptyLists()
			return This.IsListOfEmptyLists()

		def ItemsAreEmptyLists()
			return This.IsListOfEmptyLists()

		def ItemsAreAllEmptyLists()
			return This.IsListOfEmptyLists()

		def AllItemsAreEmptyLists()
			return This.IsListOfEmptyLists()

		#>

	#--

	def IsNamedObject()
		return _FALSE_

	def IsListOfNamedObjects()
		bResult = _TRUE_

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if NOT ( isList(aContent[i]) and Q(aContent[i]).IsNamedObject() )
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def AreNamedObjects()
			return This.IsListOfNamedObjects()

	#--

	def IsPairOfNumberAndString()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isString(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForm

		def IsAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def IsAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		#--

		def IsMadeOfPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		#--

		def ContainsOnlyPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def ContainsPairOfNumberAndStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def ContainsAPairOfNumberAndStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def ContainsPairOfANumberAndAStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def ContainsAPairOfANumberAndAStringOnly()
			return This.IsPairOfNumberAndString()

		#>

	def IsPairOfStringAndNumber()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isNumber(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def IsAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		#--

		def IsMadeOfPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		#--

		def ContainsOnlyPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def ContainsPairOfStringAndNumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def ContainsAPairOfStringAndNumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def ContainsPairOfAStringAndANumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def ContainsAPairOfAStringAndANumberOnly()
			return This.IsPairOfStringAndNumber()

		#>

	def IsPairOfNumberAndList()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isList(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def IsAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		#--

		def IsMadeOfPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		#--

		def ContainsOnlyPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def ContainsPairOfNumberAndListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def ContainsAPairOfNumberAndListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def ContainsPairOfANumberAndAListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def ContainsAPairOfANumberAndAListOnly()
			return This.IsPairOfNumberAndList()

		#>

	def IsPairOfListAndNumber()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isNumber(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def IsAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		#--

		def IsMadeOfPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		#--

		def ContainsOnlyPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def ContainsPairOfListAndNumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def ContainsAPairOfListAndNumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def ContainsPairOfAListAndANumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def ContainsAPairOfAListAndANumberOnly()
			return This.IsPairOfListAndNumber()

		#>

	def IsPairOfNumberAndObject()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isObject(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def IsAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		#--

		def IsMadeOfPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsMadeOfAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsMAdeOfPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def IsMAdeOfAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		#--

		def ContainsOnlyPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def ContainsPairOfNumberAndObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def ContainsAPairOfNumberAndObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def ContainsPairOfANumberAndAnObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def ContainsAPairOfANumberAndAnObjectOnly()
			return This.IsPairOfNumberAndObject()

		#>

	def IsPairOfObjectAndNumber()
		if This.NumberOfItems() = 2 and isObject(This.Item(1)) and isNumber(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def IsAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		#--

		def IsMAdeOfPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsMAdeOfAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsMadeOfPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def IsMadeOfAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		#--

		def ContainsOnlyPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsPairOfObjectAndNumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsAPairOfObjectAndNumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsPairOfAnObjectAndANumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsAPairOfAnObjectAndANumberOnly()
			return This.IsPairOfObjectAndNumber()

		#>

	def IsPairOfStringAndList()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isList(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def IsAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		#--

		def IsMadeOfPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		#--

		def ContainsOnlyPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def ContainsPairOfStringAndListOnly()
			return This.IsPairOfStringAndList()

		def ContainsOnlyAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def ContainsAPairOfStringAndList()
			return This.IsPairOfStringAndListOnly()

		def ContainsOnlyPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def ContainsPairOfAStringAndAListOnly()
			return This.IsPairOfStringAndList()

		def ContainsOnlyAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def ContainsAPairOfAStringAndAListOnly()
			return This.IsPairOfStringAndList()

		#>

	def IsPairOfListAndString()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isString(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def IsAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		#--

		def IsMadeOfPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsMadeOfAPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsMadeOfPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def IsMadeOfAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		#--

		def ContainsOnlyPairOfListAndString()
			return This.IsPairOfListAndString()

		def ContainsPairOfListAndStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyAPairOfListAndString()
			return This.IsPairOfListAndString()

		def ContainsAPairOfListAndStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def ContainsPairOfAListAndAStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def ContainsAPairOfAListAndAStringOnly()
			return This.IsPairOfListAndString()

		#>

	def IsPairOfStringAndObject()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isObject(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def IsAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		#--

		def IsMadeOfPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		#--

		def ContainsOnlyPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def ContainsPairOfStringAndObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def ContainsAPairOfStringAndObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def ContainsPairOfAStringAndAnObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def ContainsAPairOfAStringAndAnObjectOnly()
			return This.IsPairOfStringAndObject()

		#>

	def IsPairOfObjectAndString()
		if This.NumberOfItems() = 2 and isObject(This.Item(1)) and isString(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def IsAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		#--

		def IsMadeOfPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsMadeOfAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsMadeeOfPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def IsMAdeOfAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		#--

		def ContainsOnlyPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def ContainsPairOfObjectAndStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def ContainsAPairOfObjectAndStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def ContainsPairOfAnObjectAndAStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def ContainsAPairOfAnObjectAndAStringOnly()
			return This.IsPairOfObjectAndString()

		#>

	def IsPairOfListAndObject()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isObject(This.Item(2))
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		def IsAPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		#--

		def IsMadeOfPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfAPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		#--

		def ContainsOnlyPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def ContainsPairOfListAndObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsOnlyAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def ContainsAPairOfListAndObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsPairOfAListAndAnObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsAPairOfAListAndAnObjectOnly()
			return This.IsPairOfListAndObject()

		#>

	#--

	def IsPairOfChars()
		return This.IsPair() and This.IsListOf(:Chars)

		def IsAPairOfChars()
			return This.IsPairOfChars()

	def IsPairOf(pcType)
		return This.IsPair() and This.IsListOf(pcType)

		def IsAPairOf(pcType)
			return This.IsPairOf(pcType)

	def IsListOf(pcType)
		/* EXAMPLES

			Q([ 1, 2, 3 ]).IsListOf(:Number)	#--> _TRUE_

			pcType should be a string containing the name of:
				- a string containing one of the 4 Ring types (given by RingTypes() )
				- a Softanza type ( given by StzTypes() )

			For the sake of expressiveness, pcType can be in plural form:

			Q([ 1, 2, 3 ]).IsListOf(:Numbers)

		*/

		if CheckingParams()
			if NOT isString(pcType)
				StzRaise("Incorrect param type! pcType must be a string.")
			ok
		ok

		pcType = Q(pcType).InfereType()

		if pcType = "number" or pcType = "string" or pcType = "list"

			pcType = "A" + pcType

		but pcType = "object"

			pcType = "An" + pcType
		ok

		cCode1 = 'bOk = item.Is' + pcType + '()'
		if left(pcType, 1) = "A"
			pcType = right(pcType, len(pcType)-1)
		ok
		cCode2 = 'bOk = ( ring_type(item) = "' + upper(pcType) + '" )'

		bResult = _TRUE_
		aList = This.List()
		nLen = len(aList)

		for i = 1 to nLen
			item = aList[i]

			if isObject(item) and Q( ring_classname(item) ).IsStzClassName()
				eval(cCode1)

			else
				eval(cCode2)
			ok

			if NOT bOk
				bResult = _FALSE_
				exit
			ok
		next

		return bResult


		def IsAListOf(pcType)
			return This.IsListOf(pcType)

	def IsStzTree()
		if This.StzClassName() = "stztree"
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAStzTree()
			return This.IsStzTree()

	def IsTable() #TODO // Review this solution
		try
			new stzTable(This.List())
			return _TRUE_
		catch
			return _FALSE_
		done

	def IsPivotTable() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def IsAPivotTable()
			return This.IsPivotTable()

	def IsGraph() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	#=====

	def IsListOfPairsOfStzObjects()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzObjects(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfStzObjects()
			return This.IsListOfPairsOfStzObjects()

	def IsListOfPairsOfStzNumbers()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzNumbers(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult
	
		def ArePairsOfStzNumbers()
			return This.IsListOfPairsOfStzNumbers()

	def IsListOfPairsOfStzStrings()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzStrings(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult
	
		def ArePairsOfStzStrings()
			return This.IsListOfPairsOfStzStrings()

	def IsListOfPairsOfStzLists()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzLists(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfStzlists()
			return This.IsListOfPairsOfStzLists()

	def IsListOfPairsOfNumberAndString()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndString()
			return This.IsListOfPairsOfNumberAndString()

	def IsListOfPairsOfStringAndNumber()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndNumber()
			return This.IsListOfPairsOfStringAndNumber()

	def IsListOfPairsOfNumberAndList()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndlist(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndList()
			return This.IsListOfPairsOfNumberAndList()

	def IsListOfPairsOfListAndNumber()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfListAndNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndNumber()
			return This.IsListOfPairsOfListAndNumber()

	def IsListOfPairsOfNumberAndObject()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndObject()
			return This.IsListOfPairsOfNumberAndObject()

	def IsListOfPairsOfObjectAndNumber()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfObjectAndNumber(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfObjectAndNumber()
			return This.IsListOfPairsOfObjectAndNumber()

	def IsListOfPairsOfStringAndList()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndList()
			return This.IsListOfPairsOfStringAndList()

	def IsListOfPairsOfListAndString()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfListAndString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndString()
			return This.IsListOfPairsOfListAndString()

	def IsListOfPairsOfStringAndObject()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndObject()
			return This.IsListOfPairsOfStringAndObject()

	def IsListOfPairsOfObjectAndString()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOdObjectAndString(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def AreairsOfObjectAndString()
			return This.IsListOfPairsOfObjectAndString()

	def IsListOfPairsOfListAndObject()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfListAndObject(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndObject()
			return This.IsListOfPairsOfListAndObject()

	def IsListOfPairsOfObjectAndList()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfObjectAndList(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ArePairsOfObjectAndList()
			return This.IsListOfPairsOfObjectAndList()

	def IsListOfPairsOfChars()
		bResult = _TRUE_
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfChars(@aContent[i])
				bResult = _FALSE_
				exit
			ok
		next

		return bResult	

		def ArePairsOfChars()
			return This.IsListOfPairsOfChars()

	  #----------------------------#
	 #   SAME TYPE & SAME VALUE   #
	#----------------------------#

	def ItemsHaveSameType()
		return This.IsPureList()

		def AllItemsHaveSameType()
			return This.ItemsHaveSameType()

		def AreOfSametype()
			return This.ItemsHaveSameType()

		def IsMadeOfItemsOfSameType()
			return This.ItemsHaveSameType()

	def ItemsHaveSameValue()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_
		if This.ItemsHaveSameType()
			if This.ItemsAreAllNumbers() or This.ItemsAreAllStrings()
				for i = 2 to nLen		
					if aContent[i] != aContent[i-1]
						bResult = _FALSE_
						exit
					ok
				next

			but This.ItemsAreAllLists()
				for i = 2 to nLen
					oTempList = new stzList(aContent[i])
					if oTempList.IsEqualTo(aContent[i-1])
						bResult = _FALSE_
						exit
					ok
				next

			but ItemsAreAllObjects()
				StzRaise("Can't compare between objects!")
			
			else
				StzRaise("Unsupported type!")
			ok
		else
			bResult = _FALSE_
		ok

		return bResult

		def AllItemsHaveSameValue()
			return This.ItemsHaveSameValue()

		def AreOfSameValue()
			return This.ItemsHaveSameValue()

		def IsMadeOfItemsOfSameValue()
			return This.ItemsHaveSameValue()

	  #-----------------------------------#
	 #  CHECKING IF ALL ITEMS ARE EQUAL  #
	#-----------------------------------#

	def ItemsAreAllEqualCS(pCaseSensitive)

		nLen = This.NumberOfItems()
		if nLen = 0
			return _FALSE_
		but nLen = 1
			return _TRUE_
		ok

		aContent = This.Content()

		oFirstItem = Q(aContent[1])


		bResult = _TRUE_
		for i = 2 to nLen

			if isNumber(aContent[i])
				if NOT aContent[i] = aContent[1]
					bResult = _FALSE_
					exit
				ok

			but isString(aContent[i]) or isList(aContent[i])
				if NOT oFirstItem.IsEqualToCS(aContent[i], pCaseSensitive)
					bResult = _FALSE_
					exit
				ok

			else // isObject(aContent[i])
				if NOT oFirstItem.IsEqualTo(aContent[i])
					bResult = _FALSE_
					exit
				ok
			ok
		next

		return bResult
		
		#< @FunctionAlternativeForms

		def ItemsAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AllItemsAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AreAllEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def IsMadeOfEqualItemsCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def IsMadeOfItemsThatAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		#>

	#-- CASESENSITIVITY

	def ItemsAreAllEqual()
		return This.ItemsAreAllEqualCS(_TRUE_)

		#< @FunctionAlternativeForms

		def ItemsAreEqual()
			return This.ItemsAreAllEqual()

		def AllItemsAreEqual()
			return This.ItemsAreAllEqual()

		def AreEqual(pCaseSensitive)
			return This.ItemsAreAllEqual()

		def AreAllEqual(pCaseSensitive)
			return This.ItemsAreAllEqual()

		def IsMadeOfEqualItems()
			return This.ItemsAreAllEqual()

		def IsMadeOfItemsThatAreEqual()
			return This.ItemsAreAllEqual()

		#>

	  #----------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE EQUAL TO A GIVEN VALUE  #
	#----------------------------------------------------#

	def ItemsAreEqualToCS(pItem, pCaseSensitive)

		bResult = @AreEqualCS(@aContent + pItem, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfItemCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)

		def IsMadeOfThisItemCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)
	
		def ContainsOnlyCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)
	
		def ContainsOnlyItemCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)
	
		def ContainsOnlyThisItemCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)

		#--

		def AllItemsAreCS(pItem, pCaseSensitive)
			return This.ItemsAreEqualToCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsAreEqualTo(pItem)
		return This.ItemsAreEqualToCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def IsMadeOfItem(pItem)
			return This.ItemsAreEqualTo(pItem)

		def IsMadeOfThisItem(pItem)
			return This.ItemsAreEqualTo(pItem)
	
		def ContainsOnly(pItem)
			return This.ItemsAreEqualTo(pItem)
	
		def ContainsOnlyItem(pItem)
			return This.ItemsAreEqualTo(pItem)
	
		def ContainsOnlyThisItem(pItem)
			return This.ItemsAreEqualTo(pItem)

		#--

		def AllItemsAre(pItem)
			return This.ItemsAreEqualTo(pItem)

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE LISTS HAVING SAME NUMBER OF ITEMS  #
	#---------------------------------------------------------------#

	def ContainsOnlyListsWithSameNumberOfItems()
		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok

		if NOT isList(aContent[1])
			return _FALSE_
		ok

		nLenFirst = len(aContent[1])
		if nLenFirst = 1
			return _TRUE_
		ok

		bResult = _TRUE_

		for i = 2 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = nLen )
				bResult = _FALSE_
				exit
			ok

		next
		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreAllListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def AllItemsAreListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def IsMadeOfListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		#--

		def ContainsOnlyUniformLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def ItemsAreAllUniformLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def AllItemsAreUniformLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def IsMadeOfUniformLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		#--

		def ContainsOnlyUniSizeLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def ItemsAreAllUniSizeLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def AllItemsAreUniSizeLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def IsMadeOfUniSizeLists()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		#>
	  #-----------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE STRINGS CONTAINING VALID RING CODES  #
	#-----------------------------------------------------------------#

	def ContainsOnlyValidRingCodes()
		bResult = _TRUE_

		if NOT This.IsListOfStrings()
			return _FALSE_
		ok

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT Q(aContent[i]).IsValidRingCode()
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def AllItemsAreValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

		def ItemsAreAllValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

		def IsMadeOfValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

	  #---------------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE STRINGS CONTAINING SOFTANZA CLASS NAMES  #
	#---------------------------------------------------------------------#

	def ContainsOnlyStzClassNames()
		bResult = _TRUE_

		if NOT This.IsListOfStrings()
			return _FALSE_
		ok

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT Q(aContent[i]).IsStzClassName()
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def AllItemsAreStzClassNames()
			return This.ContainsOnlyStzClassNames()

		def ItemsAreAllStzClassNames()
			return This.ContainsOnlyStzClassNames()

		def IsMadeOfStzClassNames()
			return This.ContainsOnlyStzClassNames()

	  #==========================#
	 #  WALKING THE LIST ITEMS  #
	#==========================#

	#TODO
	# These functions were implemented before we abstracted all
	# the walking feature in a stzWalker class

	# ~> Redesign these functions based on stzWalker class

	def AddWalker(pcName, pnStart, pnEnd, panSteps)

		if CheckingParams()

			if isList(pcName) and StzListQ(pcName).IsNameOrNamedNamedParam()
				pcName = pcName[2]
			ok

			if NOT isString(pcName)
				StzRaise("Incorrect param type! pcName must be a string.")
			ok
		ok

		aWalkers = This.Walkers()
		nLenWalkers = len(aWalkers)

		bNewName = _TRUE_

		for i = 1 to nLenWalkers
			if aWalkers[i][1] = pcName
				bNewName = _FALSE_
				exit
			ok
		next

		if NOT bNewName
			StzRaise(stzListError(:CanNotAddWalkerAlreadyExistant))
		else
			oWalk = new stzWalker(pnStart, pnEnd, panSteps)
			@aWalkers + [ pcName, oWalk.Content() ]
		ok

	def Walkers()
		return @aWalkers

	def Walker(pcWalker)
		return This.Walkers()[pcWalker]

	def FindWalker(pcWalker) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	def RemoveWalker(pcWalker)
		del( @aWalkers, This.FindWalker(pcWalker) )

	def RemoveTheseWalkers(pacNames) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	def RemoveWalkers()
		@aWalkers = []

		def RemoveAllWalkers()
			This.RemoveWalkers()

	def CombineTheseWalkers(pacNames) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def ComposeTheseWalkers(pacNames)
			return This.CombineTheseWalkers(pacNames)

	def CombineWalkers()
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def CombineAllWalkers()
			This.CombineWalkers()

		def ComposeWalkers()
			This.CombineWalkers()

		def ComposeAllWalkers()
			This.CombineWalkers()

	def CombinedWalkers() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def ComposedWalkers()
			return This.CombinedWalkers()

	  #-----------------------------------------------#
	 #  WALKING THE LIST EACH TIME N ITEMS FORWARD   #
	#===============================================#

	def WalkNItemsForward(n)
		return This.WalkNItemsForwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkNStepsForward(n)
			return This.WalkNItemsForward(n)

		def WalkForward(n)
			return This.WalkNItemsForward(n)

		def WalkNForward(n)
			return This.WalkNItemsForward(n)

		#--

		def WalkEachTimeNSItemsForward(n)
			return This.WalkNItemsForward(n)

		def WalkEachTimeNStepsForward(n)
			return This.WalkNItemsForward(n)

		#>

	def WalkNItemsForwardXT(n, pReturn)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param! n must be a number.")
			ok
	
			if isList(pReturn) and
			   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])
	
				pReturn = pReturn[2]
			ok
	
			if NOT ( isString(pReturn) and
	
				 ring_find([
					:WalkedPositions, :WalkedItems,
					:LastPosition, :LastWalkedPosition,
					:LastItem, :LastWalkedItem,
					:Default
				], pReturn) > 0 )
	
				StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
					 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
			ok
		ok

		# Doing the job

		_anPos_ = []
		_nLen_ = This.NumberOfItems()

		for @i = 1 to _nLen_ step n
			_anPos_ + @i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(_anPos_)

		but pReturn = :WalkedPositions
			return _anPos_

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(_anPos_))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return _anPos_[len(_anPos_)]

		else
			return _anPos_
		end

		#< @FunctionAlterntives

		def WalkNStepsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkNForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		#--

		def WalkEachTimeNSItemsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkEachTimeNStepsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		#>

	  #-----------------------------------------------#
	 #  WALKING THE LIST EACH TIME N ITEMS BACKWARD  #
	#-----------------------------------------------#

	def WalkNItemsBackward(n)
		return This.WalkNItemsBackwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkNStepsBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkNBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkBackward(n)
			return This.WalkNItemsBackward(n)

		#--

		def WalkEachTimeNItemsBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkEachTimeNStepsBackward(n)
			return This.WalkNItemsBackward(n)

		#>

	def WalkNItemsBackwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = []

		for i = This.NumberOfItems() to 1 step -n
			anPos + i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkNStepsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkNBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		#--

		def WalkEachTimeNItemsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkEachTimeNStepsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		#>

	  #-------------------#
	 #  WALKING BETWEEN  #
	#===================#

	def WalkBetween(n1, n2)
		return This.WalkBetweenIB(n1, n2, :WalkedPositions)

	def WalkBetweenIB(n1, n2, pReturn)

		# Checking params

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :Position, :Positions ])
			n1 = n1[2]
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :Position, :AndPosition, :And ])
			n2 = n2[2]
		ok

		if NOT Q([ n1, n2 ]).BothAreNumbers()
			StzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		anPos = []
		nLen = This.NumberOfItems()

		anPos = n1 : n2

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #-----------------------------------#
	 #  WALKING THE LIST FORTH AND BACK  #
	#===================================#

	def WalkForthAndBack()
		return This.WalkForthAndBackXT(:Return = :WalkedPositions)

	def WalkForthAndBackXT(pReturn)

		# Checking pReturn param

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0)

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		nLen = This.NumberOfItems()
		anPos = 1 : nLen

		for i = nLen-1 to 1 step -1
			anPos + i
		next
		
		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #-----------------------------------#
	 #  WALKING THE LIST BACK AND FORTH  #
	#===================================#

	def WalkBackAndForth()
		return This.WalkBackAndForthXT(:Return = :WalkedPositions)

	def WalkBackAndForthXT(pReturn)

		# Checking pReturn param

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		nLen = This.NumberOfItems()
		anPos = nLen : 1

		for i = 2 to nLen
			anPos + i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #-----------------#
	 #  WALKING WHERE  #
	#=================#

	def WalkWhere(pcCondition)
		return This.WalkWhereXT(pcCondition, :Forward, :Return = :WalkedPositions)

		def WalkW(pcCondition)
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			return This.WalkWhere(pcCondition)

	def WalkWhereXT(pcCondition, pcDirection, pReturn)
		/*
		o1 = new stzList([ 1, "A", 3, "B", "_", 6 ])

		? WalkWhere("isNumber(@item)")
		#--> [1, 3, 6]
		*/

		# Checking params

		if CheckingParams()
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
	
			if isList(pReturn) and
			   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])
	
				pReturn = pReturn[2]
			ok
	
			if NOT ( isString(pReturn) and
	
				 ring_find([
					:WalkedPositions, :WalkedItems,
					:LastPosition, :LastWalkedPosition,
					:LastItem, :LastWalkedItem,
					:Default
				], pReturn) > 0 )
	
				StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
					 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
			ok
	
			if pReturn = :Default
				pReturn = :WalkedPositions
			ok
	
			if isList(pcDirection) and
			   ring_find([ :Direction, :Going ], pcDirection) > 0
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and
				 ring_find([ :Forward, :Backward, :Default ], pcDirection) > 0 )
	
				StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
			ok
	
			if pcDirection = :Default
				pcDirection = :Forward
			ok
		ok

		# Doing the job

		anPos = []

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				anPos + @i
			ok
	
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		def WalkWXT(pcCondition, pReturn)
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			return This.WalkWhereXT(pcCondition, pReturn)

	  #--------------------------------------------#
	 #  WALKING UNTIL (AND WALKING UNTIL BEFORE)  #
	#============================================#

	def WalkUntil(pcCondition)
		return This.WalkUntilXT(pcCondition, :Forward, :WalkedPositions)

	def WalkUntilBefore(pcCondition)
		return This.WalkUntil( :Before = pcCondition )

	def WalkUntilXT(pcCondition, pcDirection, pReturn)
		/*
		[ "A", "B", 12, "C", "D", "E", 4, "F", 25, "G", "H" ]

		WalkUntil("@item = 'D'", :Return = :WalkedPositions  )  #--> 1:5
		WalkUntil("@item = 'D'", :Return = :LastPosition )  #--> 5

		WalkUntil("@item = 'D'", :Return = :WalkedItems )
		#--> [ "A", "B", 12, "C", "D" ]

		WalkUntil("@item = 'D'", :Return = :LastItem ) #--> "D"


		WalkUntil("isNumber(@item)") #--> 1:3
		WalkUntil("isNumber(@item) and @item > 20") #--> 1:9
		*/

		bWalkBefore = _FALSE_

		# Checking the params

		if isList(pcCondition) and Q(pcCondition).IsBeforeNamedParam()
			bWalkBefore = _TRUE_
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn)  > 0)

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 ring_find([ :Forward, :Backward, :Default ], pcDirection) > 0 )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok
		# Doing the job

		cCode = 'bOk = ( ' +  StzCCodeQ(pcCondition).Transpiled() + ' )'

		bFound = _FALSE_
		aList = This.Content()
		nLen = This.NumberOfItems()

		anPos = []

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				if bWalkBefore = _FALSE_
					anPos + @i
				ok

				exit
			ok

			anPos + @i
			
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	def WalkUntilBeforeXT(pcCondition, pReturn)
		return This.WalkUntilXT( :Before = pcCondition, pReturn)

	  #-----------------#
	 #  WALKING WHILE  #
	#=================#

	def WalkWhile(pcCondition)
		return This.WalkWhileXT(pcCondition, :Forward, :WalkedPositions)

	def WalkWhileXT(pcCondition, pcDirection, pReturn)
		/*
		o1 = new stzList([ "A", "B", "_", "*", 12, "C", "D", 4 ])

		? WalkWhile("Q(@item).IsNotNumber()")
		#--> 1:4
		*/

		# Checking params

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 ring_find([ :Forward, :Backward, :Default ], pcDirection) > 0 )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if NOT bOk
				exit
			ok

			anPos + @i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #----------------#
	 #  WALKING WHEN  #
	#================#

	def WalkWhen(pcCondition)
		return This.WalkWhenXT(pcCondition, :Forward, :WalkedPositions)

	def WalkWhenXT(pcCondition, pcDirection, pReturn)

		# Checking params

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 ring_find([ :Forward, :Backward, :Default ], pcDirection) > 0 )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				anPos = @i : nEnd
				exit
			ok

			
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #----------------------------------------------------#
	 #  WALKING THE LIST EACH TIME N MORE ITEMS FORWARD   #
	#====================================================#

	def WalkNProgressiveItemsForward(n)
		return This.WalkNProgressiveItemsForwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkProgressiveNItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkNProgressiveStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNProgressiveStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkProgressiveNStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkNMoreItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNMoreItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkNMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkMoreNItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkNMoreForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkMoreForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#==

		def WalkNCumulativeItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNCumulativeItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkCumulativeNItemsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		#--

		def WalkNCumulativeStepsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		def WalkEachTimeNCumulativeStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkCumulativeNStepsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		#>

	def WalkNProgressiveItemsForwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		nLen = This.NumberOfItems()
		anPos = []

		if n < 0

			StzRaise("Can't proceed. n must be positive!")
		but n = 0
			anPos = [1]

		else
			anPos = [1]
			nstep = 1
			i = 0
			
			while nStep <= nLen
				i++
				nStep += (n * i)
				if nStep <= nLen
					anPos + nStep
				ok
			end

		ok

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkProgressiveNItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkNProgressiveStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNProgressiveStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkProgressiveNStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkNMoreItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNMoreItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkNMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkMoreNItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkNMoreForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkMoreForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#==

		def WalkNCumulativeItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNCumulativeItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkCumulativeNItemsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		#--

		def WalkNCumulativeStepsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		def WalkEachTimeNCumulativeStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkCumulativeNStepsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		#>

	  #------------------------------------------------------------#
	 #  WALKING THE LIST EATCH TIME N PROGRESSIVE ITEMS BACKWARD  #
	#------------------------------------------------------------#

	def WalkNProgressiveItemsBackward(n)
		return This.WalkNProgressiveItemsBackwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkProgressiveNItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkNProgressiveStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNProgressiveStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkProgressiveNStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkNMoreItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNMoreItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkNMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkMoreNItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkNMoreBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkMoreBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#==

		def WalkNCumulativeItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNCumulativeItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkCumulativeNItemsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		#--

		def WalkNCumulativeStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		def WalkEachTimeNCumulativeStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)


		def WalkCumulativeNStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		#>

	def WalkNProgressiveItemsBackwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		nLen = This.NumberOfItems()
		anPos = []

		if n < 0
			StzRaise("Can't proceed. n must be positive!")

		but n = 0
			anPos = [ nLen ]

		else
			anPos = [ nLen ]
			nStep = nLen
			i = 0
			
			while nStep > 0
				i++
				nStep -= (n * i)
				if nStep > 0
					anPos + nStep
				ok
			end
	
		ok

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkProgressiveNItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkNProgressiveStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNProgressiveStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkProgressiveNStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkNMoreItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNMoreItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkNMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkMoreNItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkNMoreBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkMoreBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#==

		def WalkNCumulativeItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNCumulativeItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkCumulativeNItemsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		#--

		def WalkNCumulativeStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		def WalkEachTimeNCumulativeStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)


		def WalkCumulativeNStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		#>

	  #================================================#
	 #  WALKING N ITEMS FORWARD AND N ITEMS BACKWARD  #
	#================================================#

	def WalkNItemsForwardNItemsBackward(pnForward, pnBackward)
		return This.WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsForwardNItemsBackward(pnForward, pnBackward)
			return This.WalkNItemsForwardNItemsBackward(pnForward, pnBackward)


		def WalkNStepsForwardNStepsBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		def WalkEachTimeNStepsForwardNStepsBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)


		def WalkNForwardNBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		def WalkForwardBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		#>

	def WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		# Checking params

		if NOT Q([pnForward, pnBackward]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnForward and pnBackward must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		if pnForward = pnBackward
			return []
		ok

		if pnBackward > pnForward
			nStart = pnBackward - pnForward + 1
		else
			nStart = 1
		ok

		i = nStart
		anPos = [ i ]

		while (i + pnForward) >= 1 and (i + pnForward) <= nLen and
		      (i + pnForward - pnBackward) >= 1 and (i + pnForward - pnBackward) <= nLen

			i = i + pnForward
			anPos + i

			i = i - pnBackward
			anPos + i

		end

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end
	
		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)


		def WalkNStepsForwardNStepsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkEachTimeNStepsForwardNStepsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkNForwardNBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkForwardBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		#>

	  #------------------------------------------------#
	 #  WALKING N ITEMS FORWARD AND N ITEMS BACKWARD  #
	#------------------------------------------------#

	def WalkNItemsBackwardNItemsForward(pnBackward, pnForward)
		return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsBackwardNItemsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)


		def WalkNStepsBackwardNStepsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)

		def WalkEachTimeNStepsBackwardNStepsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)


		def WalkNBackwardNForward(pnForward, pnBackward)
			return This.WalkNITemsBackwardNItemsForward(pnForward, pnBackward)

		def WalkBackwardForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)

		#>

	def WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		# Checking params

		if NOT Q([pnBackward, pnForward]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnForward and pnBackward must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		if pnForward = pnBackward
			return []
		ok

		if pnForward > pnBackward
			nStart = nLen - pnBackward
		else
			nStart = nLen
		ok

		i = nStart
		anPos = [ nStart ]

		while ( (i - pnBackward) >= 1 and (i - pnBackward) <= nLen ) and
		      ( (i - pnBackward + pnForward) >= 1 and (i - pnBackward + pnForward) <= nLen )

			i = i - pnBackward
			anPos + i

			i = i + pnForward
			anPos + i

		end

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)


		def WalkNStepsBackwardNStepsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		def WalkEachTimeNStepsBackwardNStepsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)


		def WalkNBackwardNForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNITemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		def WalkBackwardForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		#>

	  #===================================================#
	 #  WALKING N STEPS FROM START AND N STEPS FROM END  #
	#===================================================#

	def WalkNItemsFromStartNItemsFromEnd(nFromStart, nFromEnd)
		return This.WalkNItemsFromStartNItemsFromEndXT(nFromStart, nFromEnd, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)


		def WalkNStepsFromStartNStepsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkEachTimeNStepsFromStartNStepsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)


		def WalkNFromStartNFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkFromStartFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkNStartNEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkStartEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		#>

	def WalkNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		# Checking params

		if NOT Q([pnFromStart, pnFromEnd]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnFromStart and pnFromEnd must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		anPos = [ 1 ]

		for i = 1 to nLen
			nPosFromStart = i + pnFromStart
			nPosFromEnd   = nLen - i - pnFromEnd + 1

			if nPosFromEnd >= nPosFromStart
				anPos + nPosFromStart
				if nPosFromEnd != nPosFromStart
					anPos + nPosFromEnd
				ok
			ok
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end
	
		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)


		def WalkNStepsFromStartNStepsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkEachTimeNStepsFromStartNStepsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkNFromStartNFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkFromStartFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkNStartNEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkStartEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		#>

	  #---------------------------------------------------#
	 #  WALKING N ITEMS FROM END AND N ITEMS FROM START  #
	#---------------------------------------------------#

	def WalkNItemsFromEndNItemsFromStart(pnFromEnd, pnFromStart)
		return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)


		def WalkNStepsFromEndNStepsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkEachTimeNStepsFromEndNStepsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)


		def WalkNFromEndNFromStart(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkFromEndFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkNEndNStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkEndStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		#>

	def WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		# Checking params

		if NOT Q([ pnFromEnd, pnFromStart ]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnFromStart and pnFromEnd must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 ring_find([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			], pReturn) > 0 )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		anPos = [ 7 ]

		for i = nLen to 1 step -1

			nPosFromEnd   = i - pnFromEnd
			nPosFromStart = nLen - i + 1

			if nPosFromEnd >= nPosFromStart
				anPos + nPosFromEnd
				
				if nPosFromStart != nPosFromEnd
					anPos + nPosFromStart
				ok
			ok
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)


		def WalkNStepsFromEndNStepsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkEachTimeNStepsFromEndNStepsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)


		def WalkNFromEndNFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNITemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkFromEndFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkNEndNStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkEndStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		#>

	  #===========================================#
	 #   EXPANDING THE LIST OF PAIR OF NUMBERS   #
	#===========================================#

	/* Example
		o1 = new stzList([ 12, 7 ])
		? o1.ExpandedIfPairOfNumbers() #--> [ 12, 11, 10, 9, 8, 7 ]
	*/

	def ExpandIfPairOfNumbers() #TODO // Should be delegated to stzPairOfNumbers
		if This.IsPairOfNumbers()
			n1 = This.Item(1)
			n2 = This.Item(2)

			anResult = n1 : n2

			This.UpdateWith( anResult )
		ok

		def ExpandIfPairOfNumbersQ()
			This.ExpandIfPairOfNumbers()
			return This

	def ExpandedIfPairOfNumbers()
		bResult = This.Copy().ExpandIfPairOfNumbersQ().Content()
		return bResult

	  #=============================================#
	 # REDUCING THE LIST BY CUMULATIONG ITS ITEMS  #
	#=============================================#
	# Only the last cumulated item is returned

	def Cumulate()

		nLen = len(@aContent)
		if nLen = 0
			return _NULL_
		but nLen = 1
			return @aContent[1]
		ok

		cumul = @aContent[1]

		if This.IsMadeOfNumbers() or
		   This.IsMadeOfStrings()

			for i = 2 to nLen
				cumul += @aContent[i]
			next

			return cumul

		but This.StartsWithAList()

			aResult = @aContent[1]

			for i = 2 to nLen
				aResult + @aContent[i]
			next

			return aResult

		else
			StzRaise("Can't proceed! The list must be made of only numbers, or strings, or lists.")
		ok

		def Reduce()
			return This.Cumulate()

	  #---------------------------------------------------------#
	 # REDUCING THE LIST BY CUMULATIONG ITS ITEMS -- EXTENDED  #
	#---------------------------------------------------------#
	# All the cumulated items are returned

	def CumulateXT()
		nLen = len(@aContent)
		if nLen = 0
			return []
		but nLen = 1
			return @aContent
		ok

		
		cumul = @aContent[1]
		aResult = [ cumul ]

		if This.IsMadeOfNumbers() or
		   This.IsMadeOfStrings()

			for i = 2 to nLen
				cumul += @aContent[i]
				aResult + cumul
			next

			return aResult

		but This.StartsWithAList()
			aResult = [ @aContent[1] ]
			aCumul = @aContent[1]

			for i = 2 to nLen
				aCumul + @aContent[i]
				aResult + aCumul
			next

			return aResult
		else
			StzRaise("Can't proceed! The list must be made of only numbers, or strings, or lists.")
		ok

		def ReduceXT()
			return This.CumulateXT()

	  #==================================================#
	 #  CHECKING IF THE LIST IS EQUAL TO AN OTHER LIST  #
	#==================================================#

	def IsEqualToCS(paOtherList, pCaseSensitive)
		/*
		Two lists are equal when they have:
			1. same type
			2. same number of items AND
			3. same content
		*/

		# A check made to enable some external code
		# In Ring context use IsEqualToQ()

		if isObject(paOtherList)

			content = paOtherList.Content()

			if isList(content) and
		  	   len(content) = len(This.List()) and
		  	   This.HasSameContentAsCS(content, pCaseSensitive)

				return paOtherList
			else
				return _FALSE_
			ok
		ok

		if NOT isList(paOtherList)
			return _FALSE_
		ok

		# Doublechecking for potential performance gain

		if This.NumberOfItems() != len(paOtherList)
			return _FALSE_
		ok

		if isList(paOtherList) and
		   len(paOtherList) = len(This.List()) and
		   This.HasSameContentAsCS(paOtherList, pCaseSensitive)

			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionFluentForm

		def IsEqualToCSQ(paOtherList)

			bResult = _FALSE_

			if isList(paOtherList)
				bResult = This.IsEqualToCS(paOtherList, pCaseSensitive)
				
			ok

			if bResult = _TRUE_
				return This
			else
				return new stzFalsObject
			ok

		#>

		#< @FunctionAlternativeForms

		def IsEqualCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsEqualToCS(paOtherList, pCaseSensitive)

		def EqualsCS(paOtherList, pCaseSensitive)
			return This.IsEqualToCS(paOtherList, pCaseSensitive)

		#>

		#< @FunctionNegativeForm

		def IsNotEqualToCS(paOtherList, pCaseSensitive)
			return NOT This.IsEqualToCS(paOtherList, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtToCS(pcOtherList, pCaseSensitive)
			return This.IsEqualToCS(pcOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(paOtherList)
		return This.IsEqualToCS(paOtherList, _TRUE_)

		def IsEqualToQ(paOtherList)
			return This.IsEqualToCSQ(paOtherList, _TRUE_)

		#< @FunctionAlternativeForms

		def IsEqual(paOtherList)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsEqualTo(paOtherList)

			def IsEqualQ(paOtherList)
				return This.IsEqualToQ(paOtherList)

		def Equals(paOtherList)
			return This.IsEqualTo(paOtherList)

			def EqualsQ(paOtherList)
				return This.IsEqualToQ(paOtherList)

		#>

		#< @FunctionNegativeForm

		def IsNotEqualTo(paOtherList)
			return NOT This.IsEqualTo(paOtherList)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtTo(pcOtherList)
			return This.IsEqualTo(pcOtherList)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST IS STRICTLY EQUAL TO AN OTHER LIST  #
	#-----------------------------------------------------------#

	def IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		/*
		Tow lists are striclty equal when:
			1. they are equal (in the sense of IsEqualTo() method)
			2. they have same order of items (ItemsHaveSameOrder())
		*/
		
		if This.IsEqualToCS(paOtherList, pCaseSensitive) and
		   This.ItemsHaveSameOrderAs(paOtherList)
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsStrictlyEqualCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		def IsIdenticalToCS(paOtherList, pCaseSensitive)
			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		def IsIdenticalCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(paOtherList)
		return This.IsStrictlyEqualToCS(paOtherList, _TRUE_)

		#< @FunctionAlternativeForms

		def IsStrictlyEqual(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualTo(paOtherList)

		def IsIdenticalTo(paOtherList)
			return This.IsStrictlyEqualTo(paOtherList)

		def IsIdentical(paOtherList)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualTo(paOtherList)

		#>

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST IS QUEIT EQUAL TO AN OTHER LIST  #
	#--------------------------------------------------------#

	def IsQuietEqualTo(paOtherList)
		if StzListQ(paOtherList).IsToNamedParam()
			paOtherList = paOtherList[2]
		ok

		if This.IsEqualTo(paOtherList)
			return _TRUE_
		ok

		nDif = abs(This.NumberOfItems() - StzListQ(paOtherList).NumberOfItems())
		n = nDif / This.NumberOfItems()
		
		if n < QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return _TRUE_
		ok

		return _FALSE_

		def IsQuietEqual(paOtherList)
			return This.IsQuietEqualTo(paOtherList)

		def IsApproximativelyEqual(paOtherList)
			return This.IsQuietEqualTo(paOtherList)

		def IsApproximativelyEqualTo(paOtherList)
			return This.IsQuietEqualTo(paOtherList)

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS NEITHER EQUAL TO A GIVEN LIST NOR TO AN OTHER  #
	#-------------------------------------------------------------------------#

	def IsNeitherCS(paList1, paList2, pCaseSensitive)
		if CheckingParams()
			if isList(paList1) and Q(paList1).IsEqualToNamedParam()
				paList1 = paList1[2]
			ok

			if isList(palist2) and Q(paList2).IsNorNamedParam()
				paList2 = paList2[2]
			ok

			if @BothAreStrings(paList1, paList2)
				return This.@IsNeither(paList1, paList2)
			ok

			if NOT @BothAreLists(paList1, paList2)
				StzRaise("Incorrect param type! paList1 and paList2 must both be lists.")
			ok
		ok

		bEqualToList1 = This.IsEqualToCS(paList1, pCaseSensitive)
		bEqualToList2 = This.IsEqualToCS(paList2, pCaseSensitive)

		if NOT bEqualToList1 and NOT bEqualToList2
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsNeitherEqualToCS(paList1, paList2, pCaseSensitive)
			return This.IsNeitherCS(paList1, paList2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVITY

	def IsNeither(paList1, paList2)
		return This.IsNeitherCS(paList1, paList2, _TRUE_)

		def IsNeitherEqualTo(paList1, paList2)
			return This.IsNeither(paList1, paList2)

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS SAME ORDER AS AN OTHER LIST  #
	#--------------------------------------------------------#

	def ItemsHaveSameOrderAs(paOtherList)

		if CheckingParams()
			if isList(paOtherList) and StzListQ(paOtherList).IsAsNamedParam()
				paOtherList = paOtherList[2]
			ok

			if NOT isList(paOtherList)
				StzRaise("Incorrect param type! paOtherList must be a list.")
			ok
		ok

		if This.SortingOrder() = StzListQ(paOtherList).SortingOrder()
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms
	
		def ItemsHaveSameOrder(paOtherList)
			return This.ItemsHaveSameOrderAs(paOtherList)

		def ItemsHaveSameSortingOrderAs(paOtherList)
			return This.ItemsHaveSameOrderAs(paOtherList)

		def ItemsHaveSameSortingOrder(paOtherList)
			return This.ItemsHaveSameOrderAs(paOtherList)

		#>

	  #==========================================================#
	 #  CHECKING IF ALL THE ITEMS ARE EIGTHER NUMBERS OR ITEMS  #
	#==========================================================#

	def AllItemsAreNumbersOrStrings()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _TRUE_
		for i = 1 to nLen
			if NOT (isNumber(aContent[i]) or isString(aContent[i]))
				bResult = _FALSE_
				exit
			ok
		next
		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AllItemsAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def ItemsAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def IsMadeOfNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def IsMadeOfStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		#--

		def AreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def AreAllNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AreAllStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def AllAreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AllAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING IF THE LIST IS MADE OF A NUMBER AND A STRING  #
	#---------------------------------------------------------#

	def IsMadeOfANumberAndAString()
		acContent = This.Content()
		nLen = len(aContent)

		if nLen != 2
			return _FALSE_
		ok

		if ( isNumber(acContent[1]) and isString(acContent[2]) ) OR
		   ( isString(acContent[1]) and isNumber(acContent[2]) )

			return _TRUE_

		else

			return _FALSE_
		ok


		def IsMadeOfAStringAndANumber()
			return This.IsMadeOfANumberAndAString()

	  #----------------------------------------------------------#
	 #  CHECKING IF ALL THE ITEMS ARE EIGTHER NUMBERS OR ITEMS  #
	#==========================================================#

	def AllItemsAreNumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)

		bGotANumber = _FALSE_
		bGotAString = _FALSE_

		for i = 1 to nLen
			if isNumber(aContent[i])
				bGotANumber = _TRUE_
			but isString(aContent[i])
				bGotAString = _TRUE_
			ok

			if isNumber(aContent[i]) and bGotANumber
				i++

			but isString(aContent[i]) and bGotAString
				i++
			ok

		next

		bResult = bGotANumber AND bGotAString

		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreNumbersAndStrings()
			return This.AllItemsAreNumbersAndStrings()

		def AllItemsAndStringsOrNumbers()
			return This.AllItemsAndNumbersAndStrings()

		def ItemsAndStringsOrNumbers()
			return This.AllItemsAndNumbersAndStrings()

		def IsMadeOfNumbersAndStrings()
			return This.AllItemsAreNumbersAndStrings()

		def IsMadeOfStringsAndNumbers()
			return This.AllItemsAreNumbersAndStrings()

		#>

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 NUMBERS  #
	#===========================================#

	def BothAreNumbers()
		if This.NumberOfItems() = 2 and
		   isNumber(This.Item(1)) and isNumber(This.Item(2))

			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsTwoNumbers()
			return This.BothAreNumbers()

		def Contains2Numbers()
			return This.BothAreNumbers()

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 STRINGS  #
	#-------------------------------------------#

	def BothAreStrings()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and isString(This.Item(2))

			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsTwoStrings()
			return This.BothAreStrings()

		def Contains2Strings()
			return This.BothAreStrings()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 LISTS  #
	#-----------------------------------------#

	def BothAreLists()
		if This.NumberOfItems() = 2 and
		   isList(This.Item(1)) and isList(This.Item(2))

			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsTwoLists()
			return This.BothAreLists()

		def Contains2Lists()
			return This.BothAreLists()

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 OBJECTS  #
	#-------------------------------------------#

	def BothAreObjects()
		if This.NumberOfItems() = 2 and
		   isObject(This.Item(1)) and isObject(This.Item(2))

			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsTwoObjects()
			return This.BothAreObjects()

		def Contains2Objects()
			return This.BothAreObjects()

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST IS THE REVERSE OF AN OTHER LIST  #
	#--------------------------------------------------------#
	 #TODO // check performance

	def IsReverseOf(paOtherList)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		nLen = This.NumberOfItems()
		nLenOtherList = len(paOtherList)

		if nLen != nLenOtherList
			return _FALSE_
		ok

		aContent = This.Content()

		bResult = _TRUE_
		for i = 1 to nLen
			if Q(aContent[i]).IsDifferentFrom( paOtherList[ nLenOtherList - i + 1 ] )
				bResult = _FALSE_
				exit
			ok
		next i

		return bResult

		#< @FunctionAlternativeForms

		def IsReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsInverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)
		
		def IsInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAnInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAnInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#==

		def IsTheReverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsTheReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsTheInverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)
		
		def IsTheInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsTheInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#>

	  #-------------------------------------#
	 #  REVERSING ITEMS ORDER IN THE LIST  #
	#-------------------------------------#

	def Reverse()

		aResult = ring_reverse( This.List() )
		This.Update( aResult )

		def ReverseQ()
			This.Reverse()
			return This

		#< @FunctionAlternativeForms

		def ReverseOrder()
			This.Reverse()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		def ReverseItems()
			This.Reverse()

			def ReverseItemsQ()
				This.ReverseItems()
				return This

		def ReverseItemsOrder()
			This.Reverse()

			def ReverseItemsOrderQ()
				This.ReverseItemsOrder()
				return This

		#>

	def Reversed()
		aResult = This.Copy().ReverseQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ItemsReversed()
			return This.Reversed()

		def ItemsOrderReversed()
			return This.Reversed()

		def OrderReversed()
			return This.Reversed()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS MORE ITEMS THAN AN OTHER LIST  #
	#----------------------------------------------------------#

	def HasMoreNumberOfItems(paOtherList)
		if isList(paOtherList) and Q(paOtherList).IsThanNamedParam()
			paOtherList = paOtherList[2]
		ok

		if This.NumberOfItems() > len(paOtherList)
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def HasMoreNumberOfItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def HasMoreItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def HasMoreItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		#--

		def ContainsMoreNumberOfItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreNumberOfItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		#--

		def IsLarger(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def IsLargerThen(panOtherList)
			return This.HasMoreNumberOfItems(paOtherList)
	
		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS LESS ITEMS THAN AN OTHER LIST  #
	#----------------------------------------------------------#

	def HasLessNumberOfItems(paOtherList)
		if isList(paOtherList) and Q(paOtherList).IsThanNamedParam()
			paOtherList = paOtherList[2]
		ok

		if This.NumberOfItems() < len(paOtherList)
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def HasLessNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasLessItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasLessItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def ContainsLessNumberOfItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def IsSmaller(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def IsSmallerThen(panOtherList)
			return This.HasLessNumberOfItems(paOtherList)
	
		#--

		def HasFewerNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasFewerItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasFewerItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def ContainsFewerNumberOfItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF A GIVEN VALUE IS ALSO A LIST  #
	#--------------------------------------------#

	def HasSameTypeAs(p)
		return isList(p)

		def HasSameType(p)
			return This.HasSameTypeAs(p)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF LIST HAS THE SAME CONTENT AS AN OTHER LIST OR ITEM  #
	#--------------------------------------------------------------------#

	def HasSameContentCS(paOtherList, pCaseSensitive)
		if CheckingParams()
			if isList(paOtherList) and Q(paOtherList).IsAsNamedParam()
				paOtherList = paOtherList[2]
			ok
	
			if NOT isList(paOtherList)
				StzRaise("Incorrect param type! paOtherList must be a list.")
			ok
		ok

		nLen1 = len(@aContent)
		nLen2 = len(paOtherList)

		if EarlyCheck()

			# The two lists must have same number of items

			if NOT nLen1 = nLen2
				return _FALSE_
			ok
		ok

		# Doing the job

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		if bCaseSensitive = _FALSE_
			acList1 = This.StringifyQ().SortQ().Lowercased()
			acList2 = StzListQ(paOtherList).StringifyQ().SortQ().Lowercased()

		else
			acList1 = This.StringifyQ().Sorted()
			acList2 = StzListQ(paOtherList).StringifyQ().Sorted()
		ok

		bresult = _TRUE_

		for i = 1 to nLen1
			if NOT acList1[i] = acList2[i]
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def HasSameContentAsCS(paOtherList, pCaseSensitive)
			return This.HasSameContentCS(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasSameContent(paOtherList)
		return This.HasSameContentCS(paOtherList, _TRUE_)

		def HasSameContentAs(paOtherList)
			return This.HasSameContent(paOtherList)

	  #==================================================#
	 #  CHECKING IF ALL THE ITEMS ARE CONTIGUOUS LISTS  #
	#==================================================#

	def AllItemsAreContiguousLists()

		nLen = len(@aContent)

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT isList(item)
				bResult = _FALSE_
				exit
			ok

			if StzListQ(item).IsContiguous()
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def AllItemsAreContinuousLists()
			return This.AllItemsAreContiguousLists()

	  #=====================================#
	 #    CLASSIFYING (OR CATEGORIZING)    #
	#=====================================#
	
	def Classify()

		/* EXAMPLE

		aList = [
			:Arabic,
			:Arabic,
			:French,
			:English,
			:Spanish,
			:Spanish,
			:English,
			:Arabic
		]
		
		StzListQ(aList) {
		 	? ClassifyZ()
			#--> [
			# 	:Arabic  = [ 1, 2, 8 ],
			# 	:French  = [ 3 ],
			# 	:Enslish = [ 4, 7 ],
			#    	:Spanish = [ 5, 6 ]
			#    ]
		}
		*/

		acContent = This.StringifyQ().Lowercased()

		nLen = len(acContent)
		anPosUndefined = []
		acSeen = []

		aResult = []

		for i = 1 to nLen
			
			if isString(acContent[i])

				if acContent[i] = :@NullObject or
				   acContent[i] = :@TrueObject or
				   acContent[i] = :@FalseObject

					anPosUndefined + i
					loop
				ok

				if ring_find(acSeen, acContent[i]) = 0
					aResult + [ acContent[i], [i] ]
					acSeen + acContent[i]

				else
					aResult[ acContent[i] ] + i
					
				ok
			else
				anPosUndefined + i
			ok
		next

		if len(anPosUndefined) > 0
			aResult + [ :@Undefined, anPosUndefined ]
		ok

		return aResult

		#< @FunctionFluentForms

		def ClassifyQ()
			return This.ClassifyQRT(:stzList)

		def ClassifyQRT(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Classify() )

			on :stzListOfHashList
				return new stzHashList( This.Classify() )

			other
				StzRaise("Unssupported return type!")

			off
		#>

		#< @FunctionAlternativeForm

		def classified()
			return this.classify()

		#>

	  #------------------------------------------#
	 #  CLASSIFYING THE LIST ON A GIVEN COLUMN  #
	#------------------------------------------#

	def ClassifyOn(pnColNumber)

	  #--------------------------------------------#
	 #   GETTING THE LIST OF CLASSES IN THE LIST  #
	#============================================#

	def Classes()

		aClasses = StzHashListQ( This.Classify() ).Keys()
		return aClasses


		#< @FunctionFluentForm

		def ClassesQ()
			return This.ClassesQRT(:stzList)

		def ClassesQRT(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Classes() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Classes() )

			other
				StzRaise("Unsupported return type!")
			off
		#>

	#--

	def NumberOfClasses()
		return len( This.Classes() )

		def NumberOfClassesQ()
			return new stzNumber( This.NumberOfClasses() )

		def CountClasses()
			return This.NumberOfClasses()

		def HowManyClasses()
			return This.NumberOfClasses()

		def HowManyClass()
			return This.NumberOfClasses()

	def Klass(pcClass)
		return This.Classify()[pcClass]

		def KlassQ(pcClass)
			return new stzString(This.Klass(pcClass))

	def NumberOfOccurrenceOfClass(pcClass)
		nResult = StzListQ( This.Classes() ).NumberOfOccurrence( pcClass )
		return nResult

		def CountClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def CountOccurrencesOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def HowManyOccurrencesOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def HowManyOccurrenceOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)


	def ClassFrequency(pcClass)
		nResult = This.NumberOfOccurrenceOfClass(pcClass) / This.NumberOfClasses()

		def ClassFreq(pcClass)

	def ClassesFrequencies()
		anResult = []
		for cClass in This.Classes()
			anResult + This.ClassFrequency(pcClass)
		next
		return anResult

		def ClassesFreq()
			return This.ClassesFrequencies()

	def ClassesAndTheirFrequencies()
		acClasses 	= This.Classes()
		anFrequencies 	= This.ClassesFrequencies()

		aResult = StzListQ( acClasses ).AssociatedWith( anFrequencies )

		return aResult

		def ClassesAndTheirFreq()
			return This.ClassesAndTheirFrequencies()

		def ClassesXT()
			return This.ClassesAndTheirFrequencies()

	   #--------------------------------------------------------#
	  #   CLASSIFYING: SPECIEFIC CASE OF LISTS MADE OF LISTS   #
	 #   OF NUMBERS IN WHICH THE _:_ SYNTAX IS PREFERRED      #
	#--------------------------------------------------------#

	# @C prefix is used to say this function returns its result with
	# list of numbers in the _:_ Contiguous List syntax
	# provided by Ring. See example hereafter.

	def ClassifySF()	# Specific for lists of lists of numbers
				# Returs classes in the "_:_" syntax
				# @C for Continuous lists
	
		/* EXAMPLE
		o1 = new stzList([
			1:5, 3:9, 1:5, 10:15, 3:9, 12:20, 10:15, 1:5, 12:20
		])
		
		? o1.ClassifySF()	# Same as Categorize()
		#--> [
		#	[ "1:5",   [1, 3, 8 ] ],	
		#	[ "3:9",   [2, 5 ] ],
		#	[ "10:15", [4, 7 ] ],
		#	[ "12:20", [6, 9 ]
		#    ]

		*/

		acClasses@C = This.ClassesSF()

		aPositions = StzHashListQ( This.Classify() ).Values()

		aResult = StzListQ(acClasses@C).AssociatedWith(aPositions)

		return aResult

		#< @FunctionFluentForm

		def Classify@CQ()
			return This.Classify@CQRT(:stzList)

		def Classify@CQRT(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ClassifySF() )

			on :stzHashList
				return new stzHashList( This.ClassifySF() )

			other
				StzRaise("Unssupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def ClassifiedSF()
			return This.Classify@C()

		#>

	def ClassesSF()
		acClasses = This.Classes()

		for cClass in acClasses
			cClass = StzStringQ(cClass).ToListInShortForm()
		next

		return acClasses

		#< @FunctionFluentForm

		def Classes@CQ()
			return This.Classes@CQRT(:stzList)

		def Classes@CQRT(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ClassesSF() )

			on :stzListOfStrings
				return new stzListOfStrings( This.ClassesSF() )

			other
				StzRaise("Unsupported return type!")
			off
		#>

	def KlassSF(pcClass)
		aResult = []

		if isString(pcClass) and StzStringQ(pcClass).IsListInShortForm()
			cClass =Q(pcClass).WithoutSpaces()
			aResult = This.ClassifySF()[cClass]
		ok

		return aResult

		def Klass@CQ(pcClass)
			return new stzString( This.KlassSF(pcClass) )

	def NumberOfOccurrenceOfClassSF(pcClass)
		nResult = StzListQ( This.ClassesSF() ).NumberOfOccurrence( pcClass )
		return nResult

		def CountClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def CountOccurrencesOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyOccurrencesOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyOccurrenceOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		
	def ClassFrequencySF(pcClass)
		nResult = This.NumberOfOccurrenceOfClassSF(pcClass) / This.NumberOfClasses()
		return nResult

		def ClassFreqSF(pcClass)
			return This.ClassFrequencySF(pcClass)

	def ClassesFrequenciesSF()
		anResult = []
		for cClass in This.ClassesSF()
			anResult + This.ClassFrequencySF(pcClass)
		next
		return anResult

		def ClassesFreqSF()
			return This.ClassesFrequenciesSF()

	def ClassesAndTheirFrequenciesSF()
		acClasses 	= This.ClassesSF()
		anFrequencies 	= This.ClassesFrequencies()

		aResult = StzListQ( acClasses ).AssociatedWith( anFrequencies )

		return aResult

		def ClassesAndTheirFreqSF()
			return This.ClassesAndTheirFrequenciesSF()

		def ClassesXTSF()
			return This.ClassesAndTheirFrequenciesSF()

	  #--------------------------------------------------------#
	 #   CLASSIFYING THE LIST ITEMS USING A GIVEN EXPRESSION  #
	#--------------------------------------------------------#

	def ClassifyByCS(pcExpr, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzList([ 3007, 2100, 170, 8, 10001, 2, 0, 150 ])
		? @@( o1.ClassifiedBy(' Q(@item).HowMany(0) ') )
		#--> [
		# 	[ "0", [ 8, 2 ] ],
		#	[ "1", [ 170, 0, 150 ] ],
		#	[ "2", [ 3007, 2100, 2100 ] ],
		#	[ "3", [ 10001 ] ]
		# ]
		*/

		#NOTE
		# Duplicates in the list are automatically removed and not
		# couted in the classification

		if CheckingParams()
			if NOT isString(pcExpr)
				StzRaise("Incorrect param type! pcExpr must be a string.")
			ok
		ok

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		oExpr = new stzString(pcExpr)
		if NOT oExpr.ContainsOneOfTheseCS([ "@i", "@item" ], _FALSE_)
			StzRaise("Cant't proceed! The classifier must contain the keyword @i or @item or both.")
		ok

		cExpr = Q(pcExpr).TrimQ().RemoveTheseBoundsQ("{", "}").Trimmed()
		cCode = ' value = (' + cExpr + ')'

		aContentU = This.ContentU()
		nLen = len(aContentU)

		aResult = []
		oaSeen = new stzList([])

		for @i = 1 to nLen
			@item = aContentU[@i]
			eval(cCode)

			n = oaSeen.FindFirstCS(value, bCaseSensitive)
			if n = 0
				aResult + [ value, [ @item ] ]
				oaSeen.Add(value)

			else
				aResult[n][2] + @item
			ok

		next

		return aResult

		#< @FunctionFluentForms

		def ClassifyByCSQ(pcExpr, pCaseSensitive)
			return This.ClassifyByCSQRT(pcExpr, pCaseSensitive, :stzList)

		def ClassifyByCSQRT(pcExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ClassifyByCS(pcExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.ClassifyByCS(pcExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ClassifiedByCS(pcExpr, pCaseSensitive)
			return This.ClassifyByCS(pcExpr, pCaseSensitive)

		def ClassifiedUsingCS(pcExpr, pCaseSensitive)
			return This.ClassifyByCS(pcExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyBy(pcExpr)
		return This.ClassifyByCS(pcExpr, _TRUE_)

		#< @FunctionFluentForms

		def ClassifyByQ(pcExpr)
			return This.ClassifyByCSQ(pcExpr, _TRUE_)

		def ClassifyByQRT(pcExpr, pcReturnType)
			return This.ClassifyByCSQRT(pcExpr, _TRUE_, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def ClassifiedBy(pcExpr)
			return This.ClassifyBy(pcExpr)

		def ClassifiedUsing(pcExpr)
			return This.ClassifyBy(pcExpr)

		#>


	  #==================================#
	 #  GETTING THE PARTS OF THE LIST   #
	#==================================#

	def PartsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
			else
				aResult + aPart
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + aPart

		return aResult

		#< @FunctionFluentForms

		def PartsCSQ(pCaseSensitive)
			return This.PartsCSQRT(pCaseSensitive, :stzList)

		def PartsCSQRT(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfLists( This.PartsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsCS(pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionCS(pCaseSensitive) # A verb: to partition
			return This.PartsCS(pCaseSensitive)

			def PartitionCSQ(pCaseSensitive)
				return This.PartitionCSQRT(pCaseSensitive, :stzList)

			def PartitionCSQRT(pCaseSensitive, pcReturnType)
				return This.PartsCSQRT(pCaseSensitive, pcReturnType)

		def PartionedCS(pCaseSensitive)
			return This.PartsCS(pCaseSensitive)

			def PartionedCSQ(pCaseSensitive)
				return This.PartionedCSQRT(pCaseSensitive, :stzList)

			def PartionedCSQRT(pCaseSensitive, pcReturnType)
				return This.PartsCSQRT(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def Parts()
		return This.PartsCS(_TRUE_)

		#< @FunctionFluentForms

		def PartsQ()
			return This.PartsQRT(:stzList)

		def PartsQRT(pcReturnType)
			return This.PartsCSQRT(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def Partition() # A verb: to partition
			return This.Parts()

			def PartitionQ()
				return This.PartitionQRT(:stzList)

			def PartitionQRT(pcReturnType)
				return This.PartsQRT(pcReturnType)

		def Partioned()
			return This.Parts()

			def PartionedQ()
				return This.PartionedQRT(:stzList)

			def PartionedQRT(pcReturnType)
				return This.PartsQRT(pcReturnType)

		#>

	  #--------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE LIST  #
	#--------------------------------------------------#

	def FindPartsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ 1 ]
		ok

		# Doing the job

		aResult = [ 1 ]

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]
				aResult + i
			ok
	
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindPartsCSZ(pCaseSensitive)
			return This.FindPartsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindParts()
		return This.FindPartsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindPartsZ()
			return This.FindParts()

		#>

	  #--------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE LIST  #
	#--------------------------------------------------#

	def FindPartsAsSectionsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Doing the job

		aResult = [ [1] ]
		nLenResult = 1

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]

				aResult[nLenResult] + (i-1)
				aResult + [ i ]
				nLenResult++
			ok
	
		next

		aResult[len(aResult)] + nLen
		return aResult

		#< @FunctionAlternativeForms

		def FindPartsCSZZ(pCaseSensitive)
			return This.FindPartsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindPartsAsSections()
		return This.FindPartsAsSectionsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindPartZZ()
			return This.FindPartsAsSections()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE LIST ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def PartsCSZ(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, 1 ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, i-n-1 ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, nLen-n ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsCS(pCaseSensitive)
			return This.PartsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZ()
		return This.PartsCSZ(_TRUE_)

		#< @FunctionAlternativeForms

		def PartAndTheirPositions()
			return This.PartsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING THE PARTS OF THE LIST ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------#

	def PartsCSZZ(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, [ 1, nLen ] ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, [ i-n-1, i-1 ] ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, [ nLen-n, nLen ] ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsCS(pCaseSensitive)
			return This.PartsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZZ()
		return This.PartsCSZZ(_TRUE_)

		#< @FunctionAlternativeForms

		def PartAndTheirSections()
			return This.PartsZZ()

		#>

	  #---------------------------------------------------------------#
	 #  PARTIONONING A LIST BASED ON A GIVEN PARTITION EXPRESSION  #
	#===============================================================#

	/* Note:

	This function analyzes the list, by sequentially partitioning
	its content, using a given "partition expression", a "PartitionExpr",
	for short. Hence, it serves in answering this kind of question:

	How is the list composed in term of some item criteria
	(the item beeing, for example, lowercase or uppercase, or
	left-oriented or right-oriented).

	The PartitionExpr is what we should provide to the method in
	a param as a conditional code containing the @item keyword.

	For example:

	o1 = new stzList([ "TUNIS", "gafsa", "NABEUL", "beja" ])
	? o1.PartsUsing( 'Q(@item).StringCase()' )

	Uses the Kase() method in stzString as a PartitionExpr.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or _NULL_, then the classification done will return:

	[
		[ "TUNIS" ] = :Uppercase,
		[ " " ] = _NULL_,
		[ "gafsa" ] = :Lowercase,
		[ " " ] = _NULL_,
		[ "NABEUL" ] = :Uppercase,
		[ " " ] = _NULL_,
		[ "beja" ] = :Lowercase
	]

	*/
 
	def PartsUsingCS(paPartitionExpr, pCaseSensitive)
		/*
		Examples:

		o1 = new stzList([ "A", "b", "c", "28", "5", "X", "Y", "&", "" ])
		
		? o1.PartsUsing( 'Q(@item).IsLetter()' )
		#--> [
		#	[ "A", "b", "c" ] = _TRUE_,
		#	["28", "5" ] = _FALSE_,
		# 	[ "X", "Y" ] = _TRUE_,
		#o	[ "&", "" ] = _FALSE_
		# ]
		
		? o1.PartsUsing('Q(@item).Orientation()' )
		#--> [
		#	[ A", "b", "c", "28", "5", "X", "Y", "&" ] = :LeftToRight,
		#o	[ "" = :RightToLeft ]
		# ]
		
		? o1.PartsUsing( 'Q(@item).IsUppercase()' )
		#--> [
		# 	[ "A" ]  = _TRUE_,
		#	[ "b", "c", "28", "5" ] = _FALSE_,
		#	[ "X", Y" ] = _TRUE_,
		#o	[ "&", "" = _FALSE_
		# ]
		
		? o1.PartsUsing( 'Q(@item).Kase()' )
		#--> [
		#	[ "A" ] = :Uppercase,
		#	[ "b", "c" ] = :Lowercase,
		#	[ "28", "5" ] = _NULL_,
		#	[ "X", "Y" ] = :Uppercase,
		#o	[ "&", "" ] = _NULL_
		# ]

		*/

		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ [ @aContent ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
			else
				aResult + aPart
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + aPart

		return aResult

		#< @FunctionFluentForms

		def PartsUsingCSQ(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSQRT(paPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionUsingCS(paPartitionExpr, pCaseSensitive) # A verb: to partition
			return This.PartsUsingCS(paPartitionExpr, pCaseSensitive)

			def PartitionUsingCSQ(paPartitionExpr, pCaseSensitive)
				return This.PartitionUsingCSQRT(paPartitionExpr, pCaseSensitive, :stzList)

			def PartitionCSUsingQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQRT(paPartitionExpr, pCaseSensitive, pcReturnType)

		def PartionedUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCS(paPartitionExpr, pCaseSensitive)

			def PartionedUsingCSQ(paPartitionExpr, pCaseSensitive)
				return This.PartionedUsingCSQRT(paPartitionExpr, pCaseSensitive, :stzList)

			def PartionedUsingCSQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQRT(paPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsing(paPartitionExpr)
		return This.PartsUsingCS(paPartitionExpr, _TRUE_)

		#< @FunctionFluentForms

		def PartsUsingQ(paPartitionExpr)
			return This.PartsUsingQRT(paPartitionExpr, :stzList)

		def PartsUsingQRT(paPartitionExpr, pcReturnType)
			return This.PartsUsingCSQRT(paPartitionExpr, _TRUE_, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartitionUsing(paPartitionExpr) # A verb: to partition
			return This.PartsUsing(paPartitionExpr)

			def PartitionUsingQ(paPartitionExpr)
				return This.PartitionUsingQRT(paPartitionExpr, :stzList)

			def PartitionUsingQRT(paPartitionExpr, pcReturnType)
				return This.PartsUsingQRT(paPartitionExpr, pcReturnType)

		def PartionedUsing(paPartitionExpr)
			return This.PartsUsing(paPartitionExpr)

			def PartionedUsingQ(paPartitionExpr)
				return This.PartionedUsingQRT(paPartitionExpr, :stzList)

			def PartionedUsingQRT(paPartitionExpr, pcReturnType)
				return This.PartsUsingQRT(paPartitionExpr, pcReturnType)

		#>

	   #---------------------------------------------------------------------#
	  #  PARTIONONING A LIST BASED ON A GIVEN PARTITION EXPRESSION AND      #
	 #  RETURNING THE PARTS ALONG WITH THEIR RESPECTIVE EXPRESSION VALUES  #
	#=====================================================================#
 
	def PartsUsingCSXT(paPartitionExpr, pCaseSensitive)
		/*
		Examples:

		o1 = new stzList([ "A", "b", "c", "28", "5", "X", "Y", "&", "" ])
		
		? o1.PartsUsingXT( 'Q(@item).IsLetter()' )
		#--> [
		#	[ "A", "b", "c" ] = _TRUE_,
		#	["28", "5" ] = _FALSE_,
		# 	[ "X", "Y" ] = _TRUE_,
		#o	[ "&", "" ] = _FALSE_
		# ]
		
		? o1.PartsUsingXT('Q(@item).Orientation()' )
		#--> [
		#	[ A", "b", "c", "28", "5", "X", "Y", "&" ] = :LeftToRight,
		#o	[ "" = :RightToLeft ]
		# ]
		
		? o1.PartsUsingXT( 'Q(@item).IsUppercase()' )
		#--> [
		# 	[ "A" ]  = _TRUE_,
		#	[ "b", "c", "28", "5" ] = _FALSE_,
		#	[ "X", Y" ] = _TRUE_,
		#o	[ "&", "" = _FALSE_
		# ]
		
		? o1.PartsUsingXT( 'Q(@item).Kase()' )
		#--> [
		#	[ "A" ] = :Uppercase,
		#	[ "b", "c" ] = :Lowercase,
		#	[ "28", "5" ] = _NULL_,
		#	[ "X", "Y" ] = :Uppercase,
		#o	[ "&", "" ] = _NULL_
		# ]

		*/

		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, _NULL_ ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ [ @aContent, _NULL_ ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
			else
				aResult + [ aPart, aValues[i-1] ]
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + [ aPart, aValues[nLen] ]

		return aResult

		#< @FunctionFluentForms

		def PartsUsingCSXTQ(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTQRT(paPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSXTQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionUsingCSXT(paPartitionExpr, pCaseSensitive) # A verb: to partition
			return This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive)

			def PartitionUsingCSXTQ(paPartitionExpr, pCaseSensitive)
				return This.PartitionUsingCSXTQRT(paPartitionExpr, pCaseSensitive, :stzList)

			def PartitionCSUsingXTQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQRT(paPartitionExpr, pCaseSensitive, pcReturnType)

		def PartionedUsingCSXT(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive)

			def PartionedUsingCSXTQ(paPartitionExpr, pCaseSensitive)
				return This.PartionedUsingCSXTQRT(paPartitionExpr, pCaseSensitive, :stzList)

			def PartionedUsingCSXTQRT(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQRT(paPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsingXT(paPartitionExpr)
		return This.PartsUsingCSXT(paPartitionExpr, _TRUE_)

		#< @FunctionFluentForms

		def PartsUsingXTQ(paPartitionExpr)
			return This.PartsUsingXTQRT(paPartitionExpr, :stzList)

		def PartsUsingXTQRT(paPartitionExpr, pcReturnType)
			return This.PartsUsingCSXTQRT(paPartitionExpr, _TRUE_, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartitionUsingXT(paPartitionExpr) # A verb: to partition
			return This.PartsUsingXT(paPartitionExpr)

			def PartitionUsingXTQ(paPartitionExpr)
				return This.PartitionUsingXTQRT(paPartitionExpr, :stzList)

			def PartitionUsingXTQRT(paPartitionExpr, pcReturnType)
				return This.PartsUsingXTQRT(paPartitionExpr, pcReturnType)

		def PartionedUsingXT(paPartitionExpr)
			return This.PartsUsingXT(paPartitionExpr)

			def PartionedUsingXTQ(paPartitionExpr)
				return This.PartionedUsingXTQRT(paPartitionExpr, :stzList)

			def PartionedUsingXTQRT(paPartitionExpr, pcReturnType)
				return This.PartsUsingXTQRT(paPartitionExpr, pcReturnType)

		#>

	  #-----------------------------#
	 #  FINDING PARTS IN THE LIST  #
	#=============================#

	def FindPartsUsingCS(paPartitionExpr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ 1 ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ 1 ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = @aContent[1]

		anResult = [ 1 ]

		for i = 2 to nLen

			if acValues[i] != acValues[i-1]
				anResult + i
			ok
	
		next

		return anResult

		def FindPartsUsingCSZ(paPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(paPartitionExpr, pCaseSensitive)

	def FindPartsUsing(paPartitionExpr)
		return This.FindPartsUsingCS(paPartitionExpr, _TRUE_)

		def FindPartsUsingZ(paPartitionExpr)
			return This.FindPartsUsing(paPartitionExpr)

	  #-------------------------------------------------------------------------#
	 #  FINDING PARTS IN THE LIST AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#=========================================================================#

	def FindPartsAsSectionsUsingCS(paPartitionExpr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ [ 1, nLen ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aResult = [ [ 1 ] ]

		for i = 2 to nLen

			if acValues[i] != acValues[i-1]
				aResult[len(aResult)] + (i-1)
				aResult + [i]
			ok
	
		next

		aResult[len(aResult)] + nLen

		return aResult

		def FindPartsUsingCSZZ(paPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(paPartitionExpr, pCaseSensitive)

	def FindPartsAsSectionsUsing(paPartitionExpr)
		return This.FindPartsAsSectionsUsingCS(paPartitionExpr, _TRUE_)

		def FindPartsUsingZZ(paPartitionExpr)
			return This.FindPartsAsSectionsUsing(paPartitionExpr)

	  #----------------------------------------------------------#
	 #  GETTING PARTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#==========================================================#

	def PartsUsingCSZ(paPartitionExpr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ [ @aContent ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, i-n-1 ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, nLen-n ]

		return aResult

		def PartsAndTheirPositionsUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(paPartitionExpr, pCaseSensitive)

	def PartsUsingZ(paPartitionExpr)
		return This.PartsUsingCSZ(paPartitionExpr, _TRUE_)

		def PartsAndTheirPositionsUsing(paPartitionExpr)
			return This.PartsUsingZ(paPartitionExpr)

	  #-----------------------------------------------------------------------------#
	 #  gettING PARTS IN THE LIST AND RETURNING THEM ALO?G WITH THEIR POSITIONS  #
	#=============================================================================#

	def PartsUsingCSZZ(paPartitionExpr, pCaseSensitive)
		if CheckingParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", _FALSE_)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, [1, nLen] ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = _FALSE_ and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], _FALSE_)

				return [ [ @aContent, [1, nLen] ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = _FALSE_
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, [ i-n-1, i-1 ] ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, [ nLen-n, nLen ] ]

		return aResult

		def PartsAndTheirSectionsUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(paPartitionExpr, pCaseSensitive)

	def PartsUsingZZ(paPartitionExpr)
		return This.PartsUsingCSZZ(paPartitionExpr, _TRUE_)

		def PartsAndTheirSectionsUsing(paPartitionExpr)
			return This.PartsUsingZZ(paPartitionExpr)

	  #=====================================================#
	 #   THE LIST IS MADE OF CONTIGUOUS CHARS OR NUMBERS   #
	#=====================================================#

	def IsContiguous()
		bResult = _FALSE_

		if This.IsListOfNumbers()

			bResult = This.ToStzListOfNumbers().IsContiguous()

		but This.IsListOfChars()

			bResult = This.ToStzListOfChars().IsContiguous()

		ok

		return bResult

		def IsContinuous()
			return This.IsContiguous()

		def IsConsecutive()
			return This.IsContiguous()


	  #==================================#
	 #  BISECTING THE LIST INTO HALVES  #
	#==================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfItems() / 2)
		acResult = This.Section(1, nPos)

		return acResult

		#-- MISSPELLED

		def FristHalf()
			return This.FirstHalf()

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

		#-- MISSPELLED

		def FristHalfAndPosition()
			return This.FirstHalfAndPosition()

		def FristHalfAndItsPosition()
			return This.FirstHalfAndPosition()


	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfItems() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()

		#-- MISSPELLED

		def FristHalfAndSection()
			return This.FirstHalfAndSection()

		def FristHalfAndItsSection()
			return This.FirstHalfAndSection()

	def FirstHalfXT()

		nPos = ceil(This.NumberOfItems() / 2)
		acResult = This.Section(1, nPos)

		return acResult

		#-- MISSPELLED

		def FristHalfXT()
			return This.FirstHalfXT()
		
	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

		#-- MISSPELLED

		def FristHalfAndPositionXT()
			return This.FirstHalfAndPositionXT()

		def FristHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfItems() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

		#-- MISSPELLED

		def FristHalfAndSectionXT()
			return This.FirstHalfAndSectionXT()

		def FristHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
				return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

	  #=============================================================#
	 #  CHECKING IF THE LIST CONTAINS SAME ITEMS AS AN OTHER LIST  #
	#=============================================================#

	def ContainsSameItemsAsCS(paOtherList, pCaseSensitive)
		if len( This.DifferentItemsWithCS(paOtherList, pCaseSensitive) ) = 0
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsSameItemsAs(paOtherList)
		return This.ContainsSameItemsAsCS(paOtherList, _TRUE_)

	   #---------------------------------------------------------#
	  #  GETTING THE LIST OF ITEMS WHICH ARE DIFFERENT BETWEEN  #
	 #  THE MAIN LIST AND AND OTHER GIVEN LIST                 #
	#---------------------------------------------------------#

	def DifferentItemsWithCS(paOtherList, pCaseSensitive)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		# Stringifying the list so we can use Ring find() function

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		acList = []
		acOtherList = []

		if bCaseSensitive = _TRUE_
			acList = This.Stringified()
			acOtherList = StzListQ(paOtherList).Stringified()

		else
			acList = This.Copy().StringifyQ().Lowercased()
			acOtherList = StzListQ(paOtherList).SringifyQ().Lowercased()
		ok

		#-- Doing the job

		aResult = []

		nLen = len(@aContent)
		for i = 1 to nLen
			if ring_find(acOtherList, acList[i]) = 0
				aResult + @aContent[i]
			ok
		next

		nLen = len(paOtherList)
		for i = 1 to nLen
			if ring_find(acList, acOtherList[i]) = 0
				aResult + paOtherList[i]
			ok
		next

		return aResult

		def DifferentItemsWithCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.DifferentItemsWithCS(paOtherList, pCaseSensitive) )

		def DifferenceWithCS(paOtherList, pCaseSensitive)
			return This.DifferentItemsWith(paotherList)

			def DifferenceWithCSQ(paOtherList, pCaseSensitive)
				return This.DifferentItemsWithCSQ(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DifferentItemsWith(paOtherList)
		return This.DifferentItemsWithCS(paOtherList, _TRUE_)

		def DifferentItemsWithQ(paOtherList)
			return This.DifferentItemsWithCSQ(paOtherList, _TRUE_)

		def DifferenceWith(paOtherList)
			return This.DifferentItemsWith(paOtherList)

			def DifferenceWithQ(paOtherList)
				return This.DifferentItemsWithQ(paOtherList)

	   #---------------------------------------------------------#
	  #  GETTING THE LIST OF ITEMS WHICH ARE DIFFERENT BETWEEN  #
	 #  THE MAIN LIST AND AND OTHER GIVEN LIST   -- XTended    #
	#---------------------------------------------------------#

	def DifferentItemsWithCSXT(paOtherList, pCaseSensitive)
		/*
		Returns a list composed of two hashlists:
			[
			:SURPLUS = [ "A", "B", ... ],
			:LACKING = [ "X", "Y", ... ]
			]
		*/
		aResult = [
				:SURPLUS = This.OverItemsComparedToCS(paOtherList, pCaseSensitive),
				:LACKING = This.LackingItemsComparedToCS(paOtherList, pCaseSensitive)
			  ]

		return aResult

		def DifferentItemsWithCSXTQ(paOtherList, pCaseSensitive)
			return new stzList( This.DifferentItemsWithCSXT(paOtherList, pCaseSensitive) )

		def DifferenceWithCSXT(paOtherList, pCaseSensitive)
			return This.DifferentItemsWithXT(paotherList)

			def DifferenceWithCSXTQ(paOtherList, pCaseSensitive)
				return This.DifferentItemsWithCSXTQ(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DifferentItemsWithXT(paOtherList)
		return This.DifferentItemsWithCSXT(paOtherList, _TRUE_)

		def DifferentItemsWithXTQ(paOtherList)
			return This.DifferentItemsWithCSXTQ(paOtherList, _TRUE_)

		def DifferenceWithXT(paOtherList)
			return This.DifferentItemsWithXT(paOtherList)

			def DifferenceWithXTQ(paOtherList)
				return This.DifferentItemsWithXTQ(paOtherList)

	  #--------------------------------------------------------------------#
	 #  GETTING THE OVER-ITEMS IN A GIVEN LIST COMPARED TO THE MAIN LIST  #
	#--------------------------------------------------------------------#

	def OverItemsComparedToCS(paOtherList, pCaseSensitive)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		aResult = []

		oOtherList = new stzList(paOtherList)
		nLen = This.NumberOfItems()

		aContent = This.Content()

		for i = 1 to nLen

			if NOT oOtherList.ContainsCS(aContent[i], pCaseSensitive)
				aResult + aContent[i]
			ok
		next

		return aResult

		def OverItemsComparedToCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.OverItemsComparedToCS(paOtherList, pCaseSensitive) )

	#-- WITHOUT CASESENSITIVITY

	def OverItemsComparedTo(paOtherList)
		return This.OverItemsComparedToCS(paOtherList, _TRUE_)

		def OverItemsComparedToQ(paOtherList)
			return new stzList( This.OverItemsComparedTo(paOtherList) )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE LACKING-ITEMS IN THE LIST COMPARED TO AN OTHER GIVEN LIST  #
	#-------------------------------------------------------------------------#

	def LackingItemsComparedToCS(paOtherList, pCaseSensitive)
		aResult = []
		nLen = len(paOtherList)

		for i = 1 to nLen
			item = paOtherList[i]

			if NOT This.ContainsCS(item, pCaseSensitive)
				aResult + item
			ok
		next

		return aResult

		def LackingItemsComparedToCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.LackingItemsComparedToCS(paOtherList, pCaseSensitive) )	

	#-- WITHOUT CASESENSITIVITY

	def LackingItemsComparedTo(paOtherList)
		return This.LackingItemsComparedToCS(paOtherList, _TRUE_)

		def LackingItemsComparedToQ(paOtherList)
			return new stzList( This.LackingItemsComparedTo(paOtherList) )	

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS SAME NUMBER OF ITEMS AS AN OTHER GIVEN LIST  #
	#------------------------------------------------------------------------#

	def HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)
		If len(paOtherList) = This.NumberOfItems()
			return _TRUE_
		else
			return _FALSE_
		ok

		def HasSameWidthAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

		def HasSameSizeAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

		def ContainsSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasSameNumberOfItemsAs(paOtherList)
		return This.HasSameNumberOfItemsAsCS(paOtherList, _TRUE_)

		def HasSameWidthAs(paOtherList)
			return HasSameNumberOfItemsAs(paOtherList)

		def HasSameSizeAs(paOtherList)
			return HasSameNumberOfItemsAs(paOtherList)

		def ContainsSameNumberOfItemsAs(paOtherList)
			return This.HasSameNumberOfItemsAs(paOtherList)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE COMMON-ITEMS (INTERSECTION) BETWEEN THE MAIN LIST AN OTHER GIVEN LIST  #
	#-------------------------------------------------------------------------------------#

	def CommonItemsWithCS(paOtherList, pCaseSensitive)

		if CheckingParam()
			if isList(paOtherList) and StzListQ(paOtherList).IsWithNamedParam()
				paOtherList = paOtherList[2]
			ok

			if NOT isList(paOtherList)
				StzRaise("Incorrect param type! paOtherList must be a list.")
			ok
		ok

		nLen = len(@aContent)
		nLenOther = len(paOtherList)

		# Stringifying the two lists

		bCaseSensitive = CaseSensitive(pCaseSensitive)
		acList = []
		acOther = []

		if bCaseSensitive
			acList = This.Stringified()
			acOther = StzListQ(paOtherList).Stringified()

		else
			acList = This.Copy().StringifyQ().Lowercased()
			acOther = StzListQ(paOtherList).StringifyQ().Lowercased()
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen
			if ring_find(acOther, acList[i]) > 0 and
				aResult + @aContent[i]
			ok
		next

		for i = 1 to nLenOther
			if ring_find(acList, acOther[i]) > 0 and
			   ring_find(aResult, acOther[i]) = 0

				aResult + paOtherList[i]
			ok
		next

		return aResult

		#< FunctionFluentForm

		def CommonItemsWithCSQ(paOtherList, pCaseSensitive)
			return new stzlist( This.CommonItemsWithCS(paOtherList, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def IntersectionWithCS(paOtherList, pCaseSensitive)
			return This.CommonItemsWithCS(paOtherList, pCaseSensitive)

			def IntersectionWithCSQ(paOtherList, pCaseSensitive)
				return This.CommonItemsWithCSQ(paOtherList, pCaseSensitive)

		def IntersectWithCS(paOtherList, pCaseSensitive)
			return This.CommonItemsWithCS(paOtherList, pCaseSensitive)

			def IntersectWithCSQ(paOtherList, pCaseSensitive)
				return This.CommonItemsWithCSQ(paOtherList, pCaseSensitive)

		def IntersectionCS(paOtherList, pCaseSensitive)
			if CheckingParam()
				if isList(paOtherList) and StzListQ(paOtherList).IsWithNamedParam()
					paOtherList = paOtherList[2]
				ok
			ok

			aResult =  This.CommonItemsWithCS(paOtherList, pCaseSensitive)
			return aResult

			def IntersectionCSQ(paOtherList, pCaseSensitive)
				return This.CommonItemsWithCSQ(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CommonItemsWith(paOtherList)
		return This.CommonItemsWithCS(paOtherList, _TRUE_)

		#< @FunctionFluentForm

		def CommonItemsWithQ(paOtherList)
			return new stzlist( This.CommonItemsWith(paOtherList) )

		#>

		#< @FunctionAlternativeForms

		def IntersectionWith(paOtherList)
			return This.CommonItemsWith(paOtherList)

			def IntersectionWithQ(paOtherList)
				return This.CommonItemsWithQ(paOtherList)

		def IntersectWith(paOtherList)
			return This.CommonItemsWith(paOtherList)

			def IntersectWithQ(paOtherList)
				return This.CommonItemsWithQ(paOtherList)

		def Intersection(paOtherList)
			return This.CommonItemsWith(paOtherList)

			def IntersectionQ(paOtherList)
				return This.CommonItemsWithQ(paOtherList)

		#>

	  #---------------------------------------------------#
	 #  GETTING THE UNION OF THE LIST AND AN OTHER LIST  #
	#---------------------------------------------------#

	def Union(paOtherList)
		if CheckingParam()
			if isList(paOtherList) and StzListQ(paOtherList).IsWithNamedParam()
				paOtherList = paOtherList[2]
			ok
	
			if NOT isList(paOtherList)
				StzRaise("Incorrect param type! paOtherList must be a list.")
			ok
		ok

		# Doing the job

		aResult = @aContent

		nLen = len(paOtherList)
		for i = 1 to nLen
			aResult + paOtherList[i]
		next

		return aResult

		def UnionQ(paOtherList)
			return new stzList( This.Union(paOtherList) )

		def UnionWith(paOtherList)
			return This.Union(paOtherList)

			def UnionWithQ(paOtherList)
				return This.Union(paOtherList)

	  #------------------------------------------------------------------------#
	 #  NUMBER OF COMMON ITEMS BETWEEN THE MAIN LIST AND AN OTHER GIVEN LIST  #
	#------------------------------------------------------------------------#

	def NumberOfCommonItemsWithCS(paItems, pCaseSensitive)
		return len(This.CommonItemsWithCS(paItems, pCaseSensitive))

		def SizeOfIntersectionWithCS(paItems, pCaseSensitive)
			return NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def CountCommonItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def HowManyCommonItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def HowManyCommonItemWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCommonItemsWith(paItems)
		return This.NumberOfCommonItemsWithCS(paItems, _TRUE_)

		def SizeOfIntersectionWith(paItems)
			return NumberOfCommonItemsWith(paItems)

		def CountCommonItemsWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

		def HowManyCommonItemsWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

		def HowManyCommonItemWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

	  #---------------------------------------------------------------------------#
	 #  NUMBER OF DIFFERENT ITEMS BETWEEN THE MAIN LIST AND AN OTHER GIVEN LIST  #
	#---------------------------------------------------------------------------#

	def NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)
		return len(This.DifferentItemsWithCS(paItems, pCaseSensitive))

		def CountDifferentItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

		def HowManyDifferentItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

		def HowManyDifferentItemWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDifferentItemsWith(paItems)
		return This.NumberOfDifferentItemsWithCS(paItems, _TRUE_)

		def CountDifferentItemsWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

		def HowManyDifferentItemsWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

		def HowManyDifferentItemWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

	  #=============================#
	 #  SORTING ORDER OF THE LIST  #
	#=============================#

	def SortingOrder()
		cResult = :Unsorted

		if This.IsSorted()
			if This.IsSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

	def HasSameSortingOrderAs(paOtherList)

		oTemp = new stzList(paOtherList)
		if oTemp.SortingOrder() = This.SortingOrder()
			return _TRUE_
		else
			return _FALSE_
		ok

		def HasSameOrderAs(paOtherList)
			return This.HasSameSortingOrderAs(paOtherList)

	  #-----------------------------------#
	 #  IS THE LIST SORTED OR UNSORTED?  #
	#-----------------------------------#
 
	def IsSorted()
		if This.IsSortedInAscending() or
		   This.IsSortedInDescending()
			return _TRUE_
		else
			return _FALSE_
		ok

		def ItemsAreSorted()
			return This.IsSorted()

	def IsSortedInAscending()

		# The idea is to sort a copy and then compare
		# it to the original content

		aContent = This.Content()
		nLen = len(aContent)

		aSorted = @SortList(aContent)

		bResult = _TRUE_

		for i = 1 to nLen
			cItem   = @@(aContent[i])
			cSorted = @@(aSorted[i])

			if cItem != cSorted
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ItemsAreSortedInAscending()
			return This.IsSortedInAscending()

		def IsSortedUp()
			return This.IsSortedInAscending()

		def ItemsAreSortedUp()
			return This.IsSortedInAscending()

	def IsSortedInDescending()
		aContent = This.Content()
		nLen = len(aContent)

		aSorted = ring_reverse( @SortList(aContent) )

		bResult = _TRUE_

		for i = 1 to nLen
			cItem   = @@(aContent[i])
			cSorted = @@(aSorted[i])

			if cItem != cSorted
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ItemsAreSortedInDescending()
			return This.IsSortedInDescending()

		def IsSortedDown()
			return This.IsSortedInAscending()

		def ItemsAreSortedDown()
			return This.IsSortedInAscending()

	def IsUnsorted()
		return NOT This.IsSorted()

		def ItemsAreUnSorted()
			return This.IsUnsorted()

		def IsNotSorted()
			return NOT This.IsUnsorted()

		def ItemsAreNotSorted()
			return NOT This.IsUnsorted()

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS SORTABLE (MADE OF SORTABLE ITEMS)  #
	#-------------------------------------------------------------#
 
	def IsSortable()
		if This.SortableItems() = This.NumberOfItems()
			return _TRUE_
		else
			return _FALSE_
		ok

	  #-------------------------------------#
	 #  SORTABLE ITEMS & UNSORTABLE ITEMS  #
	#-------------------------------------#
 
	def SortableItems()
		/*
		Number, strings and lists are sortable.

		Objects are not sortable except if they are stzNumber, stzString or stzList,
		or anyone of their derivaties.

		NB: This may change in the future and normal ring objects become sortable.

		*/

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			if isNumber(aContent[i]) or isString(aContent[i]) or isList(aContent[i]) or
			   @IsStzNumber(aContent[i]) or @IsStzString(aContent[i]) or @IsStzList(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

	def UnsortableItems()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i]) or isList(aContent[i]) or
			   @IsStzNumber(aContent[i]) or @IsStzString(aContent[i]) or @IsStzList(aContent[i])
				// do nothing, skip!
			else
				aResult + aContent[i]
			ok
		next
		return aResult

	  #----------------------------------#
	 #  SORTING THE ITEM IN ASSCENDING  #
	#----------------------------------#
 
	def SortInAscending()

		/*
		Ring native sort() function can sort a list made:
			- only of numbers
			- or only of strings.

		Softanza can do the same and more. Even heteregenous lists
		made of numbers, strings, lists and objects can be sorted !

		If the list is made of numbers and/or strings, then
		Ring native sort function is used.

		Otherwise, the list may contain items that are lists
		or objects, in addition to numbers and strings.

		In this case, Sofanza makes the sort by applying 10 steps:

		1- if the list contains stzNumbers they are numberified
		2- If the list contains stzStrings they are stringified
		3- if the list contains stzLists they are listified

		4- numbers are sorted first and put at the beginning
		5- stzNumbers are identified and set at their expected positions

		6- then strings are sorted and put after numbers
		5- stzStrings are identified and set at their expected positions

		7- then lists are sorted and put after strings
		8- stzLists are identified and set at their expected positions

		9- then objects are sorted based on type of their content
		   ~> if it is number, then the object is numberified and sorted
		      within the number. If it is a string, then it is sorted
		      within the strings, and so on.

		10. Remaining objects, whose Content() type is not a Ring type
		    (C or C++ object for example), are put at the end in the
		    order of their appearance.

		NOTE: In the mean time, stzObjects (and other objects) are
		not sortable yet ~> FUTURE

		*/

		aResult = @SortList( This.Content() )
		This.Update( aResult )

		#< @FunctionFluentForm

		def SortInAscendingQ()
			This.SortInAscending()
			return This

		#>

		#< @FunctionAlternativeForms

		def Sort()
			This.SortInAscending()

			def SortQ()
				return This.SortInAscendingQ()

		def SortUp()
			This.SortInAscending()

			def SortUpQ()
				return This.SortQ()

		#>

		#< @FunctionMisspelledForms

		def SortInAsending()
			This.SortInAscending()

			def SortInAsendingQ()
				return This.SortQ()

		def SortInAssending()
			This.SortInAscending()

			def SortInAssendingQ()
				return This.SortQ()

		#>

	def SortedInAscending()
		aResult = This.Copy().SortInAscendingQ().Content()
		return aResult

		def Sorted()
			return This.SortedInAscending()

		def SortedInAsending()
			return This.SortedInAscending()

		def SortedInAssending()
			return This.SortedInAscending()

		def SortedUp()
			return This.SortedInAscending()

	  #-----------------------------------#
	 #  SORTING THE ITEMS IN DESCENDING  #
	#-----------------------------------#

	def SortInDescending()
		aResult = ring_reverse( This.SortedInAscending() )
		This.Update( aResult )

		#< @FunctionFluentForm

		def SortInDescendingQ()
			This.SortInDescending()
			return This
		
		#>
	
		#< @FunctionAlternativeForms

		def SortDown()
			This.SortInDescending()

			def SortDownQ()
				return This.SortInDescendingQ()

		#>

		#< @FunctionMisspelledForms

		def SortInDesending()
			This.SortInDescending()

			def SortInDesendingQ()
				This.SortInDescending()
				return This

		def SortInDessending()
			This.SortInDescending()

			def SortInDessendingQ()
				This.SortInDescending()
				return This

		#>

	def SortedInDescending()
		aResult = This.Copy().SortInDescendingQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def SortedDown()
			return This.SortedInDescending()

		#>

		#< @FunctionMisspelledForms

		def SortedInDesending()
			return This.SortedInDescending()

		def SortedInDessending()
			return This.SortedInDescending()

		#>

	  #-------------------------------------------#
	 #  SORTING THE ITEM IN THE REVERSE ORDER  #
	#-------------------------------------------#
 
	def SortInReverseOrder()
		switch This.SortingOrder()
		on :Ascending
			This.SortInDescending()

		on: Descending
			This.SortInAscending()
		off

		def SortInReverseOrderQ()
			This.SortInReverse()
			return This

		def SortInReverse()
			This.SortInReverseOrder()

			def SortInReverseQ()
				This.SortInReverse()
				return This

	def SortedInReverse()
		aResult = This.Copy().SortInReverseQ().Content()
		return aResult

		def SortedInReverseOrder()
			return This.SortedInReverse()

	  #--------------------------------------------------------------#
	 #  SORTING THE ITEM BY AN EVALUATED EXPRESSION - IN ASCENDING  #
	#==============================================================#
 
	def SortBy(pcExpr)
		/* EXAMPLE
		o1 = new stzList([ "a", "abcde", "abc", "ab", "abcd" ])
		o1.SortBy('len(@item)')
		? o1.Content()

		#--> [ "a", "ab", "abc", "abcd", "abcde" ]

		*/

		if NOT (isString(pcExpr) and Q(pcExpr).ContainsCS("@item", _FALSE_))
			StzRaise("Incorrect param! pcExpr must be a string containing @item keyword.")
		ok

		aContent = This.Content()
		nLen = len(aContent)

		aContentXT = []

		cCode = ' value = (' + pcExpr + ')'

		for @i = 1 to nLen
			@item = aContent[@i]
			eval(cCode)
			aContentXT + [ @item, value ]
		next

		aContentXT = @SortOn(aContentXT, 2)

		aResult = []

		for i = 1 to nLen
			aResult + aContentXT[i][1]
		next

		This.UpdateWith(aResult)


		#< @FunctionFluentForm

		def SortByQ(pcExpr)
			This.SortBy(pcExpr)
			return This

		#>

		#< @FunctionAlternativeForms

		def SortByInAscending(pcExpr)
			This.SortBy(pcExpr)

			def SortByInAscendingQ(pcExpr)
				return This.SortByQ(pcExpr)

		def SortByUp(pcExpr)
			This.SortBy(pcExpr)

			def SortByUpQ(pcExpr)
				return This.SortByQ(pcExpr)

		#>

	def SortedBy(pcExpr)
		aResult = This.Copy().SortByQ(pcExpr).Content()
		return aResult

		def SortedByInAscending(pcExpr)
			return This.SortedBy(pcExpr)

		def SortedByUp(pcExpr)
			return This.SortedBy(pcExpr)

	  #---------------------------------------#
	 #  SORTING THE ITEM BY - IN DESCENDING  #
	#---------------------------------------#
 
	def SortByInDescending(pcExpr)
		aResult = ring_reverse( This.SortedByInAscending(pcExpr) )
		This.UpdateWith(aResult)

		def SortByInDescendingQ(pcExpr)
			This.SortByInDescending(pcExpr)
			return This

		def SortByDown(pcExpr)
			This.SortByInDescending(pcExpr)

			def SortByDownQ(pcExpr)
				return This.SortByInDescendingQ(pcExpr)

	def SortedByInDescending(pcExpr)
		aResult = ring_reverse( This.SortedByInAscending(pcExpr) )
		return aResult

		def SortedByDown(pcExpr)
			return This.SortedByInDescending(pcExpr)
		
	  #=======================================#
	 #     ASSOCIATE WITH AN ANOTHER LIST    #
	#=======================================#

	// Returns an Associative List (HashList) from the main list and an other list

	def AssociateWith(paOtherList)
		/* EXAMPLE

		o1 = new stzList([ "Name", "Age", "Job" ])
		o1.AssociateWith([ "Ali", 24, "Programmer" ])
		? o1.Content()

		#--> [ ["Name", "Ali"], ["Age", 24], ["Job", "Programmer"] ]

		*/

		if NOT isList(paOtherList)
			StzRaise("Incorrect param tpe!")
		ok

		aResult = []
		nLen  = This.NumberOfItems()
		nLenOtherList = len(paOtherList)

		aContent = This.Content()

		for i = 1 to nLen
			otherItem = _NULL_
			if i <= nLenOtherList
				otherItem = paOtherList[i]
			ok

			aResult + [ aContent[i], otherItem ]
		next

		This.Update( aResult )

		def AssociateWithQ(paOtherList)
			This.AssociateWith(paOtherList)
			return This

	def AssociatedWith(paOtherList)
		aResult = This.Copy().AssociateWithQ(paOtherList).Content()
		return aResult

	  #=====================================================#
	 #   CHECKING IF THE LIST HAS REPEATED LEADING ITEMS   #
	#=====================================================#

	def HasRepeatedLeadingItemsCS(pCaseSensitive)
		aLead = This.RepeatedLeadingItemsCS(pCaseSensitive)

		if len(aLead) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedItemsCS(pCaseSensitive)
			return This.HasRepeatedLeadingItemsCS(pCaseSensitive)

		def HasLeadingItemsCS(pCaseSensitive)
			return This.HasRepeatedLeadingItemsCS(pCaseSensitive)
	
		#--

		def ContainsRepeatedLeadingItemsCS(pCaseSensitive)
			return This.HasRepeatedLeadingItemsCS(pCaseSensitive)

		def ContainsLeadingRepeatedItemsCS(pCaseSensitive)
			return This.HasRepeatedLeadingItemsCS(pCaseSensitive)

		def ContainsLeadingItemsCS(pCaseSensitive)
			return This.HasRepeatedLeadingItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingItems()
		return This.HasRepeatedLeadingItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedItems()
			return This.HasRepeatedLeadingItems()

		def HasLeadingItems()
			return This.HasRepeatedLeadingItems()
	
		#--

		def ContainsRepeatedLeadingItems()
			return This.HasRepeatedLeadingItems()

		def ContainsLeadingRepeatedItems()
			return This.HasRepeatedLeadingItems()

		def ContainsLeadingItems()
			return This.HasRepeatedLeadingItems()

		#>

	  #------------------------------------------------------#
	 #   CHECKING IF THE LIST HAS REPEATED TRAILING ITEMS   #
	#------------------------------------------------------#


	def HasRepeatedTrailingItemsCS(pCaseSensitive)
		aTrail = This.RepeatedTrailingItemsCS(pCaseSensitive)

		if len(aTrail) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedItemsCS(pCaseSensitive)
			return This.HasRepeatedTrailingItemsCS(pCaseSensitive)

		def HasTrailingItemsCS(pCaseSensitive)
			return This.HasRepeatedTrailingItemsCS(pCaseSensitive)
	
		#--

		def ContainsRepeatedTrailingItemsCS(pCaseSensitive)
			return This.HasRepeatedTrailingItemsCS(pCaseSensitive)

		def ContainsTrailingRepeatedItemsCS(pCaseSensitive)
			return This.HasRepeatedTrailingItemsCS(pCaseSensitive)

		def ContainsTrailingItemsCS(pCaseSensitive)
			return This.HasRepeatedTrailingItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedTrailingItems()
		return This.HasRepeatedTrailingItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedItems()
			return This.HasRepeatedTrailingItems()

		def HasTrailingItems()
			return This.HasRepeatedTrailingItems()
	
		#--

		def ContainsRepeatedTrailingItems()
			return This.HasRepeatedTrailingItems()

		def ContainsTrailingRepeatedItems()
			return This.HasRepeatedTrailingItems()

		def ContainsTrailingItems()
			return This.HasRepeatedTrailingItems()

		#>

	  #--------------------------------------------------#
	 #  GETTING THE REPEATED LEADING ITEMS IN THE LIST  #
	#==================================================#

	def RepeatedLeadingItemsCS(pCaseSensitive) # Same item is repeated at the start of the list

		/* Example:
			[ 'e', 'e', 'e', 'T', 'U', 'N', 'I', 'S' ]
			--> ['e','e','e']

			[ 'e', 'x', 'e', 'e', 'e', 'T', 'U', 'N', 'I', 'S' ]
			--> []
		*/

		
		aContent = This.Content()
		nLen = This.NumberOfItems()

		# Stringiying the list depending on case sensitivity

		bCase = @CaseSensitive(pCaseSensitive)
		acList = ""

		if bCase = _TRUE_
			acList = This.Stringified()
		else
			acList.StringifyQ().Lowercased()
		ok

		aResult = []

		if nLen > 0
			cResult = ""
	
			i = 1
			while acList[i] = acList[1] and i <= nLen
				i++
			end

			if i > 2
				aResult = This.NFirstItems(i-1)
			ok
		ok

		return aResult

		#< @FunctionFluentForm

		def RepeatedLeadingItemsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedLeadingItemsCS(pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemsCS(pCaseSensitive)
			return This.RepeatedLeadingItemsCS(pCaseSensitive)

			def LeadingRepeatedItemsCSQ(pCaseSensitive)
				return This.RepeatedLeadingItemsQ()
	
		def LeadingItemsCS(pCaseSensitive)
			return This.RepeatedLeadingItemsCS(pCaseSensitive)

			def LeadingItemsCSQ(pCaseSensitive)
				return This.RepeatedLeadingItemsCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingItems()
		return This.RepeatedLeadingItemsCS(_TRUE_)

		#< @FunctionFluentForm

		def RepeatedLeadingItemsQ()
			return new stzList( This.RepeatedLeadingItems() )

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedItems()
			return This.RepeatedLeadingItems()

			def LeadingRepeatedItemsQ()
				return This.RepeatedLeadingItemsQ()
	
		def LeadingItems()
			return This.RepeatedLeadingItems()

			def LeadingItemsQ()
				return This.RepeatedLeadingItemsQ()

		#>

	  #-------------------------------------------------#
	 #  GETTING THE REPEATED LEADING ITEM IN THE LIST  #
	#-------------------------------------------------#

	def RepeatedLeadingItemCS(pCaseSensitive)
		aLead = This.RepeatedLeadingItemsCS(pCaseSensitive)
		if len(aLead) = 0
			StzRaise("Can't proceed! The list has no repeated leading items.")
		ok

		return aLead[1]

		#< @FunctionFluentForm

		def RepeatedLeadingItemCSQ(pCaseSensitive)
			return Q(This.RepeatedLeadingItemCS(pCaseSensitive))
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemCS(pCaseSensitive)
			return This.RepeatedLeadingItemCS(pCaseSensitive)

			def LeadingRepeatedItemCSQ(pCaseSensitive)
				return This.RepeatedLeadingItemCSQ(pCaseSensitive)
	
		def LeadingItemCS(pCaseSensitive)
			return This.RepeatedLeadingItemCS(pCaseSensitive)

			def LeadingItemCSQ(pCaseSensitive)
				return This.RepeatedLeadingItemCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingItem()
		return This.RepeatedLeadingItem(_TRUE_)

		#< @FunctionFluentForm

		def RepeatedLeadingItemQ()
			return new stzList(This.RepeatedLeadingItem())
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedItem()
			return This.RepeatedLeadingItem()

			def LeadingRepeatedItemQ()
				return This.RepeatedLeadingItemQ()
	
		def LeadingItem()
			return This.RepeatedLeadingItem()

			def LeadingItemQ()
				return This.RepeatedLeadingItemQ()

		#>

	  #------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED LEADING ITEMS  #
	#------------------------------------------------#

	def NumberOfRepeatedLeadingItemsCS(pCaseSensitive)
		aLead = This.RepeatedLeadingItemsCS(pCaseSensitive)
		nResult = len(aLead)
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def NumberOfLeadingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def CountRepeatedLeadingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def CountLeadingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def CountLeadingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def HowManyRepeatedLeadingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def HowManyRepeatedLeadingItemCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def HowManyLeadingRepeatedItemCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def HowManyLeadingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		def HowManyLeadingItemCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedLeadingItems()
		return This.NumberOfRepeatedLeadingItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def NumberOfLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountRepeatedLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyRepeatedLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyRepeatedLeadingItem()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingRepeatedItem()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingItem()
			return This.NumberOfRepeatedLeadingItems()

		#>

	  #----------------------------------------------------#
	 #  CHECKING IF AN ITEM IS THE REPEATED LEADING ITEM  #
	#----------------------------------------------------#

	def RepeatedLeadingItemIsCS(pItem, pCaseSensitive)

		aLead = This.RepeatedLeadingItemsCS(pCaseSensitive)
		bResult = _FALSE_

		if len(aLead) > 0
			if Q(aLead[1]).IsEqualToCS(pItem, pCaseSensitive)
				bResult = _TRUE_
			ok
		ok

		return bResult

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemIsCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemIsCS(pItem, pCaseSensitive)

		def LeadingItemIsCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemIsCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingItemIs(pItem)
		return This.RepeatedLeadingItemIs(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemIs(pItem)
			return This.RepeatedLeadingItemIs(pItem)

		def LeadingItemIs(pItem)
			return This.RepeatedLeadingItemIs(pItem)

		#>

	  #----------------------------------------#
	 #   GETTING THE REPEATED TRAILING ITEM   #
	#----------------------------------------#

	def RepeatedTrailingItemCS(pCaseSensitive)

		aTrail = This.RepeatedTrailingItemsCS(pCaseSensitive)

		if len(aTrail) = 0
			StzRaise("Can't proceed! The list has no repeated trailing items.")
		ok

		return aTrail[1]

		#< @FunctionFluentForm

		def RepeatedTrailingItemCSQ(pCaseSensitive)
			return Q(This.RepeatedTrailingItemCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedItemCS(pCaseSensitive)
			return This.RepeatedTrailingItemCS(pCaseSensitive)

			def TrailingRepeatedItemCSQ(pCaseSensitive)
				return This.RepeatedTrailingItemCSQ(pCaseSensitive)

		def TrailingItemCS(pCaseSensitive)
			return This.RepeatedTrailingItemCS(pCaseSensitive)

			def TrailingItemCSQ(pCaseSensitive)
				return RepeatedTrailingItemCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingItem()
		return This.RepeatedTrailingItemCS(_TRUE_)

		#< @FunctionFluentForm

		def RepeatedTrailingItemQ()
			return Q(This.RepeatedTrailingItem())
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedItem()
			return This.RepeatedTrailingItem()

			def TrailingRepeatedItemQ()
				return This.RepeatedTrailingItemQ()

		def TrailingItem()
			return This.RepeatedTrailingItem()

			def TrailingItemQ()
				return This.RepeatedTrailingItemQ()

		#>

	  #----------------------------------------#
	 #   GETTING THE REPEATED TRAILING ITEMS  #
	#----------------------------------------#

	def RepeatedTrailingItemsCS(pCaseSensitive)
		aResult = This.Copy().ReverseQ().RepeatedLeadingItemsCS(pCaseSensitive)
		return aResult

		#< @FunctionFluentForm

		def RepeatedTrailingItemsCSQ(pCaseSensitive)
			return new stzList(This.RepeatedTrailingItemsCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedItemsCS(pCaseSensitive)
			return This.RepeatedTrailingItemsCS(pCaseSensitive)

			def TrailingRepeatedItemsCSQ(pCaseSensitive)
				return new stzList(This.TrailingRepeatedItemsCS(pCaseSensitive))
	
		def TrailingItemsCS(pCaseSensitive)
			return This.RepeatedTrailingItemsCS(pCaseSensitive)

			def TrailingItemsCSQ(pCaseSensitive)
				return new stzList(This.TrailingItemsCS(pCaseSensitive))

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingItems()
		return This.RepeatedTrailingItemsCS(_TRUE_)

		#< @FunctionFluentForm

		def RepeatedTrailingItemsQ()
			return new stzList(This.RepeatedTrailingItems())

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedItems()
			return This.RepeatedTrailingItems()

			def TrailingRepeatedItemsQ()
				return new stzList(This.TrailingRepeatedItems())
	
		def TrailingItems()
			return This.RepeatedTrailingItems()

			def TrailingItemsQ()
				return new stzList(This.TrailingItems())

		#>

	  #-------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED TRAILING ITEMS  #
	#-------------------------------------------------#

	def NumberOfRepeatedTrailingItemsCS(pCaseSensitive)
		aTrail = This.RepeatedTrailingItemsCS(pCaseSensitive)
		return len(aTrail)

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def NumberOfTrailingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def CountRepeatedTrailingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def CountTrailingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def CountTrailingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowManyRepeatedTrailingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowManyRepeatedTrailingItemCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowManyTrailingRepeatedItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowManyTrailingRepeatedItemCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowmanyTrailingItemsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		def HowmanyTrailingItemCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedTrailingItems()
		return This.NumberOfRepeatedTrailingItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def NumberOfTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountRepeatedTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyRepeatedTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyRepeatedTrailingItem()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyTrailingRepeatedItem()
			return This.NumberOfRepeatedTrailingItems()

		def HowmanyTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowmanyTrailingItem()
			return This.NumberOfRepeatedTrailingItems()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF A GIVEN ITEM IS THE REPEATED TRAILING ITEM  #
	#----------------------------------------------------------#

	def RepeatedTrailingItemIsCS(pItem, pCaseSensitive)

		aLead = This.RepeatedTrailingItemsCS(pCaseSensitive)
		bResult = _FALSE_

		if len(aLead) > 0
			if Q(aLead[1]).IsEqualToCS(pItem, pCaseSensitive)
				bResult = _TRUE_
			ok
		ok

		return bResult

		#< @FunctionAlternativeForms

		def TrailingRepeatedItemIsCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemIsCS(pItem, pCaseSensitive)

		def TrailingItemIsCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemIsCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingItemIs(pItem)
		return This.RepeatedTrailingItemIsCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def TrailingRepeatedItemIs(pItem)
			return This.RepeatedTrailingItemIs(pItem)

		def TrailingItemIs(pItem)
			return This.RepeatedTrailingItemIs(pItem)

		#>

	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING ITEMS   #
	#=====================================#

	def RemoveRepeatedLeadingItemsCS(pCaseSensitive)
		if This.HasRepeatedLeadingItems()
			This.RemoveFirstNItems( This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive) )
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingItemsCSQ(pCaseSensitive)
			This.RemoveRepeatedLeadingItemsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingRepeatedItemsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingItemsCS(pCaseSensitive)

			def RemoveLeadingRepeatedItemsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingItemsCSQ(pCaseSensitive)
	
		def RemoveLeadingItemsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingItemsCS(pCaseSensitive)

			def RemoveLeadingItemsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingItemsCSQ(pCaseSensitive)

		#>

	def RepeatedLeadingItemsRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedLeadingItemsCSQ(pCaseSensitive).Content()
		return aResult

		def LeadingRepeatedItemsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingItemsRemovedCS(pCaseSensitive)

		def LeadingItemsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingItemsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLEadingItems()
		This.RemoveRepeatedLeadingItemsCS(_TRUE_)

		def RemoveRepeatedLeadingItemsQ()
			This.RemoveRepeatedLeadingItems()
			return This

		def RemoveLeadingRepeatedItems()
			This.RemoveRepeatedLeadingItems()

			def RemoveLeadingRepeatedItemsQ()
				return This.RemoveRepeatedLeadingItemsQ()
	
		def RemoveLeadingItems()
			This.RemoveRepeatedLeadingItems()

			def RemoveLeadingItemsQ()
				return This.RemoveRepeatedLeadingItemsQ()
	
	def RepeatedLeadingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedLeadingItemsQ().Content()
		return aResult

		def LeadingRepeatedItemsRemoved()
			return This.RepeatedLeadingItemsRemoved()

		def LeadingItemsRemoved()
			return This.RepeatedLeadingItemsRemoved()

	  #--------------------------------------------#
	 #  REMOVING THE GIVEN REPEATED LEADING ITEM  #
	#--------------------------------------------#

	def RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)
		if This.RepeatedLeadingItemCSQ(pCaseSensitive).IsEqualToCS(pItem, pCaseSensitive)
			return This.RemoveRepeatedLeadingItemsCS(pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
			This.RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingRepeatedItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def RemoveLeadingRepeatedItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
	
		def RemoveLeadingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def RemoveLeadingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedLeadingItemCSQ(pItem, pCaseSensitive)

		#--

		def RemoveThisRepeatedLeadingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def RemoveThisRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedLeadingItemCSQ(pItem, pCaseSensitive)

		def RemoveThisLeadingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def RemoveThisLeadingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveThisLeadingItemCS(pItem, pCaseSensitive)

		#>

	def RepeatedLeadingItemRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedLeadingItemCSQ(pItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemRemovedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemRemovedCS(pItem, pCaseSensitive)

		def LeadingItemRemovedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemRemovedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingItem(pItem)
		This.RemoveRepeatedLeadingItemCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingItemQ(pItem)
			This.RemoveRepeatedLeadingItem(pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingRepeatedItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveLeadingRepeatedItemQ(pItem)
				This.RemoveLeadingRepeatedItem(pItem)
				return This
	
		def RemoveLeadingItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveLeadingItemQ(pItem)
				This.RemoveLeadingItem(pItem)
				return This
	
		#--

		def RemoveThisRepeatedLeadingItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveThisRepeatedLeadingItemQ(pItem)
				return This.RemoveRepeatedLeadingItemQ(pItem)

		def RemoveThisLeadingItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveThisLeadingItemQ(pItem)
				return This.RemoveThisLeadingItem(pItem)

		#>

	def RepeatedLeadingItemRemoved(pItem)
		aResult = This.Copy().RemoveRepeatedLeadingItemQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms

		def LeadingRepeatedItemRemoved(pItem)
			return This.RepeatedLeadingItemRemoved(pItem)

		def LeadingItemRemoved(pItem)
			return This.RepeatedLeadingItemRemoved(pItem)

		#>

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING ITEMS   #
	#======================================#

	def RemoveRepeatedTrailingItemsCS(pCaseSensitive)
		if This.HasRepeatedTrailingItemsCS(pCaseSensitive)
			This.RemoveLastNItems( This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedTrailingItemsCSQ(pCaseSensitive)
			This.RemoveRepeatedTrailingItemsCS(pCaseSensitive)
			return This
	
		def RemoveTrailingRepeatedItemsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingItemsCS(pCaseSensitive)

			def RemoveTrailingRepeatedItemsCSQ(pCaseSensitive)
				This.RemoveTrailingRepeatedItemsCS(pCaseSensitive)
				return This
	
		def RemoveTrailingItemsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingItemsCS(pCaseSensitive)

			def RemoveTrailingItemsCSQ(pCaseSensitive)
				This.RemoveTrailingItemsCS(pCaseSensitive)
				return This
	
	def RepeatedTrailingItemsRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedTrailingItemsCSQ(pCaseSensitive).Content()
		return aResult

		def TrailingRepeatedItemsRemovedCS(pCaseSensitive)
			This.RepeatedTrailingItemsRemovedCS(pCaseSensitive)

		def TrailingItemsRemovedCS(pCaseSensitive)
			This.RepeatedTrailingItemsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingItems()
		This.RemoveRepeatedTrailingItemsCS(_TRUE_)

		def RemoveRepeatedTrailingItemsQ()
			This.RemoveRepeatedTrailingItems()
			return This
	
		def RemoveTrailingRepeatedItems()
			This.RemoveRepeatedTrailingItems()

			def RemoveTrailingRepeatedItemsQ()
				This.RemoveTrailingRepeatedItems()
				return This
	
		def RemoveTrailingItems()
			This.RemoveRepeatedTrailingItems()

			def RemoveTrailingItemsQ()
				This.RemoveTrailingItems()
				return This
	
	def RepeatedTrailingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedTrailingItemsQ().Content()
		return aResult

		def TrailingRepeatedItemsRemoved()
			This.RepeatedTrailingItemsRemoved()

		def TrailingItemsRemoved()
			This.RepeatedTrailingItemsRemoved()

	  #------------------------------------------#
	 #  REMOVIN A GIVEN REPEATED TRAILING ITEM  #
	#------------------------------------------#

	def RemoveRepeatedTrailingItemCS(pItem, pCaseSensitive)
		if This.RepeatedTrailingItemCSQ(pCaseSensitive).IsEqualToCS(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemsCS(pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingRepeatedItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def RemoveTrailingRepeatedItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
	
		def RemoveTrailingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemCS(pItem, pCaseSensiitve)

			def RemoveTrailingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive)

		#--

		def RemoveThisRepeatedTrailingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def RemoveThisRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
	
		def RemoveThisTrailingItemCS(pItem, pCaseSensitive)
			This.RemoveRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def RemoveThisTrailingItemCSQ(pItem, pCaseSensitive)
				return This.RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive)

		#>

	def RepeatedTrailingItemRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedTrailingItemCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def TrailingRepeatedItemRemovedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemRemovedCS(pItem, pCaseSensitive)

		def TrailingItemRemovedCS(pItem, pCaseSEnsitive)
			return This.RepeatedTrailingItemRemovedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingItem(pItem)
		This.RemoveRepeatedTrailingItemCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingItemQ(pItem)
			This.RemoveRepeatedTrailingItem(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingRepeatedItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveTrailingRepeatedItemQ(pItem)
				return This.RemoveRepeatedTrailingItemQ(pItem)
	
		def RemoveTrailingItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveTrailingItemQ(pItem)
				return This.RemoveRepeatedTrailingItemQ(pItem)

		#--

		def RemoveThisRepeatedTrailingItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveThisRepeatedTrailingItemQ(pItem)
				return This.RemoveRepeatedTrailingItemQ(pItem)
	
		def RemoveThisTrailingItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveThisTrailingItemQ(pItem)
				return This.RemoveRepeatedTrailingItemQ(pItem)

		#>

	def RepeatedTrailingItemRemoved(pItem)
		aResult = This.Copy().RemoveRepeatedTrailingItemQ(pItem).Content()
		return aResult

		def TrailingRepeatedItemRemoved(pItem)
			return This.RepeatedTrailingItemRemoved(pItem)

		def TrailingItemRemoved(pItem)
			return This.RepeatedTrailingItemRemoved(pItem)

	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING ITEMS   #
	#==================================================#

	def RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pCaseSensitive)
		This.RemoveRepeatedLeadingItemCS(pItem1, pCaseSensitive)
		This.RemoveRepeatedTrailingItemCS(pItem2, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingcharAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
			This.RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)
			This.RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def RemoveLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
				return This.RemoveRepeatedLeadingcharAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
	
		def RemoveTrailingItemAndLeadingItemCS(pItem1, pItem2, pCaseSensitive)
			This.RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def RemoveTrailingItemAndLeadingItemCSQ(pItem1, pItem2, pCaseSensitive)
				return This.RemoveRepeatedLeadingcharAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		#--

		def RemoveTheseLeadingAndTrailingItemsCS(pItem1, pItem2, pCaseSensitive)
			This.RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def RemoveTheseLeadingAndTrailingItemsCSQ(pItem1, pItem2, pCaseSensitive)
				return This.RemoveRepeatedLeadingcharAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		def RemoveTheseTrailingAndLeadingItemsCS(pItem1, pItem2, pCaseSensitive)
			This.RemoveRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def RemoveTheseTrailngAndLeadingItemsCSQ(pItem1, pItem2, pCaseSensitive)
				return This.RemoveRepeatedLeadingcharAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		#>

	def RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingItemAndLeadingItemRemovedCS(pItem1, pItem2, pCaseSensitive)
			return This.RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)

		def LeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)
			return This.RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)

		def TrailingItemAndLeadingItemRemovedCS(pItem1, pItem2, pCaseSensitive)
			return This.RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)

		def TheseLeadingAndTrailingItemsRemovedCS(pItem1, pItem2, pCaseSensitive)
			return This.RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)

		def TheseTrailingAndLeadingItemsRemovedCS(pItem1, pItem2, pCaseSensitive)
			return This.RepeatedLeadingItemAndTrailingItemRemovedCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
		This.RemoveRepeatedLeadingItem(pItem1)
		This.RemoveRepeatedTrailingItem(pItem2)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingcharAndTrailingItemQ(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingItemAndTrailingItem(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveLeadingItemAndTrailingItemQ(pItem1, pItem2)
				This.RemoveLeadingItemAndTrailingItem(pItem1, pItem2)
				return This
	
		def RemoveTrailingItemAndLeadingItem(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveTrailingItemAndLeadingItemQ(pItem1, pItem2)
				This.RemoveTrailingItemAndLeadingItem(pItem1, pItem2)
				return This

		#--

		def RemoveTheseLeadingAndTrailingItems(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveTheseLeadingAndTrailingItemsQ(pItem1, pItem2)
				return This.RemoveRepeatedLeadingcharAndTrailingItemQ(pItem1, pItem2)

		def RemoveTheseTrailingAndLeadingItems(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveTheseTrailngAndLeadingItemsQ(pItem1, pItem2)
				return This.RemoveRepeatedLeadingcharAndTrailingItemQ(pItem1, pItem2)

		#>

	def RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)
		aResult = This.Copy().RemoveRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingItemAndLeadingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def LeadingItemAndTrailingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def TrailingItemAndLeadingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def TheseLeadingAndTrailingItemsRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def TheseTrailingAndLeadingItemsRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		#>
	
	  #-------------------------------------------------------------#
	 #  REMOVING REPEATED LEADTING AND TRAILING ITEMS IN THE LIST  #
	#-------------------------------------------------------------#

	def RemoveRepeatedLeadingAndTrailingItemsCS(pCaseSensitive)
		This.RemoveRepeatedLeadingItemsCS(pCaseSensitive)
		This.RemoveRepeatedTrailingItemsCS(pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingAndTrailingItemsCSQ(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingItemsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeadingAndTrailingRepeatedItemsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingItemsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingRepeatedItemsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingAndTrailingItemsCSQ(pCaseSensitive)
	
		#>

	def RepeatedLeadingAndTrailingItemsRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveRepeatedLeadingAndTrailingItemsCSQ(pCaseSensitive).Content()
		return aResult

		def RepeatedTrailingAndLeadingItemsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsRemovedCS(pCaseSensitive)

		def LeadingAndTrailingItemsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsRemovedCS(pCaseSensitive)

		def TrailingAndLeadingItemsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsRemovedCS(pCaseSensitive)

	#-- WTIHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingAndTrailingItems()
		This.RemoveRepeatedLeadingAndTrailingItemsCS(_TRUE_)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingAndTrailingItemsQ()
			This.RemoveRepeatedLeadingAndTrailingItems()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeadingAndTrailingRepeatedItems()
			This.RemoveRepeatedLeadingAndTrailingItems()

			def RemoveLeadingAndTrailingRepeatedItemsQ()
				return This.RemoveRepeatedLeadingAndTrailingItemsQ()

		#>

	def RepeatedLeadingAndTrailingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedLeadingAndTrailingItemsQ().Content()
		return aResult

		def RepeatedTrailingAndLeadingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()

		def LeadingAndTrailingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()

		def TrailingAndLeadingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()
	
	  #-----------------------------#
	 #   REPLACING LEADING ITEMS   #
	#=============================#

	def ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)
		/* Example:

		o1 = new stzList([ '_', '_', '_', 'V', 'A', 'R', '-', '-', '-' ])
		ReplaceRepeatedLeadingItem(:With = "-")

		--> Gives: [ '-', '-', '-', 'V', 'A', 'R', '-', '-', '-' ]
		*/

		if isList(pItem) and Q(pItem).IsWithOrByNamedParam()
			pItem = pItem[2]
		ok

		if This.HasRepeatedLeadingItemsCS(pCaseSensitive)
			n = This.NumberOfRepeatedLeadingItemsCS(pCaseSensitive)

			for i = 1 to n
				This.ReplaceAt(i, pItem)
			next

		ok

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms
	
		def ReplaceLeadingRepeatedItemCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def ReplaceLeadingRepeatedItemCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
	
		def ReplaceLeadingItemCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def ReplaceLeadingItemCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedLeadingItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def ReplaceRepeatedLeadingItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)

		def ReplaceLeadingRepeatedItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def ReplaceLeadingRepeatedItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)
	
		def ReplaceLeadingItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemCS(pItem, pCaseSensitive)

			def ReplaceLeadingItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive)

		#>

	def RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)
		aResult = This.Copy().ReplaceRepeatedLeadingItemCSQ(pItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def LeadingRepeatedItemReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)
	
		def LeadingItemReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)

		#-- Same functions with ...Items in plural

		def RepeatedLeadingItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)

		def LeadingRepeatedItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)
	
		def LeadingItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedLeadingItemReplacedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingItem(pItem)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingItemQ(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)
			return This
			
		#>
	
		#< @FunctionAlternativeForms
	
		def ReplaceLeadingRepeatedItem(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingRepeatedItemQ(pItem)
				This.ReplaceLeadingRepeatedItem(pItem)
				return This
	
		def ReplaceLeadingItem(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingItemQ(pItem)
				This.ReplaceLeadingItem(pItem)
				return This

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedLeadingItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceRepeatedLeadingItemsQ(pItem)
				This.ReplaceRepeatedLeadingItems(pItem)
				return This

		def ReplaceLeadingRepeatedItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingRepeatedItemsQ(pItem)
				This.ReplaceLeadingRepeatedItems(pItem)
				return This
	
		def ReplaceLeadingItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingItemsQ(pItem)
				This.ReplaceLeadingItems(pItem)
				return This

		#>

	def RepeatedLeadingItemReplaced(pItem)
		aResult = This.Copy().ReplaceRepeatedLeadingItemQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def LeadingRepeatedItemReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)
	
		def LeadingItemReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		#-- Same functions with ...Items in plural

		def RepeatedLeadingItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		def LeadingRepeatedItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)
	
		def LeadingItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		#>

	  #---------------------------------------------------#
	 #  REPLACING A GIVEN LEADING ITEM BY AN OTHER ITEM  #
	#---------------------------------------------------#

	def ReplaceThisRepeatedLeadingItemCS(pItem, pNewItem, pCaseSensitive)

		if CheckingParams()
			if isList(pNewItem) and StzListQ(pNewItem).IsWithOrByNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		if This.RepeatedLeadingItemIsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemsCS(pNewItem, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingItemCSQ(pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingItemCS(pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisLeadingItemCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingItemCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceThisLeadingItemCSQ(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisRepeatedLeadingItemCSQ(pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedLeadingItem(pItem, pNewItem)
		This.ReplaceThisRepeatedLeadingItemCS(pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingItemQ(pItem, pNewItem)
			This.ReplaceThisRepeatedLeadingItem(pItem, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisLeadingItem(pItem, pNewItem)
			This.ReplaceThisRepeatedLeadingItem(pItem, pNewItem)

			def ReplaceThisLeadingItemQ(pItem, pNewItem)
				return This.ReplaceThisRepeatedLeadingItemQ(pItem, pNewItem)

		#>

	  #------------------------------#
	 #   REPLACING TRAILING ITEMS   #
	#==============================#

	def ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)
		/* Example:

		o1 = new stzList([ "_","_","_","V","A","R","-","-","-" ])
		o1.ReplaceRepeatedTrailingItemBy("_")

		#--> [ "_","_","_","V","A","R","_","_","_" ]
		*/

		if isList(pItem) and Q(pItem).IsWithOrByNamedParam()
			pItem = pItem[2]
		ok

		if This.HasRepeatedTrailingItemsCS(pCaseSensitive)
			n = This.NumberOfRepeatedTrailingItemsCS(pCaseSensitive)

			nLen = This.NumberOfItems()
			n = nLen - n + 1
			for i = n to nLen
				This.ReplaceAt(i, pItem)
			next

		ok

		#< @FunctionFluentForm

		def ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)
			return This
			
		#>
	
		#< @FunctionAlternativeForms
	
		def ReplaceTrailingRepeatedItemCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def ReplaceTrailingRepeatedItemCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
	
		def ReplaceTrailingItemCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def ReplaceTrailingItemCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedTrailingItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def ReplaceRepeatedTrailingItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)

		def ReplaceTrailingRepeatedItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def ReplaceTrailingRepeatedItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)
	
		def ReplaceTrailingItemsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemCS(pItem, pCaseSensitive)

			def ReplaceTrailingItemsCSQ(pItem, pCaseSensitive)
				return This.ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive)

		#>

	def RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)
		aResult = This.Copy().ReplaceRepeatedTrailingItemCSQ(pItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def TrailingRepeatedItemReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)
	
		def TrailingItemReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)

		#-- Same functions with ...Items in plural

		def RepeatedTrailingItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)

		def TrailingRepeatedItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)
	
		def TrailingItemsReplacedCS(pItem, pCaseSensitive)
			return This.RepeatedTrailingItemReplacedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedTrailingItem(pItem)
		This.ReplaceRepeatedTralingItemCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceRepeatedTrailingItemQ(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)
			return This
			
		#>
	
		#< @FunctionAlternativeForms
	
		def ReplaceTrailingRepeatedItem(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingRepeatedItemQ(pItem)
				This.ReplaceTrailingRepeatedItem(pItem)
				return This
	
		def ReplaceTrailingItem(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingItemQ(pItem)
				This.ReplaceTrailingItem(pItem)
				return This

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedTrailingItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceRepeatedTrailingItemsQ(pItem)
				This.ReplaceRepeatedTrailingItems(pItem)
				return This

		def ReplaceTrailingRepeatedItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingRepeatedItemsQ(pItem)
				This.ReplaceTrailingRepeatedItems(pItem)
				return This
	
		def ReplaceTrailingItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingItemsQ(pItem)
				This.ReplaceTrailingItems(pItem)
				return This

		#>

	def RepeatedTrailingItemReplaced(pItem)
		aResult = This.Copy().ReplaceRepeatedTrailingItemQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def TrailingRepeatedItemReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)
	
		def TrailingItemReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		#-- Same functions with ...Items in plural

		def RepeatedTrailingItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		def TrailingRepeatedItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)
	
		def TrailingItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		#>

	  #---------------------------------------------------#
	 #  REPLACING A GIVEN TRAILING ITEM BY AN OTHER ITEM  #
	#---------------------------------------------------#

	def ReplaceThisRepeatedTrailingItemCS(pItem, pNewItem, pCaseSensitive)

		if CheckingParams()
			if isList(pNewItem) and StzListQ(pNewItem).IsWithOrByNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		if This.RepeatedTrailingItemIsCS(pItem, pCaseSensitive)
			This.ReplaceRepeatedTrailingItemsCS(pNewItem, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingItemCSQ(pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingItemCS(pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisTrailingItemCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingItemCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceThisTrailingItemCSQ(pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisRepeatedTrailingItemCSQ(pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedTrailingItem(pItem, pNewItem)
		This.ReplaceThisRepeatedTrailingItemCS(pItem, pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingItemQ(pItem, pNewItem)
			This.ReplaceThisRepeatedTrailingItem(pItem, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceThisTrailingItem(pItem, pNewItem)
			This.ReplaceThisRepeatedTrailingItem(pItem, pNewItem)

			def ReplaceThisTrailingItemQ(pItem, pNewItem)
				return This.ReplaceThisRepeatedTrailingItemQ(pItem, pNewItem)

		#>

	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING ITEMS   #
	#===================================================#

	def ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)
		This.ReplaceRepeatedLeadingItemWithCS(pItem1, pCaseSensitive)
		This.ReplaceRepeatedTrailingItemWithCS(pItem2, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingItemAndLeadingItemCS(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def ReplaceRepeatedTrailingItemAndLeadingItemCSQ(pItem1, pItem2, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
	
		def ReplaceLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def ReplaceLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)
	
		def ReplaceTrailingItemAndLeadingItemCS(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def ReplaceTrailingItemAndLeadingItemCSQ(pItem1, pItem2, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		#--

		def ReplaceTheseLeadingAndTrailingItemsCS(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingItemsCSQ(pItem1, pItem2, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		def ReplaceTheseTrailingAndLeadingItemsCS(pItem1, pItem2, pCaseSensitive)
			This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingItemsCSQ(pItem1, pItem2, pCaseSensitive)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive)

		#>

	def RepeatedLeadingcharAndTrailingItemReplacedCS(pItem1, pItem2, pCaseSensitive)
		aResult = This.Copy().ReplaceRepeatedLeadingItemAndTrailingItemCSQ(pItem1, pItem2, pCaseSensitive).Content()
		return aResult
	
		def RepeatedTrailingItemAndLeadingItemReplacedCS(pItem1, pItem2, pCaseSensitive)
			This.RepeatedLeadingcharAndTrailingItemReplacedCS(pItem1, pItem2, pCaseSensitive)
	
		def TrailingItemAndLeadingItemReplacedCS(pItem1, pItem2, pCaseSensitive)
			This.RepeatedLeadingcharAndTrailingItemReplacedCS(pItem1, pItem2, pCaseSensitive)

		def TheseLeadingAndTrailingItemsReplacedCS(pItem1, pItem2, pCaseSensitive)
			This.RepeatedLeadingcharAndTrailingItemReplacedCS(pItem1, pItem2, pCaseSensitive)

		def TheseTrailingandLeadingItemsReplacedCS(pItem1, pItem2, pCaseSensitive)
			This.RepeatedLeadingcharAndTrailingItemReplacedCS(pItem1, pItem2, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
		This.ReplaceRepeatedLeadingItemAndTrailingItemCS(pItem1, pItem2, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingItemAndLeadingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceRepeatedTrailingItemAndLeadingItemQ(pItem1, pItem2)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)
	
		def ReplaceLeadingItemAndTrailingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceLeadingItemAndTrailingItemQ(pItem1, pItem2)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)
	
		def ReplaceTrailingItemAndLeadingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceTrailingItemAndLeadingItemQ(pItem1, pItem2)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)

		#--

		def ReplaceTheseLeadingAndTrailingItems(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceTheseLeadingAndTrailingItemsQ(pItem1, pItem2)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)

		def ReplaceTheseTrailingAndLeadingItems(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceTheseTrailingAndLeadingItemsQ(pItem1, pItem2)
				return This.ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)

		#>

	def RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)
		aResult = This.Copy().ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2).Content()
		return aResult
	
		def RepeatedTrailingItemAndLeadingItemReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)
	
		def TrailingItemAndLeadingItemReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)

		def TheseLeadingAndTrailingItemsReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)

		def TheseTrailingandLeadingItemsReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)

	  #---------------------------------------------------------------#
	 #  REPLACING THE LEADING AND TRAINLING ITEMS WITH A GIVEN ITEM  #
	#---------------------------------------------------------------#

	def ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)
		This.ReplaceRepeatedLeadingItemsCS(pNewItem, pCaseSensitive)
		This.ReplaceRepeatedTrailingItemsCS(pNewItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)

			def ReplaceLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive)
	
		def ReplaceRepeatedTrailingAndLeadingItemsCS(pNewItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)

			def ReplaceRepeatedTrailingAndLeadingItemCSQ(pNewItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive)
	
		def ReplaceTrailingAndLeadingItemsCS(pNewItem, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, pCaseSensitive)

			def ReplaceTrailingAndLeadingItemsCSQ(pNewItem, pCaseSensitive)
				return This.ReplaceRepeatedLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive)
		#>


	def RepeatedLeadingAndTrailingItemsReplacedCS(pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceRepeatedLeadingAndTrailingItemsCSQ(pNewItem, pCaseSensitive).Content()
		return aResult

		def RepeatedTrailingAndLeadingItemsReplacedCS(pNewItem, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsReplacedCS(pNewItem, pCaseSensitive)

		def LeadingAndTrailingItemsReplacedCS(pNewItem, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsReplacedCS(pNewItem, pCaseSensitive)
	
		def TrailingAndLeadingItemsReplacedCS(pNewItem, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingItemsReplacedCS(pNewItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingAndTrailingItems(pNewItem)
		This.ReplaceRepeatedLeadingAndTrailingItemsCS(pNewItem, _TRUE_)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingItemsQ(pNewItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pNewItem)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceLeadingAndTrailingItems(pNewItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pNewItem)

			def ReplaceLeadingAndTrailingItemsQ(pNewItem)
				return This.ReplaceRepeatedLeadingAndTrailingItemsQ(pNewItem)
	
		def ReplaceRepeatedTrailingAndLeadingItems(pNewItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pNewItem)

			def ReplaceRepeatedTrailingAndLeadingItemQ(pNewItem)
				return This.ReplaceRepeatedLeadingAndTrailingItemsQ(pNewItem)
	
		def ReplaceTrailingAndLeadingItems(pNewItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pNewItem)

			def ReplaceTrailingAndLeadingItemsQ(pNewItem)
				return This.ReplaceRepeatedLeadingAndTrailingItemsQ(pNewItem)
		#>


	def RepeatedLeadingAndTrailingItemsReplaced(pNewItem)
		aResult = This.Copy().ReplaceRepeatedLeadingAndTrailingItemsQ(pNewItem).Content()
		return aResult

		def RepeatedTrailingAndLeadingItemsReplaced(pNewItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pNewItem)

		def LeadingAndTrailingItemsReplaced(pNewItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pNewItem)
	
		def TrailingAndLeadingItemsReplaced(pNewItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pNewItem)

	  #==============================#
	 #     OPERATORS OVERLOADING    #
	#==============================#

	#TODO #WARNING
	# ~> Operators should adopt same semantics in all classes...

	#WARNING // DON'T ADD = OPERATOR
	# Because it causes semantic conflict with
	# feature in stzExtCode (see CREATE_TABLE sql function)

	def operator(pcOp, pValue)
		
		if pcOp = "[]"

			if isNumber(pValue)
				return This.Item(pValue)

			but isString(pValue)
				oStr = new stzString(pValue)
			
				if oStr.NumberOfOccurrenceQ(":").IsEither(1, 2) and
				    oStr.Copy().RemoveQ(":").IsNumberInString()

					/* EXAMPLES

					? Q(1:5)['::-1']
					#--> [ 5, 4, 3, 2, 1 ]

					? Q(1:10)['2:8:2']
					#--> [ 2, 4, 6, 8 ]

					*/

					acNumbers = oStr.SplitAt(":")
					nLen = len(acNumbers)

					n1 = 1
					if acNumbers[1] != _NULL_
						n1 = 0+ acNumbers[1]
					ok

					n2 = This.NumberOfItems()
					if acNumbers[2] != _NULL_
						n2 = 0+ acNumbers[2]
					ok

					nStep = 1
					if nLen = 3
						nStep = 0+ acNumbers[3]
					ok

					aContent = This.Content()
					aResult = []

					if nStep < 0
						nTemp = n1
						n1 = n2
						n2 = nTemp
					ok

					for i = n1 to n2 step nStep
						aResult + aContent[i]
					next

					return aResult

				but oStr.TrimQ().IsBoundedBy([ "{", "}" ])

					pcCondition = StzStringQ(pValue).TrimQ().TheseBoundsRemoved("{", "}")
					anResult = []
	
					@i = 0
					for @item in This.List()
						@i++
						cCode = 'if ( ' + pcCondition + ' )' + NL +
							'	anResult + @i' + NL +
							'ok'
						eval(cCode)
					next
	
					return anResult

				else
					return This.FindAll(pValue)
				ok

			else
				return This.FindAll(pValue)
			ok

		// Add an item at the beginning of the list
		but pcOp = "<<"
			This.InsertBeforePosition(1)

		// Add an item at the end of the list
		but pcOp = ">>"
			This.Add(pValue)

		but pcOp = "=="
			return This.IsStrictlyEqualTo(pValue)

		// Divides the list on pValue sublists (a list of lists)
		but pcOp = "/" 

			if @IsStzString(pValue)
				aResult = This.SplittedUsing(pValue.Content())
				return new stzList(aResult)

			but isList(pValue)
				aResult = This.DistributeOver(pValue)
				return aResult
	
			but @IsStzList(pValue)
				aResult = This.DistributeOver(pValue.Content())
				return new stzList(aResult)
	
			but @IsStzNumber(pValue)
				aResult = This.SplittedToNParts(pValue.NumericValue())
				return new stzList(aResult)

			but isNumber(pValue)
				aResult = This.SplittedToNParts(pValue)
				return aResult
			ok

		but pcOp = "+"

			if isList(pValue)

				if _bTheseQ

					aResult = This.ManyAdded(pValue)
					bTheseQ = _FALSE_
					return new stzList(aResult)

				but _bThese

					aResult = This.ManyAdded(pValue)
					_bThese = _FALSE_ # Resets the global flag
					return aResult

				else
					aResult = This.ItemAdded(pValue)
					return aResult
				ok
			
			but @IsStzObject(pValue) 

				if _bAsObject
					aResult = This.ItemAdded(pValue)
					_bAsObject = _FALSE_
					return aResult

				but _bAsObjectQ
					aResult = This.ItemAdded(pValue)
					_bAsObjectQ = _FALSE_
					return new stzList(aResult)

				but _bTheseQ
					aResult = This.ManyAdded(pValue.Content())
					_bTheseQ = _FALSE_ # Resets the global flag
					return new stzList(aResult)

				but _bThese
					aResult = This.Copy().ManyAdded(pValue.Content())
					_bThese = _FALSE_ # Resets the global flag
					return aResult
				else

					value = pValue.Content()
					if @IsStzNumber(pValue)
						value = pValue.NumericValue()
					ok

					aResult = This.ItemAdded(value)
					return new stzList(aResult)
				ok

			else

				aResult = This.ItemAdded(pValue)
				return aResult
			ok

		but pcOp = "-"

			if isList(pValue)

				if _bTheseQ
					aResult = This.ManyRemoved(pValue)
					bTheseQ = _FALSE_

					return new stzList(aResult)

				but _bThese

					aResult = This.ManyRemoved(pValue)
					_bThese = _FALSE_ # Resets the global flag

					return aResult

				else
					aResult = This.ItemRemoved(pValue)
					return aResult
				ok
			
			but @IsStzList(pValue) 

				if _bAsObject

					aResult = This.ItemRemoved(pValue)
					_bAsObject = _FALSE_

					return aResult

				but _bAsObjectQ
					aResult = This.ItemRemoved(pValue)
					_bAsObjectQ = _FALSE_

					return new stzList(aResult)

				but _bTheseQ
					aResult = This.ManyRemoved(pValue.Content())
					_bTheseQ = _FALSE_ # Resets the global flag

					return new stzList(aResult)

				but _bThese
					aResult = This.Copy().ManyRemoved(pValue.Content())
					_bThese = _FALSE_ # Resets the global flag

					return aResult
				else

					aResult = This.ItemRemoved(pValue.Content())
					return new stzList(aResult)
				ok

			but @IsStzObject(pValue)

				if @IsStzNumber(pValue)
					value = pValue.NumericValue()
				else
					value = pValue.Content()
				ok

				anPos = This.FindAll(value)
				aResult = This.ItemsAtPositionsRemoved(anPos)

				return new stzList(aResult)

			else

				anPos = This.FindAll(pValue)
				aResult = This.ItemsAtPositionsRemoved(anPos)

				return aResult
			ok

		but pcOp = "*"

			if isList(pValue)

				if _bTheseQ
					aResult = This.ManyMultipliedBy(pValue)
					bTheseQ = _FALSE_
					return new stzList(aResult)

				but _bThese

					aResult = This.ManyMultipliedBy(pValue)
					_bThese = _FALSE_ # Resets the global flag
					return aResult

				else
					aResult = This.ItemMultipliedBy(pValue)
					return aResult
				ok
			
			but @IsStzList(pValue) 

				if _bAsObject
					aResult = This.ItemMultipliedBy(pValue)
					_bAsObject = _FALSE_
					return aResult

				but _bAsObjectQ
					aResult = This.ItemMultipliedBy(pValue)
					_bAsObjectQ = _FALSE_
					return new stzList(aResult)

				but _bTheseQ
					aResult = This.ManyMultipliedBy(pValue.Content())
					_bTheseQ = _FALSE_ # Resets the global flag
					return new stzList(aResult)

				but _bThese
					aResult = This.Copy().ManyMultipliedBy(pValue.Content())
					_bThese = _FALSE_ # Resets the global flag
					return aResult
				else

					aResult = This.ItemMultipliedBy(pValue.Content())
					return new stzList(aResult)
				ok

			but @IsStzObject(pValue)

				if @IsStzNumber(pValue)
					value = pValue.NumericValue()
				else
					value = pValue.Content()
				ok

				aResult = This.MultipliedBy(value)
				return new stzList(aResult)

			else
				aResult = This.MultipliedBy(pValue)
				return aResult
			ok

		ok

	  #------------------------------------------#
	 #  MULTIPLYING THE lIST BY A GIVEN VALUE   #
	#==========================================#

	def MultiplyBy(p)
		switch ring_type(p)
		on "NUMBER"

			if p = 0
				aResult = []

			but p = 1
				aResult = @aContent

			else
				aResult = []
	
				for i = 1 to p
					aResult + @aContent
				next
			ok

			This.Update( aResult )

		on "STRING"

			nLen = len(@aContent)
			aResult = []

			for i = 1 to nLen
				if isString(@aContent[i])
					@aContent[i] += p
				ok
			next

		on "LIST"
			/* EXAMPLE

			? Q([ "VALUE1", "VALUE2", "VALUE3" ]) * [ 1001, 1002, 1003 ]
			#--> [
			#	[  "VALUE1", [ 1001, 1002, 1003 ] ],
			#	[  "VALUE2", [ 1001, 1002, 1003 ] ],
			#	[  "VALUE3", [ 1001, 1002, 1003 ] ]
			# ]

			*/

			nLen = len(@aContent)
			aResult = []

			for i = 1 to nLen
				item = @aContent[i]
				@aContent[i] = [ item , p ]
			next

		other
			StzRaise("Can't multiply the list by an object!")
		off

		#< @FunctionFluentForm

		def MultiplyByQ(p)
			This.MultiplyBy(p)
			return This

		#>

		#< @FunctionAlternativeForm

		def Multiply(p)
			This.MultiplyWith(p)

		#>

	#-- @FunctionPassiveForm

	def MultipliedBy(p)
		aResult = This.Copy().MultiplyByQ(p).Content()
		return aResult

		def Multiplied(p)
			return This.MultipliedBy(p)

		def ItemMultiplied(p)
			return This.MultipliedBy(p)

		def ItemMultipliedBy(p)
			return This.MultipliedBy(p)

	  #===========================================#
	 #  EXTENDING THE LIST WITH THE GIVEN ITEMS  #
	#===========================================#

	def ExtendWith(paItems)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		aContent = This.Content()
		nLen = len(paItems)

		for i = 1 to nLen
			aContent + paItems[i]
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ExtendWithQ(paItems)
			This.ExtendWith(paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithItems(paItems)
			This.ExtendWith(paItems)

			def ExtendWithItemsQ(paItems)
				This.ExtendWithItems(paItems)
				return This

		#>

	def ExtendedWith(paItems)
		aResult = This.Copy().ExtendWithQ(paItems).Content()
		return aResult

		def ExtendedWithItems(paItems)
			return This.ExtendedWith(paItems)

	  #-------------------------------------#
	 #  EXTENDINF THE LIST TO N POSITIONS  #
	#-------------------------------------#

	def ExtendToPosition(n)

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		aContent = This.Content()

		if n > nLen

			value = ""
			if This.IsListOfNumbers()
				value = 0
			ok

			nExtend = n - nLen
			for i = 1 to nExtend
				aContent + value
			next
		ok

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsToNItemsNamedParam() )

				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNItems(n)
			This.ExtendToPosition(n)
			
			def ExtendToNItemsQ(n)
				This.ExtendToNItems(n)
				return This

		def Extend(n)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNItems ])
				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		aResult = This.Copy().ExtendToPositionQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNItems(n)
			return This.ExtendedToPosition(n)

		#>

	  #-------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION WITH A GIVEN VALUE  #
	#-------------------------------------------------------------#

	def ExtendToPositionWith(n, pValue)
		if isList(pValue) and StzListQ(pValue).IsWithOrByOrUsingNamedParam()
			pvalue = pValue[2]
		ok
			
		if isString(pValue) and pValue = :ItemsRepeated
			This.ExtendToPositionWithItemsRepeated(n)
			return
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		aContent = This.Conten()

		if n > nLen

			nExtend = n - nLen
			for i = 1 to nExtend
				aContent + pValue
			next
		ok

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pValue)
			This.ExtendToPositionWith(n, pValue)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pValue)
			This.ExtendToPositionWith(n, pValue)

			def ExtendToWithQ(n, pValue)
				return This.ExtendToPositionWithQ(n, pValue)

		def ExtendToXT(n, pValue)
			This.ExtendToPositionWith(n, pValue)

			def ExtendToXTQ(n, pValue)
				return This.ExtendToPositionWithQ(n, pValue)

		def ExtendToPositionXT(n, pValue)
			This.ExtendToPositionWith(n, pValue)

			def ExtendToPositionXTQ(n, pValue)
				return This.ExtendToPositionWithQ(n, pValue)

		#>

	def ExtendedToPositionWith(n, pValue)
		aResult = This.Copy().ExtendToPositionWithQ(n, pValue).Content()
		return aResult

		def ExtendedToWith(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

		def ExtendedToXT(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

		def ExtendedToPositionXT(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

		#-- Misspelled

		def ExtendtedToWith(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

	  #----------------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION BY REPEATING THE LIST ITEMS  #
	#----------------------------------------------------------------------#
	
	def ExtendToPositionWithItemsRepeated(n)
		This.ExtendToPositionWithItemsIn(n, This.List())

		#< @FunctionFluentForm

		def ExtendToPositionWithItemsRepeatedQ(n)
			This.ExtendToPositionWithItemsRepeated(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtendToWithItemsRepeated(n)
			This.ExtendToPositionWithItemsRepeated(n)

			def ExtendToWithItemsRepeatedQ(n)
				This.ExtendToWithItemsRepeated(n)
				return This

		def ExtendToByRepeatingItems(n)
			This.ExtendToPositionWithItemsRepeated(n)

			def ExtendtoByRepeatingItemsQ(n)
				This.ExtendtoByRepeatingItems(n)
				return This

		#>

	def ExtendedToPositionWithItemsRepeated(n)
		aResult = This.Copy().ExtendToPositionWithItemsRepeatedQ(n).Content()
		return aResult

		#< @FunctionAlternativeForm

		def ExtendedToWithItemsRepeated(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		def ExtendedToByRepeatingItems(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		#>

		#< @FunctionMisspelledForm

		def ExtendtedToWithItemsRepeated(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		#>

	  #----------------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION BY REPEATING THE LIST ITEMS  #
	#----------------------------------------------------------------------#

	def ExtendToPositionWithItemsIn(n, paItems)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = len(paItems)
		nTemp = n - nLen
		aTemp = []

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				aTemp + paItems[j]
			next
		ok

		This.ExtendWith(aTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithItemsInQ(n, paItems)
			This.ExtendToPositionWithItemsIn(n, paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithItemsIn(n, paItems)
			return This.ExtendToPositionWithItemsIn(n, paItems)

			def ExtendToWithItemsInQ(n, paItems)
				This.ExtendToWithItemsIn(n, paItems)
				return This

		#>

	def ExtendedToPositionWithItemsIn(n, paItems)
		aResult = This.Copy().ExtendToPositionWithItemsInQ(n, paItems).Content()
		return aResult

		def ExtendedToWithItemsIn(n, paItems)
			return This.ExtendedToPositionWithItemsIn(n, paItems)

		#-- Misspelled

		def ExtendtedToWithItemsIn(n, paItems)
			return This.ExtendedToPositionWithItemsIn(n, paItems)

	  #------------------------------------------------#
	 #  EXTENDING THE LIST - A GENERAL EXTENDED FORM  #
	#------------------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :List, :With = ["D", "E"])
		o1.Show()
		#--> [ "A", "B", "C", "D", "E" ])

		EXAMPLE 2

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :List, :ToPosition = 5 )
		o1.Show()
		#--> [ "A", "B", "C", "", "" ]

		EXAMPLE 3

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPosition = 5, :With = :ItemsRepeated )
		# Or: o1.ExtendXT( :ToPosition = 5, :ByRepeatingItems )
		o1.Show()
		#--> [ "A", "B", "C", "A", "B" ])

		EXAMPLE 4

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> [ "A", "B", "C", "*", "*" ]

		EXAMPLE 5

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPosition = 5, :WithItemsIn = [ "D", "E" ])
		o1.Show()
		#--> [ "A", "B", "C", "D", "E" ]

		*/

		if isString(n) and n = :List

			# Case 1: o1.ExtendXT( :List, :With = ["D", "E"])
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :List, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			oParam = Q(pWith)

			if isList(pWith) and oParam.IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :ItemsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :ItemsRepeated or pWith[2] = :RepeatingItems )

					This.ExtendToPositionWithItemsRepeated(n[2])
					#NOTE this is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    ring_find([ :ByRepeatingItems, :WithItemsRepeated,
					:ByItemsRepeated ], pWith ) > 0

				if isList(n) and Q(n).IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithItemsRepeated(n)
				return

			# Case 5: o1.ExtendXT( :ToPosition = 5, :WithItemsIn = [ "D", "E" ])
			but oParam.IsWithItemsInNamedParam()
				This.ExtendToPositionWithItemsIn(n[2], pWith[2])
				return

			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionFluentForm

		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		aResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return aResult

		#< @FunctionMisspelledForm

		def ExtendtedXT(n, pWith)
			return This.ExtendedXT(n, pWith)

	  #------------------------------------------#
	 #  SHRINKING THE LIST TO A GIVEN POSITION  #
	#==========================================#

	def ShrinkTo(n)
		if isList(n) and Q(n).IsPositionNamedParam()
			n = n[2]
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveItemsAtPositions( (n+1) : nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNItems(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNItemsQ(n)
				This.ShrinkToNItems(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNItems(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================================#
	 #  MERGING THE LIST - IF IT IS A LIST OF LISTS  #
	#===============================================#

	def Merge()

		aContent = This.Content()
		nLen = This.NumberOfItems()

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				nLenList = len(aContent[i])
				for j = 1 to nLenList
					aResult + aContent[i][j]
				next
			else
				aResult + aContent[i]
			ok
		next

		This.Update(aResult)

		def MergeQ()
			This.Merge()
			return This

	def Merged()
		aResult = This.Copy().MergeQ().Content()
		return aResult

	  #-----------------------------------------#
	 #   MERGING THE LIST WITH AN OTHER LIST   #
	#-----------------------------------------#

	def MergeWith(paOtherList)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param! paOtherList must be a list.")
		ok

		nLen = len(paOtherList)

		for i = 1 to nLen
			This.Add(paOtherList[i])
		next

		def MergeWithQ(paOtherList)
			This.MergeWith(paOtherList)
			return This

	def MergedWith(paOtherList)
		aResult = This.Copy().MergeWithQ(paOtherList).Content()
		return aResult

	  #----------------------------#
	 #     FLATTENING THE LIST    #
	#----------------------------#
	
	# This preserves all the actual data while removing
	# both nesting and empty structures, making it cleaner
	# and more useful for most purposes.

	def Flatten() 
		/* EXAMPLE

		o1 = new stzList([ "A", [ "]B[", "C" ], "D", [ [ "E", "F" ] ] ]
		? o1.Flatten()

		#--> [ "A", "B", "C", "D" ]

		*/

		aContent = This.Content()
		nLen = This.NumberOfItems()
		
		aResult = []
		aTemp = []

		for i = 1 to nLen

			if isList(aContent[i])

				aTemp = Q(aContent[i]).Flattened()
				nLenTemp = len(aTemp)

				for j = 1 to nLenTemp
					aResult + aTemp[j]
				next
			else
				aResult + aContent[i]
			ok
		next
		
		This.Update(aResult)

		#< @FunctionFluentForm

		def FlattenQ()
			This.Flatten()
			return This

		def FlattenQRT(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.Flattened() )
				on :stzListOfStrings
					return new stzListOfStrings( This.Flattened() )

				on :stzListOfNumbers
					return new stzListOfNumbers( This.Flattened() )

				on :stzListOfLists
					return new stzListOfLists( This.Flattened() )

				on :stzListOfPairs
					return new stzListOfPairs( This.Flattened() )

				on :stzListOfObjects
					return new stzListOfObjects( This.Flattened() )

				other
					StzRaise("Unsupported return type!")
				off
		#>
	
	def Flattened()
		aResult = This.Copy().FlattenQ().Content()
		return aResult

	  #----------------------#
	 #     FROM/TO LIST     #
	#----------------------#
	#TODO
	# Do it for all Softanza classes()

	def ToStzTable()
		return new stzTable( This.Content() )

	def ToStzGrid()
		return new stzGrid( This.Content() )

	def ToStzSet()
		return new stzSet( This.ToSet() )

	def ToStzListOfNumbers()
		return new stzListOfNumbers( This.Content() )

	def ToStzListOfLists()
		return new stzListOfLists(This.Content())

	def ToStzListOfPairs()
		return new stzListOfPairs(This.Content())

	def ToStzListOfStrings()
		return new stzListOfStrings(This.Content())

	def ToStzHashList()
		return new stzHashList( This.List() )

	  #-----------------------------------------------------#
	 #     NUMBER OF OCCURRENCE OF AN ITEM IN THE LIST     #
	#=====================================================#
	
	def NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#WARNING // Risky implementation!

		# I use the list stringifuing technique for performance, but!

		# ~> If ToCoode() changes its ouput format in the future,
		# and the items are nolonger separated by " ,", neigher the last
		# two chars are " ]", then the function will be wrong!

		#TODO // Think of a more robust solution!

		if CheckingParams()
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
		ok

		# Doing the job

		oListInStr = new stzString( This.ToCodeQ().LastNCharsRemoved(2) + ", ]" )

		nResult = len( oListInStr.SplitCS( " " + @@(pItem) + ",", pCaseSensitive) ) - 1

		return nResult


		#< @FunctionAlternativeForms

		def NumberOfOccurrencesCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def CountCS(pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def HowManyCS(pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def ItemOccursNTimesCS(n, pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def NumberOfDuplicationsOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def NumberOfDuplicationOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#--

		def NumberOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NumberOfOccurenceCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#--

		def NumberOfDupplicatesOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def NumberOfDupplicationsOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def NumberOfDupplicationOfCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pItem)
		return This.NumberOfOccurrenceCS(pItem, _TRUE_)

		#< @FucntionAlternativeForms

		def NumberOfOccurrences(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfOccurrencesOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfOccurrenceOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def Count(pItem)
			return This.NumberOfOccurrence(pItem)

		def HowMany(pItem)
			return This.NumberOfOccurrence(pItem)

		def ItemOccursNTimes(n, pItem)
			return This.NumberOfOccurrence(pItem)

		#--

		def NumberOfDuplicatesOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfDuplicationsOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfDuplicationOf(pItem)
			return This.NumberOfOccurrence(pItem)

		#--

		def NumberOf(pItem)
			return This.NumberOfOccurrence(pItem)

		#>
	
		#< @FunctionMisspelledForm

		def NumberOfOccurence(pItem)
			return This.NumberOfOccurrence(pItem)

		#--

		def NumberOfDupplicatesOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfDupplicationsOf(pItem)
			return This.NumberOfOccurrence(pItem)

		def NumberOfDupplicationOf(pItem)
			return This.NumberOfOccurrence(pItem)

		#

	  #--------------------------------------------------------------------#
	 #     NUMBER OF OCCURRENCE OF AN ITEM STARTING AT A GIVEN POSITION   #
	#--------------------------------------------------------------------#
	
	def NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		if CheckingParams()
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if isString(pnStartingAt)
				if pnStartingAt = :Start or
			  	   pnStartingAt = :First or
				   pnStartingAt = :FirstChar

					pnStartingAt = 1

				but pnStartingAt = :End or
			  	    pnStartingAt = :Last or
				    pnStartingAt = :LastChar

					pnStartingAt = This.NumberOfChars()
				ok
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		# Doing the job

		nResult = This.SectionQ(pnStartingAt, This.NumberOfItems()).
			       NumberOfOccurrenceCS(pItem, pCaseSensitive)		

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def CountSTCS(pItem, pnStartingAt, pCaseSensitive)
			return NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def HowManySTCS(pItem, pnStartingAt, pCaseSensitive)
			return NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def ItemOccursNTimesSTCS(n, pnStartingAt, pItem, pCaseSensitive)
			return NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def NumberOfDuplicationsOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def NumberOfDuplicationOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def NumberOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NumberOfOccurenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def NumberOfDupplicatesOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def NumberOfDupplicationsOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		def NumberOfDupplicationOfSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)

		#

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceST(pItem, pnStartingAt)
		return This.NumberOfOccurrenceSTCS(pItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		def CountST(pItem, pnStartingAt)
			return NumberOfOccurrenceST(pItem, pnStartingAt)

		def HowManyST(pItem, pnStartingAt)
			return NumberOfOccurrenceST(pItem, pnStartingAt)

		def ItemOccursNTimesST(n, pnStartingAt, pItem)
			return NumberOfOccurrenceST(pItem, pnStartingAt)

		#--

		def NumberOfDuplicatesOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		def NumberOfDuplicationsOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		def NumberOfDuplicationOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		#--

		def NumberOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		#>

		#< @FunctionMisspelledForm

		def NumberOfOccurenceST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		#--

		def NumberOfDupplicatesOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		def NumberOfDupplicationsOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		def NumberOfDupplicationOfST(pItem, pnStartingAt)
			return This.NumberOfOccurrenceST(pItem, pnStartingAt)

		#

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING N (OR MORE) TIMES IN THE LIST  #
	#=========================================================#

	def ItemsOccurringNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) >= n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringAtLeastNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringAtLeastNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringNTimes(n)
		return This.ItemsOccurringNTimesCS(n, _TRUE_)

		#< @FunctionFluentForm

		def ItemsOccurringNTimesQ(n)
			return This.ItemsOccurringNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimes(n) # On r instead of 2
			return This.ItemsOccurringNTimes(n)

			def ItemsOccuringNTimesQ(n)
				return This.ItemsOccurringNTimesQ(n)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNTimesOrMore(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringNTimesOrMoreQ(n)
				return This.ItemsOccuringNTimesQ(n)

		def ItemsOccurringNTimesAndMore(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringNTimesAndMoreQ(n)
				return This.ItemsOccuringNTimesQ(n)

		def ItemsOccurringAtLeastNTimes(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringAtLeastNTimesQ(n)
				return This.ItemsOccuringNTimesQ(n)

		#>

	  #-------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING EXACTLY N TIMES IN THE LIST  #
	#-------------------------------------------------------#

	def ItemsOccurringExactlyNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) = n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringExactlyNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringExactlyNTimesCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringExactlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringExactlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringExactlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringExactlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#--

		def ItemsOccurringOnlyNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringOnlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringOnlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringExactlyNTimes(n)
		return This.ItemsOccurringExactlyNTimesCS(n, _TRUE_)

		#< @FunctionFluentForm

		def ItemsOccurringExactlyNTimesQ(n)
			return This.ItemsOccurringExactlyNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringExactlyNTimes(n) # On r instead of 2
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccuringExactlyNTimesQ(n)
				return This.ItemsOccurringExactlyNTimesQ(n)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringExactlyNTimesOrMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringExactlyNTimesOrMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringExactlyNTimesAndMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringExactlyNTimesAndMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		#--

		def ItemsOccurringOnlyNTimes(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringOnlyNTimesOrMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesOrMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringOnlyNTimesAndMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesAndMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		#>

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING MORE THAN N TIMES IN THE LIST  #
	#---------------------------------------------------------#

	def ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) > n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNoLessThanNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		def ItemsOccuringNoLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringMoreThanNTimes(n)
		return This.ItemsOccurringMoreThanNTimesCS(n, _TRUE_)

		#< @FunctionFluentForm

		def ItemsOccurringMoreThanNTimesQ(n)
			return This.ItemsOccurringMoreThanNTimes(n)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNoLessThanNTimes(n)
			return This.ItemsOccurringMoreThanNTimes(n)

			def ItemsOccurringNoLessThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringMoreThanNTimes(n) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimes(n)

			def ItemsOccuringMoreThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		def ItemsOccuringNoLessThanNTimes(n) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n)

			def ItemsOccuringNoLessThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		#>

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING LESS THAN N TIMES IN THE LIST  #
	#---------------------------------------------------------#

	def ItemsOccurringLessThanNTimesCS(n, pCaseSensitive) #TODO // Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) < n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringNoMoreThanNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		def ItemsOccuringNoMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringLessThanNTimes(n)
		return This.ItemsOccurringLessThanNTimesCS(n, _TRUE_)

		#< @FunctionFluentForm

		def ItemsOccurringLessThanNTimesQ(n)
			return This.ItemsOccurringLessThanNTimes(n)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringNoMoreThanNTimes(n)
			return This.ItemsOccurringLessThanNTimesCS(n)

			def ItemsOccurringNoMoreThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringLessThanNTimes(n)
			return This.ItemsOccurringLessThanNTimes(n)

			def ItemsOccuringLessThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		def ItemsOccuringNoMoreThanNTimes(n)
			return This.ItemsOccurringLessThanNTimes(n)

			def ItemsOccuringNoMoreThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		#>

	  #-------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING N TIMES OR LESS IN THE LIST  #
	#-------------------------------------------------------#

	def ItemsOccurringNTimesOrLessCS(n, pCaseSensitive) #TODO // Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) <= n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringNTimesOrLessCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringNTimesOrLessCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesOrLessCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringNTimesOrLessCS(n, pCaseSensitive)

			def ItemsOccuringNTimesOrLessCSQ(n, pCaseSensitive)
				return This.ItemsOccurringNTimesOrLessCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringNTimesOrLess(n)
		return This.ItemsOccurringNTimesOrLessCS(n, _TRUE_)

		#< @FunctionFluentForm

		def ItemsOccurringNTimesOrLessQ(n)
			return This.ItemsOccurringNTimesOrLess(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesOrLess(n) # On r instead of 2
			return This.ItemsOccurringNTimesOrLess(n)

			def ItemsOccuringNTimesOrLessQ(n)
				return This.ItemsOccurringNTimesOrLessQ(n)

		#>

	  #------------------------------------------------------------------#
	 #  GETTING THE ITEMS WITH THEIR NUMBER OF OCCURRENCES IN THE LIST  #
	#------------------------------------------------------------------#

	def ItemsAndTheirNumberOfOccurrenceCS(pCaseSensitive)
		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aList = @aContent

		if pCaseSensitive = _FALSE_
			aList = This.Lowercased()
		ok

		nLenList = len(aList)

		# Early cheks

		if nLenList = 0
			return []
		ok

		acListStringified = []
		for i = 1 to nLenList
			acListStringified + @@(aList[i])
		next

		aResult = []
		acSeen = []
		for i = 1 to nLenList
			if ring_find(acSeen, acListStringified[i])
				loop
			ok

			//anPos = []
			nPos = 0

			for j = 1 to nLenList
				if acListStringified[i] = acListStringified[j]
					//anPos + j
					nPos++
				ok
			next

			//aResult + [ aList[i], anPos ]
			aResult + [ aList[i], nPos ]
			acSeen + acListStringified[i]
		next

		return aResult

		#< @FunctionAlternativeForms

		def ItemsAndTheirNumberOfOccurrencesCS(pCaseSensitive)
			return This.ItemsAndTheirNumberOfOccurrenceCS(pCaseSensitive)

		def IndexByNumberOfOccurrenceCS(pCaseSensitive)
			return This.ItemsAndTheirNumberOfOccurrenceCS(pCaseSensitive)

		def IndexByNumberOfOccurrencesCS(pCaseSensitive)
			return This.ItemsAndTheirNumberOfOccurrenceCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsAndTheirNumberOfOccurrence()
		return This.ItemsAndTheirNumberOfOccurrenceCS(_TRUE_)

		#< @FunctionAlternativeForms

		def ItemsAndTheirNumberOfOccurrences()
			return This.ItemsAndTheirNumberOfOccurrence()

		def IndexByNumberOfOccurrence()
			return This.ItemsAndTheirNumberOfOccurrence()

		def IndexByNumberOfOccurrences()
			return This.ItemsAndTheirNumberOfOccurrence()

		#>

	#--- #TODO add

	// def IndexByPosition()

	// def IndexBy(pcPosOrOccurr)

	  #--------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF EACH ITEM CONTAINED IN THE LIST  #
	#==============================================================#

	def FindItemsCS(pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "Ab", "Im", "Ab", "Cf", "Fd", "Ab", "Cf" ])

		? @@( o1.FindItems() ) # Or PositionsOfEachItem()

		#--> [
		#	[ "Ab", [ 1, 3, 6 ] ],
		#	[ "Im", [ 2 ] ],
		#	[ "Cf", [ 4, 7 ] ],
		#	[ "Fd", [ 5 ] ]
		# ]

		*/

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aList = @aContent

		if pCaseSensitive = _FALSE_
			aList = This.Lowercased()
		ok

		nLenList = len(aList)

		# Early cheks

		if nLenList = 0
			return []
		ok

		acListStringified = []
		for i = 1 to nLenList
			acListStringified + @@(aList[i])
		next

		aResult = []
		acSeen = []
		for i = 1 to nLenList
			if ring_find(acSeen, acListStringified[i])
				loop
			ok

			anPos = []

			for j = 1 to nLenList
				if acListStringified[i] = acListStringified[j]
					anPos + j
				ok
			next

			aResult + [ aList[i], anPos ]
			acSeen + acListStringified[i]
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindItemsCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def ItemsCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def FindEachItemCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def FindEachItemCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		
		def ItemsAndTheirPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def PositionsOfEachItemCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def EachItemAndItsPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def EachItemCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def IndexCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def IndexByPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindItems()
		return This.FindItemsCS(_TRUE_)

		#< @FunctionAlternativeForm

		def FindItemsZ(pCaseSensitive)
			return This.FindItems()

		def ItemsZ()
			return This.FindItems()

		def FindEachItem()
			return This.FindItems()

		def FindEachItemZ()
			return This.FindItems()

		
		def ItemsAndTheirPositions()
			return This.FindItems()

		def PositionsOfEachItem()
			return This.FindItems()

		def EachItemAndItsPositions()
			return This.FindItems()

		def EachItemZ()
			return This.FindItems()

		def Index()
			return This.FindItems()

		def IndexByPositions()
			return This.FindItems()

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCES OF EACH ITEM CONTAINED IN THE LIST  #
	#------------------------------------------------------------------------#

	def NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aList = @aContent

		if pCaseSensitive = _FALSE_
			aList = This.Lowercased()
		ok

		nLenList = len(aList)

		# Early cheks

		if nLenList = 0
			return []
		ok

		# Doing the job

		aItems = This.WithoutDuplicationCS(pCaseSensitive)
		nLenItems = len(aItems)

		aResult = []
	
		for i = 1 to nLenItems
			n = 0
			for j = 1 to nLenList
				if ring_type(aItems[i]) = ring_type(aList[j]) and
				   aItems[i] = aList[j]

					n++
				ok
			next
			aResult + [ aItems[i], n ]
		next
			
		return aResult

		#< @FunctionAlternativeForms

		def ItemsCountCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def NumberOfOccurrenceOfEachItemCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrenceItemsHaveCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrenceEachItemHasCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		#--

		def NumberOfOccurrencesOfItemsCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def NumberOfOccurrencesOfEachItemsCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrencesItemsHaveCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrencesEachItemHasCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceOfItems()
		return This.NumberOfOccurrenceOfItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def ItemsCount()
			return This.NumberOfOccurrenceOfItems()

		def NumberOfOccurrenceOfEachItem()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrenceItemsHave(paseSensitive)
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrenceEachItemHas()
			return This.NumberOfOccurrenceOfItems()

		#--

		def NumberOfOccurrencesOfItems()
			return This.NumberOfOccurrenceOfItems()

		def NumberOfOccurrencesOfEachItems()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrencesItemsHave()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrencesEachItemHas()
			return This.NumberOfOccurrenceOfItems()

		#>

	   #=============================================================#
	  #  FINING NEAREST OCCURRENCE OF AN ITEM TO A GIVEN POSITION,  #
	 #  SECTION, OR GIVEN OTHER ITEM                               #
	#=============================================================#

	#TODO
	# Add FindNNearest(n, pItem, pToPositionSectionOrItem, pCaseSensitive)

	def FindNearestCS(pItem, pToPositionSectionOrItem, pCaseSensitive)

		oParam = Q(pToPositionSectionOrItem)
		if oParam.IsToNamedParam()
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToPositionNamedParam()
			return This.FindNearestToPositionCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToPositionsNamedParam()
			return This.FindNearestToPositionsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToSectionNamedParam()

			n1 = pToPositionSectionOrItem[2][1]
			n2 = pToPositionSectionOrItem[2][2]

			return This.FindNearestToSectionCS(pItem, n1, n2, pCaseSensitive)

		but oParam.IsToSectionsNamedParam()
			return This.FindNearestToSectionsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToItemNamedParam()
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToItemsNamedParam()
			return This.FindNearestToItemsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		else
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNearest(pItem, pToPositionSectionOrItem)
		return This.FindNearestCS(pItem, pToPositionSectionOrItem, _TRUE_)

	  #-----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN POSITION  #
	#=================================================================#

	def FindNearestToPositionCS(pItem, pnPos, pCaseSensitive)
		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(pnPos)
				if pnPos = :FirstItem
					pnPos = 1
				but pnPos = :LastItem
					pnPos = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok

		ok

		if NOT pnPos > 0 and pnPos < This.NumberOfItems()
			StzRaise("Index out of range!")
		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		anDiff = []
		for i = 1 to nLenPos
			anDiff + Abs(pnPos - anPos[i])
		next

		nResult = anPos[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPosition(pItem, pnPos)
		return This.FindNearestToPositionCS(pItem, pnPos, _TRUE_)
	
	  #------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCES OF AN ITEM TO A GIVEN POSITION -- XT  #
	#------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToPositionCSXT(pItem, pnPos, pCaseSensitive)
		if CheckingParams()
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok
		ok

		if pnPos < 1 ans pnPos > This.NumberOfItems()
			StzRaise("Index out of range! pnPost must be inside the list.")
		ok

		anResult = This.FindNearestToSectionCSXT(pItem, pnPos, pnPos, pCaseSensitive)

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionXT(pItem, pnPos)
		return This.FindNearestToPositionCSXT(pItem, pnPos, _TRUE_)

	  #----------------------------------------------------------------#
	 #  FINDING NEAREST OCCURRENCE OF AN ITEM TO THE GIVEN POSITIONS  #
	#----------------------------------------------------------------#

	def FindNearestToPositionsCS(pItem, panPos, pCaseSensitive)
	
		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckingParams()

			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return 0
		ok

		anNearest = []
		anDiff = []

		for i = 1 to nLenPos
			anTemp = This.FindNearestToPositionCSXT(pItem, panPos[i], pCaseSensitive)
			nDiff1 = panPos[i] - anTemp[1]
			nDiff2 = anTemp[2] - panPos[i]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositions(pItem, panPos)
		return This.FindNearestToPositionsCS(pItem, panPos, _TRUE_)

	  #----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN SECTION  #
	#================================================================#

	def FindNearestToSectionCS(pItem, n1, n2, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(n1)
				if n1 = :FirstItem
					n1 = 1

				but n1 = :LastItem
					n1 = nLenList
				ok
			ok
			if isString(n2)
				if n2 = :LastItem
					n2 = nLenList

				but n2 = :FirstItem
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenList) and (n2 > 0 and n2 < nLenList) )
			StzRaise("Index out of range! n1 and n2 must be both inside the list.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pItem, n1, pCaseSensitive)
		nDistBefore = n1 - nNearestBefore

		nNearestAfter  = This.SectionQ(n2, nLenList).
				 FindNearestToPositionCS(pItem, 1, pCaseSensitive) + n2 - 1

		nDistAfter = nNearestAfter - n2
		
		if nDistBefore < nDistAfter
			nResult = nNearestBefore
		else
			nResult = nNearestAfter
		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSection(pItem, n1, n2)
		return This.FindNearestToSectionCS(pItem, n1, n2, _TRUE_)

	  #---------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN SECTION -- XT #
	#---------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToSectionCSXT(pItem, n1, n2, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckingParams()

			if isString(n1)
				if n1 = :FirstItem
					n1 = 1

				but n1 = :LastItem
					n1 = nLenList
				ok
			ok
			if isString(n2)
				if n2 = :LastItem
					n2 = nLenList

				but n2 = :FirstItem
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenList) and (n2 > 0 and n2 < nLenList) )
			StzRaise("Index out of range! n1 and n2 must be both inside the list.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pItem, n1, pCaseSensitive)

		nNearestAfter  = This.SectionQ(n2, nLenList).
				 FindNearestToPositionCS(pItem, 1, pCaseSensitive) + n2 - 1

		anResult = [ nNearestBefore, nNearestAfter ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSectionXT(pItem, n1, n2)
		return This.FindNearestToSectionCSXT(pItem, n1, n2, _TRUE_)

	  #-------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO THE SECTIONS  #
	#-------------------------------------------------------------#

	def FindNearestToSectionsCS(pItem, paSections, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		nLenSections = len(paSections)
		anNearest = []
		anDiff = []

		for i = 1 to nLenSections
			anTemp = This.FindNearestToSectionCSXT(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nDiff1 = paSections[i][1] - anTemp[1]
			nDiff2 = anTemp[2] - paSections[i][2]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSections(pItem, paSections)
		return This.FindNearestToSectionsCS(pItem, paSections, _TRUE_)

	  #-------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN OTHER ITEM  #
	#===================================================================#

	def FindNearestToItemCS(pItem, pcOtherItem, pCaseSensitive)

		anPos = This.FindAllCS(pcOtherItem, pCaseSensitive)

		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		nResult = This.FindNearestToPositionsCS(pItem, anPos, pCaseSensitive)

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToItem(pItem, pcOtherSubStr)
		return This.FindNearestToItemCS(pItem, pcOtherSubStr, _TRUE_)

	  #------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO GIVEN OTHER ITEMS  #
	#------------------------------------------------------------------#

	def FindNearestToItemsCS(pItem, pacOtherItems, pCaseSensitive)

		anPos = This.FindManyCS(pacOtherItems, pCaseSensitive)

		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		nResult = This.FindNearestToPositionsCS(pItem, anPos, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToItems(pItem, pacOtherItems)
		return This.FindNearestToItemsCS(pItem, pcOtherSubStr, _TRUE_)

	  #==================================================#
	 #  CHECKING IF AN ITEM IS DUPPLICATED IN THE LIST  #
	#==================================================#

	def ItemIsDuplicatedCS(pItem, pCaseSensitive)

		nFirstPos = This.FindFirstCS(pItem, pCaseSensitive)

		nFindBefore = This.FindPreviousCS(pItem, :StartingAt = nFirstPos, pCaseSensitive)
		if nFindBefore != 0
			return _TRUE_
		ok

		nFindAfter = This.FindNext(pItem, :StartingAt = nFirstPos, pCaseSensitive)
		if nFindAfter != 0
			return _TRUE_
		ok

		return _FALSE_

		#< @FunctionAlternativeForms

		def ItemIsDuplicateCS(pItem, pCaseSensitive)
			return This.IsDuplicatedCS(pItem, pCaseSensitive)

		def ItemIsADuplicateCS(pItem, pCaseSensitive)
			return This.IsDuplicatedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemIsDuplicated(pItem)
		return This.ItemIsDuplicatedCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ItemIsDuplicate(pItem)
			return This.IsDuplicated(pItem)

		def ItemIsADuplicate(pItem)
			return This.IsDuplicated(pItem)

		#>

	  #-----------------------------------------------------#
	 #  CHECKING IF MANY ITEMS ARE DUPLICATED IN THE LIST  #
	#-----------------------------------------------------#

	def ItemsAreDuplicatedCS(paItems, pCaseSensitive)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = len(paItems)
		bResult = _TRUE_

		for i = 1 to nLen
			if NOT This.ItemIsDuplicatedCS(pItem, pCaseSensitive)
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def ItemsAreDuplicatesCS(paItems, pCaseSensitive)
			return This.ItemsAreDuplicatedCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ItemsAreDuplicated(paItems)
		return This.ItemsAreDuplicatedCS(paItems, _TRUE_)
		
		def ItemsAreDuplicates(paItems)
			return This.ItemsAreDuplicated(paItems)

	  #----------------------------------------------------#
	 #   CHECKING IF THE LIST CONTAINS DUPLICATED ITEMS   #
	#----------------------------------------------------#

	#WARNING// As implemented currently, duplication is performed
	# in a reasonable performance when the size of the list does
	# not exceed 30K items!

	def ContainsDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)


		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next

		ok

		# Checking if an item is a duplicate

		bResult = _FALSE_
		acSeen = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
			else
				bResult = _TRUE_
				exit
			ok

		next

		return bResult
			
		#< @FunctionAlternativeForms

		def ContainsDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		def ContainsDuplicationsCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		def ContainsDuplicationCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicates()
		return This.ContainsDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForms

		def ContainsDuplicatedItems()
			return This.ContainsDuplicates()

		def ContainsDuplications()
			return This.ContainsDuplicates()

		def ContainsDuplication()
			return This.ContainsDuplicates()

		#>

	  #-----------------------------------------------------#
	 #   CHECHKING IF A GIVEN ITEM IS DUPLICATED N-TIMES   #
	#-----------------------------------------------------#

	def ItemIsDuplicatedNTimesCS(n, pItem, pCaseSensitive)
		if This.NumberOfDuplicatesOfItemCS(pItem, pCaseSensitive) = n
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WITHOUT CASESENSITIVITY

	def ItemIsDuplicatedNTimes(n, pItem)
		return This.ItemIsDuplicatedNTimesCS(n, pItem, _TRUE_)

	  #----------------------------------------------------#
	 #  CHECKING IF ALL ITEMS IN THE LIST ARE DUPLICATED  #
	#----------------------------------------------------#

	def AllItemsAreDuplicatedCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)


		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])			
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next

		ok

		# Checking if an item is a duplicate

		bResult = _TRUE_
		acSeen = []
		acNonDuplicated = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
				acNonDuplicated + acStr[i]
			else
				nPos = ring_find( acNonDuplicated, acStr[i] )
				if nPos > 0
					ring_del(acNonDuplicated, nPos)
				ok
	
			ok

		next

		if len(acNonDuplicated) > 0
			bResult = _FALSE_
		ok

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def AllItemsAreDuplicated()
		return This.AllItemsAreDuplicatedCS(_TRUE_)

	  #-------------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS A SET (CONTAINS NO DUPLICATIONS AT ALL)  #
	#===================================================================#

	def ContainsNoDuplicatesCS(pCaseSensitive) # Alternative of IsSet()

		# Checking params

		if CheckingParams()

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
				StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
			ok

		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if EarlyCheck()
			if nLen = 0
				return _FALSE_
			ok
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next

		ok

		# Checking if an item is a duplicate

		bResult = _TRUE_
		acSeen = []
		acNonDuplicated = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
				acNonDuplicated + acStr[i]
			else
				nPos = ring_find( acNonDuplicated, acStr[i] )
				if nPos > 0
					bResult = _FALSE_
					exit
				ok
	
			ok

		next

		return bResult

		#< @FunctionAlterativeForms

		def ContainsNoDuplicatesAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicatedItemsAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationsAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatedCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatesCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatedAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatesAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def IsSetCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def IsASetCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNoDuplicates()
		return This.ContainsNoDuplicatesCS(_TRUE_)

		#< @FunctionAlterativeForms

		def ContainsNoDuplicatesAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicatedItems()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicatedItemsAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplications()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicationsAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplication()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicationAtAll()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicated()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicates()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicatedAtAll()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicatesAtAll()
			return This.ContainsNoDuplicates()

		def IsSet()
			return This.ContainsNoDuplicates()

		def IsASet()
			return This.ContainsNoDuplicates()

		#>

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)
		nResult = len( This.FindDuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForm

		def NumberOfDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def NumberOfDuplicationsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def NumberOfDuplicationCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#--

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicatedItemCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicationsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicationCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManuDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForm

		def NumberOfDuplicatedItems()
			return This.NumberOfDuplicates()

		def NumberOfDuplications()
			return This.NumberOfDuplicates()

		def NumberOfDuplication()
			return This.NumberOfDuplicates()

		#--

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		def HowManyDuplicatedItems()
			return This.NumberOfDuplicates()

		def HowManyDuplicatedItem()
			return This.NumberOfDuplicates()

		def HowManyDuplications()
			return This.NumberOfDuplicates()

		def HowManyDuplication()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		def HowManuDuplicate()
			return This.NumberOfDuplicates()

		#>

	  #------------------------------------------#
	 #  GETTING DUPLICATES AND THEIR POSITIONS  #
	#------------------------------------------#

	def DuplicatesCSZ(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can use them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
			
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding duplicates positions

		acSeen = [ acStr[1] ]
		anPos = [ [] ]

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anPos + [ i ]
			else
				anPos[ n ] + i
			ok

		next

		# Composing the association of items and their positions

		aResult = []
		nLen = len(acSeen)

		for i = 1 to nLen
			del(anPos[i], 1)
			if len(anPos[i]) > 0
				aResult + [ aContent[anPos[i][1]], anPos[i] ]
			ok
		next
		

		return aResult


		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicatedItemsAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicatedItemsCSZ(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsCSZ(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesZ()
		return This.DuplicatesCSZ(_TRUE_)

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicatedItemsAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicatedItemsZ()
			return This.DuplicatesZ()

		def DuplicationsAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicationsZ()
			return This.DuplicatesZ()

		#>

	  #----------------------------------#
	 #   FINDING DUPLICATES POSITIONS   #
	#----------------------------------#

	#NOTE 1 // The first occurrence of an item is not considered as a duplicate
	#  --> If you want to get also the first occurrence then you can
	#  use FindDuplicatesXT() #TODO

	#NOTE 2 // We use a part of the code of DuplicatesZ(). There is a duplication
	# but this is better for performance then calling DuplicatesZ(), because it
	# performs extra work not needed here!

	def FindDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]

			else
				anPos + i
			ok

		next

		return anPos

		#< @FunctionAlternativeForms

		def FindDuplicationsCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		def FindDuplicationCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		def FindDuplicatedItemsCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindDuplications()
			return This.FindDuplicates()

		def FindDuplication()
			return This.FindDuplicates()

		def FindDuplicatedItems()
			return This.FindDuplicates()

		#>

	  #------------------------------------------------------#
	 #  GETTING DUPLICATES AND THEIR POSITIONS -- EXTENDED  #
	#------------------------------------------------------#
	# Positions of first duplicates are also returned

	def DuplicatesCSXTZ(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anSeen = []

		anPos = []
		aResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
				aResult + [ aContent[i], [i] ]
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
				ok
				anPos + i

				aResult[n][2] + i
				
			ok

		next

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicatedItemsAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicatedItemsCSXTZ(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicationsAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsCSXTZ(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesXTZ()
		return This.DuplicatesCSXTZ(_TRUE_)

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicatedItemsAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicatedItemsXTZ()
			return This.DuplicatesXTZ()

		def DuplicationsAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicationsXTZ()
			return This.DuplicatesXTZ()

		#>

	  #----------------------------------------#
	 #   FINDING DUPLICATES POSITIONS -- XT   #
	#----------------------------------------#

	# FinDuplicates() returns the positions of the duplicated items.
	# Hence, the first occurrences of those items are not returned.
	# To return them, use this eXTended version of the function

	def FindDuplicatesCSXT(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anSeen = []

		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
				ok
				anPos + i
			ok

		next

		anPos = ring_sort(anPos)
		return anPos

		#< @FunctionAlternativeForms

		def FindDuplicationsCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		def FindDuplicationCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		def FindDuplicatedItemsCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesCSXT(_TRUE_)

		#< @FunctionAlternativeForms

		def FindDuplicationsXT()
			return This.FindDuplicatesXT()

		def FindDuplicationXT()
			return This.FindDuplicatesXT()

		def FindDuplicatedItemsXT()
			return This.FindDuplicatesXT()

		#>

	  #----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF EACH DUPLICATED ITEM  #
	#----------------------------------------------------#

	#NOTE // There is a better alternative name : FindDuplicatesOrigins()

	def FindFirstDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding first duplicates positions

		acSeen = []
		anSeen = []
		anPos = []

		anResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
					anResult + anSeen[n]
				ok
				anPos + i
			ok

		next

		return ring_sort(anResult)

		#< @FunctionAlternativeForms

		def FindFirstDuplicatedItemsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstDuplicationsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicatedItemCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicateCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicationCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristDuplicatesCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristDuplicatedItemsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristDuplicationsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicatedItemCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicateCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicationCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		#--

		def FindDupOriginsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindDuplicatesOriginsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindDupliationOriginsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindDuplicationsOriginsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDuplicates()
		return This.FindFirstDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindFirstDuplicatedItems()
			return This.FindFirstDuplicates()

		def FindFirstDuplications()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplicatedItem()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplicate()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplication()
			return This.FindFirstDuplicates()

		#--

		def FindDupOrigins()
			return This.FindFirstDuplicates()

		def FindDuplicatesOrigins()
			return This.FindFirstDuplicates()

		def FindDupliationOrigins()
			return This.FindFirstDuplicates()

		def FindDuplicationsOrigins()
			return This.FindFirstDuplicates()

		#>

		#< @FunctionMisspelledForms

		def FindFristDuplicates()
			return This.FindFirstDuplicates()

		def FindFristDuplicatedItems()
			return This.FindFirstDuplicates()

		def FindFristDuplications()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplicatedItem()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplicate()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplication()
			return This.FindFirstDuplicates()

		#>

	  #-------------------------------#
	 #  REMOVING DUPLICATES ORIGINS  #
	#-------------------------------#

	def RemoveDupOriginsCS(pCaseSensitive)
		anPos = This.FindDupOriginsCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveDupOriginsCSQ(pCaseSensitive)
			This.RemoveDupOriginsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOriginsCS(pCaseSensitive)
			This.RemoveDupOriginsCS(pCaseSensitive)

			def RemoveDuplicatesOriginsCSQ(pCaseSensitive)
				return This.RemoveDupOriginsCSQ(pCaseSensitive)

		def RemoveDuplicationsOriginsCS(pCaseSensitive)
			This.RemoveDupOriginsCS(pCaseSensitive)

			def RemoveDuplicationsOriginsCSQ(pCaseSensitive)
				return This.RemoveDupOriginsCSQ(pCaseSensitive)

		def RemoveDuplicationOriginsCS(pCaseSensitive)
			This.RemoveDupOriginsCS(pCaseSensitive)

			def RemoveDuplicationOriginsCSQ(pCaseSensitive)
				return This.RemoveDupOriginsCSQ(pCaseSensitive)

		#>

	def DupOriginsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDupOriginsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def DuplicatesOriginsRemovedCS(pCaseSensitive)
			return This. DupOriginsRemovedCS(pCaseSensitive)

		def DuplicationsOriginsRemovedCS(pCaseSensitive)
			return This. DupOriginsRemovedCS(pCaseSensitive)

		def DuplicationOriginsRemovedCS(pCaseSensitive)
			return This. DupOriginsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDupOrigins()
		This.RemoveDupOriginsCS(_TRUE_)

		#< @FunctionFluentForm

		def RemoveDupOriginsQ()
			This.RemoveDupOrigins()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOrigins()
			This.RemoveDupOrigins()

			def RemoveDuplicatesOriginsQ()
				return This.RemoveDupOriginsQ()

		def RemoveDuplicationsOrigins()
			This.RemoveDupOrigins()

			def RemoveDuplicationsOriginsQ()
				return This.RemoveDupOriginsQ()

		def RemoveDuplicationOrigins()
			This.RemoveDupOrigins()

			def RemoveDuplicationOriginsQ()
				return This.RemoveDupOriginsQ()

		#>

	def DupOriginsRemoved()
		cResult = This.Copy().RemoveDupOriginsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def DuplicatesOriginsRemoved()
			return This. DupOriginsRemoved()

		def DuplicationsOriginsRemoved()
			return This. DupOriginsRemoved()

		def DuplicationOriginsRemoved()
			return This. DupOriginsRemoved()

		#>

	  #----------------------------------#
	 #  GETTING THE LIST OF DUPLICATES  #
	#----------------------------------#

	def DuplicatesCS(pCaseSensitive)
		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next


		ok

		# Finding duplicated items

		acSeen = [ acStr[1] ]
		anPos = [ [] ]

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anPos + [ i ]
			else
				anPos[ n ] + i
			ok

		next

		# Constructing the list of items that are duplicated in the list

		aResult = []
		nLen = len(acSeen)

		for i = 1 to nLen
			if len(anPos[i]) > 1
				aResult + aContent[anPos[i][1]]
			ok
		next
		

		return aResult

		#< @FunctionFluentForm

		def DuplicatesCSQ(pCaseSensitive)
			return new stzList(This.DuplicatesCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForm

		def DuplicatedItemsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicatedItemsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		def DuplicationsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicationsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		#--

		def DuplicatesOriginsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicatesOriginsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		def DuplicationsOriginsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicationsOriginsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		def DuplicationOriginsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicationOriginsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		def DupOriginsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DupOriginsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(_TRUE_)

		#< @FunctionFluentForm

		def DuplicatesQ()
			return new stzList(This.Duplicates())

		#>

		#< @FunctionAlternativeForm

		def DuplicatedItems()
			return This.Duplicates()

			def DuplicatedItemsQ()
				return This.DuplicatesQ()

		def Duplications(pCaseSensitive)
			return This.Duplicates(pCaseSensitive)

			def DuplicationsQ(pCaseSensitive)
				return This.DuplicatesQ(pCaseSensitive)

		#--

		def DuplicatesOrigins()
			return This.Duplicates()

			def DuplicatesOriginsQ()
				return This.DuplicatesQ()

		def DuplicationsOrigins()
			return This.Duplicates()

			def DuplicationsOriginsQ()
				return This.DuplicatesQ()

		def DuplicationOrigins()
			return This.Duplicates()

			def DuplicationOriginsQ()
				return This.DuplicatesQ()

		def DupOrigins()
			return This.Duplicates()

			def DupOriginsQ()
				return This.DuplicatesQ()
		#>

	  #----------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN ITEM   #
	#----------------------------------------#

	def FindDuplicatesOfItemCS(pItem, pCaseSensitive)
		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		anResult = []

		if nLen > 1
			del(anPos, 1)
			anResult = anPos
		ok

		return anResult
		
		#< @FunctionAlternativeForms

		def FindDuplicatesOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		#--

		def PositionsOfDuplicatesOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def PositionsOfDuplicatesOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		#--

		def FindDuplicationsOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationsOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfItem(pItem)
		return This.FindDuplicatesOfItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindDuplicatesOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#--

		def PositionsOfDuplicatesOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def PositionsOfDuplicatesOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#--

		def FindDuplicationsOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationsOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOR DUPLICTAED  #
	#===============================================================#

	def ContainsNonDuplicatedItemsCS(pCaseSensitive)
		
		anPos = This.FindDuplicatesCSXT(pCaseSensitive)
		nLenPos = len(anPos)

		nLen = This.NumberOfItems()

		if NOT Q(anPos).IsEqualTo(1:nLen)
			return _TRUE_
		else
			return _FALSE_
		ok

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsNoDupplicationCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsNoDupplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsThatAreNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneNonDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemThatIsNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemThatIsNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneNonDuplicatedItemCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedItems()
		return This.ContainsItemsThatAreNotDuplicatedCS(_TRUE_)

		#< @FunctionAlternativeForms

		def ContainsNoDupplication()
			return This.ContainsNonDuplicatedItems()

		def ContainsNoDupplications()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsThatAreNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneNonDuplicatedItems()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemThatIsNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemThatIsNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneNonDuplicatedItem()
			return This.ContainsNonDuplicatedItems()

		#>

	  #--------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED ITEMS  #
	#--------------------------------------------#

	def NonDuplicatedItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok

		
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not only numbers and strings, but also lists,
		# and get relatively better performance on larger lists (up to 30K items)


		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next

		ok

		# Doing the job

		acSeen = []
		acResult = []
		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				acResult + acStr[i]
				anPos + i

			else
				nPos = ring_find(acResult, acStr[i])

				if nPos > 0
					ring_del(acResult, nPos)
					ring_del(anPos, nPos)
				ok

			ok

		next

		aResult = []
		nLen = len(anPos)

		for i = 1 to nLen
			aResult + aContent[anPos[i]]
		next

		return aResult


		#< @FunctionAlternativeForms

		def NonDuplicatesCS(pCaseSensitive)
			return This.NonDuplicatedItemsCS(pCaseSensitive)

		def UnduplicatedItemsCS(pCaseSensitive)
			return This.NonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedItems()
		return This.NonDuplicatedItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def NonDuplicates()
			return This.NonDuplicatedItems()

		def UnduplicatedItems()
			return This.NonDuplicatedItems()

		#>

	  #----------------------------------#
	 #  NUMBER OF NON DUPLICATED ITEMS  #
	#----------------------------------#

	def NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		nResult = len(This.NonDuplicatedItemsCS(pCaseSensitive))
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfNonDuplicatesCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def NumberOfUnduplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyNonDuplicatedItemCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyNonDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyNonDuplicatesCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyNonDuplicateCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyUnduplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyUnduplicatedItemCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedItems()
		return This.NumberOfNonDuplicatedItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def NumberOfNonDuplicates()
			return This.NumberOfNonDuplicatedItems()

		def NumberOfUnduplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyNonDuplicatedItem()
			return This.NumberOfNonDuplicatedItems()

		def HowManyNonDuplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyNonDuplicates()
			return This.NumberOfNonDuplicatedItems()

		def HowManyNonDuplicate()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyUnduplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		def HowManyUnduplicatedItem()
			return This.NumberOfNonDuplicatedItems()

		#>

	  #--------------------------------#
	 #  FINDING NON DUPLICATED ITEMS  #
	#--------------------------------#

	def FindNonDuplicatedItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_ )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return _FALSE_
		ok


		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not only numbers and strings, but also lists,
		# and get relatively better performance on larger lists (up to 30K items)


		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + ring_lower(cItem)
			next

		ok

		# Doing the job

		acSeen = []
		acResult = []
		anResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				acResult + acStr[i]
				anResult + i

			else
				nPos = ring_find(acResult, acStr[i])

				if nPos > 0
					ring_del(acResult, nPos)
					ring_del(anResult, nPos)
				ok

			ok

		next

		return anResult

		#< @FunctionAlternativeForms

		def FindUndiplicatedItemsCS(pCaseSensitive)
			return This.FindNonDuplicatedItemsCS(pCaseSensitive)

		def FindNonDuplicatesCS(pCaseSensitive)
			return This.FindNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedItems()
		return This.FindNonDuplicatedItemsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindUndiplicatedItems()
			return This.FindNonDuplicatedItems()

		def FindNonDuplicates()
			return This.FindNonDuplicatedItems()

		#>

	  #--------------------------------------------#
	 #  NON DUPLICATED ITEMS AND THEIR POSITIONS  #
	#--------------------------------------------#

	def NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		aNonDuplicated = This.NonDuplicatedItemsCS(pCaseSensitive)
		nLen = len(aNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated item appears once
			nPos = This.FindFirstCS(aNonDuplicated[i], pCaseSensitive)
			aResult + [ aNonDuplicated[i], nPos ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def UndiplicatedItemsAndTheirPositionsCS(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def UndiplicatedItemsCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def NonDuplicatesAndTheirPositionsCS(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def NonDuplicatesCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedItemsAndTheirPositions()
		return This.NonDuplicatedItemsAndTheirPositionsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		def UndiplicatedItemsAndTheirPositions()
			return This.NonDuplicatedItemsAndTheirPositions()

		def UndiplicatedItemsZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		def NonDuplicatesAndTheirPositions()
			return This.NonDuplicatedItemsAndTheirPositions()

		def NonDuplicatesZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		#>

	  #-----------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE LIST   #
	#=========================================#

	#perf #note // Acceptable performance for list of 10K items

	def RemoveDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatedItemsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicatedItemsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDuplicationsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicationsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDuplicationCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicationCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def RemoveDupplicatesCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicatesCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicatedItemsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicatedItemsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicationsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicationsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicationCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicationCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		#>

	def DuplicatesRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ToSetCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ToSetOfItemsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def UniqueItemsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ItemsCSU(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ItemsWithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicatedItemsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicationsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicationRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#--

		def WithoutDuplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms # double p instead of one p #TODO // Generalize it

		def ItemsWithoutDupplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicatedItemsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicationsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicationRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#--

		def WithoutDupplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDupplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDupplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForms

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

		def RemoveDuplicatedItems()
			This.RemoveDuplicates()

			def RemoveDuplicatedItemsQ()
				This.RemoveDuplicatedItems()
				return This

		def RemoveDuplications()
			This.RemoveDuplicates()

			def RemoveDuplicationsQ()
				This.RemoveDuplications()
				return This

		def RemoveDuplication()
			This.RemoveDuplicates()

			def RemoveDuplicationQ()
				This.RemoveDuplications()
				return This

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def RemoveDupplicates()
			This.RemoveDuplicates()

			def RemoveDupplicatesQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplicatedItems()
			This.RemoveDuplicates()

			def RemoveDupplicatedItemsQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplications()
			This.RemoveDuplicates()

			def RemoveDupplicationsQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplication()
			This.RemoveDuplicates()

			def RemoveDupplicationQ()
				return This.RemoveDuplicatesQ()

		#>

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ToSet()
			return This.DuplicatesRemoved()

			def ToSetQ()
				return new stzList(this.ToSet())

		def ToSetOfItems()
			return This.DuplicatesRemoved()

			def ToSetOfItemsQ()
				return This.ToSetQ()

		def UniqueItems()
			return This.DuplicatesRemoved()

			def UniqueItemsQ()
				return This.ToSetQ()

		def ItemsU()
			return This.DuplicatesRemoved()

			def ItemsUQ()
				return This.ToSetQ()

		def ItemsWithoutDuplication()
			return This.DuplicatesRemoved()

			def ItemsWithoutDuplicationQ()
				return This.ToSetQ()

		def DuplicatedItemsRemoved()
			return This.DuplicatesRemoved()

		def DuplicationsRemoved()
			return This.DuplicatesRemoved()

		def DuplicationRemoved()
			return This.DuplicatesRemoved()

		#--

		def WithoutDuplicates()
			return This.DuplicatesRemoved()

			def WithoutDuplicatesQ()
				return This.ToSetQ()

		def WithoutDuplication()
			return This.DuplicatesRemoved()

			def WithoutDuplicationQ()
				return This.ToSetQ()

		def WithoutDuplications()
			return This.DuplicatesRemoved()

			def WithoutDuplicationsQ()
				return This.ToSetQ()

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def ItemsWithoutDupplication()
			return This.DuplicatesRemoved()

		def DupplicatedItemsRemoved()
			return This.DuplicatesRemoved()

		def DupplicationsRemoved()
			return This.DuplicatesRemoved()

		def DupplicationRemoved()
			return This.DuplicatesRemoved()

		#--

		def WithoutDupplicates()
			return This.DuplicatesRemoved()

		def WithoutDupplication()
			return This.DuplicatesRemoved()

		def WithoutDupplications()
			return This.DuplicatesRemoved()

		#>

  	  #-----------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN ITEM   #
	#-----------------------------------------#

	def RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
		anPos = This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfItemCSQ(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicatesOfThisItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicatesOfThisItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicationsOfItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationOfItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicationOfItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicatesOfCS(pItem, pCaseSensitive)
			if isList(pItem)
				This.RemoveDuplicatesOfItemsCS(pItem, pCaseSensitive)

			else
				This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
			ok

			def RemoveDuplicatesOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationsOfCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)

			def RemoveDuplicationsOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationOfCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)

			def RemoveDuplicationOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfCS(pItem, pCaseSensitive)
				return This

		#>

	def DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfItemCSQ(pItem, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationsOfItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationsOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationOfItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		#--

		def WithoutDuplicationOfItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def WithoutDuplicationsOfItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def WithoutDuplicatingItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfItem(pItem)
		This.RemoveDuplicatesOfItemCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfItemQ(pItem)
			This.RemoveDuplicatesOfItem(pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisItem(pItem)
			This.RemoveDuplicatesOfItem(pItem)

			def RemoveDuplicatesOfThisItemQ(pItem)
				This.RemoveDuplicatesOfThisItem(pItem)
				return This

		def RemoveDuplicationsOfItem(pItem)
			This.RemoveDuplicatesOfItem(pItem)

			def RemoveDuplicationsOfItemQ(pItem)
				This.RemoveDuplicationsOfItem(pItem)
				return This

		def RemoveDuplicatesOf(pItem)
			This.RemoveDuplicatesOfCS(pItem, _TRUE_)

			def RemoveDuplicatesOfQ(pItem)
				This.RemoveDuplicatesOf(pItem)
				return This

		def RemoveDuplicationsOf(pItem)
			This.RemoveDuplicatesOf(pItem)

			def RemoveDuplicationsOfQ(pItem)
				This.RemoveDuplicationsOf(pItem)
				return This

		def RemoveDuplicationOf(pItem)
			This.RemoveDuplicatesOf(pItem)

			def RemoveDuplicationOfQ(pItem)
				This.RemoveDuplicationsOf(pItem)
				return This

		#>

	def DuplicatesOfItemRemoved(pItem)
		return This.DuplicatesOfItemRemovedCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationsOfItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationsOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationOfItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		#--

		def WithoutDuplicationOfItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def WithoutDuplicationsOfItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def WithoutDuplicatingItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		#>

	  #---------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN ITEMS   #
	#---------------------------------------------#

	def RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

		if NOT isList(paItems)
			StzRaise("Incorrect param! paItems must be a list.")
		ok

		nLen = len(paItems)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(paItems[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfItemsCSQ(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicatesOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicatesOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		#--

		def  RemoveDuplicatesOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicatesOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicatesOfManyItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
				return This


		#>
		
	def DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfItemsCSQ(paItems, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationsOfItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationsOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationOfItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		#--

		def WithoutDuplicationOfItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def WithoutDuplicationsOfItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def WithoutDuplicatingItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfItems(paItems)
		This.RemoveDuplicatesOfItemsCS(paItems, _TRUE_)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfItemsQ(paItems)
			This.RemoveDuplicatesOfItems(paItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicatesOfTheseItemsQ(paItems)
				This.RemoveDuplicatesOfTheseItems(paItems)
				return This

		def  RemoveDuplicationsOfItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfItemsQ(paItems)
				This.RemoveDuplicationsOfItems(paItems)
				return This

		def  RemoveDuplicationsOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfTheseItemsQ(paItems)
				This.RemoveDuplicationsOfTheseItems(paItems)
				return This

		def  RemoveDuplicationOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationOfTheseItemsQ(paItems)
				This.RemoveDuplicationsOfTheseItems(paItems)
				return This


		#--

		def  RemoveDuplicatesOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicatesOfManyItemsQ(paItems)
				This.RemoveDuplicatesOfManyItems(paItems)
				return This

		def  RemoveDuplicationsOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfManyItemsQ(paItems)
				This.RemoveDuplicationsOfManyItems(paItems)
				return This

		def  RemoveDuplicationOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationOfManyItemsQ(paItems)
				This.RemoveDuplicationsOfManyItems(paItems)
				return This

		#>

	def DuplicatesOfItemsRemoved(paItems)
		return This.DuplicatesOfItemsRemovedCS(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def DuplicatesOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationsOfItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationsOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationOfItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		#--

		def WithoutDuplicationOfItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def WithoutDuplicationsOfItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def WithoutDuplicatingItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		#>

	  #-----------------------------------------#
	 #   REMOVING NON DUPLICATES IN THE LIST   #
	#=========================================#

	def RemoveNonDuplicatesCS(pCaseSensitive)

		anPos = This.FindNonDuplicatesCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionAlternativeForms

		def RemoveNonDuplicatesCSQ(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)
			return This

		def RemoveNonDuplicatedItemsCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicatedItemsCSQ(pCaseSensitive)
				This.RemoveNonDuplicatedItemsCS(pCaseSensitive)
				return This

		def RemoveNonDuplicationsCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicationsCSQ(pCaseSensitive)
				This.RemoveNonDuplicationsCS(pCaseSensitive)
				return This

		def RemoveNonDuplicationCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicationCSQ(pCaseSensitive)
				This.RemoveNonDuplicationCS(pCaseSensitive)
				return This

		#>

	def NonDuplicatesRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveNonDuplicatesCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)

		def NonDuplicationsRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)

		def NonDuplicationRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNonDuplicates()
		This.RemoveNonDuplicatesCS(_TRUE_)

		#< @FunctionAlternativeForms

		def RemoveNonDuplicatesQ()
			This.RemoveNonDuplicates()
			return This

		def RemoveNonDuplicatedItems()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicatedItemsQ()
				This.RemoveNonDuplicatedItems()
				return This

		def RemoveNonDuplications()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicationsQ()
				This.RemoveNonDuplications()
				return This

		def RemoveNonDuplication()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicationQ()
				This.RemoveNonDuplications()
				return This

		#>

	def NonDuplicatesRemoved()
		aResult = This.Copy().RemoveNonDuplicatesQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsRemoved()
			return This.NonDuplicatesRemoved()

		def NonDuplicationsRemoved()
			return This.NonDuplicatesRemoved()

		def NonDuplicationRemoved()
			return This.NonDuplicatesRemoved()


		#>

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS DUPLICATED CONSECUTIVE ITEMS  #
	#==============================================================#

	def ContainsDupSecutiveItemsCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return _FALSE_
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		bResult = _FALSE_

		if bCaseSensitive = _TRUE_

			cLast = Q(aContent[1]).Stringified()
	
			for i = 2 to nLen
				cItem = Q(aContent[i]).Stringified()
				if cLast = cItem
					bResult = _TRUE_
					exit
				ok
				cLast = cItem
			next
	
			return bResult

		else // bCaseSensitive = _FALSE_

			cLast = Q(aContent[1]).StringifyQ().Lowercased()

			for i = 2 to nLen
				cItem = Q(aContent[i]).StringifyQ().Lowercased()
				if cLast = cItem
					bResult = _TRUE_
					exit
				ok
				cLast = cItem
			next

			return bResult
		ok

		def ContainsDuplicatedConSecutiveItemsCS(pCaseSensitive)
			return This.ContainsDupSecutiveItemsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDupSecutiveItems()
		return This.ContainsDupSecutiveItemsCS(_TRUE_)

		def ContainsDuplicatedConSecutiveItems()
			return This.ContainsDupSecutiveItems()

	  #---------------------------------------------------------------------#
	 #  FINDING THE POSITIONS OF DUPLICATED CONSECUTIVE ITEMS IN THE LIST  #
	#---------------------------------------------------------------------#

	def FindDupSecutiveItemsCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return []
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		acItems = []

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acItems + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acItems + ring_lower(cItem)
			next

		ok

		# Doing the job

		anResult = []

		for i = 2 to nLen

			if acItems[i-1] = acItems[i]
				anResult + i
			ok

		next

		return anResult

		def FindDuplicatedConsecutiveItemsCS(pCaseSensitive)
			return This.FindDupSecutiveItemsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDupSecutiveItems()
		return This.FindDupSecutiveItemsCS(_TRUE_)

		def FindDuplicatedConsecutiveItems()
			return This.FindDupSecutiveItems()

	  #----------------------------------------------------#
	 #  GETTING DUPLICATED CONSECUTIVE ITEMS IN THE LIST  #
	#----------------------------------------------------#

	def DupSecutiveItemsCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return []
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		acItems = []

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acItems + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acItems + ring_lower(cItem)
			next

		ok

		# Doing the job

		aResult = []
		acSeen = []

		for i = 2 to nLen

			if acItems[i-1] = acItems[i]
				if ring_find(acSeen, acItems[i-1]) = 0
					aResult + aContent[i-1]
					acSeen + acItems[i-1]
				ok
			ok

		next

		return aResult


		def DuplicatedConsecutiveItemsCS(pCaseSensitive)
			return This.DupSecutiveItemsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveItems()
		return This.DupSecutiveItemsCS(_TRUE_)

		def DuplicatedConsecutiveItems()
			return This.DupSecutiveItems()

	  #----------------------------------------------------------------------#
	 #  GETTING THE DUPLICATED CONSECUTIVE ITEMS ALONG WITH THEIR POSIIONS  #
	#----------------------------------------------------------------------#

	def DupSecutiveItemsCSZ(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return []
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		acItems = []

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acItems + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acItems + ring_lower(cItem)
			next

		ok

		# Doing the job

		aResult = []
		acSeen = []

		for i = 2 to nLen

			if acItems[i-1] = acItems[i]
				n = ring_find(acSeen, acItems[i-1])
				if n = 0
					aResult + [ aContent[i-1], [i] ]
					acSeen + acItems[i-1]
				else
					aResult[n][2] + i
				ok
			ok

		next

		return aResult

		def DuplicatedConsecutiveItemsCSZ(pCaseSensitive)
			return This.DupSecutiveItemsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveItemsZ()
		return This.DupSecutiveItemsCSZ(_TRUE_)

		def DuplicatedConsecutiveItemsZ()
			return This.DupSecutiveItemsZ()

	  #-----------------------------------------------------------#
	 #  REMOVING THE DUPLICATED CONSECUTIVE ITEMS FROM THE LIST  #
	#-----------------------------------------------------------#

	def RemoveDupSecutiveItemsCS(pCaseSensitive)
		anPos = This.FindDupSecutiveItemsCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		def RemoveDupSecutiveItemsCSQ(pCaseSensitive)
			This.RemoveDupSecutiveItemsCS(pCaseSensitive)
			return This

		def RemoveDuplicatedConsecutiveItemsCS(pCaseSensitive)
			This.RemoveDupSecutiveItemsCS(pCaseSensitive)

			def RemoveDuplicatedConsecutiveItemsCSQ(pCaseSensitive)
				return This.RemoveDupSecutiveItemsCSQ(pCaseSensitive)

	def DupSecutiveItemsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDupSecutiveItemsCSQ(pCaseSensitive).Content()
		return cResult

		def DuplicatedConsecutiveItemsRemovedCS(pCaseSensitive)
			return This.DupSecutiveItemsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveDupSecutiveItems()
		This.RemoveDupSecutiveItemsCS(_TRUE_)

		def RemoveDupSecutiveItemsQ()
			This.RemoveDupSecutiveItems()
			return This

		def RemoveDuplicatedConsecutiveItems()
			This.RemoveDupSecutiveItems()

			def RemoveDuplicatedConsecutiveItemsQ()
				return This.RemoveDupSecutiveItemsQ(pCaseSensitive)

	def DupSecutiveItemsRemoved()
		cResult = This.Copy().RemoveDupSecutiveItemsQ().Content()
		return cResult

		def DuplicatedConsecutiveItemsRemoved()
			return This.DupSecutiveItemsRemoved()

	  #------------------------------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE ORIGINS OF DUPLICATED CONSECUTIVE ITEMS  #
	#------------------------------------------------------------------------#

	def FindDupSecutiveOriginsCS(pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return _FALSE_
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		bResult = _FALSE_

		if bCaseSensitive = _TRUE_

			cLast = Q(aContent[1]).Stringified()
	
			for i = 2 to nLen
				cItem = Q(aContent[i]).Stringified()
				if cLast = cItem
					bResult = _TRUE_
					exit
				ok
				cLast = cItem
			next
	
			return bResult

		else // bCaseSensitive = _FALSE_

			cLast = Q(aContent[1]).StringifyQ().Lowercased()

			for i = 2 to nLen
				cItem = Q(aContent[i]).StringifyQ().Lowercased()
				if cLast = cItem
					bResult = _TRUE_
					exit
				ok
				cLast = cItem
			next

			return bResult
		ok

		#< @FunctionAlternativeForms

		def FindDuplicatesSecutiveOriginsCS(pCaseSensitive)
			return This.FindDupSecutiveOriginsCS(pCaseSensitive)

		def FindDuplicationsSecutiveOriginsCS(pCaseSensitive)
			return This.FindDupSecutiveOriginsCS(pCaseSensitive)

		def FindDuplicationSecutiveOriginsCS(pCaseSensitive)
			return This.FindDupSecutiveOriginsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDupSecutiveOrigins()
		return This.FindDupSecutiveOriginsCS(_TRUE_)

		#< @FunctionAlternativeForms

		def FindDuplicatesSecutiveOrigins()
			return This.FindDupSecutiveOrigins()

		def FindDuplicationsSecutiveOrigins()
			return This.FindDupSecutiveOrigins()

		def FindDuplicationSecutiveOrigins()
			return This.FindDupSecutiveOrigins()

		#>

	  #----------------------------------------------------------------#
	 #  FINDING THE POSITIONS OF A GIVEN DUPLICATED CONSECUTIVE ITEM  #
	#----------------------------------------------------------------#

	def FindDupSecutiveItemCS(pItem, pCaseSensitive)

		aContent = This.Content()
		nLen = len(aContent)

		if nLen <= 1
			return []
		ok

		bCaseSensitive = @CaseSensitive(pCaseSensitive)
		acItems = []

		if pCaseSensitive = _TRUE_

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acItems + cItem
			next

		else // pCaseSensitive = _FALSE_

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acItems + ring_lower(cItem)
			next

		ok

		# Doing the job

		cItem = @@(pItem)
		if bCaseSensitive = _FALSE_
			cItem = ring_lower(cItem)
		ok

		anResult = []

		for i = 2 to nLen
			if acItems[i] != cItem
				loop
			ok

			if acItems[i-1] = acItems[i]
				anResult + i
			ok

		next

		return anResult

		#< @FunctionAlternativeForms

		def FindDuplicatedConsecutiveItemCS(pItem, pCaseSensitive)
			return This.FindDupSecutiveItemCS(pItem, pCaseSensitive)

		def FindThisDupSecutiveItemCS(pItem, pCaseSensitive)
			return This.FindDupSecutiveItemCS(pItem, pCaseSensitive)

		def FindThisDuplicatedConsecutiveItemCS(pItem, pCaseSensitive)
			return This.FindDupSecutiveItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDupSecutiveItem(pItem)
		return This.FindDupSecutiveItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindDuplicatedConsecutiveItem(pItem)
			return This.FindDupSecutiveItem(pItem)

		def FindThisDupSecutiveItem(pItem)
			return This.FindDupSecutiveItem(pItem)

		def FindThisDuplicatedConsecutiveItem(pItem)
			return This.FindDupSecutiveItem(pItem)

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING A GIVEN DUPLICATED CONSECUTIVE ITEM ALONG WITH ITS OCCURRENCES  #
	#--------------------------------------------------------------------------#

	def DupSecutiveItemCSZ(pItem, pCaseSensitive)
		anPos = This.FindDupSecutiveItemCS(pItem, pCaseSensitive)
		aResult = [ pItem, anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def DuplicatedConsecutiveItemCSZ(pItem, pCaseSensitive)
			return This.DupSecutiveItemCSZ(pItem, pCaseSensitive)

		def DupSecutiveItemAndItsPositionsCS(pItem, pCaseSensitive)
			return This.DupSecutiveItemCSZ(pItem, pCaseSensitive)

		def DuplicatedConsecutiveItemAndItsPositionsCS(pItem, pCaseSensitive)
			return This.DupSecutiveItemCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DupSecutiveItemZ(pItem)
		return This.DupSecutiveItemCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def DuplicatedConsecutiveItemZ(pItem)
			return This.DupSecutiveItemZ(pItem)

		def DupSecutiveItemAndItsPositions(pItem)
			return This.DupSecutiveItemZ(pItem)

		def DuplicatedConsecutiveItemAndItsPositions(pItem)
			return This.DupSecutiveItemZ(pItem)

		#>

	  #------------------------------------------------#
	 #  REMOVING A GIVEN DUPLICATED CONSECUTIVE ITEM  #
	#------------------------------------------------#

	def RemoveDupSecutiveItemCS(pItem, pCaseSensitive)

		anPos = This.FindDupSecutiveItemCS(pItem, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFlunetForm

		def RemoveDupSecutiveItemCSQ(pItem, pCaseSensitive)
			This.RemoveDupSecutiveItemCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatedConsecutiveItemCS(pItem, pCaseSensitive)
			This.RemoveDupSecutiveItemCS(pItem, pCaseSensitive)

			def RemoveDuplicatedConsecutiveItemCSQ(pItem, pCaseSensitive)
				return This.RemoveDupSecutiveItemCSQ(pItem, pCaseSensitive)

		#--

		def RemoveThisDupSecutiveItemCS(pItem, pCaseSensitive)
			This.RemoveDupSecutiveItemCS(pItem, pCaseSensitive)

			def RemoveThisDupSecutiveItemCSQ(pItem, pCaseSensitive)
				return This.RemoveThisDupSecutiveItemCSQ(pItem, pCaseSensitive)

		def RemoveThisDuplicatedConsecutiveItemCS(pItem, pCaseSensitive)
			This.RemoveDupSecutiveItemCS(pItem, pCaseSensitive)

			def RemoveThisDuplicatedConsecutiveItemCSQ(pItem, pCaseSensitive)
				return This.RemoveDupSecutiveItemCSQ(pItem, pCaseSensitive)

		#>

	def DupSecutiveItemRemovedCS(pItem, pCaseSensitive)
		cResult = This.Copy().RemoveDupSecutiveItemCSQ(pItem, pCaseSensitive).Content()
		return cResult

		def DuplicatedConsecutiveItemRemovedCS(pItem, pCaseSenssitive)
			return This.DupSecutiveItemRemovedCS(pItem, pCaseSensitive)

		def ThisDupSecutiveItemRemovedCS(pItem, pCaseSensitive)
			return This.DupSecutiveItemRemovedCS(pItem, pCaseSensitive)

		def ThisDuplicatedConsecutiveItemRemovedCS(pItem, pCaseSenssitive)
			return This.DupSecutiveItemRemovedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveDupSecutiveItem(pItem)
		This.RemoveDupSecutiveItemCS(pItem, _TRUE_)

		#< @FunctionFlunetForm

		def RemoveDupSecutiveItemQ(pItem)
			This.RemoveDupSecutiveItem(pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatedConsecutiveItem(pItem)
			This.RemoveDupSecutiveItem(pItem)

			def RemoveDuplicatedConsecutiveItemQ(pItem)
				return This.RemoveDupSecutiveItemQ(pItem)

		#--

		def RemoveThisDupSecutiveItem(pItem)
			This.RemoveDupSecutiveItem(pItem)

			def RemoveThisDupSecutiveItemQ(pItem)
				return This.RemoveThisDupSecutiveItemQ(pItem)

		def RemoveThisDuplicatedConsecutiveItem(pItem)
			This.RemoveDupSecutiveItem(pItem)

			def RemoveThisDuplicatedConsecutiveItemQ(pItem)
				return This.RemoveDupSecutiveItemQ(pItem)

		#>

	def DupSecutiveItemRemoved(pItem)
		cResult = This.Copy().RemoveDupSecutiveItemQ(pItem).Content()
		return cResult

		def DuplicatedConsecutiveItemRemoved(pItem)
			return This.DupSecutiveItemRemoved(pItem)

		def ThisDupSecutiveItemRemoved(pItem)
			return This.DupSecutiveItemRemoved(pItem)

		def ThisDuplicatedConsecutiveItemRemoved(pItem)
			return This.DupSecutiveItemRemoved(pItem)

	  #==============================================#
	 #  CHECKING IF THE LIST CONTAINS A GIVEN ITEM  #
	#==============================================#

	def ContainsCS(pItem, pCaseSensitive)

		if This.FindFirstCS(pItem, pCaseSensitive) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForm

		def ContainsItemCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

			def ContainsNoItemCS(pItem, pCaseSensitive)
				return NOT This.ContainsItemCS(pItem, pCaseSensitive)
	
		#>

		#< @FunctionNegativeForm
	
		def ContainsNoCS(pItem, pCaseSensitive)
			return NOT This.ContainsCS(pItem, pCaseSensitive)

		def DoesNotContainCS(pItem, pCaseSensitive)
			return NOT This.ContainsCS(pItem, pCaseSensitive)

		def ContainsNeitherCS(pItem1, pItem2, pCaseSensitive)
			if isList(pItem2) and Q(pItem2).IsNorNamedParam()
				pItem2 = pItem2[2]
			ok

			return This.ContainsNoneOfTheseCS([pItem1, pItem2], pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

		def ConttainsCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def Contains(pItem)
		return This.ContainsCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def ContainsItem(pItem)
			return This.Contains(pItem)

			def ContainsNoItem(pItem)
				return NOT This.ContainsItem(pItem)
	
		#>

		#< @FunctionNegativeForm
	
		def ContainsNo(pItem)
			return NOT This.Contains(pItem)

		def DoesNotContain(pItem)
			return NOT This.Contains(pItem)

		def ContainsNeither(pItem1, pItem2)
			if isList(pItem2) and Q(pItem2).IsNorNamedParam()
				pItem2 = pItem2[2]
			ok

			return This.ContainsNoneOfThese([pItem1, pItem2])

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pItem)
			return This.Contains(pItem)

		def Conttains(pItem)
			return This.ContainsCS(pItem)

		#>

	  #---------------------------#
	 #  CONDITIONAL CONTAINMENT  #
	#===========================#

	def ContainsW(pcCondition)

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		nLen = len(@aContent)

		# Getting the executable section

		_oCode_ = new stzCCode(pcCondition)
		anSection = _oCode_.ExecutableSection()

		n1 = anSection[1]
		n2 = anSection[2]
		if n2 = :Last
			n2 = nLen
		ok

		# Composing the conditional code

		cCode = 'bOk = (' + oCode.Content() + ')'
		
		# Evaluating the code against the items

		bResult = _FALSE_

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				bResult = _TRUE_
				exit
			ok
		next

		# Returning the result

		return bResult

	  #--------------------------------------#
	 #  CONDITIONAL CONTAINMENT -- XTended  #
	#--------------------------------------#

	def ContainsWXT(pcCondition)

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		nLen = len(@aContent)

		# Transpiling the conditional code

		_oCode_ = new stzCCode(pcCondition)
		_oCode_.Transpile()

		# Getting the executable section

		anSection = _oCode_.ExecutableSection()
		n1 = anSection[1]
		n2 = anSection[2]
		if n2 = :Last
			n2 = nLen
		ok

		# Composing the conditional code

		cCode = 'bOk = ( ' + _oCode_.Content() + ' )'

		# Evaluating the code against the list items

		bResult = _FALSE_

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				bResult = _TRUE_
				exit
			ok
		next

		# Getting the result

		return bResult

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS CONTAINED IN A GIVEN LIST OR ITEM  #
	#-------------------------------------------------------------#

	def IsContainedInCS(p, pCaseSensitive)

		if NOT ( isString(p) or isList(p) )
			return _FALSE_
		ok

		anPos = Q(p).FindAllCS(This.Content(), pCaseSensitive)
		nLen = len(anPos)

		if nLen > 0
			return _TRUE_
		else
			return _FALSE_
		ok


		#< @FunctionAlternativeForm

		def ExistsInCS(p, pCaseSensitive)
		
			return This.IsContainedInCS(p, pCaseSensitive)

		def IsIncludedInCS(p, pCaseSensitive)
			return This.IsContainedInCS(p, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(p)
		return This.IsContainedInCS(p, _TRUE_)

		#< @FunctionAlternativeForms

		def ExistsIn(p)
			return This.IsContainedIn(p)

		def IsIncludedIn(p)
			return This.IsContainedIn(p)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING EXISTS AT THE GIVEN POSITIONS  #
	#-----------------------------------------------------------#

	def ExistsAtCS(pcSubStr, panPos, pCaseSensitive)

		# Earlu checkbox()

		if isNumber(panPos)
			return This.ExistsAtPositionCS(pcsubStr, panPos, pCaseSensitive)
		ok

		# Checki,g params

		if CheckParams()
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
		ok

		# Doing the job

		_anPos_ = This.FindAllCS(pcSubStr, pCaseSensitive)
		_nLen_ = len(_anPos_)

		_bResult_ = _TRUE_

		for @i = 1 to _nLen_
			if NOT ring_find(panPos, _anPos_[@i])
				_bResult_ = _FALSE_
				exit
			ok
		next

		return _bResult_

		#< @FunctionAlternativeForms

		def ExistsAtPositionsCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)

		def SubStringExistsAtCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)

		def SubStringExistsAtPositionsCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)
 
		#--

		def ExistsInPositionsCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)

		def SubStringExistsInCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)

		def SubStringExistsInPositionsCS(pcSubStr, panPos, pCaseSensitive)
			return This.ExistsAtCS(pcSubStr, panPos, pCaseSensitive)
 
		#>

	#-- WIHTOUT CASESENSITIVITY

	def ExistsAt(pcSubStr, panPos)
		return This.ExistsAtCS(pcSubStr, panPos, _TRUE_)

		#< @FunctionAlternativeForms

		def ExistsAtPositions(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)

		def SubStringExistsAt(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)

		def SubStringExistsAtPositions(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)
 
		#--

		def ExistsInPositions(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)

		def SubStringExistsIn(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)

		def SubStringExistsInPositions(pcSubStr, panPos)
			return This.ExistsAt(pcSubStr, panPos)

		#>

	  #--------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING EXISTS AT A GIVEN POSITION  #
	#--------------------------------------------------------#

	def ExistsAtPositionCS(pcSubStr, n, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		_anPos_ = This.FindAllCS(pcSubStr, pCaseSensitive)
		
		if ring_find(_anPos_, n) > 0
			return _TRUE_

		else
			return _FALSE_
		ok


		def ExistsInPositionCS(pcSubStr, n, pCaseSensitive)
			return This.ExistsAtPositionCS(pcSubStr, n, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def ExistsAtPosition(pcSubStr, n)
		return This.ExistsAtCS(pcSubStr, n, _TRUE_)

		def ExistsInPosition(pcSubStr, n)
			return This.ExistsAtPosition(pcSubStr, n)

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS BOTH OF THE PROVIDED ITEM  #
	#-----------------------------------------------------------#

	def ContainsBothCS(pItem1, pItem2, pCaseSensitive)
		if CheckingParams()
			if isList(pItem2) and Q(pItem2).IsAndNamedParam()
				pItem2 = pItem[2]
			ok
		ok

		return This.ContainsManyCS([ pItem1, pItem2 ], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pItem1, pItem2)
		return This.ContainsBothCS(pItem1, pItem2, _TRUE_)

	  #-----------------------------------------------------------#
	 #    CONTAINING ONE GIVEN ITEM OR AN OTHER (BUT NOT BOTH)   #
	#-----------------------------------------------------------#

	def ContainsEitherCS(pItem1, pItem2, pCaseSensitive)
		if isList(pItem2) and Q(pItem2).IsOrNamedParam()
			pItem2 = pItem2[2]
		ok

		#NOTE
		# We can solve it quickly like this:
		# return This.ContainsOnlyOneOfTheseCS([ pItem1, pItem2 ], pCaseSensitive)

		b1 = This.ContainsCS(pItem1, pCaseSensitive)
		b2 = This.ContainsCS(pItem2, pCaseSensitive)

		if (b1 = 1 and b2 = 0) or (b1 = 0 and b2 = 1)
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsEither(pItem1, pItem2)
		return This.ContainsEitherCS(pItem1, pItem2, _TRUE_)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF EACH ONE OF THE GIVEN ITEMS EXISTS IN THE GIVEN LIST  #
	#--------------------------------------------------------------------#
	
	def EachItemExistsInCS(paOtherList, pCaseSensitive)

		bResult = StzListQ(paOtherList).ContainsEachCS(This.List(), pCaseSensitive)

		return bResult

		#< @FunctionAlternativeForms

		def ItemsExistInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		def AllItemsExistInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsIn(paOtherList, pCaseSensitive)

		def EachExistsInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		def ExistInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		def AreIncludedInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVI

	def EachItemExistsIn(paOtherList)
		return This.EachItemExistsInCS(paOtherList, _TRUE_)

		#< @FunctionAlternativeForms

		def ItemsExistIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def AllItemsExistIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def EachExistsIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def ExistIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def AreContainedIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def AreIncludedIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS ONE OF THE ITEMS OF A GIVEN LIST  #
	#------------------------------------------------------------#

	def IsOneOfTheseCS(paOtherList, pCaseSensitive)
		bResult = StzListQ(paOtherList).ContainsCS( This.List(), pCaseSensitive )
		return bResult

		def IsNotOneOfTheseCS(paOtherList, pCaseSensitive)
			return NOT This.IsOneOfTheseCS(paOtherList, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def IsOneOfThese(paOtherList)
		return This.IsOneOfTheseCS(paOtherList, _TRUE_)

		def IsNotOneOfThese(paOtherList)
			return NOT This.IsOneOfThese(paOtherList)

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS EACH OF THE PROVIDED ITEMS  #
	#------------------------------------------------------------#

	def ContainsManyCS(paItems, pCaseSensitive)
		
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		paItems = U(paItems)
		aContent = paItems

		bResult = _TRUE_

		nLen = len(aContent)

		for i = 1 to nLen

			if NOT This.ContainsCS(aContent[i], pCaseSensitive)
				bResult = _FALSE_
				exit
			ok
		end

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def IsMadeOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def ContainsTheseCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def ContainsEachCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def ContainsEachOneOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def ContainsAllCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)

		def ContainsAllTheseCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paItems, pCaseSensitive)


		#>

		#< @FunctionNagationForm

		def ContainsNoOneCS(paItems, pCaseSensitive)
			return NOT This.ContainsEachCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsMany(paItems)
		return This.ContainsManyCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def IsMadeOf(paItems)
			return This.ContainsMany(paItems)

		def IsMadeOfThese(paItems)
			return This.ContainsMany(paItems)

		def ContainsThese(paItems)
			return This.ContainsMany(paItems)

		def ContainsEach(paItems)
			return This.ContainsMany(paItems)

		def ContainsEachOneOfThese(paItems)
			return This.ContainsMany(paItems)

		def ContainsAll(paItems)
			return This.ContainsMany(paItems)

		def ContainsAllThese(paItems)
			return This.ContainsMany(paItems)

		#>

		#< @FunctionNagationForm

		def ContainsNoOne(paItems)
			return NOT This.ContainsEach(paItems)

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS SOME OF THE PROVIDED ITEMS  #
	#------------------------------------------------------------#

	def ContainsSomeCS(paItems, pCaseSensitive)
		paItems = U(paItems)
		bResult = _FALSE_

		for item in paItems
			if This.ContainsCS(item, pCaseSensitive)
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfSomeCS(paItems, pCaseSensitive)
			return This.ContainsSomeCS(paItems, pCaseSensitive)

		def IsMadeOfSomeOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsSomeCS(paItems, pCaseSensitive)

		def IsMadeOfOneOrMoreOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsSomeCS(paItems, pCaseSensitive)

		def IsMadeOfOneOrMoreOfCS(paItems, pCaseSensitive)
			return This.ContainsSomeCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSome(paItems)
		return This.ContainsSomeCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def IsMadeOfSome(paItems)
			return This.ContainsSome(paItems)

		def IsMadeOfSomeOfThese(paItems)
			return This.ContainsSome(paItems)

		def IsMadeOfOneOrMoreOfThese(paItems)
			return This.ContainsSome(paItems)

		def IsMadeOfOneOrMoreOf(paItems)
			return This.ContainsSome(paItems)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONE OF THE PROVIDED ITEMS  #
	#-----------------------------------------------------------#
	
	def ContainsOneOfTheseCS(paItems, pCaseSensitive)
		
		aItems = Q(paItems).WithoutDupplication()
		nLen = len(paItems)

		bResult = _FALSE_

		for i = 1 to nLen
			if This.ContainsCS( paItems[i],  pCaseSensitive)
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def ContainsAnyOneOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def ContainsAnyOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def IsMadeOfOneOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def IsMadeOfAnyOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def ContainsOneCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		def ContainsOneOfTheCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsAnyOfTheCS(paItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		#>

		#< @FunctionNegativeForm

		def ContainsNoOneOfTheseCS(paItems, pCaseSensitive)
			return NOT This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

			def ContainsNoneOfTheseCS(paItems, pCaseSensitive)
				return NOT This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

			def ContainsNoItemOfTheseCS(paItems, pCaseSensitive)
				return NOT This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

			def ContainsNoneOfTheseItemsCS(paItems, pCaseSensitive)
				return NOT This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

			def ContainsNoOneOfTheseItemsCS(paItems, pCaseSensitive)
				return NOT This.ContainsOneOfTheseCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(paItems)
		return This.ContainsOneOfTheseCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def ContainsAny(paItems)
			return This.ContainsOneOfThese(paItems)

		def ContainsAnyOneOfThese(paItems)
			return This.ContainsOneOfThese(paItems)

		def ContainsAnyOfThese(paItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def IsMadeOfOneOfThese(paItems)
			return This.ContainsOneOfThese(paItems)

		def IsMadeOfAnyOfThese(paItems)
			return This.ContainsOneOfThese(paItems)

		def ContainsOne(paItems)
			return This.ContainsOneOfThese(paItems)

		def ContainsOneOfThe(paItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsAnyOfThe(paItems)
			return This.ContainsOneOfThese(paItems)

		#>

		#< @FunctionNegativeForm

		def ContainsNoOneOfThese(paItems)
			return NOT This.ContainsOneOfThese(paItems)

			def ContainsNoneOfThese(paItems)
				return NOT This.ContainsOneOfThese(paItems)

			def ContainsNoItemOfThese(paItems)
				return NOT This.ContainsOneOfThese(paItems)

			def ContainsNoneOfTheseItems(paItems)
				return NOT This.ContainsOneOfThese(paItems)

			def ContainsNoOneOfTheseItems(paItems)
				return NOT This.ContainsOneOfThese(paItems)

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ONE OF THE PROVIDED ITEMS  #
	#----------------------------------------------------------------#

	def ContainsOnlyOneOfTheseCS(paItems, pCaseSensitive)
		if CheckingParam()
			if NOT (isList(paItems) and @IsListOfStrings(paItems))
				StzRaise("Incorrect param type! paItems must be a list of strings.")
			ok
		ok

		if EarlyCheck()
			if len(paItems) = 0
				return _FALSE_
			ok
		ok

		aItems = @WithoutDuplication(paItems)
		nLen = len(aItems)

		anOccurr = []
		
		for i = 1 to nLen
			anOccurr + This.ContainsCS(aItems[i], pCaseSensitive)
		next
		
		nOnes  = Q(anOccurr).HowMany(1)
		nZeros = Q(anOccurr).HowMany(0)

		if nOnes = 1 and nZeros = nLen - 1
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WTIHOUT CASESENSITIVITY

	def ContainsOnlyOneOfThese(paItems)
		return This.ContainsOnlyOneOfTheseCS(paItems, _TRUE_)

	  #---------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS N OF THE PROVIDED ITEMS  #
	#---------------------------------------------------------#

	def ContainsNCS(n, paItems, pCaseSensitive)
		paItems = U(paItems)
		bResult = _FALSE_
		m = 0
		for pItem in paItems
			if This.ContainsCS(pItem, pCaseSensitive)
				m++
				if n = m
					bResult = _TRUE_
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrencesOfCS(n, paItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsNOccurrencesCS(n, paItems, pCaseSensitive)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNCS(n, pItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNOccurrencesOfCS(n, paItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNOccurrencesCS(n, paItems, pCaseSensitive)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsN(n, paItems)
		return This.ContainsNCS(n, paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def ContainsNOccurrencesOf(n, paItems)
			return This.ContainsN(n, paItems)

		def ContainsNOccurrences(n, paItems)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsN(n, paItems)

		def ContainsExactlyN(n, pItems)
			return This.ContainsN(n, paItems)

		def ContainsExactlyNOccurrencesOf(n, paItems)
			return This.ContainsN(n, paItems)

		def ContainsExactlyNOccurrences(n, paItems)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsN(n, paItems)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS MORE THEN N OCCURRENCES OF A GIVEN ITEM  #
	#-------------------------------------------------------------------------#

	def ContainsMoreThenCS(n, pItem, pCaseSensitive)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.NumberOfOccurrenceCS(pItem, pCaseSensitive) > n
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WITHOUT CASESENSITIVTY

	def ContainsMoreThen(n, pItem)
		return This.ContainsMoreThen(n, pItem)

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS LESS THEN N OCCURRENCES OF A GIVEN ITEM  #
	#-------------------------------------------------------------------------#

	def ContainsLessThenCS(n, pItem, pCaseSensitive)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.NumberOfOccurrenceCS(pItem, pCaseSensitive) < n
			return _TRUE_
		else
			return _FALSE_
		ok

	#-- WITHOUT CASESENSITIVTY

	def ContainsLessThen(n, pItem)
		return This.ContainsLessThen(n, pItem)

	  #--------------------------------------------------#
	 #  CHECKING IF EACH ITEM CONTAINS THE GIVEN VALUE  #
	#--------------------------------------------------#

	def EachContainsCS(pItem, pCaseSensitive)

		/* EXAMPLES

		EXAMPLE 1

		o1 = new stzList([ "eeee", "bbbb", "ccc", "" ])
		? o1.EachContains("")
		#--> _TRUE_
		
		EXAMPLE 2

		o1 = new stzList([ ["ee","","ee"], ["", "bb"], "ccc", "" ])
		? o1.EachContains("")
		#--> _TRUE_
		
		EXAMPLE 3

		o1 = new stzList([ "aa" ])
		? o1.EachContains("")
		#--> _TRUE_
		
		EXAMPLE 4

		o1 = new stzList([ 0, "aa" ])
		? o1.EachContains("")
		#--> _FALSE_

		*/


		bResult = _TRUE_

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) or isString(aContent[i]) )
				bResult = _FALSE_
				exit

			else
				bResult = Q(aContent[i]).ContainsCS(pItem, pCaseSensitive)
				if bResult = _FALSE_
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForm

		def EachItemContainsCS(pItem, pCaseSensitive)
			return This.EachContainsCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def EachContains(pItem)
		return This.EachContainsCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def EachItemContains(pItem)
			return This.EachContains(pItem)

		#>

	  #---------------------------------------------------#
	 #  CHECKING IF EACH ITEM CONTAINS THE GIVEN STRING  #
	#---------------------------------------------------#

	def EachContainsTheseCS(paItems, pCaseSensitive)

		bResult = _TRUE_

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) or isString(aContent[i]) )
				bResult = _FALSE_
				exit

			else

				bResult = Q(aContent[i]).ContainsTheseCS(paItems, pCaseSensitive)
				if bResult = _FALSE_
					exit
				ok
			ok

		next

		return bResult

		#< @FunctionAlternativeForm

		def EachItemContainsTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachItemContainsAllTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachItemContainsAllOfTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachContainsManyCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def EachContainsThese(paItems)
		return This.EachContainsTheseCS(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def EachItemContainsThese(paItems)
			return This.EachContainsThese(paItems)

		def EachItemContainsAllThese(paItems)
			return This.EachContainsThese(paItems)

		def EachItemContainsAllOfThese(paItems)
			return This.EachContainsThese(paItems)

		def EachContainsMany(paItems)
			return This.EachContainsThese(paItems)

		#>

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS NUMBERS  #
	#=========================================#

	def ContainsNumbers()
		bResult = _FALSE_

		for item in This.List()
			if isNumber(item)
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		def ContainsNoNumbers()
			return NOT This.ContainsNumbers()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS STRINGS  #
	#-----------------------------------------#

	def ContainsStrings()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_bResult_ = _TRUE_

		for @i = 1 to _nLen_

			if NOT isString(_aContent_[@i])
				_bResult_ = _FALSE_
				exit
			ok

		next

		return _bResult_

		def ContainsNoStrings()
			return NOT This.ContainsStrings()

	#--

	def FindEmptyStrings()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_anResult_ = []

		for @i = 1 to _nLen_
			if isString( _aContent_[@i] ) and _aContent_[@i] = ""
				_anResult_ + @i
			ok
		next

		return _anResult_

	def NumberOfEmptyStrings()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_nResult_ = 0

		for @i = 1 to _nLen_

			if isString(_aContent_[@i]) and _aContent_[@i] = ""
				_nResult_++
			ok

		next

		return _nResult_

		def CountEmptyStrings()
			return This.NumberOfEmptyStrings()

		def HowManyEmptyStrings()
			return This.NumberOfEmptyStrings()

	def ContainsEmptyStrings()

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_bResult_ = _FALSE_

		for @i = 1 to _nLen_

			if isString(_aContent_[@i]) and _aContent_[@i] = ""
				_bResult_ = _TRUE_
				exit
			ok

		next

		return _bResult_

	#--

	def RemoveEmptyStrings()
		_anPos_ = This.FindEmptyStrings()
? _anPos_
fdef
		_cResult_ = This.ItemsAtPositionsRemoved(_anPos_)
		This.UpdateWith(_cResult_)

		def RemoveEmptyStringsQ()
			This.RemoveEmptyStrings()
			return This

	def EmptyStringsRemoved()
		_aResult_ = This.Copy().RempveEmptyStringsQ().Content()
		return _aResult_

	#--

	def ReplaceEmptyStrings(pItem)
		_anPos_ = This.FindEmptyStrings()
		This.ReplaceItemsAtPositions(_anPos_, pItem)

		def ReplaceEmptyStringsQ(pItem)
			This.ReplaceEmptyStrings(pItem)
			return This

	def EmptyStringsReplaced(pItem)
		_aResult_ = This.ReplaceEmptyStringsQ(pItem).Content()
		return _aResult_

	  #---------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS LISTS  #
	#---------------------------------------#

	def ContainsLists()
		bResult = _FALSE_

		for item in This.List()
			if isList(item)
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		def ContainsNoLists()
			return NOT This.ContainsLists()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS OBJECTS  #
	#-----------------------------------------#

	def ContainsObjects()
		for item in This.List()
			if isObject(item)
				return _TRUE_
			ok
		next

	def ContainsNoObjects()
		return NOT This.ContainsObjects()

	def ContainsObjectsAtSomeLevel() // TODO: Review this risky implementation!
		/*
		This solution is build upon the observation that
		list2code() Ring functions generates empty string
		for objects.

		Hence, list2Code([ 1, 2, "C"]) generates '[1,2,"C"]'
		but:
			o1 = new stzString("C")
			? list2code([ 1, 2, o1, "C"]) generates:

			'[1,2,,"C"]'

		As you can see, we can know that an object exists by
		analyzing list2code() for any generated empty string!

		WARNING: if Ring enhances this function to generate the
		name of the object, for example, then the logic used
		here must change accordingly...
		*/

		_oCode_ = StzStringQ( list2code( This.List() ) )

		if _oCode_[4] = "," or
		   _oCode_[ _oCode_.NumberOfChars()-3 ] = "," or
		   _oCode_.Contains(",,") or
		   _oCode_.Contains("[,") or
		   _oCode_.Contains(",]")

			return _TRUE_
		else
			return _FALSE_
		ok
	
	def ContainsNoObjectsAtAnyLevel()
		return NOT This.ContainsObjectsAtSomeLevel()

	def ContainsAtAnyLevel(pItem) #TODO
		// TODO

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT STRINGS  #
	#============================================================#

	def ContainsItemsOtherThanStrings()
		if This.ContainsNumbers() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		def ContainsItemsWhichAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		#--

		def IsMadeOfItemsOtherThanStrings()
			return This.ContainsItemsOtherThanStrings()

		def IsMadeOfItemsThatAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		def IsMadeOfItemsWhichAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT NUMBERS  #
	#------------------------------------------------------------#

	def ContainsItemsOtherThanNumbers()
		if This.ContainsStrings() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def ContainsItemsWhichAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		#--

		def IsMadeOfItemsOtherThanNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def IsMadeOfItemsThatAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def IsMadeOfItemsWhichAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT LISTS  #
	#----------------------------------------------------------#

	def ContainsItemsOtherThanLists()
		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotLists()
			return This.ContainsItemsOtherThanLists()

		def ContainsItemsWhichAreNotLists()
			return This.ContainsItemsOtherThanLists()

		#--

		def IsMadeOfItemsOtherThanLists()
			return This.ContainsItemsOtherThanLists()

		def IsMadeOfItemsThatAreNotLists()
			return This.ContainsItemsOtherThanLists()

		def IsMadeOfItemsWhichAreNotLists()
			return This.ContainsItemsOtherThanLists()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT OBJECTS  #
	#------------------------------------------------------------#

	def ContainsItemsOtherThanObjects()
		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsLists()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		def ContainsItemsWhichAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		#--

		def IsMadeOfItemsOtherThanObjects()
			return This.ContainsItemsOtherThanObjects()

		def IsMadeOfItemsThatAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		def IsMadeOfItemsWhichAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT STRINGS  #
	#=================================================================#

	def ContainsOnlyItemsOtherThanStrings()

		if This.ContainsStrings()
			return _FALSE_
		ok

		if This.ContainsNumbers() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def ContainsOnlyItemsWhichAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		#--

		def IsMadeOfOnlyItemsOtherThanStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfOnlyItemsThatAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfOnlyItemsWhichAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		#==

		def ContainsItemsThatAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def ContainsItemsWhichAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		#--

		def ContainsItemsOtherThanStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsOtherThanStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsThatAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsWhichAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT NUMBERS  #
	#-----------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanNumbers()

		if This.ContainsNumbers()
			return _FALSE_
		ok

		if This.ContainsStrings() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def ContainsOnlyItemsWhichAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#--

		def IsMadeOfOnlyItemsOtherThanNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfOnlyItemsThatAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfOnlyItemsWhichAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#==

		def ContainsItemsThatAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def ContainsItemsWhichAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def ContainsItemsOtherThanNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsOtherThanNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsThatAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsWhichAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT LISTS  #
	#---------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanLists()

		if This.ContainsLists()
			return _FALSE_
		ok

		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsObjects()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def ContainsOnlyItemsWhichAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		#--

		def IsMadeOfOnlyItemsOtherThanLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfOnlyItemsThatAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfOnlyItemsWhichAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		#==

		def ContainsItemsThatAreNotlistsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def ContainsItemsWhichAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		#--

		def ContainsItemsOtherThanListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsOtherThanListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsThatAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsWhichAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT OBJECTS  #
	#-----------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanObjects()
		if This.ContainsObjects()
			return _FALSE_
		ok

		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsLists()

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def ContainsOnlyItemsWhichAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def IsMadeOfOnlyItemsOtherThanObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfOnlyItemsThatAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfOnlyItemsWhichAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		#==

		def ContainsItemsThatAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def ContainsItemsWhichAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def ContainsItemsOtherThanObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsOtherThanObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsThatAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsWhichAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#>

	  #====================#
	 #  SHOWING THE LIST  #
	#====================#

	def Show()
		? @@( This.Content() )

		#< @FuntionMisspelledForm

		def Shwo()
			This.Show()

		#>

	def ShowShort()
		? @@S( This.Content() )

		def ShowShortCopy()
			This.ShowShort()

		#< @FuntionMisspelledForms

		def ShwoShort()
			This.ShowShort()

		def ShwoShortCopy()
			This.ShowShort()

		#>

	def ShowShortXT(p)
		? @@SXT( This.Content(), p)

		def ShowShortenedXT(p)
			This.ShowShortXT(p)

		#< @FuntionMisspelledForms

		def ShwoShortXT(p)
			This.ShowShortXT(p)

		def ShwoShortenedXT(p)
			This.ShowShortXT(p)

		#>

	def ShowShortN(n)
		? @@SN( This.Content(), n )

		#< @FuntionMisspelledForm

		def ShwoShortN(n)
			This.ShowShortN(n)

		#>

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortUsing(pcMiddlePart)
			This.ShowShortUsing(pcMiddlePart)

		#>

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortNUsing(n, pcMiddlePart)
			This.ShowShortNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST  #
	#=========================================#

	def ToShort()
		return This.ToShortXT(10, 3, "...")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST WITH N ITEMS FROM EACH SIDE  #
	#---------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, "...")

	  #-------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST USiNG A GIVEN MIDDLE PART  #
	#-------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST USING N ITEMS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #----------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE LIST -- EXTENDED  #
	#----------------------------------------------------#

	def ToShortXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		# nMinListSize : the minimum size to start shortening
		# --> if the size of the list is less than this value,
		#     the list will not be shortened (returned as is)

		# pNumberOfItemsToShow: the number of items to show from
		# both the beginning and end of the list
		# --> the other part of the item (coming in the middle)
		#     will be hided and replaced by pcMiddlePart

		/* EXAMPLES

		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).Shortened()
		#--> '[ "1", "2", "3", "...", "7", "8", "9" ]'
		
		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).ShortenedN(2)
		#--> '[ "1", "2", "...", "8", "9" ]'
		
		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).ShortenedXT(0, 2, "{...}")
		#--> '[ "1", "2", "{...}", "8", "9" ]'

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinListSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfItemsToShow)
			n1 = pNumberOfItemsToShow
			n2 = pNumberOfItemsToShow

		but isList(p) and Q(pNumberOfItemsToShow).IsPairOfNumbers()
			n1 = pNumberOfItemsToShow[1]
			n2 = pNumberOfItemsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfItemsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of items to show must be different of zero..")
		ok

		# Doing the job

		aPart1 = This.Section(1, n1)
		aPart2 = This.Section(nLen - n2 + 1, nLen)

		aResult = aPart1
		aResult + pcMiddlePart

		for i = 1 to n2
			aResult + aPart2[i]
		next

		return aResult

	  #-----------------------#
	 #  SHORTENING THE LIST  #
	#=======================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #------------------------------------------------#
	 #  SHORTENING THE LIST TO N ITEMS FROM EACH SIDE #
	#------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNItems(n)
			This.ShortenN(n)

			def ShortenToNItemsQ(n)
				This.ShortenToNItems(n)
				return This

		def ShortenToNItemsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsInEachSideQ(n)
				This.ShortenToNItemsInEachSide(n)
				return This

		def ShortenToNItemsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsFromEachSideQ(n)
				This.ShortenToNItemsFromEachSide(n)
				return This

		def ShortenToNItemsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsAtEachSideQ(n)
				This.ShortenToNItemsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNItems(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #---------------------------------------------------------------#
	 #  SHORTENING THE LIST USING THE GIVEN STRING AS A MIDDLE ITEM  #
	#---------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE LIST USING N ITEMS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE LIST -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
			This.ShortenXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinListSize, pNumberOfItemsToShow, pcMiddlePart).Content()
		return cResult

	  #======================================#
	 #  FINDING ALL OCCURRENCES OF AN ITEM  #
	#======================================#

	#TODO
	# Compare the code of this function and the FindDuplicates() function
	#-> See if there is a window of enhancement

	#NOTE
	# The function uses This.Stringified() to turn the items of the list
	# into strings before finding them (necessary to find items other than
	# numbers and strings). Hence, when the function is called on a
	# child class like for example:

	# StzListOfPairs([ [1,3], [9, 9], [12, 15], [9, 9] ]).FindAll([9, 9])

	# and when the list is stringified, an error message will be raised
	# when the list of pairs is updated (Can't update the list of pairs
	# with a list of strings).

	# To avoid this problem, we force stzList to apply This.Stringified()
	# on itself and not in its child classes, by using instead of it:

	# StzListQ(this.Content()).Stringified()

	def FindAllOccurrencesCS(pItem, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ring", "ring", "_" ])
		? o1.Find("ring")

		*/

		if CheckingParams()
	
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

			if isObject(pItem) and NOT @IsNamedObject(pItem)
				StzRaise("Can't find an unnamed object!")
			ok

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok

		ok

		# Relying on a Ring-native solution (using the @FindAll() optimised
		# function, provided by Softannza at the global level)

		aContent = This.Content()
		nLen = len(aContent)

		if EarlyCheck()
			if nLen = 0
				return []
			ok
		ok

		anResult = @FindAllCS( aContent, pItem, pCaseSensitive)

		if isList(anResult) > 0
			return anResult

		else # the returned value is -1 ~> @FindAll() was not able to compute pItem
		     # because it was not a number or string

		# we rely on an advanced Softanza solution that finds
		# not only numbers and strings (base on the stringifying of the list)

			cItem = ""
			if isList(pItem)
				cItem = @@(pItem)
	
			but isObject(pItem) and @IsStzObject(pItem) and pItem.IsNamed()
				cItem = pItem.ObjectName()
	
			else
				cItem = Q(pItem).Stringified()
	
			ok
	
			acContent = StzListQ(This.Content()).Stringified()
			nLen = len(acContent)
	
			# Managing case sensitivity
	
			if pCaseSensitive = _FALSE_
				cItem = ring_lower(cItem)
	
				for i = 1 to nLen
					if NOT ring_isLower(acContent[i])
						acContent[i] = ring_lower(acContent[i])
					ok
				next
			ok
	
			# Getting the occurrences
	
			anResult = []
	
			for i = 1 to nLen
				if acContent[i] = cItem
					anResult + i
				ok
			next
	
			return anResult
		ok

		#< @FunctionFluentForm

		def FindAllOccurrencesCSQ(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCSQRT(pItem, pCaseSensitive, :stzList)

		def FindAllOccurrencesCSQRT(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfUnicodes
				return new stzListOfUnicodes( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfSets
				return new stzListOfSets( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfGrids
				return new stzListOfGrids( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfTables
				return new stzListOfTables( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfEntities
				return new stzListOfEntities( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfBytes
				return new stzListOfBytes( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.FindAllCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FindAllCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def FindAllCSQ(pItem, pCaseSensitive)
				return This.FindAllCSQRT(pItem, pCaseSensitive, :stzList)
	
			def FindAllCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllOccurrencesCSQRT(pItem, pCaseSensitive, pcReturnType)
			#>

		def FindItemCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def FindItemCSQ(pItem, pCaseSensitive)
				return This.FindItemCSQRT(pItem, pCaseSensitive, :stzList)
	
			def FindItemCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQRT(pItem, pCaseSensitive, pcReturnType)
			#>

		def PositionsCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def PositionsCSQ(pItem, pCaseSensitive)
				return This.PositionsCSQRT(pItem, pCaseSensitive, :stzList)
	
			def PositionsCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQRT(pItem, pCaseSensitive, pcReturnType)
			#>

		def OccurrencesCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def OccurrencesCSQ(pItem, pCaseSensitive)
				return This.OccurrencesCSQRT(pItem, pCaseSensitive, :stzList)
	
			def OccurrencesCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQRT(pItem, pCaseSensitive, pcReturnType)
			#>

		def FindCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			def FindCSQ(pItem, pCaseSensitive)
				return This.FindCSQRT(pItem, pCaseSensitive, :stzList)

			def FindCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQRT(pItem, pCaseSensitive, pcReturnType)

		#>	

	#-- WITHOUT CASESENSITIVITY

	def FindAllOccurrences(pItem)
		aResult = This.FindAllOccurrencesCS(pItem, _TRUE_)
		return aResult

		#< @FunctionFluentForm

		def FindAllOccurrencesQ(pItem)
			return This.FindAllOccurrencesQRT(pItem, :stzList)

		def FindAllOccurrencesQRT(pItem, pcReturnType)
			return This.FindAllOccurrencesCSQRT(pItem, _TRUE_, pcReturnType)
		#>

		#< @FunctionAlternativeForms

		def FindAll(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindAllQ(pItem)
				return This.FindAllQRT(pItem, :stzlist)
	
			def FindAllQRT(pItem, pcReturnType)
				return This.FindAllOccurrencesQRT(pItem, pcReturnType)
	
			#>

		def FindItem(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindItemQ(pItem)
				return This.FindItemQRT(pItem, :stzList)
	
			def FindItemQRT(pItem, pcReturnType)
				return This.FindAllOccurrencesQRT(pItem, pcReturnType)
			#>

		def Positions(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def PositionsQ(pItem)
				return This.PositionsQRT(pItem, :stzList)
	
			def PositionsQRT(pItem, pcReturnType)
				return This.FindAllOccurrencesQRT(pItem, pcReturnType)
			#>

		def Occurrences(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def OccurrencesQ(pItem)
				return This.OccurrencesQRT(pItem, :stzList)
	
			def OccurrencesQRT(pItem, pcReturnType)
				return This.FindAllOccurrencesQRT(pItem, pcReturnType)
			#>

		def Find(pItem)
			if isList(pItem) and Q(pItem).IsItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindQ(pItem)
				return This.FindQRT(pItem, :stzList)
	
			def FindQRT(pItem, pcReturnType)
				return This.FindAllOccurrencesQRT(pItem, pcReturnType)
			#>
		#>

	  #---------------------------------------------------#
	 #  FINDING POSITIONS WHERE THE ITEM DOES NOT EXIST  #
	#===================================================#

	def AntiFindCS(pItem, pCaseSensitive)
		/* Example

		o1 = new stzList([ "1", "2", "", "4", "5", "", "6", "7", "", "9" ])
		
		? @@( o1.Find("") ) + NL
		#--> [ 3, 6, 9 ]
		
		? @@( o1.AntiFind("") ) + NL
		#--> [ 1, 2, 4, 5, 7, 8, 10 ]

		*/

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anResult = Q(1:This.NumberOfItems()) - These(anPos)
		// #TODO Make a more performant solution!

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pItem)
		return This.AntiFindCS(pItem, _TRUE_)

	  #--------------------------------------------------#
	 #  FINDING SECTIONS WHERE THE ITEM DOES NOT EXIST  #
	#--------------------------------------------------#

	def AntiFindAsSectionsCS(pItem, pCaseSensitive)
		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzListQ(1:This.NumberOfItems()).AntiPositionsZZ(anPos)
		return aResult

		def AntiFindCSZZ(pItem, pCaseSensitive)
			return This.AntiFindAsSectionsCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSections(pItem)
		return This.AntiFindAsSectionsCS(pItem, _TRUE_)

		def AntiFindZZ(pItem)
			return This.AntiFindAsSections(pItem)

	  #-----------------------------------------------------------------#
	 #  GETTING THE ANTI-POSITIONS OF THE GIVEN POSITIONS IN THE LIST  #
	#-----------------------------------------------------------------#

	def AntiPositions(anPos)

		if CheckingParams()
			if isList(anPos) and stzListQ(anPos).IsOfNamedParam()
				anPos = anPos[2]
			ok

			if NOT isList(anPos)
				Stzraise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		nLen = len(@aContent)
		anContent = 1 : len(@aContent)

		anResult = []

		for i = 1 to nLen
			if ring_find(anPos, anContent[i]) = 0
				anResult + i
			ok
		next

		return anResult

		#< @FunctionFluentForm

		def AntiPositionsQ(anPos)
			return new stzList(This.AntiPositions(anPos))

		def AntiPositionsQRT(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.AntiPositions(anPos))
			on :stzListOfNumbers
				return new stzListOfNumbers(This.AntiPositions(anPos))
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def AntiPositionsOf(anPos)
			return This.AntiPositions(anPos)

			def AntiPositionsOfQ(anPos)
				return This.AntiPositionsQ(anPos)

			def AntiPositionsOfQRT(anPos, pcReturnType)
				return This.AntiPositionsQRT(anPos, pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE ANTI-Sections OF THE GIVEN POSITIONS IN THE LIST  #
	#----------------------------------------------------------------#

	def AntiPositionsAsSections(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtPositions(panPos)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			nLenTemp = len(aSections[i])
			aResult + [ aSections[i][1], aSections[i][nLenTemp] ]
		next

		return aResult

		def AntiPositionsZZ(panPos)
			return This.AntiPositionsAsSections(panPos)

	  #=======================================================#
	 #    FINDING N OCCURRENCES OF AN ITEM INSIDE THE LIST   #
	#=======================================================#

	# Finding works only for numbers and strings

	#TODO // Lists and objects will become findable after
	# designing an overall solution of the Equality problem
	# in SoftanzaLib

	#UPDATE // Lists are now findable (only objects are left for future)
	#UPDATE // Named objects are now findable!

	def FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ 1, 2, "*", 4, 5, "*", 7, 8, "*", 10 ])
		? o1.FindNth(3, "*")
		#--> 9

		*/

		if CheckingParams()

			if isString(n)
				if n = :First or n = :FirstOccurrence
					n = 1
	
				but n = :Last or n = :LastOccurrence
					n = This.NumberOfOccurrenceCS(pItem, pCaseSensitive)
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect  param type! n must be a number.")
			ok
	
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

			if isObject(pItem) and NOT @IsNamedObject(pItem)
				StzRaise("Can't proceed! Objects, unless they are named objects, can not be found yet.")
			ok

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok

		ok

		# Early chek

		if NOT This.NumberOfOccurrenceCS(pItem, pCaseSensitive) >= n
			return 0
		ok

		# Trying to use the Ring native find() function

		nPos = @FindNthCS(This.Content(), n, pItem, pCaseSensitive)

		#NOTE // We can send the content directly since the @FindNthCS()
		# function is safe and won't change the value of its params.
		if nPos != -1
			return nPos

		else
		# Otherwise, stringifying the list and doing the job
	
			cItem = ""
			if isList(pItem) or @IsNamedObject(pItem)
				cItem = @@(pItem)
			else
				cItem = Q(pItem).Stringified()
			ok
	
			acContent = StzListQ(This.Content()).Stringified()
			nLen = len(acContent)
	
			# Managing case sensitivity
	
			if pCaseSensitive = _FALSE_
				cItem = ring_lower(cItem)
	
				for i = 1 to nLen
					if NOT ring_isLower(acContent[i])
						acContent[i] = ring_lower(acContent[i])
					ok
				next
			ok
	
			# Counting the occurrences
	
			nOccurr = 0
	
			for i = 1 to nLen
	
				if acContent[i] = cItem
					nOccurr++
					if nOccurr = n
						return i
					ok
				ok
			next
	
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindNthItemCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def FindNthCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthOccurrenceCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def ItemPositionByOccurrenceCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pItem) 
		return This.FindNthOccurrenceCS(n, pItem, _TRUE_) 

		#< @FunctionAlternativeForms

		def FindNthItem(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def FindNth(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def Nth(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def NthOccurrence(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def ItemPositionByOccurrence(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		#>

	  #----------------------------------------------------------------#
	 #    FINDING NTH TO LAST OCCURRENCE OF AN ITEM INSIDE THE LIST   #
	#----------------------------------------------------------------#

	def NthToLast(n)
		return This.ItemAtPosition( This.NumberOfItems() - n )

	  #----------------------------------------------------------------#
	 #    FINDING NTH TO LAST OCCURRENCE OF AN ITEM INSIDE THE LIST   #
	#----------------------------------------------------------------#

	def NthToFirst(n)
		return This.ItemAtPosition(n + 1)

	  #---------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN THE LIST  #
	#---------------------------------------------------#

	def FindFirstOccurrenceCS(pItem, pCaseSensitive)

		return This.FindNthOccurrenceCS(1, pItem, pCaseSensitive)


		#< @FunctionAlternativeForms

		def FindFirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FirstOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)
	
		#>

		#< @FunctionMisspelledForms

		def FindFristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FristOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFristOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstOccurrence(pItem)
		return This.FindFirstOccurrenceCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindFirst(pItem)
			return This.FindFirstOccurrence(pItem)

		def FirstOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)

		def First(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFirst(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFirstOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)
	
		#>

		#< @FunctionMisspelledForms

		def FindFrist(pItem)
			return This.FindFirstOccurrence(pItem)

		def FristOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)

		def Frist(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFrist(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFristOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)
	
		#>

	  #--------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN THE LIST  #
	#--------------------------------------------------#

	def FindLastOccurrenceCS(pItem, pCaseSensitive)
		nLen = len(@aContent)
		nPos = This.Copy().ReverseQ().FindFirstCS(pItem, pCaseSensitive)
		nResult = nLen - nPos + 1
		return nResult

		#< @FunctionAlternativeForms

		def FindLastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def LastOccurrenceCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def LastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfLastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfLastOccurrenceCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastOccurrence(pItem)

		return This.FindLastOccurrenceCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLast(pItem)
			return This.FindLastOccurrence(pItem)

		def LastOccurrence(pItem)
			return This.FindLastOccurrenceCS(pItem)

		def Last(pItem)
			return This.FindLastOccurrenceCS(pItem)

		def PositionOfLast(pItem)
			return This.FindLastOccurrence(pItem)

		def PositionOfLastOccurrence(pItem)
			return This.FindLastOccurrence(pItem)

		#>

	  #------------------------------------------#
	 #   FINDING GIVEN OCCURRENCES OF AN ITEM   #
	#------------------------------------------#

	def FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		if CheckingParams()
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and Q(panOccurr[nLen]).IsAndNamedParam()
				panOccurr[nLen] = panOccurr[nLen][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrenceCS(pItem, pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panOccurr)
				StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
			ok

		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		return Q(anPos).ItemsAt(panOccurr)

		def FindOccurrencesCS(panOccurr, pItem, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pItem)
		return This.FindTheseOccurrencesCS(panOccurr, pItem, _TRUE_)

		def FindOccurrences(panOccurr, pItem)
			return This.FindTheseOccurrences(panOccurr, pItem)

	  #-------------------------------------------------------#
	 #   FINDING THE OCCURRENCES OF MANY ITEMS IN THE LIST   #
	#-------------------------------------------------------#
	
	def FindManyCS(paItems, pCaseSensitive)

		/*
		o1 = new stzList([ :one, :two, :one, :three, :one, :four ])
		? o1.FindMany([ :one, :two, :four ])
		#--> [ 1, 2, 3, 5, 6 ]
		*/

		if CheckingParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		aItems = U(paItems)
		nLen = len(aItems)

		anResult = []

		for i = 1 to nLen
			anPos = This.FindAllCS(aItems[i], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)

		return anResult

		#< @FunctionFluentForm

		def FindManyCSQ(paItems, pCaseSensitive)
			return new stzList(This.FindManyCS(paItems, pCaseSensitive))

		def FindManyCSQRT(paItems, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(paItems, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(paItems, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#

		#< @FunctionAlternativeForms

		def FindTheseItemsCS(paItems, pCaseSensitive)
			return This.FindManyCS(paItems, pCaseSensitive)

		def FindTheseCS(paItems, pCaseSensitive)
			return This.FindManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(paItems)
		return This.FindManyCS(paItems, _TRUE_)

		#< @FunctionFluentForm

		def FindManyQ(paItems)
			return new stzList(This.FindMany(paItems))

		def FindManyQRT(paItems, pcReturnType)
			return This.FindManyCSQRT(paItems, _TRUE_, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def FindTheseItems(paItems)
			return This.FindMany(paItems)

		def FindThese(paItems)
			return This.FindMany(paItems)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING THE OCCURRENCES OF MANY ITEMS IN THE LIST -- EXTENDED  #
	#------------------------------------------------------------------#

	def TheseItemsCSZ(paItems, pCaseSensitive)
		/*
		o1 = new stzList([ :one, :two, :one, :three, :one, :four ])
		? o1.TheseItemsZZ([ :one, :two, :four ])
		#--> [ :one = [1, 3, 5], :two = [2], :three = [6] ]
		*/

		if CheckingParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)

		aResult = []

		for i = 1 to nLen
			aResult + [ paItems[i], This.FindAllCS(paItems[i], pCaseSensitive) ]
		next

		return aResult

		#< @FunctionFluentForm

		def TheseItemsCSZQ(paItems, pCaseSensitive)
			return new stzList( This.TheseItemsCSZ(paItems, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def TheseItemsAndTheirPositionsCS(paItems, pCaseSensitive)
			return This.TheseItemsCSZ(paItems, pCaseSensitive)

			def TheseItemsAndTheirPositionsCSQ(paItems, pCaseSensitive)
				return This.TheseItemsCSZQ(paItems, pCaseSensitive)
		#>

	#-- CASESENSITIVITY

	def TheseItemsZ(paItems)
		return This.TheseItemsCSZ(paItems, _TRUE_)

		#< @FunctionFluentForm

		def TheseItemsZQ(paItems)
			return new stzList( This.TheseItemsZ(paItems) )

		#>

		#< @FunctionAlternativeForm

		def TheseItemsAndTheirPositions(paItems)
			return This.TheseItemsZ(paItems)

			def TheseItemsAndTheirPositionsQ(paItems)
				return This.TheseItemsZQ(paItems)
		#>

	  #-------------------------------------------#
	 #  FINDING ITEMS OTHER THAN THOSE PROVIDED  #
	#-------------------------------------------#

	def FindItemsOtherThanCS(paItems, pCaseSensitive)
		if CheckingParams()

			if NOT isList(paItems)
				aTemp = []
				aTemp + paItems
				paItems = aTemp
			ok

		ok

		anPos = This.FindTheseItemsCS(paItems, pCaseSensitive)

		nLen = This.NumberOfItems()
		anResult = Q( 1 : nLen) - These(anPos)
		// #TODO Make a more performant solution!

		return anResult

		#< @FunctionAlternativeForms

		def FindItemsExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindItemsOtherThanTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanTheseItemsCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindAllExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllItemsExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindAllButCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindItemsOtherThan(paItems)
		return This.FindItemsOtherThanCS(paItems, :CaseSensitive)

		#< @FunctionAlternativeForms

		def FindItemsExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindItemsOtherThanThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindItemsExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThanTheseItems(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThanThese(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindAllExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllItemsExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllItemsExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThan(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindAllBut(paItems)
			return This.FindItemsOtherThan(paItems)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF AN ITEM, EXCEPT THE FIRST OCCURRENCE  #
	#-------------------------------------------------------------------#

	def FindAllExceptFirstCS(pItem, pCaseSensitive)
		anResult = This.FindAllCSQ(pItem, pCaseSensitive).Section(2, :LastItem)
		return anResult

		#< @FunctionFluentForm

		def FindAllExceptFirstCSQRT(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptFirstCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptFirstCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptFirstCSQ(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCSQRT(pItem, pCaseSensitive, :stzList)

		#

		#< @FunctionAlternativeForms

		def FindExceptFirstCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptFirstCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptFirstCSQRT(pItem, pCaseSensitive, pcReturnType)
	
			def FindExceptFirstCSQ(pItem, pCaseSensitive)
				return This.FindAllExceptFirstCSQRT(pItem, pCaseSenstive, :stzList)
	
		def FindFirstExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		def FindFirstButCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		def FindAllButFirstCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindExceptFristCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptFristCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptFristCSQRT(pItem, pCaseSensitive, pcReturnType)
	
			def FindExceptFristCSQ(pItem, pCaseSensitive)
				return This.FindAllExceptFristCSQRT(pItem, pCaseSenstive, :stzList)
	
		def FindFristExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		def FindFristButCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		def FindAllButFristCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		#>

	#-- WITHoUT CASESENSITIVITY

	def FindAllExceptFirst(pItem)
		return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		#< @FunctionFluentForm

		def FindAllExceptFirstQ(pItem)
			return This.FindAllExceptFirstQRT(pItem, :stzList)

		def FindAllExceptFirstQRT(pItem, pcReturnType)
			return This.FindAllExceptFirstCSQRT(pItem, _TRUE_, pcReturnType)

		#

		#< @FunctionAlternativeForms

		def FindExceptFirst(pItem)
			return This.FindAllExceptFirst(pItem)

			#< @FunctionFluentForm
	
			def FindExceptFirstQRT(pItem, pcReturnType)
				return This.FindExceptFirstCSQRT(pItem, _TRUE_, pcReturType)
	
			def FindExceptFirstQ(pItem)
				return This.FindAllExceptFirstQRT(pItem, :stzList)
	
			#>

		def FindFirstExcept(pItem)
			return This.FindAllExceptFirst(pItem)

		def FindFirstBut(pItem)
			return This.FindAllExceptFirst(pItem)

		def FindAllButFirst(pItem)
			return This.FindAllExceptFirst(pItem)

		#>

		#< @FunctionMisspelledForms

		def FindExceptFrist(pItem)
			return This.FindAllExceptFrist(pItem)

			#< @FunctionFluentForm
	
			def FindExceptFristQRT(pItem, pcReturnType)
				return This.FindAllExceptFristQRT(pItem, pcReturnType)
	
			def FindExceptFristQ(pItem)
				return This.FindAllExceptFristQRT(pItem, :stzList)
	
		def FindFristExcept(pItem)
			return This.FindAllExceptFrist(pItem)

		def FindFristBut(pItem)
			return This.FindAllExceptFrist(pItem)

		def FindAllButFrist(pItem)
			return This.FindAllExceptFrist(pItem)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF AN ITEM, EXCEPT THE LAST OCCURRENCE  #
	#------------------------------------------------------------------#

	def FindAllExceptLastCS(pItem, pCaseSensitive)
		oTemp = new stzList( This.FindAllCS(pItem, pCaseSensitive) )
		return oTemp.Section( 1, oTemp.NumberOfItems()-1 )

		#< @FunctionFluentForm

		def FindAllExceptLastCSQRT(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptLastCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptLastCS(pItem, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptLastCSQ(pItem, pCaseSensitive)
			return This.FindAllExceptLastCSQRT(pItem, pCaseSensitive, :stzList)

		#

		#< @FunctionAlternativeForms

		def FindExceptLastCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptLastCSQRT(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptLastCSQRT(pItem, pCaseSensitive, pcReturnType)
	
			def FindExceptLastCSQ(pItem)
				return This.FindAllExceptLastQRT(pItem, pCaseSensitive, :stzList)
	
			#>

		def FindLastExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		def FindLastButCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		def FindAllButLastCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FindAllExceptLast(pItem)
		return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		#< @FunctionFluentForm

		def FindAllExceptLastQRT(pItem, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptLast(pItem) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptLast(pItem) )
			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptLastQ(pItem)
			return This.FindAllExceptLastQRT(pItem, :stzList)

		#

		#< @FunctionAlternativeForm

		def FindExceptLast(pItem)
			return This.FindAllExceptLast(pItem)

			#< @FunctionFluentForm
	
			def FindExceptLastQ(pItem)
				return This.FindAllExceptLastQRT(pItem, :stzListOfNumbers)

			def FindExceptLastQRT(pItem, pcReturnType)
				return This.FindExceptLastCSQRT(pItem, _TRUE_, pcReturnType)
		
			#>

		def FindLastExcept(pItem)
			return This.FindAllExceptLast(pItem)

		def FindLastBut(pItem)
			return This.FindAllExceptLast(pItem)

		def FindAllButLast(pItem)
			return This.FindAllExceptLast(pItem)

		#>

	  #------------------------------------------------#
	 #   FINDING A SUBLIST IN AN ITEM THAT IS A LIST   #
	#================================================#

	def FindSubListCS(paItems, pCaseSensitive)
		/* EXAMPLE

				   .  .  .  .   .   .  .  .  .   .   .  .  .  .
		o1 = new stzList([ 1, 2, 3, 4, "|", 2, 3, 4, 5, "|", 2, 3, 4, 5 ])
				      \_____/       \_____/          \_____/
					 2             6                11

		? o1.FindSubList([ 2, 3, 4 ])
		
		#--> [

		*/

		if CheckingParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if len(paItems) < 2
				StzRaise("Incorrect param value! paItems must contain at least two items.")
			ok
		ok

		nLen = len(paItems)
		onPos = This.FindManyCSQ(paItems, pCaseSensitive)

		anSubPos = onPos / nLen
		// #TODO Replace with a more performant solution

		if len(anSubPos) = 0
			return []
		ok

		anResult = []

		if @AreContiguous(anSubPos)
			for i = 1 to nLen
				anResult + anSubPos[i][1]
			next
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindTheseContiguousItemsCS(paItems, pCaseSensitive)
			return This.FindSubListCS(paItems, pCaseSensitive)

		def FindTheseAdjascentItemsCS(paItems, pCaseSensitive)
			return This.FindSubListCS(paItems, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def FindSubList(paItems)
		return This.FindSubListCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindTheseContiguousItems(paItems)
			return This.FindSubList(paItems)

		def FindTheseAdjascentItems(paItems)
			return This.FindSubList(paItems)

		#>

	  #---------------------------------------------------#
	 #   CHECKING IF THE LIST CONTAINS A GIVEN SUBLIST   #
	#===================================================#

	def ContainsSubListCS(paSubList, pCaseSensitive)

		if CheckingParams()
			if NOT isList(paSubList)
				StzRaise("Incorrect param type! paSubList must be a list.")
			ok
		ok

		ocListInAString     = @@Q(@aContent)
		cSubListStringified = @@Q(paSubList).RemoveTheseBoundsQ("[", "]").TrimQ().Content()

		bResult = ocListInAString.ContainsCS(cSubListStringified, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def ContainsTheseContiguousItemsCS(paSubList, pCaseSensitive)
			return This.ContainsSubListCS(paSubList, pCaseSensitive)

		def ContainsTheseAdjascentItemsCS(paSubList, pCaseSensitive)
			return This.ContainsSubListCS(paSubList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubList(paSubList)
		return This.ContainsSubListCS(paSubList, _TRUE_)

		#< @FunctionAlternativeForms

		def ContainsTheseContiguousItems(paSubList)
			return This.ContainsSubList(paSubList)

		def ContainsTheseAdjascentItems(paSubList)
			return This.ContainsSubList(paSubList)

		#>
		
	  #======================================================#
	 #  CHECKING IF THE LIST CONTAINS AN ITEM AT ANY LEVEL  #
	#======================================================#

	def DeepContainsCS(pItem, pCaseSensitive)

		_bCase_ = @CaseSensitive(pCaseSensitive)

		if _bCase_ = _FALSE_
			_cList_ = @@Q( This.Content() ).Lowercased()
			_cItem_ = @@Q(pItem).Lowercased()

		else
			_cList_ = @@(This.content())
			_cItem_ = @@(pItem)
		ok

		if _cItem_ = ""
			return 0
		ok

		_oQStr_ = new QString2()
		_oQStr_.append(_cList_)
		_bResult_ = _oQStr_.contains(_cItem_, _bCase_)

		return _bResult_

	#-- WITHOUT CASESENSITIVITY

	def DeepContains(pItem)
		return This.DeepContainsCS(pItem, _TRUE_)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE PROVIDED ITEMS ARE ALL CONTAINED IN THE LIST AT ANY LEVEL  #
	#-----------------------------------------------------------------------------#

	def DeepContainsManyCS(paItems, pCaseSensitive)
		bResult = _TRUE_
		nLen = len(paItems)

		for i = 1 to nLen

			if NOT This.DeepContainsCS(paItems[i], pCaseSensitive)
				bResult = _FALSE_
				exit
			ok

		next

		return bResult

		#< @FunctionAlternativeForms

		def DeepContainsTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachOneOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsAllOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsMany(paItems)
		return This.DeepContainsManyCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def DeepContainsThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEach(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEachOneOfThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEachOfThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsAllOfThese(paItems)
			return This.DeepContainsMany(paItems)

		#>


	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS BOTH OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#-------------------------------------------------------------------------#

	def DeepContainsBothCS(pItem1, pItem2, pCaseSensitive)
		if isList(pItem2) and Q(pItem2).IsAndNamedParam()
			pItem2 = pItem2[2]
		ok

		return This.DeepContainsEachCS([ pItem1, pItem2 ], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsBoth(pItem1, pItem2)
		return This.DeepContainsBothCS(pItem1, pItem2, _TRUE_)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS AT LEAST ONE OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#--------------------------------------------------------------------------------#

	def DeepContainsOneOfTheseCS(paItems, pCaseSensitive)
		bResult = _FALSE_

		for i = 1 to len(paItems)
			if This.DeepContainsCS(paItems[i], pCaseSensitive)
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsOneOfThese(paItems)
		return This.DeepContainsOneOfTheseCS(paItems, _TRUE_)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS AT LEAST N OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#--------------------------------------------------------------------------------#

	def DeepContainsNOfTheseCS(n, paItems, pCaseSensitive)
		bResult = _FALSE_
		v = 0

		for i = 1 to len(paItems)
			if This.DeepContainsCS(paItems[i], pCaseSensitive)
				v++
				if v = n
					bResult = _TRUE_
					exit
				ok
			ok
		next

		return bResult

		def DeepContainsNItemsOfTheseCS(n, paItems, pCaseSensitive)
			return This.DeepContainsNOfTheseCS(n, paItems, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def DeepContainsNOfThese(n, paItems)
		return This.DeepContainsNOfTheseCS(n, paItems, _TRUE_)

		def DeepContainsNItemsOfThese(n, paItems)
			return This.DeepContainsNOfThese(n, paItems)

	  #================================#
	 #  FINDING AN ITEM AT ANY LEVEL  #
	#================================#

	/*
	TODO: Harmonize this section with  "LIST STRUCTURE" section
	--> There are some TODOs their, review them.
	*/

	// Finding pItem at any level of the list

	def DeepFindCS(pItem, pCaseSensitive) #ai #chat-gpt
		/* EXAMPLE

		o1 = new stzList([
			"you",
			"other",
			[ "other", "you", [ "you" ], "other" ],
			"other",
			"you"
		])

		o1.DeepFind("you")
		#--> "you" is found in the following positions
		[
			[ [1, 1], [1, 5] ],	# positions 1 and 5 in the level [1, 1]
			[ [3, 1], [ 2 ]  ],	# position 2 in the level [3, 1]
			[ [3, 2], [ 1 ]  ],	# position 1 in the level [3, 2]
		]
		*/

		_aContent_ = This.Content()
		_bCase_ = @CaseSensitive(pCaseSensitive)

		if isNumber(pItem)
			return FindNumberOrStringInNestedList(pItem, _aContent_)

		but isList(pItem)
			_cItem_ = @@(pItem)
			_cContent_ = @@(_aContent_)
	
			if _bCase_ = _FALSE_
				_cItem_ = lower(_cItem_)
				_cContent_ = lower(_cContent_)
			ok
	
			return FindStrListInNestedStrList( _cItem_, _cContent_ )

		but isString(pItem)

			if _bCase_ = _TRUE_
				_acStringified_ = This.DeepStringified()

			else
				_acStringified_ = This.DeepStringifyQ().Lowercased()
			ok

			return FindNumberOrStringInNestedList(pItem, _acStringified_)

		else //isObject(pItem)

			_cItem_ = @@(pItem)
			_cContent_ = @@(_aContent_)

			return FindStrListInNestedStrList( _cItem_, _cContent_ )

		ok

	#-- WITHOUT CASESENSITIVITY

	def DeepFind(pItem)
		return This.DeepFindCS(pItem, _TRUE_)

	  #-----------------------------------------------------#
	 #  FINDING THE LIST ITEMS IN AN OTHER LIST OR ITEM  #
	#-----------------------------------------------------#

	def FindInCS(pOtherListOrStr, pCaseSensitive)
		/* 
		EXAMPLE 1:

		o1 = new stzList([ "11", "22", "33" ])
		? o1.FindIn([ "11", "_", "22", "_", "33" ])
		#--> [ 1, 3, 4 ]

		EXAMPLE 2:

		o1 = new stzList([ "11", "22", "33" ])
		? o1.FindIn("**11**22**33**")
		#--> [ 3, 7, 11 ]

		*/

		if isList(pOtherListOrStr) and Q(pOtherListOrStr).IsListNamedParam()
			pOtherListOrStr = pOtherListOrStr[2]

			if NOT isList(paOtherListOrStr)
				StzRaise("Incorrect param type! pOtherListOrStr must be a list.")
			ok
		ok

		if isList(pOtherListOrStr) and Q(pOtherListOrStr).IsStringNamedParam()
			pOtherListOrStr = pOtherListOrStr[2]

			if NOT isString(paOtherListOrStr)
				StzRaise("Incorrect param type! pOtherListOrStr must be a string.")
			ok
		ok

		if NOT (isList(pOtherListOrStr) or isString(pOtherListOrStr))
			StzRaise("Incorrect param type! pOtherListOrStr must be a list or string.")
		ok

		anResult = Q(pOtherListOrStr).FindManyCS(This.Content(), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForm

		def FindItemsInCS(pOtherListOrStr, pCaseSensitive)
			return This.FindInCS(pOtherListOrStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindIn(pOtherListOrStr)
		return FindInCS(pOtherListOrStr, _TRUE_)

		#< @FunctionAlternativeForm

		def FindItemsIn(pOtherListOrStr)
			return FindIn(pOtherListOrStr)

		#>

	  #-------------------------------------------#
	 #  FINDING THE LIST ITEMS IN AN OTHER LIST  #
	#-------------------------------------------#

	def FindInListCS(paOtherList, pCaseSensitive)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		return This.FindInCS(paOtherList, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindItemsInListCS(paOtherList, pCaseSensitive)
			return This.FindInListCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInList(paOtherList)
		return This.FindInListCS(paOtherList, _TRUE_)

		#< @FunctionAlternativeForm

		def FindItemsInList(paOtherList)
			return This.FindInList(paOtherList)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING THE GIVEN SUBSTRING INSIDE THE STRING-ITEMS IN THE LIST  #
	#-------------------------------------------------------------------#

	def FindInStringCS(pcStr, pCaseSensitive)
		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		return This.FindInCS(pcStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindItemsInStringCS(pcStr, pCaseSensitive)
			return This.FindInStringCS(pcStr, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def FindInString(pcStr)
		return This.FindInStringCS(pcStr, _TRUE_)

		#< @FunctionAlternativeForm

		def FindItemsInString(pcStr)
			return This.FindInString(pcStr)

		#>

	  #========================#
	 #  MANAGING INNER-LISTS  #
	#========================#
	#TODO// Organize this section with the section GETTING & REMOVING ITEMS OF TYPE LIST

	# Inner lists #Move this part near to Lists()

	def SizeOfLargestList()
		_nResult_ = @Max( This.ListsSizes() )
		return _nResult_

		def MaxListsSize()
			return This.SizeOfLargestList()

		def SizeOfBiggestList()
			return This.SizeOfLargestList()

		def SizeOfLongestList()
			return This.SizeOfLargestList()

	def FindLargestLists()

		if NOT This.ContainsLists()
			StzRaise("Can't proceed! The list contains no inner lists.") 
		ok

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_anResult_ = []
		_nMax_ = @Max( This.ListsSizes() )

		for @i = 1 to _nLen_
			if NOT islist(_aContent_[@i])
				loop
			ok

			if len(_aContent_[@i]) = _nMax_
				_anResult_ + @i
			ok
		next

		return _anResult_

		def FindBiggestLists()
			return This.FindLargestLists()

		def FindLongestLists()
			return This.FindLargestLists()

		def FindLargestList()
			_anResult_ = This.FindLargestLists()
			_nLen_ = len(_anResult_)

			if _nLen_ = 1
				return _anResult_[1]

			else
				return _anResult_
			ok

		def FindBiggestList()
			return This.FindLargestList()

		def FindLongestList()
			return This.FindLargestList()

	def LargestLists()
		return This.ItemsAtPositions( This.FindLargestLists() )

		def LongestLists()
			return This.LargestLists()

		def BiggestLists()
			return This.LargestLists()

		def LargestList()
			_pos_ = This.FindLargestLists()

			if isNumber(_pos_)
				return This.ItemAtPosition(_pos_)

			else
				return This.ItemsAtPositions(_pos_)
			ok

		def BiggestList()
			return This.LargestList()

		def LongestList()
			return This.LargestList()

	#--

	def SizeOfSmallestList()
		_nResult_ = @Min( This.ListsSizes() )
		return _nResult_

		def MinListsSize()
			return This.SizeOfSmallestList()

		def SizeOfShortestList()
			return This.SizeOfSmallestList()

	def FindSmallestLists()

		if NOT This.ContainsLists()
			StzRaise("Can't proceed! The list contains no inner lists.") 
		ok

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_anResult_ = []
		_nMin_ = @Min( This.ListsSizes() )

		for @i = 1 to _nLen_
			if NOT islist(_aContent_[@i])
				loop
			ok

			if len(_aContent_[@i]) = _nMin_
				_anResult_ + @i
			ok
		next

		return _anResult_

		def FindShortestLists()
			return This.FindSmallestLists()

		def FindSmallestList()
			_anResult_ = This.FindSmallestLists()
			_nLen_ = len(_anResult_)

			if _nLen_ = 1
				return _anResult_[1]

			else
				return _anResult_
			ok

		def FindShortestList()
			return This.FindSmallestList()

	def SmallestLists()
		return This.ItemsAtPositions( This.FindSmallestLists() )

		def ShortestLists()
			return This.SmallestLists()

		def SmallestList()
			_pos_ = This.FindSmallestLists()

			if isNumber(_pos_)
				return This.ItemAtPosition(_pos_)

			else
				return This.ItemsAtPositions(_pos_)
			ok

		def ShortestList()
			return This.SmallestList()

	  #===========================================#
	 #  PATH MANAGEMENT FOR NESTED (DEEP) LISTS  #
	#===========================================#

	def Paths()
		if This.IsEmpty()
			return []
		ok

		_cContent_ = @@Q( This.Content() ).AllRemovedExcept([ "[", ",", "]" ])
		_aResult_ = GeneratePaths(_cContent_)

		return _aResult_
	
		def AllPaths()
			return This.Paths()

		def PathsQ()
			return new stzList(This.Paths())

			def AllPathsQ()
				return This.PathsQ()

	#-- PATH METRICS
	
	def NumberOfPaths()
		return len(This.Paths())
	    
		def CountPaths()
			return This.NumberOfPaths()

		def HowManyPaths()
			return This.NumberOfPaths()

	#--

	def DeepestPath()
		return @DeepestPath( This.Paths() )

		def HighestPath()
			return This.DeepstPath()

	def ShallowestPath()
		_aResult_ = @ShallowestPath( This.Paths() )
		return _aResult_

		def LowestPath()
			return This.ShallowestPath()

	#--

	def PathsLengths()
		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_anResult_ = []

		for @i = 1 to _nLen_
			_anResult_ + len(_aPaths_[@i])
		next

		return _anResult_

		def LenghtsOfPaths()
			return This.PathsLengths()

		def LenOfPaths()
			return This.PathsLengths()

	def PathsAndTheirLengths()
		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_aResult_ = []

		for @i = 1 to _nLen_
			_aResult_ + [ _aPaths_[@i], len(_aPaths_[@i]) ]
		next

		return _aResult_

		def PathsAndTheirLen()
			return This.PathsAndTheirLenghts()

		#-- @Misspelled

		def PathsAndTheirLenghts()
			return This.PathsAndTheirLengths()

	def LengthOfLongestPath()
		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_nMax_ = 0

		for @i = 1 to _nLen_

			_nLenPath_ = len(_aPaths_[@i])

			if _nLenPath_ > _nMax_
				_nMax_ = _nLenPath_
			ok
		next

		return _nMax_

		def LenOfLongestPath()
			return This.LengthOfLongestPath()

		def LongestPathLenght()
			return This.LengthOfLongestPath()

		def LongestPathLen()
			return This.LengthOfLongestPath()

		#-- @Misspelled

		def LenghtOfLongestPath()
			return This.LengthOfLongestPath()

	def LongestPath()
		if This.IsEmpty()
			return []
		ok

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_nMax_ = 0
		_n_ = 1

		for @i = 1 to _nLen_

			_nLenPath_ = len(_aPaths_[@i])

			if _nLenPath_ > _nMax_
				_nMax_ = _nLenPath_
				_n_ = @i
			ok
		next

		return _aPaths_[_n_]

		def LargestPath()
			return This.LongestPath()

	def LongestPaths()
		if This.IsEmpty()
			return []
		ok

		_nMax_ = This.LengthOfLongestPath()

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_aResult_ = []

		for @i = 1 to _nLen_
			if len(_aPaths_[@i]) = _nMax_
				_aResult_ + _aPaths_[@i]
			ok
		next

		return _aResult_

		def LargestPaths()
			return This.LongestPaths()

	def NumberOfLongestPaths()
		if This.IsEmpty()
			return 0
		ok

		_nMax_ = This.LengthOfLongestPath()

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_nResult_ = 0

		for @i = 1 to _nLen_
			if len(_aPaths_[@i]) = _nMax_
				_nResult_++
			ok
		next

		return _nResult_

		def HowManyLongestPaths()
			return This.NumberOfLongestPaths()

		def CountLongestPaths()
			return This.NumberOfLongestPaths()

	def LengthOfShortestPath()
		if This.IsEmpty()
			return 0
		ok

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_nMin_ = len(_aPaths_[1])

		for @i = 1 to _nLen_

			_nLenPath_ = len(_aPaths_[@i])

			if _nLenPath_ < _nMin_
				_nMin_ = _nLenPath_
			ok
		next

		return _nMin_

		#-- @Misspelled

		def LenghtOfShortestPath()
			return This.LengthOfShortestPath()

	def ShortestPath()
		if This.IsEmpty()
			return []
		else
			return [1]
		ok

		def SmallestPath()
			return This.ShortestPath()

	def ShortestPaths()
		if This.IsEmpty()
			return []
		ok

		_nMax_ = This.LengthOfShortestPath()

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_aResult_ = []

		for @i = 1 to _nLen_
			if len(_aPaths_[@i]) = _nMax_
				_aResult_ + _aPaths_[@i]
			ok
		next

		return _aResult_

		def SmallestPaths()
			return This.ShortestPaths()

	def NumberOfShortestPaths()
		if This.IsEmpty()
			return 0
		ok

		_nMin_ = This.LengthOfShortestPath()

		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)

		_nResult_ = 0

		for @i = 1 to _nLen_
			if len(_aPaths_[@i]) = _nMin_
				_nResult_++
			ok
		next

		return _nResult_

		def HowManyShortestPaths()
			return This.NumberOfShortestPaths()

		def CountShortestPaths()
			return This.NumberOfShortestPaths()

	#-- PATH OPERATIONS

	def ItemAtPath(paPath)
		if CheckParams()
			if NOT This.IsValidPath(paPath)
				StzRaise("Incorrect param type! paPath must be a valid path in the list.")
			ok
		ok

		_aContent_ = This.Content()
		_cCode_ = '_result_ = _aContent_' + @@Q(paPath).ReplaceQ(",", "][").Content()
		eval(_cCode_)

		return _result_

		def ItemAtPathQ(paPath)
			return Q(This.ItemAtPath(paPath))

	def ItemAtPathZZ(paPath)
		if CheckParams()
			if NOT This.IsValidPath(paPath)
				StzRaise("Incorrect param type! paPath must be a valid path in the list.")
			ok
		ok

		_aContent_ = This.Content()
		_cCode_ = '_item_ = _aContent_' + @@Q(paPath).ReplaceQ(",", "][").Content()
		eval(_cCode_)

		_aResult_ = [ _item_, paPath ]
		return _aResult_

		def ItemAtPathZ(paPath)
			return This.ItemAtPathZZ(paPath)

	def ItemsAtPath(paPath)
		if CheckParams()
			if NOT This.IsValidPath(paPath)
				StzRaise("Incorrect param type! paPath must be a valid path in the list.")
			ok
		ok

		_aContent_ = This.Content()
		_nLenPath_ = len(paPath)

		_aResult_ = []

		_item_ = ""
		_cCode_ = '_item_ = _aContent_'

		for @i = 1 to _nLenPath_

			_cCode_ += '[' + paPath[@i] + ']' 
			eval(_cCode_)

			_aResult_ + _item_
		next

		return _aResult_

		def ItemsAtPathXT(paPath)
			return This.ItemsAtPath(paPath)

	def ItemsAtPathZZ(paPath)

		if CheckParams()
			if NOT This.IsValidPath(paPath)
				StzRaise("Incorrect param type! paPath must be a valid path in the list.")
			ok
		ok

		_aContent_ = This.Content()
		_nLenPath_ = len(paPath)

		_aResult_ = []

		_item_ = ""
		_cCode_ = '_item_ = _aContent_'

		for @i = 1 to _nLenPath_

			_cCode_ += '[' + paPath[@i] + ']' 
			eval(_cCode_)

			_aSubPath_ = []
			for @j = 1 to @i
				_aSubPath_ + paPath[@j]
			next

			_aResult_ + [ _item_, _aSubPath_ ]
		next

		return _aResult_

		def ItemsAtPathZ(paPath)
			return This.ItemsAtPathZZ(paPath)

		def ItemsAtPathXTZZ(paPath)
			return This.ItemsAtPathZZ(paPath)

		def ItemsAtPathXTZ(paPath)
			return This.ItemsAtPathZZ(paPath)

	def ItemsAtPaths(paPaths)
		if CheckParams()
			if NOT This.AreValidPaths(paPaths)
				StzRaise("Incorrect param type! paPaths must be a valid list of paths in the list.")
			ok
		ok

		_nLenPaths_ = len(paPaths)
		_aResult_ = []

		for @i = 1 to _nLenPaths_
			_aResult_ + This.ItemAtPath(paPaths[@i])
		next

		return _aResult_

	def ItemsAtPathsZZ(paPaths)
		if CheckParams()
			if NOT This.AreValidPaths(paPaths)
				StzRaise("Incorrect param type! paPaths must be a valid list of paths in the list.")
			ok
		ok

		_nLenPaths_ = len(paPaths)
		_aResult_ = []

		for @i = 1 to _nLenPaths_
			_aResult_ + [ This.ItemAtPath(paPaths[@i]), paPaths[@i] ]
		next

		return _aResult_

		def ItemsAtPathsZ(paPaths)
			return This.ItemsAtPathsZZ(paPaths)

	def ItemsAtPathsXT(paPaths)
		if CheckParams()
			if NOT This.AreValidPaths(paPaths)
				StzRaise("Incorrect param type! paPaths must be a valid list of paths in the list.")
			ok
		ok

		_nLenPaths_ = len(paPaths)
		_aResult_ = []

		for @i = 1 to _nLenPaths_
			_aResult_ + This.ItemsAtPathXT(paPaths[@i])
		next

		return _aResult_

	def ItemsAtPathsXTZZ(paPaths)
		if CheckParams()
			if NOT This.AreValidPaths(paPaths)
				StzRaise("Incorrect param type! paPaths must be a valid list of paths in the list.")
			ok
		ok

		_nLenPaths_ = len(paPaths)
		_aResult_ = []

		for @i = 1 to _nLenPaths_
			_aResult_ + [ This.ItemsAtPathXT(paPaths[@i]), paPaths[@i] ]
		next

		return _aResult_

		def ItemsAtPathsXTZ(paPaths)
			return This.ItemsAtPathsXTZZ(paPaths)

	#-- PATH'S SECTION

	def PathsSection(paPath1, paPath2)

		if CheckParams()

			if isList(paPath1) and StzListQ(paPath1).IsFromOrFromPathNamedParam()
				paPath1 = paPath1[2]
			ok

			if isList(paPath2) and StzListQ(paPath2).IsToOrToPathNamedParam()
				paPath2 = paPath2[2]
			ok

			if NOT AreValidPaths([ paPath1, paPath2 ])
				StzRaise("Incorrect param type! paPath1 and paPath2 are not valid paths.")
			ok
		ok

		_aResult_ = This.ItemsAtPaths( @PathsSection(paPath1, paPath2) )
		return _aResult_

		#< @FunctionAlternativeFroms

		def ItemsBetweenPaths(paPath1, paPath2)
			return This.PathsSection(paPath1, paPath2)

		def ItemsFromPathToPath(paPath1, paPath2)
			return This.PathsSection(paPath1, paPath2)

		#>

	def PathsSectionZZ(paPath1, paPath2)
		if CheckParams()

			if isList(paPath1) and StzListQ(paPath1).IsFromOrFromPathNamedParam()
				paPath1 = paPath1[2]
			ok

			if isList(paPath2) and StzListQ(paPath2).IsToOrToPathNamedParam()
				paPath2 = paPath2[2]
			ok

			if NOT AreValidPaths([ paPath1, paPath2 ])
				StzRaise("Incorrect param type! paPath1 and paPath2 are not valid paths.")
			ok
		ok

		_aPaths_ = @PathsSection(paPath1, paPath2)
		_aItems_ = This.ItemsAtPaths(_aPaths_)
		_aResult_ = @Association([ _aItems_, _aPaths_ ])

		return _aResult_

		#< @FunctionAlternativeFroms

		def ItemsBetweenPathsZZ(paPath1, paPath2)
			return This.PathsSectionZZ(paPath1, paPath2)

		def ItemsFromPathToPathZZ(paPath1, paPath2)
			return This.PathsSectionZZ(paPath1, paPath2)

		def PathsSectionZ(paPath1, paPath2)
			return This.PathsSectionZZ(paPath1, paPath2)

		def ItemsFromPathToPathZ(paPath1, paPath2)
			return This.PathsSectionZZ(paPath1, paPath2)

		#>

	#-- COMMON PATH

	def CommonPath()
		_aResult_ = @CommonPath(This.Paths())
		return _aResult_

		def PathsIntersection()
			return This.CommonPath()

	def ItemsAtCommonPath()
		_aResult_ = This.ItemsAtPath( This.CommonPath() )
		return _aResult_

		def ItemsAtPathsIntersection()
			return This.ItemsAtCommonPath()

	def IsTree()
		_aTemp_ = This.CommonPath()
		_nLen_ = len(_aTemp_)

		if _nLen_ = 1 and _aTemp_[1] = 1
			return TRUE
		else
			return FALSE
		ok

		def IsATree()
			return IsTree()

	#-- NTH ITEM(S) OVER A GIVEN PATH

	def NumberOfItemsInPath(paPath)

		_aPaths_ = This.PathsInPath(paPath)
		_nResult_ = len(_aPaths_)

		return _nResult_

		#< @FunctionAlternativeForms

		def HowManyItemsInPath(paPath)
			return This.NumberOfItemsInPath(paPath)

		def CountItmesInPath(paPath)
			return This.NumberOfItemsInPath(paPath)

		#>

	def ItemsInPath(paPath)

		_aResult_ = []
		_aPaths_ = This.PathsInPath(paPath)
		_nLenPaths_ = len(_aPaths_)

		_aResult_ = []

		for @i = 1 to _nLenPaths_
			 _aResult_ + This.ItemAtPath(_aPaths_[@i])
		next

		return _aResult_

		#< @FunctionFluentForm

		def ItemsInPathQ(paPath)
			return new stzList(This.ItemsInPath(paPath))

		#>

	def ItemsInPathZZ(paPath)
		_aItems_ = This.ItemsInPath(paPath)
		_aPaths_ = This.PathsInPath(paPath)

		_aResult_ = @Association([ _aItems_, _aPaths_ ])
		return _aResult_

	#-- NTH PATH(S) OVER A GIVEN PATH

	def NthPathInPath(n, paPath)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok
	
		_aPaths_ = This.PathsInPath(paPath)
		_aResult_ = _aPaths_[n]
		return _aResult_
	
		#< @FunctionFluentForm

		def NthPathInPathQ(n, paPath)
			return new stzList(This.NthPathInPath(n, paPath))

		#>

	func NthPathsInPath(panPos, paPath)
		if CheckParams()
			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
		ok
	
		_aPaths_ = This.PathsInPath(paPath)
		_nLenPos_ = len(panPos)
	
		_aResult_ = []
	
		for @i = 1 to _nLenPos_
			_aResult_ + _aPaths_[panPos[@i]]
		next
	
		return _aResult_

		#< @FunctionFluentForm

		def NthPathsInPathQ(panPos, paPath)
			return new stzList(This.NthPathsInPath(panPos, paPath))

		#>

	def PathsInPath(paPath)
		_oPaths_ = new stzList( This.Paths() )
		_nPos_ = _oPaths_.FindFirst(paPath)
	
		if _nPos_ = 0
			return []
		ok
	
		_aResult_ = _oPaths_.Section(1, _nPos_)
		return _aResult_

		#< @FunctionFluentForm

		def PathsInPathQ(paPath)
			return new stzList( This.PathsInPath(paPath) )

		#>

	def PathsInPaths(paPaths)
		if NOT These.AreValidPaths(paPaths)
			StzRaise("Can't proceed! paPaths is not a list of valid paths in the list.")
		ok

		_nLen_ = len(paPaths)
		_aResult_ = []

		for @i = 1 to _nLen_
			_aPaths_ = This.PathsIn(paPaths[@i])
			_nLenTemp_ = len(_aPaths_)

			for @j = 1 to  _nLenTemp_
				_aResult_ + _aPaths_[@j]
			next
		next

		return _aResult_


		def PathsInPathsQ(paPaths)
			return new stzList(This.PathsInPaths(paPaths))

	#-- NTH ITEM(S) OVER A GIVEN PATH

	def NthItemsInPath(panPos, paPath)

		if CheckParams()
	
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
	
	   		if NOT This.IsValidPath(paPath)
	        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
	    		ok
		ok

		_aResult_ = []
		_aPaths_ = This.PathsInPath(paPath)

		_nLenPos_ = len(panPos)

		_aResult_ = []

		for @i = 1 to _nLenPos_
			 _aResult_ + This.ItemAtPath(_aPaths_[panPos[@i]])
		next

		return _aResult_

		#< @FunctionFluentForm

		def NthItemsInPathQ(panPos, paPath)
			return new stzList(This.NthItemsInPath(panPos, paPath))

		#>

	def NthItemsInPathZZ(panPos, paPath)

		if CheckParams()
	
			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok
	
	   		if NOT This.IsValidPath(paPath)
	        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
	    		ok
		ok

		_aResult_ = []
		_aPaths_ = This.PathsInPath(paPath)

		_nLenPos_ = len(panPos)

		_aResult_ = []

		for @i = 1 to _nLenPos_
			 _aResult_ + [
				This.ItemAtPath(_aPaths_[panPos[@i]]),
				_aPaths_[panPos[@i]]
			]
		next

		return _aResult_

	def NthItemInPath(n, paPath)

		if CheckParams()

			if isList(n) and isNumb(paPath)
				_temp_ = n
				n = paPath
				paPath_ = _temp_
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
	   		if NOT This.IsValidPath(paPath)
	        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
	    		ok
		ok

		_aResult_ = []
		_aPaths_ = This.PathsInPath(paPath)
		_nLenPaths_ = len(_aPaths_)

		if n < 1 or n > _nLenPaths_
			StzRaise("Incorrect param value! n must be within the size of the path.")
		ok

		_result_ = This.ItemAtPath(_aPaths_[n])
		return _result_

		#< @FunctionFluentForm

		def NthItemInPathQ(n, paPath)
			return new stzList(This.NthItemInPath(n, paPath))

		#>

	def FirstItemInPath(paPath)
		return This.NthItemInPath(1, paPath)

		#< @FunctionFluentForm

		def FirstItemInPathQ(paPath)
			return new stzList(This.FirstItemInPath(paPath))

		#>

	def LastItemInPath(paPath)
		return This.NthItemInPath(len(paPath), paPath)

	#-- FINDING ITEM(S) AT PATH(S)

	def ItemExistsAtPathCS(pItem, paPath, pCaseSensitive)

		_aPath_ = This.FindItemAtPathCS(pItem, paPath, pCaseSensitive)

		if len(_aPath_) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

	func ItemExistsAtPath(pItem, paPath)
		return This.ItemExistsAtPathCS(pItem, paPath, _TRUE_)

	#--

	def FindItemAtPathCS(pItem, paPath, pCaseSensitive)

		_item_ = This.ItemAtPath(paPath)

		if NOT isList(_item_)
	 		if Q(_item_).IsEqualToCS(pItem, pCaseSensitive)
				return paPath
			else
				return []
			ok

		else # the item is a list

			_nLenPath_ = len(paPath)

			_anPos_ = StzListQ(_item_).FindCS(pItem, pCaseSensitive)
			_nLenPos_ = len(_anPos_)

			_aResult_ = []

			for @i = 1 to _nLenPos_
				_aPath_ = paPath
				_aPath_ +  _anPos_[@i]
				_aResult_ + _aPath_
			next

			return _aResult_
		ok

		#< @FunctionAlternativeForms

		def FindAtPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemAtPathCS(pItem, paPath, pCaseSensitive)

		def DeepFindItemAtPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemAtPathCS(pItem, paPath, pCaseSensitive)

		def DeepFindAtPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemAtPathCS(pItem, paPath, pCaseSensitive)

		#>

	def FindItemAtPath(pItem, paPath)
		return This.FindItemAtPathCS(pItem, paPath, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAtPath(pItem, paPath)
			return This.FindItemAtPath(pItem, paPath)

		def DeepFindItemAtPath(pItem, paPath)
			return This.FindItemAtPath(pItem, paPath)

		def DeepFindAtPath(pItem, paPath)
			return This.FindItemAtPath(pItem, paPath)

		#>

	#--

	def FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)
		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if NOT This.IsValidPath(paPath)
				StzRaise("Can't proceed! paPath is not a valid path of the list.")
			ok
		ok

		_aPaths_ = @PathsIn(paPath)
		_nLen_ = len(_aPaths_)

		_oListOfItems_ = new stzList(paItems)

		for @i = 1 to _nLen_
			if This.ItemAtPathQ(_aPaths_[@i]).ExistsInCS(paItems, pCaseSensitive)
				return _aPaths_[@i]
			ok
		next

		return []

		#< @FunctionAlternativeForms

		def FindItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def FindManyAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def FindManyItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def FindTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def FindAnyOfTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		#--

		def DeepFindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindManyAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindManyItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindAnyOfTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This.FindAnyItemsAtPathCS(paItems, paPath, pCaseSensitive)

		#>

	def FindAnyItemsAtPath(paItems, paPath)
		return This.FindItemsAtPathCS(paItems, paPath, _TRUE_)

		#< @FunctionAlternativeForms

		def FindItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def FindManyAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def FindManyItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def FindTheseItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def FindAnyOfTheseItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		#--

		def DeepFindAnyItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def DeepFindItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def DeepFindManyAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def DeepFindManyItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def DeepFindTheseItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		def DeepFindAnyOfTheseItemsAtPath(paItems, paPath)
			return This.FindAnyItemsAtPath(paItems, paPath)

		#>

	#--

	def FindItemAtPathsCS(pItem, paPaths, pCaseSensitive)

    		if NOT This.AreValidPaths(paPaths)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		_nLen_ = len(paPaths)

		_aResult_ = []

		for @i = 1 to _nLen_

			_aPaths_ = This.FindItemAtPathCS(pItem, paPaths[@i], pCaseSensitive)

			_nLenPaths_ = len(_aPaths_)

			for @j = 1 to _nLenPaths_
				_aResult_ + _aPaths_[@j]
			next

		next

		return U(_aResult_)

		#< @FunctionAlternativeForms

		def FindAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.FindItemAtPathsCS(pItem, paPaths, pCaseSensitive)

		#--

		def DeepFindItemAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.This.FindItemAtPathsCS(pItem, paPaths, pCaseSensitive)

		def DeepFindAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.FindItemAtPathsCS(pItem, paPaths, pCaseSensitive)

		#>

	def FindItemAtPaths(pItem, paPaths)
		return This.FindItemAtPathsCS(pItem, paPaths, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAtPaths(pItem, paPaths)
			return This.FindItemAtPaths(pItem, paPaths)

		#--

		def DeepFindItemAtPaths(pItem, paPaths)
			return This.This.FindItemAtPaths(pItem, paPaths)

		def DeepFindAtPaths(pItem, paPaths)
			return This.FindItemAtPaths(pItem, paPaths)

		#>

	#---

	def FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
    		if NOT This.AreValidPaths(paPaths)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		_nLen_ = len(paItems)

		_aResult_ = []

		for @i = 1 to _nLen_

			_aPaths_ = This.FindItemAtPathsCS(paItems[@i], paPaths, pCaseSensitive)

			_nLenPaths_ = len(_aPaths_)

			for @j = 1 to _nLenPaths_
				_aResult_ + _aPaths_[@j]
			next

		next

		return U(_aResult_)

		#< @FunctionAlternativeForms

		def FindManyItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		def FindTheseItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		#--

		def DeepFindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		def DeepFindManyItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		def DeepFindTheseItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		#>

	def FindItemsAtPaths(paItems, paPaths)
		return This.FindItemsAtPathsCS(paItems, paPaths, _TRUE_)

		
		#< @FunctionAlternativeForms

		def FindManyItemsAtPaths(paItems, paPaths)
			return This.FindItemsAtPaths(paItems, paPaths)

		def FindTheseItemsAtPaths(paItems, paPaths)
			return This.FindItemsAtPaths(paItems, paPaths)

		#--

		def DeepFindItemsAtPaths(paItems, paPaths)
			return This.FindItemsAtPaths(paItems, paPaths)

		def DeepFindManyItemsAtPaths(paItems, paPaths)
			return This.FindItemsAtPaths(paItems, paPaths)

		def DeepFindTheseItemsAtPaths(paItems, paPaths)
			return This.FindItemsAtPaths(paItems, paPaths)

		#>

	#-- EXPANDING AND COLLABSING PATHS

	def ExpandThisPath(paPath)
		_aPaths_ = This.Paths()
		_nLen_ = len(_aPaths_)
	
		_aResult_ = []
		_oPath_ = new stzList(paPath)
	
		for @i = 1 to _nLen_
	
			if @IsSubPathOf(paPath, _aPaths_[@i]) or
			   _oPath_.IsEqualTo(_aPaths_[@i])
	
				_aResult_ + _aPaths_[@i]
			ok
		next
	
		return _aResult_
	
		def ExpandPath(paPath)
			return This.ExpandThisPath(paPath)
	
		def PathExpanded(paPath)
			return This.ExpandThisPath(paPath)
	
	def ExpandPaths()
		return This.Paths()
	
		def ExpandAllPaths()
			return This.ExpandPaths()
	
		def PathsExpanded()
			return This.ExpandPaths()
	
		def AllPathsExpanded()
			return This.ExpandPaths()
	
	def ExpandThesePaths(paPaths)
	
		if NOT These.AreValidPaths(paPaths)
			StzRaise("Can't proceed! paPaths is not a list of valid paths in the list.")
		ok
	
		_aResult_ = []
		_nLen_ = len(paPaths)
	
		for @i = 1 to _nLen_
			_aTemp_ = This.ExpandPath(paPaths[@i])
			_nLenTemp_ = len(_aTemp_)
	
			for @j = 1 to _nLenTemp_
				_aResult_ + _aTemp_[@j]
			next
	
		next
	
		return _aResult_
	
		def ThesePathsExpanded()
			return This.ExpandThesePaths(paPaths)
		
	def CollabseThisPath(paPath)
		if NOT This.IsValidPath(paPath)
			StzRaise("Can't proceed! paPath must be a valid path in the list.")
		ok
	
		_aResult_ = [] + paPath[1]
		return _aResult_
	
		def CollabsePath(paPath)
			return This.CollabseThisPath(paPath)
	
		def PathCollabsed(paPath)
			return This.CollabseThisPath(paPath)
	
		def ThisPathCollabsed(paPath)
			return This.CollabseThisPath(paPath)
	
	def CollabsePaths()
		return This.ThesePathsCollabsed(This.Paths())
	
		def CollabseAllPaths()
			return This.CollabsePaths()
	
		def PathsCollabsed()
			return This.CollabsePaths()
	
		def AllPathsCollabsed()
			return This.CollabsePaths()
	
	def CollabseThesePaths(paPaths)
	
		if NOT These.AreValidPaths(paPaths)
			StzRaise("Can't proceed! paPaths is not a list of valid paths in the list.")
		ok
	
		_aResult_ = []
		_nLen_ = len(paPaths)
		_anSeen_ = []
	
		for @i = 1 to _nLen_
	
			_n_ = paPaths[@i][1]
	
			if ring_find(_anSeen_, _n_) = 0
				_aResult_ + [_n_]
				_anSeen_ + _n_
			ok
	
		next
	
		return _aResult_
	
		def ThesePathsCollabsed(paPaths)
			return This.CollabseThesePaths(paPaths)

	#-- CHECKING ITEM(S) EXISTENCE OVER PATH(S)

	def ItemExistsInPathCS(pItem, paPath, pCaseSensitive)

		_aPath_ = This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		if len(_aPath_) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsItemInPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemExistsInPathCS(pItem, paPath, pCaseSensitive)

	func ItemExistsInPath(pItem, paPath)
		return This.ItemExistsInPathCS(pItem, paPath, _TRUE_)

		def ContainsItemInPath(pItem, paPath)
			return This.ItemExistsInPath(pItem, paPath)

	#--

	def ItemExistsInAllNodesOfPathCS(pItem, paPath, pCaseSensitive)

		/* ... */ #TODO
		stzraise("Function not yet implemented!")

		def ContainsItemInAllNodesOfPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemExistsInAllNodesPathCS(pItem, paPath, pCaseSensitive)

	func ItemExistsInAllNodesOfPath(pItem, paPath)
		return This.ItemExistsInAllNodesOfPathCS(pItem, paPath, _TRUE_)

		def ContainsItemInAllNodesOfPath(pItem, paPath)
			return This.ItemExistsInAllNodesOfPath(pItem, paPath)

	#--

	def ItemExistsInPathsCS(pItem, paPaths, pCaseSensitive)

		_aPath_ = This.FindItemInPathsCS(pItem, paPaths, pCaseSensitive)

		if len(_aPath_) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsItemInPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemExistsInPathsCS(pItem, paPaths, pCaseSensitive)

	func ItemExistsInPaths(pItem, paPaths)
		return This.ItemExistsInPathsCS(pItem, paPaths, _TRUE_)

		def ContainsItemInPaths(pItem, paPaths)
			return This.ItemExistsInPaths(pItem, paPaths)

	#--

	def ItemExistsInAllNodesOfPathsCS(pItem, paPaths, pCaseSensitive)

		/* ... */ #TODO
		stzraise("Function not yet implemented!")

		def ContainsItemInAllNodesOfPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemExistsInAllNodesPathsCS(pItem, paPaths, pCaseSensitive)

	func ItemExistsInAllNodesOfPaths(pItem, paPath)
		return This.ItemExistsInAllNodesOfPathsCS(pItem, paPaths, _TRUE_)

		def ContainsItemInAllNodesOfPaths(pItem, paPaths)
			return This.ItemExistsInAllNodesOfPaths(pItem, paPaths)

	#--

	def ItemsExistInPathCS(paItems, paPath, pCaseSensitive)

		_aPath_ = This.FindItemsInPathCS(paItems, paPath, pCaseSensitive)

		if len(_aPath_) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsExistInPathCS(paItems, paPath, pCaseSensitive)

	func ItemsExistInPath(paItems, paPath)
		return This.ItemsExistInPathCS(paItems, paPath, _TRUE_)

		def ContainsItemsInPath(paItems, paPath)
			return This.ItemsExistInPath(paItems, paPath)

	#--

	def ItemsExistInPathsCS(paItems, paPaths, pCaseSensitive)

		_aPath_ = This.FindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		if len(_aPath_) > 0
			return _TRUE_
		else
			return _FALSE_
		ok

		def ContainsItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsExistInPathsCS(paItems, paPaths, pCaseSensitive)

	func ItemsExistInPaths(paItems, paPaths)
		return This.ItemsExistInPathsCS(paItems, paPaths, _TRUE_)

		def ContainsItemsInPaths(paItems, paPaths)
			return This.ItemsExistInPaths(paItems, paPaths)

	#-- FINDING ITEM(S) OVER PATH(S)

	def FindItemInPathCS(pItem, paPath, pCaseSensitive)

    		if NOT This.IsValidPath(paPath)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		_aItemsZZ_ = This.ItemsInPathZZ(paPath)
		_nLen_ = len(_aItemsZZ_)

		_oItem_ = Q(pItem)
		_aResult_ = []

		for @i = 1 to _nLen_
			if _oItem_.IsEqualToCS(_aItemsZZ_[@i][1], pCaseSensitive)
				_aResult_ + _aItemsZZ_[@i][2]
			ok
		next

		return _aResult_

		#< @FunctionAlternativeForms

		def FindInPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#--

		def FindItemUpToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		def FindUpToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#--

		def FindItemDownToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		def FindDownToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#==

		def DeepFindItemInPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		def DeepFindInPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#--

		def DeepFindItemUpToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		def DeepFindUpToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#--

		def DeepFindItemDownToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		def DeepFindDownToPathCS(pItem, paPath, pCaseSensitive)
			return This.FindItemInPathCS(pItem, paPath, pCaseSensitive)

		#>

	def FindItemInPath(pItem, paPath)
		return This.FindItemInPathCS(pItem, paPath, _TRUE_)

		#< @FunctionAlternativeForms

		def FindInPath(pItem, paPath)
			return This.FindItemInPath(pItem, paPath)

		#==

		def DeepFindItemInPath(pItem, paPath)
			return This.FindItemInPath(pItem, paPath)

		def DeepFindInPath(pItem, paPath)
			return This.FindItemInPath(pItem, paPath)

		#>

	#--

	def FindItemsInPathCS(paItems, paPath, pCaseSensitive)

    		if NOT This.IsValidPath(paPath)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		_aItemsZZ_ = This.ItemsInPathZZ(paPath)
		_nLen_ = len(_aItemsZZ_)

		_oItems_ = new stzList(paItems)
		_aResult_ = []

		for @i = 1 to _nLen_
			if _oItems_.ContainsCS(_aItemsZZ_[@i][1], pCaseSensitive)
				_aResult_ + _aItemsZZ_[@i][2]
			ok
		next

		return _aResult_


		#< @FunctionAlternativeForms

		def FindManyInPathCS(paItems, paPath, pCaseSensitive)
			return This.FindItemsInPathCS(paItems, paPath, pCaseSensitive)

		def FindManyItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This.FindItemsInPathCS(paItems, paPath, pCaseSensitive)

		def FindTheseItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This.FindItemsInPathCS(paItems, paPath, pCaseSensitive)

		#==

		def DeepFindManyInPathCS(paItems, paPath, pCaseSensitive)
			return This.DeepFindItemsInPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindManyItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This.DeepFindItemsInPathCS(paItems, paPath, pCaseSensitive)

		def DeepFindTheseItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This.DeepFindItemsInPathCS(paItems, paPath, pCaseSensitive)

		#>

	def FindItemsInPath(paItems, paPath)
		return This.FindItemsInPathCS(paItems, paPath, _TRUE_)

		#< @FunctionAlternativeForms

		def FindManyInPath(paItems, paPath)
			return This.FindItemsInPath(paItems, paPath)

		def FindManyItemsInPath(paItems, paPath)
			return This.FindItemsInPath(paItems, paPath)

		def FindTheseItemsInPath(paItems, paPath)
			return This.FindItemsInPath(paItems, paPath)

		#==

		def DeepFindManyInPath(paItems, paPath)
			return This.DeepFindItemsInPath(paItems, paPath)

		def DeepFindManyItemsInPath(paItems, paPath)
			return This.DeepFindItemsInPath(paItems, paPath)

		def DeepFindTheseItemsInPath(paItems, paPath)
			return This.DeepFindItemsInPath(paItems, paPath)

		#>

	#--

	def FindItemInPathsCS(pItem, paPaths, pCaseSensitive)
    		if NOT These.AreValidPaths(paPaths)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		_aResult_ = This.FindItemInPathCS(pItem, @DeepestPath(paPaths), pCaseSensitive)
		return _aResult_

		#< @FunctionAlternativeForms

		def FindInPathsCS(pItem, paPaths, pCaseSensitive)
			return This.FindItemInPathsCS(pItem, paPaths, pCaseSensitive)

		#==

		def DeepFindItemInPathsCS(pItem, paPaths, pCaseSensitive)
			return This.FindItemInPathsCS(pItem, paPaths, pCaseSensitive)

		def DeepFindInPathsCS(pItem, paPaths, pCaseSensitive)
			return This.FindItemInPathsCS(pItem, paPaths, pCaseSensitive)

		#>

	def FindItemInPaths(pItem, paPaths)
		return This.FindItemInPathsCS(pItem, paPaths, _TRUE_)

		#< @FunctionAlternativeForms

		def FindInPaths(pItem, paPaths)
			return This.FindItemInPaths(pItem, paPaths)

		#==

		def DeepFindItemInPaths(pItem, paPaths)
			return This.FindItemInPaths(pItem, paPaths)

		def DeepFindInPaths(pItem, paPaths)
			return This.FindItemInPaths(pItem, paPaths)

		#>

	#---

	def FindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

    		if NOT These.AreValidPaths(paPaths)
        		StzRaise("Incorrect param type! paPath must be a valid path in the list.")
    		ok

		return This.FindItemsInPathCS(paItems, @DeepestPath(paPaths), pCaseSensitive)


		#< @FunctionAlternativeForms

		def FindManyItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		def FindTheseItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.FindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		#==

		def DeepFindItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.DeepFindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		def DeepFindManyItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.DeepFindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		def DeepFindTheseItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.DeepFindItemsInPathsCS(paItems, paPaths, pCaseSensitive)

		#>

	def FindItemsInPaths(paItems, paPaths)
		return This.FindItemsInPathsCS(paItems, paPaths, _TRUE_)

		#< @FunctionAlternativeForms

		def FindManyItemsInPaths(paItems, paPaths)
			return This.FindItemsInPaths(paItems, paPaths)

		def FindTheseItemsInPaths(paItems, paPaths)
			return This.FindItemsInPaths(paItems, paPaths)

		#==

		def DeepFindItemsInPaths(paItems, paPaths)
			return This.DeepFindItemsInPaths(paItems, paPaths)

		def DeepFindManyItemsInPaths(paItems, paPaths)
			return This.DeepFindItemsInPaths(paItems, paPaths)

		def DeepFindTheseItemsInPaths(paItems, paPaths)
			return This.DeepFindItemsInPaths(paItems, paPaths)

		#>

	#-- REMOVING ITEMS OVER PATHS

	def RemoveItemInPathCS(pItem, paPath, pCaseSensitive)

		_aPaths_ = This.FindItemInPathCS(pItem, paPath, pCaseSensitive)
		This.RemoveItemAtPathsCS(pItem, _aPaths_, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveItemInPathCSQ(pItem, paPath, pCaseSensitive)
			This.RemoveInPathCS(pItem, paPath, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveInPathCS(pItem, paPath, pCaseSensitive)
			return This.RemoveItemInPathCS(pItem, paPath, pCaseSensitive)

			def RemoveInPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveInPathCSQ(pItem, paPath, pCaseSensitive)

		#--

		def DeepRemoveItemInPathCS(pItem, paPath, pCaseSensitive)
			return This.RemoveItemInPathCS(pItem, paPath, pCaseSensitive)

			def DeepRemoveItemInPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveInPathCSQ(pItem, paPath, pCaseSensitive)

		def DeepRemoveInPathCS(pItem, paPath, pCaseSensitive)
			return This.RemoveItemInPathCS(pItem, paPath, pCaseSensitive)

			def DeepRemoveInPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveInPathCSQ(pItem, paPath, pCaseSensitive)

		#>

	def ItemRemoveInPathCS(pItem, paPath, pCaseSensitive)
		_aResult_ = This.Copy().RemoveInPathCSQ(pItem, paPath, pCaseSensitive).Content()
		return _aResult_

		def RemovedInPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemoveInPathCS(pItem, paPath, pCaseSensitive)

		def ItemDeepRemovedInPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemoveInPathCS(pItem, paPath, pCaseSensitive)

		def DeepRemovedInPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemoveInPathCS(pItem, paPath, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemInPath(pItem, paPath)
		return This.RemoveItemInPathCS(pItem, paPath, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemInPathQ(pItem, paPath)
			This.RemoveInPath(pItem, paPath)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveInPath(pItem, paPath)
			return This.RemoveItemInPath(pItem, paPath)

			def RemoveInPathQ(pItem, paPath)
				return This.RemoveInPathQ(pItem, paPath)

		#--

		def DeepRemoveItemInPath(pItem, paPath)
			return This.RemoveItemInPath(pItem, paPath)

			def DeepRemoveItemInPathQ(pItem, paPath)
				return This.RemoveInPathQ(pItem, paPath)

		def DeepRemoveInPath(pItem, paPath)
			return This.RemoveItemInPath(pItem, paPath)

			def DeepRemoveInPathQ(pItem, paPath)
				return This.RemoveInPathQ(pItem, paPath)

		#>

	def ItemRemoveInPath(pItem, paPath)
		_aResult_ = This.Copy().RemoveInPathQ(pItem, paPath).Content()
		return _aResult_

		def RemovedInPath(pItem, paPath)
			return This.ItemRemoveInPath(pItem, paPath)

		def ItemDeepRemovedInPath(pItem, paPath)
			return This.ItemRemoveInPath(pItem, paPath)

		def DeepRemovedInPath(pItem, paPath)
			return This.ItemRemoveInPath(pItem, paPath)

	#==

	def RemoveItemsInPathCS(paItems, paPath, pCaseSensitive)

   		_aPaths_ = This.FindItemsInPathCS(paItems, paPath, pCaseSensitive)
		_aResult_ = This.RemoveItemsAtPaths(paItems, _aPaths_)

		#< @FunctionFluentForm

		def RemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive)
			This.RemoveItemsInPathCS(paItems, paPath, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveTheseItemsInPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsInPathCS(paItems, paPath, pCaseSensitive)

			def RemoveTheseItemsInPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive)

		#--

		def DeepRemoveItemsInPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsInPathCS(paItems, paPath, pCaseSensitive)

			def DeepRemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive)
 
		def DeepRemoveTheseItemsInPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsInPathCS(paItems, paPath, pCaseSensitive)

			def DeepRemoveTheseItemsInPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive)

		#>

	def ItemsRemoveInPathCS(paItems, paPath, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemsInPathCSQ(paItems, paPath, pCaseSensitive).Content()
		return _aResult_

		def TheseItemsRemovedInPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemoveInPathCS(paItems, paPath, pCaseSensitive)

		def TheseItemsDeepRemovedInPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemoveInPathCS(paItems, paPath, pCaseSensitive)

		def ItemsDeepRemovedInPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemoveInPathCS(paItems, paPath, pCaseSensitive)
 
	#-- WITHOUT CASESENSITIVITY

	def RemoveItemsInPath(paItems, paPath)
		return This.RemoveItemsInPathCS(paItems, paPath, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemsInPathQ(paItems, paPath)
			This.RemoveItemsInPath(paItems, paPath)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveTheseItemsInPath(paItems, paPath)
			This.RemoveItemsInPath(paItems, paPath)

			def RemoveTheseItemsInPathQ(paItems, paPath)
				return This.RemoveItemsInPathQ(paItems, paPath)

		#--

		def DeepRemoveItemsInPath(paItems, paPath)
			This.RemoveItemsInPath(paItems, paPath)

			def DeepRemoveItemsInPathQ(paItems, paPath)
				return This.RemoveItemsInPathQ(paItems, paPath)
 
		def DeepRemoveTheseItemsInPath(paItems, paPath)
			This.RemoveItemsInPath(paItems, paPath)

			def DeepRemoveTheseItemsInPathQ(paItems, paPath)
				return This.RemoveItemsInPathQ(paItems, paPath)

		#>

	def ItemsRemoveInPath(paItems, paPath)
		_aResult_ = This.Copy().RemoveItemsInPathQ(paItems, paPath).Content()
		return _aResult_

		def TheseItemsRemovedInPath(paItems, paPath)
			return This.ItemsRemoveInPath(paItems, paPath)

		def TheseItemsDeepRemovedInPath(paItems, paPath)
			return This.ItemsRemoveInPath(paItems, paPath)

		def ItemsDeepRemovedInPath(paItems, paPath)
			return This.ItemsRemoveInPath(paItems, paPath)
 
	#== REMOVING ITEM(S) AT GIVEN PATH(S)

	#~> //AT (and not IN) concerns the last item in the path
	# while IN concerns all the items of the path 

	def RemoveItemAtPathCS(pItem, paPath, pCaseSensitive)

		if NOT This.IsValidPath(paPath)
			StzRaise("Can't proceed! paPath is not a valid path in the list.")
		ok

		_aContent_ = This.Content()

		# Eraly check

		if len(paPath) = 1 and NOT isList(_aContent_[paPath[1]])
			del(_aContent_, paPath[1])
			This.UpdateWith(_aContent_)
			return
		ok


		_aPath_ = paPath
		if NOT isList(This.ItemAtPath(_aPath_))

			# Constructing the accessor of the inner list
	
			_cAccessor_ = "_aContent_["
			_nLenPath_ = len(_aPath_)
	
			for @i = 1 to _nLenPath_ - 1
				_cAccessor_ += '' + _aPath_[@i] + "]["
			next
	
			_cAccessor_ = StzStringQ(_cAccessor_).LastCharRemoved()
	
			# Evaluating the new value of the inner list after removal
	
			_cCode_ = 'del(' + _cAccessor_ + ', ' + _aPath_[_nLenPath_] + ')'
			eval(_cCode_)

			This.UpdateWith(_aContent_)

			return
		ok

		# Constructing the accessor of the inner list

		_cAccessor_ = "_aContent_["
		_nLenPath_ = len(_aPath_)

		for @i = 1 to _nLenPath_
			_cAccessor_ += '' + _aPath_[@i] + "]["
		next

		_cAccessor_ = StzStringQ(_cAccessor_).LastCharRemoved()

		# Evaluating the new value of the inner list after removal

		_cCode_ = '_aNewValue_ = Q(' + _cAccessor_ + ').
			  RemoveCSQ(pItem, pCaseSensitive).Content()'

		eval(_cCode_)

		# Evaluating the code doing the replacement of the old
		# value of the inner list by the new one

		_cCode_ = '

		_nTempLen_ = len(' + _cAccessor_ + ')
		for @i = _nTempLen_ to 1 step -1
			del(' + _cAccessor_ + ', @i)
		next

		_nTempLen_ = len(_aNewValue_)
		for @i=1 to _nTempLen_
			' + _cAccessor_ + ' + _aNewValue_[@i]
		next
		'

		eval(_cCode_)

		# Updating the list content

		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def RemoveItemAtPathCSQ(pItem, paPath, pCaseSensitive)
			This.RemoveItemAtPathCS(pItem, paPath, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForm

		def RemoveAtPathCS(pItem, paPath, pCaseSensitive)
			This.RemoveItemAtPathCS(pItem, paPath, pCaseSensitive)

			def RemoveAtPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveItemAtPathCSQ(pItem, paPath, pCaseSensitive)

		#--

		def DeepRemoveItemAtPathCS(pItem, paPath, pCaseSensitive)
			This.RemoveItemAtPathCS(pItem, paPath, pCaseSensitive)

			def DeepRemoveItemAtPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveItemAtPathCSQ(pItem, paPath, pCaseSensitive)

		def DeepRemoveAtPathCS(pItem, paPath, pCaseSensitive)
			This.RemoveItemAtPathCS(pItem, paPath, pCaseSensitive)

			def DeepRemoveAtPathCSQ(pItem, paPath, pCaseSensitive)
				return This.RemoveItemAtPathCSQ(pItem, paPath, pCaseSensitive)

		#>

	def ItemRemovedAtPathCS(pItem, paPath, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemAtPathCSQ(pItem, paPAth, pCaseSensitive).Content()
		return _aResult_

		def RemovedAtPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemovedAtPathCS(pItem, paPath, pCaseSensitive)

		def ItemDeepRemovedAtPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemovedAtPathCS(pItem, paPath, pCaseSensitive)

		def DeepRemovedAtPathCS(pItem, paPath, pCaseSensitive)
			return This.ItemRemovedAtPathCS(pItem, paPath, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemAtPath(pItem, paPath)
		This.RemoveItemAtPathCS(pItem, paPAth, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemAtPathQ(pItem, paPath)
			This.RemoveItemAtPath(pItem, paPath)
			return This
		#>

		#< @FunctionAlternativeForm

		def RemoveAtPath(pItem, paPath)
			This.RemoveItemAtPath(pItem, paPath)

			def RemoveAtPathQ(pItem, paPath)
				return This.RemoveItemAtPathQ(pItem, paPath)

		#--

		def DeepRemoveItemAtPath(pItem, paPath)
			This.RemoveItemAtPath(pItem, paPath)

			def DeepRemoveItemAtPathQ(pItem, paPath)
				return This.RemoveItemAtPathQ(pItem, paPath)

		def DeepRemoveAtPath(pItem, paPath)
			This.RemoveItemAtPath(pItem, paPath)

			def DeepRemoveAtPathQ(pItem, paPath)
				return This.RemoveItemAtPathQ(pItem, paPath)

		#>

	def ItemRemovedAtPath(pItem, paPath)
		_aResult_ = This.Copy().RemoveItemAtPathQ(pItem, paPAth).Content()
		return _aResult_

		def RemovedAtPath(pItem, paPath)
			return This.ItemRemovedAtPath(pItem, paPath)

		def ItemDeepRemovedAtPath(pItem, paPath)
			return This.ItemRemovedAtPath(pItem, paPath)

		def DeepRemovedAtPath(pItem, paPath)
			return This.ItemRemovedAtPath(pItem, paPath)

	#==

	def RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)
		if NOT This.IsValidPath(paPath)
			StzRaise("Can't proceed! paPath is not a valid path in the list.")
		ok

		_aContent_ = This.Content()

		# Constructing the accessor of the inner list

		_cAccessor_ = "_aContent_["
		_nLenPath_ = len(paPath)

		for @i = 1 to _nLenPath_
			_cAccessor_ += '' + paPath[@i] + "]["
		next

		_cAccessor_ = StzStringQ(_cAccessor_).LastCharRemoved()

		# Evaluating the new value of the inner list after removal

		_cCode_ = '_aNewValue_ = Q(' + _cAccessor_ +
			  ').RemoveManyCSQ(paItems, pCaseSensitive).Content()'

		eval(_cCode_)

		# Evaluating the code doing the replacement of the old
		# value of the inner list by the new one

		_cCode_ = '

		_nTempLen_ = len(' + _cAccessor_ + ')
		for @i = _nTempLen_ to 1 step -1
			del(' + _cAccessor_ + ', @i)
		next

		_nTempLen_ = len(_aNewValue_)
		for @i=1 to _nTempLen_
			' + _cAccessor_ + ' + _aNewValue_[@i]
		next
		'

		eval(_cCode_)

		# Updating the list content

		This.UpdateWith(_aContent_)

		
		#< @FunctionFluentForm

		def RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveManyAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPaths, pCaseSensitive)

			def RemoveManyAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def RemoveManyItemsAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def RemoveManyItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def RemoveTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def RemoveTheseItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def RemoveTheseAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def RemoveTheseAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		#==

		def DeepRemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def DeepRemoveManyAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveManyAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def DeepRemoveManyItemsAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def DeepRemoveManyItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def DeepRemoveTheseItemsAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def DeepRemoveTheseItemsAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		def DeepRemoveTheseAtPathCS(paItems, paPath, pCaseSensitive)
			This.RemoveItemsAtPathCS(paItems, paPath, pCaseSensitive)

			def DeepRemoveTheseAtPathCSQ(paItems, paPath, pCaseSensitive)
				return This.RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive)

		#>

	def ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemsAtPathCSQ(paItems, paPath, pCaseSensitive).Content()
		return _aResult_

		#< @FunctionAlternativeForms

		def ManyRemovedAtPathCs(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def ManyItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def TheseItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def TheseRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		#==

		def ItemsDeepRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def ManyDeepRemovedAtPathCs(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def ManyItemsDeepRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def TheseItemsDeepRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		def TheseDeepRemovedAtPathCS(paItems, paPath, pCaseSensitive)
			return This.ItemsRemovedAtPathCS(paItems, paPath, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSItiviTY

	def RemoveItemsAtPath(paItems, paPath)
		This.RemoveItemsAtPathCS(paItems, paPath, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemsAtPathQ(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveManyAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPaths)

			def RemoveManyAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def RemoveManyItemsAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def RemoveManyItemsAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def RemoveTheseItemsAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def RemoveTheseItemsAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def RemoveTheseAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def RemoveTheseAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		#==

		def DeepRemoveItemsAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPaths)

			def DeepRemoveItemsAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def DeepRemoveManyAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPaths)

			def DeepRemoveManyAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def DeepRemoveManyItemsAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def DeepRemoveManyItemsAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def DeepRemoveTheseItemsAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def DeepRemoveTheseItemsAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		def DeepRemoveTheseAtPath(paItems, paPath)
			This.RemoveItemsAtPath(paItems, paPath)

			def DeepRemoveTheseAtPathQ(paItems, paPath)
				return This.RemoveItemsAtPathQ(paItems, paPath)

		#>

	def ItemsRemovedAtPath(paItems, paPath)
		_aResult_ = This.Copy().RemoveItemsAtPathCSQ(paItems, paPath).Content()
		return _aResult_

		#< @FunctionAlternativeForms

		def ManyRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def ManyItemsRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def TheseItemsRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def TheseRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		#==

		def ItemsDeepRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def ManyDeepRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def ManyItemsDeepRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def TheseItemsDeepRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		def TheseDeepRemovedAtPath(paItems, paPath)
			return This.ItemsRemovedAtPath(paItems, paPath)

		#>

	#==

	def RemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)
		if NOT These.AreValidPaths(paPaths)
			StzRaise("Can't proceed! paPaths is not a valid list of paths in the list.")
		ok

		_aPaths_ = @SortPaths(paPaths)
		_nLenPaths_ = len(_aPaths_)

		_oCopy_ = This.Copy()

		for @i = _nLenPaths_ to 1 step -1
			_oCopy_.RemoveItemAtPathCS(pItem, _aPaths_[@i], pCaseSensitive)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive)
			This.RemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForm

		def RemoveAtPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)

			def RemoveAtPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive)

		#--

		def DeepRemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)

			def DeepRemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive)

		def DeepRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemAtPathsCS(pItem, paPaths, pCaseSensitive)

			def DeepRemoveAtPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive)

		#>

	def ItemRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemAtPathsCSQ(pItem, paPaths, pCaseSensitive).Content()
		return _aResult_

		def RemovedAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)

		def DeepItemRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)

		def DeepRemovedAtPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveAtPathsCS(pItem, paPaths, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def RemoveItemAtPaths(pItem, paPaths)
		This.RemoveItemAtPathsCS(pItem, paPaths, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemAtPathsQ(pItem, paPaths)
			This.RemoveItemAtPaths(pItem, paPaths)
			return This
		#>

		#< @FunctionAlternativeForm

		def RemoveAtPaths(pItem, paPaths)
			This.RemoveItemAtPaths(pItem, paPaths)

			def RemoveAtPathsQ(pItem, paPaths)
				return This.RemoveItemAtPathsQ(pItem, paPaths)

		#--

		def DeepRemoveItemAtPaths(pItem, paPaths)
			This.RemoveItemAtPaths(pItem, paPaths)

			def DeepRemoveItemAtPathsQ(pItem, paPaths)
				return This.RemoveItemAtPathsQ(pItem, paPaths)

		def DeepRemoveAtPaths(pItem, paPaths)
			This.RemoveItemAtPaths(pItem, paPaths)

			def DeepRemoveAtPathsQ(pItem, paPaths)
				return This.RemoveItemAtPathsQ(pItem, paPaths)

		#>

	def ItemRemoveAtPaths(pItem, paPaths)
		_aResult_ = This.Copy().RemoveItemAtPathsQ(pItem, paPaths).Content()
		return _aResult_

		def RemovedAtPaths(pItem, paPaths)
			return This.ItemRemoveAtPaths(pItem, paPaths)

		def DeepItemRemoveAtPaths(pItem, paPaths)
			return This.ItemRemoveAtPaths(pItem, paPaths)

		def DeepRemovedAtPaths(pItem, paPaths)
			return This.ItemRemoveAtPaths(pItem, paPaths)

	#==

	def RemoveItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
	
			if NOT These.AreValidPaths(paPaths)
				StzRaise("Can't proceed! paPaths is not a valid list of paths in the list.")
			ok
		ok

		_nLen_ = len(paItems)
		_oCopy_ = This.Copy()

		for @i = 1 to _nLen_
			_oCopy_.RemoveItemAtPathsCS(paItems[@i], paPaths, pCaseSensitive)
		next

		This.UpdateWith(_oCopy_.Content())

		#< @FunctionFluentForm

		def RemoveItemsAtPathsCSQ(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def DeepRemoveItemsAtPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsAtPathsCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveItemsAtPathsCSQ(paItems, paPaths, pCaseSensitive)
				This.RemoveItemsAtPathsCSQ(paItems, paPaths, pCaseSensitive)

		#>

	def ItemsRemoveAtPathsCS(paItems, paPaths, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemsAtPathsCSQ(paItems, paPaths, pCaseSensitive).Content()
		return _aResult_

		def ItemsDeepRemovedAtPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveAtPathsCS(paItems, paPaths, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemsAtPaths(paItems, paPaths)
		This.RemoveItemsAtPathsCS(paItems, paPaths, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemsAtPathsQ(paItems, paPaths)
			This.RemoveItemsAtPaths(paItems, paPaths)
			return This

		#>

		#< @FunctionAlternativeForm

		def DeepRemoveItemsAtPaths(paItems, paPaths)
			This.RemoveItemsAtPaths(paItems, paPaths)

			def DeepRemoveItemsAtPathsQ(paItems, paPaths)
				This.RemoveItemsAtPathsQ(paItems, paPaths)

		#>

	def ItemsRemoveAtPaths(paItems, paPaths)
		_aResult_ = This.Copy().RemoveItemsAtPathsQ(paItems, paPaths).Content()
		return _aResult_

		def ItemsDeepRemovedAtPaths(paItems, paPaths)
			return This.ItemsRemoveAtPathsCS(paItems, paPaths)

	#==

	def RemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)

   		_aPaths_ = This.FindItemInPathsCS(pItem, paPaths, pCaseSensitive)
		_aResult_ = This.RemoveItemsAtPaths(_aPaths_)

		#< @FunctionFluentForm

		def RemoveItemInPathsCSQ(pItem, paPaths, pCaseSensitive)
			This.RemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def DeepRemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)

			def DeepRemoveItemInPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemInPathsCSQ(pItem, paPaths, pCaseSensitive)

		def RemoveItemUpToPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)

			def RemoveItemUpToPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemInPathsCSQ(pItem, paPaths, pCaseSensitive)

		def DeepRemoveItemUpToPathsCS(pItem, paPaths, pCaseSensitive)
			This.RemoveItemInPathsCS(pItem, paPaths, pCaseSensitive)

			def DeepRemoveItemUpToPathsCSQ(pItem, paPaths, pCaseSensitive)
				return This.RemoveItemInPathsCSQ(pItem, paPaths, pCaseSensitive)

		#>

	def ItemRemoveInPathsCS(pItem, paPaths, pCaseSensitive)
		_aResult_ = This.Copy().RemoveInPathsCSQ(pItem, paPaths, pCaseSensitive).Content()
		return _aResult_

		def ItemDeepRemovedInPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveInPathsCS(pItem, paPaths, pCaseSensitive)

		def ItemDeepRemovedUpToPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveInPathsCS(pItem, paPaths, pCaseSensitive)

		def ItemRemoveUpToPathsCS(pItem, paPaths, pCaseSensitive)
			return This.ItemRemoveInPathsCS(pItem, paPaths, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemInPaths(pItem, paPaths)
		return This.RemoveItemInPathCS(pItem, paPaths, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemInPathsQ(pItem, paPaths)
			This.RemoveItemInPaths(pItem, paPaths)
			return This

		#>

		#< @FunctionAlternativeForms

		def DeepRemoveItemInPaths(pItem, paPaths)
			This.RemoveItemInPaths(pItem, paPaths)

			def DeepRemoveItemInPathsQ(pItem, paPaths)
				return This.RemoveItemInPathsQ(pItem, paPaths)

		def RemoveItemUpToPaths(pItem, paPaths)
			This.RemoveItemInPaths(pItem, paPaths)

			def RemoveItemUpToPathsQ(pItem, paPaths)
				return This.RemoveItemInPathsQ(pItem, paPaths)

		def DeepRemoveItemUpToPaths(pItem, paPaths)
			This.RemoveItemInPaths(pItem, paPaths)

			def DeepRemoveItemUpToPathsQ(pItem, paPaths)
				return This.RemoveItemInPathsQ(pItem, paPaths)

		#>

	def ItemRemoveInPaths(pItem, paPaths)
		_aResult_ = This.Copy().RemoveInPathsQ(pItem, paPaths).Content()
		return _aResult_

		def ItemDeepRemovedInPaths(pItem, paPaths)
			return This.ItemRemoveInPaths(pItem, paPaths)

		def ItemDeepRemovedUpToPaths(pItem, paPaths)
			return This.ItemRemoveInPaths(pItem, paPaths)

		def ItemRemoveUpToPaths(pItem, paPaths)
			return This.ItemRemoveInPaths(pItem, paPaths)

	#==

	def RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

   		_aPaths_ = This.FindItemsInPathsCS(paItems, paPaths, pCaseSensitive)
		_aResult_ = This.RemoveItemsAtPaths(_aPaths_)

		#< @FunctionFluentForm

		def RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveTheseItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def RemoveTheseItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		#--

		def DeepRemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		def DeepRemoveTheseItemsInPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveTheseItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		#==

		def RemoveItemsUpToPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def RemoveItemsUpToPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		def RemoveTheseItemsUpToPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def RemoveTheseItemsUpToPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		#--

		def DeepRemoveItemsUpToPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveItemsUpToPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		def DeepRemoveTheseItemsUpToPathsCS(paItems, paPaths, pCaseSensitive)
			This.RemoveItemsInPathsCS(paItems, paPaths, pCaseSensitive)

			def DeepRemoveTheseItemsUpToPathsCSQ(paItems, paPaths, pCaseSensitive)
				return This.RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive)

		#>

	def ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)
		_aResult_ = This.Copy().RemoveItemsInPathsCSQ(paItems, paPaths, pCaseSensitive).Content()
		return _aResult_

		#< @FunctionAlternativeForms

		def TheseItemsRemovedInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		def ItemsDeepRemovedInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		def TheseItemsDeepRemovedInPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		#--

		def ItemsRemoveUpToPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		def TheseItemsRemovedUpToPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		def ItemsDeepRemovedUpToPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		def TheseItemsDeepRemovedUpToPathsCS(paItems, paPaths, pCaseSensitive)
			return This.ItemsRemoveInPathsCS(paItems, paPaths, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemsInPaths(paItems, paPaths)
		return This.RemoveItemsInPathCS(paItems, paPaths, _TRUE_)

		#< @FunctionFluentForm

		def RemoveItemsInPathsQ(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveTheseItemsInPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def RemoveTheseItemsInPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		#--

		def DeepRemoveItemsInPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def DeepRemoveItemsInPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		def DeepRemoveTheseItemsInPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def DeepRemoveTheseItemsInPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		#==

		def RemoveItemsUpToPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def RemoveItemsUpToPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		def RemoveTheseItemsUpToPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def RemoveTheseItemsUpToPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		#--

		def DeepRemoveItemsUpToPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def DeepRemoveItemsUpToPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		def DeepRemoveTheseItemsUpToPaths(paItems, paPaths)
			This.RemoveItemsInPaths(paItems, paPaths)

			def DeepRemoveTheseItemsUpToPathsQ(paItems, paPaths)
				return This.RemoveItemsInPathsQ(paItems, paPaths)

		#>


	def ItemsRemoveInPaths(paItems, paPaths)
		_aResult_ = This.Copy().RemoveItemsInPathsQ(paItems, paPaths).Content()
		return _aResult_

		#< @FunctionAlternativeForms

		def TheseItemsRemovedInPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		def ItemsDeepRemovedInPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		def TheseItemsDeepRemovedInPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		#--

		def ItemsRemoveUpToPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		def TheseItemsRemovedUpToPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		def ItemsDeepRemovedUpToPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		def TheseItemsDeepRemovedUpToPaths(paItems, paPaths)
			return This.ItemsRemoveInPaths(paItems, paPaths)

		#>

	#== #TODO

	def PathsContainingItem(pItem)
		stzraise("Function not implemented yet!")

	def PathsContainingItems(paItems)
		stzraise("Function not implemented yet!")

	def PathsContaining(pItemOrItems)
		stzraise("Function not implemented yet!")

	#-- #TODO

	def Depths()
		stzraise("Function not implemented yet!")

		def Levels()
			return Depths()

	def NumberOfDepths()
		stzraise("Function not implemented yet!")

		
		def HowManyDepths()
			return This.NumberOfDepths()

		def CountDepths()
			return This.NumberOfDepths()

		def NumberOfLevels()
			return This.NumberOfDepths()

		def CountLevels()
			return This.NumberOfDepths()

		def HowManyLevels()
			return This.NumberOfDepths()

	def PathsAtDepth(pnDepth)
		if CheckParams()
			if NOT isNumber(pnDepth)
				StzRaise("Incorrect param type! pnDepth must be a number.")
			ok
		ok

    		_aAllPaths_ = This.AllPaths()
    		_nLen_ = len(_aAllPaths_)
		_aResult_ = []

    		for @i = 1 to _nLen_
        		if len(_aAllPaths_[@i]) = pnDepth
            			_aResult_ + _aAllPaths_[@i]
       			 ok
    		next

    		return _aResult_

		#< @FunctionAlternativeForms

		def FindItemsAtDepth(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtDepth(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def FindItemsAtDepthZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def FindItemsAtDepthZZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtDepthZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtDepthZZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		#--

		def PathsAtLevel(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def FindItemsAtLevel(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtLevel(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def FindItemsAtLevelZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def FindItemsAtLevelZZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtLevelZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		def DeepFindItemsAtLevelZZ(pnDepth)
			return This.PathsAtDepth(pnDepth)

		#>

	def ItemsAtDepth(pnDepth)
		_aResult_ = This.ItemsAtPaths( This.PathsAtDepth(pnDepth) )
		return _aResult_

		def ItemsAtLevel(pnDepth)
			return This.ItemsAtDepth(pnDepth)

	def ItemsAtDepthZZ(pnDepth)
		_aResult_ = This.ItemsAtPathsZZ( This.PathsAtDepth(pnDepth) )
		return _aResult_

		def ItemsAtDepthZ(pnDepth)
			return This.ItemsAtDepthZZ(pnDepth)

		def ItemsAtLevelZZ(pnDepth)
			return This.ItemsAtDepthZZ(pnDepth)

		def ItemsAtLevelZ(pnDepth)
			return This.ItemsAtDepthZZ(pnDepth)

	def ReplaceItemsAtDepth(pnDepth, pNewItem) #TODO
		stzraise("Function not implemented yet!")

		def ReplaceItemsAtLevel(pnDepth, pNewItem)
			This.ReplaceItemsAtDepth(pnDepth, pNewItem)

	def ReplaceItemsAtDepthByMany(pnDepth, paNewItems) #TODO
		stzraise("Function not implemented yet!")

		def ReplaceItemsAtLevelByMany(pnDepth, paNewItems)
			This.ReplaceItemsAtDepthByMany(pnDepth, paNewItems)

	def ReplaceItemsAtDepthByManyXT(pnDepth, paNewItems) #TODO
		stzraise("Function not implemented yet!")

		def ReplaceItemsAtLevelByManyXT(pnDepth, paNewItems)
			This.ReplaceItemsAtDepthByManyXT(pnDepth, paNewItems)

	def RemoveItemsAtDepth(pnDepth) #TODO
		stzraise("Function not implemented yet!")

		def RemoveItemsAtLevel(pnDepth)
			This.RemoveItemsAtDepth(pnDepth)

	#--

	def IsPath(paPath)
		if NOT isList(paPath)
			return _FALSE_
		ok

		if NOT @IsListOfNumbers(paPath)
			return _FALSE_
		ok

		_bResult_ = This.PathsQ().Contains(paPath)
		return _bResult_

		def IsAPath(paPath)
			return This.IsPath(paPath)

		def IsValidPath(paPath)
			return This.IsPath(paPath)

		def IsAValidPath(paPath)
			return This.IsPath(paPath)

		def ContainsPath(paPath)
			return This.IsPath(paPath)

		def PathExists(paPath)
			return This.IsPath(paPath)

	def ArePaths(paPaths)
		if NOT isList(paPaths)
			return _FALSE_
		ok

		if NOT @IsListOfListsOfNumbers(paPaths)
			return _FALSE_
		ok

		_bResult_ = _TRUE_
		_nLen_ = len(paPaths)

		for @i = 1 to _nLen_
			if NOT This.ContainsPath(paPaths[@i])
				_bResult_ = _FALSE_
				exit
			ok
		next

		return _bResult_

		#< @FunctionAlternativeForms

		def AreValidPaths(paPaths)
			return This.ArePaths(paPaths)

		def ContainsPaths(paPaths)
			return This.ArePaths(paPaths)

		def PathsExist(paPath)
			return This.ArePaths(paPaths)

		#--

		def IsListOfPaths(paPaths)
			return This.ArePaths(paPaths)

		def IsListOfValidPaths(paPaths)
			return This.ArePaths(paPaths)

		def IsValidListOfPaths(paPaths)
			return This.ArePaths(paPaths)

		#>

	#-- INSERTING ITEM #TODO

	def InsertAtNthPositionOfPath(pItem, paPath, pnPos)
		stzraise("Function not implemented yet!")

	def AddToPath(pItemOrItems, paPath)
		stzraise("Function not implemented yet!")

	def AddItemToPath(pItem, paPath)
		stzraise("Function not implemented yet!")

	def AddItemsToPath(pItem, paPath)
		stzraise("Function not implemented yet!")

	#--

	def InsertAtNthPositionOfPaths(pItem, paPaths, pnPos)
		stzraise("Function not implemented yet!")

	def AddToPaths(pItemOrItems, paPaths)
		stzraise("Function not implemented yet!")

	def AddItemToPaths(pItem, paPaths)
		stzraise("Function not implemented yet!")

	def AddItemsToPaths(pItem, paPaths)
		stzraise("Function not implemented yet!")

	#-- REPLACING ITEMS AT PATHS #TODO

	def ReplaceAtPath(pItemOrItems, pNewtItemOrItems, paPath)
		stzraise("Function not implemented yet!")

	def ReplaceItemAtPath(pItem, pNewItem, paPath)
		stzraise("Function not implemented yet!")

	def RepalceTheseItemsAtPath(pItems, pNewtItemOrItems, paPath)
		stzraise("Function not implemented yet!")

	#--

	def ReplaceAtPaths(pItemOrItems, pNewtItemOrItems, paPaths)
		stzraise("Function not implemented yet!")

	def ReplaceItemAtPaths(pItem, pNewItem, paPaths)
		stzraise("Function not implemented yet!")

	def RepalceTheseItemsAtPaths(paItems, pNewtItemOrItems, paPaths)
		stzraise("Function not implemented yet!")

	#-- REMOVING ITEMS AT PATHS

	#TODO

	#--

	def RemovePath(paPath)
		stzraise("Function not implemented yet!")

		def RemoveAllInPath(paPath)
			This.RemovePath(paPath)

		def RemoveAllItemsInPath(paPath)
			This.RemovePath(paPath)

	def RemovePaths(paPaths)
		stzraise("Function not implemented yet!")

		def RemoveAllInPaths(paPaths)
			This.RemovePaths(paPaths)

		def RemoveAllItemsInPaths(paPaths)
			This.RemovePaths(paPaths)


	  #=======================================================#
	 #    VISUALLY FINDING ALL OCCURRENCES OF A GIVEN ITEM   #
	#=======================================================#

	#NOTE // Works only if items are chars (string of 1 char each)
	#TODO // Implement a more general solution for longer items

	def VizFindAllOccurrencesCS(pItem, pCaseSensitive)
		if NOT @IsChar(pItem)
			StzRaise("Can't proceed! Only chars can currently be visualised in the output.")
		ok

		cResult = This.ToCodeQ().Simplified()
		anPos = Q(cResult).FindAllCS( @@(pItem), pCaseSensitive )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2
			
			if ring_find(anPos, i) > 0
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindAllOccurrencesCSQ(pItem, pCaseSensitive)
			return new stzString( This.VizFindAllOccurrencesCS(pItem, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def VizFindAllCS(pItem, pCaseSensitive)
			return This.VizFindAllOccurrencesCS(pItem, pCaseSensitive)

			def VizFindAllCSQ(pItem, pCaseSensitive)
				return new stzString(This.VizFindAllCS(pItem, pCaseSensitive))
	

		def VizFindCS(pItem, pCaseSensitive)
			return This.VizFindAllOccurrencesCS(pItem, pCaseSensitive)

			def VizFindCSQ(pItem, pCaseSensitive)
				return new stzString(This.VizFindCS(pItem, pCaseSensitive))
		#>

	#-- WITHOUT CASESENSITIVITY

	def VizFindAllOccurrences(pItem)
		return This.VizFindAllOccurrencesCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def VizFindAllOccurrencesQ(pItem)
			return new stzString( This.VizFindAllOccurrences(pItem) )

		#>

		#< @FunctionAlternativeForms

		def VizFindAll(pItem)
			return This.VizFindAllOccurrences(pItem)

			def VizFindAllQ(pItem)
				return new stzString(This.VizFindAll(pItem))
	

		def VizFind(pItem)
			return This.VizFindAllOccurrences(pItem)

			def VizFindQ(pItem)
				return new stzString(This.VizFind(pItem))
		#>

	  #==================================================================#
	 #  FINDING NEXT NTH ITEM IN THE LIST STARTING AT A GIVEN POSITION  #
	#==================================================================#

	def FindNextNthItemST(nth, nStart)

		if CheckingParams()

			if NOT isNumber(nth)
				StzRaise("Incorrect param type! nth must be a number.")
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isString(nStart)
				if nStart = :Start or nStart = :First or nStart = :FirstItem
					nStart = 1
	
				but nStart = :End or nStart = :Last or nStart = :LastItem
					nStart = len(@aContent)
				ok
			ok
	
			if NOT isNumber(nStart)
				StzRaise("Incorrect param type! nth must be a number.")
			ok

		ok

		_nResult_ = nth + nStart

		if _nResult_ > This.NumberOfItems() or _nResult_ < 1
			_nResult_ = 0
		ok

		return _nResult_


		#< @FunctionAlternativeForms

		def FindNextNthItem(nth, nStart)
			return This.FindNextNthItemST(nth, nStart)

		def FindNthNextItemST(nth, nStart)
			return This.FindNextNthItemST(nth, nStart)

		def FindNthNextItem(nth, nStart)
			return This.FindNextNthItemST(nth, nStart)

		#>

	  #------------------------------------------------------------------#
	 #  GETTING NEXT NTH ITEM IN THE LIST STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------#

	def NextNthItemST(nth, nStart)
		_nPos_ = This.FindNextNthItemST(nth, nStart)
		return @aContent[_nPos_]

		#< @FunctionFluentForm

		def NextNthItemSTQ(nth, nStart)
			return Q( This.NextNthItemST(nth, nStart) )

		#>

		#< @FunctionAlternativeForms

		def NextNthItem(nth, nStart)
			return This.NextNthItemST(nth, nStart)

			def NextNthItemQ(nth, nStart)
				return This.NextNthItemSTQ(nth, nStart)

		def NthNextItemST(nth, nStart)
			return This.NextNthItemST(nth, nStart)

			def NthNextItemSTQ(nth, nStart)
				return This.NextNthItemSTQ(nth, nStart)

		def NthNextItem(nth, nStart)
			return This.NextNthItemST(nth, nStart)

			def NthNextItemQ(nth, nStart)
				return This.NextNthItemSTQ(nth, nStart)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING PREVIOUS NTH ITEM IN THE LIST STARTING AT A GIVEN POSITION  #
	#======================================================================#

	def FindPreviousNthItemST(nth, nStart)

		if CheckingParams()

			if NOT isNumber(nth)
				StzRaise("Incorrect param type! nth must be a number.")
			ok
	
			if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isString(nStart)
				if nStart = :Start or nStart = :First or nStart = :FirstItem
					nStart = 1
	
				but nStart = :End or nStart = :Last or nStart = :LastItem
					nStart = len(@aContent)
				ok
			ok
	
			if NOT isNumber(nStart)
				StzRaise("Incorrect param type! nth must be a number.")
			ok

		ok

		_nResult_ = nStart - nth + 1

		if _nResult_ < 1 or _nResult_ > This.NumberOfItems()
			_nResult_ = 0
		ok

		return _nResult_


		#< @FunctionAlternativeForms

		def FindPreviousNthItem(nth, nStart)
			return This.FindPreviousNthItemST(nth, nStart)

		def FindNthPreviousItemST(nth, nStart)
			return This.FindPreviousNthItemST(nth, nStart)

		def FindNthPreviousItem(nth, nStart)
			return This.FindPreviousNthItemST(nth, nStart)

		#>

	  #----------------------------------------------------------------------#
	 #  GETTING PREVIOUS NTH ITEM IN THE LIST STARTING AT A GIVEN POSITION  #
	#----------------------------------------------------------------------#

	def PreviousNthItemST(nth, nStart)

		_nPos_ = This.FindPreviousNthItemST(nth, nStart)
		return @aContent[_nPos_]


		#< @FunctionFluentForm

		def PreviousNthItemSTQ(nth, nStart)
			return Q( This.PreviousNthItemST(nth, nStart) )

		#>

		#< @FunctionAlternativeForms

		def PreviousNthItem(nth, nStart)
			return This.PreviousNthItemST(nth, nStart)

			def PreviousNthItemQ(nth, nStart)
				return This.PreviousNthItemSTQ(nth, nStart)

		def NthPreviousItemST(nth, nStart)
			return This.PreviousNthItemST(nth, nStart)

			def NthPreviousItemSTQ(nth, nStart)
				return This.PreviousNthItemSTQ(nth, nStart)

		def NthPreviousItem(nth, nStart)
			return This.PreviousNthItemST(nth, nStart)

			def NthPreviousItemQ(nth, nStart)
				return This.PreviousNthItemSTQ(nth, nStart)

		#>

	   #=================================================#
	  #      FINDING NTH NEXT OCCURRENCE OF AN ITEM     #
	 #      STARTING AT A GIVEN POSITION               #
	#=================================================#

	def FindNthNextOccurrenceCS( n, pItem, pnStartingAt, pCaseSensitive )

		if CheckingParams()

			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

		ok

		# Trying to use the Ring native find() function first

		aTempContent = This.Content()
		nResult = @FindNthNextSTCS( aTempContent, n, pItem, pnStartingAt, pCaseSensitive )
		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NextNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthNextSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthNextOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NthNextOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NextNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthOccurrenceStartingAtCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthStartingAtCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pItem, nStart )
		return This.FindNthNextOccurrenceCS( n, pItem, nStart, _TRUE_ )

		#< @FunctionAlternativeForms

		def FindNextNthOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NthNextOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NextNthOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNth( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthNext( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#--

		def FindNthNextOccurrenceST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNthOccurrenceST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NthNextOccurrenceST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NextNthOccurrenceST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNthST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthNextST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#--

		def FindNthOccurrenceST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthOccurrenceStartingAt( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthST( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthStartingAt( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#>

	   #----------------------------------------------#
	  #  FINDING NTH PREVIOUS OCCURRENCE OF AN ITEM  #
	 #  STARTING AT A GIVEN POSITION                #
	#----------------------------------------------#

	def FindNthPreviousOccurrenceCS(n, pItem, nStart, pCaseSensitive)

		if CheckingParams()

			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isString(nStart) and ( nStart = :Last Or nStart = :LastItem )
				nStart = This.NumberOfItem()
			ok
	
			if isString(n)
	
				if n = :First Or n= :FirstOccurrence
					n = 1
	
				but n = :Last Or n = :LastOccurrence
					n = This.SectionQ(1, nStart).NumberOfOccurrenceCS(pItem, pCaseSensitive)
				ok
			ok
	
			if NOT ( isNumber(n) and isNumber(nStart) )
				StzRaise("Incorrect param type! n and nStart must be numbers.")
			ok

		ok

		# Early checks (gains performance for large lists)

		nLen = This.NumberOfItems()

		if EarlyChecks()
	
			if nStart = 1
				return 0
			ok

			if nStart < 0 or nStart > nLen
				return 0
			ok

			if NOT This.ContainsCS(pItem, pCaseSensitive)
				return 0
			ok
	
			if This.SectionQ(1, nStart - 1).
				NumberOfOccurrenceCS(pItem, pCaseSensitive) < n

				return  0
			ok

		ok

		# Full check (only occurrences of pItem are parsed, not every item)

		bCase = @CaseSensitive(pCaseSensitive)
		nPos = nStart - 1
		nFound = 0
		i = 0

		while _TRUE_
			i++
			if i > nLen
				exit
			ok

			nPos = This.FindPreviousCS(pItem, nPos, bCase)

			if nPos = 0
				exit
			else
				nFound++
				if nFound = n
					return nPos
				ok
			ok
		end

		return 0

		
		#< @FunctionAlternativeForms

		def FindPreviousNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def PreviousNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def NthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthPreviousCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthPreviousOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def PreviousNthOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def NthPreviousOccurrenceSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthPreviousSTCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence(n, pItem, nStart)
		return This.FindNthPreviousOccurrenceCS(n, pItem, nStart, _TRUE_)

		#< @FunctionAlternativeForms

		def FindPreviousNthOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def PreviousNthOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def NthPreviousOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNth( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindNthPrevious( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		#--

		def FindNthPreviousOccurrenceST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNthOccurrenceST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def PreviousNthOccurrenceST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def NthPreviousOccurrenceST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNthST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindNthPreviousST( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		#>

	   #---------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF AN ITEM     #
	 #      STARTING AT A GIVEN POSITION           #
	#---------------------------------------------#

	def FindNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ 1, 2, 3, "*", 5, 6, "*", 8, 9 ])
		? o1.FindNext("*", :StartingAt = 4)
		#--> 7

		*/

		if CheckingParams()

			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

		ok

		# Trying with a Ring-based solution first (efficient if the list is
		# made of strings or numbers and if the item is a string or number)

		aTempContent = This.Content()
		nResult = @FindNextCS(aTempContent, pItem, pnStartingAt, pCaseSensitive)

		if nResult != -1
			return nResult

		else
		# Otherwise we rely on an advanced Softanza solution, based on the
		# fact of stringifying the items of the list, and permitting the
		# finding of not only numbers and strings, but also lists and
		# named objects...

			nResult = This.SectionQ(pnStartingAt + 1, :Last).
				FindFirstCS(pItem, pCaseSensitive)
	
			if nResult != 0
				nResult += pnStartingAt
			ok

			return nResult
		ok

		#< @FunctionAlternativeForms

		def FindNextSTCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		def NextOccurrenceCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		#--

		def FindNextOccurrenceSTCS(pItem, nStart, pCaseSensitive)
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		def NextOccurrenceSTCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pItem, nStart)
		nResult = This.FindNextOccurrenceCS(pItem, nStart, _TRUE_)
		return nResult

		#< @FunctionAlternativeForms

		def FindNext( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		def NextOccurrence( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		#--

		def FindNextOccurrenceST(pItem, nStart)
			return This.FindNextOccurrence(pItem, nStart)

		def FindNextST( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		def NextOccurrenceST( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		#>

	   #-------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF AN ITEM     #
	 #      STARTING FROM A GIVEN POSITION N           #
	#-------------------------------------------------#

	def FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ 1, 2, 3, "*", 5, 6, "*", 8, 9 ])
		? o1.FindPrevious("*", :StartingAt = 7)
		#--> 7

		*/

		if CheckingParams()

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		if EarlyCheck()

			if NOT This.ContainsCS(pItem, pCaseSensitive)
				return 0
			ok

		ok

		nResult = This.SectionQ(1, pnStartingAt - 1).
			  FindLastCS(pItem, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def FindPreviousCS( pItem, pnStartingAt, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		def PreviousOccurrenceCS( pItem, pnStartingAt, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousOccurrenceSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		def FindPreviousSTCS( pItem, pnStartingAt, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		def PreviousOccurrenceSTCS( pItem, pnStartingAt, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		#==

		def FindPreviousItemCS(pITem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		def FindPreviousItemSTCS(pITem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pItem, pnStartingAt)
		return This.FindPreviousOccurrenceCS(pItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def FindPrevious( pItem, pnStartingAt )
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		def PreviousOccurrence( pItem, pnStartingAt )
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		#--

		def FindPreviousOccurrenceST(pItem, pnStartingAt)
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		def FindPreviousST( pItem, pnStartingAt )
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		def PreviousOccurrenceST( pItem, pnStartingAt )
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		#==

		def FindPreviousItem(pITem, pnStartingAt)
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		def FindPreviousItemST(pITem, pnStartingAt)
			return This.FindPreviousOccurrence(pItem, pnStartingAt)

		#>

	   #-----------------------------------------#
	  #   FINDING NEXT OCCURRENCES OF AN ITEM   #
	 #   STARTING AT A GIVEN POSITION          #
	#-----------------------------------------#

	def FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		if CheckingParams()

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if isString(pnStartingAt)
				if ring_find([ :First, :FirstItem ], pnStartingAt) > 0
	
					pnStartingAt = 1
				
				but ring_find([ :Last, :LastItem ], pnStartingAt) > 0
	
					pnStartingAt = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param! pnStartingAt must be a number.")
			ok

		ok

		oSection = This.SectionQ(pnStartingAt+1, This.NumberOfItems())
		anPos = oSection.FindAllCS(pItem, pCaseSensitive)

		nLen = len(anPos)

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] + pnStartingAt )
		next

		return anResult

		#< @FunctionAlternativeForms

		def NextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindNextOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		def NextOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrences(pItem, pnStartingAt)
		return This.FindNextOccurrencesCS(pItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def NextOccurrences(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		#--

		def FindNextOccurrencesST(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		def NextOccurrencesST(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		#>

	   #---------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF AN ITEM   #
	 #   STARTING AT A GIVEN POSITION              #
	#---------------------------------------------#

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckingParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if isString(pnStartingAt)

				if ring_find([ :First, :FirstItem ], pnStartingAt) > 0
	
					pnStartingAt = 1
				
				but ring_find([ :Last, :LastItem ], pnStartingAt) > 0
	
					pnStartingAt = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param! pnStartingAt must be a number.")
			ok

		ok

		oSection = This.SectionQ(1, pnStartingAt-1)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPos

		#< @FunctionAlternativeForm

		def PreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		def PreviousOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForm

		def PreviousOccurrences(pItem, pnStartingAt)
			return This.FindPreviousOccurrences(pItem, pnStartingAt)

		#--

		def FindPreviousOccurrencesST(pItem, pnStartingAt)
			return This.FindPreviousOccurrences(pItem, pnStartingAt)

		def PreviousOccurrencesST(pItem, pnStartingAt)
			return This.FindPreviousOccurrences(pItem, pnStartingAt)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING NEXT NTH OCCURRENCES OF AN ITEM STARTING AT A GIVEN POSITION  #
	#========================================================================#

	def FindNextNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		anAllPos = This.FindNextOccurrencesSTCS(pItem, pnStartingAt, pCaseSensitive)
		nLenPos = len(panPos)

		anResult = []

		for i = 1 to nLenPos
			anResult + anAllPos[panPos[i]]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindNthNextOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindNextNthOccurrencesSTCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		def FindNthNextOccurrencesSTCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthOccurrences(panPos, pItem, pnStartingAt)
		return This.FindNextNthOccurrencesCS(panPos, pItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthNextOccurrences(panPos, pItem, pnStartingAt)
			return This.FindNextNthOccurrences(panPos, pItem, pnStartingAt)

		#--

		def FindNextNthOccurrencesST(panPos, pItem, pnStartingAt)
			return This.FindNextNthOccurrences(panPos, pItem, pnStartingAt)

		def FindNthNextOccurrencesST(panPos, pItem, pnStartingAt)
			return This.FindNextNthOccurrences(panPos, pItem, pnStartingAt)
	
		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING PREVIOUS NTH OCCURRENCES OF AN ITEM STARTING AT A GIVEN POSITION  #
	#============================================================================#

	def FindPreviousNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		anAllPos = This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
		nLenPos = len(panPos)

		anResult = []

		for i = 1 to nLenPos
			anResult + anAllPos[panPos[i]]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindNthPreviousOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousNthOccurrencesSTCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)

		def FindNthPreviousOccurrencesSTCS(panPos, pItem, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthOccurrencesCS(panPos, pItem, pnStartingAt, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthOccurrences(panPos, pItem, pnStartingAt)
		return This.FindPreviousNthOccurrencesCS(panPos, pItem, pnStartingAt, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthPreviousOccurrences(panPos, pItem, pnStartingAt)
			return This.FindPreviousNthOccurrences(panPos, pItem, pnStartingAt)

		#--

		def FindPreviousNthOccurrencesST(panPos, pItem, pnStartingAt)
			return This.FindPreviousNthOccurrences(panPos, pItem, pnStartingAt)

		def FindNthPreviousOccurrencesST(panPos, pItem, pnStartingAt)
			return This.FindPreviousNthOccurrences(panPos, pItem, pnStartingAt)
	
		#>

	  #===================================================#
	 #   FINDING ALL ITEMS VERIFYING A GIVEN CONDITION   #
	#===================================================#

	def FindAllItemsWCS(pcCondition, pCaseSensitive)

		/*
		pcCondition can only contain the @i and This[@i...] keywords.
		@NextItem, @PreviousItem, @item ans so on can not be used.

		This is always the better option to take if you want a more
		performant code.

		If you want to be more expressive and include them in your
		pccondition string, use FindWXT() instead. 

		WARNING

		We can't use this solution:

			anPos = This.YieldW('@position', pcCondition)
			return anPos

		because YieldW() uses the current function FindW() --> Stackoverfolw!
		*/

		# 1) ~> Checking params

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		# 2) ~> Identifying the executable section

		nLen = len(@aContent)

		_oCode_ = new stzCCode(pcCondition)
		aExecutableSection = _oCode_.ExecutableSection()
		nStart = aExecutableSection[1]
		nEnd   = aExecutableSection[2]

		#WARNING // Very important check!
		# Read explanation in the stzCCode file --> ExectutableSection() method
		#TODO
		# check that this is done for all places where
		# ExecutableSection() is used in the library

		if isString(nEnd) and nEnd = :last
			nEnd = nLen
		ok

		if nEnd < 0
			nEnd += nLen
		but nEnd = :Last
			nEnd = nLen
		ok

		# 3) ~> Composing the code to be evaluated bu the loop

		#WARNING # Don't transpile conditional code in ..W() functions!
		# Only ...WXT() must contain Transpile() feature.
		# Therefore, the fellowing line is incorrect:

		# cCode = 'bOk = ( ' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		# And you should put simply:

		cCode = 'bOk = (' + _oCode_.Code() + ' )'

		# 4) ~>  Preparing the list for casesensitivity

		if @CaseSensitive(pCaseSensitive) = _TRUE_
			_oCopy_ = This.Copy()
		else
			_oCopy_ = This.Copy().LowercaseQ()
		ok

		cCode = StzStringQ(cCode).ReplaceCSQ("This", "_oCopy_", _FALSE_).Content()

		# 5) ~>  Doing the job

		anResult = []

		for @i = nStart to nEnd

			#WARNING
			# You don't need to use any sophisticated keywords
			# like @item = @aContent[@i], since the code is
			# supposed to contain only @ and This[@i]-like keywords

			eval(cCode)

			if bOk
				anResult + @i
			ok
		next

		return anResult
		
		#< @FunctionAlternativeForms

		def FindAllWCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def FindWCS(pCondition, pCaseSensitive)
			aResult = This.FindAllItemsWCS(pCondition, pCaseSensitive)
			return aResult

		def FindWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def FindAllWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def FindAllItemsWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def FindItemsWCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def FindItemsWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def ItemsPositionsWCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def ItemsPositionsWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def PositionsWCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def PositionsOfItemsWCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def PositionsWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

		def PositionsOfItemsWhereCS(pCondition, pCaseSensitive)
			return This.FindAllItemsWCS(pCondition, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllItemsW(pcCondition)
		return This.FindAllItemsWCS(pcCondition, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllW(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindW(pCondition)
			aResult = This.FindAllItemsW(pCondition)
			return aResult

		def FindWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindAllWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindAllItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindItemsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def ItemsPositionsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def ItemsPositionsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsOfItemsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsOfItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

	#>

	  #--------------------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#--------------------------------------------------------------#
	# Condditional code can contain keywords other then This[@i],
	# like @NextItem, @PreviousItem etc.

	def FindAllItemsWCSXT(pcCondition, pCaseSensitive)

		/*
		pcCondition can only contain the @i and This[@i...] keywords.
		@NextItem, @PreviousItem, @item ans so on can not be used.

		This is always the better option to take if you want a more
		performant code.

		If you want to be more expressive and include them in your
		pccondition string, use FindWXT() instead. 

		WARNING

		We can't use this solution:

			anPos = This.YieldW('@position', pcCondition)
			return anPos

		because YieldW() uses the current function FindW() --> Stackoverfolw!
		*/

		# 1) ~> Checking params

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		# 2) ~> Identifying the executable section

		nLen = len(@aContent)

		_oCode_ = new stzCCode(pcCondition)

		_oCode_.Transpile() # The sole difference with ..W() form of the function

		#WARNING
		# If you use _oCode_ variable name to assign a stzCCode object
		# to it in your code then you will get an error of an object
		# trying to destroy itself! That's why I used _ and _ bounds
		# here to minimise that risk!

		#TODO // ~> Clearly specify this in the documentation!

		#TODO // Review all the places in the codebase that could
		# contains a similar error!

		aExecutableSection = _oCode_.ExecutableSection()
		nStart = aExecutableSection[1]
		nEnd   = aExecutableSection[2]

		if isString(nEnd) and nEnd = :last
			nEnd = nLen
		ok

		if nEnd < 0
			nEnd += nLen
		but nEnd = :Last
			nEnd = nLen
		ok

		# 3) ~> Composing the code to be evaluated bu the loop

		cCode = 'bOk = (' + _oCode_.Code() + ' )'

		# 4) ~>  Preparing the list for casesensitivity

		if @CaseSensitive(pCaseSensitive) = _TRUE_
			_oCopy_ = This.Copy()
		else
			_oCopy_ = This.Copy().LowercaseQ()
		ok

		cCode = @ReplaceCS(cCode, "This", "_oCopy_", _FALSE_)
		# 5) ~>  Doing the job

		anResult = []

		for @i = nStart to nEnd

			#WARNING
			# You don't need to use any sophisticated keywords
			# like @item = @aContent[@i], since the code has been
			# transpiled above and hence is garanteed to containing
			# only @ and This[@i]-like keywords

			eval(cCode)

			if bOk
				anResult + @i
			ok
		next

		return anResult
		
		#< @FunctionAlternativeForms

		def FindAllWCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def FindWCSXT(pCondition, pCaseSensitive)
			aResult = This.FindAllItemsWCSXT(pCondition, pCaseSensitive)
			return aResult

		def FindWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def FindAllWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def FindAllItemsWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def FindItemsWCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def FindItemsWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def ItemsPositionsWCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def ItemsPositionsWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def PositionsWCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def PositionsOfItemsWCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def PositionsWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

		def PositionsOfItemsWhereCSXT(pCondition, pCaseSensitive)
			return This.FindAllItemsWCSXT(pCondition, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllItemsWXT(pcCondition)
		return This.FindAllItemsWCSXT(pcCondition, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindAllWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindAllItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindItemsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def ItemsPositionsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def ItemsPositionsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsOfItemsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsOfItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

	#>

	  #--------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION  #
	#==================================================#

	def FindFirstW(pcCondition)
		return This.FindNthW(1, pcCondition)

		#< @FunctionAlternativeForms

		def FindFirstItemW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFirstOccurrenceW(pcCondition)
			return This.FindFirstW(pcCondition)

		#>

		#< @FunctionMisspelledForms

		def FindFristW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFristItemW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFristOccurrenceW(pcCondition)
			return This.FindFirstW(pcCondition)

		#>

	  #-------------------------------------------------#
	 #  FINDING LAST ITEM VERIFYING A GIVEN CONDITION  #
	#-------------------------------------------------#

	def FindLastW(pcCondition) #TODO // Check for performance
		nLastW = This.NumberOfOccurrencesW(pcCondition)
		return FindNthW(nLastW , pcCondition)

		def FindLastItemW(pcCondition)
			return This.FindLastW(pcCondition)

		def FindLastOccurrenceW(pcCondition)
			return This.FindLastW(pcCondition)

	  #------------------------------------------------#
	 #  FINDING NTH ITEM VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------#

	def FindNthW(n, pcCondition)

		anTemp = This.FindW(pcCondition)
		nLen = len(anTemp)

		if isString(n)
			if ( n = :First or n = :FirstOccurrence )
				n = 1

			but ( n = :Last or n = :LastOccurrence )
				n = nLen
			ok
		ok

		nResult = 0

		if nLen > 0
			nResult = anTemp[n]
		ok

		return nResult

		def FindNthItemW(pcCondition)
			return This.FindNthW(n, pcCondition)

		def FindNthOccurrenceW(pcCondition)
			return This.FindNthW(n, pcCondition)

	  #------------------------------------------------------------#
	 #  FINDING NTH ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#------------------------------------------------------------#

	def FindNthWXT(n, pcCondition)

		anTemp = This.FindWXT(pcCondition)
		nLen = len(anTemp)

		if isString(n)
			if ( n = :First or n = :FirstOccurrence )
				n = 1

			but ( n = :Last or n = :LastOccurrence )
				n = nLen
			ok
		ok

		nResult = 0

		if nLen > 0
			nResult = anTemp[n]
		ok

		return nResult

		def FindNthItemWXT(pcCondition)
			return This.FindNthWXT(n, pcCondition)

		def FindNthOccurrenceWXT(pcCondition)
			return This.FindNthWXT(n, pcCondition)

	  #--------------------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#--------------------------------------------------------------#

	def FindFirstWXT(pcCondition)
		return This.FindNthWXT(1, pcCondition)

		#< @FunctionAlternativeForms

		def FindFirstItemWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFirstOccurrenceWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		#>

		#< @FunctionMisspelledForms

		def FindFristWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFristItemWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFristOccurrenceWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING LAST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#-------------------------------------------------------------#

	def FindLastWXT(pcCondition) #TODO # Check for performance
		n = This.NumberOfItemsWXT(pcCondition)
		return This.FindNthWXT(n, pcCondition)

		def FindLastItemWXT(pcCondition)
			return This.FindLastWXT(pcCondition)

		def FindLastOccurrenceWXT(pcCondition)
			return This.FindLastWXT(pcCondition)

	  #===================================================#
	 #  INFERING SECTION'S ITEMS FROM THE PROVIDED FORM  #
	#===================================================#

	/* #NOTE

	For the mean time, this function is used to translate the section
	returned from the StzCCodeQ().ExecutableSection method, to fill
	it with the actual values of the current list.

	So, for example, if the list has 10 items:

		--> [ 1, :Last ] is transformed to [ 1, 10 ]
		--> [ 2, -3 ] is transformed to [ 2, 7)
		--> Etc.

	TODO: In the future, it can be used to tranform all other forms used
	to create a section, sutch as [ :From = ..., :To = ... ].

	*/
	
	def InfereSection(paSection)
		aResult = []
		nStart = paSection[1]
		
		if nStart < 0
			nStart = This.NumberOfItems() - Abs(nStart) + 1
		ok

		nEnd = paSection[2]
		if isString(nEnd) and nEnd = :Last
			nEnd = This.NumberOfItems()
		ok

		if nEnd < 0
			nEnd = This.NumberOfItems() - Abs(nEnd) + 1
		ok

		aResult = [nStart, nEnd]
		return aResult

  	  #======================================#
	 #   GETTING ITEMS AT GIVEN POSITIONS   #
	#======================================#

	def ItemsAtPositions(panPos)

		if CheckingParams()
			if NOT isList(panPos)
				StzRaise("incorrect param type! panPos must be a list.")
			ok

			nLen = len(panPos)
			if nLen = 0
				return []
			ok

			for i = 1 to nLen
				if isString(panPos[i])
					if panPos[i] = :First or panPos[i] = :FirstPosition
						panPos[i] = 1
					but panPos[i] = :Last or panPos[i] = :LastPosition
						panOccurr[i] = This.NumberOfItemsCS(pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok


		aResult = []
		nLen = len(panPos)
		aContent = This.List()

		for i = 1 to nLen
			aResult + aContent[panPos[i]]
		next

		return aResult

		#< @FunctionFluentForms

		def ItemsAtPositionsQ(panPos)
			return This.ItemsAtPositionsQRT(panPos, :stzList)

		def ItemsAtPositionsQRT(panPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsAtPositions(panPos) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsAtPositions(panPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsAtPositions(panPos) )

			on :stzListOfLists
				return new stzListOfLists( This.ItemsAtPositions(panPos) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsAtPositions(panPos) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsAtPositions(panPos) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsAtPositions(panPos) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllItemsAtPositions(panPos)
			return This.ItemsAtPositions(panPos)

		def ItemsAtThesePositions(panPos)
			return This.ItemsAtPositions(panPos)

		def AllItemsAtThesePositions(panPos)
			return This.ItemsAtPositions(panPos)

		def ItemsAt(panPos)
			return This.ItemsAtPositions(panPos)

		def AllItemsAt(panPos)
			return This.ItemsAtPositions(panPos)

		#>

	  #----------------------------------------------#
	 #   GETTING ITEMS OUTSIDE THE GIVEN POSITIONS  #
	#----------------------------------------------#

	def ItemsOutsidePositions(panPos)
		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
			StzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		panPos = Q( 1 : This.NumberOfItems ) - These(panPos)
		// #TODO Make a more performant solution!

		aResult = This.ItemsAtPositions(panPos)

		return aResult

		#< @FunctionFluentForms

		def ItemsOutsidePositionsQ(panPos)
			return This.ItemsOutsidePositionsQRT(panPos, :stzList)

		def ItemsOutsidePositionsQRT(panPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsOutsidePositions(panPos) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsOutsidePositions(panPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsOutsidePositions(panPos) )

			on :stzListOfLists
				return new stzListOfLists( This.ItemsOutsidePositions(panPos) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsOutsidePositions(panPos) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsOutsidePositions(panPos) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsOutsidePositions(panPos) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllItemsOutsidePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsOutsideThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsOutsideThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsOutside(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsOutside(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsAtPositionsOtherThan(panPos)
			return This.ItemsOutsidePositions(panPos)

			def AllItemsAtPositionsOtherThen(panPos)
				return This.ItemsOutsidePositions(panPos)

		#--

		def AllItemsNotAtPositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsNotAtThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsNotAtThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsNotAt(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsNotAt(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsAtPositionsOtherThan(panPos)
			return This.ItemsOutsidePositions(panPos)

			def ItemsAtPositionsOtherThen(panPos)
				return This.ItemsOutsidePositions(panPos)

		#>

	  #====================================================#
	 #  CHECKING IF ALL THE ITEMS VERY A GIVEN CONDITION  #
	#====================================================#

	#TODO // Reconsider this function when CheckW() is reincluded

	def ItemsHaveCS(pcCondition, pCaseSensitive)
		bResult = This.EqualsCS(This.ItemsW(pcCondition), pCaseSensitive)
		return bResult

	def ItemsHave(pcCondition)
		return This.ItemsHaveCS(pcCondition, _TRUE_)

	#-- XTendedForm

	def ItemsHaveCSXT(pcCondition, pCaseSensitive)
		bResult = This.EqualsCS(This.ItemsWXT(pcCondition), pCaseSensitive)
		return bResult

	def ItemsHaveXT(pcCondition)
		return This.ItemsHaveCSXT(pcCondition, _TRUE_)

	  #===============================================#
	 #   GETTING ITEMS VERIFYING A GIVEN CONDITION   #
	#===============================================#

	/* #NOTE
	Note the semantic difference between "Getting" items, and "Finding" items.
		-> Getting items return the items themselves, while
		-> Finding items return their positions as numbers
		-> Their sections can also be found using FindAsSections() or simply FindZZ()
	*/

	def ItemsW(pcCondition)
		/* #WARNING

		Do not use this solution:

			return This.YieldW('@item', pcCondition)

		--> Stackoverflow!
		*/

		anPos = This.FindAllItemsW(pcCondition)
		aResult = This.ItemsAtThesePositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def ItemsWQ(pcCondition)
			return This.ItemsWQRT(pcCondition, :stzList)

		def ItemsWQRT(pcCondition, pcReturnType)
			if isList(pcCondition) and Q(pcCondition).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT (isString(pcReturnType) and Q(pcReturnType).IsStzType() )
				StzRaise("Incorrect param type! pcCondition must be a string containing a Softanza type.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsW(pcCondition) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsW(pcCondition) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsW(pcCondition) )
			
			on :stzListOfLists
				return new stzListOfLists( This.ItemsW(pcCondition) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsW(pcCondition) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsW(pcCondition) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsW(pcCondition) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def W(pcCondition)
			return This.ItemsW(pcCondition)

		def OnlyW(pcCondition)
			return This.ItemsW(pcCondition)

		#--

		def ItemsWhere(pcCondition)
			return This.ItemsW(pcCondition)
	
		def OnlyWhere(pcCondition)
			return This.ItemsW(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTINIG THE NTH ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------------------#

	def NthItemW(n, pcCondition)

		cResult = ItemsW(pcCondition)[n]
		return cResult

		#< @FunctionFluentForm

		def NthItemWQ(n, pCondition)
			item = This.NthItemW(n, pCondition)

			switch ring_type(item)
			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NthItemWhere(n, pcCondition)
			return This.NthItemW(n, pcCondition)

			def NthItemWhereQ(n, pcCondition)
				return This.NthItemWQ(n, pCondition)

		#>
		
	  #-------------------------------------------------------------------#
	 #  GETTINIG THE FIRST ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#-------------------------------------------------------------------#

	def FirstItemW(pCondition)
		return This.NthItemWhere(1, pCondition)

		#< @FunctionFluentForm

		def FirstItemWQ(pCondition)
			item = This.FirstItemW(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionMisspelledForm

		def FristItemW(pCondition)
			return This.FirstItemW(pCondition)

			def FristItemWQ(pCondition)
				return This.FirstItemWQ(pCondition)

		#>

	  #------------------------------------------------------------------#
	 #  GETTINIG THE LAST ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------------------------#

	def LastItemW(pCondition)
		return This.ItemsW(pCondition)[ len(This.ItemsW(pCondition)) ]

		#< @FunctionFluentForm

		def LastItemWQ(pCondition)
			item = This.LastItemW(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

	  #----------------------------------------------------------#
	 #   GETTING ITEMS VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#==========================================================#

	def ItemsWXT(pcCondition)
		
		anPos = This.FindAllItemsWXT(pcCondition)
		aResult = This.ItemsAtThesePositions(anPos)

		return aResult

		def ItemsWXTQ(pcCondition)
			return ItemsWXTQRT(pcCondition, :stzList)

		def ItemsWXTQRT(pcCondition, pcReturnType)
			if isList(pcCondition) and Q(pcCondition).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT (isString(pcReturnType) and Q(pcReturnType).IsStzType() )
				StzRaise("Incorrect param type! pcCondition must be a string containing a Softanza type.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsWXT(pcCondition) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsWXT(pcCondition) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsWXT(pcCondition) )
			
			on :stzListOfLists
				return new stzListOfLists( This.ItemsWXT(pcCondition) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsWXT(pcCondition) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsWXT(pcCondition) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsWXT(pcCondition) )

			other
				StzRaise("Unsupported return type!")
			off

			#< @FunctionAlternativeForms

			def WXT(pcCondition)
				return This.ItemsWXT(pcCondition)

			def OnlyWXT(pcCondition)
				return This.ItemsWXT(pcCondition)

			def OnlyWhereXT(pcCondition)
				return This.ItemsWXT(pcCondition)

			#>

	def NthItemWXT(n, pcCondition)

		cResult = ItemsWXT(pcCondition)[n]
		return cResult

		#< @FunctionFluentForm

		def NthItemWXTQ(n, pCondition)
			item = This.NthItemWXT(n, pCondition)

			switch ring_type(item)
			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NthItemWhereXT(n, pcCondition)
			return This.NthItemWXT(n, pcCondition)

			def NthItemWhereXTQ(n, pcCondition)
				return This.NthItemWXTQ(n, pCondition)

		#>
		
	def FirstItemWXT(pCondition)
		return This.NthItemWhereXT(1, pCondition)

		#< @FunctionFluentForm

		def FirstItemWXTQ(pCondition)
			item = This.FirstItemWXT(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#-- MISSPELLED

		def FristItemWXT(pCondition)
			return This.FirstItemWXT(pCondition)

			def FristItemWXTQ(pCondition)
				return This.FirstItemWXTQ(pCondition)

	def LastItemWXT(pCondition)
		return This.ItemsWXT(pCondition)[ len(This.ItemsWXT(pCondition)) ]

		#< @FunctionFluentForm

		def LastItemWXTQ(pCondition)
			item = This.LastItemWXT(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

	  #======================================================#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION   #
	#======================================================#

	def UniqueItemsW(pCondition)

		aResult = This.ItemsWQ(pCondition).ToSet()
		return aResult

		#< @FunctionFluentForm

		def UniqueItemsWQ(pCondition)
			return new stzList( This.UniqueItemsW(pCondition) )

		#>

		#< @FunctionAlternativeForms

		def UniqueItemsWhere(pCondition)
			return This.UniqueItemsW(pCondition)

			def UniqueItemsWhereQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		def ItemsWithoutDuplicationW(pCondition)
			return This.UniqueItemsW(pCondition)

			def ItemsWithoutDuplicationWQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		#--

		def ItemsWU(pCondition)
			return This.UniqueItemsW(pCondition)

			def ItemsWUQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		#>

	  #----------------------------------------------------------------------#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION -- WXT/EXTENSION  #
	#----------------------------------------------------------------------#

	def UniqueItemsWXT(pCondition)

		aResult = This.ItemsWXTQ(pCondition).ToSet()
		return aResult

		#< @FunctionFluentForm

		def UniqueItemsWXTQ(pCondition)
			return new stzList( This.UniqueItemsWXT(pCondition) )

		#>

		#< @FunctionAlternativeForms

		def UniqueItemsWhereXT(pCondition)
			return This.UniqueItemsWXT(pCondition)

			def UniqueItemsWhereXTQ(pCondition)
				return This.UniqueItemsWXTQ(pCondition)

		def ItemsWithoutDuplicationWXT(pCondition)
			return This.UniqueItemsWXT(pCondition)

			def ItemsWithoutDuplicationWXTQ(pCondition)
				return This.UniqueItemsWXTQ(pCondition)

		#--

		def ItemsWXTU(pCondition)
			return This.UniqueItemsWXTU(pCondition)

			def ItemsWXTUQ(pCondition)
				return This.UniqueItemsWXTUQ(pCondition)

		def ItemsWUXT(pCondition)
			return This.UniqueItemsWXTU(pCondition)

			def ItemsWUXTQ(pCondition)
				return This.UniqueItemsWXTUQ(pCondition)

		#>

	  #===============================================#
	 #   GETTING ALL ITEMS EXCEPT THE ONE PRPVIDED   #
	#===============================================#

	def AllItemsExceptCS(pItem, pCaseSensitive)
		aResult = This.ItemRemovedCS(pItem, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def AllItemsExcept(pItem)
		return This.AllItemsExceptCS(pItem, _TRUE_)

	  #================================================================================#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION ALONG WITH THEIR POSITIONS  #
	#================================================================================#

	def ItemsAndTheirPositionsW(pcCondition)
		/* Example
		o1 = new stzList([ "A", "m", "n", "B", "A", "x", "C", "z", "B" ])
		
		? o1.ItemsW('Q(@item).IsUppercase()')
		#--> [ "A", "B", "A", "C", "B" ]
		
		? o1.ItemsPositionsW('Q(@item).IsUppercase()') # Say also o1.FindItemsW(...)
		#--> [ 1, 4, 5, 7, 9 ]
		
		? o1.ItemsAndTheirPositionsW('Q(@item).IsUppercase()')
		#--> [ "A" = [1, 5], "B" = [4, 9], "C" = [7] ]
		*/

		aItems = This.ItemsW(pcCondition)
		anPos = This.FindItemsW(pcCondition)

		aPairs = StzListQ( aItems ).AssociatedWith( anPos )
	
		aUniqueItems = StzListQ(aItems).ToSet()

		aResult = []
		anItemPositions = []
		nLenUniqueItems = len(aUniqueItems)

		nLenAPairs = len(aPairs)

		for i = 1 to nLenUniqueItems
			pItem = aUniqueItems[i]
			
			for v = 1 to nLenAPairs
				aPair = aPairs[v]

				if ( isNumber(pItem) or isString(pItem) ) and
				   ( isNumber(aPair[1]) or isString(aPair[1]) )

					if aPair[1] = pItem
						anItemPositions + aPair[2]
					ok

				else
					if Q(aPair[1]).IsStrictlyEqualTo(pItem) # #TODO Check performance!
						anItemPositions + aPair[2]
					ok
				ok
			next
			
			aResult + [ pItem, anItemPositions ]
			anItemPositions = []

		next

		return aResult

		#< @FunctionAlternativeForms

		def ItemsAndTheirPositionsWhere(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWZ(pCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		#>

	   #======================================================#
	  #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION 	 #
	 #   ALONG WITH THEIR POSITIONS -- EXTENDED             #
	#======================================================#

	def ItemsAndTheirPositionsWXT(pcCondition)
		/* #INFO
		This version is less performant then ItemsAndTheirPositionsW()
		but provides more features, like transpiling the conditional
		code, allowing us to compose more expressive conditions, usinf
		not only @i and This[@i]-like conditions, but also @Item,
		@CurrentItem, @NextItem, @PreviousItem, and so on.
		*/

		aItems = This.ItemsWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)

		aPairs = StzListQ( aItems ).AssociatedWith( anPos )
	
		aUniqueItems = StzListQ(aItems).ToSet()

		aResult = []
		anItemPositions = []
		nLenUniqueItems = len(aUniqueItems)

		nLenAPairs = len(aPairs)

		for i = 1 to nLenUniqueItems
			pItem = aUniqueItems[i]
			
			for v = 1 to nLenAPairs
				aPair = aPairs[v]

				if ( isNumber(pItem) or isString(pItem) ) and
				   ( isNumber(aPair[1]) or isString(aPair[1]) )
					if aPair[1] = pItem
						anItemPositions + aPair[2]
					ok

				else
					if Q(aPair[1]).IsStrictlyEqualTo(pItem) # #TODO Check performance!
						anItemPositions + aPair[2]
					ok
				ok
			next
			
			aResult + [ pItem, anItemPositions ]
			anItemPositions = []

		next

		return aResult

		#< @FunctionAlternativeForms

		def ItemsAndTheirPositionsWhereXT(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWXTUZ(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWUXTZ(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		#>

	  #=================================#
	 #   GETTING ITEMS OF TYPE NUMBER  #
	#=================================#

	def NumberOfNumbers()
		return len( This.Numbers() )

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumers()
			return This.NumberOfNumbers()

		def HowManyNumer()
			return This.NumberOfNumbers()

	def FindNumbers()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindNumbersZ()
			return This.FindNumbers()

	def FindNumbersAsSections()
		aContent = This.Copy().Content() + "X"
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isNumber(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isNumber(aContent[i]) and NOT isNumber(aContent[i-1])
				n1 = i
			ok

			if isNumber(aContent[i]) and NOT isNumber(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindNumbersZZ()
			return This.FindNumbersAsSections()
		
	def Numbers()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isNumber(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def NumbersQ()
			return This.NumbersQRT(:stzList)

		def NumbersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyNumbers()
			return This.Numbers()

			def OnlyNumbersQ()
				return This.OnlyNumbersQRT(:stzList)
	
			def OnlyNumbersQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNumbers() )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.OnlyNumbers() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	def FindNumber(paNumber) # Add case sensitivity

		if CheckingParams()
			if NOT isNumber(paNumber)
				StzRaise("Incorrect param type! paNumber must be a list.")
			ok
		ok

		anPos = Q(This.Numbers()).Find(paNumber)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindNumbers()).ItemsAtPositions(anPos)
		ok

		return anResult

	def NumberZ(paNumber)
		if CheckingParams()
			if NOT isNumber(paNumber) 
				StzRaise("Incorrect param type! paNumber must be a list.")
			ok
		ok

		anPos = This.FindNumber(paNumber)
		aResult = [ paNumber, anPos ]	
		return aResult

	def FindTheseNumbers(paNumbers)
		if CheckingParams()
			if NOT ( isNumber(paNumbers) and Q(paNumbers).IsNumberOfNumbers() )
				StzRaise("Incorrect param type! paNumbers must be a list of lists.")
			ok
		ok

		paNumbers = U(paNumbers) # Duplicates removed
		nLen = len(paNumbers)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindNumber(paNumbers[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseNumbersZ(paNumbers)
		if CheckingParams()
			if NOT ( isNumber(paNumbers) and Q(paNumbers).IsNumberOfNumbers() )
				StzRaise("Incorrect param type! paNumbers must be a list of lists.")
			ok
		ok

		nLen = len(paNumbers)
		aResult = []

		for i = 1 to nLen
			aResult + [ paNumbers[i], This.FindNumber(paNumbers[i]) ]
		next

		return aResult

	  #----------------------------------#
	 #   REMOVING ITEMS OF TYPE NUMBER  #
	#----------------------------------#

	def RemoveNumbers()
		This.RemoveItemsAtPositions( This.FindNumbers() )

		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

		def RemoveOnlyNumbers()
			This.RemoveNumbers()

			def RemoveOnlyNumbersQ()
				This.RemoveOnlyNumbers()
				return This

	def NumbersRemoved()
		aResult = This.Copy().RemoveNumbersQ().Content()
		return aResult

	  #-------------------------------------------#
	 #  GETTING THE NUMBERS AND THEIR POSITIONS  #
	#-------------------------------------------#

	def NumbersZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NumbersAndTheirPositions()
			return This.NumbersZ()

		def NumbersAndPositions()
			return This.NumbersZ()

	  #----------------------------------------#
	 #   GETTING ITEMS WHICH ARE NOT NUMBERS  #
	#========================================#

	def FindNonNumbers()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if NOT isNumber(aContent[i])
				aResult + i
			ok
		next
		
		return aResult	

	def NonNumbers()
		aResult = This.ItemsAtPositions( This.FindNonNumbers() )
		return aResult

		def NonNumbersQ()
			return This.NonNumbersQRT(:stzList)

		def NonNumbersQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonNumbers() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NonNumbers() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonNumbers()
			return This.NonNumbers()

			def OnlyNonNumbersQ()
				return This.OnlyNonNumbersQRT(:stzList)
	
			def OnlyNonNumbersQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonNumbers() )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.OnlyNonNumbers() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #-----------------------------------------#
	 #   REMOVING ITEMS WHICH ARE NOT NUMBERS  #
	#-----------------------------------------#

	def RemoveNonNumbers()
		This.RemoveItemsAtPositions( This.FindNonNumbers() )

		def RemoveNonNumbersQ()
			This.RemoveNonNumbers()
			return This

		def RemoveOnlyNonNumbers()
			This.RemoveNonNumbers()

			def RemoveOnlyNonNumbersQ()
				This.RemoveOnlyNonNumbers()
				return This

		def RemoveAllExceptNumbers()
			This.RemoveNonNumbers()

			def RemoveAllExceptNumbersQ()
				This.RemoveAllExceptNumbers()
				return This
		
	def NonNumbersRemoved()
		aResult = This.Copy().RemoveNonNumbersQ().Content()
		return aResult

	  #-----------------------------------------------#
	 #  GETTING THE NON-NUMBERS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def NonNumbersZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isNumber(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonNumbersAndTheirPositions()
			return This.NonNumbersZ()

		def NonNumbersAndPositions()
			return This.NonNumbersZ()

	  #==============================================#
	 #   GETTING THE STRINGS CONTAINED IN THE LIST  #
	#==============================================#

	def NumberOfStrings()
		return len( This.Strings() )

		def CountStrings()
			return This.NumberOfStrings()

		def HowManyStrings()
			return This.NumberOfStrings()

		def HowManyString()
			return This.NumberOfStrings()

	def FindStrings()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindStringsZ()
			return This.FindStrings()

	def FindStringsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isString(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isString(aContent[i]) and NOT isString(aContent[i-1])
				n1 = i
			ok

			if isString(aContent[i]) and NOT isString(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindStringsZZ()
			return This.FindStringsAsSections()

	def Strings()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isString(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def StringsQ()
			return This.StringsQRT(:stzList)

		def StringsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Strings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Strings() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyStrings()
			return This.Strings()

			def OnlyStringsQ()
				return This.OnlyStringsQRT(:stzList)
	
			def OnlyStringsQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyStrings() )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.OmlyStrings() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	#TODO
	# Add NumbersU(), ListsU() and ObjectsU()

	def StringsU()
		#TODO
		# Add caseSensitivity
	
		aContent = This.Content()
		nLen = len(aContent)
		acResult = []

		for i = 1 to nLen
			if isString(aContent[i]) and ring_find(acResult,aContent[i]) = 0
				acResult + aContent[i]
			ok
		next

		return acResult

		def StringsUQ()
			return new stzList( This.StringsU() )	

	def FindString(paString) # Add case sensitivity

		if CheckingParams()
			if NOT isString(paString)
				StzRaise("Incorrect param type! paString must be a list.")
			ok
		ok

		anPos = Q(This.Strings()).Find(paString)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindStrings()).ItemsAtPositions(anPos)
		ok

		return anResult

	def StringZ(paString)
		if CheckingParams()
			if NOT isString(paString) 
				StzRaise("Incorrect param type! paString must be a list.")
			ok
		ok

		anPos = This.FindString(paString)
		aResult = [ paString, anPos ]	
		return aResult

	def FindTheseStrings(paStrings)
		if CheckingParams()
			if NOT ( isString(paStrings) and Q(paStrings).IsStringOfStrings() )
				StzRaise("Incorrect param type! paStrings must be a list of lists.")
			ok
		ok

		paStrings = U(paStrings) # Duplicates removed
		nLen = len(paStrings)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindString(paStrings[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseStringsZ(paStrings)
		if CheckingParams()
			if NOT ( isString(paStrings) and Q(paStrings).IsStringOfStrings() )
				StzRaise("Incorrect param type! paStrings must be a list of lists.")
			ok
		ok

		nLen = len(paStrings)
		aResult = []

		for i = 1 to nLen
			aResult + [ paStrings[i], This.FindString(paStrings[i]) ]
		next

		return aResult

	  #-------------------------------------#
	 #   REMOVING ITEMS WHICH ARE STRINGS  #
	#-------------------------------------#

	def RemoveStrings()

		This.RemoveItemsAtThesePositions(This.FindStrings())

		def RemoveStringsQ()
			This.RemoveStrings()
			return This

		def RemoveOnlyStrings()
			This.RemoveStrings()

			def RemoveOnlyStringsQ()
				This.RemoveOnlyStrings()
				return This

	def FindSpaces()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isString(aContent[i]) and aContent[i] = " "
				anResult + i
			ok
		next

		return anResult

	def RemoveSpaces()
		anPos = This.FindSpaces()
		This.RemoveItemsAtPositions(anPos)

		def RemoveSpacesQ()
			This.RemoveSpaces()
			return This

	def SpacesRemoved()
		aResult = This.Copy().RemoveSpacesQ().Content()
		return aResult

	  #-------------------------------------------#
	 #  GETTING THE STRINGS AND THEIR POSITIONS  #
	#-------------------------------------------#

	def StringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def StringsAndTheirPositions()
			return This.StringsZ()

		def StringsAndPositions()
			return This.StringsZ()

	  #----------------------------------------#
	 #   GETTING ITEMS WHICH ARE NOT STRING   #
	#========================================#

	def FindNonStrings()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isString(aContent[i])
				anResult + i
			ok
		next
		
		return anResult		

	def NonStrings()
		aResult = This.ItemsAtPositions( This.FindNonStrings() )
		return aResult	

		def NonStringsQ()
			return This.NonStringsQRT(:stzList)

		def NonStringsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.NonStrings() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonStrings()
			return This.NonStrings()

			def OnlyNonStringsQ()
				return This.OnlyNonStringsQRT(:stzList)
	
			def OnlyNonStringsQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonStrings() )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.OnlyNonStrings() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #-----------------------------------------------#
	 #  GETTING THE NON-STRINGS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def NonStringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonStringsAndTheirPositions()
			return This.NonStringsZ()

		def NonStringsAndPositions()
			return This.NonStringsZ()

	  #-----------------------------------------#
	 #   REMOVING ITEMS WHICH ARE NOT STRINGS  #
	#-----------------------------------------#

	def RemoveNonStrings()
		This.RemoveItemsAtPositions( This.FindNonStrings() )

		def RemoveNonStringsQ()
			This.RemoveNonStrings()
			return This

		def RemoveOnlyNonStrings()
			This.RemoveNonStrings()

			def RemoveOnlyNonStringsQ()
				This.RemoveOnlyNonStrings()
				return This

		def RemoveAllExceptStrings()
			This.RemoveNonStrings()

			def RemoveAllExceptStringsQ()
				This.RemoveAllExceptStrings()
				return This

	def NonStringsRemoved()
		acResult = This.Copy().RemoveNonStringsQ().Content()
		return acResult

	  #=================================================#
	 #  LOWERCASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def LowercaseStrings()

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for @i = 1 to _nLen_

			if isString(_aContent_[@i])
				_aContent_[@i] = ring_lower(_aContent_[@i])
			ok

		next

		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def LowercaseStringsQ()
			This.LowercaseStrings()
			return This

			def LowercaseStringsQC()
				_oCopy_ = This.Copy()
				_oCopy_.LowercaseStrings()
				return _oCopy_

		#>

		#< @FunctionAlternativeForm

		def Lowercase()
			This.LowercaseStrings()

			def LowercaseQ()
				return This.LowercaseStringsQ()

			def LowercaseQC()
				return LowercaseStringsQC()

		#>

	def StringsLowercased()
		aResult = This.Copy().LowercaseStringsQ().Content()
		return aResult

		def Lowercased()
			return This.StringsLowercased()

	  #-----------------------------#
	 #  DEEP-LOWERCASING THE LIST  #
	#-----------------------------#

	def DeepLowercase()

		_cCode_ = ' _aResult_ = ' + lower( @@(This.Content()) )
		eval(_cCode_)
		This.Update(_aResult_)


		def DeepLowercaseQ()
			This.DeepLowercase()
			return This

			def DeepLowercaseQC()
				_oCopy_ = This.Copy()
				_oCopy_.DeepLowercase()
				return _oCopy_

		def DeepApplyLowercase()
			This.DeepLowercase()

			def DeppApplyLowercaseQ()
				return This.DeepLowercaseQ()

			def DeppApplyLowercaseQC()
				return This.DeepLowercaseQC()

	def DeepLowercased()
		_aResult_ = This.Copy().DeepLowercaseQ().Content()
		return _aResult_

	  #-------------------------------------------------------------------#
	 #  DEEP-LOWERCASING A GIVEN STRING IN THE LIST AND ITS INNER LISTS  #
	#-------------------------------------------------------------------#

	def DeepLowercaseString(pcStr)

		_cContent_ = @@Q( This.Content() ).ReplaceQ(pcStr, lower(pcStr)).Content()
		_cCode_ = ' _aResult_ = ' + _cContent_
		eval(_cCode_)
		This.Update(_aResult_)


		def DeepLowercaseStringQ(pcStr)
			This.DeepLowercaseString(pcStr)
			return This

		def DeepLowercaseThis(pcStr)
			This.DeepLowercaseString(pcStr)

			def DeepLowercaseThisQ(pcStr)
				return This.DeepLowercaseStringQ(pcStr)

		def DeepLowercaseXT(pcStr)
			This.DeepLowercaseString(pcStr)

			def DeepLowercaseXTQ(pcStr)
				return This.DeepLowercaseStringQ(pcStr)

	def StringDeepLowercased(pcStr)
		_aResult_ = This.Copy().DeepLowercaseStringQ(pcStr).Content()
		return _aResult_
 
		def ThisDeepLowercased(pcStr)
			return This.StringDeepLowercased(pcStr)

		def DeepLowercasedXT(pcStr)
			return This.StringDeepLowercased(pcStr)

	  #=================================================#
	 #  UPPERCASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def UppercaseStrings()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for @i = 1 to _nLen_
			if isString(_aContent_[@i])
				_cStrUpp_ = ring_upper(_aContent_[@i])
				_aContent_[@i] = _cStrUpp_
			ok
		next

		This.UpdateWith(_aContent_)

		def UppercaseStringsQ()
			This.UppercaseStrings()
			return This

			def UppercaseStringsQC()
				_oCopy_ = This.Copy()
				_oCopy_.UppercaseString()
				return _oCopy_

		def Uppercase()
			This.UppercaseStrings()

			def UppercaseQ()
				This.Uppercase()
				return This

			def UppercaseQC()
				return This.UppercaseStringsQC()

		def ApplyUppercase()
			This.UppercaseStrings()

			def ApplyUppercaseQ()
				This.ApplyUppercase()
				return This

			def ApplyUppercaseQC()
				return This.UppercaseStringsQC()

	def StringsUppercased()
		aResult = This.Copy().UppercaseStringsQ().Content()
		return aResult

		def Uppercased()
			return This.StringsUppercased()

	  #-----------------------------#
	 #  DEEP-UPPERCASING THE LIST  #
	#-----------------------------#

	def DeepUppercase()
		_cCode_ = ' _aResult_ = ' + upper( @@(This.Content()) )
		eval(_cCode_)
		This.Update(_aResult_)


		def DeepUppercaseQ()
			This.DeepUppercase()
			return This

			def DeepUppercaseQC()
				_oCopy_ = This.Copy()
				_oCopy_.DeepUppercase()
				return _oCopy_

		def DeepApplyUppercase()
			This.DeepUppercase()

			def DeppApplyUppercaseQ()
				return This.DeepUppercaseQ()

			def DeepApplyUppercaseQC()
				return This.DeepUppercaseQC()

	def DeepUppercased()
		_aResult_ = This.Copy().DeepUppercaseQ().Content()
		return _aResult_

	  #-------------------------------------------------------------------#
	 #  DEEP-UPPERCASING A GIVEN STRING IN THE LIST AND ITS INNER LISTS  #
	#-------------------------------------------------------------------#

	def DeepUppercaseString(pcStr)

		_cContent_ = @@Q( This.Content() ).ReplaceQ(pcStr, upper(pcStr)).Content()
		_cCode_ = ' _aResult_ = ' + _cContent_
		eval(_cCode_)
		This.Update(_aResult_)


		def DeepUppercaseStringQ(pcStr)
			This.DeepUppercaseString(pcStr)
			return This

		def DeepUppercaseThis(pcStr)
			This.DeepUppercaseString(pcStr)

			def DeepUppercaseThisQ(pcStr)
				return This.DeepUppercaseStringQ(pcStr)

		def DeepUppercaseXT(pcStr)
			This.DeepUppercaseString(pcStr)

			def DeepUppercaseXTQ(pcStr)
				return This.DeepUppercaseStringQ(pcStr)

	def StringDeepUppercased(pcStr)
		_aResult_ = This.Copy().DeepUppercaseStringQ(pcStr).Content()
		return _aResult_
 
		def ThisDeepUppercased(pcStr)
			return This.StringDeepUppercased(pcStr)

		def DeepUppercasedXT(pcStr)
			return This.StringDeepUppercased(pcStr)		

	  #=================================================#
	 #  TITLECASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def TitlecaseStrings()
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrTtl = Q(aContent[i]).Titlecased()
				This.ReplaceAt(i, cStrTtl)
			ok
		next

		def TitlecaseStringsQ()
			This.TitlecaseStrings()
			return This

		def Titlecase()
			This.TitlecaseStrings()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def ApplyTitlecase()
			This.TitlecaseStrings()

			def ApplyTitlecaseQ()
				This.ApplyTitlecase()
				return This

	def StringsTitlecased()
		aResult = This.Copy().TitlecaseStringsQ().Content()
		return aResult

		def Titlecased()
			return This.StringsTitlecased()


	  #==================================================#
	 #  CAPITALIZING THE STRINGS CONTAINED IN THE LIST  #
	#==================================================#

	def CapitaliseStrings()
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen
			
			if isString(aContent[i])
				cStrCap = Q(aContent[i]).Capitalised()
				This.ReplaceAt(i, cStrCap)
			ok
		next

		def CapitaliseStringsQ()
			This.CapitaliseStrings()
			return This

		def CapitalizeStrings()
			This.CapitaliseStrings()

			def CapitalizeStringsQ()
				This.CapitalizeStrings()
				return This

		def Capitalise()
			This.CapitaliseStrings()

			def CapitaliseQ()
				This.CapitaliseStrings()
				return This

		def Capitalize()
			This.CapitalizeStrings()

			def CapitalizeQ()
				This.Capitalize()
				return This

		def ApplyCapitalcase()
			This.CapitalizeStrings()

			def ApplyCapitalcaseQ()
				This.ApplyCapitalcase()
				return This

	def StringsCapitalised()
		aResult = This.Copy().CapitaliseStringsQ().Content()
		return aResult

		def Capitalised()
			return This.StringsCapitalised()

		def Capitalized()
			return This.StringsCapitalised()


	#----

	def LowercaseLists()

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if isList(item)
				acLowercased = StzListOfStringsQ(aContent[i]).Lowercased()
				aContent[i] = acLowercased
			ok
		next

		This.UpdateWith(aContent)


		def LowercaseListsQ()
			This.LowercaseLists()
			return This

	def ListsLowercased()
		return This.Copy().LowercaseListsQ().Content()

	#----

	def LowercaseListsOfStrings()

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if isList(item) and @IsListOfStrings(aContent[i])
				acLowercased = StzListOfStringsQ(aContent[i]).Lowercased()
				aContent[i] = acLowercased
			ok
		next

		This.UpdateWith(aContent)


		def LowercaseListsOfStringsQ()
			This.LowercaseListsOfStrings()
			return This

	def ListsOfStringsLowercased()
		return This.Copy().LowercaseListsOfStringsQ().Content()

	#----

	def UppercaseLists()
		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if isList(item)
				acLowercased = StzListOfStringsQ(aContent[i]).Uppercased()
				aContent[i] = acLowercased
			ok
		next

		This.UpdateWith(aContent)


		def UppercaseListsQ()
			This.UppercaseLists()
			return This

	def ListsUppercased()
		return This.Copy().UppercaseListsQ().Content()

	#----

	def UppercaseListsOfStrings()

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if isList(item) and @IsListOfStrings(aContent[i])
				acLowercased = StzListOfStringsQ(aContent[i]).Uppercased()
				aContent[i] = acLowercased
			ok
		next

		This.UpdateWith(aContent)


		def UppercaseListsOfStringsQ()
			This.LowercaseListsOfStrings()
			return This

	def ListsOfStringsUppercased()
		return This.Copy().UppercaseListsOfStringsQ().Content()

	  #===========================================#
	 #   GETTING & REMOVING ITEMS OF TYPE LIST   #
	#===========================================#

	def NumberOfLists()
		return len( This.Lists() )

		def CountLists()
			return This.NumberOfLists()

		def HowManyLists()
			return This.NumberOfLists()

		def HowManyList()
			return This.NumberOfLists()

	  #---------------------------------------#
	 #  GETTING THE LISTS ITEMS IN THE LIST  #
	#---------------------------------------#

	def Lists()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isList(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ListsQ()
			return This.ListsQRT(:stzList)

		def ListsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Lists() )

			on :stzListOfLists
				return new stzListOfLists( This.Lists() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyLists()
			return This.Lists()

			def OnlyListsQ()
				return This.OnlyListsQRT(:stzList)
	
			def OnlyListsQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyLists() )
	
				on :stzListOfLists
					return new stzListOfLists( This.OnlyLists() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	  #----------------------------------#
	 #  FINDING THE LISTS IN THE LISTS  #
	#----------------------------------#

	def FindLists()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindListsZ()
			return This.FindLists()

	def FindListsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isList(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isList(aContent[i]) and NOT isList(aContent[i-1])
				n1 = i
			ok

			if isList(aContent[i]) and NOT isList(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindListsZZ()
			return This.FindListsAsSections()

	def FindList(paList) # Add case sensitivity

		if CheckingParams()
			if NOT isList(paList)
				StzRaise("Incorrect param type! paList must be a list.")
			ok
		ok

		anPos = Q(This.Lists()).Find(paList)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindLists()).ItemsAtPositions(anPos)
		ok

		return anResult

	def ListZ(paList)
		if CheckingParams()
			if NOT isList(paList) 
				StzRaise("Incorrect param type! paList must be a list.")
			ok
		ok

		anPos = This.FindList(paList)
		aResult = [ paList, anPos ]	
		return aResult

	def FindTheseLists(paLists)
		if CheckingParams()
			if NOT ( isList(paLists) and Q(paLists).IsListOfLists() )
				StzRaise("Incorrect param type! paLists must be a list of lists.")
			ok
		ok

		paLists = U(paLists) # Duplicates removed
		nLen = len(paLists)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindList(paLists[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseListsZ(paLists)
		if CheckingParams()
			if NOT ( isList(paLists) and Q(paLists).IsListOfLists() )
				StzRaise("Incorrect param type! paLists must be a list of lists.")
			ok
		ok

		nLen = len(paLists)
		aResult = []

		for i = 1 to nLen
			aResult + [ paLists[i], This.FindList(paLists[i]) ]
		next

		return aResult

	  #--------------------------------------------#
	 #  REMOVING THE LISTS CONTAINED IN THE LIST  #
	#--------------------------------------------#

	def RemoveLists()
		anPos = This.FindLists()
		This.RemoveItemsAtThesePositions(anPos)

		def RemoveListsQ()
			This.RemoveLists()
			return This

		def RemoveOnlyLists()
			This.RemoveLists()

			def RemoveOnlyListsQ()
				This.RemoveOnlyLists()
				return This

	def ListsRemoved()
		aResult = This.Copy().RemoveListsQ().Content()
		return aResult

	  #-----------------------------------------#
	 #  GETTING THE /SS AND THEIR POSITIONS  #
	#-----------------------------------------#

	def ListsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def ListsAndTheirPositions()
			return This.ListsZ()

		def ListsAndPositions()
			return This.ListsZ()


	  #-------------------------------------------------#
	 #  GETTING THE SIZE OF EACH ITEM WHICH IS A LIST  #
	#=================================================#

	def ListsNumberOfItems()
		aResult = []
		for item in This.List()
			if isList(item)
				aResult + len(item)
			ok
		next
		return aResult
		
		def ListsSizes()
			return This.ListsNumberOfItems()

		def NumberOfItemsOfEachList()
			return This.ListsNumberOfItems()

		def SizeOfEachList()
			return This.ListsNumberOfItems()


	def ListsHaveSameNumberOfItems()
		bResult = _TRUE_
		for i=2 to len( This.Sublists() )
			if len( This.Sublists()[i] ) != len( This.Sublists()[i-1] )
				bResult = _FALSE_
			ok
		next
		return bResult

		def ListsHaveSameSize()
			return This.ListsHaveSameNumberOfItems()

	def ListsAtAnyLevelHaveSameNumberOfItems()
		bResult = _TRUE_
		for i=2 to len( This.listsAtAnyLevel() )
			if len( This.listsAtAnyLevel()[i] ) != len( This.listsAtAnyLevel()[i-1] )
				bResult = _FALSE_
			ok
		next
		return bResult

		def ListsAtAnyLevelHaveSameSize()
			return This.ListsAtAnyLevelHaveSameNumberOfItems()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF NUMBERS IN THE LIST  #
	#============================================#

	def FindListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF NUMBERS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfNumbers()
			return This.NumberOfListsOfNumbers()

		def HowManyListOfNumbers()
			return This.NumberOfListsOfNumbers()

		def CountListsOfNumbers()
			return This.NumberOfListsOfNumbers()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForms

		def ListsOfNumbersQ()
			return new stzList(This.ListsOfNumbers())

		def ListOfNumbersQQ()
			return new stzListOfNumbers(This.ListsOfNumbers())

		def ListOfNumbersQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfNumbers())

			on :stzListOfNumbers
				return new stzListOfNumbers(This.ListsOfNumbers())

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfNumbers()
			return This.ListsOfNumbers()

			def OnlyListsOfNumbersQ()
				return This.ListsOfNumbersQ()

			def OnlyListsOfNumbersQQ()
				return This.ListOfNumbersQQ()

			def OnlyListsOfNumbersQRT(pcReturnType)
				return This.ListOfNumbersQRT(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfNumbers()
		aResult = @WithoutDupplication(This.ListsOfNumbers())
		return aResult

		def ListsOfNumbersU()
			return This.UniqueListsOfNumbers()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfNumbersZ()
		aListsU = This.UniqueListsOfNumbers()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfNumbersZ()
			return This.ListsOfNumbersZ()

		def ListsOfNumbersAndTheirPositions()
			return This.ListsOfNumbersZ()

		def OnlyListsOfNumbersAndTheirPositions()
			return This.ListsOfNumbersZ()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF STRINGS IN THE LIST  #
	#============================================#

	def FindListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF STRINGS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfStrings()
			return This.NumberOfListsOfStrings()

		def HowManyListOfStrings()
			return This.NumberOfListsOfStrings()

		def CountListsOfStrings()
			return This.NumberOfListsOfStrings()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfStringsQ()
			return new stzList(This.ListsOfStrings())

		def ListOfStringsQQ()
			return new stzListOfStrings(This.ListsOfStrings())

		def ListOfStringsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfStrings())

			on :stzListOfStrings
				return new stzListOfStrings(This.ListsOfStrings())

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfStrings()
			return This.ListsOfStrings()

			def OnlyListsOfStringsQ()
				return This.ListsOfStringsQ()

			def OnlyListsOfStringsQQ()
				return This.ListOfStringsQQ()

			def OnlyListsOfStringsQRT(pcReturnType)
				return This.ListOfStringsQRT(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfStrings()
		aResult = @WithoutDupplication(This.ListsOfStrings())
		return aResult

		def ListsOfStringsU()
			return This.UniqueListsOfStrings()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfStringsZ()
		aListsU = This.UniqueListsOfStrings()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfStringsZ()
			return This.ListsOfStringsZ()

		def ListsOfStringsAndTheirPositions()
			return This.ListsOfStringsZ()

		def OnlyListsOfStringsAndTheirPositions()
			return This.ListsOfStringsZ()

	  #------------------------------------------#
	 #  FINDING THE LISTS OF LISTS IN THE LIST  #
	#==========================================#

	def FindListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF LISTS IN THE LIST  #
	#----------------------------------------------------#

	def NumberOfListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfLists()
			return This.NumberOfListsOfLists()

		def HowManyListOfLists()
			return This.NumberOfListsOfLists()

		def CountListsOfLists()
			return This.NumberOfListsOfLists()

	  #------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST  #
	#------------------------------------------#

	def ListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfListsQ()
			return new stzList(This.ListsOfLists())

		def ListOfListsQQ()
			return new stzListOfLists(This.ListsOfLists())

		def ListOfListsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfLists())

			on :stzListOfLists
				return new stzListOfLists(This.ListsOfLists())

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfLists()
			return This.ListsOfLists()

			def OnlyListsOfListsQ()
				return This.ListsOfListsQ()

			def OnlyListsOfListsQQ()
				return This.ListOfListsQQ()

			def OnlyListsOfListsQRT(pcReturnType)
				return This.ListOfListsQRT(pcReturnType)

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST WITHOUT DUPPLICATION  #
	#---------------------------------------------------------------#

	def UniqueListOfLists()
		aResult = @WithoutDupplication(This.ListsOfLists())
		return aResult

		def ListsOfListsU()
			return This.UniqueListsOfLists()

	  #---------------------------------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#---------------------------------------------------------------------#

	def ListsOfListsZ()
		aListsU = This.UniqueListsOfLists()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfListsZ()
			return This.ListsOfListsZ()

		def ListsOfListsAndTheirPositions()
			return This.ListsOfListsZ()

		def OnlyListsOfListsAndTheirPositions()
			return This.ListsOfListsZ()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF OBJECTS IN THE LIST  #
	#============================================#

	def FindListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF OBJECTS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfObjects()
			return This.NumberOfListsOfObjects()

		def HowManyListOfObjects()
			return This.NumberOfListsOfObjects()

		def CountListsOfObjects()
			return This.NumberOfListsOfObjects()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfObjectsQ()
			return new stzList(This.ListsOfObjects())

		def ListOfObjectsQQ()
			return new stzListOfObjects(This.ListsOfObjects())

		def ListOfObjectsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfObjects())

			on :stzListOfObjects
				return new stzListOfObjects(This.ListsOfObjects())

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfObjects()
			return This.ListsOfObjects()

			def OnlyListsOfObjectsQ()
				return This.ListsOfObjectsQ()

			def OnlyListsOfObjectsQQ()
				return This.ListOfObjectsQQ()

			def OnlyListsOfObjectsQRT(pcReturnType)
				return This.ListOfObjectsQRT(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfObjects()
		aResult = @WithoutDupplication(This.ListsOfObjects())
		return aResult

		def ListsOfObjectsU()
			return This.UniqueListsOfObjects()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfObjectsZ()
		aoObjectsU = This.UniqueListsOfObjects()
		nLenU = len(aoObjectsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aoObjectsU[i])
			aResult + [ aoObjectsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfObjectsZ()
			return This.ListsOfObjectsZ()

		def ListsOfObjectsAndTheirPositions()
			return This.ListsOfObjectsZ()

		def OnlyListsOfObjectsAndTheirPositions()
			return This.ListsOfObjectsZ()

	  #===============================================#
	 #  GETTING THE NUMBERS AND STRINGS IN THE LIST  #
	#===============================================#

	def FindNumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + i
			ok
		next

		return aResult

		def FindStringsAndNumbers()
			return This.FindNumbersAndStrings()

	def NumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		def StringsAndNumbers()
			return This.NumbersAndStrings()

	def NumbersAndStringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def StringsAndNumbersZ()
			return This.NumberAndStringsZ()

	def RemoveNumbersAndStrings()
		This.RemoveItemsAtPositions( This.FindNumbersAndStrings() )

		def RemoveStringsAndNumbers()

	def NumbersAndStringsRemoved()
		aResult = This.Copy().RemoveNumbersAndStringsQ().Content()
		return aResult

		def StringsAndNumbersRemoved()
			return This.NumbersAndStringsRemoved()

	  #=====================================#
	 #  GETTING THE NON-LISTS IN THE LIST  #
	#=====================================#

	def FindNonLists()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if NOT isList(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

	def NonLists()
		aResult = This.ItemsAtPositions( This.FindNonLists() )
		return aResult		

		def NonListsQ()
			return This.NonListsQRT(:stzList)

		def NonListsQRT(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonLists() )

			on :stzListOfLists
				return new stzListOfLists( This.NonLists() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonLists()
			return This.NonLists()

			def OnlyNonListsQ()
				return This.OnlyNonListsQRT(:stzList)
	
			def OnlyNonListsQRT(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonLists() )
	
				on :stzListOfLists
					return new stzListOfLists( This.OnlyNonLists() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #------------------------------------#
	 #  REMOVING NON LISTS FROM THE LIST  #
	#------------------------------------#

	def RemoveNonLists()
		anPos = This.FindNonLists()
		This.RemoveItemsAtThesePositions(anPos)

		def RemoveNonListsQ()
			This.RemoveNonLists()
			return This

		def RemoveOnlyNonLists()
			This.RemoveNonLists()

			def RemoveOnlyNonListsQ()
				This.RemoveOnlyNonLists()
				return This

		def RemoveAllExceptLists()
			This.RemoveNonLists()

			def RemoveAllExceptListsQ()
				This.RemoveAllExceptLists()
				return This

	def NonListsRemoved()
		aResult = This.Copy().RemoveNonListsQ().Content()
		return aResult

	  #---------------------------------------------#
	 #  GETTING THE NON-LISTS AND THEIR POSITIONS  #
	#---------------------------------------------#

	def NonListsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isList(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonListsAndTheirPositions()
			return This.NonListsZ()

		def NonListsAndPositions()
			return This.NonListsZ()

	  #=================================================#
	 #     GETTING & REMOVING ITEMS OF TYPE OBJECT     #
	#=================================================#

	def NumberOfObjects()
		return len( This.Objects() )

		def CountObjecs()
			return This.NumberOfObjects()

		def HowManyObjects()
			return This.NumberOfObjects()

		def HowManyObject()
			return This.NumberOfObjects()


	def Objects()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isObject(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ObjectsQ()
			return This.ObjectsQRT(:stzObject)

		def ObjectsQRT(pcReturnType)
			if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzObject
				return new stzObject( This.Objects() )

			on :stzObjectOfObjects
				return new stzObjectOfObjects( This.Objects() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyObjects()
			return This.Objects()

			def OnlyObjectsQ()
				return This.OnlyObjectsQRT(:stzObject)
	
			def OnlyObjectsQRT(pcReturnType)
				if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzObject
					return new stzObject( This.OnlyObjects() )
	
				on :stzObjectOfObjects
					return new stzObjectOfObjects( This.OnlyObjects() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	#--

	def RemoveObjects()
		This.RemoveItemsAtThesePositions(This.FindObjects())

		def RemoveObjectsQ()
			This.RemoveObjects()
			return This

		def RemoveOnlyObjects()
			This.RemoveObjects()

			def RemoveOnlyObjectsQ()
				This.RemoveOnlyObjects()
				return This

	def ObjectsRemoved()
		aResult = This.Copy().RemoveObjectsQ().Content()
		return aResult

	#--

	def FindNonObjects()
		aContent = This.COntent()
		nLen = len(aContent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def NonObjects()
		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		def NonObjectsQ()
			return This.NonObjectsQRT(:stzObject)

		def NonObjectsQRT(pcReturnType)
			if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzObject
				return new stzObject( This.NonObjects() )

			on :stzObjectOfObjects
				return new stzObjectOfObjects( This.NonObjects() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonObjects()
			return This.NonObjects()

			def OnlyNonObjectsQ()
				return This.OnlyNonObjectsQRT(:stzObject)
	
			def OnlyNonObjectsQRT(pcReturnType)
				if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzObject
					return new stzObject( This.OnlyNonObjects() )
	
				on :stzObjectOfObjects
					return new stzObjectOfObjects( This.OnlyNonObjects() )
	
				other
					StzRaise("Unsupported return type!")
				off

	def RemoveNonObjects()
		This.RemoveItemsAtThesePositions( This.FindNonObjects() )

		def RemoveNonObjectsQ()
			This.RemoveNonObjects()
			return This

		def RemoveOnlyNonObjects()
			This.RemoveNonObjects()

			def RemoveOnlyNonObjectsQ()
				This.RemoveOnlyNonObjects()
				return This

		def RemoveAllExceptObjects()
			This.RemoveNonObjects()

			def RemoveAllExceptObjectsQ()
				This.RemoveAllExceptObjects()
				return This

	def NonObjectsRemoved()
		aResult = This.Copy().RemoveNonObjectsQ().Content()
		return aResult

	  #--------------------------------------------------#
	 #     COUNTING ITEMS VERIFYING A GIVEN CONDITION   #
	#==================================================#

	def CountItemsW(pCondition)
		aItems = This.FindW(pCondition)

		nResult = len(aItems)

		return nResult
		
		#< @AlternativeFunctionNames

		def CountW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfOccurrenceW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfOccurrencesW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfItemsW(pCondition)
			return This.CountItemsW(pCondition)

		def HowManyItemsW(pcCondition)
			return This.CountItemsW(pCondition)

		def HowManyItemW(pcCondition)
			return This.CountItemsW(pCondition)

		#>
			
	def NumberOfUniqueItemsW(pCondition)
		return len( This.UniqueItemsW(pCondition) )

		#< @FunctionAlternativeForms

		def NumberOfItemsUW(pCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def CountUniqueItemsW(pccondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def CountItemsUW(pccondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyUniqueItemsW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyUniqueItemW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyItemsUW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyItemUW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def NumberOfItemsWithoutDuplicationW(pCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		#>

	  #------------------------------------------------------------#
	 #     COUNTING ITEMS VERIFYING A GIVEN CONDITION -- XTended  #
	#------------------------------------------------------------#

	def CountItemsWXT(pCondition)
		aItems = This.FindWXT(pCondition)
		nResult = len(aItems)

		return nResult
		
		#< @AlternativeFunctionNames

		def CountWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfOccurrenceWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfOccurrencesWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfItemsWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def HowManyItemsWXT(pcCondition)
			return This.CountItemsWXT(pCondition)

		def HowManyItemWXT(pcCondition)
			return This.CountItemsWXT(pCondition)

		#>
			
	def NumberOfUniqueItemsWXT(pCondition)
		return len( This.UniqueItemsWXT(pCondition) )

		#< @FunctionAlternativeForms

		def NumberOfItemsUWXT(pCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def CountUniqueItemsWXT(pccondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def CountItemsUWXT(pccondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyUniqueItemsWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyUniqueItemWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyItemsUWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyItemUWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def NumberOfItemsWithoutDuplicationWXT(pCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		#>

	  #--------------------------------------------------------------------#
	 #  INSERTING ITEM AFTER OR BEFORE ITEMS VERIFYING A GIVEN CONDITION  #
	#====================================================================#

	def InsertAfterW( pcCondition, pNewItem )
		anPos = This.FindItemsW(pcCondition)
		This.InsertAfterManyPositions( anPos, pNewItem )

		#< @FunctionFluentForm

		def InsertAfterWQ( pcCondition, pNewItem )
			This.InsertAfterW( pCondition, pNewItem )
			return This

		#>

		def InsertAfterWhere(pcCondition, pNewItem)
			This.InsertAfterW(pCondition, pNewItem)

			def InsertAfterWhereQ(pcCondition, pNewItem)
				This.InsertAfterWhere(pcCondition, pNewItem)
				return This

	def InsertBeforeW(pcCondition, pNewItem)
		/*
		o1.InsertBeforeW( :Where = '{ StzStringQ(item).IsUppercase() }', "*" )
		*/

		anPos = This.FindItemsW(pcCondition)
		This.InsertBeforeThesePositions(anPos, pNewItem)

		#< @FunctionFluentForm

		def InsertBeforeWQ(pcCondition, pNewItem)
			This.InsertBeforeW(pcCondition, pNewItem)
			return This

		#>

		def InsertAtW(pcCondition, pNewItem)
			This.InsertBeforeW(pcCondition, pNewItem)

			def InsertAtWQ(pcCondition, pNewItem)
				This.InsertAt(pcCondition, pNewItem)
				return This

	  #------------------------------------------------------------------------------------#
	 #  INSERTING ITEM AFTER OR BEFORE ITEMS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------------------#

	def InsertAfterWXT( pcCondition, pNewItem )
		anPos = This.FindItemsWXT(pcCondition)
		This.InsertAfterManyPositions( anPos, pNewItem )

		#< @FunctionFluentForm

		def InsertAfterWXTQ( pcCondition, pNewItem )
			This.InsertAfterWXT( pCondition, pNewItem )
			return This

		#>

		def InsertAfterWhereXT(pcCondition, pNewItem)
			This.InsertAfterWXT(pCondition, pNewItem)

			def InsertAfterWhereXTQ(pcCondition, pNewItem)
				This.InsertAfterWhereXT(pcCondition, pNewItem)
				return This

	def InsertBeforeWXT(pcCondition, pNewItem)
		/*
		o1.InsertBeforeWXT( :Where = '{ StzStringQ(item).IsUppercase() }', "*" )
		*/

		anPos = This.FindItemsWXT(pcCondition)
		This.InsertBeforeThesePositions(anPos, pNewItem)

		#< @FunctionFluentForm

		def InsertBeforeWXTQ(pcCondition, pNewItem)
			This.InsertBeforeWXT(pcCondition, pNewItem)
			return This

		#>

		def InsertAtWXT(pcCondition, pNewItem)
			This.InsertBeforeWXT(pcCondition, pNewItem)

			def InsertAtWXTQ(pcCondition, pNewItem)
				This.InsertAtXT(pcCondition, pNewItem)
				return This

	  #--------------------------------------------#
	 #  INSERTING AN ITEM BEFORE MANY PositIONNS  #
	#============================================#

	def InsertBeforeManyPositions(panPos, pItem)

		# Param checks

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		# Early checks

		nLenList = This.NumberOfChars()
		if nLenList = 0
			return
		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return
		ok

		# Leaving only the accurate positions

		panPos = ring_sort(panPos)

		anPos = []
		
		for i = 1 to nLenPos
			if panPos[i] > 1 and panPos[i] <= nLenList
				anPos + panPos[i]
			ok
		next

		# Doing the job

		aContent = This.Content()
		nLenPos = len(anPos)

		for i = nLenPos to 1 step -1
			ring_insert(aContent, panPos[i], pItem)
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm
		
		def InsertBeforeManyPositionsQ(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeThesePositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertBeforeThesePositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		def InsertBeforePositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertBeforePositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		def InsertAtPositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertAtPositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		#>

	  #------------------------------------------#
	 #  INSERTING AN ITEM AFTER MANY POSITIONS  #
	#------------------------------------------#

	def InsertAfterManyPositions(panPos, pItem)

		# Param checks

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		# Early checks

		nLenList = This.NumberOfChars()
		if nLenList = 0
			return
		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return
		ok

		# Leaving only the accurate positions

		panPos = ring_sort(panPos)

		anPos = []
		
		for i = 1 to nLenPos
			if panPos[i] > 0 and panPos[i] < nLenList
				anPos + panPos[i]
			ok
		next

		# Doing the job

		aContent = This.Content()
		nLenPos = len(anPos)

		for i = nLenPos to 1 step -1
			ring_insert(aContent, panPos[i]+1, pItem)
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm
		
		def InsertAfterManyPositionsQ(panPos, pItem)
			This.InsertAfterManyPositions(panPos, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterThesePositions(panPos, pItem)
			This.InsertAfterManyPositions(panPos, pItem)

			def InsertAfterThesePositionsQ(panPos, pItem)
				This.InsertAfterThesePositions(panPos, pItem)
				return This

		def InsertAfterPositions(panPos, pItem)
			This.InsertAfterManyPositions(panPos, pItem)

			def InsertAfterPositionsQ(panPos, pItem)
				This.InsertAfterThesePositions(panPos, pItem)
				return This

		#>

	  #================================================#
	 #    GETTING A SECTION (OR SLICE) OF THE LIST    #
	#================================================#


	def SectionCS(n1, n2, pCaseSensitive)

		nLen = This.NumberOfItems()

		if CheckingParams()

			# Managing the use of :From and :To named params
	
			if isList(n1) and
			   StzListQ(n1).IsOneOfTheseNamedParams([
					:From, :FromPosition, :FromItemAt, :FromItemAtPosition,

					:StartingAt, :StartingAtPosition,
					:StartingAtItemAt, :StartingAtItemAtPosition,

					:Between, :BetweenPosition, :BetweenCharAt,
					:BetweenItemAtPosition,

					:BetweenPositions, :BetweenItemsAtPosition
					])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   StzListQ(n2).IsOneOfTheseNamedParams([

					:To, :ToPosition, :ToItemAt, :ToItemAtPosition,

					:Until, :UntilPosition, :UntilItemAt, :UntilItemAtPosition,

					:UpTo, :UpToPosition, :UpToItemAt, :UpToItemAtPosition,

					:And,

					:StartingAt, :StartingAtPosition, :StartingAtItemAt, :StartingAtItemAtPosition

					])
	
				n2 = n2[2]
			ok
	
			# Managing the use of :NthToFirst named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstItem ])
	
				n1 = n1[2] + 1
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstItem ])
	
				n2 = n2[2] + 1
			ok
	
			# Managing the use of :NthToLast named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastItem ])
	
				n1 = nLen - n1[2]
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastItem ])
	
				n2 = nLen - n2[2]
	
			but isList(n2) and Q(n2).IsStoppingAtNamedParam()
	
				n2 = n2[2]
			ok
	
			# Managing the case of :First and :Last keywords
	
			if isString(n1)

				if ring_find([ :First, :FirstItem ], n1) > 0

					n1 = 1
	
				but ring_find([ :Last, :LastItem ], n1) > 0

					n1 = nLen
	
				but n1 = :@
					n1 = n2

				else
					n1 = This.FindFirstCS(n1, pCaseSensitive)
				ok
			ok
		
			if isString(n2)

				if ring_find([
					:End, :Last, :LastItem, :EndOfList
				], n2) > 0

					n2 = nLen
	
				but ring_find([ :First, :FirstItem ], n2) > 0

					n2 = 1
	
				but n2 = :@
					n2 = n1

				else
					nLen2 = StzStringQ(n2).NumberOfItems()
					n2 = This.FindLastCS(n2, pCaseSensitive) + nLen2 - 1
				ok
			ok

			if n1 = :@ and n2 = :@
				n1 = 1
				n2 = nLen
			ok

			# Params must be numbers
	
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params! n1 and n2 must be numbers.")
			ok

		ok

		#NOTE: when positions are given in inversed order, the same
		# section as if they were not inverted is returned, so:
		#--> Q([ "r", "i", "n", "g" ]).Section(1,3) and .Section(3,1) both
		#    return [ "r", "i", "n" ]

		# In some languages, like Pyhton for example, reverting the positions,
		# inverts the section. So:
		#--> Q([ "r", "i", "n", "g" ]).Section(1,3) returns [ "r", "i", "n" ], but
		#    .Section(3,1) returns [ "n", "i", "r" ]

		# If you need to use this feature in Softanza, use the eXTended form
		# SectionXT(), like this :
		#--> Q([ "r", "i", "n", "g" ]).SectionXT(3,1) and it will return
		#    [ "n", "i", "r" ]

		# params must be in range

		if NOT 	( ( n1 >= 1 and n1 <= nLen ) and
			   ( n2 >= 1 and n2 <= nLen ) )
				
			StzRaise("Indexes out of range! n1 and n2 must be inside the list.")
		ok

		aContent = This.Content()
		aResult = []

		if n2 < n1
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok
		
		for i = n1 to n2
			aResult + aContent[i]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionCSQ(n1, n2, pCaseSensitive)
			return new stzList( This.SectionCS(n1, n2, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SliceCS(n1, n2, pCaseSensitive)
			return This.SectionCS(n1, n2, pCaseSensitive)

			#< @FunctionFluentForm

			def SliceCSQ(n1, n2, pCaseSensitive)
				return This.SectionCSQ(n1, n2, pCaseSensitive)

			#>
		#>	

	#-- WITHOUT CASESENSITIVITY

	def Section(n1, n2)
		return This.SectionCS(n1, n2, _TRUE_)

		def SectionQ(n1, n2)
			return new stzList(This.Section(n1, n2))

		def Slice(n1, n2)
			return This.Section(n1, n2)

			def SliceQ(n1, n2)
				return new stzList(This.Slice(n1, n2))

	  #------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE LIST -- Z/EXTENDED   #
	#------------------------------------------------------------#

	def SectionCSZ(n1, n2, pCaseSensitive)
		if CheckingParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSZ(n1, n2, pCaseSensitive)
			return This.SectionCSZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZ(n1, n2)
		return This.SectionCSZ(n1, n2, _TRUE_)

		def SliceZ(n1, n2)
			return SectionZ(n1, n2)

	  #------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE LIST -- ZZ/EXTENDED  #
	#------------------------------------------------------------#

	def SectionCSZZ(n1, n2, pCaseSensitive)
		if CheckingParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = This.NumberOfItems()
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSZZ(n1, n2, pCaseSensitive)
			return This.SectionCSZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZZ(n1, n2)
		return This.SectionCSZZ(n1, n2, _TRUE_)

		def SliceZZ(n1, n2)
			return SectionZZ(n1, n2)

	  #-------------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTended form  #
	#===================================================================#

	def SectionCSXT(n1, n2, pCaseSensitive)

		#NOTE:
		# This is an extended form of Section() that supports
		# two fency features (that we find in other languages like Python):
		# ~> n1 and n2 can be negative numbers, so their values are counted from the end
		# ~> n1 can be greater then n2, and hence the section is reversed

		#UPDATE
		# We supported the syntax SectionXT( :FromPath = [2], :ToPath = [2,2,1] )
		# as a bridge the less-obvious PathsSection() method.

		nLen = This.NumberOfItemsCS(pCaseSensitive)

		if CheckingParams()

			if isList(n1) and StzListQ(n1).IsFromPathNamedParam() and
			   isList(n2) and StzListQ(n2).IsToPathNamedParam()

				return This.PathsSection(n1, n2)
			ok

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		# Managing negative values

		if n1 < 0
			n1 = nLen + n1 + 1
			# Be careful : + n1 and not - n1 because n1 is already negative!
		ok

		if n2 < 0
			n2 = nLen + n2 + 1
		ok

		# Managing the case where n1 > n2 --> section reversed

		aResult = []

		if n1 > n2
			aResult = This.SectionCSQ(n2, n1, pCaseSensitive).Reversed()

		else
			aResult = This.SectionCS(n2, n1, pCaseSensitive)
		ok

		return aResult

		def SliceCSXT(n1, n2, pCaseSensitive)
			return This.SectionCSXT(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXT(n1, n2)
		return This.SectionCSXT(n1, n2, _TRUE_)

		def SliceXT(n1, n2)
			return This.SectionXT(n1, n2)

	  #---------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZ form  #
	#---------------------------------------------------------------#

	def SectionCSXTZ(n1, n2, pCaseSensitive)
		if CheckingParams()

			if isList(n1) and StzListQ(n1).IsFromPathNamedParam() and
			   isList(n2) and StzListQ(n2).IsToPathNamedParam()

				return This.PathsSectionZ(n1, n2)
			ok

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSXTZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZ(n1, n2)
		return This.SectionCSXTZ(n1, n2, _TRUE_)

		def SliceXTZ(n1, n2)
			return This.SectionXTZ(n1, n2)

	  #----------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZZ form  #
	#----------------------------------------------------------------#

	def SectionCSXTZZ(n1, n2, pCaseSensitive)
		if CheckingParams()

			if isList(n1) and StzListQ(n1).IsFromPathNamedParam() and
			   isList(n2) and StzListQ(n2).IsToPathNamedParam()

				return This.PathsSectionZZ(n1, n2)
			ok

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSXTZZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZZ(n1, n2)
		return This.SectionCSXTZZ(n1, n2, _TRUE_)

		def SliceXTZZ(n1, n2)
			return This.SectionXTZZ(n1, n2)

	#TODO : RangeZ(), RangeZZ(), RangeXT(), RangeXTZ(), and RangeXTZZ()

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #
	#---------------------------------------#

	def Sections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")

		ok

		if len(paSections) = 0
			return []
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

		def Slices(paSections)
			return This.Sections(paSections)

		def ManySlices(paSections)
			return This.Sections(paSections)

		#>

	  #--------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- XT  #
	#--------------------------------------------#

	def SectionsXT(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")

		ok

		if len(paSections) = 0
			return []
		ok

		aResult = []

		for aSection in paSections
			aResult + This.SectionXT( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

		#>

	  #--------------------------------------------#
	 #   GETIING THE SECTIONS BETWEEN TWO ITEMS   #
	#--------------------------------------------#

	def SectionsBetweenCS(pItem1, pItem2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "T", "A", "Y", "O", "U", "B", "T", "A" ])
		? o1.SectionsBetween( "T", :And = "A" )
		#--> [ ["T", "A"], [ "T", "A", "Y", "O", "U", "B", "T", "A" ], ["T", "A"] ]

		*/

		if CheckingParams()
	
			if isList(pItem2) and Q(pItem2).IsAndNamedParam()
				pItem2 = pItem2[2]
			ok

		ok

		anSections = []

		anPos1 = This.FindAllCS(pItem1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pItem2, pCaseSensitive) #--> [ 2, 8 ]

		#TODO
		# Use for/to instead of for/in ~> Better performance!

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		#< @FunctionAlternativeForm

		def SectionsBetweenItemsCS(pItem1, pItem2, pCaseSensitive)
			return This.SectionsBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def SectionsBetween(pItem1, pItem2)
		return This.SectionsBetweenCS(pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def SectionsBetweenItems(pItem1, pItem2)
			return This.SectionsBetween(pItem1, pItem2)

		#>

	  #--------------------------------------#
	 #  GETTING THE SECTIONS OF SAME ITEMS  #
	#--------------------------------------#

	def SectionsOfSameItemsCS(pCaseSensitive)
		/* EXAMpLE

		o1 = new stzList([ "ONE", "TWO", "TWO", "ONE", "THREE", "ONE" ])
		? o1.SectionsOfSameItems()
		#--> [
			[ "ONE", "ONE", "ONE" ],
			[ "TWO", "TWO" ],
			[ "THREE" ]
		]

		*/

		# Getting the items and their positions

		acItemsZ = This.ItemsCSZ(pCaseSensitive)
		nLen = len(acItemsZ)

		# Doing the job

		aResult = []

		for i = 1 to nLen

			aSection = []

			nLenSection = len(acItemsZ[i][2])
			for j = 1 to nLenSection
				aSection + acItemsZ[i][1]
			next

			aResult + aSection
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def SectionsOfSameItems()
		return This.SectionsOfSameItemsCS(_TRUE_)

	   #--------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND   #
	 #   RETURNING THEM AS PAIRS OF NUMBERS                         #
	#==============================================================#

	def FindAntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")

		? o1.FindAntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ [1, 2], [6, 6], [9, 10] ]

		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ ["A", "B"], ["F"], ["I", "J"] ]

		*/

		if isList(paSections) and Q(paSections).IsOfNamedParam()
			paSections = paSections[2]
		ok

		if isList(paSections) and len(paSections) = 0
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		aSorted = []
		for i = 1 to nLen
			aSorted + ring_sort(paSections[i])
		next
		#--> [ [3,5], [7,8] ]

		aAntiSections = []
		n1 = 1

		i = 0
		bLastPair = _FALSE_

		for i = 1 to nLen

			if i = nLen
				bLastPair = _TRUE_
			ok

			aPair = aSorted[i]

			if aPair[1] > n1
				n2 =  aPair[1] - 1
				aAntiSections + [ n1, n2 ]
			ok

			if NOT bLastPair
				n1 = aPair[2] + 1
			ok
		next

		nLast = aSorted[ nLen ][2]
		nLenList = This.NumberOfItems()

		if nLast < nLenList
			aAntiSections + [ nLast + 1, nLenList ]
		ok

		aResult = aAntiSections
		return aResult

		#< @FunctionFluentForm

		def FindAntiSectionsQ(paSections)
			return new stzList( This.FindAntiSections(paSections) )

		#>

		#< @FunctionAlternativeForms

		def FindAntiSectionsZZ(paSections)
			return This.FindAntiSections(paSections)

			def FindAntiSectionsZZQ(paSections)
				return This.FindAntiSectionsQ(paSections)

		def AntiSectionsZZ(paSections)
			return This.FindAntiSections(paSections)

			def AntiSectionsZZQ(paSections)
				return This.FindAntiSectionsQ(paSections)

		#>

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ ["A", "B"], ["F"], ["I", "J"] ]
		*/

		aResult = This.Sections( This.FindAntiSections(paSections) )
		return aResult

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return new stzList( This.AntiSections(paSections) )

		#>

	def FindAsSectionsAndAntiSections(paSections)
		aAntiSections = This.FindAntiSections(paSections)
		nLen = len(aAntiSections)

		for i = 1 to nLen
			aList = aAntiSections[i]
			if len(aList) = 1
				aList + aList[1]

			but len(aList) > 2
				n1 = aList[1]
				n2 = aList[len(aList)]
				aList = [n1, n2]
			ok
		next

		aAllSections = aAntiSections
		nLen = len(aAllSections)

		for i = 1 to nLen
				aAllSections + aAllSections[i]
		next

		aAllSections = StzListOfPairsQ(aAllSections).SortedInAscending()

		aResult = aAllSections
		return aResult

	def SectionsAndAntiSections(paSections)
		aAllSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections(aAllSections)
		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return new stzList( This.SectionsAntiSections(paSections) )

		#>

	   #--------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND   #
	 #   RETURNING THEM AS PAIRS OF NUMBERS  -- INCLUDING BOUNDS    #
	#--------------------------------------------------------------#

	def FindAntiSectionsIB(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")

		? o1.FindAntiSectionsIB( :Of = [ [3,5], [7,8] ])
		#--> [ [1, 3], [5, 7], [8, 10] ]

		*/

		if CheckingParams()
			if isList(paSections) and Q(paSections).IsOfNamedParam()
				paSections = paSections[2]
			ok
	
			if isList(paSections) and len(paSections) = 0
				return []
			ok
	
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
			ok
		ok

		# Doing the job

		aSorted = StzListOfPairsQ(paSections).SortedInAscending()
	
		nLen = len(aSorted)

		aAntiSectionsIB = []
		n1 = 1

		i = 0
		bLastPair = _FALSE_

		for i = 1 to nLen

			if i = nLen
				bLastPair = _TRUE_
			ok

			aPair = aSorted[i]

			if aPair[1] > n1
				n2 =  aPair[1]
				aAntiSectionsIB + [ n1, n2 ]
			ok

			if NOT bLastPair
				n1 = aPair[2]
			ok
		next

		nLast = aSorted[ nLen ][2]
		nLenList = This.NumberOfItems()

		if nLast < nLenList
			aAntiSectionsIB + [ nLast, nLenList ]
		ok

		aResult = aAntiSectionsIB
		return aResult

		#< @FunctionAlternativeForms

		def FindAntiSectionsIBZZ(paSections)
			return This.FindAntiSectionsIB(paSections)

		def AntiSectionsIBZZ(paSections)
			return This.FindAntiSectionsIB(paSections)

		#>

	def AntiSectionsIB(paSections)
		aResult = This.Sections( This.FindAntiSectionsIB(paSections) )
		return aResult

		#< @FunctionFluentForm

		def AntiSectionsIBQ(paSections)
			return new stzList( This.AntiSectionsIB(paSections) )

		#>

	def FindAsSectionsAndAntiSectionsIB(paSections)
		aAntiSectionsIB = This.FindAntiSectionsIB(paSections)
		nLen = len(aAntiSectionsIB)

		for i = 1 to nLen
			aList = aAntiSectionsIB[i]
			if len(aList) = 1
				aList + aList[1]

			but len(aList) > 2
				n1 = aList[1]
				n2 = aList[len(aList)]
				aList = [n1, n2]
			ok
		next

		aAllSectionsIB = aAntiSectionsIB
		nLen = len(aAllSectionsIB)

		for i = 1 to nLen
				aAllSections + aAllSectionsIB[i]
		next

		aAllSectionsIB = StzListOfPairsQ(aAllSectionsIB).SortedInAscending()

		aResult = aAllSectionsIB
		return aResult


	def SectionsAndAntiSectionsIB(paSections)
		aAllSectionsIB = This.FindAsSectionsAndAntiSectionsIB(paSections)
		aResult = This.Sections(aAllSectionsIB)
		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsIBQ(paSections)
			return new stzList( This.SectionsAntiSectionsIB(paSections) )

		#>

	   #--------------------------------------------------------#
	  #   FINDING THE ANTI-SECTION(S) OF A GIVEN SECTION AND   #
	 #   RETURNING IT AS A PAIR OF NUMBERS                    #
	#========================================================#

	def FindAntiSection(n1, n2)
		if NOT ( isNumber(n1) and isNumber(n2) )
			StzRaise("Incorrect param types! n1 and n2 must be both Numbers.")
		ok

		return This.FindAntiSections([ [n1, n2 ] ])

		#< @FunctionAlternativeForms

		def FindAntiSectionZZ(n1, n2)
			return This.FindAntiSection(n1, n2)

		def AntiSectionZZ(n1, n2)
			return This.FindAntiSection(n1, n2)

		#>

	def AntiSection(n1, n2)
		aResult = This.Section( This.FindAntiSection(n1, n2) )
		return aResult

		#< @FunctionFluentForm

		def AntiSectionQ(paSections)
			return new stzList( This.AntiSection(paSections) )

		#>

	   #------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SECTION AND         #
	 #   RETURNING IT AS A PAIR OF NUMBERS  -- INCLUDING BOUNDS   #
	#------------------------------------------------------------#

	def FindAntiSectionIB(n1, n2)
		if NOT ( isNumber(n1) and isNumber(n2) )
			StzRaise("Incorrect param types! n1 and n2 must be both Numbers.")
		ok

		return This.FindAntiSectionsIB([ [n1, n2 ] ])

		#< @FunctionAlternativeForms

		def FindAntiSectionIBZZ(n1, n2)
			return This.FindAntiSectionIB(n1, n2)

		def AntiSectionIBZZ(n1, n2)
			return This.FindAntiSectionIB(n1, n2)

		#>

	def AntiSectionIB(n1, n2)
		aResult = This.Section( This.FindAntiSectionIB(n1, n2) )
		return aResult

		#< @FunctionFluentForm

		def AntiSectionIBQ(paSections)
			return new stzList( This.AntiSectionIB(paSections) )

		#>

	  #===================================#
	 #    GETTING A RANGE OF THE LIST    #
	#===================================#

	def Range(pnStart, pnRange)

		# Chacking params

		if CheckingParams()
			if isString(pnStart)
				if pnStart = :First or pnStart = :FirstChar
					pnStart = 1
	
				but pnStart = :Last or pnStart = :LastChar
					pnStart = This.NumberOfItems()
				ok
			ok
	
			if NOT Q([pnStart, pnRange]).BothAreNumbers()
				StzRaise("Incorrect param type! pnStart and pnRange must be both numbers.")
			ok
		ok

		# Doing the job

		if pnStart < 0
			pnStart = This.NumberOfItems() + pnStart + 1
		ok

		if pnStart = 0 or pnRange = 0
			return _NULL_
		ok

		aResult = []

		if pnRange > 0
			aResult + This.Section( pnStart, pnStart + pnRange -1 )

		else
			n1 = pnStart + pnRange + 1

			if n1 > 0
				aResult + This.Section( n1, pnStart )
			ok	
		ok

		return aResult

		#< @FunctionFluentForms

		def RangeQ(pnStart, pnRange)
			return This.RangeQRT(pnStart, pnRange, :stzList)

		def RangeQRT(pnStart, pnRange, pcReturntype)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzList
				return new stzList( This.Range(pnStart, pnRange) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Range(pnStart, pnRange) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Range(pnStart, pnRange) )

			on :stzListOfLists
				return new stzListOfLists( This.Range(pnStart, pnRange) )

			on :stzListOfObjects
				return new stzListOfObjects( This.Range(pnStart, pnRange) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #--------------------------------------#
	 #  GETTING THE RANGE -- eXTended form  #
	#--------------------------------------#

	def RangeXT(pnStart, pnRange)
		if NOT (isNumber(pnStart) and isNumber(pnRange))
			StzRaise("Incorrect param types! pnStart and pnRange must be both numbers.")
		ok

		if NOT pnRange >= 0
			StzRaise("Incorrect param value! pnRange must be positive.")
		ok

		if pnStart < 0
			pnStart = len(@aContent) + pnStart + 1
		ok

		aSection = @RangeToSection(pnStart, pnRange)
		aResult = This.SectionXT(aSection[1], aSection[2])

		return aResult

	  #------------------------------------#
	 #   GETTING MANY RANGES OF THE LIST  #
	#------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

		#< @FunctionFluentForm

		def AntiRangesQ(paRanges)
			return new stzList( This.AntiRanges(paRanges) )

		#>

	def RangesAndAntiRanges(paRanges)
		aSections = SectionsToRanges(paRanges)
		aResult = This.SectionsAndAntiSections(aSections)
		
		return aResult

		#< @FunctionFluentForm

		def RangesAndAntiRangesQ(paRanges)
			return new stzList( This.RangesAndAntiRanges(paRanges) )

		#>

		#< @FunctionAlternativeForm

		def AllRangesIncluding(paRanges)
			return This.RangesAndAntiRanges(paRanges)

			def AllRangesIncludingQ(paRanges)
				return new stzList( This.AllRangesIncluding(paRanges) )
	
		#>

	  #---------------------------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def AntiRangesIB(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSectionsIB(aSections)

		return aResult

		def RangesOtherThanIB(paRanges)
			return This.AntiRangesIB()

		#< @FunctionFluentForm

		def AntiRangesIBQ(paRanges)
			return new stzList( This.AntiRangesIB(paRanges) )

		#>

	def RangesAndAntiRangesIB(paRanges)
		aSections = SectionsToRanges(paRanges)
		aResult = This.SectionsAndAntiSectionsIB(aSections)
		
		return aResult

		#< @FunctionFluentForm

		def RangesAndAntiRangesIBQ(paRanges)
			return new stzList( This.RangesAndAntiRangesIB(paRanges) )

		#>

		#< @FunctionAlternativeForm

		def AllRangesIncludingIB(paRanges)
			return This.RangesAndAntiRangesIB(paRanges)

			def AllRangesIncludingIBQ(paRanges)
				return new stzList( This.AllRangesIncludingIB(paRanges) )
	
		#>

	  #===================#
	 #     MULTINGUAL    #
	#===================#

	def AreLanguageAbbreviations()
		
		if NOT @IsListOfStrings(@aContent)
			return _FALSE_
		ok

		nLen = len(@aContent)
		aoStzStr = This.ToListOfStzStrings()

		bResult = _TRUE_

		for i = 1 to nLen
			if NOT aoStzStr[i].IsLanguageAbbreviation()
				bResult = _FALSE_
				exit
			ok
		next
		return bResult

		def AreLanguagesAbbreviations()
			return This.AreLanguageAbbreviations()

	def IsMultilingualString()
	     
		/* A multilingual string is a hashlist of the form:
			[
			:en = "house",
			:fr = "maison",
			:ar = ""
		     	]

		The keys of the hashlit must be language abbreviations as
		defined by LocaleLanguageAbbreviations() in stzLocale
		*/

		# The MultilingualString must be a hashlist!

		if NOT This.IsHashlist()
			return _FALSE_
		ok

		nLen = len(@aContent)

		aoKeys = []
		acValues = []

		# All values (traslations provided) must be strings

		for i = 1 to nLen
			if NOT isString(@aContent[i][2])
				return _FALSE_
			ok
		next

		# Keys must be language names or abbreviations

		for i = 1 to nLen
			aoKeys + StzStringQ(@aContent[i][1])
		next

		for i = 1 to nLen
			if NOT aoKeys[i].IsLanguageNameOrAbbreviation()
				return _FALSE_
			ok
		next

		# Otherwise, we are confident the list a multilingual string

		return _TRUE_

	def IsLocaleList()

		nLen = len(@aContent)

		if nLen = 1 and isString(@aContent[1]) and

		   ring_find([
			:Default, :DefaultLocale,
			:System, :SystemLocale, "c", "C", :CLocale

		   ], @aContent[1]) > 0

			return _TRUE_
		ok

		# The list should not exceed 3 items

		if nLen > 3
			return _FALSE_
		ok

		# It must be a hashlist

		if NOT This.IsHashList()
			return _FALSE_
		ok

		# The Hashlist must take the form:
		# 	[ :Language = "...", :Country = "...", :Script = "..." ]
		# At least one item must be provided. And one, two, or three can
		# can be provided.

		acKeys = []
		for i = 1 to nLen
			acKeys + @aContent[i][1]
		next

		bLanguage = ring_find(acKeys, "language")
		bScript = ring_find(acKeys, "script")
		bCountry = ring_find(acKeys, "country")

		if bLanguage = 0 and bScript = 0 and bCountry = 0
			return _FALSE_
		ok

		cLanguage = @aContent[ :Language ]
		cScript   = @aContent[ :Script   ]
		cCountry  = @aContent[ :Country  ]

		if NOT ( isString(cLanguage) and isString(cScript) and isString(cCountry) )
			return _FALSE_
		ok

		if cLanguage = _NULL_ and cScript = _NULL_ and cCountry = _NULL_
			return _FALSE_
		ok

		if cLanguage != _NULL_ and
		   NOT StzStringQ(cLanguage).IsLanguageIdentifier()
			return _FALSE_
		ok

		if cScript != _NULL_ and
		   NOT StzStringQ(cScript).IsScriptIdentifier()
			return _FALSE_
		ok

		if cCountry != _NULL_ and
		   NOT StzStringQ(cCountry).IsCountryIdentifier()
			return _FALSE_
		ok

		# At this level we are sure it is a language identification list
		return _TRUE_

	  #----------------------------------------#
	 #   DISTRIBUTING THE ITEMS OF THE LIST   #
	#----------------------------------------#

	def DistributeOverXT( acBeneficiaryItems, anShareOfEachItem )

		/* Explanation
	
		Distributes the items of the main list over the items of the
		provided list, called metaphorically 'Beneficiary Items'
		(anShareOfEachItem) here as they 'benfit' from that distribution).
		
		The distribution is defined by the share of each item.
		
		The share of each item, defined by a list of numbers (anShareOfEachItem),
		determines how many items should be given to the beneficiaries.
		
		--> The beneficiary items can be of any type. In practice, they are
		strings and hence the returned result is a hashlist as demonstrated by
		the following example:
	
		o1 = new stzList([ :water, :coca, :milk, :spice, :cofee, :tea, :honey ] )
		? o1.DistributeOverXT([ :arem, :mohsen, :hamma ], :Using = [ 2, 3, 2 ] )
	
		Gives:
	
		[
			:arem   = [ :water, :coca ],
			:mohsen = [ :milk, :spice, :cofee ],
			:hamma  = [ :tea, honey ]
		]
	
		*/

		if isList(anShareOfEachItem) and Q(anShareOfEachItem).IsUsingNamedParam()
			anShareOfEachItem = anShareOfEachItem[2]
		ok

		# The acBeneficiaryItems param should be non empty list of items:

		if NOT ( isList(acBeneficiaryItems) and  len( acBeneficiaryItems) > 0 )
			StzRaise(stzListError(:CanNoteDistributeItemsOverTheList1))
		ok

		# Controlling the validity of the syntax of anShareOfEachItem param

		if NOT ( isList(anShareOfEachItem) and
			 Q(anShareOfEachItem).IsListOfNumbers() and
			 len(anShareOfEachItem) > 0 )
			 StzRaise("Incorrect param! anShareOfEachItem must be a non empty list of numbers.")
		ok

		# The sum of numbers in anShareOfEachItem should be equal to the
		# number of items of the main list

		if NOT Sum(anShareOfEachItem) = This.NumberOfItems()
			StzRaise(stzListError(:CanNoteDistributeItemsOverTheList2))
		ok

		# Now, we can perform the distribution

		aResult = []

		nLen = len(acBeneficiaryItems)
		n1 = 1

		for i = 1 to nLen

			cBenef = acBeneficiaryItems[i]
			nRange = anshareOfEachItem[i]
			n2 = n1 + nRange - 1

			aShare = []

			for j = n1 to n2
				aShare + @aContent[j]
			next

			aResult + [ cBenef, aShare ]
			n1 = n2 + 1


		next
		
		return aResult
	
	def DistributeOver( acBeneficiaryItems )
		nLenList = This.NumberOfItems()
		nLenBenef = len(acBeneficiaryItems)

		anShare = []

		if nLenBenef >= nLenList
			for i = 1 to nLenList
				anShare + 1
			next

		else
			n = floor( nLenList / nLenBenef )

			for i = 1 to nLenBenef	
				anShare + n
			next

			nRest = nLenList - ( n * nLenBenef )

			if nRest > 0
				for i = 1 to nRest
					anShare[i]++
				next
			ok
			
		ok

		aResult = This.DistributeOverXT( acBeneficiaryItems, :Using = anShare)
		return aResult

	  #=======================#
	 #     GETTING TYPES     #
	#=======================#

	# Deeling wuth the list itself

	def IsStzList()
		return _TRUE_

	def StzType()
		return :stzList


	  #----------------------------------------------#
	 #  GETTING THE TYPES OF EACH ITEM IN THE LIST  #
	#----------------------------------------------#

	def Types()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			aResult + ring_type(aContent[i])
		next

		return aResult

	def TypesXT()
		aResult = This.ListQ().AssociatedWith( This.Types() )
		return aResult

		def ItemsAndTypes()
			return This.TypesXT()

		def ItemsAndTheirTypes()
			return This.TypesXT()

	def UniqueTypes()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if ring_find(aResult, ring_type(aContent[i])) = 0
				aResult + ring_type(aContent[i])
			ok
		next

		return aResult

		def TypesU()
			return This.UniqueTypes()

		def TypesWithoutDuplication()
			return This.UniqueTypes()

	def TypesAndTheirPositions()
		acTypes = This.TypesU()
		nLen = len(acTypes)

		aResult = []

		for i = 1 to nLen

			cType = lower(acTypes[i])

			if  cType = "number"
				aResult + [ :Number, This.FindNumbers() ]

			but cType = "string"
				aResult + [ :String, This.FindStrings() ]

			but cType = "list"
				aResult + [ :List, This.FindLists() ]

			but cType = "object"
				aResult + [ :Object, This.FindObjects() ]
			ok

		next
		
		return aResult

		def TypesZ()
			return This.TypesAndTheirPositions()

	def TypesAndTheirSections()
		acTypes = This.TypesU()
		nLen = len(acTypes)

		aResult = []

		for i = 1 to nLen

			cType = lower(acTypes[i])

			if  cType = "number"
				aResult + [ :Number, This.FindNumbersZZ() ]

			but cType = "string"
				aResult + [ :String, This.FindStringsZZ() ]

			but cType = "list"
				aResult + [ :List, This.FindListsZZ() ]

			but cType = "object"
				aResult + [ :Object, This.FindObjectsZZ() ]
			ok

		next
		
		return aResult

		def TypesZZ()
			return This.TypesAndTheirSections()

	  #-------------------------------------------------------#
	 #  GETTING THE SOFTANZA TYPES OF EACH ITEM IN THE LIST  #
	#-------------------------------------------------------#
	# For non softanza objects a _NULL_ is returned

	def StzTypes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			if isObject(aContent[i]) and aContent[i].IsStzObject()
				aResult + aContent[i].StzType()
			else
				aResult + _NULL_
			ok
		next

		return aResult

	def StzTypesXT()
		aResult = This.ListQ().AssociatedWith( This.StzTypes() )
		return aResult

	def UniqueStzTypes()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if ring_find(aResult, Q(aContent[i]).StzType()) = 0
				aResult + Q(aContent[i]).StzType()
			ok
		next

		return aResult

		def StzTypesU()
			return This.UniqueStzTypes()

		def StzTypesWithoutDuplication()
			return This.StzUniqueTypes()

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A GIVEN SUBLIST OF ITEMS  #
	#-------------------------------------------------------------#

	def StartsWithCS(paItems, pCaseSensitive)

		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = This.NumberOfItems()
		nLenItems = len(paItems)

		if nLenItems > nLen
			return _FALSE_
		ok

		if This.IsStrictlyEqualToCS(paItems, pCaseSensitive)
			return _TRUE_
		ok

		bResult = _TRUE_
		aContent = This.Content()

		for i = 1 to nLenItems
			if NOT Q(aContent[i]).IsEqualToCS(paItems[i], pCaseSensitive)
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def BeginsWithCS(paItems, pCaseSensitive)
			return This.StartsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(paItems)
		return This.StartsWithCS(paItems, _TRUE_)

		def BeginsWith(paItems)
			return This.StartsWith()

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST ENDS WITH A GIVEN SUBLIST OF ITEMS  #
	#-----------------------------------------------------------#

	def EndsWithCS(paItems, pCaseSensitive)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLenItems = len(paItems)
		nLen = This.NumberOfItems()

		if nLenItems > nLen
			return _FALSE_
		ok

		if This.IsStrictlyEqualToCS(paItems, pCaseSensitive)
			return _TRUE_
		ok

		bResult = _TRUE_
		
		aLastItems = This.NLastItems( nLenItems )
		nLenLastItems = len(aLastItems)
		aContent = This.Content()

		for i = 1 to nLenLastItems

			if NOT Q(aContent[i]).IsEqualToCS(aLastItems[i], pCaseSensitive)
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		def FinishesWithCS(paItems, pCaseSensitive)
			return This.EndsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(paItems)
		return This.EndsWithCS(paItems, _TRUE_)

		def FinishesWith(paItems)
			return This.EndsWith(paItems)

	  #===========================================#
	 #  CHECKING IF THE LIST STARTS WITH A LIST  #
	#===========================================#

	def StartsWithList()
		if len(@aContent) = 0
			return _FALSE_
		ok

		if isList(@aContent[1])
			return _TRUE_
		else
			return _FALSE_
		ok

		def StartsWithAList()
			return This.StartsWithList()

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A NUMBER  #
	#---------------------------------------------#

	def StartsWithNumber()
		if len(@aContent) = 0
			return _FALSE_
		ok

		if isNumber(@aContent[1])
			return _TRUE_
		else
			return _FALSE_
		ok

		def StartsWithANumber()
			return This.StartsWithNumber()

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A STRING  #
	#---------------------------------------------#

	def StartsWithString()
		if len(@aContent) = 0
			return _FALSE_
		ok

		if isString(@aContent[1])
			return _TRUE_
		else
			return _FALSE_
		ok

		def StartsWithAString()
			return This.StartsWithString()

	  #----------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH AN OBJECT  #
	#----------------------------------------------#

	def StartsWithObject()
		if len(@aContent) = 0
			return _FALSE_
		ok

		if isObject(@aContent[1])
			return _TRUE_
		else
			return _FALSE_
		ok

		def StartsWithAnObject()
			return This.StartsWithObject()

	  #===========================================#
	 #  CHECKING IF THE LIST STARTS WITH A LIST  #
	#===========================================#

	def EndsWithList()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		if isList(@aContent[nLen])
			return _TRUE_
		else
			return _FALSE_
		ok

		def EndsWithAList()
			return This.EndsWithList()

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A NUMBER  #
	#---------------------------------------------#

	def EndsWithNumber()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		if isNumber(@aContent[nLen])
			return _TRUE_
		else
			return _FALSE_
		ok

		def EndsWithANumber()
			return This.EndsWithNumber()

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A STRING  #
	#---------------------------------------------#

	def EndsWithString()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		if isString(@aContent[nLen])
			return _TRUE_
		else
			return _FALSE_
		ok

		def EndsWithAString()
			return This.EndsWithString()

	  #----------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH AN OBJECT  #
	#----------------------------------------------#

	def EndsWithObject()
		nLen = len(@aContent)
		if nLen = 0
			return _FALSE_
		ok

		if isObject(@aContent[nLen])
			return _TRUE_
		else
			return _FALSE_
		ok

		def EndsWithAnObject()
			return This.EndsWithObject()

	  #==============================================#
	 #  GETTING THE SIZES OF THE ITEMS OF THE LIST  #
	#==============================================#

	def Sizes()
		nLen = len(@aContent)
		anResult = []

		for i = 1 to nLen
			nSize = 0

			if isNumber(@aContent[i])
				nSize = StzNumberQ(@aContent[i]).
					StringValueQ().NumberOfChars()

			but isString(@aContent[i])
				oQString = new qstring2()
				oQString.append(@aContent[i])
				nSize = oQString.size()

			but isList(@aContent[i])
				nSize = len(@aContent[i])

			else
				if @IsStzObject(@aContent[i])
					nSize = @aContent[i].Size()
				ok
			ok

			anResult + nSize
		next

		return anResult

	def MaxSize()
		nResult = @Max(This.Sizes())
		return nResult

		def LargestSize() # Note this is different from LargestItem()
			return This.MaxSize()

	def MinSize()
		nResult = @Min(This.Sizes())
		return nResult

		def SmallestSize() # Note this is different from SmallestItem()
			return This.MinSize()

	  #==========================================#
	 #  SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#==========================================#

	def SmallestItem()

		if This.NumberOfItems() > 1
			aSorted = This.SortedInAscending()
			return aSorted[1]

		ok

		def Smallest()
			return This.SmallestItem()

	def LargestItem()
		if This.NumberOfItems() > 1
			aSorted = This.SortedInDescending()
			return aSorted[1]
		ok

		def Largest()
			return This.LargestItem()

		def GreatestItem()
			return This.LargestItem()

		def Greatest()
			return This.LargestItem()

	  #--------------------------------------------------#
	 #  FINDING SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#--------------------------------------------------#

	def FindSmallestItem()
		return This.FindAll( This.SmallestItem() )

		def FindSmallest()
			return This.FindSmallestItem()

		def FindAllOccurrencesOfSmallestItem()
			return This.FindSmallestItem()

		def FindAllOccurrencesOfSmallest()
			return This.FindSmallestItem()

	def FindLargestItem()
		return This.FindAll( This.LargestItem() )

		def FindLargest()
			return This.FindLargestItem()

		def FindAllOccurrencesOfLargestItem()
			return This.FindLargestItem()

		def FindAllOccurrencesOfLargest()
			return This.FindLargestItem()

	  #-------------------------------------------------------------------#
	 #  NUMBER OF OCCURRENCES OF SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#-------------------------------------------------------------------#

	def NumberOfOccurrencesOfSmallestItem()
		return len( This.FindAllOccurrencesOfSmallestItem() )

		def NumberOfOccurrenceOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfOccurrencesOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfOccurrenceOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def CoutOccurrencesOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def HowManyOccurrencesOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def HowManyOccurrenceOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

	def NumberOfOccurrencesOfLargestItem()
		return len( This.FindAllOccurrencesOfLargestItem() )

		def NumberOfOccurrenceOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfOccurrencesOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfOccurrenceOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def CoutOccurrencesOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def HowManyOccurrencesOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def HowManyOccurrenceOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

	  #--------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#--------------------------------------------------------------------#

	def FindNthOccurrenceOfSmallestItem(n)
		if CheckingParams()
			if isString(n)

				if n = :First Or n = :FirstItem
					n = 1

				but n = :Last Or n = :LastItem
					n = This.NumberOfOccurrencesOfSmallestItem()
				ok
			ok
		ok

		return This.FindAll( This.SmallestItem() )[n]

		def FindNthOccurrenceOfSmallest(n)
			return This.FindNthSmallestItem(n)

	def FindNthOccurrenceOfLargestItem(n)
		if CheckingParams()
			if isString(n)
				if n = :First Or n = :FirstItem
					n = 1

				but n = :Last Or n = :LastItem
					n = This.NumberOfOccurrencesOfLargestItem()
				ok
			ok
		ok

		return This.FindAll( This.LargestItem() )[n]

		def FindNthOccurrenceOfLargest(n)
			return This.FindNthLargestItem(n)

		def FindNthOccurrenceOfGreatestItem(n)
			return This.FindNthLargestItem(n)

		def FindNthOccurrenceOfGreatest(n)
			return This.FindNthLargestItem(n)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSTS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				return This.FindBeforeItemCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindBeforePositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				return This.FindAfterItemCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAfterPositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitive)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				n = This.FindFirstCS(p2[2], pCaseSensitive)
				return This.FindBeforePositionCS( p1[2], n, pCaseSensitive)

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindBeforePositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				n = This.FindLastCS(p2[2], pCaseSensitive)
				return This.FindAfterPositionCS( p1[2], n, pCaseSensitive)


			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and ring_find([ :Any, :AnySubString ], p1) > 0 and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindCSXT(p1, p2, _TRUE_)

	  #=====================================================#
	 #  FINDING OCCURRENCES OF AN ITEM IN A GIVEN SECTION  #
	#=====================================================#

	def FindInSectionCS(pItem, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckingParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)

				if ring_find([ :First, :FirstItem ], n1) > 0
					n1 = 1
				but ring_find([ :Last, :LastItem ], n1) > 0
					n1 = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)

				if ring_find([ :Last, :LastItem ], n2) > 0
					n2 = This.NumberOfItems()

				but ring_find([ :First, :FirstItem ], n2) > 0
					n2 = 1
				ok

			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		anPos = This.SectionQ(n1, n2).FindCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		n1 = Min([ n1, n2 ])

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

		#< @FunctionAlternativeForm

		def FindInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pItem, n1, n2)
		return This.FindInSectionCS(pItem, n1, n2, _TRUE_)
		
		#< @FunctionAlternativeForm

		def FindInSectionZ(pItem, n1, n2)
			return This.FindInSection(pItem, n1, n2)

		#>

	  #---------------------------------------------------#
	 #  FINDING OCCURRENCES OF AN ITEM IN MANY SECTIONS  #
	#---------------------------------------------------#

	def FindInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + anPos[j]
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		#==

		def FindItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindItemInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindItemInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindItemInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pItem, paSections)
		return This.FindInSectionsCS(pItem, paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindInManySections(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		#--

		def FindInSectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		def FindInManySectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		#==

		def FindItemInSections(pItem, paSections)
			return This.FindInSectionsCS(pItem, paSections)

		def FindItemInManySections(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		def FindItemInSectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		def FindItemInManySectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#========================================================#

	def FindNthInSectionCS(n, pItem, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckingParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)

				if ring_find([ :First, :FirstItem ], n1) > 0
					n1 = 1
				but ring_find([ :Last, :LastItem ], n1) > 0
					n1 = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)

				if ring_find([ :Last, :LastItem ], n2) > 0
					n2 = This.NumberOfItems()
				but ring_find([ :First, :FirstItem ], n2) > 0
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		nPos = This.SectionQ(n1, n2).FindNthCS(n, pItem, pCaseSensitive)
		nResult = n1 + nPos - 1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthInSectionCSZ(n, pItem, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSection(n, pItem, n1, n2)
		return This.FindNthInSectionCS(n, pItem, n1, n2, _TRUE_)
		
		#< @FunctionAlternativeForm

		def FindNthInSectionZ(n, pItem, n1, n2)
			return This.FindNthInSection(n, pItem, n1, n2)

		#>

	  #------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#------------------------------------------------------#

	def FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		nResult = 0
		nCounter = 0

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				nCounter++
				if nCounter = n
					nResult = anPos[j]
					exit
				ok
			next
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthInManySectionsCS(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		#--

		def FindNthInSectionsCSZ(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZ(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSections(n, pItem, paSections)
		return This.FindNthInSectionsCS(n, pItem, paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthInManySections(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		#--

		def FindNthInSectionsZ(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		def FindNthInManySectionsZ(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#==========================================================#

	def FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pItem, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSectionCS(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		def FindFristInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSection(pItem, n1, n2)
		return This.FindFirstInSectionCS(pItem, n1, n2, _TRUE_)
		
		#< @FunctionAlternativeForm

		def FindFirstInSectionZ(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSection(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		def FindFristInSectionZ(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#--------------------------------------------------------#

	def FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindFirstInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindFirstInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFristInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindFristInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFristInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSections(pItem, paSections)
		return This.FindFirstInSectionsCS(pItem, paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindFirstInManySections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#--

		def FindFirstInSectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFirstInManySectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFristInManySections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#--

		def FindFristInSectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFristInManySectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#=========================================================#

	def FindLastInSectionCS(pItem, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pItem, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSection(pItem, n1, n2)
		return This.FindLastInSectionCS(pItem, n1, n2, _TRUE_)
		
		#< @FunctionAlternativeForm

		def FindLastInSectionZ(pItem, n1, n2)
			return This.FindLastInSection(pItem, n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#-------------------------------------------------------#

	def FindLastInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckingParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QRT(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindLastInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindLastInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSections(pItem, paSections)
		return This.FindLastInSectionsCS(pItem, paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastInManySections(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		#--

		def FindLastInSectionsZ(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		def FindLastInManySectionsZ(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		#>

	  #====================================================================================#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN POSITION OR A GIVEN OTHER ITEM  #
	#====================================================================================#

	def FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		if CheckingParams()
			if isList(pPosOrItem) and Q(pPosOrItem).IsPositionNamedParam()
				return This.FindbeforePositionCS(pItem, pPosOrItem[2], pCaseSensitive)
			ok
		ok

		return This.FindBeforeItemCS(pItem, pPosOrItem, pCaseSensitive)


		#< @FunctionAlternativeForms

		def FindAllBeforeCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesBeforeCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		#--

		def FindBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindAllBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBefore(pItem, pPosOrItem)
		return This.FindBeforeCS(pItem, pPosOrItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllBefore(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindOccurrencesBefore(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		#--

		def FindBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindAllBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindOccurrencesBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN POSITION  #
	#==============================================================# 

	def FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		anResult = This.FindInSectionCS(pItem, 1, pnPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePosition(pItem, pnPos)
		return This.FindBeforePositionCS(pItem, pnPos, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllBeforePosition(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindOccurrencesBeforePosition(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		#--

		def FindBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindAllBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindOccurrencesBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		#>

	  #----------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN OTHER ITEM  #
	#================================================================# 

	def FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, 1, nPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeItem(pItem, pcOtherSubStr)
		return This.FindBeforeItemCS(pItem, pcOtherSubStr, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllBeforeItem(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindOccurrencesBeforeItem(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		#--

		def FindBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindAllBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindOccurrencesBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		#>

	  #============================================================================#
	 #  FINDING THE OCCURRENCES OF A ITEM AFTER A GIVEN POSITION OR A GIVEN ITEM  #
	#============================================================================#

	def FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		if isList(pPosOrItem) and Q(pPosOrItem).IsPositionNamedParam()
			return This.FindAfterPositionCS(pItem, pPosOrItem[2], pCaseSensitive)
		else
			return This.FindAfterItemCS(pItem, pPosOrItem, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesAfterCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		#--

		def FindAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindAllAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfter(pItem, pPosOrItem)
		return This.FindAfterCS(pItem, pPosOrItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllAfter(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindOccurrencesAfter(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		#--

		def FindAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindAllAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindOccurrencesAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM AFTER A GIVEN POSITION  #
	#=============================================================# 

	def FindAfterPositionCS(pItem, pnPos, pCaseSensitive)
		nLen = This.NumberOfItems()
		if nLen = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, pnPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPosition(pItem, pnPos)
		return This.FindAfterPositionCS(pItem, pnPos, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllAfterPosition(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindOccurrencesAfterPosition(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		#--

		def FindAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindAllAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindOccurrencesAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A NITEM AFTER A GIVEN OTHER ITEM  #
	#===============================================================# 

	def FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfItems()
		if nLen = 0
			return 0
		ok

		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, nPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterItem(pItem, pcOtherSubStr)
		return This.FindAfterItemCS(pItem, pcOtherSubStr, _TRUE_)

		#< @FunctionAlternativeForms

		def FindAllAfterItem(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindOccurrencesAfterItem(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		#--

		def FindAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindAllAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindOccurrencesAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		#>

	  #==================================================================#
	 #  GETTING NUMBER OF OCCURRENCES OF AN ITEM IN THE GIVEN SECTIONS  #
	#==================================================================#

#TODO // Add
#	FindNearest("hi", :To = "emm")
#	FindNearest("hi", :ToPositio = 10)

	def NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		nResult = len( This.FindItemInSectionsCS(pItem, paSections, pCaseSensitive) )
		return nResult

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrenceInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrenceOfItemInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesOfItemInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrencesInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrenceOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrencesOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def CountInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def CountItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceInSections(pItem, paSections)
		return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, _TRUE_)

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrenceInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrenceOfItemInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesOfItemInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrenceInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrencesInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrenceOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrencesOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def CountInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def CountItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		#>

	  #======================================================#
	 #  GETTING NTH SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#======================================================#

	def NthSmallestItem(n)
		return This.Copy().RemoveDuplicatesQ().SortedInAscending()[n]

		def NthSmallest(n)
			return This.NthSmallestItem(n)

	def NthLargestItem(n)
		return This.Copy().RemoveDuplicatesQ().SortedInDescending()[n]

		def NthLargest(n)
			return This.NthLargestItem(n)

		def NthGreatestItem(n)
			return This.NthLargestItem(n)

		def NthGreatest(n)
			return This.NthLargestItem(n)

	  #------------------------------------------------------#
	 #  FINDING NTH SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#------------------------------------------------------#

	def FindNthSmallestItem(n)
		return This.FindAll( This.NthSmallestItem(n) )

		def FindNthSmallest(n)
			return This.FindNthSmallestItem(n)

	def FindNthLargestItem(n)
		return This.FindAll( This.NthLargestItem(n) )

		def FindNthLargest(n)
			return This.FindNthLargestItem(n)

		def FindNthGreatestItem(n)
			return This.FindNthLargestItem(n)

		def FindNthGreatest(n)
			return This.FindNthLargestItem(n)

	  #-------------------------------#
	 #  FINDING OBJECTS IN THE LIST  #
	#===============================#

	def FindObjects()
		
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				anResult + i
			ok
		next

		return anResult
			
		def FindObjectsZ()
			return This.FindObjects()

	def FindObjectsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isObject(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isObject(aContent[i]) and NOT isObject(aContent[i-1])
				n1 = i
			ok

			if isObject(aContent[i]) and NOT isObject(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindObjectsZZ()
			return This.FindObjectsAsSections()

	def ObjectsZ()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		acSeen = []
		for i = 1 to nLen	
			if NOT isObject(aContent[i])
				i++
			ok

			cName = :@NoName

			if ObjectIsStzObject(aContent[i])
				cName = aContent[i].VarName()
			ok

			if ring_find(acSeen, cName)
				loop
			ok

			anPos = This.FindObject(cName)
			aResult + [ cName, anPos ]
			acSeen + cName

		next

		return aResult

		def ObjectsAndTheirPositions()
			return This.Objects()

	def TheseObjectsZ(paoObjects)

		if CheckingParams() = _TRUE_
			if NOT ( isList(paoObjects) and Q(paoObjects).EachItemIsEitherA(:String, :Or, :Object) )
				StzRaise("Incorrect param type! paoObjects must be a list of strings and objects.")
			ok
	
		ok

		# Doing the job

		nLen = len(paoObjects)
		aResult = []
		acSeen = []

		for i = 1 to nLen
			if isObject(paoObjects[i])
				cName = @ObjectVarName(paoObjects[i])
			else
				cName = paoObjects[i]
			ok

			if ring_find(acSeen, cName) = 0
				anPos = This.FindObject(cName)
				aResult + [ cName, anPos ]
				acSeen + cName
			ok
		next


		return aResult

	  #-----------------------------------------------#
	 #  FINDING NAMED & UNNAMED OBJECTS IN THE LIST  #
	#===============================================#

	def FindNamedObjects()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				loop
			ok

			if @ObjectVarName(aContent[i]) != :@NoName
				anResult + i
			ok
		next

		return anResult

	def FindUnnamedObjects()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				loop
			ok

			if @ObjectVarName(aContent[i]) = :@NoName
				anResult + i
			ok
		next

		return anResult

	def FindNamedObject(p) # pass an object or an object name in string

		cObjectVarName = :@NoName
		if isObject(p)
			cObjectVarName = p.VarName()
		but isString(p)
			cObjectVarName = p
		else
			StzRaise("Incorrect param type! p must be an object or a string containing an object varname.")
		ok

		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and
			   aContent[i].VarName() = cObjectVarName

				anResult + i
				
			ok
		next

		return anResult

		def FindThisNamedObject(p)
			return This.FindNamedObject(p)

		def FindObject(p)
			return This.FindNamedObject(p)

		def FindThisObject(p)
			return This.FindNamedObject(p)

	def NamedObjectZ(paObject)
		if CheckingParams()
			if NOT isObject(paObject) 
				StzRaise("Incorrect param type! paObject must be a list.")
			ok
		ok

		anPos = This.FindNamedObject(paObject)
		aResult = [ paObject, anPos ]	
		return aResult

	  #----------------------#
	 #  FINDING STZNUMBERS  #
	#======================#

	def FindStzNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzNumber(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzNumber(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #----------------------#
	 #  FINDING STZSTRINGS  #
	#======================#

	def FindStzStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzString(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzString(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #---------------------#
	 #  FINDING STZLISTSS  #
	#=====================#

	def FindStzLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzList(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzList(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #----------------------#
	 #  FINDING STZOBJECTS  #
	#======================#

	def FindStzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzObject(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	def StzObjectsZ() #TODO
		raise("Not implemented yet!")

	  #--------------------------#
	 #  FINDING NON-STZOBJECTS  #
	#==========================#

	def FindNonStzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and NOT @IsStzObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def NonStzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and NOT @IsStzObject(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	def NonStzObjectsZ() #TODO
		raise("Not implemented yet!")

	  #--------------------#
	 #  FINDING QOBJECTS  #
	#====================#

	def FindQObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and @IsQObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def QObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and @IsQObject(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	def QObjectsZ() #TODO
		raise("Not implemented yet!")

	  #=================================================#
	 #  GETTING THE LIST OF NAMED OBJECTS IN THE LIST  #
	#=================================================#

	def NamedObjects()
		aContent = This.Content()
		nLen = len(aContent)

		aoResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and @IsNamedObject(aContent[i])
				aoResult + aContent[i]
			ok
		next

		return aoResult

	def UniqueNamedObjects()
		aoResult = U( This.NamedObjects() )
		return aoResult

		def UNamedObjects()
			return This.UniqueNamedObjects()

	  #------------------------------------------------------#
	 #  GETTING THE NAMES OF THE NAMED-OBJECTS IN THE LIST  #
	#======================================================#

	def ObjectsVarNames()
		aContent = This.Content()
		nLen = len(aContent)

		acResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and @IsNamedObject(aContent[i])
				acResult + aContent[i].VarName()
			ok
		next

		return acResult

	def ObjectsVarNamesU()
		return U( This.ObjectsVarNames() )

		def UniqueObjectsVarNames()
			return This.ObjectsVarNamesU()

	def NumberOfNamedObjects()
		aContent = This.Content()
		nLen = len(aContent)

		n = 0

		for i = 1 to nLen
			if isObject(aContent[i]) and @IsNamedObject(aContent[i])
				n++
			ok
		next

		return n

		def HowManyNamedObjects()
			return This.NumberOfNamedObjects()

		def HowManyNamedObject()
			return This.NumberOfNamedObjects()

	def NumberOfUniqueNamedObjects()
		nResult = len( This.UniqueNamedObjects() )
		return nResult

		def HowManyUniqueNamedObjects()
			return This.NumberOfUniqueNamedObjects()

		def HowManyUniqueNamedObject()
			return This.NumberOfUniqueNamedObjects()

		#--

		def NumberOfUNamedObjects()
			return This.NumberOfUniqueNamedObjects()

		def HowManyUNamedObjects()
			return This.NumberOfUniqueNamedObjects()

		def HowManyUNamedObject()
			return This.NumberOfUniqueNamedObjects()

	  #===========================================================#
	 #  CHECKING IF THE LIST CONTAINS JUST STRINGS IN UPPERCASE  #
	#===========================================================#

	def IsUppercase()
		if This.IsListOfStrings()
		   	acContent = This.ToListOfStzStrings()
			nLen = len(acContent)

			bResult = _TRUE_

			for i = 1 to nLen
				if acContent[i].IsUppercase() = _FALSE_
					bResult = _FALSE_
					exit
				ok
			next

			return bResult

		else
			return _FALSE_
		ok

		#< @FunctionFluentForm

		def IsUppercaseQ()
			if This.IsUppercase()
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsAnUppercase()
			return This.IsUppercase()

			def IsAnUppercaseQ()
				return This.IsUppercaseQ()

		def IsUppercased()
			return This.IsUppercase()

			def IsUppercasedQ()
				return This.IsUppercaseQ()

		def IsUpper()
			return This.IsUppercase()

			def IsUpperQ()
				return This.IsUppercaseQ()

		def IsInUppercase()
			return This.IsUppercase()

			def IsInUppercaseQ()
				return This.IsUppercaseQ()

		def InUppercase()
			return This.IsUppercase()

			def InUppercaseQ()
				return This.IsUppercaseQ()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS JUST STRINGS IN LOWERCASE  #
	#-----------------------------------------------------------#

	def IsLowercase()
		if This.IsListOfStrings()
		   	acContent = This.ToListOfStzStrings()
			nLen = len(acContent)

			bResult = _TRUE_

			for i = 1 to nLen
				if acContent[i].IsLowercase() = _FALSE_
					bResult = _FALSE_
					exit
				ok
			next

			return bResult

		else
			return _FALSE_
		ok

		#< @FunctionFluentForm

		def IsLowercaseQ()
			if This.IsLowercase()
				return This
			else
				return AFalseObject()
			ok


		#>

		#< @FunctionAlternativeForms

		def IsALowercase()
			return This.IsLowercase()

			def IsALowercaseQ()
				return This.IsLowercaseQ()

		def IsLowercased()
			return This.IsLowercase()

			def IsLowercasedQ()
				return This.IsLowercaseQ()

		def IsLower()
			return This.IsLowercase()

			def IsLowerQ()
				return This.IsLowercaseQ()

		def InLowerCase()
			return This.IsLowercase()

			def InLowercaseQ()
				return This.IsLowercaseQ()
	
		def IsInLowerCase()
			return This.IsLowercase()

			def IsInLowercaseQ()
				return This.IsLowercaseQ()

		#>

		#< @FunctionNegativeForms

		def IsNotLowercase()
			return NOT This.IsLowercase()

		def IsNotLowercased()
			return This.IsNotLowercase()

		def IsNotLower()
			return This.IsNotLowercase()

		def IsNotInLowercase()
			return This.IsNotLowercase()

		def IsNotInALowercase()
			return This.IsNotLowercase()

		#>

	  #------------------------------------------------------------#
	 #  TRANSFORMING THE LIST TO ITS REPRESENTATION IN RING CODE  #
	#------------------------------------------------------------#

	def ToCode()
		cResult = @@( This.Content() )
		return cResult

		def ToCodeQ()
			return new stzString(This.ToCode())

	  #------------------------------------------------------------------#
	 #  STRINGIFYING THE LIST (ALL ITEMS ARE FORCED TO BECOME STRINGS)  #
	#------------------------------------------------------------------#
	#TODO // Abstract this function in stzObject

	def Stringify()

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for @i = 1 to _nLen_

			if isString(_aContent_[@i])
				loop

			but isNumber(_aContent_[@i])
				_aContent_[@i] = ""+ _aContent_[@i]

			but isList(_aContent_[@i])
				_aContent_[@i] = @@(_aContent_[@i])

			but isObject(_aContent_[@i])
				_aContent_[@i] = @ObjectVarName(_aContent_[@i])
			ok

		next

		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def StringifyQ()
			This.Stringify()
			return This

		def StringifyQRT(pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.Stringified() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def StringifyItems()
			This.Stringify()

			def StringifyItemsQ()
				return This.StringifyQ()

			def StringifyItemsQRT(pcReturnType)
				return This.StringifyQRT(pcReturnType)

		#>

	def Stringified()
		_acResult_ = This.Copy().StringifyQ().Content()
		return _acResult_

		def ItemsStringified()
			return This.Stringified()

		def ToListOfStringifiedItems()
			return This.Stringified()

	  #--------------------------------------#
	 #  STRINGIFYING THE LISTS IN THE LIST  #
	#--------------------------------------#

	def StringifyLists()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for @i = 1 to _nLen_
			if isList(_aContent_[@i])
				_aContent_[@i] = @@(_aContent_[@i])	
			ok
		next

		This.UpdateWith(_aContent_)

		def StringifylistsQ()
			This.Stringifylists()
			return This

	def ListsStringified()
		_aResult_ = This.Copy().StringifyListsQ().Content()
		return _aResult_

	  #----------------------------------------#
	 #  STRINGIFYING THE OBJECTS IN THE LIST  #
	#----------------------------------------#

	def StringifyObjects()

		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for i = 1 to _nLen_
			if isObject(_aContent_[@i])
				_aContent_[@i] = @ObjectVarName(_aContent_[@i])	
			ok
		next

		This.UpdateWith(_aContent_)

		def StringifyObjectsQ()
			This.StringifyObjects()
			return This

	def ObjectsStringified()
		_aResult_ = This.Copy().StringifyObjectsQ().Content()
		return _aResult_

	  #----------------------------------------------#
	 #  STRINGIFYING THE NAMED OBJECTS IN THE LIST  #
	#----------------------------------------------#

	def StringifyNamedObjects()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		for @i = 1 to _nLen_
			if @IsNamedObject(_aContent_[@i])
				_aContent_[@i] = @ObjectVarName(_aContent_[@i])	
			ok
		next

		This.UpdateWith(_aContent_)


		def StringifyNamedObjectsQ()
			This.StringifyNamedObjects()
			return This

	def NamedObjectsStringified()
		_aResult_ = This.Copy().StringifyNamedObjectsQ().Content()
		return _aResult_

	  #---------------------------------------------------------------------#
	 #  Q-STRINGIFYING THE LIST (ALL ITEMS ARE FORCED TO BECOME QSTRINGS)  #
	#---------------------------------------------------------------------#

	def QStringify()
		aContent = This.Content()
		nLen = len(aContent)

		aoResult = []
		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)
				cItem = item

			but isList(item)
				cItem = @@(item)

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			oQStr = new QString2()
			oQStr.append(cItem)
			aoResult + oQStr
		next

		This.UpdateWith( aoResult )

		def QStringifyQ()
			This.Stringify()
			return This

	def QStringified()
		aResult = This.Copy().QStringfyQ().Content()
		return aResult


		#< @FunctionAlternativeForms

		def ToListOfQStrings()
			return This.QStringified()

		def ToListOfQStringifiedItems()
			return This.QStringified()

		def ItemsQStringified()
			return This.QStringified()

		#>

	  #---------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING -- EXTENDED  #
	#---------------------------------------------------------------------------------------#
	# This extented version returns along the stringified items, the list of positions of
	# the items beeing affected by the replacement operation
	#--> Used internally in some places to boost performance

	def StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		#NOTE // General note on performance of code written here in SoftanzaLib

		# For all loops running on large data (tens of thousands of times and more), we
		# don't rely on softanza objects services (stzString and alike), we use Qt directly instead!

		# In fact the problem comes, not from Softanza objects themselves, but from
		# going back and forth between Ring and Qt

		# Resolving params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if pcSubStr = ""
			return
		ok

		if isList(pcOtherSubStr) and Q(pcOtherSubStr).IsWithOrByOrUsingNamedParam()
			pcOtherSubStr = pcOtherSubStr[2]
		ok

		if NOT isString(pcOtherSubStr)
			StzRaise("Incorrect param type! pcOtherSubStr must be a string.")
		ok

		if pcOtherSubStr = ""
			return
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT (pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_)
			StzRaise("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		acResult = []
		anPos = []
		anPosExt = []
		cExtension = Q("_").RepeatedNTImes( ( Q(pcOtherSubStr).NumberOfChars() * 2 ) )

		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)

				oQStr = new QString2()
				oQStr.append(item)

				bExtend = _FALSE_
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = _TRUE_
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					cItem = @ReplaceCS(item, pcSubStr, pcOtherSubStr, pCaseSensitive)
					anPos + i
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem = cExtension + cItem + cExtension
					anPosExt + i
				ok

			but isList(item)
				item = @@(item)
				oQStr = new QString2()
				oQStr.append(item)

				bExtend = _FALSE_
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = _TRUE_
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					cItem = @ReplaceCS(item, pcSubStr, pcOtherSubStr, pCaseSensitive)
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem += cExtendion
					anPosExt + i
				ok

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			acResult + cItem
		next

		aResult = [ acResult, anPos, anPosExt ]
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyAndReplaceCSXTQRT(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedAndCommaReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyAndReplaceXT(pcSubStr, pcOtherSubStr)
		This.StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, _TRUE_)

		#< @FunctionFluentForm

		def StringifyAndReplaceXTQ(pcSubStr, pcOtherSubStr)
			This.StringifyAndReplaceXT(pcSubStr, pcOtherSubStr)
			return This

		def StringifyAndReplaceXTQRT(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyAndReplaceXTQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)
			return This.StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)

	  #-------------------------------------------------------------------------------#
	 #  STRINGIFYING THE ITEMS AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING  #
	#-------------------------------------------------------------------------------#

	def StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		aResult = This.Copy().StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()[1]
		This.Update(aResult)

		#< @FunctionFluentForm

		def StringifyAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyAndReplaceCSQRT(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedAndCommaReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyAndReplace(pcSubStr, pcOtherSubStr)
		This.StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, _TRUE_)

		#< @FunctionFluentForm

		def StringifyAndReplaceQ(pcSubStr, pcOtherSubStr)
			This.StringifyAndReplace(pcSubStr, pcOtherSubStr)
			return This

		def StringifyAndReplaceQRT(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplaced(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplaced(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyAndReplaceQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedAndReplaced(pcSubStr, pcOtherSubStr)
			return This.StringifiedAndReplaced(pcSubStr, pcOtherSubStr)

	  #----------------------------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS, LOWERCASING THEM, AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING -- EXTENDED  #
	#==========================================================================================================#

	# A special function used internally by Softanza to boost its performance

	def StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		# Resolving params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if pcSubStr = ""
			return
		ok

		if isList(pcOtherSubStr) and Q(pcOtherSubStr).IsWithOrByOrUsingNamedParam()
			pcOtherSubStr = pcOtherSubStr[2]
		ok

		if NOT isString(pcOtherSubStr)
			StzRaise("Incorrect param type! pcOtherSubStr must be a string.")
		ok

		if pcOtherSubStr = ""
			return
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT (pCaseSensitive = _TRUE_ or pCaseSensitive = _FALSE_)
			StzRaise("Incorrect param! pCaseSensitive must be a boolean (_TRUE_ or _FALSE_).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		acResult = []
		anPos = []
		cItem = ""
		anPosExt = []
		cExtension = Q("_").RepeatedNTImes( ( Q(pcOtherSubStr).NumberOfChars() * 2 ) )
		
		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)

				oQStr = new QString2()
				oQStr.append(item)


				bExtend = _FALSE_
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = _TRUE_
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					cItem = @ReplaceCS(item, pcSubStr, pcOtherSubStr, pCaseSensitive)
					anPos + i
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem = cExtension + cItem + cExtension
					anPosExt + i
				ok

			but isList(item)
				item = @@(item)
				oQStr = new QString2()
				oQStr.append(item)

				bExtend = _FALSE_
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = _TRUE_
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					cItem = @ReplaceCS(item, pcSubStr, pcOtherSubStr, pCaseSensitive)
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem += cExtendion
					anPosExt + i
				ok

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			oQLocale = new QLocale("C")
			cItem = oQLocale.toLower( cItem )
			acResult + cItem
		next

		aResult = [ acResult, anPos, anPosExt ]
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyLowercaseAndReplaceCSXTQRT(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedLowercasedAndCommaReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyLowercaseAndReplaceXT(pcSubStr, pcOtherSubStr)
		This.StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, _TRUE_)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceXTQ(pcSubStr, pcOtherSubStr)
			This.StringifyLowercaseAndReplaceXT(pcSubStr, pcOtherSubStr)
			return This

		def StringifyLowercaseAndReplaceXTQRT(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyLowercaseAndReplaceXTQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)
			return This.StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)

	  #-----------------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS, LOWERCASING THEM, AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING   #
	#-----------------------------------------------------------------------------------------------#
	# A special function used internally by Softanza to boost its performance

	def StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		aResult = This.Copy().StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()[1]
		This.Update(aResult)
		
		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyLowercaseAndReplaceCSQRT(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyLowercaseAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedLowercasedAndCommaReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyLowercaseAndReplace(pcSubStr, pcOtherSubStr)
		This.StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, _TRUE_)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceQ(pcSubStr, pcOtherSubStr)
			This.StringifyLowercaseAndReplace(pcSubStr, pcOtherSubStr)
			return This

		def StringifyLowercaseAndReplaceQRT(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyLowercaseAndReplaceQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)
			return This.StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)

	  #-----------------------------------------------------------------------#
	 #  DEEP STRINGIFYING THE LIST (ALL ITEMS ARE FORCED TO BECOME STRINGS)  #
	#-----------------------------------------------------------------------#

	def DeepStringify() #ai #chat-gpt
	
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)
	
		for @i = 1 to _nLen_
	
			if isString(_aContent_[@i])
				loop
	
			but isNumber(_aContent_[@i])
				_aContent_[@i] = "" + _aContent_[@i]
	
			but isList(_aContent_[@i])
				# Recursive call to handle deep lists
				_innerList_ = _aContent_[@i]
				objInner = new stzList(_innerList_)
				objInner.DeepStringify()
				_aContent_[@i] = objInner.Content()
	
			but isObject(_aContent_[@i])
				_aContent_[@i] = @ObjectVarName(_aContent_[@i])
			ok
	
		next
	
		This.UpdateWith(_aContent_)

		#< @FunctionFluentForm

		def DeepStringifyQ()
			This.DeepStringify()
			return This

		#>


	def DeepStringified()
		_aResult_ = This.Copy().DeepStringifyQ().Content()
		return _aResult_

	  #==================================================#
	 #  TRANSFORMING THE ITEMS OF THE LIST TO A STRING  #
	#==================================================#

	def ToString()
		return This.ToStringXT(:ConcatenatedUsing = NL)

		def ToStringQ()
			return new stzString( This.ToString() )

	def ToStringXT(pOption)
		if isString(pOption)
			if pOption = :AsCode
				return This.ToCode()

			but pOption = :Concatenated
				return This.StringifyQRT(:stzListOfStrings).Concatenated()
			ok

		but isList(pOption) and
		    Q(pOption).IsOneOfTheseNamedParams([
			:Concatenated, :ConcatenatedUsing, :ConcatenatedWith ])

			if isList(pOption[2]) and
			   Q(pOption[2]).IsOneOfTheseNamedParams([ :Using, :With ])

				pOption[2] = pOption[2][2]
			ok

			return This.StringifyQRT(:stzListOfStrings).ConcatenatedUsing(pOption[2])
		ok

		StzRaise("Unsupprorted syntax!")
			
		def ToStringXTQ(pOption)
			return new stzString( This.ToStringXT(pOption) )

	  #-----------------------------------------------------------------#
	 #  CONCATENATING THE STRING ITEMS AND RETURNING THEM IN A STRING  #
	#-----------------------------------------------------------------#

	def Concatenate()
		_cResult_ = This.StringsQ().ToStzListOfStrings().Concatenate()
		return _cResult_

		#< @FunctionFluentForm

		def ConcatenateQ()
			return new stzString(This.Concatenate())
		#>

		#< @FunctionAlternativeForms

		def Concat()
			This.Concatenate()

			def ConcatQ()
				return This.ConcatenateQ()

		def Join()
			This.Concatenate()

			def JoinQ()
				return This.ConcatenateQ()
		#--

		def ConcatenateStrings()
			This.Concatenate()

			def ConcatenateStringsQ()
				return This.ConcatenateQ()

		def ConcatStrings()
			This.Concatenate()

			def ConcatStringsQ()
				return This.ConcatenateQ()

		def JoinStrings()
			This.Concatenate()

			def JoinStringsQ()
				return This.ConcatenateQ()

		#>

	def Concatenated()
		return This.Concatenate()

		def Joined()
			return This.Concatenate()

		def StringsConcatenated()
			return This.Concatenate()

		def StringJoined()
			return This.Concatenated()

	  #--------------------------------------------------------------------#
	 #  CONCATENATING ALL THE ITEMS AND RETURNING THEM IN A STRING -- XT  #
	#--------------------------------------------------------------------#
	# ~> XT: even the non string items are stringifed and concatenated

	def ConcatenateXT()
		_cResult_ = This.StringifyQ().ToStzListOfStrings().Concatenate()
		return _cResult_

		#< @FunctionFluentForm

		def ConcatenateXTQ()
			return new stzString(This.ConcatenateXT())
		#>

		#< @FunctionAlternativeForms

		def ConcatXT()
			This.ConcatenateXT()

			def ConcatXTQ()
				return This.ConcatenateXTQ()

		def JoinXT()
			This.ConcatenateXT()

			def JoinXTQ()
				return This.ConcatenateXTQ()

		#>

	def ConcatenatedXT()
		return This.ConcatenateXT()

		def JoinedXT()
			return This.ConcatenateXT()

	   #=============================================#
	  #  CHECKS IF THE LIST CONTAINS AT LEAST ONE   #
	 #  ITEM IN THE FORM OF A CONDITIONAL CODE     #
	#=============================================#

	def ContainsCCode()
		bResult = _FALSE_

		aTempList = This.List()
		nLen = len(aTempList)

		
		for i = 1 to nLen
			item = aTempList[i]

			if isList(item) and Q(item).IsWhereNamedParam()
				item = item[2]
			ok

			if isString(item) and
			   Q(item).TrimQ().IsBoundedBy(["{","}"])
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		def ContainsConditionalCode()
			return This.ContainsCCode()

	  #====================================================#
	 #      CHECKING IF EACH ITEM IS EITHER ... OR ...    #
	#====================================================#

	def AllItemsAreEither(p1, p2, p3)

		/* EXAMPLE

		SYNTAX 1

		o1 = new stzList([ "to", -4, "be", "or", -8, "not", "to", -10, "be" ])
		? o1.EachItemIsEitherA( :Number, :Or, :String )
		#--> _TRUE_

		SYNTAX 2

		o1 = new stzList([ 6, -2, 9, 5, -10 ])
		? o1.EachItemIsEither(:Positive, :Or = :Negative, :Number )
		#--> _TRUE_

		*/

		# Checking params

		cSyntax = ""

		if isString(p2) and ( p2 = :Or or p2 = :OrA )
			cSyntax = "1"

		but isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :Or, :OrA ])
			p2 = p2[2]
			cSyntax = "2"
		ok

		if cSyntax = ""
			StzRaise("Unsupported syntax!")
		ok

		if NOT ( isString(p1) and isString(p2) and isString(p3) )
			StzRaise("Incorrect param types! p1, p2, and p3 must be all strings.")
		ok

		p1 = lower(p1)
		p2 = lower(p2)
		p3 = lower(p3)

		# Composing the conditional expression

		if cSyntax = "1"
			if p1 = :Object
				p1 = "n" + p1
			ok
			if p3 = :Object
				p3 = "n" + p3
			ok

			if p1 = "number" or p1 = "string" or p1 = "list"
				p1 = "A" + p1
			but p1 = "object"
				p1 = "An" + p1
			ok

			if p3 = "number" or p3 = "string" or p3 = "list"
				p3 = "A" + p3
			but p3 = "object"
				p3 = "An" + p3
			ok

			cCode = 'bOk = ( Q(@aContent[@i]).Is' + p1 + '() or' + NL +
				'Q(@aContent[@i]).Is' + p3 + '() )'

		but cSyntax = "2"

			if NOT This.AllItemsAre(p3)
				return _FALSE_
			ok
	
			if p1 = :Object
				p1 = "n" + p1
			ok
			if p2 = :Object
				p2 = "n" + p2
			ok

			if p1 = "number" or p1 = "string" or p1 = "list"
				p1 = "A" + p1
			but p1 = "object"
				p1 = "An" + p1
			ok

			if p2 = "number" or p2 = "string" or p2 = "list"
				p2 = "A" + p2
			but p2 = "object"
				p2 = "An" + p2
			ok

			cCode = 'bOk = ( Stz' + p3 + 'Q(@aContent[@i]).Is' + p1 + '() ) or' + NL +
			        '( Stz' + p3 + 'Q(@aContent[@i]).Is' + p2 + '() )'
	
		ok

		cCode = ring_substr2(cCode, "Isnobject", "IsAnObject")
		# Brute force solution!
		# #TODO A cleaner solution is to check how cCode is composed
		# and let IsAnObject be generated isntead of IsnObject

		# Doing the job

		nLen = This.NumberOfItems()

		bResult = _TRUE_

		for @i = 1 to nLen
			@item = @aContent[@i]
			eval(cCode)

			if NOT bOk
				bResult = _FALSE_
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEitherA(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEitherAn(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def ItemsHaveEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2)

		def AllItemsHaveEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		#>

	def AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)
		if isList(p2) and Q(p2).IsANamedParam()
			p2 = p2[2]
		ok

		if This.AllItemsAreXT([p1, p3], paEvalDirection) or
		   This.AllItemsAreXT([p2, p3], paEvalDirection)

			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def ItemsAreEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherAXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherAnXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def ItemsHaveEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def AllItemsHaveEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING IF A CHAIN OF TYPES IS _TRUE_ AGAINST THE LIST OF ITEMS  #
	#==================================================================#

	def Are(p)
		return This.AreXT(p, :EvalDirection = :Default)

		def ItemsAre(p)
			return This.Are(p)

	def AreXT(p, paEvalDirection)

		# Managing the params

		if NOT isList(p)
			aTempList = []
			aTempList + p
			p = aTempList
		ok

		if len(p) = 0
			return _FALSE_
		ok

		if isList(paEvalDirection) and
		   Q(paEvalDirection).IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if NOT isString(paEvalDirection)
			StzRaise("Incorrect param type! paEvalDirection must be a string.")
		ok

		if NOT ring_find([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], paEvalDirection) > 0

			StzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if paEvalDirection = :Default or paEvalDirection = :Nothing
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		if ring_find([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			], paEvalDirection) > 0

			p = Q(p).Reversed()
		ok

		if len(p) = 1

			cType = @InfereType(p[1])

			bResult = _TRUE_
			nLen = len(@aContent)

			for i = 1 to nLen
				cCode = 'bOk = is' + cType + '(' + @@(@aContent[i]) + ')'
				eval(cCode)
				if NOT bOk
					bResult = _FALSE_
					return bResult
				ok
			next

			return bResult

		else
			nLenMethods = len(p)
			for i = 2 to nLenMethods
				if isList(p[i]) and Q(p[i]).IsWhereNamedParam()
					p[i] = p[i][2]
				ok
			next

			cMainClass = 'stz' + Q(p[1]).InfereStzClass()
			cCode = 'oObj = new ' + cMainClass + '(@item)'

			aContent = This.Content()
			nLenList = len(aContent)

			bResult = _TRUE_

			for i = 1 to nLenList
				@item = aContent[i]
		
				for j = 2 to nLenMethods

					if Q(p[j]).TrimQ().IsBoundedBy(["{","}"])
						cCode = 'bOk = (' + Q(p[j]).TrimQ().TheseBoundsRemoved("{","}") + ')'
					else
						cMethod = p[j]
						if cMethod = "number" or cMethod = "string" or cMethod = "list"
							cMethod = "A" + cMethod
						but cMethod = "object"
							cMethod = "AnObject"
						ok

						cCode = 'bOk = Q(@item).Is' + cMethod + '()'
					ok

					eval(cCode)
					if NOT bOk
						bResult = _FALSE_
						exit 2
					ok
				next j
			next i

			return bResult
		ok

		def ItemsAreXT(p, paEvalDirection)
			return This.AreXT(p, paEvalDirection)

	  #================================#
	 #    USUED FOR NATURAL-CODING    #
	#================================#

	def IsAString()
		return _FALSE_

		def IsNotAString()
			return _TRUE_

	def IsAList()
		return _TRUE_

		def IsNotAList()
			return _FALSE_

	def IsAnObject()
		return _TRUE_

		def IsAObject()
			return _TRUE_

		def IsNotAnObject()
			return _FALSE_

	#--- ITEM

	def IsItem()
		return _TRUE_

		def IsAnItem()
			return This.IsItem()

	def IsItemOf(paList)
		return StzListQ(paList).Contains(This.Content())
	
		def AsAnItemOf(paList)
			return This.IsItemOf(paList)
	
	def IsItemIn(paList)
		return This.IsItemOf(paList)
	
		def IsAnItemIn(paList)
			return This.IsItemOf(paList)

	#--

	def IsMember()
		return _TRUE_

		def IsAMember()
			return This.IsMember()

	def IsMemberOf(paList)
		return StzListQ(paList).Contains(This.Content())
	
		def AsAMemberOf(paList)
			return This.IsMemberOf(paList)
	
	def IsMemberIn(paList)
		return This.IsMemberOf(paList)
	
		def IsAMemberIn(paList)
			return This.IsMemberOf(paList)


	#--- NUMBER

	def IsANumber()
		return _FALSE_

		def IsNotANumber()
			return _TRUE_

	def IsNumberOf(paList)
		return _FALSE_

		def IsANumberOf(paList)
			return _FALSE_
	
	def IsNumberIn(paList)
		return _FALSE_
	
		def IsANumberIn(paList)
			return _FALSE_

	#--- ITEM

	def IsLetter()
		return _FALSE_

		def IsALetter()
			return _FALSE_
	
	def IsLetterOf(pStrOrListOfChars)
		return _FALSE_

		def IsALetterOf(pcStr)
			return _FALSE_
	
	def IsLetterIn(pcStr)
		return _FALSE_

		def IsALetterIn(pcStr)
			FALSE

	def IsCharOf(pStrOrListOfChars)
		return _FALSE_

		def IsACharOf(pcStr)
			return _FALSE_

	def IsCharIn(pcStr)
		return _FALSE_

		def IsACharIn(pcStr)
			return _FALSE_

	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzlist"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	#===

	def ToListOfStzStrings()
		if NOT This.IsListOfStrings()
			StzRaise("Can't proceed! All items must be strings.")
		ok

		acContent = This.Content()
		nLen = len(acContent)

		aoResult = []

		for i = 1 to nLen
			aoResult + new stzString(acContent[i])
		next

		return aoResult

		def ToListOfStzStringsQ()
			return This.ToListOfStzStringsQRT(:stzList)

		def ToListOfStzStringsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ToListOfStzStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.ToListOfStzStrings() )

			on :stzListOfChars
				return new stzListOfChars( This.ToListOfStzStrings() )

			off

	  #==========================================#
	 #  TRANSFORMING THE LIST TO AN OTHER FORM  #
	#==========================================#

	def ToStzListOfChars()
		if NOT This.IsListOfChars()
			StzRaise("Can't cast the list into a stzListOfChars!")
		ok

		return new stzListOfChars( This.Content() )

	def ToListOfStzChars()
		if NOT This.IsListOfChars()
			StzRaise("Can't cast the list into a stzListOfChars!")
		ok

		acChars = This.Content()
		nLen = len(acChars)

		aResult = []

		for i = 1 to nLen
			oChar = new stzChar(acChars[i])
			aResult + oChar
		next

		return aResult

	  #========================================================#
	 #  TRANSFORMING THE LIST TO RING CODE (COMPUTABLE FORM)  #
	#========================================================#
 
	def ToListInStringInShortForm()
		cResult = This.ToCodeQ().ToListInShortForm()
		return cResult

		def ToListInShortForm()
			return This.ToListInStringInShortForm()

		def ToListInAStringInShortForm()
			return This.ToListInStringInShortForm()

	def ComputableForm()
		return @@( This.Content() )

		def ToListInString()
			return This.ComputableForm()

		def ToListInAString()
			return This.ComputableForm()

	  #===========================================#
	 #   GETTING A RANDOM POSITION IN THE LIST   #
	#===========================================#

	def RandomPosition()

		nResult = ARandomNumberBetween(1, This.NumberOfItems())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPosition()
			return This.RandomPosition()

		#--

		def APosition()
			return This.RandomPosition()

		def AnyPosition()
			return This.RandomPosition()

		def AnyRandomPosition()
			return This.RandomPosition()


		#>

	  #------------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST GREATER THAN THE ONE PROVIDED  #
	#------------------------------------------------------------------------#

	def RandomPositionGreaterThan(n)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfItems()

		if NOT ( n >= 1 and n < nLen - 1 )
			StzRaise("Out of range! n must be >= 1 and < (nLen-1).")
		ok

		nResult = ARandomNumberBetween(n+1, This.NumberOfItems())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def RandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def ARandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		#--

		def APositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyRandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)


		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST LESS THAN THE ONE PROVIDED  #
	#---------------------------------------------------------------------#

	def RandomPositionLessThan(n)
		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfItems()

		if NOT ( n > 1 and n <= nLen )
			StzRaise("Out of range! n must be > 1 and < nLen.")
		ok

		nResult = ARandomNumberBetween(1, n - 1)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def RandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		def ARandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#--

		def APositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyRandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)


		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST EXECEPT THE ONE PROVIDED  #
	#-------------------------------------------------------------------#

	def RandomPositionExcept(n)

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		aNumbers = Q( 1:This.NumberOfItems() ) - n
		nResult = ARandomNumberIn(aNumbers)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def RandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def ARandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#--

		def APositionExcept(n)
			return This.RandomPositionExcept(n)

		def APositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyRandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyRandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#>

	  #-------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST  #
	#===========================================#

	def RandomSection()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aResult = This.Section(n1, n2)

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSection()
			return This.RandomSection()

		def ASection()
			return This.RandomSection()

		def AnySection()
			return This.RandomSection()

		def AnyRandomSection()
			return This.RandomSection()

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST ALONG WITH ITS POSITION  #
	#-------------------------------------------------------------------#

	def RandomSectionZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, n1 ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZ()
			return This.RandomSectionZ()

		def ASectionZ()
			return This.RandomSectionZ()

		def AnySectionZ()
			return This.RandomSectionZ()

		def AnyRandomSectionZ()
			return This.RandomSectionZ()

		#--

		def RandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ASectionAndItsPosition()
			return This.RandomSectionZ()

		def AnySectionAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSectionAndItsPosition()
			return This.RandomSectionZ()

		#>

	  #------------------------------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST ALONG WITH ITS SECTION  #
	#------------------------------------------------------------------#

	def RandomSectionZZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, [ n1, n2 ] ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZZ()
			return This.RandomSectionZZ()

		def ASectionZZ()
			return This.RandomSectionZZ()

		def AnySectionZZ()
			return This.RandomSectionZZ()

		def AnyRandomSectionZZ()
			return This.RandomSectionZZ()

		#>

	  #--------------------------------#
	 #  GETTING SOME RANDOM SECTIONS  #
	#--------------------------------#

	def RandomSections()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aSections = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aSections + [ n1, n2 ]
		next

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def SomeSections()
			return This.RandomSections()

		def SomeRandomSections()
			return This.RandomSections()

		def AnySections()
			return This.RandomSections()

		def AnyRandomSections()
			return This.RandomSections()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------#

	def RandomSectionsZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def SomeSectionsZ()
			return This.RandomSectionsZ()

		def SomeRandomSectionsZ()
			return This.RandomSectionsZ()

		def AnySectionsZ()
			return This.RandomSectionsZ()

		def AnyRandomSectionsZ()
			return This.RandomSectionsZ()

		#--

		def RandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def SomeSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def SomeRandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def AnySectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def AnyRandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		#>

	  #----------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------#

	def RandomSectionsZZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def SomeSectionsZZ()
			return This.RandomSectionsZZ()

		def SomeRandomSectionsZZ()
			return This.RandomSectionsZZ()

		def AnySectionsZZ()
			return This.RandomSectionsZZ()

		def AnyRandomSectionsZZ()
			return This.RandomSectionsZZ()

		#>

	  #-----------------------------#
	 #  GETTING N RANDOM SECTIONS  #
	#=============================#

	def NRandomSections(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aSections + [ n1, n2 ]
		next

		aResult = This.Sections(aSections)

		return aResult

	  #--------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------#

	def NRandomSectionsZ(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

	  #-------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------#

	def NRandomSectionsZZ(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [ n1, n2 ] ]
		next

		return aResult

	  #---------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST   #
	#=======================================#

	def RandomItem()

		cResult = This.ItemAtPosition( This.RandomPosition() )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomItem()
			return This.RandomItem()

		#--

		def AnItem()
			return This.RandomItem()

		def AnyItem()
			return This.RandomItem()

		def AnyRandomItem()
			return This.RandomItem()

		#>

	  #---------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST ALONG WITH ITS POSITION   #
	#---------------------------------------------------------------#

	def RandomItemZ()

		nPos =  This.RandomPosition()
		cItem = This.ItemAtPosition(nPos)
		aResult = [ cItem, nPos] 

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemZ()
			return This.RandomItemZ()

		#--

		def AnItemZ()
			return This.RandomItemZ()

		def AnyItemZ()
			return This.RandomItemZ()

		def AnyRandomItemZ()
			return This.RandomItemZ()

		#==

		def RandomItemAndItsPosition()
			return This.RandomItemZ()

		def ARandomItemAndItsPosition()
			return This.RandomItemZ()

		#--

		def AnItemAndItsPosition()
			return This.RandomItemZ()

		def AnyItemAndItsPosition()
			return This.RandomItemZ()

		def AnyRandomItemAndItsPosition()
			return This.RandomItemZ()

		#>

	  #------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED POSITION  #
	#==================================================================#

	def RandomItemAfterPosition(n)

		cResult = This.ItemAt( This.RandomPositionGreaterThan(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		#--

		def AnItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		def AnyItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		def AnyRandomItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		#>

	   #--------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED  #
	 #  POSITION ALONG WITH ITS POSITION                      #
	#--------------------------------------------------------#

	def RandomItemAfterPositionZ(n)

		nPos = This.RandomPositionGreaterThan(n)
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#--

		def AnItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyRandomItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#==

		def RandomItemAndItsPositionAfterPosition(n)
			return This.RandomItemAfterPositionZ(n)

		def ARandomItemAndItsPositionAfterPosition(n)
			return This.RandomItemAfterPositionZ(n)

		#--

		def AnItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyRandomItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#>

	  #--------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED ITEM  #
	#==============================================================#

	def RandomItemAfterCS(pItem, pCaseSensitive)
		nPos = This.RandomPositionAfter( This.FindFirstCS(pItem, pCaseSensitive) )
		result = This.ItemAt(nPos)
		return result

		#< @FunctionAlternativeForms

		def ARandomItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterCS(pItem, pCaseSensitive)

		def ARandomItemAfterItemCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		#--

		def AnItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		def AnyItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		def AnyRandomItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemAfter(pItem)
		return This.RandomItemAfterCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemAfter(pItem)
			return This.RandomItemAfter(pItem)

		def ARandomItemAfterItem(pItem)
			return This.RandomItemAfterItem(pItem)

		#--

		def AnItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		def AnyItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		def AnyRandomItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		#>

	   #--------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED  #
	 #  ITEM ALONG WITH ITS POSITION                          #
	#--------------------------------------------------------#

	def RandomItemAfterCSZ(pItem, pCaseSensitive)

		nPos = This.RandomPositionAfter( This.FindFirstCS(pItem, pCaseSensitive) )
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterCSZ(pItem, pCaseSensitive)

		def ARandomItemAfterItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		#--

		def AnItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		def AnyItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		def AnyRandomItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemAfterZ(pItem)
		return This.RandomItemAfterCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemAfterZ(pItem)
			return This.RandomItemAfterZ(pItem)

		def ARandomItemAfterItemZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		#--

		def AnItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		def AnyItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		def AnyRandomItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED POSITION  #
	#===================================================================#

	def RandomItemBeforePosition(n)

		result = This.ItemAt( This.RandomPositionLessThan(n) )
		return result

		#< @FunctionAlternativeForms

		def ARandomItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		#--

		def AnItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		def AnyItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		def AnyRandomItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		#>

	  #----------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED  #
	 #  POSITION ALONG WITH ITS POSITION                       #
	#---------------------------------------------------------#

	def RandomItemBeforePositionZ(n)
		nPos = This.RandomPositionLessThan(n)
		aResult = [ This.ItemAt(nPos), nPos ]
		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		#--

		def AnItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		def AnyItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		def AnyRandomItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		#>

	  #---------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED ITEM  #
	#===============================================================#

	def RandomItemBeforeCS(pItem, pCaseSensitive)

		nPos = This.RandomPositionBefore( This.FindFirstCS(pItem, pCaseSensitive) )
		result = This.ItemAt(nPos)
		return result

		#< @FunctionAlternativeForms

		def ARandomItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def ARandomItemBeforeItemCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeItemCS(pItem, pCaseSensitive)

		#--

		def AnItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def AnyItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def AnyRandomItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemBefore(pItem)
		return This.RandomItemBeforeCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def ARandomItemBeforeItem(pItem)
			return This.RandomItemBeforeItem(pItem)

		#--

		def AnItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def AnyItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def AnyRandomItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		#>

	   #--------------------------------------------------------------#
	  #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED ONE  #
	 #  ALONG WITH ITS POSITION                                     #
	#--------------------------------------------------------------#

	def RandomItemBeforeCSZ(pItem, pCaseSensitive)

		nPos = This.RandomPositionBefore( This.FindFirstCS(pItem, pCaseSensitive) )
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def ARandomItemBeforeItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeItemCSZ(pItem, pCaseSensitive)

		#--

		def AnItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def AnyItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def AnyRandomItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemBeforeZ(pItem)
		return This.RandomItemBeforeCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def ARandomItemBeforeItemZ(pItem)
			return This.RandomItemBeforeItemZ(pItem)

		#--

		def AnItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def AnyItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def AnyRandomItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE PROVIDED ONE  #
	#===================================================================#

	def RandomItemExceptCS(pItem, pCaseSensitive)
		anPos = This.AntiFindCS(pItem, pCaseSensitive)
		n = ARandomNumberIn(anPos)
		result = This.ItemAt(n)

		return result

		#< @FunctionAlternativeForms

		def ARandomItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def RandomItemExceptItemCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def ARandomItemExceptItemCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		#--

		def AnItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def AnyItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def AnyRandomItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomItemExcept(pItem)
		return This.RandomItemExceptCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def RandomItemExceptItem(pItem)
			return This.RandomItemExcept(pItem)

		def ARandomItemExceptItem(pItem)
			return This.RandomItemExcept(pItem)

		#--

		def AnItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def AnyItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def AnyRandomItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		#>

	   #--------------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE PROVIDED  #
	 #  ALONG WITH ITS POSITION                                     #
	#--------------------------------------------------------------#

	def RandomItemExceptCSZ(pItem, pCaseSensitive)
		anPos = This.AntiFindCS(pItem, pCaseSensitive)
		n = ARandomNumberIn(anPos)
		aResult = [ This.ItemAt(n), n ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def RandomItemExceptItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def ARandomItemExceptItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		#--

		def AnItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def AnyItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def AnyRandomItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomItemExceptZ(pItem)
		return This.RandomItemExceptCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def ARandomItemExceptZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def RandomItemExceptItemZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def ARandomItemExceptItemZ(pItem)
			return This.RandomItemExceptZ(pItem)

		#--

		def AnItemExceptZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def AnyItemExceptZ(pItem)
			return This.RandomItemExcept(pItem)

		def AnyRandomItemExceptZ(pItem)
			return This.RandomItemExcept(pItem)

		#>

	  #-------------------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE AT THE POSITION PROVIDED  #
	#===============================================================================#

	def RandomItemExceptPosition(n)
		result = This.ItemAt( This.RandomPositionExcept(n) )
		return result

		#< @FunctionAlternativeForms

		def ARandomItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptAt(n)
			return This.RandomItemExceptPosition(n)

		#==

		def AnItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def AnItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		#>

	   #----------------------------------------------------------------------#
	  #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE AT THE POSITION  #
	 #  PROVIDED ALONG WITH ITS POSITION                                    #
	#----------------------------------------------------------------------#

	def RandomItemExceptPositionZ(n)
		nPos = This.RandomPositionExcept(n)
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#==

		def AnItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def AnItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#>

	  #--------------------------------------------#
	 #  GETIING N RANDOM POSITIONS FROM THE LIST  #
	#--------------------------------------------#

	def NRandomPositions(n)
		anResult = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		return anResult

		#< @FunctionAlternativeForms

		def NPositions(n)
			return This.NRandomPositions(n)

		def AnyNPositions(n)
			return This.NRandomPositions(n)

		def AnyRandomNPositions(n)
			return This.NRandomPositions(n)

		def AnyNRandomPositions(n)
			return This.NRandomPositions(n)

		#>

	  #----------------------------------------#
	 #  GETIING N RANDOM ITEMS FROM THE LIST  #
	#----------------------------------------#

	def NRandomItems(n)
		anPos = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		aResult = This.ItemsAtPositions(anPos)

		return aResult
	
		#< @functionAlternativeForm

		def NItems(n)
			return This.NRandomItems(n)

		def RandomNItems(n)
			return This.NRandomItems(n)

		def NRandomItemsC(n)
			return This.NRandomItems(n)

		def AnyNItems(n)
			return This.NRandomItems(n)

		def AnyNRandomItems(n)
			return This.NRandomItems(n)

		def AnyRandomNItems(n)
			return This.NRandomItems(n)

		def rndNItems(n)
			return This.NRandomItems(n)

		#>

	  #-------------------------------------------------------------------#
	 #  GETIING N RANDOM ITEMS FROM THE LIST ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------#

	def NRandomItemsZ(n)
		anPos = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		aItems = This.ItemsAtPositions(anPos)
		aResult = Association([ aItems, anPos ])
		return aResult
		
		#< @functionAlternativeForms

		def NItemsZ(n)
			return This.NRandomItemsZ(n)

		def RandomNItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyNItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyNRandomItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyRandomNItemsZ(n)
			return This.NRandomItemsZ(n)

		#--

		def NRandomItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def NItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def RandomNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyNRandomItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyRandomNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)


		#>

	  #-----------------------------------------------#
	 #  GETIING SOME RANDOM POSITIONS FROM THE LIST  #
	#-----------------------------------------------#

	def SomeRandomPositions()
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		anResult = This.NRandomPositions(n)
		return anResult

		#< @functionAlternativeForms

		def RandomPositions()
			return This.SomeRandomPositions()

		def SomePositions()
			return This.SomeRandomPositions()

		def AnyPositions()
			return This.SomeRandomPositions()

		def AnyRandomPositions()
			return This.SomeRandomPositions()

		#>

	  #-------------------------------------------#
	 #  GETIING SOME RANDOM ITEMS FROM THE LIST  #
	#-------------------------------------------#

	def SomeRandomItems()
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		aResult = This.NRandomItems(n)
	
		return aResult

		#< @FunctionAlternativeForm

		def SomeItems()
			return This.SomeRandomItems()

		def RandomItems()
			return This.SomeRandomItems()

		def AnyItems()
			return This.SomeRandomItems()

		def AnyRandomItems()
			return This.SomeRandomItems()

		def rndItems()
			return This.SomeRandomItems()

		#>

	  #----------------------------------------------------------------------#
	 #  GETIING SOME RANDOM ITEMS FROM THE LIST ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------#

	def SomeRandomItemsZ(pCaseSensitive)
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		anPos = This.NRandomPositions(n)
		aItems = This.ItemsAtPositions(anPos)
	
		aResult = Association([ aItems, anPos ])
		return aResult


		#< @FunctionAlternativeForm

		def SomeItemsZ()
			return This.SomeRandomItemsZ()

		def RandomItemsZ()
			return This.SomeRandomItemsZ()

		def AnyItemsZ()
			return This.SomeRandomItemsZ()

		def AnyRandomItemsZ()
			return This.SomeRandomItemsZ()

		#--

		def SomeRandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def SomeItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def RandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def AnyItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def AnyRandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		#>

	  #---------------------------------------------------------#
	 #  GETTING AN ITEM FROM THE LIST OTHER THEN A GIVEN ITEM  #
	#---------------------------------------------------------#

	def AnItemOtherThanCS(pItem, pCaseSensitive)

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anPos = Q(anPos) - These(anPos)
		// #TODO Make a more performant solution!

		n = ARandomNumberIn(anPos)
		result = This.ItemAt(n)
	
		return result

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)
	
		def AnItemDifferentOfCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)

		def AnItemDifferentToCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)

		def AnItemDifferentFromCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)
	
		#--
	
		def ItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
		
		def ItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def ItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		#--
	
		def AnyItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		def AnyItemDifferentThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pcChar, pCaseSensitive)
	
		def AnyItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def AnyItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		#--

		def AnyRandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		def AnyRandomItemDifferentThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pcChar, pCaseSensitive)
	
		def AnyRandomItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		#--

		def RandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def ARandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnItemOtherThan(pItem)
		return This.AnItemOtherThanCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnItemDifferentOf(pItem)
			return This.ANumberOtherThan(pItem)

		def AnItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)
	
		#--
	
		def ItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def ItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def ItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def ItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)
	
		#--
	
		def AnyItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnyItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)

		#--
	
		def AnyRandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyRandomItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyRandomItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnyRandomItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)

		#--

		def RandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)

		def ARandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem, pCaseSensitive)

		#>

	  #---------------------------------------------------------------------------------#
	 #  GETTING AN ITEM FROM THE LIST OTHER THEN A GIVEN ITEM ALONG WITH ITS POSITION  #
	#---------------------------------------------------------------------------------#

	def AnItemOtherThanCSZ(pItem, pCaseSensitive)

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anPos = Q(anPos) - These(anPos)
		// #TODO Make a more performant solution!

		nPos = ARandomNumberIn(anPos)
		item = This.ItemAt(nPos)
	
		aResult = [ item, nPos ]
		return aResult
	

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnItemDifferentOfCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)

		def AnItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)

		def AnItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)
	
		#--
	
		def ItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
		
		def ItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def ItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		#--
	
		def AnyItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnyItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pcChar, pCaseSensitive)
	
		def AnyItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def AnyItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#--
	
		def AnyRandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnyRandomItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pcChar, pCaseSensitive)
	
		def AnyRandomItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def RandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def ARandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnItemOtherThanZ(pItem)
		return This.AnItemOtherThanCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnItemDifferentOfZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		#--
	
		def ItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def ItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def ItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def ItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		#--
	
		def AnyItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnyItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#--
	
		def AnyRandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyRandomItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyRandomItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnyRandomItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#--

		def RandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def ARandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#>

	  #-------------------------------------------------------#
	 #  GETTING A RANDOM ITEM OTHER THAN THE ITEMS PROVIDED  #
	#-------------------------------------------------------#

	def AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)
		anPos = This.FindManyCS(paItems, pCaseSensitive)
		aResult = This.AnyItemsInPositionsOtherThan(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def ARandomItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnyRandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def RandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def ARandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		#==

		def RandomItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def ARandomItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnyRandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def RandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def ARandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnyRandomItemOtherThanMany(paItems)
		return This.AnyRandomItemOtherThanManyCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def RandomItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def ARandomItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		#--

		def AnyRItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnyRandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def RandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def ARandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		#==

		def RandomItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def ARandomItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		#--

		def AnyRItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnyRandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def RandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def ARandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING A RANDOM ITEM OTHER THAN THE ITEMS PROVIDED ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------------------#

	def AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		anPos = This.FindManyCS(paItems, pCaseSensitive)
		aResult = [ This.AnyItemsInPositionsOtherThan(anPos), anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def ARandomItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnyRandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def RandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def ARandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		#==

		def RandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def ARandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnyRandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def RandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def ARandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnyRandomItemOtherThanManyZ(paItems)
		return This.AnyRandomItemOtherThanManyCSZ(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def ARandomItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		#--

		def AnyRItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnyRandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def RandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def ARandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		#==

		def RandomItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def ARandomItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		#--

		def AnyRItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnyRandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def RandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def ARandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		#>

	  #--------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM  #
	#--------------------------------------------------#

	def NRandomItemsOtherThanCS(pItem, pCaseSensitive)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		// #TODO Make a more performant solution!

		anRandomPos = NRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositions(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def NItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def NRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def NItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#==

		def AnyNRandomItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomNItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyNItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def AnyNRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomNItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyNItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanS(pItem)
		return This.NRandomItemsOtherThanCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def NItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#--

		def NRandomItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def NItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#==

		def AnyNRandomItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyRandomNItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyNItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#--

		def AnyNRandomItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyRandomNItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyNItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- Z/EXTENDED  #
	#----------------------------------------------------------------#

	def NRandomItemsOtherThanCSZ(pItem)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		// #TODO Make a more performant solution!

		anRandomPos = NRandomNumbersIn(anPos)
		aItems = This.ItemsAtPositions(anRandomPos)

		aResult = Association([ aItems, anRandomPos ])

		return aResult

		#< @FunctionAlternativeForms

		def NItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def NRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def NItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#==

		def AnyNRandomItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomNItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyNItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def AnyNRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomNItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyNItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanZ(pItem)
		return This.NRandomItemsOtherThanCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def NItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#--

		def NRandomItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def NItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#==

		def AnyNRandomItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyRandomNItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyNItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#--

		def AnyNRandomItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyRandomNItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyNItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- U/EXTENDED  #
	#----------------------------------------------------------------#

	#TODO

	  #-----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- UZ/EXTENDED  #
	#-----------------------------------------------------------------#

	#TODO

	  #-----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM  #
	#-----------------------------------------------------#

	def SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		// #TODO Make a more performant solution!

		anRandomPos = SomeRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositions(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def SomeRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def SomeItemsExceptCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def AnyRandomItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SomeRandomItemsOtherThanpItem(pItem)
		return This.SomeRandomItemsOtherThanCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def SomeItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def SomeRandomItemsExcept(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def SomeItemsExcept(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		#--

		def AnyRandomItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def AnyItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- Z/EXTENDED  #
	#-------------------------------------------------------------------#

	def SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		// #TODO Make a more performant solution!

		anRandomPos = SomeRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositionsQ(anRandomPos).AssociatedWith(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def SomeRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def SomeItemsExceptCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def AnyRandomItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SomeRandomItemsOtherThanZ(pItem)
		return This.SomeRandomItemsOtherThanCSZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def SomeRandomItemsExceptZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def SomeItemsExceptZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		#--

		def AnyRandomItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def AnyItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- U/EXTENDED  #
	#-------------------------------------------------------------------#

	#TODO

	  #--------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- UZ/EXTENDED  #
	#--------------------------------------------------------------------#

	#TODO

	  #------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN MANY GIVEN ITEMS  #
	#------------------------------------------------------#

	def NRandomItemsOtherThanManyCS(paItems, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanMany(paItems)
		return This.NRandomItemsOtherThanManyCS(paItems, _TRUE_)

	  #---------------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN MANY GIVEN ITEMS  -- Z/EXTENDED  #
	#---------------------------------------------------------------------#

	def NRandomItemsOtherThanManyCSZ(paItems, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanManyZ(paItems)
		return This.NRandomItemsOtherThanManyCSZ(paItems, _TRUE_)

	#-- U/EXTENDED FORM

	#TODO

	#-- UZ/EXTENDED FORM

	#TODO

	  #-----------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A MANY GIVEN ITEMS  #
	#-----------------------------------------------------------#

	def SomeRandomItemsOtherThanManyCS(paItems)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- Z/EXTENDED FORM

	def SomeRandomItemsOtherThanManyCSZ(paItems)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- U/EXTENDED FORM

	#TODO

	#-- UZ/EXTENDED FORM

	#TODO

	  #--------------------------------------------------------#
	 #  GETTING AN ITEM BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#========================================================#

	def AnItemBetweenCS(pMin, pMax, pCaseSensitive) # InSection
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- Z/EXTENDED FORM

	def AnItemBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- IB/EXTENDED FORM

	def AnItemBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- IBZ/EXTENDED FORM

	def AnItemBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------------------#
	 #  GETTING AN ITEM NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#------------------------------------------------------------#

	def AnItemNotBetweenCS(pMin, pMax, pCaseSensitive) # OutsideInSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING AN ITEM INSIDE THE GIVEN SECTIONS  #
	#=============================================#

	def AnItemBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING AN ITEM OUTSIDE THE GIVEN SECTIONS  #
	#----------------------------------------------#

	def AnItemNotBetweenManyCS(pMin, pMax, pCaseSensitive) # OutsideSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #--------------------------------------------------------#
	 #  GETTING N ITEMS BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#========================================================#

	def NItemsBetweenCS(pMin, pMax, pCaseSensitive) # InSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-----------------------------------------------------------#
	 #  GETTING SOME ITEMS BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#-----------------------------------------------------------#

	def SomeItemsBetweenCS(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------------------#
	 #  GETTING N ITEMS NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#------------------------------------------------------------#

	def NItemsNotBetweenCS(pMin, pMax, pCaseSensitive) # OutsideSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------------------------#
	 #  GETTING SOME ITEMS NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#---------------------------------------------------------------#

	def SomeItemsNotBetweenCS(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING N ITEMS INSIDE THE GIVEN SECTIONS  #
	#=============================================#

	def NItemsBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------#
	 #  GETTING SOME ITEMS INSIDE THE GIVEN SECTIONS  #
	#------------------------------------------------#

	def SomeItemsBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsBetweenManyCSIB(pMin, pMax, pCaseSensitivity)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenManyCSIBZ(pMin, pMax, pCaseSensitivity)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING N ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#----------------------------------------------#

	def NItemsNotBetweenManyCS(pMin, pMax, pCaseSensitive) # NotInSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------------#
	 #  GETTING SOME ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#-------------------------------------------------#

	def SomeItemsNotBetweenManyCS(pMin, pMax, pCaseSensitive) # NotInSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------#
	 #  GETTING AN ITEM NOT IN A GIVEN POSITION  #
	#===========================================#

	def AnItemOutsidePosition(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemOutsidePositionZ(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING AN ITEM NOT BETWEEN TWO POSITIONS  #
	#---------------------------------------------#

	def AnItemOutsidePositions(panPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemOutsidePositionsZ(panPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING N ITEMS NOT IN THE GIVEN POSITION  #
	#=============================================#

	def NItemsOutsidePosition(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsOutsidePositionZ(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

  	  #------------------------------------------------#
	 #  GETTING SOME ITEMS NOT IN THE GIVEN POSITION  #
	#------------------------------------------------#

	def SomeItemsOutsidePosition(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsOutsidePositionZ(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING N ITEMS NOT IN THE GIVEN POSITIONS  #
	#----------------------------------------------#

	def NItemsOutsidePositions(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsOutsidePositionsZ(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------------#
	 #  GETTING SOME ITEMS NOT IN THE GIVEN POSITIONS  #
	#-------------------------------------------------#

	def SomeItemsOutsidePositions(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

		def SomeItemsInPositionsOtherThan(panPos, pCaseSensitive)
			return This.SomeItemsOutsidePositions(panPos, pCaseSensitive)

	def SomeItemsOutsidePositionsZ(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

		def SomeItemsInPositionsOtherThanZ(panPos, pCaseSensitive)
			return This.SomeItemsOutsidePositionsZ(panPos, pCaseSensitive)


	  #-------------------------------------------------#
	 #  GETTING A RANDOM ITEM BEFORE A GIVEN POSITION  #
	#-------------------------------------------------#

	def AnyItemBeforeOrAfter(n) #TODO

	def AnyItemBeforeOrAfterZ(n) #TODO

	  #-----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS BEFORE A GIVEN POSITION  #
	#-----------------------------------------------------#

	def AnyItemsBeforePosition(n) #TODO

 	def AnyItemsBeforePositionZ(n) #TODO

	  #----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS AFTER A GIVEN POSITION  #
	#----------------------------------------------------#

	def AnyItemsAfterPosition(n) #TODO

	def AnyItemsAfterPositionZ(n) #TODO

	  #---------------------------------------------------#
	 #  GETTING SOME RANDOM BETWEEN TWO GIVEN POSITIONS  #
	#---------------------------------------------------#

	def AnyItemBetweenPositions(n1, n2) #TODO

	def AnyItemBetweenPositionsZ(n1, n2) #TODO

	  #------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE LIST  #
	#================================================#

	def Randomize()
		nLen = This.NumberOfItems()
		anPos = NUniqueRandomNumbersIn(nLen, 1:nLen)
		This.UpdateWith( This.ItemsAtPositions(anPos) )

		#< @FunctionFluentForm

		def RandomizeQ()
			This.Randomize()
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositions()
			This.Randomise()

			def RandomizePositionsQ()
				This.RandomizePositions()
				return This

		#--

		def Randomise()
			This.Randomize()

			def RandomiseQ()
				This.Randomise()
				return This

		def RandomisePositions()
			This.Randomize()

			def RandomisePositionsQ()
				This.RandomisePositions()
				return This

	#--

		def Shuffle()
			This.Randomize()

			def ShuffleQ()
				This.Shuffle()
				return This

		def ShufflePositions()
			This.Randomize()

			def ShufflePositionsQ()
				This.ShufflePositions()
				return This

		#>

	def Randomized()
		aResult = This.Copy().RandomizeQ().Content()
		return aResult

		def Randomised()
			return This.Randomized()

		def Shuffeled()
			return This.Randomized()
		
	  #---------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE GIVEN SECTION OF THE LIST  #
	#---------------------------------------------------------------------#

	def RandomizeSection(n1, n2)
		if CheckingParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param types! n1 and n2 must be both numbers.")
			ok
		ok

		aContent = This.Content()

		nLen = n2 - n1 + 1
		anPos = NRandomNumbersBetweenU(nLen, n1, n2)
		aItems = This.ItemsAtPositions(anPos)

		j = 0
		for i = n1 to n2
			j++
			aContent[i] = aItems[j]
		next

		This.UpdateWith(aContent)

		#< @FunctionFluentForm

		def RandomizeSectionQ(n1, n2)
			This.RandomizeSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositionsInSection(n1, n2)
			This.RandomiseSection(n1, n2)

			def RandomizePositionsInSectionQ(n1, n2)
				This.RandomizePositionsInSection(n1, n2)
				return This

		#--

		def RandomiseSection(n1, n2)
			This.RandomizeSection(n1, n2)

			def RandomiseSectionQ(n1, n2)
				This.RandomiseSection(n1, n2)
				return This

		def RandomisePositionsInSection(n1, n2)
			This.RandomizeSection(n1, n2)

			def RandomisePositionsInSectionQ(n1, n2)
				This.RandomisePositionsInSection(n1, n2)
				return This

		#>

	def SectionRandomized(n1, n2)
		aResult = This.Copy().RandomizeSectionQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def PositionsInSectionRandomized(n1, n2)
			return This.SectionRandomized(n1, n2)

		#--

		def SectionRandomised(n1, n2)
			return This.SectionRandomized(n1, n2)

		def PositionsInSectionRandomised(n1, n2)
			return This.SectionRandomized(n1, n2)

		#>

	  #----------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE GIVEN SECTIONS OF THE LIST  #
	#----------------------------------------------------------------------#

	def RandomizeSections(panSections)
		if CheckingParams() = _TRUE_ # Generalise this all over the library
			if NOT ( isList(panSections) and @IsListOfPairsOfNumbers(panSections) )
				StzRaise("Incorrect param type! panSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(panSections)

		for i = 1 to nLen
			This.RandomizeSection(panSections[i][1], panSections[i][2])
		next

		#< @FunctionFluentForm

		def RandomizeSectionsQ(panSections)
			This.RandomizeSections(panSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositionsInSections(panSections)
			This.RandomiseSections(panSections)

			def RandomizePositionsInSectionsQ(panSections)
				This.RandomizePositionsInSections(panSections)
				return This

		#--

		def RandomiseSections(panSections)
			This.RandomizeSections(panSections)

			def RandomiseSectionsQ(panSections)
				This.RandomiseSections(panSections)
				return This

		def RandomisePositionsInSections(panSections)
			This.RandomizeSections(panSections)

			def RandomisePositionsInSectionsQ(panSections)
				This.RandomisePositionsInSections(panSections)
				return This

		#>

	def SectionsRandomized(panSections)
		aResult = This.Copy().RandomizeSectionsQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def PositionsInSectionsRandomized(n1, n2)
			return This.SectionsRandomized(n1, n2)

		#--

		def SectionsRandomised(n1, n2)
			return This.SectionsRandomized(n1, n2)

		def PositionsInSectionsRandomised(n1, n2)
			return This.SectionsRandomized(n1, n2)

		#>

	  #-------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS BETWEEN TWO POSITIONS OR ITEMS  #
	#-------------------------------------------------------------------#

	def RandomizeBetweenCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsPositionOrPositionsNamedParam()
			p1 = p1[2]

			This.RandomizeBetweenPositions(p1, p2) # Or RandomizSection
		ok

		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)


		#< @FunctionFluentForm

		def RandomizeBetweenCSQ(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomiseBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomiseBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#--

		def RandomizePositionsBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomizePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomizePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		def RandomisePositionsBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomisePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomisePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#>

	def RandomizedBetweenCS(p1, p2, pCaseSensitive)
		aResult = This.RandomizeBetweenCSQ(p1, p2, pCaseSensitive).Content()
		return This

		def RanomisedBetweenCS(p1, p2, pCaseSensitive)
			return This.RandomizedBetweenCS(p1, p2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RandomizeBetween(p1, p2)
		This.RandomizeBetweenCS(p1, p2, _TRUE_)

		#< @FunctionFluentForm

		def RandomizeBetweenQ(p1, p2)
			This.RandomizeBetween(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomiseBetweenQ(p1, p2)
				This.RandomiseBetweenQ(p1, p2)
				return This

		#--

		def RandomizePositionsBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomizePositionsBetweenQ(p1, p2)
				This.RandomizePositionsBetweenQ(p1, p2)
				return This

		def RandomisePositionsBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomisePositionsBetweenQ(p1, p2)
				This.RandomisePositionsBetweenQ(p1, p2)
				return This

		#>

	def RandomizedBetween(p1, p2)
		aResult = This.RandomizeBetweenQ(p1, p2).Content()
		return This

		def RanomisedBetween(p1, p2)
			return This.RandomizedBetween(p1, p2)

	  #-------------------------------------------------------------#
	 #  RANDOMIZING ITEMS POSITIONS BETWEEN TWO ITEMS IN THE LIST  #
	#-------------------------------------------------------------#

	def RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)
		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)
	
		#< @FunctionFluentForm

		def RandomizeBetweenItemsCSQ(p1, p2, pCaseSensitive)
			This.RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseBetweenItemsCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)

			def RandomiseBetweenItemsCSQ(p1, p2, pCaseSensitive)
				This.RandomiseBetweenItemsCS(p1, p2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomizeBetweenItems(p1, p2)
		This.RandomizeBetweenItemsCS(p1, p2, _TRUE_)

		#< @FunctionFluentForm

		def RandomizeBetweenItemsQ(p1, p2)
			This.RandomizeBetweenItems(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseBetweenItems(p1, p2)
			This.RandomizeBetweenItems(p1, p2)

			def RandomiseBetweenItemsQ(p1, p2)
				This.RandomiseBetweenItems(p1, p2)
				return This

		#>

	  #-----------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS NOT BETWEEN TWO POSITIONS OR ITEMS  #
	#-----------------------------------------------------------------------#

	def RandomizeNotBetweenCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsPositionOrPositionsNamedParam()
			p1 = p1[2]

			This.RandomizeNotBetweenPositions(p1, p2) # Or RandomizSection
		ok

		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)


		#< @FunctionFluentForm

		def RandomizeNotBetweenCSQ(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomiseNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomiseNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#--

		def RandomizePositionsNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomizePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomizePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		def RandomisePositionsNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomisePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomisePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#>

	def RandomizedNotBetweenCS(p1, p2, pCaseSensitive)
		aResult = This.RandomizeNotBetweenCSQ(p1, p2, pCaseSensitive).Content()
		return This

		def RanomisedNotBetweenCS(p1, p2, pCaseSensitive)
			return This.RandomizedNotBetweenCS(p1, p2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RandomizeNotBetween(p1, p2)
		This.RandomizeNotBetweenCS(p1, p2, _TRUE_)

		#< @FunctionFluentForm

		def RandomizeNotBetweenQ(p1, p2)
			This.RandomizeNotBetween(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomiseNotBetweenQ(p1, p2)
				This.RandomiseNotBetweenQ(p1, p2)
				return This

		#--

		def RandomizePositionsNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomizePositionsNotBetweenQ(p1, p2)
				This.RandomizePositionsNotBetweenQ(p1, p2)
				return This

		def RandomisePositionsNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomisePositionsNotBetweenQ(p1, p2)
				This.RandomisePositionsNotBetweenQ(p1, p2)
				return This

		#>

	def RandomizedNotBetween(p1, p2)
		aResult = This.RandomizeNotBetweenQ(p1, p2).Content()
		return This

		def RanomisedNotBetween(p1, p2)
			return This.RandomizedNotBetween(p1, p2)

	  #-----------------------------------------------------------------#
	 #  RANDOMIZING ITEMS POSITIONS NOT BETWEEN TWO ITEMS IN THE LIST  #
	#-----------------------------------------------------------------#

	def RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)
		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeAntiSection(n1, n2)
	
		#< @FunctionFluentForm

		def RandomizeNotBetweenItemsCSQ(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseNotBetweenItemsCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)

			def RandomiseNotBetweenItemsCSQ(p1, p2, pCaseSensitive)
				This.RandomiseNotBetweenItemsCS(p1, p2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomizeNotBetweenItems(p1, p2)
		This.RandomizeNotBetweenItemsCS(p1, p2, _TRUE_)

		#< @FunctionFluentForm

		def RandomizeNotBetweenItemsQ(p1, p2)
			This.RandomizeNotBetweenItems(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseNotBetweenItems(p1, p2)
			This.RandomizeNotBetweenItems(p1, p2)

			def RandomiseNotBetweenItemsQ(p1, p2)
				This.RandomiseNotBetweenItems(p1, p2)
				return This

		#>

	  #------------------------------------------------------------#
	 #  RANDOMIZING POSITIONS OF ITEMS OUTSIDE THE GIVEN SECTION  #
	#------------------------------------------------------------#

	def RandomizeAntiSection(n1, n2)
		anSections = This.FindAntiSections([ [n1, n2] ])
		This.RandomizeSections(anSections)

		#< @FunctionFluentForm

		def RandomizeAntiSectionQ(n1, n2)
			This.RandomizeAntiSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizeOutsideSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)
	
			def RandomizeOutsideSectionQ(n1, n2)
				This.RandomizeOutsideSection(n1, n2)
				return This

		#--

		def RandomiseAntiSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)

			def RandomiseAntiSectionQ(n1, n2)
				This.RandomiseAntiSection(n1, n2)
				return This

		def RandomiseOutsideSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)
	
			def RandomiseOutsideSectionQ(n1, n2)
				This.RandomizeOutsideSection(n1, n2)
				return This

		#>

	def AntiSectionRandomized(n1, n2)
		aResult = This.Copy().RandomizeAntiSectionQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def OutsideSectionRandomized(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		#--

		def AntiSectionRandomised(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		def OutsideSectionRandomised(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #  RANDOMIZING POSITIONS OF ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#-------------------------------------------------------------#

	def RandomizeAntiSections(panSections)
		anSections = This.FindAntiSections(panSections)
		This.RandomizeSections(anSections)

		#< @FunctionFluentForm

		def RandomizeAntiSectionsQ(panSections)
			This.RandomizeAntiSections(panSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizeOutsideSections(panSections)
			This.RandomizeAntiSections(panSections)
	
			def RandomizeOutsideSectionsQ(panSections)
				This.RandomizeOutsideSections(panSections)
				return This

		#--

		def RandomiseAntiSections(panSections)
			This.RandomizeAntiSections(panSections)

			def RandomiseAntiSectionsQ(panSections)
				This.RandomiseAntiSections(panSections)
				return This

		def RandomiseOutsideSections(panSections)
			This.RandomizeAntiSections(panSections)
	
			def RandomiseOutsideSectionsQ(panSections)
				This.RandomizeOutsideSections(panSections)
				return This

		#>

	def AntiSectionsRandomized(panSections)
		aResult = This.Copy().RandomizeAntiSectionsQ(panSections).Content()
		return aResult

		#< @FunctionAlternativeForms

		def OutsideSectionsRandomized(panSections)
			return This.AntiSectionsRandomized(panSections)

		#--

		def AntiSectionsRandomised(panSections)
			return This.AntiSectionsRandomized(panSections)

		def OutsideSectionsRandomised(panSections)
			return This.AntiSectionsRandomized(panSections)

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE NUMBERS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeNumbers()
		aSections = This.FindNumbersAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeNumbersQ()
			This.RandomizeNumbers()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseNumbers()
			This.RandomizeNumbers()

		def ShuffleNumbers()
			This.RandomizeNumbers()

		#>

	#-- @FunctionPassiveForm

	def NumbersRandomized()
		aResult = This.Copy().RandomizeNumbersQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def NumbersRansomised()
			return This.NumbersRandomized()

		def NumbersShuffled()
			return This.NumbersRandomized()

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE STRINGS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeStrings()
		aSections = This.FindStringsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeStringsQ()
			This.RandomizeStrings()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseStrings()
			This.RandomizeStrings()

		def ShuffleStrings()
			This.RandomizeStrings()

		#>

	#-- @FunctionPassiveForm

	def StringsRandomized()
		aResult = This.Copy().RandomizeStringsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def StringsRansomised()
			return This.StringsRandomized()

		def StringsShuffled()
			return This.StringsRandomized()

		#>

	  #-----------------------------------------------#
	 #  RANDOMINZING THE LISTS EXISTING IN THE LIST  #
	#===============================================#

	def RandomizeLists()
		aSections = This.FindListsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeListsQ()
			This.RandomizeLists()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseLists()
			This.RandomizeLists()

		def ShuffleLists()
			This.RandomizeLists()

		#>

	#-- @FunctionPassiveForm

	def ListsRandomized()
		aResult = This.Copy().RandomizeListsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ListsRansomised()
			return This.ListsRandomized()

		def ListsShuffled()
			return This.ListsRandomized()

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE OBJECTS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeObjects()
		aSections = This.FindObjectsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeObjectsQ()
			This.RandomizeObjects()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseObjects()
			This.RandomizeObjects()

		def ShuffleObjects()
			This.RandomizeObjects()

		#>

	#-- @FunctionPassiveForm

	def ObjectsRandomized()
		aResult = This.Copy().RandomizeObjectsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ObjectsRansomised()
			return This.ObjectsRandomized()

		def ObjectsShuffled()
			return This.ObjectsRandomized()

		#>

	  #=========#
	 #  WHERE  #
	#=========#

	def Where(pcCondition)
		/* EXAMPLE

		o1 = new stzList([ :StartingAt, 5 ])
		? o1.IsAPairQ().Where('{ isString(@pair[1]) and isNumber(@pair[2]) }')
		#--> _TRUE_

		*/

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		cCondition = StzStringQ(pcCondition).
				TrimQ().
				RemoveTheseBoundsQ("{","}").
				ReplaceManyCSQ([ "@list", "@pair" ], "This", _FALSE_).
				Content()

		cCode = 'bOk = (' + cCondition + ')'

		eval(cCode)
		return bOk

	  #-----------------------------------------#
	 #  GETTING THE LIST OF CHARS IN THE LIST  #
	#-----------------------------------------#

	def Chars()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_aResult_ = []

		for @i = 1 to _nLen_
			if isString(_aContent_[@i]) and @IsChar(_aContent_[@i])
				_aResult_ + _aContent_[@i]
			ok
		next

		return _aResult_

		#< @FunctionFluentForms

		def CharsQ()
			return new stzList( This.Chars() )

		def CharsQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				new stzList(This.Chars())

			on :stzListOfStrings
				new stzListOfStrings(This.Chars())

			on :stzListOfChars
				return new stzListOfChars(This.Chars())

			other
				StzRaise("Unsupported return type!")

			off
		#>

	  #-------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS IN THE LIST  #
	#-------------------------------------------#

	def NumberOfChars()
		return len(This.Chars())

		#< @FunctionFluentForm

		def NumberOfCharsQ()
			return new stzNumber( This.NumberOfChars() )

		#>

		#< @FunctionAlternativeForms

		def HowManyChars()
			return This.NumberOfChars()

			def HowManyCharsQ()
				return This.NumberOfCharsQ()

		def CountChars()
			return This.NumberOfChars()

			def CountCharsQ()
				return This.NumberOfCharsQ()

		#>

	  #-------------------------------------------#
	 #  GETTING THE LIST OF LETTERS IN THE LIST  #
	#-------------------------------------------#

	def Letters()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_aResult_ = []

		for @i = 1 to _nLen_
			if isString(_aContent_[@i]) and @IsLetter(_aContent_[@i])
				_aResult_ + _aContent_[@i]
			ok
		next

		return _aResult_

		#< @FunctionFluentForms

		def LetterQ()
			return new stzList( This.Letters() )

		def LettersQRT(pcReturnType)
			switch pcReturnType
			on :stzList
				new stzList(This.Letters())

			on :stzListOfStrings
				new stzListOfStrings(This.Letters())

			on stzListOfChars
				return new stzListOfLetters(This.Letters())

			other
				StzRaise("Unsupported return type!")

			off
		#>

	  #---------------------------------------------#
	 #  GETTING THE NUMBER OF LETTERS IN THE LIST  #
	#---------------------------------------------#

	def NumberOfLetters()
		return len(This.Letters())

		#< @FunctionFluentForm

		def NumberOfLettersQ()
			return new stzNumber( This.NumberOfLetters() )

		#>

		#< @FunctionAlternativeForms

		def HowManyLetters()
			return This.NumberOfLetters()

			def HowManyLettersQ()
				return This.NumberOfLettersQ()

		def CountLetters()
			return This.NumberOfLetters()

			def CountLettersQ()
				return This.NumberOfLettersQ()

		#>

	  #=========================================#
	 #  GETTING THE LIST OF PAIRS IN THE LIST  #
	#=========================================#

	def ContainsPairs()
		_aContent_ = This.Content()
		_nLen_ = len(_aContent_)

		_bResult_ = _FALSE_

		for i@ = 1 to _nLen_
			if isList(_aContent_[@i]) and @IsPair(_aContent_[@i])
				_bResult_ = _TRUE_
				exit
			ok
		next

		return _bResult_

		def ContainsParsQ()
			if This.ContainsPairs() = _TRUE_
				return This
			else
				return AFalseObject()
			ok

	  #-------------------------------------------#
	 #  GETTING THE NUMBER OF PAIRS IN THE LIST  #
	#-------------------------------------------#

	def NumberOfPairs()
		return len(This.Pairs())

		#< @FunctionFluentForm

		def NumberOfPairsQ()
			return new stzNumber( This.NumberOfPairs() )

		#>

		#< @FunctionAlternativeForms

		def HowManyPairs()
			return This.NumberOfPairs()

			def HowManyPairsQ()
				return This.NumberOfPairsQ()

		def CountPairs()
			return This.NumberOfPairs()

			def CountPairsQ()
				return This.NumberOfPairsQ()

		#>

	  #---------------------------------#
	 #  FINDING THE PAIRS IN THE LIST  #
	#---------------------------------#

	def FindPairs()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsPair()
				anResult + i
			ok
		next

		return anResult

	def Pairs()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsPair()
				aResult + item
			ok
		next

		return aResult

	def PairsU()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = aContent[i]

			if NOT (isList(item) and Q(item).IsPair())
				loop
			ok

			cItem = @@(item)

			if ring_find(acSeen, cItem) = 0
				aResult + item
				acSeen + cItem
			ok
	
		next

		return aResult

	def PairsZ()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = acontent[i]

			if NOT (isList(item) and Q(item).IsPair())
				loop
			ok

			if ring_find(acSeen, @@(item)) = 0
				anPos = This.Find(aContent[i])
				aResult + [ item, anPos ]
				acSeen + @@(item)
			ok
	
		next

		return aResult

	  #--------------------------------------------------------#
	 #  PAIRIFYING THE LIST BY TRANFORMING EACH ITEM TO PAIR  #
	#--------------------------------------------------------#

	def Pairify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aPair = []

			if isList(aContent[i])

				nLenTemp = len(aContent[i])
				if nLenTemp = 0
					aPair + _NULL_ + _NULL_

				but nLenTemp = 1
					aPair + aContent[i][1] + _NULL_

				but nLenTemp = 2
					aPair = aContent[i]

				else
					aPair + aContent[i][1] + aContent[i][2]
				ok
			
			else
				aPair + aContent[i] + _NULL_
			ok

			aResult + aPair
		next

		This.UpdateWith(aResult)

		def PairifyQ()
			This.Pairify()
			return This

	def Pairified()
		aResult = This.Copy().PairifyQ().Content()
		return aResult

	  #===========================================#
	 #  GETTING THE LIST OF SINGLES IN THE LIST  #TODO // Add case sensitivity
	#===========================================#

	def ContainsSingles()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = _FALSE_

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

	def NumberOfSingles()
		return len(This.Singles())

		def HowManySingles()
			return This.NumberOfSingles()

		def HowManySingle()
			return This.NumberOfSingles()

	def FindSingles()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				anResult + i
			ok
		next

		return anResult

	def Singles()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				aResult + item
			ok
		next

		return aResult

	def SinglesU()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = aContent[i]

			if NOT (isList(item) and Q(item).IsSingle())
				loop
			ok

			cItem = @@(item)

			if ring_find(acSeen, cItem) = 0
				aResult + item
				acSeen + cItem
			ok
	
		next

		return aResult

	def SinglesZ()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = acontent[i]

			if NOT (isList(item) and Q(item).IsSingle())
				loop
			ok

			if ring_find(acSeen, @@(item)) = 0
				anPos = This.Find(aContent[i])
				aResult + [ item, anPos ]
				acSeen + @@(item)
			ok
	
		next

		return aResult

	  #-----------------------------------------------------------#
	 #  SINGLIFYING THE LIST BY TRANFORMING EACH ITEM TO SINGLE  #
	#-----------------------------------------------------------#

	def Singlify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aSingle = []

			if isList(aContent[i])

				nLenTemp = len(aContent[i])
				if nLenTemp = 0
					aSingle + _NULL_

				else
					aSingle + aContent[i][1]
				ok
			
			else
				aSingle + aContent[i]
			ok

			aResult + aSingle
		next

		This.UpdateWith(aResult)

		def SinglifyQ()
			This.Singlify()
			return This

	def Singlified()
		aResult = This.Copy().SinglifyQ().Content()
		return aResult

	  #========================================================#
	 #  LISTIFYING THE LIST BY TRANFORMING EACH ITEM TO LIST  #
	#========================================================#

	def Listify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aList = []

			if isList(aContent[i])
				aList = aContent[i]

			else
				aList + aContent[i]
			ok

			aResult + aList
		next

		This.UpdateWith(aResult)
			 
		def ListifyQ()
			This.Listify()
			return This

	def Listified()
		aResult = This.Copy().ListifyQ().Content()
		return aResult

	  #-------------------------------------------------------------#
	 #  LISTIYING THE ITEMS OF THE LIST BY SIZING THEM TO N ITEMS  #
	#-------------------------------------------------------------#

	def NListify(n)
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aList = []

			if NOT isList(aContent[i])
				aList + aContent[i]
				if n > 1
					for j = 1 to n-1
						aList + _NULL_
					next
				ok
			else

				nLenList = len(aContent[i])

				if n = nLenList
					aList = aContent[i]

				but n > nLenList
					aList = aContent[i]
					for j = 1 to n - nLenList
						aList + _NULL_
					next

				but n < nLenList
					for j = 1 to n
						aList + aContent[i][j]
					next
				ok
						
			ok

			aResult + aList
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def NListifyQ(n)
			This.NListify(n)
			return This

		#>

	def NListified(n)
		aResult = This.Copy().NListifyQ(n).Content()
		return aResult

	  #============================================================#
	 #  NUMBERIFYING THE LIST BY TRANFORMING EACH ITEM TO NUMBER  #
	#============================================================#

	def Numberify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			n = 0

			if isNumber(aContent[i])
				n = aContent[i]
				aResult + n

			but isString(aContent[i])
				cNumber = StzStringQ(acontent[i]).RemoveQ("_").Content()
				n = 0+ cNumber
				aResult + n
				
			but isList(aContent[i])
				anNumberified = StzListQ(aContent[i]).Numberified()
				nLenList = len(anNumberified)
				for j = 1 to nLenList
					aResult + anNumberified[j]
				next

			but isObject(aContent[i]) and Q(aContent[i]).IsStzNumber()
				n = aContent[i].NumericValue()
				aResult + n
			ok

		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def NumberifyQ()
			This.Numberify()
			return This

		#>

		#< @FunctionAlternativeForms

		def Numbrify()
			This.Numberify()

			def NumbrifyQ()
				return This.NumberifyQ()

		def Numberfy()
			This.Numberify()

			def NumberfyQ()
				return This.NumberifyQ()

		#>

	#-- @FunctionPassiveForms

	def Numberified()
		aResult = This.Copy().NumberifyQ().Content()
		return aResult

		def Numbrified()
			return This.Numberified()

		def Numberfied()
			return This.Numberified()

		#-- @FluentPassiveFunctionForm

		def NumbrifiedQ()
			return This.NumberifyQ()

		def NumberifiedQ()
			return This.NumberifyQ()

	  #----------------------------------------------------------------#
	 #  OBJECTIFYING THE LIST BY TRANFORMING EACH ITEM TO STZ OBJECT  #
	#----------------------------------------------------------------#

	def Objectify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			aResult + Q(aContent[i])
		next

		This.UpdateWith(aResult)

		def ObjectifyQ()
			This.Objectify()
			return This

		def Softanzify()
			This.Objectify()

			def SoftanzifyQ()
				This.Softanzify()
				return This

	def Objectified()
		aResult = This.Copy().ObjectifyQ().Content()
		return aResult

		def Softanzified()
			return This.Objectified()

	# Swapping the content of the stzList with an other stzList

	def SwapWith(pOtherStzList)

		if CheckingParams()

			if NOT @IsStzList(pOtherStzList)
				StzRaise("Incorrect param type! pOtherStzList must be a stzList object.")
			ok
	
		ok

		aThis = This.Content()
		aOther = pOtherStzList.Content()

		This.UpdateWith(aOther)
		pOtherStzList.UpdateWith(aThis)


		def SwapWithQ(pOtherStzList)
			This.SwapWith(pOtherStzList)
			return This

		def SwapContentWith(pOtherStzList)
			This.SwapWith(pOtherStzList)

			def SwapContentWithQ(pOtherStzList)
				return This.SwapWithQ(pOtherStzList)

	  #========================================#
	 #    SPLITTING : THE GENERIC FUNCTION    #
	#========================================#

	def SplitXT(p)
		anPos = StzSplitterQ(This.NumberOfItems()).SplitXT(p)
		aResult = This.PositionsAt(anPos)
		This.UpdateWith( aResult )

		#< @FunctionFluentForm

		def SplitXTQ(p)
			This.SplitXT(p)
			return This

		#>

	#-- @FunctionPassiveForm

	def SplittedXT(p)
		aResult = This.Copy().This.SplitXTQ(p).Content()
		return aResult

		def SplitsXT()
			return This.SplittedXT(p)

	#-- ZZ/EXTENDED

	def SplitAsSectionsXT(p)
		aSections = This.SplitXT(p)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			nLenTemp = len(aSections[i])
			aResult + [ aSections[i][1], aSections[i][nLenTemp] ]
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtSectionsXTQ(p)
			This.SplitAtSectionsXT(p)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitXTZZ(p)
			This.SplitAsSectionsXT(p)

			def SplitXTZZQ(p)
				return This.SplitAtSectionsXTQ(p)

		#>

	def SplittedAsSectionsXT(p)
		aResult = This.Copy().SplitAsSectionsQ(p).Content()
		return aResult

		def SplittedXTZZ(p)
			return This.SplittedAsSectionsXT(p)

		def SplitsAsSectionsXT(p)
			return This.SplittedAsSectionsXT(p)

		def SplitsXTZZ(p)
			return This.SplittedAsSectionsXT(p)

	  #----------------------------------------#
	 #  SPLITTING THE LIST -- A GENERAL FORM  #
	#========================================#

	def SplitCS(pItemOrPos, pCaseSensitive)

		if isList(pItemOrPos)

			oParam = new stzList(pItemOrPos)

			if oParam.IsWithOrByOrUsingNamedParam()
				This.SplitAtCS(pItemOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAtNamedParam()
				This.SplitAtCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAtPositionNamedParam()
				return This.SplitAtPosition(pItemOrPos[2])

			but oParam.IsAtPositionsNamedParam()
				This.SplitAtPositions(pItemOrPos[2])

			but oParam.IsAtSectionNamedParam()
				This.SplitAtSection(pItemOrPos[2][1], pItemOrPos[2][2])

			but oParam.IsAtSectionIBNamedParam()
				This.SplitAtSectionIB(pItemOrPos[2][1], pItemOrPos[2][2])

			but oParam.IsAtSectionsNamedParam()
				This.SplitAtSections(pItemOrPos[2])
			
			but oParam.IsAtSectionsIBNamedParam()
				This.SplitAtSectionsIB(pItemOrPos[2])

			but oParam.IsAtItemNamedParam()
				This.SplitAtItemCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAtItemsNamedParam()
				This.SplitAtItemsCS(pItemOrPos[2], pCaseSensitive)

			#--

			but oParam.IsBeforeNamedParam()
				This.SplitBeforeCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsBeforePositionNamedParam()
				This.SplitBeforePosition(pItemOrPos[2])

			but oParam.IsBeforePositionsNamedParam()
				This.SplitBeforePositions(pItemOrPos[2])

			but oParam.IsBeforeSectionNamedParam()
				This.SplitBeforeSection(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsBeforeSectioniBNamedParam()
				This.SplitBeforeSectionIB(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsBeforeSectionsNamedParam()
				This.SplitBeforeSections(pItemOrPos[2])
	
			but oParam.IsBeforeSectionsIBNamedParam()
				This.SplitBeforeSectionsIB(pItemOrPos[2])

			but oParam.IsBeforeSubStringNamedParam()
				This.SplitBeforeItemCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsBeforeItemsNamedParam()
				This.SplitBeforeItemsCS(pItemOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAfterNamedParam()
				This.SplitAfterCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAfterPositionNamedParam()
				This.SplitAfterPosition(pItemOrPos[2])

			but oParam.IsAfterPositionsNamedParam()
				This.SplitAfterPositions(pItemOrPos[2])

			but oParam.IsAfterSectionNamedParam()
				This.SplitAfterSection(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAfterSectionIBNamedParam()
				This.SplitAfterSectionIB(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAfterSectionsNamedParam()
				This.SplitAfterSections(pItemOrPos[2])

			but oParam.IsAfterSectionsIBNamedParam()
				This.SplitAfterSectionsIB(pItemOrPos[2])

			but oParam.IsAfterItemNamedParam()
				This.SplitAfterItemCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAfterItemsNamedParam()
				This.SplitAfterItemsCS(pItemOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAroundNamedParam()
				This.SplitAroundCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAroundPositionNamedParam()
				This.SplitAroundPosition(pItemOrPos[2])

			but oParam.IsAroundPositionsNamedParam()
				This.SplitAroundPositions(pItemOrPos[2])

			but oParam.IsAroundSectionNamedParam()
				This.SplitAroundSection(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAroundSectionIBNamedParam()
				This.SplitAroundSectionIB(pItemOrPos[2][1], pSubStrOrPos[2][2])

			but oParam.IsAroundSectionsNamedParam()
				This.SplitAroundSections(pItemOrPos[2])

			but oParam.IsAroundSectionsIBNamedParam()
				This.SplitAroundSectionsIB(pItemOrPos[2])

			but oParam.IsAroundItemNamedParam()
				This.SplitAroundSubStringCS(pItemOrPos[2], pCaseSensitive)

			but oParam.IsAroundItemsNamedParam()
				This.SplitAroundSubStringsCS(pItemOrPos[2], pCaseSensitive)

			ok
		ok

		return This.SplitAtCS(pItemOrPos, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SplitCSQ(pItemOrPos, pCaseSensitive)
			return new stzList(This.SplitCS(pItemOrPos, pCaseSensitive))

		#>

		#< @FunctionAlternativeForm

		def SplitsCS(pItemOrPos, pCaseSensitive)
			return This.SplitAtCS(pItemOrPos, pCaseSensitive)

			def SplitsCSQ(pItemOrPos, pCaseSensitive)
				return This.SplitCSQ(pItemOrPos, pCaseSensitive)
	
		#>

	def SplittedCS(pItemOrPos, pCaseSensitive)
		return This.SplitCS(pItemOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Split(pItemOrPos)
		return This.SplitCS(pItemOrPos, _TRUE_)

		#< @FunctionFluentForm

		def SplitQ(pItemOrPos)
			return new stzList(This.Split(pItemOrPos))

		#>

		#< @FunctionAlternativeForm

		def Splits(pItemOrPos)
			return This.Split(pItemOrPos)

			def SplitsQ(pItemOrPos)
				return This.SplitQ(pItemOrPos)

		#>

	def Splitted(pItemOrPos)
		return This.Split(pItemOrPos)

	  #-------------------------------------------------#
	 #    SPLITTING AT THE POSITIONS OF A GIVEN ITEM   #
	#=================================================#

	def SplitAtCS(pItem, pCaseSensitive)

		aSections = StzSplitterQ(This.NumberOfItems()).
			    SplitAtPositions(This.FindCS(pItem, pCaseSensitive))

		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen

			aTempSection = []

			for j = aSections[i][1] to aSections[i][2]
				aTempSection + @aContent[j]

			next

			aResult + aTempSection

		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtCSQ(pItem, pCaseSensitive)
			This.SplitAtCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtPositionsOfCS(pItem, pCaseSensitive)
			This.SplitAtCS(pItem, pCaseSensitive)

			def SplitAtPositionsOfCSQ(pItem, pCaseSensitive)
				return This.SplitAtCSQ(pItem, pCaseSensitive)

		#==

		def SplitAtItemCS(pItem, pCaseSensitive)
			This.SplitAtCS(pItem, pCaseSensitive)

			def SplitAtItemCSQ(pItem, pCaseSensitive)
				return This.SplitAtCSQ(pItem, pCaseSensitive)

		#>

	def SplittedAtCS(pItem, pCaseSensitive)
		aResult = This.Copy().SplitAtCSQ(pItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtPositionsOfCS(pItem, pCaseSensitive)
			return This.SplittedAtCS(pItem, pCaseSensitive)

		def SplittedAtItemCS(pItem, pCaseSensitive)
			return This.SplittedAtCS(pItem, pCaseSensitive)

		def SplitsAtCS(pItem, pCaseSensitive)
			return This.SplittedAtCS(pItem, pCaseSensitive)

		def SplitsAtPositionsOfCS(pItem, pCaseSensitive)
			return This.SplittedAtCS(pItem, pCaseSensitive)

		def SplitsAtItemCS(pItem, pCaseSensitive)
			return This.SplittedAtCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pItem)
		This.SplitAtCS(pItem, _TRUE_)

		#< @FunctionFluentForm

		def SplitAtQ(pItem)
			This.SplitAt(pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtPositionsOf(pItem)
			This.SplitAt(pItem)

			def SplitAtPositionsOfQ(pItem)
				return This.SplitAtQ(pItem)

		#==

		def SplitAtItem(pItem)
			This.SplitAt(pItem)

			def SplitAtItemQ(pItem)
				return This.SplitAtQ(pItem)

		#>

	def SplittedAt(pItem)
		aResult = This.Copy().SplitAtQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtPositionsOf(pItem)
			return This.SplittedAt(pItem)

		def SplittedAtItem(pItem)
			return This.SplittedAt(pItem)

		def SplitsAt(pItem)
			return This.SplittedAt(pItem)

		def SplitsAtPositionsOf(pItem)
			return This.SplittedAt(pItem)

		def SplitsAtItem(pItem)
			return This.SplittedAt(pItem)

		#>

	  #----------------------------------------------------#
	 #  SPLITTING AT THE POSITIONS OF A GIVEN ITEM -- ZZ  #
	#----------------------------------------------------#

	def SplitAtAsSectionsCS(pItem, pCaseSensitive)
		aSections = This.SplitAtCS(pItem, pCaseSensitive)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			nLenTemp = len(aSections[i])
			aResult + [ aSections[i][1], aSections[i][nLenTemp] ]
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtAsSectionsCSQ(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAsSectionsCS(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)

			def SplitAsSectionsCSQ(pItem, pCaseSensitive)
				return This.SplitAtAsSectionsCSQ(pItem, pCaseSensitive)

		def SplitAtCSZZ(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)

			def SplitAtCSZZQ(pItem, pCaseSensitive)
				return This.SplitAtAsSectionsCSQ(pItem, pCaseSensitive)

		def SplitCSZZ(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)

			def SplitCSZZQ(pItem, pCaseSensitive)
				return This.SplitAtAsSectionsCSQ(pItem, pCaseSensitive)

		#--

		def SplitAtPositionsOfAsSectionsCS(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)

			def SplitAtPositionsOfAsSectionsCSQ(pItem, pCaseSensitive)
				return This.SplitAtAsSectionsCSQ(pItem, pCaseSensitive)

		def SplitAtPositionsOfCSZZ(pItem, pCaseSensitive)
			This.SplitAtAsSectionsCS(pItem, pCaseSensitive)

			def SplitAtPositionsOfCSZZQ(pItem, pCaseSensitive)
				return This.SplitAtAsSectionsCSQ(pItem, pCaseSensitive)

		#>

	def SplittedAsSectionsCS(pItem, pCaseSensitive)
		aResult = This.Copy().SplitAsSectionsCSQ(pItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtCSZZ(pItem, pCaseSensitive)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		def SplittedAtPositionsOfAsSectionsCS(pItem)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		def SplitsAsSectionsCS(pItem, pCaseSensitive)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		def SplitsAtPositionsOfAsSectionsCS(pItem, pCaseSensitive)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		def SplitsAtCSZZ(pItem, pCaseSensitive)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		def SplitsAtPositionsOfCSZZ(pItem, pCaseSensitive)
			return This.SplittedAsSectionsCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtAsSections(pItem)
		return This.SplitAtAsSectionsCS(pItem, _TRUE_)

		def SplitAtAsSectionsQ(pItem)
			This.SplitAtAsSections(pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAsSections(pItem)
			This.SplitAtAsSections(pItem)

			def SplitAsSectionsQ(pItem)
				return This.SplitAtAsSectionsQ(pItem)

		def SplitAtZZ(pItem)
			This.SplitAtAsSections(pItem)

			def SplitAtZZQ(pItem)
				return This.SplitAtAsSectionsQ(pItem)

		def SplitZZ(pItem)
			This.SplitAtAsSections(pItem)

			def SplitZZQ(pItem)
				return This.SplitAtAsSectionsQ(pItem)

		#--

		def SplitAtPositionsOfAsSections(pItem)
			This.SplitAtAsSections(pItem)

			def SplitAtPositionsOfAsSectionsQ(pItem)
				return This.SplitAtAsSectionsQ(pItem)

		def SplitAtPositionsOfZZ(pItem)
			This.SplitAtAsSections(pItem)

			def SplitAtPositionsOfZZQ(pItem)
				return This.SplitAtAsSectionsQ(pItem)

		#>

	def SplittedAsSections(pItem)
		aResult = This.Copy().SplitAsSectionsQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtZZ(pItem)
			return This.SplittedAsSections(pItem)

		def SplittedAtPositionsOfAsSections(pItem)
			return This.SplittedAsSections(pItem)

		def SplitsAsSections(pItem)
			return This.SplittedAsSections(pItem)

		def SplitsAtPositionsOfAsSections(pItem)
			return This.SplittedAsSections(pItem)

		def SplitsAtZZ(pItem)
			return This.SplittedAsSections(pItem)

		def SplitsAtPositionsOfZZ(pItem)
			return This.SplittedAsSections(pItem)

		#>

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#-----------------------------------#

	def SplitAtPosition(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtPosition(n)
		aResult = This.Sections(aSection)
		This.UpdateWith(aResult)

		def SplitAtPositionQ(n)
			This.SplitAtPosition(n)
			return This

	def SplittedAtPosition(n)
		aResult = This.Copy().SplitAtPositionQ(n).Content()
		return aResult

		def SplitsAtPosition(n)
			return SplittedAtPosition(n)

	#-- ZZ/EXTENDED

	def SplitAtPositionAsSections(n)
		aSections = This.SplitAtPosition(n)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			nLenTemp = len(aSections[i])
			aResult + [ aSections[i][1], aSections[i][nLenTemp] ]
		next

		This.UpdateWith(aResult)

		def SplitAtPositionAsSectionsQ(n)
			This.SplitAtPositionAsSections(n)
			return This

		def SplitAtPositionZZ(n)
			This.SplitAtPositionAsSections(n)

			def SplitAtPositionZZQ(n)
				return This.SplitAtPositionAsSectionsQ(p)

	def SplittedAtPositionAsSections(n)
		aResult = This.Copy().SplitAtPositionAsSectionsQ(n).Content()
		return aResult

		def SplitsAtPositionAsSections(n)
			return This.SplittedAtPositionAsSections(n)

		def SplittedAtPositionZZ(n)
			return This.SplittedAtPositionAsSections(n)

		def SplitsAtPositionZZ(n)
			return This.SplittedAtPositionAsSections(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtPositions(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFleuntForm

		def SplitAtPositionsQ(panPos)
			This.SplitAtPositions(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(panPos)
			This.SplitAtPositions(panPos)

			def SplitAtThesePositionsQ(panPos)
				return This.SplitAtPositionsQ(panPos)

		def SplitAtManyPositions(panPos)
			This.SplitAtPositions(panPos)

			def SplitAtManyPositionsQ(panPos)
				return This.SplitAtPositionsQ(panPos)

		#>

	def SplittedAtPositions(panPos)
		aResult = This.Copy().SplitAtPositionsQ(panPos).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtManyPositions(panPos)
			return This.SplittedAtPositions(panPos)

		def SplittedAtThesePositions(panPos)
			return This.SplittedAtPositions(panPos)

		#--

		def SplitsAtPositions(panPos)
			return This.SplittedAtPositions(panPos)

		def SplitsAtThesePositions(panPos)
			return This.SplittedAtPositions(panPos)

		def SplitsAtManyPositions(panPos)
			return This.SplittedAtPositions(panPos)

		#>

	#-- ZZ/EXTENDED

	def SplitAtPositionsAsSections(panPos)
		aSections = This.SplitAtPositions(panPos)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			nLenTemp = len(aSections[i])
			aResult + [ aSections[i][1], aSections[i][nLenTemp] ]
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtPositionsAsSectionsQ(panPos)
			This.SplitAtPositionsAsSections(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtManyPositionsAsSections(panPos)
			This.SplitAtPositionAsSections(panPos)

			def SplitAtManyPositionsAsSectionsQ(panPos)
				return This.SplitAtPositionsAsSectionsQ(panPos)

		#--

		def SplitAtPositionsZZ(panPos)
			This.SplitAtPositionAsSections(panPos)

			def SplitAtPositionsZZQ(panPos)
				return This.SplitAtPositionsAsSectionsQ(panPos)

		def SplitAtManyPositionsZZ(panPos)
			This.SplitAtPositionAsSections(panPos)

			def SplitAtManyPositionsZZQ(panPos)
				return This.SplitAtPositionsAsSectionsQ(panPos)

		#>

	def SplittedAtPositionsAsSections(panPos)
		aResult = This.Copy().SplitAtPositionsAsSectionsQ(panPos).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtManyPositionsAsSections(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplittedAtThesePositionsAsSections(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		#--

		def SplittedAtPositionsZZ(panPonPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplittedAtManyPositionsZZ(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplittedAtThesePositionsZZ(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		#--

		def SplitsAtPositionsAsSections(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplitsAtThesePositionsAsSections(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplitsAtManyPositionsAsSections(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplitsAtPositionsZZ(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplitsAtThesePositionsZZ(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		def SplitsAtManyPositionsZZ(panPos)
			return This.SplittedAtPositionsAsSections(panPos)

		#>

	  #------------------------#
	 #    SPLITTING BEFORE    #
	#========================#

	def SplitBefore(p)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBefore(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitBeforeQ(p)
			This.SplitBefore(p)
			return This

	def SplittedBefore(p)
		aResult = This.Copy().SplitBeforeQ().Content()
		return aResult

		def SplitsBefore(p)
			return This.SplittedBefore(p)

	  #---------------------------------#
	 #   SPLITTING BEFORE A POSITION   #
	#---------------------------------#

	def SplitBeforePosition(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBeforePosition(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitBeforePositionQ(n)
			This.SplitBeforePosition(n)
			return This

	def SplittedBeforePosition(n)
		aResult = This.Copy().SplitBeforePositionQ(n).Content()
		return aResult

		def SplitsBeforePosition(n)
			return This.SplittedBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBeforePositions(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitBeforePositionsQ(panPos)
			This.SplitBeforePositions(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThesePositions(panPos)
			This.SplitBeforePositions(panPos)

			def SplitBeforeThesePositionsQ(panPos)
				return This.SplitBeforePositionsQ(panPos)

		def SplitBeforeManyPositions(panPos)
			This.SplitBeforePositions(panPos)

			def SplitBeforeManyPositionsQ(panPos)
				return This.SplitBeforePositionsQ(panPos)

		#>

	def SplittedBeforePositions(panPos)
		aResult = This.Copy().SplitBeforePositionsQ(panPos).Content()
		return aResult

		def SplittedBeforeManyPositons(panPos)
			return This.SplittedBeforePositions(panPos)

		def SplittedBeforeThesePositons(panPos)
			return This.SplittedBeforePositions(panPos)

		def SplitsBeforePositions(panPos)
			return This.SplittedBeforePositions(panPos)

		def SplitsBeforeManyPositions(panPos)
			return This.SplittedBeforePositions(panPos)

		def SplitsBeforeThesePositions(panPos)
			return This.SplittedBeforePositions(panPos)

	  #-----------------------#
	 #    SPLITTING AFTER    #
	#=======================#

	def SplitAfter(p)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfter(p)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAfterQ(p)
			This.SplitAfter(p)
			return This

	def SplittedAfter(p)
		aResult = This.SplitAfterQ(p).Content()
		return aResult

		def SplitsAfter(p)
			return This.SplittedAfter(p)

	  #--------------------------------------#
	 #   SPLITTING AFTER A GIVEN POSITION   #
	#--------------------------------------#

	def SplitAfterPosition(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterPosition(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAfterPositionQ(n)
			This.SplitAfterPosition(n)
			return This

	def SplittedAfterPosition(n)
		aResult = This.Copy().SplitAfterPositionQ(n).Content()
		return aResult

		def SplitsAfterPosition(n)
			return This.SplittedAfterPosition(n)

	  #------------------------------------#
	 #   SPLITTING AFTER MANY POSITIONS   #
	#------------------------------------#

	def SplitAfterPositions(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterPositions(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)


		#< @FunctionFluentForm

		def SplitAfterPositionsQ(panPos)
			This.SplitAfterPositions(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAfterThesePositions(panPos)
			return This.SplitAfterPositions(panPos)

			def SplitAfterThesePositionsQ(panPos)
				return This.SplitAfterPositionsQ(panPos)

		def SplitAfterManyPositions(panPos)
			return This.SplitAfterPositions(panPos)

			def SplitAfterManyPositionsQ(panPos)
				return This.SplitAfterPositionsQ(panPos)

		#>

	def SplittedAfterPositions(panPos)
		aResult = This.Copy().SplitAfterPositionsQ(panPos).Content()
		return aResult

		def SplitsAfterPositions(panPos)
			return This.SplittedAfterPositions(panPos)

		def SplitsAfterThesePositions(panPos)
			return This.SplittedAfterPositions(panPos)

		def SplitsAfterManyPositions(panPos)
			return This.SplittedAfterPositions(panPos)

		#>

	  #---------------------------------#
	 #  SPLITTING AT A GIVEN SECTION   #
	#=================================#

	def SplitAtSection(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtSection(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtSectionQ(n1, n2)
			This.SplitAtSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtThisSection(n1, n2)
			This.SplitAtSection(n1, n2)

			def SplitAtThisSectionQ(n1, n2)
				return This.SplitAtSectionQ(n1, n2)

		def SplitBetween(n1, n2)
			This.SplitAtSection(n1, n2)

			def SplitBetweenQ(n1, n2)
				return This.SplitAtSectionQ(n1, n2)

		def SplitBetweenPositions(n1, n2)
			This.SplitAtSection(n1, n2)

			def SplitBetweenPositionsQ(n1, n2)
				return This.SplitAtSectionQ(n1, n2)

		def SplitBetweenThesePositions(n1, n2)
			This.SplitAtSection(n1, n2)

			def SplitBetweenThesePositionsQ(n1, n2)
				return This.SplitAtSectionQ(n1, n2)

		def SplitBetweenManyPositions(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitBetweenManyPositionsQ(n1, n2)
				return This.SplitAtSectionQ(n1, n2)

		#>

	def SplittedAtSection(n1, n2)
		aResult = This.Copy().SplitAtSectionQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplittedBetween(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplittedBetweenPositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplittedBetweenThesePositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplittedBetweenManyPositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		#--

		def SplitsAtSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplitsAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplitsBetween(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplitsBetweenPositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplitsBetweenThesePositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		def SplitsBetweenManyPositions(n1, n2)
			return This.SplittedAtSection(n1, n2)

		#>

	#-- IB/EXTENDED

	def SplitAtSectionIB(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtSectionIB(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtSectionIBQ(n1, n2)
			This.SplitAtSectionIB(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAtThisSectionIB(n1, n2)
			This.SplitAtSection(n1, n2)

			def SplitAtThisSectionIBQ(n1, n2)
				return This.SplitAtSectionIBQ(n1, n2)

		def SplitBetweenIB(n1, n2)
			This.SplitAtSectionIB(n1, n2)

			def SplitBetweenIBQ(n1, n2)
				return This.SplitAtSectionIBQ(n1, n2)

		def SplitBetweenPositionsIB(n1, n2)
			This.SplitAtSectionIB(n1, n2)

			def SplitBetweenPositionsIBQ(n1, n2)
				return This.SplitAtSectionIBQ(n1, n2)

		def SplitBetweenThesePositionsIB(n1, n2)
			This.SplitAtSectionIB(n1, n2)

			def SplitBetweenThesePositionsIBQ(n1, n2)
				return This.SplitAtSectionIBQ(n1, n2)

		def SplitBetweenManyPositionsIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitBetweenManyPositionsIBQ(n1, n2)
				return This.SplitAtSectionIBQ(n1, n2)

		#>

	def SplittedAtSectionIB(n1, n2)
		aResult = This.Copy().SplitAtSectionIBQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplittedBetweenIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplittedBetweenPositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplittedBetweenThesePositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplittedBetweenManyPositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		#--

		def SplitsAtSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplitsAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplitsBetweenIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplitsBetweenPositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplitsBetweenThesePositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		def SplitsBetweenManyPositionsIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

		#>

	  #------------------------------#
	 #  SPLITTING AT MANY SECTIONS  #
	#------------------------------#

	def SplitAtSections(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtSections(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtSectionsQ(paSections)
			This.SplitAtSections(paSections)
			return This

		#>

		#< @FunnctionAlternativeForms

		def SplitAtTheseSections(paSections)
			This.SplitAtSections(paSections)

			def SplitAtTheseSectionsQ(paSections)
				return This.SplitAtSectionsQ(paSections)

		def SplitBetweenSections(paSections)
			This.SplitAtSections(paSections)

			def SplitBetweenSectionsQ(paSections)
				return This.SplitAtSectionsQ(paSections)

		def SplitBetweenTheseSections(paSections)
			This.SplitAtSections(paSections)

			def SplitBetweenTheseSectionsQ(paSections)
				return This.SplitAtSectionsQ(paSections)

		def SplitAtManySections(paSections)
			This.SplitAtSections(paSections)

			def SplitAtManySectionsQ(paSections)
				return This.SplitAtSectionsQ(paSections)

		def SplitBetweenManySections(paSections)
			This.SplitAtSections(paSections)

			def SplitBetweenManySectionsQ(paSections)
				return This.SplitAtSectionsQ(paSections)

		#>

	def SplittedAtSections(paSections)
		aResult = This.Copy().SplitAtSectionsQ(paSections).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplitsAtSections(paSections)
			return This.SplittedAtSections(paSections)

		def SplitsAtTheseSections(paSections)
			return This.SplittedAtSections(paSections)

		def SplitsBetweenSections(paSections)
			return This.SplittedAtSections(paSections)

		def SplitsBetweenTheseSections(paSections)
			return This.SplittedAtSections(paSections)

		def SplitsAtManySections(paSections)
			return This.SplittedAtSections(paSections)

		def SplitsBetweenManySections(paSections)
			return This.SplittedAtSections(paSections)

		#>

	#-- IB/EXtENDED

	def SplitAtSectionsIB(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtSectionsIB(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAtSectionsIBQ(paSections)
			This.SplitAtSectionsIB(paSections)
			return This

		#>

		#< @FunnctionAlternativeForms

		def SplitAtTheseSectionsIB(paSections)
			This.SplitAtSectionsIB(paSections)

			def SplitAtTheseSectionsIBQ(paSections)
				return This.SplitAtSectionsIBQ(paSections)

		def SplitBetweenSectionsIB(paSections)
			This.SplitAtSectionsIB(paSections)

			def SplitBetweenSectionsIBQ(paSections)
				return This.SplitAtSectionsIBQ(paSections)

		def SplitBetweenTheseSectionsIB(paSections)
			This.SplitAtSectionsIB(paSections)

			def SplitBetweenTheseSectionsIBQ(paSections)
				return This.SplitAtSectionsIBQ(paSections)

		def SplitAtManySectionsIB(paSections)
			This.SplitAtSectionsIB(paSections)

			def SplitAtManySectionsIBQ(paSections)
				return This.SplitAtSectionsIBQ(paSections)

		def SplitBetweenManySectionsIB(paSections)
			This.SplitAtSectionsIB(paSections)

			def SplitBetweenManySectionsIBQ(paSections)
				return This.SplitAtSectionsIBQ(paSections)

		#>

	def SplittedAtSectionsIB(paSections)
		aResult = This.Copy().SplitAtSectionsIBQ(paSections).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplitsAtSectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		def SplitsAtTheseSectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		def SplitsBetweenSectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		def SplitsBetweenTheseSectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		def SplitsAtManySectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		def SplitsBetweenManySectionsIB(paSections)
			return This.SplittedAtSectionsIB(paSections)

		#>

	  #=====================================#
	 #  SPLITTING BEFORE A GIVEN SECTION   #
	#=====================================#

	def SplitBeforeSection(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBeforeSection(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitBeforeSectionQ(n1, n2)
			This.SplitBeforeSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSection(n1, n2)
			This.SplitBeforeSection(n1, n2)

			def SplitBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeSectionQ(n1, n2)

		#>

	def SplittedBeforeSection(n1, n2)
		aResult = This.Copy().SplitBeforeThisSectionQ(n1, n2).Content()
		return aResult

		def SplitsBeforeSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

		def SplitsBeforeThisSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

	#-- IB/EXTENDED

	def SplitBeforeSectionIB(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBeforeSectionIB(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitBeforeSectionIBQ(n1, n2)
			This.SplitBeforeSectionIB(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSectionIB(n1, n2)
			This.SplitBeforeSectionIB(n1, n2)

			def SplitBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeSectionIBQ(n1, n2)

		#>

	def SplittedBeforeSectionIB(n1, n2)
		aResult = This.Copy().SplitBeforeThisSectionIBQ(n1, n2).Content()
		return aResult

		def SplitsBeforeSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

		def SplitsBeforeThisSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

	  #----------------------------------#
	 #  SPLITTING BEFORE MANY SECTIONS  #
	#----------------------------------#

	def SplitBeforeSections(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitBeforeSections(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitBeforeSectionsQ(paSections)
			This.SplitBeforeSections(paSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSections(paSections)
			This.SplitBeforeSections(paSections)

			def SplitBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeSectionsQ(paSections)

		def SplitBeforeManySections(paSections)
			This.SplitBeforeSections(paSections)

			def SplitBeforeManySectionsQ(paSections)
				return This.SplitBeforeSectionsQ(paSections)

		#>

	def SplittedBeforeSections(paSections)
		aResult = This.Copy().SplitBeforeSectionsQ(paSections).Content()
		return aResult

		#< @FunctionFluentForm

		def SplitsBeforeSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplitsBeforeTheseSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplitsBeforeManySections(paSections)
			return This.SplittedBeforeSections(paSections)

		#>

	#-- IB/EXTENDED

	def SplitBeforeSectionsIB(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterPositionsIB(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitBeforeSectionsIBQ(paSections)
			This.SplitBeforeSectionsIB(paSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSectionsIB(paSections)
			This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeSectionsIBQ(paSections)

		def SplitBeforeManySectionsIB(paSections)
			This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeSectionsIBQ(paSections)

		#>

	def SplittedBeforeSectionsIB(paSections)
		aResult = This.Copy().SplitBeforeSectionsIBQ(paSections).Content()
		return aResult

		#< @FunctionFluentForm

		def SplitsBeforeSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplitsBeforeTheseSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplitsBeforeManySectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		#>

	  #====================================#
	 #  SPLITTING AFTER A GIVEN SECTION   #
	#====================================#

	def SplitAfterSection(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterSection(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAfterSectionQ(n1, n2)
			This.SplitAfterSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSection(n1, n2)
			This.SplitAfterSection(n1, n2)

			def SplitAfterThisSectionQ(n1, n2)
				return This.SplitAfterSectionQ(n1, n2)

		#>

	def SplittedAfterSection(n1, n2)
		aResult = This.Copy().SplitAfterThisSectionQ(n1, n2).Content()
		return aResult

		def SplitsAfterSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

		def SplitsAfterThisSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

	#-- IB/EXTENDED

	def SplitAfterSectionIB(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterSectionIB(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAfterSectionIBQ(n1, n2)
			This.SplitAfterSectionIB(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSectionIB(n1, n2)
			This.SplitAfterSectionIB(n1, n2)

			def SplitAfterThisSectionIBQ(n1, n2)
				return This.SplitAfterSectionIBQ(n1, n2)

		#>

	def SplittedAfterSectionIB(n1, n2)
		aResult = This.Copy().SplitAfterThisSectionIBQ(n1, n2).Content()
		return aResult

		def SplitsAfterSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

		def SplitsAfterThisSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

	  #---------------------------------#
	 #  SPLITTING AFTER MANY SECTIONS  #
	#---------------------------------#

	def SplitAfterSections(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterSections(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAfterSectionsQ(paSections)
			This.SplitAfterSections(paSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAfterTheseSections(paSections)
			This.SplitAfterSections(paSections)

			def SplitAfterTheseSectionsQ(paSections)
				return This.SplitAfterSectionsQ(paSections)

		def SplitAfterManySections(paSections)
			This.SplitAfterSections(paSections)

			def SplitAfterManySectionsQ(paSections)
				return This.SplitAfterSectionsQ(paSections)

		#>

	def SplittedAfterSections(paSections)
		aResult = This.Copy().SplitAfterSectionsQ(paSections).Content()
		return aResult

		#< @FunctionFluentForm

		def SplitsAfterSections(paSections)
			return This.SplittedAfterSections(paSections)

		def SplitsAfterTheseSections(paSections)
			return This.SplittedAfterSections(paSections)

		def SplitsAfterManySections(paSections)
			return This.SplittedAfterSections(paSections)

		#>

	#-- IB/EXTENDED

	def SplitAfterSectionsIB(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAfterSectionsIB(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitAfterSectionsIBQ(paSections)
			This.SplitAfterSectionsIB(paSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def SplitAfterTheseSectionsIB(paSections)
			This.SplitAfterSectionsIB(paSections)

			def SplitAfterTheseSectionsIBQ(paSections)
				return This.SplitAfterSectionsIBQ(paSections)

		def SplitAfterManySectionsIB(paSections)
			This.SplitAfterSectionsIB(paSections)

			def SplitAfterManySectionsIBQ(paSections)
				return This.SplitAfterSectionsIBQ(paSections)

		#>

	def SplittedAfterSectionsIB(paSections)
		aResult = This.Copy().SplitAfterSectionsIBQ(paSections).Content()
		return aResult

		#< @FunctionFluentForm

		def SplitsAfterSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

		def SplitsAfterTheseSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

		def SplitsAfterManySectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

		#>

	  #----------------------------------------#
	 #   SPLITTING TO PARTS OF N ITEMS -- XT  #
	#========================================#
	# When a part remains with lower items then N it is also returned

	def SplitToPartsOfNItemsXT(n)

		aSections = StzSplitterQ(This.NumberOfItems()).SplitToPartsOfNItemsXT(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitToPartsOfNItemsXTQ(n)
			This.SplitToPartsOfNItemsXT(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfNXT(n)
			This.SplitToPartsOfNItemsXT(n)

		def SplitToPartsOfXT(n)
			This.SplitToPartsOfNItemsXT(n)

		def SplitToPartsOfNPositionsXT(n)
			This.SplitToPartsOfNItemsXT(n)

		#--

		def SplitToSectionsOfNItemsXT(n)
			This.SplitToPartsOfNItemsXT(n)

		def SplitToSectionsOfNXT(n)
			This.SplitToPartsOfNItemsXT(n)

		def SplitToSectionsOfXT(n)
			This.SplitToPartsOfNItemsXT(n)

		def SplitToSectionsOfNPositionsXT(n)
			This.SplitToPartsOfNItemsXT(n)

		#>

	def SplittedToPartsOfNItemsXT(n)
		aResult = This.Copy().SplitToPartsOfNItemsXTQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplitsToPartsOfNItemsXT(n)
			return This.SplittedToPartsOfNItemsXT(n)

		def SplitsToPartsOfNXT(n)
			return This.SplittedToPartsOfNItemsXT(n)

		def SplitsToPartsOfXT(n)
			return This.SplittedToPartsOfNItemsXT(n)

		def SplitsToPartsOfNPositionsXT(n)
			return This.SplittedToPartsOfNItemsXT(n)

		#--

		def SplittedToSectionsOfNItemsXT(n)
			return This.SplittedToPartsOfNItemsXT(n)

		def SplitsToSectionsOfNItemsXT(n)
			return This.SplittedToSectionsOfNItemsXT(n)

		def SplitsToSectionsOfNXT(n)
			return This.SplittedToSectionsOfNItemsXT(n)

		def SplitsToSectionsOfXT(n)
			return This.SplittedToSectionsOfNItemsXT(n)

		def SplitsToSectionsOfNPositionsXT(n)
			return This.SplittedToSectionsOfNItemsXT(n)

		#>

	  #---------------------------------------------#
	 #    SPLITTING TO PARTS OF EXACTLY N ITEMS    #
	#---------------------------------------------#

	def SplitToPartsOfNItems(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitToPartsOfNItems(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def SplitToPartsOfNItemsQ(n)
			This.SplitToPartsOfNItems(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfN(n)
			This.SplitToPartsOfNItems(n)

		def SplitToPartsOf(n)
			This.SplitToPartsOfNItems(n)

		#--

		def SplitToPartsOfExactlyN(n)
			This.SplitToPartsOfNItems(n)

		def SplitToPartsOfExactly(n)
			This.SplitToPartsOfNItems(n)

		def SplitToPartsOfExactlyNItems(n)
			This.SplitToPartsOfNItems(n)

		#==

		def SplitToSectionsOfNItems(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOfN(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOf(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOfNPositions(n)
			This.SplitToPartsOfNItems(n)

		#--

		def SplitToSectionsOfExactlyNItems(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOfExactlyN(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOfExactly(n)
			This.SplitToPartsOfNItems(n)

		def SplitToSectionsOfExactlyNPositions(n)
			This.SplitToPartsOfNItems(n)

		#>

	def SplittedToPartsOfNItems(n)
		aResult = This.Copy().SplitToPartsOfNItemsQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def SplittedToPartsOfN(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToPartsOf(n)
			return This.SplittedToPartsOfNItems(n)

		#--

		def SplittedToPartsOfExactlyN(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToPartsOfExactly(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToPartsOfExactlyNItems(n)
			return This.SplittedToPartsOfNItems(n)

		#==

		def SplittedToSectionsOfN(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToSectionsOfExactlyN(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToSectionsOfNItems(n)
			return This.SplittedToPartsOfNItems(n)

		def SplitsToSectionsOfNItems(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOfN(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOf(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOfNPositions(n)
			return This.SplittedToSectionsOfNItems(n)

		#--

		def SplittedToSectionsOfExactlyNItems(n)
			return This.SplittedToPartsOfNItems(n)

		def SplitsToSectionsOfExactlyNItems(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOfExactlyN(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOfExactly(n)
			return This.SplittedToSectionsOfNItems(n)

		def SplitsToSectionsOfExactlyNPositions(n)
			return This.SplittedToSectionsOfNItems(n)

		#>

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#----------------------------#

	def SplitToNParts(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitToNParts(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitToNPartsQ(n)
			This.SplitToNParts(n)
			return This

		def SplitToNSections(n)
			return This.SplitToNParts(n)

			def SplitToNSectionsQ(n)
				return This.SplitToNPartsQ(n)

	def SplittedToNParts(n)
		aResult = This.Copy().SplitToNPartsQ(n).Content()
		return aResult

		def SplitsToNParts(n)
			return This.SplittedToNParts(n)

		def SplittedToNSections(n)
			return This.SplittedToNParts(n)

		def SplitsToNSections(n)
			return This.SplittedToNParts(n)

	  #-----------------------------------------------#
	 #  SPLITTING AROUND POSITION(S) OR SECTION(s)  #
	#===============================================#

	def SplitAround(p)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAround(p)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundQ(p)
			This.SplitAround(p)
			return This

	def SplittedAround(p)
		aResult = This.Content().SplitAroundQ(p).Content()
		return aResult

		def SplitsAround(p)
			return This.SplittedAround(p)

	#-- IB/EXTENDED

	def SplitAroundIB(p)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundIB(p)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundIBQ(p)
			This.SplitAroundIB(p)
			return This

	def SplittedAroundIB(p)
		aResult = This.Content().SplitAroundQ(p).ContentIB()
		return aResult

		def SplitsAroundIB(p)
			return This.SplittedAroundIB(p)

	  #-------------------------------#
	 #  SPLITTING AROUND A POSITION  #
	#===============================#

	def SplitAroundPosition(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundPosition(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundPositionQ(n)
			This.SplitAroundPosition(n)
			return This

	def SplittedAroundPosition(n)
		aResult = This.Content().SplitAroundPositionQ(n).Content()
		return aResult

		def SplitsAroundPosition(n)
			return This.SplittedAroundPosition(n)

	#-- IB/EXTENDED

	def SplitAroundPositionIB(n)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundPositionIB(n)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundPositionIBQ(n)
			This.SplitAroundPositionIB(n)
			return This

	def SplittedAroundPositionIB(n)
		aResult = This.Content().SplitAroundPositionQ(n).ContentIB()
		return aResult

		def SplitsAroundPositionIB(n)
			return This.SplittedAroundPositionIB(n)

	  #------------------------------#
	 #  SPLITTING AROUND POSITIONS  #
	#------------------------------#

	def SplitAroundPositions(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundPositions(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundPositionsQ(panPos)
			This.SplitAroundPositions(panPos)
			return This

	def SplittedAroundPositions(panPos)
		aResult = This.Content().SplitAroundPositionsQ(panPos).Content()
		return aResult

		def SplitsAroundPositions(panPos)
			return This.SplittedAroundPositions(panPos)

	#-- IB/EXTENDED

	def SplitAroundPositionsIB(panPos)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundPositionsIB(panPos)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundPositionsIBQ(panPos)
			This.SplitAroundPositionsIB(panPos)
			return This

	def SplittedAroundPositionsIB(panPos)
		aResult = This.Content().SplitAroundPositionsQ(panPos).ContentIB()
		return aResult

		def SplitsAroundPositionsIB(panPos)
			return This.SplittedAroundPositionsIB(panPos)

	  #------------------------------#
	 #  SPLITTING AROUND A SECTION  #
	#==============================#

	def SplitAroundSection(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundSection(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundSectionQ(n1, n2)
			This.SplitAroundSection(n1, n2)
			return This

	def SplittedAroundSection(n1, n2)
		aResult = This.Content().SplitAroundSectionQ(n1, n2).Content()
		return aResult

		def SplitsAroundSection(n1, n2)
			return This.SplittedAroundSection(n1, n2)

	#-- IB/EXTENDED

	def SplitAroundSectionIB(n1, n2)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundSectionIB(n1, n2)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundSectionIBQ(n1, n2)
			This.SplitAroundSectionIB(n1, n2)
			return This

	def SplittedAroundSectionIB(n1, n2)
		aResult = This.Content().SplitAroundSectionQ(n1, n2).ContentIB()
		return aResult

		def SplitsAroundSectionIB(n1, n2)
			return This.SplittedAroundSectionIB(n1, n2)

	  #-----------------------------#
	 #  SPLITTING AROUND SECTIONS  #
	#-----------------------------#

	def SplitAroundSections(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundSections(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundSectionsQ(paSections)
			This.SplitAroundSections(paSections)
			return This

	def SplittedAroundSections(paSections)
		aResult = This.Content().SplitAroundSectionsQ(paSections).Content()
		return aResult

		def SplitsAroundSections(paSections)
			return This.SplittedAroundSections(paSections)

	#-- IB/EXTENDED

	def SplitAroundSectionsIB(paSections)
		aSections = StzSplitterQ(This.NumberOfItems()).SplitAroundSectionsIB(paSections)
		aResult = This.Sections(aSections)
		This.UpdateWith(aResult)

		def SplitAroundSectionsIBQ(paSections)
			This.SplitAroundSectionsIB(paSections)
			return This

	def SplittedAroundSectionsIB(paSections)
		aResult = This.Content().SplitAroundSectionsQ(paSections).ContentIB()
		return aResult

		def SplitsAroundSectionsIB(paSections)
			return This.SplittedAroundSectionsIB(paSections)

	  #---------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDITION   #
	#=======================================#

	def SplitW(pcCondition)
		# EXAMPLE
		# ? StzListQ(1:5).SplittedW('Q(This[@i]).IsMultipleOf(2)')


		if isList(pcCondition)

			oParam = new stzList(pccondition)

			if oParam.IsWhereNamedParam()
				This.SplitAtW(pcCondition[2])

			but oParam.IsAtNamedParam()
				This.SplitAtW(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				This.SplitBeforeW(pcCondition[2])

			but oParam.IsAfterNamedParam()
				This.SplitAfterW(pcCondition[2])

			ok
		
		else

			This.SplitAtW(pcCondition)
		ok

		#< @FunctionFluentForm

		def SplitWQ(pcCondition)
			This.SplitW(pcCondition)
			return This

		#>

	def SplittedW(pcCondition)
		aResult = This.Copy().SplitWQ(pcCondition).Content()
		return aResult

		def SplitsW(pcCondition)
			return This.SplittedW(pcCondition)

	  #-----------------------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDITION -- XT/EXTENDED  #
	#-----------------------------------------------------#

	def SplitWXT(pcCondition)
		# EXAMPLE:
		# ? StzListQ(1:5).SplittedW('Q(@item).IsMultipleOf(2)')
		
		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				This.SplitAtWXT(pcCondition[2])

			but oParam.IsAtNamedParam()
				This.SplitAtWXT(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				This.SplitBeforeWXT(pcCondition[2])

			but oParam.IsAfterNamedParam()
				This.SplitAfterWXT(pcCondition[2])

			ok
		
		else

			This.SplitAtWXT(pcCondition)
		ok

		#< @FunctionFluentForm

		def SplitWXTQ(pcCondition)
			This.SplitWXT(pcCondition)
			return This

		#>

	def SplittedWXT(pcCondition)
		aResult = This.Copy().SplitWXTQ(pcCondition).Content()
		return aResult

		def SplitsWXT(pcCondition)
			return This.SplittedWXT(pcCondition)

	  #------------------------------------#
	 #    SPLITTING AT A GIVEN CONDITION   #
	#====================================#

	def SplitAtW(pcCondition)

		anPos = This.FindW(pcCondition)
		This.SplitAtPositions(anPos)


		#< @FunctionFluentForm

		def SplkitAtWQ(pcCondition)
			This.SplitAtW(pccondition)
			return This

		#>

	def SplittedAtW(pcCondition)
		aResult = This.Copy().SplitAtWQ(pcCondition).Content()
		return aResult

		def SplitsAtW(pcCondition)
			return This.SplittedAtW(pcCondition)

	  #---------------------------------------------------#
	 #    SPLITTING AT A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------#

	def SplitAtWXT(pcCondition)

		anPos = This.FindWXT(pcCondition)
		This.SplitAtPositions(anPos)


		#< @FunctionFluentForm

		def SplitAtWXTQ(pcCondition)
			This.SplitAtWXT(pccondition)
			return This

		#>

	def SplittedAtWXT(pcCondition)
		aResult = This.Copy().SplitAtWXTQ(pcCondition).Content()
		return aResult

		def SplitsAtWXT(pcCondition)
			return This.SplittedAtWXT(pcCondition)

	  #----------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDITION   #
	#========================================#

	def SplitBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		This.SplitBeforePositions(anPos)

		#< @FunctionFluentForm

		def SplitBeforeWQ(pcCondition)
			This.SplitBeforeW(pcCondition)
			return This

		#>

	def SplittedBeforeW(pcCondition)
		aResult = This.Copy().SplitBeforeWQ(pcCondition).Content()
		return aResult

		def SplitsBeforeW(pcCondition)
			return This.SplittedBeforeW(pcCondition)

	  #------------------------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDITION -- XT/EXTENDED  #
	#------------------------------------------------------#

	def SplitBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		This.SplitBeforePositions(anPos)

		#< @FunctionFluentForm

		def SplitBeforeWXTQ(pcCondition)
			This.SplitBeforeWXT(pcCondition)
			return This

		#>

	def SplittedBeforeWXT(pcCondition)
		aResult = This.Copy().SplitBeforeWXTQ(pcCondition).Content()
		return aResult

		def SplitsBeforeWXT(pcCondition)
			return This.SplittedBeforeWXT(pcCondition)

	  #----------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDITION   #
	#========================================#

	def SplitAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		This.SplitAfterPositions(anPos)

		#< @FunctionFluentForm

		def SplitAfterWQ(pcCondition)
			This.SplitAfterW(pcCondition)
			return This

		#>

	def SplittedAfterW(pcCondition)
		aResult = This.Copy().SplitAfterWQ(pcCondition).Content()
		return aResult

		def SplitsAfterW(pcCondition)
			return This.SplittedAfterW(pcCondition)

	  #------------------------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDITION -- XT/EXTENDED  #
	#------------------------------------------------------#

	def SplitAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		This.SplitAfterPositions(anPos)

		#< @FunctionFluentForm

		def SplitAfterWXTQ(pcCondition)
			This.SplitAfterWXT(pcCondition)
			return This

		#>

	def SplittedAfterWXT(pcCondition)
		aResult = This.Copy().SplitAfterWXTQ(pcCondition).Content()
		return aResult

		def SplitsAfterWXT(pcCondition)
			return This.SplittedAfterWXT(pcCondition)

	  #-----------------------------------------------------------#
	 #  NTH ITEM AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#===========================================================#
	# Utility function used to simplify code in stzListOfStrings

	def NthItemAfterSplittingStringUsing(n, cSep)
	#TODO // Remake it using FindNthSplitZZ(n)

		return This.Split(cSep)[n]

		def NthSplit(n, cSep)
			return This.NthItemAfterSplittingStringUsing(n, cSep)

	  #========================#
	 #   FINDING THE SPLITS   #
	#========================#

	def FindSplitsCSXT(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindSplitsAtCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindSplitsAtPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindSplitsAtPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindSplitsAtItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindSplitsAtItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindSplitsAtSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindSplitsAtSections(pItem[2])

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindSplitsBeforeCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindSplitsBeforePosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindSplitsBeforePositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindSplitsBeforeItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindSplitsBeforeSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindSplitsBeforeSections(pItem[2])

		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindSplitsAfterCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindSplitsAfterPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindSplitsAfterPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindSplitsAfterItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindSplitsAfterItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindSplitsAfterSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindSplitsAfterSections(pItem[2])

		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindSplitsBetweenCS(pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindSplitsBetweenPositions(pItem[1], pItem[2])

		but oParam.IsBetweenItemsNamedParam()
			return This.FindSplitsBetweenItemsCS(pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindSplitsToNParts(pItem[2])

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindSplitsToPartsOfNItems(pItem[2])

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindSplitsAtW(pItem[2])

		but oParam.IsBeforeWhereNamedParam()
			return This.FindSplitsBeforeW(pItem[2])

		but oParam.IsAfterWhereNamedParam()
			return This.FindSplitsAfterW(pItem[2])

		else
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindSplitsCSXTZ(pItem, pCaseSensitive)
			return This.FindSplitsCSXT(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXT(pItem)
		return This.FindSplitsCSXT(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsXTZ(pItem)
			return This.FindSplitsXT(pItem)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN Item  #
	#====================================================#

	def FindSplitsAtCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindSplitsAtPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsAtPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsAtItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsAtItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsAtSection(pItem[2][1], pItem[2][2])
	
		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsAtSectionIB(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsAtSections(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsAtSectionsIB(pItem[2])

		else
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindSplitsAtCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAt(pItem)
		return This.FindSplitsAtCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtZ(pItem)
			return This.FindSplitsAtCS(pSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN POSITION   #
	#========================================#

	def FindSplitsAtPosition(n)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAtPosition(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPosition(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtPositionZ(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtThisPositionZ(n)
			return This.FindSplitsAtPosition(n)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AT MANY POSITIONS   #
	#--------------------------------------#

	def FindSplitsAtPositions(anPos)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		#--

		def FindSplitsAtPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtThesePositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN Item   #
	#=========================================#

	def FindSplitsAtItemCS(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		anResult = This.FindManyCS( This.SplitsAtItemCS(pItem, pCaseSensitive), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsAtItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItem(pItem)
		return This.FindSplitsAtItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplits(pItem)
			return This.FindSplitsCS(pItem, _TRUE_)

		def FindSplitsAtThisItem(pItem)
			return This.FindSplitsAtThisItemCS(pItem, _TRUE_)
		#--

		def FindSplitsAtItemZ(pItem)
			return This.FindSplitsAtItemCS(pItem, _TRUE_)

		def FindSplitsZ(pItem)
			return This.FindSplitsCS(pItem, _TRUE_)

		def FindSplitsAtThisItemZ(pItem)
			return This.FindSplitsAtThisItemCS(pItem, _TRUE_)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT GIVEN Items   #
	#----------------------------------------#

	def FindSplitsAtItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsAtItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItems(paItems)
		return This.FindSplitsAtItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItems(paItems)
			return This.FindSplitsAtItems(paItems)
	
		def FindSplitsAtManyItems(paItems)
			return This.FindSplitsAtItems(paItems)

		#--

		def FindSplitsAtItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		def FindSplitsAtTheseItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		def FindSplitsAtManyItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		#>

	  #---------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION   #
	#=======================================#

	def FindSplitsAtSectionCS(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSection(n1, n2)
		return This.FindSplitsAtSectionCS(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSection(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#--

		def FindSplitsAtSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		def FindSplitsAtThisSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#==========================================================#

	def FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIB(n1, n2)
		return This.FindSplitsAtSectionCSIB(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindSplitsAtSectionIBZ(n1, n2)
			return This.FindSplitsAtSectionIB(n1, n2)

		def FindSplitsAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS  #
	#====================================#

	def FindSplitsAtSectionsCS(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult
		
		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSections(paSections)
		return This.FindSplitsAtSectionsCS(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSections(paSections)
			return This.FindSplitsAtSections(paSections)

		#--

		def FindSplitsAtSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		def FindSplitsAtTheseSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS -- BOUNDS INCLUDED   #
	#========================================================#

	def FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
	
		ok

		acSplits = This.SplitsAtSectionsIB(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsIB(paSections)
		return This.FindSplitsAtSectionsCSIB(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsIB(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#--

		def FindSplitsAtSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		def FindSplitsAtTheseSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN ITEM   #
	#=========================================================#

	def FindSplitsBeforeCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		ok

		oItem = new stzList(pItem)

		if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindSplitsBeforePosition(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsBeforePositions(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsBeforeItemCS(pItem[2], pCaseSensitive)
	
		but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsBeforeItemsCS(pItem[2], pCaseSensitive)

		but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsBeforeSection(pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsBeforeSectionIB(pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsBeforeSections(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsBeforeSectionsIB(pItem[2])

		else
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def FindSplitsBeforeCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBefore(pItem)
		return This.FindSplitsBeforeCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeZ(pItem)
			return This.FindSplitsBefore(pItem)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#============================================#

	def FindSplitsBeforePositionCS(n, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsBeforePosition(n)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePosition(n)
		return This.FindSplitsBeforePositionCS(n, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPosition(n)
			return This.FindSplitsBeforePosition(n)

		#--

		def FindSplitsBeforePositionZ(n)
			return This.FindSplitsBeforePosition(n)

		def FindSplitsBeforeThisPositionZ(n)
			return This.FindSplitsBeforePosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#==========================================#

	def FindSplitsBeforePositionsCS(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositionsCS(anPos)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositions(anPos)
		return This.FindSplitsBeforePositionsCS(anPos, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#--

		def FindSplitsBeforePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeThesePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN Item   #
	#---------------------------------------------#

	def FindSplitsBeforeItemCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsBeforeItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		def FindSplitsBeforeThisItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItem(pItem)
		return This.FindSplitsBeforeItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItem(pItem)
			return This.FindSplitsBeforeItem(pItem)

		#--

		def FindSplitsBeforeItemZ(pItem)
			return This.FindSplitsBeforeItem(pItem)

		def FindSplitsBeforeThisItemZ(pItem)
			return This.FindSplitsBeforeItem(pItem)	

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY Items   #
	#-------------------------------------------#

	def FindSplitsBeforeItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsBeforeItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItems(paItems)
		return This.FindSplitsBeforeItemsCS(paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItems(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeManyItems(paItems)
			return This.FindSplitsBeforeItems(paItems)

		#--

		def FindSplitsBeforeItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeTheseItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeManyItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION   #
	#-------------------------------------------#

	def FindSplitsBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSection(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#--

		def FindSplitsBeforeSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		def FindSplitsBeforeThisSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------#

	def FindSplitsBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIB(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#--

		def FindSplitsBeforeSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		def FindSplitsBeforeThisSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS   #
	#-----------------------------------------#

	def FindSplitsBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSections(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindSplitsBeforeSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeTheseSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSectionsIB(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#--

		def FindSplitsBeforeSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeTheseSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN ITEM  #
	#--------------------------------------#

	def FindSplitsAfterCS(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)
		ok

		oItem = new stzList(pItem)

		if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

			return This.FindSplitsAfterPosition(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsAfterPositions(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsAfterItemCS(pItem[2], pCaseSensitive)
	
		but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsAfterItemsCS(pItem[2], pCaseSensitive)

		but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsAfterSection(pItem[2][1], pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsAfterSectionIB(pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsAfterSections(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsAfterSectionsIB(pItem[2])

		else
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		ok


		#< @FunctionAlternativeForm

		def FindSplitsAfterCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfter(pItem)
		return This.FindSplitsAfterCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterZ(pItem)
			return This.FindSplitsAfterCS(pItem, pCaseSensitive)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsAfterPosition(n)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPosition(n)

		#TODO
		# Add FindSplitsAfterPosition(n) to stzSplitter class
		#TODO
		# Add alsos all other similar functions for finding splits

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPosition(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterThisPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsAfterPositions(anPos)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositions(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositions(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#--

		def FindSplitsAfterPositionsZ(anPos)
			return This.FindSplitsAfterPositions(anPos)

		def FindSplitsAfterThesePositionsZ(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositionsZ(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN Item   #
	#---------------------------------------------#

	def FindSplitsAfterItemCS(pItem, pCaseSensitive)

		anPos = This.FindCS(pItem, pCaseSensitive)
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsAfterItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		def FindSplitsAfterThisItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItem(pItem)
		return This.FindSplitsAfterItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItem(pItem)
			return This.FindSplitsAfterItem(pItem)

		#--

		def FindSplitsAfterItemZ(pItem)
			return This.FindSplitsAfterItem(pItem)

		def FindSplitsAfterThisItemZ(pItem)
			return This.FindSplitsAfterItem(pItem)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY Items   #
	#-------------------------------------------#

	def FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		anPos = This.FindCS( paItems, pCaseSensitive )
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsAfterItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItems(paItems)
		return This.FindSplitsAfterItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItems(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterManyItems(paItems)
			return This.FindSplitsAfterItems(paItems)

		#--

		def FindSplitsAfterItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterTheseItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterManyItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION  #
	#-----------------------------------------#

	def FindSplitsAfterSection(n1, n2)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSection(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSection(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#--

		def FindSplitsAfterSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		def FindSplitsAfterThisSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------#

	def FindSplitsAfterSectionIB(n1, n2)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSectionIB(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIB(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		#--

		def FindSplitsAfterSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		def FindSplitsAfterThisSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS   #
	#----------------------------------------#

	def FindSplitsAfterSections(paSections)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSections(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#--

		def FindSplitsAfterSectionsZ(paSections)
			return This.FindSplitsAfterSections(paSections)

		def FindSplitsAfterTheseSectionsZ(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------#

	def FindSplitsAfterSectionsIB(paSections)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#--

		def FindSplitsAfterSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		def FindSplitsAfterTheseSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR Items  #
	#======================================================#

	def FindSplitsBetweenCS(pItem1, pItem2, pCaseSensitive)
		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = @Association([ anFirstBounds, anSecondBounds ])

		anResult = StzSplitterQ( This.NumberOfItems() ).
			   FindSplitsBetweenSections(aSections)
			
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSZ(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetween(pItem1, pItem2)
		return This.FindSplitsBetweenCS(pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenZ(pItem1, pItem2)
			return This.FindSplitsBetween(pItem1, pItem2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	def FindSplitsBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = @Association([ anFirstBounds, anSecondBounds ])

		anResult = StzSplitterQ( This.NumberOfItems() ).
			   FindSplitsBetweenSections(aSections)
	
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSIBZ(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIB(pItem1, pItem2)
		return This.FindSplitsBetweenCSIB(pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenIBZ(pItem1, pItem2)
			return This.FindSplitsBetweenIB(pItem1, pItem2)

		#>

	  #----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS  #
	#----------------------------------------#

	def FindSplitsBetweenPositions(n1, n2)
		This.FindSplitsAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositions(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#--

		def FindSplitsBetweenPositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		def FindSplitsBetweenThesePositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#>
		
	  #------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------#

	def FindSplitsBetweenPositionsIB(n1, n2)
		This.FindSplitsAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#--

		def FindSplitsBetweenPositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		def FindSplitsBetweenThesePositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO Items  #
	#-----------------------------------------#

	def FindSplitsBetweenItemsCS(paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		anResult = This.FindSplitsBetweenSections(aSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsBetweenItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		def FindSplitsBetweenTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenItems(paItems)
		return This.FindSplitsBetweenItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItems(paItems)
			return This.FindSplitsBetweenItems(paItems)

		#--

		def FindSplitsBetweenItemsZ(paItems)
			return This.FindSplitsBetweenItems(paItems)

		def FindSplitsBetweenTheseItemsZ(paItems)
			return This.FindSplitsBetweenItems(paItems)

		#>

	  #---------------------------------#
	 #    FINDING SPLITS TO N PARTS    #
	#=================================#

	def FindSplitsToNParts(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsToNParts(n)
		return anResult

		def FindSplitsToNPartsZ(n)
			return This.FindSplitsToNParts(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N Items   #
	#--------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindSplitsToPartsOfNItems(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).
				FindSplitsToPartsOfExactlyNPositions(n)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItems(n)
			return This.FindSplitsToPartsOfNItems(n)

		#--

		def FindSplitsToPartsOfNItemsZ(n)
			return This.FindSplitsToPartsOfNItems(n)

		def FindSplitsToPartsOfExactlyNItemsZ(n)
			return This.FindSplitsToPartsOfNItems(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF N Items -- EXTENDED   #
	#----------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindSplitsToPartsOfNItemsXT(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).
				FindSplitsToPartsOfNPositionsXT(n)

		return anResult

		def FindSplitsToPartsOfNItemsXTZ(n)
			return This.FindSplitsToPartsOfNItemsXT(n)

	  #-------------------------------------------#
	 #   FINDING SPLITS UNDER A GIVEN CONDITION   #
	#===========================================#

	def FindSplitsW(pcCondition)

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeW(pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterW(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsWZ(pcCondition)
			return This.FindSplitsWZ(pcCondition)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS UNDER A GIVEN CONDITION -- XT/EXTENDED  #
	#---------------------------------------------------------#

	def FindSplitsWXT(pcCondition)

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindSplitsAtWXT(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindSplitsAtWXT(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeWXT(pcCondition[2])

			but oParams.IsAfterNamedParam()
				return This.FindSplitsAfterWXT(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWXTZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsWXTZ(pcCondition)
			return This.FindSplitsWXTZ(pcCondition)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT A POSITION UNDER A GIVEN CONDITION  #
	#========================================================#

	def FindSplitsAtW(pcCondition)
		
		anPos = This.FindW(pcCondition)
		anResult = This.FindSplitsAtPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWZ(pcCondition)
			return This.FindSplitsAtW(pcCondition)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS AT A POSITION UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def FindSplitsAtWXT(pcCondition)
		
		anPos = This.FindWXT(pcCondition)
		anResult = This.FindSplitsAtPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWXTZ(pcCondition)
			return This.FindSplitsAtWXT(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN CONDITION   #
	#============================================#

	def FindSplitsBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		anResult = This.FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeWZ(pcCondition)
			return This.FindSplitsBeforeW(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		anResult = This.FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeWXTZ(pcCondition)
			return This.FindSplitsBeforeWXT(pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN CONDITION   #
	#===========================================#

	def FindSplitsAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		anResult = This.FindSplitsAfterPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterWZ(pcCondition)
			return This.FindSplitsAfterW(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------#

	def FindSplitsAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		anResult = This.FindSplitsAfterPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterWXTZ(pcCondition)
			return This.FindSplitsAfterWXT(pcCondition)

		#>

	  #==================================================#
	 #   FINDING THE SPLITS AS SECTIONS -- ZZ/EXTENDED  #
	#==================================================#

	def FindSplitsCSXTZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindSplitsAtCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindSplitsAtPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindSplitsAtPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindSplitsAtItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindSplitsAtItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindSplitsAtSectionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtSectionIB, :AtThisSectionIB ]) 
			return This.FindSplitsAtSectionIBZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindSplitsAtSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtSectionsIB, :AtTheseSectionsIB ]) 
			return This.FindSplitsAtSectionsIBZZ(pItem[2])

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindSplitsBeforeCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindSplitsBeforePositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindSplitsBeforePositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindSplitsBeforeItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindSplitsBeforeSectionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeSectionIB, :BeforeThisSectionIB ]) 
			return This.FindSplitsBeforeSectionIBZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindSplitsBeforeSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeSectionsIB, :BeforeTheseSectionsIB ]) 
			return This.FindSplitsBeforeSectionsIBZZ(pItem[2])


		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindSplitsAfterCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindSplitsAfterPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindSplitsAfterPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindSplitsAfterItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindSplitsAfterItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindSplitsAfterSectionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterSectionIB, :AfterThisSectionIB ]) 
			return This.FindSplitsAfterSectionIBZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindSplitsAfterSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterSectionsIB, :AfterTheseSectionsIB ]) 
			return This.FindSplitsAfterSectionsIBZZ(pItem[2])


		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindSplitsBetweenCSZZ(pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindSplitsBetweenPositionsZZ(pItem[1], pItem[2])

		but oParam.IsBetweenItemsNamedParam()
			return This.FindSplitsBetweenItemsCSZZ(pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindSplitsToNPartsZZ(pItem[2])

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindSplitsToPartsOfNItemsZZ(pItem[2])

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindSplitsAtWZZ(pItem[2])

		but oParam.IsBeforeWhereNamedParam()
			return This.FindSplitsBeforeWZZ(pItem[2])

		but oParam.IsAfterWhereNamedParam()
			return This.FindSplitsAfterWZZ(pItem[2])

		else
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsCSXT(pItem, pCaseSensitive)
			return This.FindSplitsAsSectionsCSXTZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXTZZ(pItem)
		return This.FindSplitsCSXTZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsAsSectionsXT(pItem)
			return This.FindSplitsAsSectionsXTZZ(pItem)

		#>

	  #-------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN Item  #
	#=================================================#

	def FindSplitsAtCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindSplitsAtPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsAtPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsAtItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsAtItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsAtSectionZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsAtSectionIBZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsAtSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsAtSectionsIBZZ(pItem[2])

		else
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtZZ(pItem)
		return This.FindSplitsAtCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSections(pItem)
			return This.FindSplitsAtCSZZ(pSubStr)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN POSITION   #
	#======================================================#

	def FindSplitsAtPositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAtPosition(n)
		aResult = This.FindManyAsSections(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAtPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionZZ(n)
		return This.FindSplitsAtPositionCSZZ(n, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSections(n)
			return This.FindSplitsAtPositionZZ(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY POSITIONS   #
	#----------------------------------------------------#

	def FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.SplitsAtPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAtPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionsZZ(anPos)
		return This.FindSplitsAtPositionsCSZZ(anPos, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#--

		def FindSplitsAtPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtThesePositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN Item   #
	#=======================================================#

	def FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItemZZ(pItem)
		return This.FindSplitsAtItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsZZ(pItem)
			return This.FindSplitsCSZZ(pItem, _TRUE_)

		def FindSplitsAtThisItemZZ(pItem)
			return This.FindSplitsAtThisItemCSZZ(pItem, _TRUE_)
		#--

		def FindSplitsAtItemAsSectionsZZ(pItem)
			return This.FindSplitsAtItemAsSectionsCSZZ(pItem, _TRUE_)

		def FindSplitsAsSections(pItem)
			return This.FindSplitsAsSectionsCS(pItem, _TRUE_)

		def FindSplitsAtThisItemAsSections(pItem)
			return This.FindSplitsAtThisItemAsSectionsCS(pItem, _TRUE_)

		#>

	  #-------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT GIVEN ITEMS   #
	#-------------------------------------------------#

	def FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsAtItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItemsZZ(paItems)
		return This.FindSplitsAtItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsZZ(paItems)
			return This.FindSplitsAtItemsZZ(paItems)
	
		def FindSplitsAtManyItemsZZ(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		#--

		def FindSplitsAtItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		def FindSplitsAtTheseItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		def FindSplitsAtManyItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		#>

	  #-----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION   #
	#=====================================================#

	def FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionZZ(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		def FindSplitsAtThisSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCSIB(n1, n2, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAtSectionIBZZ(n1, n2)

		def FindSplitsAtThisSectionAsSectionsIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY SECTIONS   #
	#---------------------------------------------------#

	def FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsZZ(paSections, pCaseSensitive)
		return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsZZ(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#--

		def FindSplitsAtSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		def FindSplitsAtTheseSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN ITEM   #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindSplitsBeforePositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsBeforePositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsBeforeItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsBeforeItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsBeforeSectionZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsBeforeSectionIBZZ(pItem[2][1], pItem[2][2])
	
		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsBeforeSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsBeforeSectionsIBZZ(pItem[2])

		else
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeZZ(pItem)
		return This.FindSplitsBeforeCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSections(pItem)
			return This.FindSplitsBeforeZZ(pItem)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsBeforePositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsBeforePosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionZZ(n)
		return This.FindSplitsBeforePositionCSZZ(n, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionZZ(n)
			return This.FindSplitsBeforePositionZZ(n)

		#--

		def FindSplitsBeforePositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		def FindSplitsBeforeThisPositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionsZZ(anPos)
		return This.FindSplitsBeforePositionsCSZZ(anPos, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#--

		def FindSplitsBeforePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeThesePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN Item   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBeforeItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsBeforeItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsBeforeThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItemZZ(pItem)
		return This.FindSplitsBeforeItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemZZ(pItem)
			return This.FindSplitsBeforeItem(pItem)

		#--

		def FindSplitsBeforeItemAsSections(pItem)
			return This.FindSplitsBeforeItemZZ(pItem)

		def FindSplitsBeforeThisItemAsSections(pItem)
			return This.FindSplitsBeforeItemZZ(pItem)	

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY Items   #
	#---------------------------------------------------------#

	def FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBeforeItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsBeforeItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItemsZZ(paItems)
		return This.FindSplitsBeforeItemsCSZZ(paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsZZ(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeManyItemsZZ(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		#--

		def FindSplitsBeforeItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeTheseItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeManyItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionZZ(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#----------------------------------------------------------------------------#

	def FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCsIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionIBZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIBZZ(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSZZ(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsZZ(paSections)
		return This.FindSplitsBeforeSectionsCSZZ(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsZZ(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsAsSections(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------------------#

	def FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsBeforeSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsIBZZ(paSections)
		return This.FindSplitsBeforeSectionsCSIBZZ(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN ITEM  #
	#---------------------------------------------------------------------#

	def FindSplitsAfterCSZZ(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

			return This.FindSplitsAfterPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindSplitsAfterPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindSplitsAfterItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindSplitsAfterItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindSplitsAfterSectionZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindSplitsAfterSectionIBZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindSplitsAfterSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindSplitsAfterSectionsIBZZ(pItem[2])

		#-- Providing numbers, strings, or pairs of numbers,
		#   directly without named params

		but oParam.IsListOfNumbers()
			return This.FindSplitsAfterPositionsZZ(pItem)

		but oParam.IsListOfStrings()
			return This.FindSplitsAfterItemsZZ(pItem)

		but oParam.IsListOfPairsOfNumbers()
			return This.FindSplitsAfterSectionsZZ(pItem)

		else
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterZZ(pItem)
		return This.FindSplitsAfterCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSections(pItem)
			return This.FindSplitsAfterCSZZ(pItem, pCaseSensitive)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAfterPosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		def FindSplitsAfterThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionZZ(n)
		return This.FindSplitsAfterPositionCSZZ(n, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionZZ(n)
			return This.FindSplitsAfterPositionZZ(n)

		def FindSplitsAfterThisPositionAsSections(n)
			return This.FindSplitsAfterPositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.plitsAfterPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAfterPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionsZZ(anPos)
		return This.FindSplitsAfterPositionsCSZZ(anPos, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsZZ(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsZZ(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#--

		def FindSplitsAfterPositionsAsSections(anPos)
			return This.FindSplitsAfterPositionsZZ(anPos)

		def FindSplitsAfterThesePositionsAsSections(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsAsSections(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN Item   #
	#-----------------------------------------------------------#

	def FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAfterItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsAfterItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAfterThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItemZZ(pItem)
		return This.FindSplitsAfterItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemZZ(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		#--

		def FindSplitsAfterItemAsSections(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		def FindSplitsAfterThisItemAsSections(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY Items   #
	#---------------------------------------------------------#

	def FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAfterItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsAfterItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsAsSectionsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItemsZZ(paItems)
		return This.FindSplitsAfterItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterManyItemsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		#--

		def FindSplitsAfterItemsAsSections(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterTheseItemsAsSections(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterManyItemsAsSectionsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION   #
	#--------------------------------------------------------#

	def FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionZZ(n1, n2)
		return This.FindSplitsAfterSectionCSZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionZZ(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionIBZZ(n1, n2)
		return This.FindSplitsAfterSectionCSIBZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIBZZ(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS   #
	#------------------------------------------------------#

	def FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionsZZ(paSections)
		return This.FindSplitsAfterSectionsCSZZ(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsZZ(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSections(paSections)
			return This.FindSplitsAfterSectionsZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSections(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------#

	def FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESNSITIVITY

	def FindSplitsAfterSectionsIBZZ(paSections)
		return This.FindSplitsAfterSectionsCSIBZZ(paSections, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIBZZ(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR Items  #
	#====================================================================#

	def FindSplitsBetweenCSZZ(pItem1, pItem2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
				StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
			ok
		ok

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = @Association([ anFirstBounds, anSecondBounds ])
		aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCS(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenZZ(pItem1, pItem2)
		return This.FindSplitsBetweenCS(pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSections(pItem1, pItem2)
			return This.FindSplitsBetweenZZ(pItem1, pItem2)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------------------#

	def FindSplitsBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = @Association([ anFirstBounds, anSecondBounds ])
		aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCSIB(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIBZZ(pItem1, pItem2)
		return This.FindSplitsBetweenCSIBZZ(pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsIB(pItem1, pItem2)
			return This.FindSplitsBetweenIBZZ(pItem1, pItem2)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS  #
	#------------------------------------------------------#

	def FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsZZ(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIBZZ(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO Items  #
	#-------------------------------------------------------#

	def FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBetweenItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsBetweenItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBetweenTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenItemsZZ(paItems)
		return This.FindSplitsBetweenItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsZZ(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		#--

		def FindSplitsBetweenItemsAsSections(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		def FindSplitsBetweenTheseItemsAsSections(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		#>

	  #-----------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) TO N PARTS    #
	#===============================================#

	def FindSplitsToNPartsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToNPartsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		def FindSplitsToNPartsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToNPartsCSZZ(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToNPartsZZ(n)
		return This.FindSplitsToNPartsCSZZ(n, _TRUE_)

		def FindSplitsToNPartsAsSections(n)
			return This.FindSplitsToNPartsZZ(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N Items   #
	#--------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNItemsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItemsCSZZ(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsToPartsOfNItemsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		def FindSplitsToPartsOfExactlyNItemsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToPartsOfNItemsZZ(n)
		return This.FindSplitsToPartsOfNItemsCSZZ(n, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItemsZZ(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		#--

		def FindSplitsToPartsOfNItemsAsSections(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		def FindSplitsToPartsOfExactlyNItemsAsSections(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) TO PARTS OF N Items -- EXTENDED   #
	#------------------------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindSplitsToPartsOfNItemsCSXTZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckingParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNItemsXTZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNItemsAsSectionsCSXT(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSXTZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY()

	def FindSplitsToPartsOfNItemsXTZZ(n)
		return This.FindSplitsToPartsOfNItemsCSXTZZ(n, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNItemsAsSectionsXT(n)
			return This.FindSplitsToPartsOfNItemsXTZZ(n)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) UNDER A GIVEN CONDITION   #
	#==========================================================#

	def FindSplitsWCSZZ(pcCondition, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if isList(pcCondition)
			oCondition = StzStringQ(pcCondition)
			if oCondition.IsWhereNamedParam()
				return This.FindSplitsAtWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsAtNamedParam()
				return This.FindSplitsAtWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsBeforeNamedParam()
				return This.FindSplitsBeforeWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsAfterNamedParam()
				return This.FindSplitsAfterWCSZZ(pcCondition[2], pCaseSensitive)

			ok
		
		else

			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsWZZ(pcCondition)
		return This.FindSplitsWCSZZ(pcCondition, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsW(pcCondition)
			return This.FindSplitsWZZ(pcCondition)

		#>

	  #-------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDITION   #
	#-------------------------------------------------------#

	def FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		aResult = []

		pcCondition = StzStringQ(pcCondition).TrimQ().TheseBoundsRemoved( "{","}" )

		if Q(pcCondition).ContainsCS("@Item", _FALSE_)

			aSections = This.FindItemsAsSectionsWCS(pcCondition, pCaseSensitive)
			aResult = This.FindSplitsAtSectionsCSZZ(aSections, pCaseSensitive)

			/* TODO: should we resolve it like this:

			acSplits = This.SplitsAtWCSZZ(pcCondition, pCaseSensitive)
			aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

			*/

		else

			anPos = This.FindWCS(pcCondition, pCaseSensitive)
			aResult = This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWZZ(pcCondition)
		return This.FindSplitsAtWCSZZ(pcCondition, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsW(pcCondition)
			return This.FindSplitsAtWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN CONDITION   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok

		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsCS("@Item",  _FALSE_)
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)

		else
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)
		ok

		aResult = This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWZZ(pcCondition)
		return This.FindSplitsBeforeWCSZZ(pcCondition, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsW(pcCondition)
			return This.FindSplitsBeforeWZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) AFTER A GIVEN CONDITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsCS("@Item",  _FALSE_)
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)

		else
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)
		ok

		aResult = This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWZZ(pcCondition)
		return This.FindSplitsAfterWCSZZ(pcCondition, _TRUE_)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsW(pcCondition)
			return This.FindSplitsAfterWZZ(pcCondition)

		#>

	  #===========================#
	 #   FINDING THE NTH SPLIT   #
	#===========================#

	def FindNthSplitCSXT(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindNthSplitAtCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindNthSplitAtPositionCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindNthSplitAtPositionsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindNthSplitAtItemCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindNthSplitAtItemsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindNthSplitAtSectionCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindNthSplitAtSectionsCS(n, pItem[2], pCaseSensitive)

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindNthSplitBeforeCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindNthSplitBeforePositionCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindNthSplitBeforePositionsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindNthSplitBeforeItemCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindNthSplitBeforeSectionCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindNthSplitBeforeSectionsCS(n, pItem[2], pCaseSensitive)

		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindNthSplitAfterCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindNthSplitAfterPositionCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindNthSplitAfterPositionsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindNthSplitAfterItemCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindNthSplitAfterItemsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindNthSplitAfterSectionCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindNthSplitAfterSectionsCS(n, pItem[2], pCaseSensitive)

		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindNthSplitBetweenCS(n, pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindNthSplitBetweenPositionsCS(n, pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenItemsNamedParam()
			return This.FindNthSplitBetweenItemsCS(n, pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindNthSplitToNPartsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindNthSplitToPartsOfNItemsCS(n, pItem[2], pCaseSensitive)

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindNthSplitAtWCS(n, pItem[2], pCaseSensitive)

		but oParam.IsBeforeWhereNamedParam()
			return This.FindNthSplitBeforeWCS(n, pItem[2], pCaseSensitive)

		but oParam.IsAfterWhereNamedParam()
			return This.FindNthSplitAfterWCS(n, pItem[2], pCaseSensitive)

		else
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindNthSplitCSXTZ(pItem, pCaseSensitive)
			return This.FindNthSplitCSXT(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXT(n, pItem)
		return This.FindNthSplitCSXT(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitXTZ(n, pItem)
			return This.FindNthSplitXT(n, pItem)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN Item  #
	#=======================================================#

	def FindNthSplitAtCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindNthSplitAtPositionCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindNthSplitAtPositionsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindNthSplitAtItemCS(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindNthSplitAtItemsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindNthSplitAtSectionCS(n, pItem[2][1], pItem[2][2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindNthSplitAtSectionCSIB(n, pItem[2][1], pItem[2][2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindNthSplitAtSectionsCS(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindNthSplitAtSectionsCSIB(n, pItem[2], pCaseSensitive)

		else
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindNthSplitAtCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtCS(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAt(n, pItem)
		return This.FindNthSplitAtCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAtZ(n, pItem)
			return This.FindNthSplitAtCS(n, pSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN POSITION   #
	#===========================================#

	#NOTE
	# Case sensitivty has no added value here,
	# since the split is based on position
	# and there is no use of ...CS() functions
	# in the implementatin

	def FindNthSplitAtPosition(n, nPos) 
		    
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isNumber(n, nPos) and (n = 1 or n = 2) )
				StzRaise("Incorrect pram type! n must be a number equal to 1 or 2.")
				# Because after splitting the string at a given position, there will
				# be only two splits, right?
			ok

		ok

		nResult = 0

		if n = 1
			nResult = 1

		but n = 2
			nResult + (nPos + 1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPosition(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtThisPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY POSITIONS   #
	#-----------------------------------------#

	def FindNthSplitAtPositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()

			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtPositions(anPos)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nResult += ( nLen + 1 )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#--

		def FindNthSplitAtPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtThesePositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#>

	  #---------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN ITEM   #
	#=======================================#

	def FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT isString(pItem)
				StzRaise("Incorrect param type! pItem must be a string.")
			ok
		ok

		if n = 1
			return 1
		ok

		nLenSubStr = StzStringQ(pItem).NumberOfItems()
		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitCS(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCS(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAtItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitCSZ(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCSZ(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItem(n, pItem)
		return This.FindNthSplitAtItemCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplit(n, pItem)
			return This.FindNthSplitCS(n, pItem, _TRUE_)

		def FindNthSplitAtThisItem(n, pItem)
			return This.FindNthSplitAtThisItemCS(n, pItem, _TRUE_)
		#--

		def FindNthSplitAtItemZ(n, pItem)
			return This.FindNthSplitAtItemCS(n, pItem, _TRUE_)

		def FindNthSplitZ(n, pItem)
			return This.FindNthSplitCS(n, pItem, _TRUE_)

		def FindNthSplitAtThisItemZ(pItem)
			return This.FindNthSplitAtThisItemCS(n, pItem, _TRUE_)

		#>

	  #--------------------------------------#
	 #   FINDING NTH SPLIT AT GIVEN ITEMS   #
	#--------------------------------------#

	def FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT (isList(paItems) and Q(paItems).IsListOfStrings())
				StzRaise("Incorrect param type! paItems must be a list of strings.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nLenSubStr = StzStringQ(paItems[i]).NumberOfItems()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult


		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAtItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItems(n, paItems)
		return This.FindNthSplitAtItemsCS(n, paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItems(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)
	
		def FindNthSplitAtManyItems(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		#--

		def FindNthSplitAtItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		def FindNthSplitAtTheseItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		def FindNthSplitAtManyItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		#>

	  #------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION   #
	#==========================================#

	def FindNthSplitAtSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if CheckingParams()
			if NOT @AllAreNumbers([n, n1, n2 ])
				StzRaise("Incorrect params type! n, n1 and n2 must all be numbers.")
			ok

			if NOT ( n = 1 or n = 2 )
				StzRaise("Incorrect values ! n must be equal to 1 or 2.")
				# Since the split make two parts only.
			ok
		ok

		if n = 1
			return 1
		
		but n = 2
			return n2 + 1
		ok
		
		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSection(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#--

		def FindNthSplitAtSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		def FindNthSplitAtThisSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------#

	def FindNthSplitAtSectionIB(n, n1, n2)
		nResult = This.FindNthSplitAtSection(n, n1, n2)
		if nResult > 1
			nResult - (n2 - n1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIB(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#--

		def FindNthSplitAtSectionIBZ(n, n1, n2)
			return This.FindNthSplitAtSectionIB(n, n1, n2)

		def FindNthSplitAtThisSectionIBZ(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#>

	  #----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY SECTIONS   #
	#----------------------------------------#

	def FindNthSplitAtSections(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		StzRaise("Feature not yet implemented!")

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSections(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#--

		def FindNthSplitAtSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		def FindNthSplitAtTheseSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN ITEM   #
	#------------------------------------------------------------#

	def FindNthSplitBeforeCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		ok

		oItem = StzListQ(pItem)

		if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindNthSplitBeforePosition(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindNthSplitBeforePositions(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindNthSplitBeforeItemCS(n, pItem[2], pCaseSensitive)
	
		but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindNthSplitBeforeItemsCS(n, pItem[2], pCaseSensitive)

		but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindNthSplitBeforeSection(n, pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindNthSplitBeforeSectionIB(n, pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindNthSplitBeforeSections(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindNthSplitBeforeSectionsIB(n, pItem[2])

		else
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		ok


		#< @FunctionAlternativeForms

		def FindNthSplitBeforeCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBefore(n, pItem)
		return This.FindNthSplitBeforeCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeZ(n, pItem)
			return This.FindNthSplitBefore(n, pItem)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitBeforePosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePosition(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPosition(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#--

		def FindNthSplitBeforePositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		def FindNthSplitBeforeThisPositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitBeforePositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#--

		def FindNthSplitBeforePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeThesePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN Item   #
	#------------------------------------------------#

	def FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitBeforeThisItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItem(n, pItem)
		return This.FindNthSplitBeforeItemCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItem(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		#--

		def FindNthSplitBeforeItemZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		def FindNthSplitBeforeThisItemZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)	

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY ITEMS   #
	#-----------------------------------------#

	def FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindManyCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItems(n, paItems)
		return This.FindNthSplitBeforeItemsCS(n, paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItems(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeManyItems(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		#--

		def FindNthSplitBeforeItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeTheseItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeManyItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION   #
	#----------------------------------------------#

	def FindNthSplitBeforeSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSection(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSection(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		def FindNthSplitBeforeThisSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-----------------------------------------------------------------#

	def FindNthSplitBeforeSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionIB(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		def FindNthSplitBeforeThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SECTIONS   #
	#--------------------------------------------#

	def FindNthSplitBeforeSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSections(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSections(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySections(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#--

		def FindNthSplitBeforeSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeTheseSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySectionsZ(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINING NTH SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIB(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIB(paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#--

		def FindNthSplitBeforeSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN ITEM  #
	#-----------------------------------------#

	def FindNthSplitAfterCS(n, pItem, pCaseSensitive)

		if NOT isList(pItem)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)
		ok


		oItem = StzListQ(pItem)

		if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

			return This.FindNthSplitAfterPosition(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindNthSplitAfterPositions(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindNthSplitAfterItemCS(n, pItem[2], pCaseSensitive)
	
		but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindNthSplitAfterItemsCS(n, pItem[2], pCaseSensitive)

		but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindNthSplitAfterSection(n, pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindNthSplitAfterSectionIB(n, pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindNthSplitAfterSections(n, pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindNthSplitAfterSectionsIB(n, pItem[2])

		else
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindNthSplitAfterCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfter(n, pItem)
		return This.FindNthSplitAfterCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterZ(n, pItem)
			return This.FindNthSplitAfterCS(n, pItem, pCaseSensitive)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitAfterPosition(n, nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPosition(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterThisPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitAfterPositions(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositions(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositions(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#--

		def FindNthSplitAfterPositionsZ(n, anPos)
			return This.FindNthSplitAfterPositions(n, anPos)

		def FindNthSplitAfterThesePositionsZ(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositionsZ(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN ITEM   #
	#-------------------------------------------#

	def FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAfterItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAfterThisItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItem(n, pItem)
		return This.FindNthSplitAfterItemCS(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItem(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		#--

		def FindNthSplitAfterItemZ(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		def FindNthSplitAfterThisItemZ(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY Items   #
	#----------------------------------------------#

	def FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		anPos = This.FindManyCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAfterItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItems(n, paItems)
		return This.FindNthSplitAfterItemsCS(n, paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItems(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterManyItems(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		#--

		def FindNthSplitAfterItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterTheseItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterManyItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION  #
	#--------------------------------------------#

	def FindNthSplitAfterSection(n, n1, n2)

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSection(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSection(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#--

		def FindNthSplitAfterSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		def FindNthSplitAfterThisSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindNthSplitAfterSectionIB(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionIB(n, n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		#--

		def FindNthSplitAfterSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		def FindNthSplitAfterThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)


		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS   #
	#-------------------------------------------#

	def FindNthSplitAfterSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSections(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#--

		def FindNthSplitAfterSectionsZ(n, paSections)
			return This.FindNthSplitAfterSections(n, paSections)

		def FindNthSplitAfterTheseSectionsZ(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterSectionsIB(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#--

		def FindNthSplitAfterSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		def FindNthSplitAfterTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR Items  #
	#=========================================================#

	def FindNthSplitBetweenCS(n, pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = @Association([ anFirstBounds, anSecondBounds ])

		nResult = StzSplitterQ( This.NumberOfItems() ).
			   FindNthSplitBetweenSections(n, aSections)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSZ(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCS(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetween(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCS(n, pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenZ(n, pItem1, pItem2)
			return This.FindNthSplitBetween(n, pItem1, pItem2)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIB(n, pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = @Association([ anFirstBounds, anSecondBounds ])

		nResult = StzSplitterQ( This.NumberOfItems() ).
			   FindNthSplitBetweenSections(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSIBZ(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIB(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIB(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCSIB(n, pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenIBZ(n, pItem1, pItem2)
			return This.FindNthSplitBetweenIB(n, pItem1, pItem2)

		#>

	  #-------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS  #
	#-------------------------------------------#

	def FindNthSplitBetweenPositions(n, n1, n2)
		This.FindNthSplitAtSection(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositions(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		def FindNthSplitBetweenThesePositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#>
		
	  #---------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIB(n, n1, n2)
		This.FindNthSplitAtSectionIB(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		def FindNthSplitBetweenThesePositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO Items  #
	#--------------------------------------------#

	def FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		nResult = This.FindNthSplitBetweenSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBetweenItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBetweenTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenItems(n, paItems)
		return This.FindNthSplitBetweenItemsCS(n, paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItems(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		#--

		def FindNthSplitBetweenItemsZ(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		def FindNthSplitBetweenTheseItemsZ(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		#>

	  #------------------------------------#
	 #    FINDING NTH SPLIT TO N PARTS    #
	#====================================#

	def FindNthSplitToNParts(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitToNParts(n, nPos)
		return nResult

		def FindNthSplitToNPartsZ(n, nPos)
			return This.FindNthSplitToNParts(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N Items   #
	#-----------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindNthSplitToPartsOfNItems(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfExactlyNPositions(n, nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfNItemsZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsXT(n, nPos)

		def FindNthSplitToPartsOfExactlyNItemsZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsXT(n, nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF N Items -- EXTENDED   #
	#-------------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindNthSplitToPartsOfNItemsXT(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfNPositionsXT(n, nPos)

		return nResult

		def FindNthSplitToPartsOfNItemsXTZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsXT(n, nPos)

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT UNDER A GIVEN CONDITION   #
	#==============================================#

	def FindNthSplitW(n, pcCondition)
		/*
		? StzSplitterQ(5).FindNthSplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeW(n, pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterW(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitWZ(n, pcCondition)
			return This.FindNthSplitWZ(n, pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#-------------------------------------------------------------#

	def FindNthSplitWXT(n, pcCondition)
		/*
		? StzSplitterQ(5).FindNthSplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindNthSplitAtWXT(n, pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindNthSplitAtWXT(n, pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeWXT(n, pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterWXT(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWXTZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitWXTZ(n, pcCondition)
			return This.FindNthSplitWXTZ(n, pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINSING NTH SPLIT AT A GIVEN CONDITION   #
	#===========================================#

	def FindNthSplitAtW(n, pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindNthSplitAtPositionsZ(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtWZ(n, pcCondition)
			return This.FindNthSplitAtW(n, pcCondition)

		#>

	  #----------------------------------------------------------#
	 #   FINSING NTH SPLIT AT A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------#

	def FindNthSplitAtWXT(n, pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindNthSplitAtPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtWXTZ(n, pcCondition)
			return This.FindNthSplitAtWXT(n, pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN CONDITION   #
	#===============================================#

	def FindNthSplitBeforeW(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeWZ(n, pcCondition)
			return This.FindNthSplitBeforeW(n, pcCondition)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN CONDITION -- WXT/EXTENSION  #
	#---------------------------------------------------------------#

	def FindNthSplitBeforeWXT(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeWXTZ(n, pcCondition)
			return This.FindNthSplitBeforeWXT(n, pcCondition)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN CONDITION   #
	#==============================================#

	def FindNthSplitAfterW(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindNthSplitAfterPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterWZ(pcCondition)
			return This.FindNthSplitAfterW(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN CONDITION  -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterWXT(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindNthSplitAfterPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterWXTZ(pcCondition)
			return This.FindNthSplitAfterWXT(pcCondition)

		#>

	  #====================================================#
	 #   FINDING THE NTH SPLIT AS SECTION -- ZZ/EXTENDED  #
	#====================================================#

	def FindNthSplitCSXTZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindNthSplitAtCSZZ(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindNthSplitAtPositionZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindNthSplitAtPositionsZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindNthSplitAtItemCSZZ(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindNthSplitAtItemsCSZZ(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindNthSplitAtSectionZZ(n, pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindNthSplitAtSectionsZZ(n, pItem[2])

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindNthSplitBeforeCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindNthSplitBeforePositionZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindNthSplitBeforePositionsZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindNthSplitBeforeItemCSZZ(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCSZZ(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindNthSplitBeforeSectionZZ(n, pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindNthSplitBeforeSectionsZZ(n, pItem[2])

		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindNthSplitAfterCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindNthSplitAfterPositionZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindNthSplitAfterPositionsZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindNthSplitAfterItemCSZZ(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindNthSplitAfterItemsCSZZ(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindNthSplitAfterSectionZZ(n, pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindNthSplitAfterSectionsZZ(n, pItem[2])

		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindNthSplitBetweenCSZZ(n, pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindNthSplitBetweenPositionsZZ(n, pItem[1], pItem[2])

		but oParam.IsBetweenItemsNamedParam()
			return This.FindNthSplitBetweenItemsCSZZ(n, pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindNthSplitToNPartsZZ(n, pItem[2])

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindNthSplitToPartsOfNItemsZZ(n, pItem[2])

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindNthSplitAtWZZ(n, pItem[2])

		but oParam.IsBeforeWhereNamedParam()
			return This.FindNthSplitBeforeWZZ(n, pItem[2])

		but oParam.IsAfterWhereNamedParam()
			return This.FindNthSplitAfterWZZ(n, pItem[2])

		else
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionCSXT(n, pItem, pCaseSensitive)
			return This.FindNthSplitCSXTZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXTZZ(n, pItem)
		return This.FindNthSplitCSXTXT(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionXT(n, pItem)
			return This.FindNthSplitXTZZ(n, pItem)

		#>

	  #----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#====================================================#

	def FindNthSplitAtCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindNthSplitAtPositionZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindNthSplitAtPositionsZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindNthSplitAtItemCSZZ(n, pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindNthSplitAtItemsCSZZ(n, pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindNthSplitAtSectionZZ(n, pItem[2][1], pItem[2][2])
	
		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindNthSplitAtSectionIBZZ(n, pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindNthSplitAtSectionsZZ(n, pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindNthSplitAtSectionsIBZZ(n, pItem[2])

		else
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtCSZZ(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtZZ(n, pItem)
		return This.FindNthSplitAtCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSection(n, pItem)
			return This.FindNthSplitAtCSZZ(n, pSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#========================================================#

	def FindNthSplitAtPositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPositionAsSection(n, nPos)
			return This.FindNthSplitAtPositionZZ(n, nPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-----------------------------------------------------#

	def FindNthSplitAtPositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#--

		def FindNthSplitAtPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#>

	  #---------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN ITEM  #
	#===================================================#

	def FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindAsSectionsCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItemZZ(pItem)
		return This.FindNthSplitAtItemCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, _TRUE_)

		def FindNthSplitAtThisItemZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, _TRUE_)
		#--

		def FindNthSplitAtItemAsSectionZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, _TRUE_)

		def FindNthSplitAsSection(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, _TRUE_)

		def FindNthSplitAtThisItemAsSection(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, _TRUE_)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTIONS) AT GIVEN Items  #
	#--------------------------------------------------------#

	def FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAtItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtTheseItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItemsZZ(n, paItems)
		return This.FindNthSplitAtItemsCSZZ(n, paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsZZ(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)
	
		def FindNthSplitAtManyItemsZZ(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		#--

		def FindNthSplitAtItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		def FindNthSplitAtTheseItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		def FindNthSplitAtManyItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=======================================================#

	def FindNthSplitAtSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindNthSplitAtSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIBZZ(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSectionIB(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-----------------------------------------------------#

	def FindNthSplitAtSectionsZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSectionsZZ(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#--

		def FindNthSplitAtSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		def FindNthSplitAtTheseSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING NTH SPIT (AS SECTION) BEFORE A GIVEN ITEM   #
	#------------------------------------------------------------------------#

	def FindNthSplitBeforeCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitBeforeItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitBeforeItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pItem[2][1], pItem[2][2])
		
			but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitBeforeSectionIBZZ(n, pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitBeforeSectionsIBZZ(n, pItem[2])

			else
				return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeZZ(n, pItem)
		return This.FindNthSplitBeforeCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSection(n, pItem)
			return This.FindNthSplitBeforeZZ(n, pItem)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitBeforePositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPositionZZ(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#--

		def FindNthSplitBeforePositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		def FindNthSplitBeforeThisPositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitBeforePositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#--

		def FindNthSplitBeforePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeThesePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemCSZZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemAsSectionsCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitBeforeThisItemAsSectionsCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItemZZ(n, pItem)
		return This.FindNthSplitBeforeItemCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemZZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		#--

		def FindNthSplitBeforeItemAsSection(n, pItem)
			return This.FindNthSplitBeforeItemZZ(n, pItem)

		def FindNthSplitBeforeThisItemAsSection(n, pItem)
			return This.FindNthSplitBeforeItemZZ(n, pItem)	

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY Items   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeTheseItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItemsZZ(n, paItems)
		return This.FindNthSplitBeforeItemsCSZZ(n, paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsZZ(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeManyItemsZZ(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		#--

		def FindNthSplitBeforeItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeTheseItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeManyItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindNthSplitBeforeSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsZZ(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#--

		def FindNthSplitBeforeSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSection(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIBZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindNthSplitBeforeSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		#>

	  #------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN ITEM  #
	#------------------------------------------------------#

	def FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])
				return This.FindNthSplitAfterPositionZZ(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitAfterItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitAfterItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindNthSplitAfterSectionIBZZ(n, pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindNthSplitAfterSectionsIBZZ(n, pItem[2])

			else
				return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterZZ(n, pItem)
		return This.FindNthSplitAfterCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSection(n, pItem)
			return This.FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitAfterPositionZZ(n, Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPositionZZ(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		def FindNthSplitAfterThisPositionAsSection(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitAfterPositionsZZ(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositionsZZ(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsZZ(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#--

		def FindNthSplitAfterPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterPositionsZZ(anPos)

		def FindNthSplitAfterThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemCSZZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAfterItemAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAfterThisItemAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItemZZ(n, pItem)
		return This.FindNthSplitAfterItemCSZZ(n, pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemZZ(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		#--

		def FindNthSplitAfterItemAsSection(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		def FindNthSplitAfterThisItemAsSection(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY Items   #
	#-----------------------------------------------------------#

	def FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAfterItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsAsSectionCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItemsZZ(n, paItems)
		return This.FindNthSplitAfterItemsCSZZ(n, paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterManyItemsZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		#--

		def FindNthSplitAfterItemsAsSection(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterTheseItemsAsSection(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterManyItemsAsSectionZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(paItems)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#----------------------------------------------------------#

	def FindNthSplitAfterSectionZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindNthSplitAfterSectionIBZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionIBZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n1, n2)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#--------------------------------------------------------#

	def FindNthSplitAfterSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsZZ(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterSectionsZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterSectionsIBZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items  #
	#======================================================================#

	def FindNthSplitBetweenCSZZ(n, pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBetweenZZ(n, pItem1, pItem2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCS(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSZZ(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenZZ(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCS(n, pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSection(n, pItem1, pItem2)
			return This.FindNthSplitBetweenZZ(n, pItem1, pItem2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBetweenIBZZ(n, pItem1, pItem2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCSIB(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIBZZ(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionIB(n, pItem1, pItem2)
			return This.FindNthSplitBetweenIBZZ(n, pItem1, pItem2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#--------------------------------------------------------#

	def FindNthSplitBetweenPositionsZZ(n, n1, n2)
		This.FindNthSplitAtSectionZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#>
		
	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIBZZ(n, n1, n2)
		This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIBZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO Items  #
	#---------------------------------------------------------#

	def FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)
		aSections = This.FindAsSections(paItems, pCaseSensitive)
		aResult = This.FindNthSplitBetweenSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBetweenItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBetweenTheseItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenItemsZZ(n, paItems)
		return This.FindNthSplitBetweenItemsCSZZ(n, paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsZZ(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		#--

		def FindNthSplitBetweenItemsAsSection(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		def FindNthSplitBetweenTheseItemsAsSection(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		#>

	  #-------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) TO N PARTS    #
	#=================================================#

	def FindNthSplitToNPartsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitToNPartsZZ(n, nPos)
		return aResult

		def FindNthSplitToNPartsAsSection(n, nPos)
			return This.FindNthSplitToNPartsZZ(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N Items   #
	#-----------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindNthSplitToPartsOfNItemsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfExactlyNPositionsZZ(n, nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNItemsZZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		#--

		def FindNthSplitToPartsOfNItemsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		def FindNthSplitToPartsOfExactlyNItemsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindNthSplitToPartsOfNItemsIBZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfNPositionsIBZZ(n, nPos)

		return aResult

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) UNDER A GIVEN CONDITION   #
	#============================================================#

	def FindNthSplitWZZ(n, pcCondition)

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcCondition[2])

			but oParams.IsAfterNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionW(n, pcCondition)
			return This.FindNthSplitWZZ(n, pcCondition)

		#>

	  #---------------------------------------------------------#
	 #    FINSING NTH SPLIT (AS SECTION) AT A GIVEN CONDITION   #
	#=========================================================#

	def FindNthSplitAtWZZ(n, pcCondition)
			
		aSections = This.FindItemsAsSectionsW(pcCondition)
		aResult = This.FindNthSplitAtSectionsZZ(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionW(n, pcCondition)
			return This.FindNthSplitAtWZZ(n, pcCondition)

		#>

	  #------------------------------------------------------------------------#
	 #    FINSING NTH SPLIT (AS SECTION) AT A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def FindNthSplitAtWXTZZ(n, pcCondition)
			
		aSections = This.FindItemsAsSectionsWXT(pcCondition)
		aResult = This.FindNthSplitAtSectionsZZ(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionWXT(n, pcCondition)
			return This.FindNthSplitAtWXTZZ(n, pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTIONS) BEFORE A GIVEN CONDITION   #
	#==============================================================#

	def FindNthSplitBeforeWZZ(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeAsSectionW(n, pcCondition)
			return This.FindNthSplitBeforeWZZ(n, pcCondition)

		#>

	  #-----------------------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTIONS) BEFORE A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBeforeWXTZZ(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeAsSectionWXT(n, pcCondition)
			return This.FindNthSplitBeforeWXTZZ(n, pcCondition)

		#>

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN CONDITION   #
	#============================================================#

	def FindNthSplitAfterWZZ(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.FindNthSplitAfterPositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionW(n, pcCondition)
			return This.FindNthSplitAfterWZZ(n, pcCondition)

		#>

	  #---------------------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterWXTZZ(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.FindNthSplitAfterPositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionWXT(n, pcCondition)
			return This.FindNthSplitAfterWXTZZ(n, pcCondition)

		#>

	  #============================#
	 #   FINDING THE LAST SPLIT   #
	#============================#

	def FindLastSplitCSXT(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindLastSplitAtCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindLastSplitAtPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindLastSplitAtPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindLastSplitAtItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindLastSplitAtItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindLastSplitAtSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindLastSplitAtSections(pItem[2])

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindLastSplitBeforeCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindLastSplitBeforePosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindLastSplitBeforePositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindLastSplitBeforeItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindLastSplitBeforeSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindLastSplitBeforeSections(pItem[2])

		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindLastSplitAfterCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindLastSplitAfterPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindLastSplitAfterPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindLastSplitAfterItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindLastSplitAfterItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindLastSplitAfterSection(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindLastSplitAfterSections(pItem[2])

		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindLastSplitBetweenCS(pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindLastSplitBetweenPositions(pItem[1], pItem[2])

		but oParam.IsBetweenItemsNamedParam()
			return This.FindLastSplitBetweenItemsCS(pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindLastSplitToNParts(pItem[2])

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindLastSplitToPartsOfNItemsXT(pItem[2])

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindLastSplitAtW(pItem[2])

		but oParam.IsBeforeWhereNamedParam()
			return This.FindLastSplitBeforeW(pItem[2])

		but oParam.IsAfterWhereNamedParam()
			return This.FindLastSplitAfterW(pItem[2])

		else
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitCSXTZ(pItem, pCaseSensitive)
			return This.FindLastSplitCSXT(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXT(pItem)
		return This.FindLastSplitCSXT(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitXTZ(pItem)
			return This.FindLastSplitXT(pItem)

		#>

	  #----------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN ITEM   #
	#========================================#

	def FindLastSplitAtCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindLastSplitAtPosition(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindLastSplitAtPositions(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindLastSplitAtItemCS(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindLastSplitAtItemsCS(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindLastSplitAtSection(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindLastSplitAtSectionIB(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindLastSplitAtSections(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindLastSplitAtSectionsIB(pItem[2])

		else
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindLastSplitAtCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAt(pItem)
		return This.FindLastSplitAtCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAtZ(pItem)
			return This.FindLastSplitAtCS(pSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN POSITION   #
	#============================================#

	def FindLastSplitAtPosition(nPos)
		if EarlyChek()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT isNumber(nPos)
				StzRaise("Incorrect pram type! n must be a number.")
			ok
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPosition(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtThisPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY POSITIONS   #
	#------------------------------------------#

	def FindLastSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfItems()).FindLastSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#--

		def FindLastSplitAtPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtThesePositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN Item   #
	#=============================================#

	def FindLastSplitAtItemCS(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitAtItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItem(pItem)
		return This.FindLastSplitAtItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplit(pItem)
			return This.FindLastSplitCS(pItem, _TRUE_)

		def FindLastSplitAtThisItem(pItem)
			return This.FindLastSplitAtThisItemCS(pItem, _TRUE_)
		#--

		def FindLastSplitAtItemZ(pItem)
			return This.FindLastSplitAtItemCS(pItem, _TRUE_)

		def FindLastSplitZ(pItem)
			return This.FindLastSplitCS(pItem, _TRUE_)

		def FindLastSplitAtThisItemZ(pItem)
			return This.FindLastSplitAtThisItemCS(pItem, _TRUE_)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT GIVEN Items   #
	#--------------------------------------------#

	def FindLastSplitAtItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)
		nResult = This.FindLastSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitAtItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItems(paItems)
		return This.FindLastSplitAtItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItems(paItems)
			return This.FindLastSplitAtItems(paItems)
	
		def FindLastSplitAtManyItems(paItems)
			return This.FindLastSplitAtItems(paItems)

		#--

		def FindLastSplitAtItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		def FindLastSplitAtTheseItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		def FindLastSplitAtManyItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		#>

	  #-------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION   #
	#===========================================#

	def FindLastSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSection(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#--

		def FindLastSplitAtSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		def FindLastSplitAtThisSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindLastSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindLastSplitAtSectionIBZ(n1, n2)
			return This.FindLastSplitAtSectionIB(n1, n2)

		def FindLastSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS   #
	#-----------------------------------------#

	def FindLastSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSections(paSections)
			return This.FindLastSplitAtSections(paSections)

		#--

		def FindLastSplitAtSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		def FindLastSplitAtTheseSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsIB(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#--

		def FindLastSplitAtSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		def FindLastSplitAtTheseSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN ITEM   #
	#--------------------------------------------#

	def FindLastSplitBeforeCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSection(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitBeforeSectionIB(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSections(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitBeforeSectionsIB(pItem[2])

			else
				return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBefore(pItem)
		return This.FindLastSplitBeforeCS(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeZ(pItem)
			return This.FindLastSplitBefore(pItem)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPosition(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#--

		def FindLastSplitBeforePositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		def FindLastSplitBeforeThisPositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#--

		def FindLastSplitBeforePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeThesePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN Item   #
	#--------------------------------------------#

	def FindLastSplitBeforeItemCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		def FindLastSplitBeforeThisItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItem(pItem)
		return This.FindLastSplitBeforeItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItem(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		#--

		def FindLastSplitBeforeItemZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		def FindLastSplitBeforeThisItemZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)	

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY Items   #
	#------------------------------------------#

	def FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItems(paItems)
		return This.FindLastSplitBeforeItemsCS(paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItems(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeManyItems(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		#--

		def FindLastSplitBeforeItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeTheseItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeManyItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSection(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#--

		def FindLastSplitBeforeSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		def FindLastSplitBeforeThisSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIB(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#--

		def FindLastSplitBeforeSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		def FindLastSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS   #
	#---------------------------------------------#

	def FindLastSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSections(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindLastSplitBeforeSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeTheseSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#--

		def FindLastSplitBeforeSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN ITEM  #
	#------------------------------------------#

	def FindLastSplitAfterCS(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAfterItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAfterItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSection(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAfterSectionIB(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSections(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAfterSectionsIB(pItem[2])

			else
				return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfter(pItem)
		return This.FindLastSplitAfterCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterZ(pItem)
			return This.FindLastSplitAfterCS(pItem, pCaseSensitive)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPosition(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterThisPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositions(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositions(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#--

		def FindLastSplitAfterPositionsZ(anPos)
			return This.FindLastSplitAfterPositions(anPos)

		def FindLastSplitAfterThesePositionsZ(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositionsZ(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN Item   #
	#--------------------------------------------#

	def FindLastSplitAfterItemCS(pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitAfterItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		def FindLastSplitAfterThisItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItem(pItem)
		return This.FindLastSplitAfterItemCS(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItem(pItem)
			return This.FindLastSplitAfterItem(pItem)

		#--

		def FindLastSplitAfterItemZ(pItem)
			return This.FindLastSplitAfterItem(pItem)

		def FindLastSplitAfterThisItemZ(pItem)
			return This.FindLastSplitAfterItem(pItem)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY Items   #
	#-----------------------------------------------#

	def FindLastSplitAfterItemsCS(paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitAfterItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItems(paItems)
		return This.FindLastSplitAfterItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItems(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterManyItems(paItems)
			return This.FindLastSplitAfterItems(paItems)

		#--

		def FindLastSplitAfterItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterTheseItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterManyItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION  #
	#---------------------------------------------#

	def FindLastSplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSection(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#--

		def FindLastSplitAfterSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		def FindLastSplitAfterThisSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindLastSplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		#--

		def FindLastSplitAfterSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		def FindLastSplitAfterThisSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)


		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS   #
	#--------------------------------------------#

	def FindLastSplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSections(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#--

		def FindLastSplitAfterSectionsZ(paSections)
			return This.FindLastSplitAfterSections(paSections)

		def FindLastSplitAfterTheseSectionsZ(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindLastSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#--

		def FindLastSplitAfterSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		def FindLastSplitAfterTheseSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR Items  #
	#==========================================================#

	def FindLastSplitBetweenCS(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetween(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSZ(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetween(pItem1, pItem2)
		return This.FindLastSplitBetweenCS(pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenZ(pItem1, pItem2)
			return This.FindLastSplitBetween(pItem1, pItem2)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenIB(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSIBZ(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIB(pItem1, pItem2)
		return This.FindLastSplitBetweenCSIB(pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenIBZ(pItem1, pItem2)
			return This.FindLastSplitBetweenIB(pItem1, pItem2)

		#>

	  #--------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS  #
	#--------------------------------------------#

	def FindLastSplitBetweenPositions(n1, n2)
		This.FindLastSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositions(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#--

		def FindLastSplitBetweenPositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		def FindLastSplitBetweenThesePositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#>
		
	  #----------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIB(n1, n2)
		This.FindLastSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#--

		def FindLastSplitBetweenPositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		def FindLastSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO Items  #
	#---------------------------------------------#

	def FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		nResult = This.FindLastSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitBetweenItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBetweenTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenItems(paItems)
		return This.FindLastSplitBetweenItemsCS(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItems(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		#--

		def FindLastSplitBetweenItemsZ(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		def FindLastSplitBetweenTheseItemsZ(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		#>

	  #-------------------------------------#
	 #    FINDING LAST SPLIT TO N PARTS    #
	#=====================================#

	def FindLastSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitToNParts(nPos)
		return nResult

		def FindLastSplitToNPartsZ(nPos)
			return This.FindLastSplitToNParts(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N Items   #
	#------------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindLastSplitToPartsOfNItems(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfNItemsZ(nPos)
			return This.FindLastSplitToPartsOfNItemsXT(nPos)

		def FindLastSplitToPartsOfExactlyNItemsZ(nPos)
			return This.FindLastSplitToPartsOfNItemsXT(nPos)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindLastSplitToPartsOfNItemsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindLastSplitToPartsOfNItemsXTZ(nPos)
			return This.FindLastSplitToPartsOfNItemsXT(nPos)

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT UNDER A GIVEN CONDITION   #
	#===============================================#

	def FindLastSplitW(pcCondition)
		/*
		? StzSplitterQ(5).FindLastSplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			oParam = new stzList(pccondition)

			if oParam.IsWhereNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeW(pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterW(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitWZ(pcCondition)
			return This.FindLastSplitWZ(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindLastSplitWXT(pcCondition)
		/*
		? StzSplitterQ(5).FindLastSplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			oParam = new stzList(ocCondition)

			if oParam.IsWhereNamedParam()
				return This.FindLastSplitAtWXT(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindLastSplitAtWXT(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeWXT(pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterWXT(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWXTZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitWXTZ(pcCondition)
			return This.FindLastSplitWXTZ(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN CONDITION   #
	#============================================#

	def FindLastSplitAtW(pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAtPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtWZ(pcCondition)
			return This.FindLastSplitAtW(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtWXT(pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAtPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtWXTZ(pcCondition)
			return This.FindLastSplitAtWXT(pcCondition)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN CONDITION   #
	#================================================#

	def FindLastSplitBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWZ(pcCondition)
			return This.FindLastSplitBeforeW(pcCondition)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWXTZ(pcCondition)
			return This.FindLastSplitBeforeWXT(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN CONDITION   #
	#===============================================#

	def FindLastSplitAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindLastSplitAfterPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWZ(pcCondition)
			return This.FindLastSplitAfterW(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN CONDITION -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindLastSplitAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindLastSplitAfterPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWXTZ(pcCondition)
			return This.FindLastSplitAfterWXT(pcCondition)

		#>

	  #=====================================================#
	 #   FINDING THE LAST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#=====================================================#

	def FindLastSplitCSXTZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- SPLITTING AT / USING

		if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
			return This.FindLastSplitAtCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
			return This.FindLastSplitAtPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
			return This.FindLastSplitAtPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([
					:AtItem, :AtThisItem,
					:UsingItem, :UsingThisItem ]) 

			return This.FindLastSplitAtItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([
					:AtItems, :AtTheseItems,
					:UsingItems, :UsingTheseItems ]) 

			return This.FindLastSplitAtItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
			return This.FindLastSplitAtSectionZZ(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
			return This.FindLastSplitAtSectionsZZ(pItem[2])

		#-- SPLITTING BEFORE

		but oParam.IsBeforeNamedParam()
			return This.FindLastSplitBeforeCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
			return This.FindLastSplitBeforePositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
			return This.FindLastSplitBeforePositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
			return This.FindLastSplitBeforeItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
			return This.SplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
			return This.FindLastSplitBeforeSectionZZ(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
			return This.FindLastSplitBeforeSectionsZZ(pItem[2])

		#-- SPLITTING AFTER

		but oParam.IsAfterNamedParam()
			return This.FindLastSplitAfterCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
			return This.FindLastSplitAfterPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
			return This.FindLastSplitAfterPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
			return This.FindLastSplitAfterItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
			return This.FindLastSplitAfterItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
			return This.FindLastSplitAfterSectionZZ(pItem[2])
	
		but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
			return This.FindLastSplitAfterSectionsZZ(pItem[2])

		# SPLITTING BETWEEN

		but oParam.IsBetweenNamedParam() and
			isList(pItem) and len(pItem) = 2
			
			if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
				pItem[2] = pItem[2][2]
			ok

			return This.FindLastSplitBetweenCSZZ(pItem[1], pItem[2], pCaseSensitive)

		but oParam.IsBetweenPositionsNamedParam()
			return This.FindLastSplitBetweenPositionsZZ(pItem[1], pItem[2])

		but oParam.IsBetweenItemsNamedParam()
			return This.FindLastSplitBetweenItemsCSZZ(pItem[1], pItem[2], pCaseSensitive)

		# SPLITTING TO PARTS

		but oParam.IsToNPartsNamedParam()
			return This.FindLastSplitToNPartsZZ(pItem[2])

		but oParam.IsToPartsOfNItemsNamedParam()
			return This.FindLastSplitToPartsOfNItemsZZ(pItem[2])

		# SPLITTING WHERE

		but oParam.IsWhereOrAtWhereNamedParam()
			return This.FindLastSplitAtWZZ(pItem[2])

		but oParam.IsBeforeWhereNamedParam()
			return This.FindLastSplitBeforeWZZ(pItem[2])

		but oParam.IsAfterWhereNamedParam()
			return This.FindLastSplitAfterWZZ(pItem[2])

		else
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionCSXT(pItem, pCaseSensitive)
			return This.FindLastSplitCSXTZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXTZZ(pItem)
		return This.FindLastSplitCSXTZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionXT(pItem)
			return This.FindLastSplitXTZZ(pItem)

		#>

	  #-----------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#=====================================================#

	def FindLastSplitAtCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		ok

		oParam = new stzList(pItem)

		#-- Case when named params are provided

		if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindLastSplitAtPositionZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindLastSplitAtPositionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindLastSplitAtItemCSZZ(pItem[2], pCaseSensitive)
	
		but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindLastSplitAtItemsCSZZ(pItem[2], pCaseSensitive)

		but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindLastSplitAtSectionZZ(pItem[2][1], pItem[2][2])
	
		but oParam.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindLastSplitAtSectionIBZZ(pItem[2][1], pItem[2][2])

		but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindLastSplitAtSectionsZZ(pItem[2])

		but oParam.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindLastSplitAtSectionsIBZZ(pItem[2])

		else
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtZZ(pItem)
		return This.FindLastSplitAtCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSection(pItem)
			return This.FindLastSplitAtCSZZ(pSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#=========================================================#

	def FindLastSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPositionAsSection(nPos)
			return This.FindLastSplitAtPositionZZ(nPos)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#------------------------------------------------------#

	def FindLastSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#--

		def FindLastSplitAtPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtThesePositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#=====================================================#

	def FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindAsSectionsCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItemZZ(pItem)
		return This.FindLastSplitAtItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, _TRUE_)

		def FindLastSplitAtThisItemZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, _TRUE_)
		#--

		def FindLastSplitAtItemAsSectionZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, _TRUE_)

		def FindLastSplitAsSection(pItem)
			return This.FindLastSplitAtItemZZ(pItem, _TRUE_)

		def FindLastSplitAtThisItemAsSection(pItem)
			return This.FindLastSplitAtItemZZ(pItem, _TRUE_)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTIONS) AT GIVEN Items  #
	#---------------------------------------------------------#

	def FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitAtItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItemsZZ(paItems)
		return This.FindLastSplitAtItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsZZ(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)
	
		def FindLastSplitAtManyItemsZZ(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		#--

		def FindLastSplitAtItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		def FindLastSplitAtTheseItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		def FindLastSplitAtManyItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#========================================================#

	def FindLastSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionZZ(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindLastSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAtSectionIBZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#------------------------------------------------------#

	def FindLastSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsZZ(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#--

		def FindLastSplitAtSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		def FindLastSplitAtTheseSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING LAST SPIT (AS SECTION) BEFORE A GIVEN ITEM   #
	#-------------------------------------------------------------------------#

	def FindLastSplitBeforeCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		ok

		oItem = new stzList(pItem)

		if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
			return This.FindLastSplitBeforePositionZZ(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
			return This.FindLastSplitBeforePositionsZZ(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
			return This.FindLastSplitBeforeItemCSZZ(pItem[2], pCaseSensitive)
	
		but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
			return This.FindLastSplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

		but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
			return This.FindLastSplitBeforeSectionZZ(pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
			return This.FindLastSplitBeforeSectionIBZZ(pItem[2][1], pItem[2][2])

		but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
			return This.FindLastSplitBeforeSectionsZZ(pItem[2])

		but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
			return This.FindLastSplitBeforeSectionsIBZZ(pItem[2])

		else
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeZZ(pItem)
		return This.FindLastSplitBeforeCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSection(pItem)
			return This.FindLastSplitBeforeZZ(pItem)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPositionZZ(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#--

		def FindLastSplitBeforePositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		def FindLastSplitBeforeThisPositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#--

		def FindLastSplitBeforePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeThesePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#--------------------------------------------------------------#

	def FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitBeforeThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItemZZ(pItem)
		return This.FindLastSplitBeforeItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemZZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		#--

		def FindLastSplitBeforeItemAsSection(pItem)
			return This.FindLastSplitBeforeItemZZ(pItem)

		def FindLastSplitBeforeThisItemAsSection(pItem)
			return This.FindLastSplitBeforeItemZZ(pItem)	

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY Items   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItemsZZ(paItems)
		return This.FindLastSplitBeforeItemsCSZZ(paItems, _TRUE_)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsZZ(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeManyItemsZZ(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		#--

		def FindLastSplitBeforeItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeTheseItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeManyItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionZZ(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#>

	  #-------------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindLastSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsZZ(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeManySectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN ITEM   #
	#--------------------------------------------------------#

	def FindLastSplitAfterCSZZ(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPositionZZ(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAfterItemCSZZ(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :SectionIB, :ThisSectionIB ]) 
				return This.FindLastSplitAfterSectionIBZZ(pItem[2][1], pItem[2][2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :SectionsIB, :TheseSectionsIB ]) 
				return This.FindLastSplitAfterSectionsIBZZ(pItem[2])

			else
				return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterZZ(pItem)
		return This.FindLastSplitAfterCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSection(pItem)
			return This.FindLastSplitAfterCSZZ(pItem, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPositionZZ(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		def FindLastSplitAfterThisPositionAsSection(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositionsZZ(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsZZ(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#--

		def FindLastSplitAfterPositionsAsSection(anPos)
			return This.FindLastSplitAfterPositionsZZ(anPos)

		def FindLastSplitAfterThesePositionsAsSection(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsAsSection(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#--------------------------------------------------------------#

	def FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitAfterItemAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAfterThisItemAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItemZZ(pItem)
		return This.FindLastSplitAfterItemCSZZ(pItem, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemZZ(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		#--

		def FindLastSplitAfterItemAsSection(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		def FindLastSplitAfterThisItemAsSection(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY Items   #
	#------------------------------------------------------------#

	def FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitAfterItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsAsSectionCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItemsZZ(paItems)
		return This.FindLastSplitAfterItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterManyItemsZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		#--

		def FindLastSplitAfterItemsAsSection(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterTheseItemsAsSection(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterManyItemsAsSectionZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionZZ(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindLastSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsZZ(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSection(paSections)
			return This.FindLastSplitAfterSectionsZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSection(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items  #
	#=======================================================================#

	def FindLastSplitBetweenCSZZ(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenZZ(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCS(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenZZ(pItem1, pItem2)
		return This.FindLastSplitBetweenCS(pItem1, pItem2, _TRUE_)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSection(pItem1, pItem2)
			return This.FindLastSplitBetweenZZ(pItem1, pItem2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenIBZZ(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCSIB(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIBZZ(pItem1, pItem2)
		return This.FindLastSplitBetweenCSIBZZ(pItem1, pItem2, _TRUE_)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionIB(pItem1, pItem2)
			return This.FindLastSplitBetweenIBZZ(pItem1, pItem2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#---------------------------------------------------------#

	def FindLastSplitBetweenPositionsZZ(n1, n2)
		This.FindLastSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIBZZ(n1, n2)
		This.FindLastSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO Items  #
	#----------------------------------------------------------#

	def FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)
		aSections = This.FindAsSections(paItems, pCaseSensitive)
		aResult = This.FindLastSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitBetweenItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBetweenTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenItemsZZ(paItems)
		return This.FindLastSplitBetweenItemsCSZZ(paItems, _TRUE_)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsZZ(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		#--

		def FindLastSplitBetweenItemsAsSection(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		def FindLastSplitBetweenTheseItemsAsSection(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		#>

	  #--------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) TO N PARTS    #
	#==================================================#

	def FindLastSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitToNPartsZZ(nPos)
		return aResult

		def FindLastSplitToNPartsAsSection(nPos)
			return This.FindLastSplitToNPartsZZ(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N Items   #
	#------------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindLastSplitToPartsOfNItemsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNItemsZZ(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		#--

		def FindLastSplitToPartsOfNItemsAsSection(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		def FindLastSplitToPartsOfExactlyNItemsAsSection(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#-----------------------------------------------------------------------------#
	# The remaining part (if any) less then n Items is also returned

	def FindLastSplitToPartsOfNItemsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) UNDER A GIVEN CONDITION   #
	#=============================================================#

	def FindLastSplitWZZ(pcCondition)

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeWZZ(pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterWZZ(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionW(pcCondition)
			return This.FindLastSplitWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def FindLastSplitWXTZZ(pcCondition)

		if isList(pcCondition)

			oParam = new stzList(pcCondition)

			if oParam.IsWhereNamedParam()
				return This.FindLastSplitAtWXTZZ(pcCondition[2])

			but oParam.IsAtNamedParam()
				return This.FindLastSplitAtWXTZZ(pcCondition[2])

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeWXTZZ(pcCondition[2])

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterWXTZZ(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWXTZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionWXT(pcCondition)
			return This.FindLastSplitWXTZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDITION   #
	#==========================================================#

	def FindLastSplitAtWZZ(pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAtPositionsZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionW(pcCondition)
			return This.FindLastSplitAtWZZ(pcCondition)

		#>

	  #-------------------------------------------------------------------------#
	 #    FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDITION -- WXT/EXTENDED  #
	#-------------------------------------------------------------------------#

	def FindLastSplitAtWXTZZ(pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAtPositionsZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionWXT(pcCondition)
			return This.FindLastSplitAtWXTZZ(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION   #
	#==============================================================#

	def FindLastSplitBeforeWZZ(pcCondition)
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitBeforeZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeAsSectionW(pcCondition)
			return This.FindLastSplitBeforeWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitBeforeWXTZZ(pcCondition)
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitBeforeZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeAsSectionWXT(pcCondition)
			return This.FindLastSplitBeforeWXTZZ(pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDITION   #
	#=============================================================#

	def FindLastSplitAfterWZZ(pcCondition)
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAfterZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionW(pcCondition)
			return This.FindLastSplitAfterWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDITION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterWXTZZ(pcCondition)
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAfterZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionWXT(pcCondition)
			return This.FindLastSplitAfterWXTZZ(pcCondition)

		#>

	  #=====================#
	 #     COMBINATIONS    #
	#=====================#

	def NumberOfCombinations()
		return len(This.Combinations()) #TODO // solve it mathematically.
	
		def HowManyCombinations()
			return This.NumberOfCombinations()

		def CountCombinations()
			return This.NumberOfCombinations()

	def Combinations()
		_aContent_ = This.Content()
		return @Combinations(_aContent_, 2)

	#--

	def NumberOfCombinationsN(n)
		return len(This.CombinationsN(n))

		def HowManyCombinationsN(n)
			return This.NumberOfCombinationsN(n)

		def CountCombinationsN(n)
			return This.NumberOfCombinationsN(n)

	def CombinationsN(n)
		_aContent_ = This.Content()
		return @Combinations(_aContent_, n)

	#== XT

	def NumberOfCombinationsXT()
		return len(This.CombinationsXT()) #TODO // solve it mathematically.

		def HowManyCombinationsXT()
			return This.NumberOfCombinationsXT()

		def CountCombinationsXT()
			return This.NumberOfCombinationsXT()

	def CombinationsXT()
		_aContent_ = This.Content()
		return @CombinationsXT(_aContent_, 2)

	#--

	def NumberOfCombinationsNXT(n)
		return len(This.CombinationsNXT(n))

		def HowManyCombinationsNXT(n)
			return This.NumberOfCombinationsNXT(n)

		def CountCombinationsNXT(n)
			return This.NumberOfCombinationsNXT(n)

	def CombinationsNXT(n)
		_aContent_ = This.Content()
		return @CombinationsXT(_aContent_, n)


	  #===========================================#
	 #  GETTING THE UNICODES CODES OF EACH ITEM  #
	#===========================================#

	def Unicodes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				i++
			ok

			aResult + Q(aContent[i]).Unicode()
		next

		return aResult

		def Unicode()
			return This.Unicodes()

	def HexUnicodes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				i++
			ok

			aResult + Q(aContent[i]).HexUnicode()
		next

		return aResult

		def HexUnicode()
			return This.HexUnicodes()

	  #-----------------------------------------------------------#
	 #  GETTING THE NAMES (IN UNICODE) OF THE CHARS IN THE LIST  #
	#-----------------------------------------------------------#

	def Names()
		acChars = This.Chars()
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			acResult + StzCharQ(acChars[i]).Name()
		next

		return acResult

		#< @FunctionAlternativeForms

		def NamesInUnicode()
			return This.Names()

		def UnicodeNames()
			return This.Names()

		#--

		def CharsNames()
			return This.Names()

		def CharsNamesInUnicode()
			return This.Names()

		def UnicodeCharsNames()
			return This.Names()

		#>

	  #======================================#
	 #  CHECKING IF THE LIST IS PALINDROME  #
	#======================================#

	def IsPalindromeCS(pCaseSensitive)
		if This.NumberOfChars() < 2
			return _FALSE_
		ok

		if This.IsEqualtToCS( ring_reverse(This.Content()), pCaseSensitive) = _TRUE_
			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsPalindromCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

		def IsMirroredCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsPalindrome()
		return This.IsPalindromeCS(_TRUE_)

		#< @FunctionAlternativeForms

		def IsPalindrom()
			return This.IsPalindrome()

		def IsMirrored()
			return This.ISPalindrome()

		#>


	    /////////////////////////////////////////////////////
	   /// #===========================================# ///
	  /// #   CHECKING IF THE LIST IS A NAMED PARAM   # ///
	 /// #===========================================# ///
	/////////////////////////////////////////////////////

	#NOTE
	# Currently (V1) Softanza supports more then 1500 named params

	#TODO // Add @ to all params, like this:
	# (This.Item(1) = :ParamName or This.Item(1) = :ParamName@ ) )

	def IsOnPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnPosition)

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and This.Item(1) = :InPosition)
	
				return _TRUE_
			else
				return _FALSE_
			ok
	
		// def IsAtPositionNamedParam() --> Exists below in the file


	def IsOnPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnPositions)

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInPositionsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and This.Item(1) = :InPositions)
	
				return _TRUE_
			else
				return _FALSE_
			ok

	def IsOnSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOnSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSectionIB)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOnSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOnSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSectionsIB)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Harvest)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvest)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvest)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvest)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Yield)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYield)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYield)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYield)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :HarvestSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvestSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvestSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvestSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :YieldSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYieldSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYieldSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYieldSection)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :HarvestSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvestSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvestSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvestSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :YieldSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYieldSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndThenYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYieldSections)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThenYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYieldSections)

			return _TRUE_
		else
			return _FALSE_
		ok
	#--

	def IsNCharsBeforeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NCharsBefore)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNCharsAfterNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NCharsAfter)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsToNPartsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToNParts)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNChars)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItems)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNItemsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItemsXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNSubStringss)

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsAtWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtWhere)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWhereOrAtWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAtWhereOrWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWhereOrAtWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAtWhereOrWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsAtWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtWhereXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWhereXTOrAtWhereXTNamedParam()
		if This.IsWhereXTNamedParam() or This.IsAtWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAtWhereXTOrWhereXTNamedParam()
		if This.IsWhereXTNamedParam() or This.IsAtWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWhereXTOrAtWhereXTNamedParams()
		if This.IsWhereXTNamedParam() or This.IsAtWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAtWhereXTOrWhereXTNamedParams()
		if This.IsWhereXTNamedParam() or This.IsAtWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsBeforeWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeWhere)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeOrBeforeWhereNamedParam()
		if This.IsBeforeNamedParam() or This.IsBeforeWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBeforeWhereOrBeforeNamedParam()
			return This.IsBeforeOrBeforeWhereNamedParam()

		def IsBeforeOrBeforeWhereNamedParams()
			return This.IsBeforeOrBeforeWhereNamedParam()

		def IsBeforeWhereOrBeforeNamedParams()
			return This.IsBeforeOrBeforeWhereNamedParam()

	#--

	def IsBeforeWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeWhereXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeOrBeforeWhereXTNamedParam()
		if This.IsBeforeNamedParam() or This.IsBeforeWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBeforeWhereXTOrBeforeNamedParam()
			return This.IsBeforeOrBeforeWhereXTNamedParam()

		def IsBeforeOrBeforeWhereXTNamedParams()
			return This.IsBeforeOrBeforeWhereXTNamedParam()

		def IsBeforeWhereXTOrBeforeNamedParams()
			return This.IsBeforeOrBeforeWhereXTNamedParam()

	#==

	#==

	def IsAfterWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterWhere)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterOrAfterWhereNamedParam()
		if This.IsAfterNamedParam() or This.IsAfterWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAfterWhereOrAfterNamedParam()
			return This.IsAfterOrAfterWhereNamedParam()

		def IsAfterOrAfterWhereNamedParams()
			return This.IsAfterOrAfterWhereNamedParam()

		def IsAfterWhereOrAfterNamedParams()
			return This.IsAfterOrAfterWhereNamedParam()

	#--

	def IsAfterWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterWhereXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterOrAfterWhereXTNamedParam()
		if This.IsAfterNamedParam() or This.IsAfterWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAfterWhereXTOrAfterNamedParam()
			return This.IsAfterOrAfterWhereXTNamedParam()

		def IsAfterOrAfterWhereXTNamedParams()
			return This.IsAfterOrAfterWhereXTNamedParam()

		def IsAfterWhereXTOrAfterNamedParams()
			return This.IsAfterOrAfterWhereXTNamedParam()

	#==

	def IsToPartsOfExactlyNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNItems)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfExactlyNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNChars)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfExactlyNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfExactlyNSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNSubStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsToPartsOfNItemsXT()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItemsXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNCharsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNCharsXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNStringsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNStringsXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToPartsOfNSubStringsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNSubStringsXT)

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToItems)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUntilItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsDownToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownTo)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItemAt)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItemAtPosition)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToChar)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToCharAt)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsDownToCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToCharAtPosition)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	#TODO // Move IsToCharNamedParam() here

	def IsUntilCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilChar)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToChar)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	# Move IsToSubStringNamedParam() here

	def IsUntilSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilSubString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToSubString)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	#TODO : Move IsToStringNamedParam() here

	def IsUntilStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToString)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	#TODO // Move IsToNumberNamedParam() here

	def IsUntilNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilNumber)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToNumber)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	#TODO // Move IsToListNamedParam() here

	def IsUntilListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilList)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToList)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	#TODO : Move IsToObjectNamedParam() here

	def IsUntilObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilObject)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUpToObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToObject)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsOneOfTheseNamedParams(pacParamNames)
		if CheckingParams()
			if NOT ( isList(pacParamNames) and @IsListOfStrings(pacParamNames) )
				StzRaise("Incorrect param type! pacParamNames must be a list of strings.")
			ok
		ok

		nLen = len(pacParamNames)
		bResult = _FALSE_

		for i = 1 to nLen
			cCode = 'bFound = This.Is' + pacParamNames[i] + 'NamedParam()'
			eval(cCode)
			if bFound
				bResult = _TRUE_
				exit
			ok
		next

		return bResult

		#< @FunctionMisspelledForm

		def IsOneTheseNamedParams(pacParamNames)
			return This.IsOneOfTheseNamedParams(pacParamNames)

		#>

	def IsRemoveAtOptionsNamedParam()
		bResult = _FALSE_

		if This.IsHashList() and

		   This.ToStzHashList().KeysQ().IsMadeOfSome([
			:RemoveNCharsBefore, :RemoveNCharsAfter,
			:RemoveThisSubStringBefore,:RemoveThisSubStringAfter,
			:RemoveThisCharBefore,:RemoveThisCharBefore,
			:RemoveThisBound, :RemoveThisBoundingSubString,
			:CaseSensitive, :CS ])
			#NOTE: I've decided to keep CS as a suffix in the function
			# name and never use it as an internal option...
			#--> more simple mental model to keep things memprable

			if This.ToStzHashList().
				KeysQRT(:stzListOfStrings).
				ContainsBothCS(:CaseSensitive, :CS, _FALSE_)

				StzRaise("Incorrect format! :CaseSensitive and :CS can not be used both in the same time")
			ok

			if This.ToStzHashList().
				KeysQRT(:stzListOfStrings).
				ContainsBothCS(:RemoveThisBound, :RemoveThisBoundingSubString, _FALSE_)

				StzRaise("Incorrect format! :RemoveThisBound and :RemoveThisBoundingSubString can not be used both in the same time")
			ok

			bOk1 = _FALSE_
			nRemoveNCharsBefore = This.Content()[ :RemoveNCharsBefore ]
			cType = ring_type(nRemoveNCharsBefore)
		   	if cType = "NUMBER" or ( cType = "STRING" and nRemoveNCharsBefore = _NULL_ )
				bOk1 = _TRUE_
			ok

			bOk2 = _FALSE_
			nRemoveNCharsAfter = This.Content()[ :RemoveNCharsAfter ]
			cType = ring_type(nRemoveNCharsAfter)
		   	if cType = "NUMBER" or ( cType = "STRING" and nRemoveNCharsAfter = _NULL_ )
				bOk2 = _TRUE_
			ok

			bOk3 = _FALSE_
			cRemoveSubStringBefore = This.Content()[ :RemoveSubStringBefore ]
			cType = ring_type(cRemoveSubStringBefore)
		   	if cType = "STRING"
				bOk3 = _TRUE_
			ok

			bOk4 = _FALSE_
			cRemoveSubStringAfter = This.Content()[ :RemoveSubStringAfter ]
			cType = ring_type(cRemoveSubStringAfter)
		   	if cType = "STRING"
				bOk4 = _TRUE_
			ok

			bOk5 = _FALSE_
			cRemoveThisBound = This.Content()[ :cRemoveThisBound ]
			cType = ring_type(cRemoveThisBound)
		   	if cType = "STRING"
				bOk5 = _TRUE_
			ok

			if bOk1 and bOk2 and bOk3 and bOk4 and bOk5
				bResult = _TRUE_
			ok
		ok

		return bResult

	def IsTextBoxedOptionsNamedParam()
		/*
		Example:

		? StzStringQ("TEXT1").BoxedXT([
			:Line = :Solid,	# or :Dashed
		
			:AllCorners = :Round # can also be :Rectangualr
			# :Corners = [ :Round, :Rectangular, :Round, :Rectangular ],
		
			:Width = 17,
			:TextAdjustedTo = :Center # or :Left or :Right or :Justified,
			
			:EachChar = _FALSE_ # _TRUE_,
			:Hilighted = [ 1, 3 ] # Hilight the 1st and 3rd chars,

			:Numbered = _TRUE_
		])
		*/

		if This.IsEmpty()
			return _TRUE_
		ok

		aListOfBoxOptions = [

			:Line, :Solid, :Dashed,

			:Rounded, :Round,
			:AllCorners, :Corners,
			:Width,
			:TextAdjustedTo,
			:EachChar,
			:EachWord,

			:Hilighted, :Hilight,
			:HilightPositions, :ShowPositions,

			:Numbered, :Numbers,
			:NumberedXT, :NumberXT,

			:PositionSign, :PositionChar,
			:HilightSign, :HilightChar,

			:Sectioned
		]

		nLen = This.NumberOfItems()

		if nLen >= 1 and nLen < len(aListOfBoxOptions)

			if This.IsHashList() and
			   StzHashListQ(This.Content()).KeysQ().IsMadeOfSome(aListOfBoxOptions)

				return _TRUE_
			ok

		ok

		return _FALSE_

	def IsBoxOptionsNamedParam()

		if This.IsEmpty()
			return _TRUE_
		ok

		aListOfBoxOptions = [
			:Line,
			:AllCorners,
			:Corners,
			:Width,
			:TextAdjustedTo,
			:EachChar,

			:Casesensitive,
			:CS,

			:Numbered,
			:Spacified,

			:Shadowed,
			:ShadowChar,
			:ShadowOrientation
			
		]

		nLen = This.NumberOfItems()
		   
		if nLen >= 1 and nLen <= len(aListOfBoxOptions) and
		   This.IsHashList() and
		   StzHashListQ(This.Content()).KeysQ().IsMadeOfSome(aListOfBoxOptions)
		
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsConstraintsOptionsNamedParam()
		/* EXAMPLE
		[
			:OnStzString = [
				:MustBeUppercase 	= '{ Q(@str).IsUppercase() }',
				:MustNotExceed@n@Chars 	= '{ Q(@str).NumberOfChars() <= n }',
				:MustBeginWithLetter@c@	= '{ Q(@str).BeginsWithCS(c, _FALSE_) }'
			],
		
			:OnStzNumber = [
				:MustBeStrictlyPositive = '{ @number > 0 }'
			],
		
			:OnStzList = [
				:MustBeAHashList = '{ Q(@list).IsHashList() }'
			]
		]
		*/
		
		try
			VerifyConstraints([
				:MustBeAHashList,
				:KeysMustBeOnStzTypes,
				:ValuesMustBeRingCodeInStrings
			])

			return _TRUE_

		catch
			return _FALSE_
		done

	#--

	def IsCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Cell)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCell)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Cells)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCells)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InCell)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InCells)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsCellValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :CellValue)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfCellValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCellValue)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsCellPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :CellPart)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Part)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSubPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubPart)

			return _TRUE_
		else
			return _FALSE_
		ok
	#--

	def IsSubValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubValue)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSubValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubValue)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSubValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubValues)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSubValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubValues)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsOfCellPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCellPart)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfPart)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSubPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubPart)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Col or This.Item(1) = :Column) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColumnNamedParam()
			return This.IsColNamedParam()

	def IsColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ColNumber or This.Item(1) = :ColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColumnNumberNamedParam()
			return This.IsColNumberNamedParam()

	def IsColOrColNumberNamedParam()
		if This.IsColNumberNamedParam() or This.IsColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColOrColNumberNamedParams()
			return This.IsColOrColNumberNamedParam()

		def IsColNumberOrColNamedParam()
			return This.IsColOrColNumberNamedParam()

		def IsColNumberOrColNamedParams()
			return This.IsColOrColNumberNamedParam()

	#--

	def IsOfColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfCol or This.Item(1) = :OfColumn) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColumnNamedParam()
			return This.IsOfColNamedParam()

	def IsOfColOrColumnNamedParam()
		if This.IsOfColNamedParam() or This.IsOfColumnNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsOfColumnOrColNamedParam()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColOrOfColumnNamedParam()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrOfColNamedParam()
			return This.IsOfColOrColumnNamedParam()

		#--

		def IsOfColOrColumnNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrColNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColOrOfColumnNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrOfColNamedParams()
			return This.IsOfColOrColumnNamedParam()

	#--

	def IsInColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InCol or This.Item(1) = :InColumn) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColumnNamedParam()
			return This.IsInColNamedParam()

	def IsInColOrColumnNamedParam()
		if This.IsInColNamedParam() or This.IsInColumnNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsInColumnOrColNamedParam()
			return This.IsInColOrColumnNamedParam()

		def IsInColOrInColumnNamedParam()
			return This.IsInColOrColumnNamedParam()

		def IsInColumnOrInColNamedParam()
			return This.IsInColOrColumnNamedParam()

		#--

		def IsInColOrColumnNamedParams()
			return This.IsInColOrColumnNamedParam()

		def IsInColumnOrColNamedParams()
			return This.IsInColOrColumnNamedParams()

		def IsInColOrInColumnNamedParams()
			return This.IsInColOrColumnNamedParams()

		def IsInColumnOrInColNamedParams()
			return This.IsInColOrColumnNamedParam()

	#--

	def IsColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Cols or This.Item(1) = :Columns) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColumnsNamedParam()
			return This.IsColsNamedParam()

	def IsColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ColsNumbers or This.Item(1) = :ColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColumnsNumbersNamedParam()
			return This.IsColsNumbersNamedParam()

	def IsColsOrColsNumberNamedParam()
		if This.IsColsNumbersNamedParam() or This.IsColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsColsNumbersOrColsNamedParam()
			return This.IsColsOrColsNumberNamedParam()

		def IsColsOrColsNumberNamedParams()
			return This.IsColsOrColsNumberNamedParam()

		def IsColsNumbersOrColsNamedParams()
			return This.IsColsOrColsNumberNamedParam()

	#--

	def IsOfColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfCols or This.Item(1) = :OfColumns) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColumnsNamedParam()
			return This.IsOfColsNamedParam()

	def IsOfColsOrColumnsNamedParam()
		if This.IsOfColsNamedParam() or This.IsOfColumnsNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsOfColumnsOrColsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColsOrOfColumnsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrOfColsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		#--

		def IsOfColsOrColumnsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrColsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColsOrOfColumnsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrOfColsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

	#--

	def IsInColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InCols or This.Item(1) = :InColumns) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColumnsNamedParam()
			return This.IsInColsNamedParam()

	def IsInColsOrColumnsNamedParam()
		if This.IsInColsNamedParam() or This.IsInColumnsNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsInColumnsOrColNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColsOrInColumnsNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrInColNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		#--

		def IsInColsOrColumnsNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrColNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColsOrInColumnsNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrInColNamedParams()
			return This.IsInColsOrColumnsNamedParam()

	#==

	def IsByColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ByColNumber or This.Item(1) = :ByColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByColumnNumberNamedParam()
			return This.IsByColNumberNamedParam()

	def IsByColOrByColNumberNamedParam()
		if This.IsByColNumberNamedParam() or This.IsByColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByColOrByColNumberNamedParams()
			return This.IsByColOrByColNumberNamedParam()

		def IsByColNumberOrByColNamedParam()
			return This.IsByColOrByColNumberNamedParam()

		def IsByColNumberOrColNamedParams()
			return This.IsByColOrByColNumberNamedParam()

	def IsByColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ByColsNumbers or This.Item(1) = :ByColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByColumnsNumbersNamedParam()
			return This.IsByColsNumbersNamedParam()

	def IsByColsOrByColsNumbersNamedParam()
		if This.IsByColsNumbersNamedParam() or This.IsByColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByColsOrByColsNumbersNamedParams()
			return This.IsByColsOrByColsNumbersNamedParam()

		def IsByColsNumbersOrByColsNamedParam()
			return This.IsByColsOrByColsNumbersNamedParam()

		def IsByColsNumbersOrColsNamedParams()
			return This.IsByColsOrColsNumberNamedParam()

	#--

	def IsInColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InColNumber or This.Item(1) = :InColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColumnNumberNamedParam()
			return This.IsInColNumberNamedParam()

	def IsInColOrInColNumberNamedParam()
		if This.IsInColNumberNamedParam() or This.IsInColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColOrInColNumberNamedParams()
			return This.IsInColOrInColNumberNamedParam()

		def IsInColNumberOrInColNamedParam()
			return This.IsInColOrInColNumberNamedParam()

		def IsInColInNumberOrColNamedParams()
			return This.IsInColOrInColNumberNamedParam()

	def IsInColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InColsNumbers or This.Item(1) = :InColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColumnsNumbersNamedParam()
			return This.IsInColsNumbersNamedParam()

	def IsInColsOrInColsNumbersNamedParam()
		if This.IsInColsNumbersNamedParam() or This.IsInColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInColsOrInColsNumbersNamedParams()
			return This.IsInColsOrInColsNumbersNamedParam()

		def IsInColsNumbersOrInColsNamedParam()
			return This.IsInColsOrinColsNumbersNamedParam()

		def IsInColsNumbersOrInColsNamedParams()
			return This.IsInColsOrInColsNumberNamedParam()

	#--

	def IsOfColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfColNumber or This.Item(1) = :OfColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColumnNumberNamedParam()
			return This.IsOfColNumberNamedParam()

	def IsOfColOrOfColNumberNamedParam()
		if This.IsOfColNumberNamedParam() or This.IsOfColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColOrOfColNumberNamedParams()
			return This.IsOfColOrOfColNumberNamedParam()

		def IsOfColNumberOrOfColNamedParam()
			return This.IsOfColOrOfColNumberNamedParam()

		def IsOfColNumberOrOfColNamedParams()
			return This.IsOfColOrOfColNumberNamedParam()

	def IsOfColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfColsNumbers or This.Item(1) = :OfColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColumnsNumbersNamedParam()
			return This.IsOfColsNumbersNamedParam()

	def IsOfColsOrOfColsNumbersNamedParam()
		if This.IsOfColsNumbersNamedParam() or This.IsOfColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfColsOrOfColsNumbersNamedParams()
			return This.IsOfColsOrOFColsNumbersNamedParam()

		def IsOfColsNumbersOrOfColsNamedParam()
			return This.IsOfColsOrOfColsNumbersNamedParam()

		def IsOfColsNumbersOrOfColsNamedParams()
			return This.IsOfColsOrOfColsNumberNamedParam()

	#--

	def IsToColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ToColNumber or This.Item(1) = :ToColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToColumnNumberNamedParam()
			return This.IsToColNumberNamedParam()

	def IsToColOrToColNumberNamedParam()
		if This.IsToColNumberNamedParam() or This.IsToColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToColOrToColNumberNamedParams()
			return This.IsToColOrToColNumberNamedParam()

		def IsToColNumberOrToColNamedParam()
			return This.IsToColOrToColNumberNamedParam()

		def IsToColNumberOrToColNamedParams()
			return This.IsToColOrToColNumberNamedParam()

	def IsToColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ToColsNumbers or This.Item(1) = :ToColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToColumnsNumbersNamedParam()
			return This.IsToColsNumbersNamedParam()

	def IsToColsOrToColsNumbersNamedParam()
		if This.IsToColsNumbersNamedParam() or This.IsToColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToColsOrToColsNumbersNamedParams()
			return This.IsToColsOrToColsNumbersNamedParam()

		def IsToColsNumbersOrToColsNamedParam()
			return This.IsToColsOrToColsNumbersNamedParam()

		def IsToColsNumbersOrtoColsNamedParams()
			return This.IsToColsOrToColsNumberNamedParam()

	#--

	def IsUsingColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :UsingColNumber or This.Item(1) = :UsingColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingColumnNumberNamedParam()
			return This.IsUsingColNumberNamedParam()

	def IsUsingColOrUsingColNumberNamedParam()
		if This.IsUsingColNumberNamedParam() or This.IsUsingColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingColOrUsingColNumberNamedParams()
			return This.IsUsingColOrUsingColNumberNamedParam()

		def IsUsingColNumberOrUsingColNamedParam()
			return This.IsUsingColOrUsingColNumberNamedParam()

		def IsUsingColNumberOrUsingColNamedParams()
			return This.IsUsingColOrUsingColNumberNamedParam()

	def IsUsingColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :UsingColsNumbers or This.Item(1) = :UsingColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingColumnsNumbersNamedParam()
			return This.IsUsingColsNumbersNamedParam()

	def IsUsingColsOrUsingColsNumbersNamedParam()
		if This.IsUsingColsNumbersNamedParam() or This.IsUsingColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingColsOrUsingColsNumbersNamedParams()
			return This.IsUsingColsOrUsingColsNumbersNamedParam()

		def IsUsingColsNumbersOrUsingColsNamedParam()
			return This.IsUsingColsOrUsingColsNumbersNamedParam()

		def IsUsingColsNumbersOrUsingColsNamedParams()
			return This.IsUsingColsOrUsingColsNumberNamedParam()

	#--

	def IsWithColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :WithColNumber or This.Item(1) = :WithColumnNumber) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithColumnNumberNamedParam()
			return This.IsWithColNumberNamedParam()

	def IsWithColOrWithColNumberNamedParam()
		if This.IsWithColNumberNamedParam() or This.IsWithColNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithColOrWithColNumberNamedParams()
			return This.IsWithColOrWithColNumberNamedParam()

		def IsWithColNumberOrWithColNamedParam()
			return This.IsWithColOrWithColNumberNamedParam()

		def IsWithColNumberOrWithColNamedParams()
			return This.IsWithColOrWithColNumberNamedParam()

	def IsWithColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :WithColsNumbers or This.Item(1) = :WithColumnsNumbers) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithColumnsNumbersNamedParam()
			return This.IsWithColsNumbersNamedParam()

	def IsWithColsOrWithColsNumbersNamedParam()
		if This.IsWithColsNumbersNamedParam() or This.IsWithColsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithColsOrWithColsNumbersNamedParams()
			return This.IsWithColsOrWithColsNumbersNamedParam()

		def IsWithColsNumbersOrWithColsNamedParam()
			return This.IsWithColsOrWithColsNumbersNamedParam()

		def IsWithColsNumbersOrWithColsNamedParams()
			return This.IsWithColsOrColsNumberNamedParam()

	#==

	def IsByRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ByRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok


	def IsByRowOrByRowNumberNamedParam()
		if This.IsByRowNumberNamedParam() or This.IsByRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByRowOrByRowNumberNamedParams()
			return This.IsByRowOrByRowNumberNamedParam()

		def IsByRowNumberOrByRowNamedParam()
			return This.IsByRowOrByRowNumberNamedParam()

		def IsByRowNumberOrByRowNamedParams()
			return This.IsByRowOrByRowNumberNamedParam()

	def IsByRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ByRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsByRowsOrByRowsNumbersNamedParam()
		if This.IsByRowsNumbersNamedParam() or This.IsByRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByRowsOrByRowsNumbersNamedParams()
			return This.IsByRowsOrByRowsNumbersNamedParam()

		def IsByRowsNumbersOrByRowsNamedParam()
			return This.IsByRowsOrByRowsNumbersNamedParam()

		def IsByRowsNumbersOrByRowsNamedParams()
			return This.IsByRowsOrByRowsNumberNamedParam()

	#--

	def IsInRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInRowOrInRowNumberNamedParam()
		if This.IsInRowNumberNamedParam() or This.IsInRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInRowOrInRowNumberNamedParams()
			return This.IsInRowOrInRowNumberNamedParam()

		def IsInRowNumberOrInRowNamedParam()
			return This.IsInRowOrInRowNumberNamedParam()

		def IsInRowNumberOrInRowNamedParams()
			return This.IsInRowOrInRowNumberNamedParam()

	def IsInRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInRowsOrInRowsNumbersNamedParam()
		if This.IsInRowsNumbersNamedParam() or This.IsInRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInRowsOrInRowsNumbersNamedParams()
			return This.IsInRowsOrInRowsNumbersNamedParam()

		def IsInRowsNumbersOrInRowsNamedParam()
			return This.IsInRowsOrInRowsNumbersNamedParam()

		def IsInRowsNumbersOrInRowsNamedParams()
			return This.IsInRowsOrInRowsNumberNamedParam()

	#--

	def IsOfRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfRowOrOfRowNumberNamedParam()
		if This.IsOfRowNumberNamedParam() or This.IsOfRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfRowOrOfRowNumberNamedParams()
			return This.IsOfRowOrOfRowNumberNamedParam()

		def IsOfRowNumberOrOfRowNamedParam()
			return This.IsOfRowOrOfRowNumberNamedParam()

		def IsOfRowNumberOrOfRowNamedParams()
			return This.IsOfRowOrOfRowNumberNamedParam()

	def IsOfRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfRowsOrOfRowsNumbersNamedParam()
		if This.IsOfRowsNumbersNamedParam() or This.IsOfRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfRowsOrOfRowsNumbersNamedParams()
			return This.IsOfRowsOrOfRowsNumbersNamedParam()

		def IsOfRowsNumbersOrOfRowsNamedParam()
			return This.IsOfRowsOrOfRowsNumbersNamedParam()

		def IsOfRowsNumbersOrOfRowsNamedParams()
			return This.IsOfRowsOrOfRowsNumberNamedParam()

	#--

	def IsToRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToRowOrToRowNumberNamedParam()
		if This.IsToRowNumberNamedParam() or This.IsToRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToRowOrToRowNumberNamedParams()
			return This.IsToRowOrToRowNumberNamedParam()

		def IsToRowNumberOrToRowNamedParam()
			return This.IsToRowOrToRowNumberNamedParam()

		def IsToRowNumberOrToRowNamedParams()
			return This.IsToRowOrToRowNumberNamedParam()

	def IsToRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToRowsOrToRowsNumbersNamedParam()
		if This.IsToRowsNumbersNamedParam() or This.IsToRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToRowsOrToRowsNumbersNamedParams()
			return This.IsToRowsOrToRowsNumbersNamedParam()

		def IsToRowsNumbersOrToRowsNamedParam()
			return This.IsToRowsOrToRowsNumbersNamedParam()

		def IsToRowsNumbersOrToRowsNamedParams()
			return This.IsToRowsOrToRowsNumberNamedParam()

	#--

	def IsUsingRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingRowOrUsingRowNumberNamedParam()
		if This.IsUsingRowNumberNamedParam() or This.IsUsingRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingRowOrUsingRowNumberNamedParams()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

		def IsUsingRowNumberOrUsingRowNamedParam()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

		def IsUsingRowNumberOrUsingRowNamedParams()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

	def IsUsingRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingRowsOrUsingRowsNumbersNamedParam()
		if This.IsUsingRowsNumbersNamedParam() or This.IsUsingRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingRowsOrUsingRowsNumbersNamedParams()
			return This.IsUsingRowsOrUsingRowsNumbersNamedParam()

		def IsUsingRowsNumbersOrUsingRowsNamedParam()
			return This.IsUsingRowsOrUsingRowsNumbersNamedParam()

		def IsUsingRowsNumbersOrUsingRowsNamedParams()
			return This.IsUsingRowsOrUsingRowsNumberNamedParam()

	#--

	def IsWithRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :WithRowNumber )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWithRowOrWithRowNumberNamedParam()
		if This.IsWithRowNumberNamedParam() or This.IsWithRowNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithRowOrWithRowNumberNamedParams()
			return This.IsWithRowOrWithRowNumberNamedParam()

		def IsWithRowNumberOrWithRowNamedParam()
			return This.IsWithRowOrWithRowNumberNamedParam()

		def IsWithRowNumberOrWithRowNamedParams()
			return This.IsWithRowOrWithRowNumberNamedParam()

	def IsWithRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :WithRowsNumbers )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsWithRowsOrWithRowsNumbersNamedParam()
		if This.IsWithRowsNumbersNamedParam() or This.IsWithRowsNumbersNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithRowsOrWithRowsNumbersNamedParams()
			return This.IsWithRowsOrWithRowsNumbersNamedParam()

		def IsWithRowsNumbersOrWithRowsNamedParam()
			return This.IsWithRowsOrWithRowsNumbersNamedParam()

		def IsWithRowsNumbersOrWithRowsNamedParams()
			return This.IsWithRowsOrWithRowsNumberNamedParam()

	#==

	def IsRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Row)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRow)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRow)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Rows)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRows)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRows)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Occurrence)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Nth)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNthOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NthOccurrence)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :N)

			return _TRUE_
		else
			return _FALSE_
		ok
	#--

	def IsCaseSensitiveNamedParam()
		aContent = This.Content()
		nLen = len(aContent)

		if NOT nLen = 2
			return _FALSE_
		ok

		if NOT isString(aContent[1])
			return _FALSE_
		ok

		if NOT isNumber(aContent[2])
			return _FALSE_
		ok

		if NOT ( aContent[1] = :CaseSensitive or aContent[1] = :CS )
			return _FALSE_
		ok

		if NOT ( aContent[2] = 0 or aContent[2] = 1 )
			return _FALSE_
		ok

		return _TRUE_

	def IsRangeNamedParam()

		if This.IsEmpty()
			return _TRUE_
		ok

		if NOT (This.IsHashList() and This.NumberOfItems() <= 2)
			return _FALSE_
		ok

		if This.NumberOfItems() = 1

			if This.Item(1)[1] = :Start or This.Item(1)[1] = :Range
				return _TRUE_
			ok
		ok

		if This.NumberOfItems() = 2

			if StzHashListQ( This.List() ).KeysQ().IsEqualTo([ :Start, :Range ]) and
			   StzHashListQ( This.List() ).ValuesQ().BothAreNumbers()

				return _TRUE_

			else

				return _FALSE_
			ok
		ok


	#--

	def IsStartingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartingAtOrStartingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :StartingAtPosition or
			 This.Item(1) = :StartingAt) )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStartingAtPositionOrStartingAtNamedParam()
			return This.IsStartingAtOrStartingAtPositionNamedParam()

	def IsStartingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAts )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStartsAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartsAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsEndAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok



	def IsEndsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndiingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStoppingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsStoppingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStoppingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStopsAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopsAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsendAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsendsAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndsAtOccurrence )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsInStringNNamedParam()
		if This.NumberOfItems() = 2 and

		   ( isString(This.Item(1)) and
		     ring_find([
			:InStringAt,
			:inStringAtPosition,
			:InStringN ], This.Item(1)) > 0 )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsInStringAtPositionNNamedParam()
			return This.IsInStringNNamedParam()

		def IsInStringAtPositionNamedParam()
			return This.IsInStringNNamedParam()

	def IsExceptNamedParam()
		# Used initially by ReplaceWordsWithMarquersExceptXT(pcByOption, paExcept)
		#TODO // generalize to all the functions we want to provide exceptions to it

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Except )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :As )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :Then or This.Item(1) = :Then@) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AndThen or This.Item(1) = :AndThen@) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromFileNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :FromFile

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :From or This.Item(1) = :FromPosition)  )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromOrOfNamedParam()
		if This.IsFromNamedParam() or This.IsOfNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsFromOrOfNamedParams()
			return This.IsFromOrOfNamedParam()

		def IsOfOrFromNamedParam()
			return This.IsFromOrOfNamedParam()

		def IsOfOrFromNamedParams()
			return This.IsFromOrOfNamedParam()

	#--

	def IsFromCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCell )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCellAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCellAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCells )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCellsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCellsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsToCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCell )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCellAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCellAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCells )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCellsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCellsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Value )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfValue )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Values )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringOrSubStringNamedParam()
		if This.IsStringNamedPAram() or This.IsSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsStringOrSubStringNamedParams()
			return This.IsStringOrSubStringNamedParam()

		def IsSubStringOrStringONamedParam()
			return This.IsStringOrSubStringNamedParam()

		def IsSubStringOrStringONamedParams()
			return This.IsStringOrSubStringNamedParam()

	#--

	def IsToOrOfNamedParam()
		if This.IsToNamedParam() or This.IsOfNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsToOrOfNamedParams()
			return This.IsToOrOfNamedParam()

		def IsOfOrToNamedParam()
			return This.IsToOrOfNamedParam()

		def IsOfOrToNamedParams()
			return This.IsToOrOfNamedParam()

	#==

	def IsToNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSubStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsToOrToNumberNamedParam()
		if This.IsToNamedParam() or This.IsToNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToNumberOrToNamedParam()
			return This.IsToOrToNumberNamedParam()

		def IsToOrToNumberNamedParams()
			return This.IsToOrToNumberNamedParam()

		def IsToNumberOrToNamedParams()
			return This.IsToOrToNumberNamedParam()

	def IsToOrToCharNamedParam()
		if This.IsToNamedParam() or This.IsToCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToCharOrToNamedParam()
			return This.IsToOrToCharNamedParam()

		def IsToOrToCharNamedParams()
			return This.IsToOrToCharNamedParam()

		def IsToCharOrToNamedParams()
			return This.IsToOrToCharNamedParam()

	def IsToOrToStringNamedParam()
		if This.IsToNamedParam() or This.IsToStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToStringOrToNamedParam()
			return This.IsToOrToStringNamedParam()

		def IsToOrToStringNamedParams()
			return This.IsToOrToStringNamedParam()

		def IsToStringOrToNamedParams()
			return This.IsToOrToStringNamedParam()

	def IsToOrToSubStringNamedParam()
		if This.IsToNamedParam() or This.IsToSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToSubStringOrToNamedParam()
			return This.IsToOrToSubStringNamedParam()

		def IsToOrToSubStringNamedParams()
			return This.IsToOrToSubStringNamedParam()

		def IsToSubStringOrToNamedParams()
			return This.IsToOrToSubStringNamedParam()

	def IsToOrToListNamedParam()
		if This.IsToNamedParam() or This.IsToListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToListOrToNamedParam()
			return This.IsToOrToListNamedParam()

		def IsToOrToListNamedParams()
			return This.IsToOrToListNamedParam()

		def IsToListOrToNamedParams()
			return This.IsToOrToListNamedParam()

	def IsToOrToHashListNamedParam()
		if This.IsToNamedParam() or This.IsToHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToHashListOrToNamedParam()
			return This.IsToOrToHashListNamedParam()

		def IsToOrToHashListNamedParams()
			return This.IsToOrToHashListNamedParam()

		def IsToHashListOrToNamedParams()
			return This.IsToOrToHashListNamedParam()

	def IsToOrToPairNamedParam()
		if This.IsToNamedParam() or This.IsToPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToPairOrToNamedParam()
			return This.IsToOrToPairNamedParam()

		def IsToOrToPairNamedParams()
			return This.IsToOrToPairNamedParam()

		def IsToPairOrToNamedParams()
			return This.IsToOrToPairNamedParam()

	def IsToOrToSetNamedParam()
		if This.IsToNamedParam() or This.IsToSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToSetOrToNamedParam()
			return This.IsToOrToSetNamedParam()

		def IsToOrToSetNamedParams()
			return This.IsToOrToSetNamedParam()

		def IsToSetOrToNamedParams()
			return This.IsToOrToSetNamedParam()

	def IsToOrToObjectNamedParam()
		if This.IsToNamedParam() or This.IsToObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsToStringOrToObjectParam()
			return This.IsToOrToStringNamedParam()

		def IsToOrToObjectNamedParams()
			return This.IsToOrToObjectNamedParam()

		def IsToStringOrToObjectParams()
			return This.IsToOrToStringNamedParam()

	#==

	def IsOfNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsOfOrOfNumberNamedParam()
		if This.IsOfNamedParam() or This.IsOfNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfNumberOrOfNamedParam()
			return This.IsOfOrOfNumberNamedParam()

		def IsOfOrOfNumberNamedParams()
			return This.IsOfOrOfNumberNamedParam()

		def IsOfNumberOrOfNamedParams()
			return This.IsOfOrOfNumberNamedParam()

	def IsOfOrOfCharNamedParam()
		if This.IsOfNamedParam() or This.IsOfCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfCharOrOfNamedParam()
			return This.IsOfOrOfCharNamedParam()

		def IsOfOrOfCharNamedParams()
			return This.IsOfOrOfCharNamedParam()

		def IsOfCharOrOfNamedParams()
			return This.IsOfOrOfCharNamedParam()

	def IsOfOrOfStringNamedParam()
		if This.IsOfNamedParam() or This.IsOfStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfStringOrOfNamedParam()
			return This.IsOfOrOfStringNamedParam()

		def IsOfOrOfStringNamedParams()
			return This.IsOfOrOfStringNamedParam()

		def IsOfStringOrOfNamedParams()
			return This.IsOfOrOfStringNamedParam()

	def IsOfOrOfSubStringNamedParam()
		if This.IsOfNamedParam() or This.IsOfSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfSubStringOrOfNamedParam()
			return This.IsOfOrOfSubStringNamedParam()

		def IsOfOrOfSubStringNamedParams()
			return This.IsOfOrOfSubStringNamedParam()

		def IsOfSubStringOrOfNamedParams()
			return This.IsOfOrOfSubStringNamedParam()

	def IsOfOrOfListNamedParam()
		if This.IsOfNamedParam() or This.IsOfListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfListOrOfNamedParam()
			return This.IsOfOrOfListNamedParam()

		def IsOfOrOfListNamedParams()
			return This.IsOfOrOfListNamedParam()

		def IsOfListOrOfNamedParams()
			return This.IsOfOrOfListNamedParam()

	def IsOfOrOfHashListNamedParam()
		if This.IsOfNamedParam() or This.IsOfHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfHashListOrOfNamedParam()
			return This.IsOfOrOfHashListNamedParam()

		def IsOfOrOfHashListNamedParams()
			return This.IsOfOrOfHashListNamedParam()

		def IsOfHashListOrOfNamedParams()
			return This.IsOfOrOfHashListNamedParam()

	def IsOfOrOfPairNamedParam()
		if This.IsOfNamedParam() or This.IsOfPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfPairOrOfNamedParam()
			return This.IsOfOrOfPairNamedParam()

		def IsOfOrOfPairNamedParams()
			return This.IsOfOrOfPairNamedParam()

		def IsOfPairOrOfNamedParams()
			return This.IsOfOrOfPairNamedParam()

	def IsOfOrOfSetNamedParam()
		if This.IsOfNamedParam() or This.IsOfSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfSetOrOfNamedParam()
			return This.IsOfOrOfSetNamedParam()

		def IsOfOrOfSetNamedParams()
			return This.IsOfOrOfSetNamedParam()

		def IsOfSetOrOfNamedParams()
			return This.IsOfOrOfSetNamedParam()

	def IsOfOrOfObjectNamedParam()
		if This.IsOfNamedParam() or This.IsOfObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfStringOrOfObjectParam()
			return This.IsOfOrOfStringNamedParam()

		def IsOfOrOfObjectNamedParams()
			return This.IsOfOrOfObjectNamedParam()

		def IsOfStringOrOfObjectParams()
			return This.IsOfOrOfStringNamedParam()

	#==

	def IsByNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBySubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BySubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBySetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BySet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsByOrByNumberNamedParam()
		if This.IsByNamedParam() or This.IsByNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByNumberOrByNamedParam()
			return This.IsByOrByNumberNamedParam()

		def IsByOrByNumberNamedParams()
			return This.IsByOrByNumberNamedParam()

		def IsByNumberOrByNamedParams()
			return This.IsByOrByNumberNamedParam()

	def IsByOrByCharNamedParam()
		if This.IsByNamedParam() or This.IsByCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByCharOrByNamedParam()
			return This.IsByOrByCharNamedParam()

		def IsByOrByCharNamedParams()
			return This.IsByOrByCharNamedParam()

		def IsByCharOrByNamedParams()
			return This.IsByOrByCharNamedParam()

	def IsByOrByStringNamedParam()
		if This.IsByNamedParam() or This.IsByStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByStringOrByNamedParam()
			return This.IsByOrByStringNamedParam()

		def IsByOrByStringNamedParams()
			return This.IsByOrByStringNamedParam()

		def IsByStringOrByNamedParams()
			return This.IsByOrByStringNamedParam()

	def IsByOrBySubStringNamedParam()
		if This.IsByNamedParam() or This.IsBySubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBySubStringOrByNamedParam()
			return This.IsByOrBySubStringNamedParam()

		def IsByOrBySubStringNamedParams()
			return This.IsByOrBySubStringNamedParam()

		def IsBySubStringOrByNamedParams()
			return This.IsByOrBySubStringNamedParam()

	def IsByOrByListNamedParam()
		if This.IsByNamedParam() or This.IsByListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByListOrByNamedParam()
			return This.IsByOrByListNamedParam()

		def IsByOrByListNamedParams()
			return This.IsByOrByListNamedParam()

		def IsByListOrByNamedParams()
			return This.IsByOrByListNamedParam()

	def IsByOrByHashListNamedParam()
		if This.IsByNamedParam() or This.IsByHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByHashListOrByNamedParam()
			return This.IsByOrByHashListNamedParam()

		def IsByOrByHashListNamedParams()
			return This.IsByOrByHashListNamedParam()

		def IsByHashListOrByNamedParams()
			return This.IsByOrByHashListNamedParam()

	def IsByOrByPairNamedParam()
		if This.IsByNamedParam() or This.IsByPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByPairOrByNamedParam()
			return This.IsByOrByPairNamedParam()

		def IsByOrByPairNamedParams()
			return This.IsByOrByPairNamedParam()

		def IsByPairOrByNamedParams()
			return This.IsByOrByPairNamedParam()

	def IsByOrBySetNamedParam()
		if This.IsByNamedParam() or This.IsBySetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBySetOrByNamedParam()
			return This.IsByOrBySetNamedParam()

		def IsByOrBySetNamedParams()
			return This.IsByOrBySetNamedParam()

		def IsBySetOrByNamedParams()
			return This.IsByOrBySetNamedParam()

	def IsByOrByObjectNamedParam()
		if This.IsByNamedParam() or This.IsByObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByStringOrByObjectParam()
			return This.IsByOrByStringNamedParam()

		def IsByOrByObjectNamedParams()
			return This.IsByOrByObjectNamedParam()

		def IsByStringOrByObjectParams()
			return This.IsByOrByStringNamedParam()

	#==

	def IsListOfListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ListOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsGridNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Grid )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTableNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Table )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :HashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Pair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :List )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Object )

			return _TRUE_

		else
			return _FALSE_
		ok

	#==

	def IsInNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsInOrInNumberNamedParam()
		if This.IsInNamedParam() or This.IsInNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInNumberOrInNamedParam()
			return This.IsInOrInNumberNamedParam()

		def IsInOrInNumberNamedParams()
			return This.IsInOrInNumberNamedParam()

		def IsInNumberOrInNamedParams()
			return This.IsInOrInNumberNamedParam()

	def IsInOrInCharNamedParam()
		if This.IsInNamedParam() or This.IsInCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInCharOrInNamedParam()
			return This.IsInOrInCharNamedParam()

		def IsInOrInCharNamedParams()
			return This.IsInOrInCharNamedParam()

		def IsInCharOrInNamedParams()
			return This.IsInOrInCharNamedParam()

	def IsInOrInStringNamedParam()
		if This.IsInNamedParam() or This.IsInStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInStringOrInNamedParam()
			return This.IsInOrInStringNamedParam()

		def IsInOrInStringNamedParams()
			return This.IsInOrInStringNamedParam()

		def IsInStringOrInNamedParams()
			return This.IsInOrInStringNamedParam()

	def IsInOrInSubStringNamedParam()
		if This.IsInNamedParam() or This.IsInSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInSubStringOrInNamedParam()
			return This.IsInOrInSubStringNamedParam()

		def IsInOrInSubStringNamedParams()
			return This.IsInOrInSubStringNamedParam()

		def IsInSubStringOrInNamedParams()
			return This.IsInOrInSubStringNamedParam()

	def IsInOrInListNamedParam()
		if This.IsInNamedParam() or This.IsInListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInListOrInNamedParam()
			return This.IsInOrInListNamedParam()

		def IsInOrInListNamedParams()
			return This.IsInOrInListNamedParam()

		def IsInListOrInNamedParams()
			return This.IsInOrInListNamedParam()

	def IsInOrInHashListNamedParam()
		if This.IsInNamedParam() or This.IsInHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInHashListOrInNamedParam()
			return This.IsInOrInHashListNamedParam()

		def IsInOrInHashListNamedParams()
			return This.IsInOrInHashListNamedParam()

		def IsInHashListOrInNamedParams()
			return This.IsInOrInHashListNamedParam()

	def IsInOrInPairNamedParam()
		if This.IsInNamedParam() or This.IsInPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInPairOrInNamedParam()
			return This.IsInOrInPairNamedParam()

		def IsInOrInPairNamedParams()
			return This.IsInOrInPairNamedParam()

		def IsInPairOrInNamedParams()
			return This.IsInOrInPairNamedParam()

	def IsInOrInSetNamedParam()
		if This.IsInNamedParam() or This.IsInSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInSetOrInNamedParam()
			return This.IsInOrInSetNamedParam()

		def IsInOrInSetNamedParams()
			return This.IsInOrInSetNamedParam()

		def IsInSetOrInNamedParams()
			return This.IsInOrInSetNamedParam()

	def IsInOrInObjectNamedParam()
		if This.IsInNamedParam() or This.IsInObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInObjectOrInNamedParam()
			return This.IsInOrInStringNamedParam()

		def IsInOrInObjectNamedParams()
			return This.IsInOrInObjectNamedParam()

		def IsInObjectOrInNamedParams()
			return This.IsInOrInObjectNamedParam()

	#==

	def IsWithNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsWithOrWithNumberNamedParam()
		if This.IsWithNamedParam() or This.IsWithNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithNumberOrWithNamedParam()
			return This.IsWithOrWithNumberNamedParam()

		def IsWithOrWithNumberNamedParams()
			return This.IsWithOrWithNumberNamedParam()

		def IsWithNumberOrWithNamedParams()
			return This.IsWithOrWithNumberNamedParam()

	def IsWithOrWithCharNamedParam()
		if This.IsWithNamedParam() or This.IsWithCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithCharOrWithNamedParam()
			return This.IsWithOrWithCharNamedParam()

		def IsWithOrWithCharNamedParams()
			return This.IsWithOrWithCharNamedParam()

		def IsWithCharOrWithNamedParams()
			return This.IsWithOrWithCharNamedParam()

	def IsWithOrWithStringNamedParam()
		if This.IsWithNamedParam() or This.IsWithStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithStringOrWithNamedParam()
			return This.IsWithOrWithStringNamedParam()

		def IsWithOrWithStringNamedParams()
			return This.IsWithOrWithStringNamedParam()

		def IsWithStringOrWithNamedParams()
			return This.IsWithOrWithStringNamedParam()

	def IsWithOrWithSubStringNamedParam()
		if This.IsWithNamedParam() or This.IsWithSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithSubStringOrWithNamedParam()
			return This.IsWithOrWithSubStringNamedParam()

		def IsWithOrWithSubStringNamedParams()
			return This.IsWithOrWithSubStringNamedParam()

		def IsWithSubStringOrWithNamedParams()
			return This.IsWithOrWithSubStringNamedParam()

	def IsWithOrWithListNamedParam()
		if This.IsWithNamedParam() or This.IsWithListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithListOrWithNamedParam()
			return This.IsWithOrWithListNamedParam()

		def IsWithOrWithListNamedParams()
			return This.IsWithOrWithListNamedParam()

		def IsWithListOrWithNamedParams()
			return This.IsWithOrWithListNamedParam()

	def IsWithOrWithHashListNamedParam()
		if This.IsWithNamedParam() or This.IsWithHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithHashListOrWithNamedParam()
			return This.IsWithOrWithHashListNamedParam()

		def IsWithOrWithHashListNamedParams()
			return This.IsWithOrWithHashListNamedParam()

		def IsWithHashListOrWithNamedParams()
			return This.IsWithOrWithHashListNamedParam()

	def IsWithOrWithPairNamedParam()
		if This.IsWithNamedParam() or This.IsWithPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithPairOrWithNamedParam()
			return This.IsWithOrWithPairNamedParam()

		def IsWithOrWithPairNamedParams()
			return This.IsWithOrWithPairNamedParam()

		def IsWithPairOrWithNamedParams()
			return This.IsWithOrWithPairNamedParam()

	def IsWithOrWithSetNamedParam()
		if This.IsWithNamedParam() or This.IsWithSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithSetOrWithNamedParam()
			return This.IsWithOrWithSetNamedParam()

		def IsWithOrWithSetNamedParams()
			return This.IsWithOrWithSetNamedParam()

		def IsWithSetOrWithNamedParams()
			return This.IsWithOrWithSetNamedParam()

	def IsWithOrWithObjectNamedParam()
		if This.IsWithNamedParam() or This.IsWithObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithObjectOrWithNamedParam()
			return This.IsWithOrWithObjectNamedParam()

		def IsWithOrWithObjectNamedParams()
			return This.IsWithOrWithObjectNamedParam()

		def IsWithObjectOrWithNamedParams()
			return This.IsWithOrWithObjectNamedParam()

	#==

	def IsInsideNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsidePairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsidePair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInsideObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsInsideOrInsideNumberNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideNumberOrInsideNamedParam()
			return This.IsInsideOrInsideNumberNamedParam()

		def IsInsideOrInsideNumberNamedParams()
			return This.IsInsideOrInsideNumberNamedParam()

		def IsInsideNumberOrInsideNamedParams()
			return This.IsInsideOrInsideNumberNamedParam()

	def IsInsideOrInsideCharNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideCharOrInsideNamedParam()
			return This.IsInsideOrInsideCharNamedParam()

		def IsInsideOrInsideCharNamedParams()
			return This.IsInsideOrInsideCharNamedParam()

		def IsInsideCharOrInsideNamedParams()
			return This.IsInsideOrInsideCharNamedParam()

	def IsInsideOrInsideStringNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideStringOrInsideNamedParam()
			return This.IsInsideOrInsideStringNamedParam()

		def IsInsideOrInsideStringNamedParams()
			return This.IsInsideOrInsideStringNamedParam()

		def IsInsideStringOrInsideNamedParams()
			return This.IsInsideOrInsideStringNamedParam()

	def IsInsideOrInsideSubStringNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideSubStringOrInsideNamedParam()
			return This.IsInsideOrInsideSubStringNamedParam()

		def IsInsideOrInsideSubStringNamedParams()
			return This.IsInsideOrInsideSubStringNamedParam()

		def IsInsideSubStringOrInsideNamedParams()
			return This.IsInsideOrInsideSubStringNamedParam()

	def IsInsideOrInsideListNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideListOrInsideNamedParam()
			return This.IsInsideOrInsideListNamedParam()

		def IsInsideOrInsideListNamedParams()
			return This.IsInsideOrInsideListNamedParam()

		def IsInsideListOrInsideNamedParams()
			return This.IsInsideOrInsideListNamedParam()

	def IsInsideOrInsideHashListNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideHashListOrInsideNamedParam()
			return This.IsInsideOrInsideHashListNamedParam()

		def IsInsideOrInsideHashListNamedParams()
			return This.IsInsideOrInsideHashListNamedParam()

		def IsInsideHashListOrInsideNamedParams()
			return This.IsInsideOrInsideHashListNamedParam()

	def IsInsideOrInsidePairNamedParam()
		if This.IsInsideNamedParam() or This.IsInsidePairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsidePairOrInsideNamedParam()
			return This.IsInsideOrInsidePairNamedParam()

		def IsInsideOrInsidePairNamedParams()
			return This.IsInsideOrInsidePairNamedParam()

		def IsInsidePairOrInsideNamedParams()
			return This.IsInsideOrInsidePairNamedParam()

	def IsInsideOrInsideSetNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideSetOrInsideNamedParam()
			return This.IsInsideOrInsideSetNamedParam()

		def IsInsideOrInsideSetNamedParams()
			return This.IsInsideOrInsideSetNamedParam()

		def IsInsideSetOrInsideNamedParams()
			return This.IsInsideOrInsideSetNamedParam()

	def IsInsideOrInsideObjectNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsInsideObjectOrInsideNamedParam()
			return This.IsInsideOrInsideObjectNamedParam()

		def IsInsideOrInsideObjectNamedParams()
			return This.IsInsideOrInsideObjectNamedParam()

		def IsInsideObjectOrInsideNamedParams()
			return This.IsInsideOrInsideObjectNamedParam()

	#==

	def IsOnNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsOnOrOnNumberNamedParam()
		if This.IsOnNamedParam() or This.IsOnNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnNumberOrOnNamedParam()
			return This.IsOnOrOnNumberNamedParam()

		def IsOnOrOnNumberNamedParams()
			return This.IsOnOrOnNumberNamedParam()

		def IsOnNumberOrOnNamedParams()
			return This.IsOnOrOnNumberNamedParam()

	def IsOnOrOnCharNamedParam()
		if This.IsOnNamedParam() or This.IsOnCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnCharOrOnNamedParam()
			return This.IsOnOrOnCharNamedParam()

		def IsOnOrOnCharNamedParams()
			return This.IsOnOrOnCharNamedParam()

		def IsOnCharOrOnNamedParams()
			return This.IsOnOrOnCharNamedParam()

	def IsOnOrOnStringNamedParam()
		if This.IsOnNamedParam() or This.IsOnStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnStringOrOnNamedParam()
			return This.IsOnOrOnStringNamedParam()

		def IsOnOrOnStringNamedParams()
			return This.IsOnOrOnStringNamedParam()

		def IsOnStringOrOnNamedParams()
			return This.IsOnOrOnStringNamedParam()

	def IsOnOrOnSubStringNamedParam()
		if This.IsOnNamedParam() or This.IsOnSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnSubStringOrOnNamedParam()
			return This.IsOnOrOnSubStringNamedParam()

		def IsOnOrOnSubStringNamedParams()
			return This.IsOnOrOnSubStringNamedParam()

		def IsOnSubStringOrOnNamedParams()
			return This.IsOnOrOnSubStringNamedParam()

	def IsOnOrOnListNamedParam()
		if This.IsOnNamedParam() or This.IsOnListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnListOrOnNamedParam()
			return This.IsOnOrOnListNamedParam()

		def IsOnOrOnListNamedParams()
			return This.IsOnOrOnListNamedParam()

		def IsOnListOrOnNamedParams()
			return This.IsOnOrOnListNamedParam()

	def IsOnOrOnHashListNamedParam()
		if This.IsOnNamedParam() or This.IsOnHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnHashListOrOnNamedParam()
			return This.IsOnOrOnHashListNamedParam()

		def IsOnOrOnHashListNamedParams()
			return This.IsOnOrOnHashListNamedParam()

		def IsOnHashListOrOnNamedParams()
			return This.IsOnOrOnHashListNamedParam()

	def IsOnOrOnPairNamedParam()
		if This.IsOnNamedParam() or This.IsOnPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnPairOrOnNamedParam()
			return This.IsOnOrOnPairNamedParam()

		def IsOnOrOnPairNamedParams()
			return This.IsOnOrOnPairNamedParam()

		def IsOnPairOrOnNamedParams()
			return This.IsOnOrOnPairNamedParam()

	def IsOnOrOnSetNamedParam()
		if This.IsOnNamedParam() or This.IsOnSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnSetOrOnNamedParam()
			return This.IsOnOrOnSetNamedParam()

		def IsOnOrOnSetNamedParams()
			return This.IsOnOrOnSetNamedParam()

		def IsOnSetOrOnNamedParams()
			return This.IsOnOrOnSetNamedParam()

	def IsOnOrOnObjectNamedParam()
		if This.IsOnNamedParam() or This.IsOnObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOnObjectOrOnNamedParam()
			return This.IsOnOrOnObjectNamedParam()

		def IsOnOrOnObjectNamedParams()
			return This.IsOnOrOnObjectNamedParam()

		def IsOnObjectOrOnNamedParams()
			return This.IsOnOrOnObjectNamedParam()

	#==

	def IsOverNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOverObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsOverOrOverNumberNamedParam()
		if This.IsOverNamedParam() or This.IsOverNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverNumberOrOverNamedParam()
			return This.IsOverOrOverNumberNamedParam()

		def IsOverOrOverNumberNamedParams()
			return This.IsOverOrOverNumberNamedParam()

		def IsOverNumberOrOverNamedParams()
			return This.IsOverOrOverNumberNamedParam()

	def IsOverOrOverCharNamedParam()
		if This.IsOverNamedParam() or This.IsOverCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverCharOrOverNamedParam()
			return This.IsOverOrOverCharNamedParam()

		def IsOverOrOverCharNamedParams()
			return This.IsOverOrOverCharNamedParam()

		def IsOverCharOrOverNamedParams()
			return This.IsOverOrOverCharNamedParam()

	def IsOverOrOverStringNamedParam()
		if This.IsOverNamedParam() or This.IsOverStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverStringOrOverNamedParam()
			return This.IsOverOrOverStringNamedParam()

		def IsOverOrOverStringNamedParams()
			return This.IsOverOrOverStringNamedParam()

		def IsOverStringOrOverNamedParams()
			return This.IsOverOrOverStringNamedParam()

	def IsOverOrOverSubStringNamedParam()
		if This.IsOverNamedParam() or This.IsOverSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverSubStringOrOverNamedParam()
			return This.IsOverOrOverSubStringNamedParam()

		def IsOverOrOverSubStringNamedParams()
			return This.IsOverOrOverSubStringNamedParam()

		def IsOverSubStringOrOverNamedParams()
			return This.IsOverOrOverSubStringNamedParam()

	def IsOverOrOverListNamedParam()
		if This.IsOverNamedParam() or This.IsOverListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverListOrOverNamedParam()
			return This.IsOverOrOverListNamedParam()

		def IsOverOrOverListNamedParams()
			return This.IsOverOrOverListNamedParam()

		def IsOverListOrOverNamedParams()
			return This.IsOverOrOverListNamedParam()

	def IsOverOrOverHashListNamedParam()
		if This.IsOverNamedParam() or This.IsOverHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverHashListOrOverNamedParam()
			return This.IsOverOrOverHashListNamedParam()

		def IsOverOrOverHashListNamedParams()
			return This.IsOverOrOverHashListNamedParam()

		def IsOverHashListOrOverNamedParams()
			return This.IsOverOrOverHashListNamedParam()

	def IsOverOrOverPairNamedParam()
		if This.IsOverNamedParam() or This.IsOverPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverPairOrOverNamedParam()
			return This.IsOverOrOverPairNamedParam()

		def IsOverOrOverPairNamedParams()
			return This.IsOverOrOverPairNamedParam()

		def IsOverPairOrOverNamedParams()
			return This.IsOverOrOverPairNamedParam()

	def IsOverOrOverSetNamedParam()
		if This.IsOverNamedParam() or This.IsOverSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverSetOrOverNamedParam()
			return This.IsOverOrOverSetNamedParam()

		def IsOverOrOverSetNamedParams()
			return This.IsOverOrOverSetNamedParam()

		def IsOverSetOrOverNamedParams()
			return This.IsOverOrOverSetNamedParam()

	def IsOverOrOverObjectNamedParam()
		if This.IsOverNamedParam() or This.IsOverObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOverObjectOrOverNamedParam()
			return This.IsOverOrOverObjectNamedParam()

		def IsOverOrOverObjectNamedParams()
			return This.IsOverOrOverObjectNamedParam()

		def IsOverObjectOrOverNamedParams()
			return This.IsOverOrOverObjectNamedParam()

	#==

	def IsAgainstNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverHashList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSet )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAgainstObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAgainstOrAgainstNumberNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstNumberNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstNumberOrAgainstNamedParam()
			return This.IsAgainstOrAgainstNumberNamedParam()

		def IsAgainstOrAgainstNumberNamedParams()
			return This.IsAgainstOrAgainstNumberNamedParam()

		def IsAgainstNumberOrAgainstNamedParams()
			return This.IsAgainstOrAgainstNumberNamedParam()

	def IsAgainstOrAgainstCharNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstCharNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstCharOrAgainstNamedParam()
			return This.IsAgainstOrAgainstCharNamedParam()

		def IsAgainstOrAgainstCharNamedParams()
			return This.IsAgainstOrAgainstCharNamedParam()

		def IsAgainstCharOrAgainstNamedParams()
			return This.IsAgainstOrAgainstCharNamedParam()

	def IsAgainstOrAgainstStringNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstStringOrAgainstNamedParam()
			return This.IsAgainstOrAgainstStringNamedParam()

		def IsAgainstOrAgainstStringNamedParams()
			return This.IsAgainstOrAgainstStringNamedParam()

		def IsAgainstStringOrAgainstNamedParams()
			return This.IsAgainstOrAgainstStringNamedParam()

	def IsAgainstOrAgainstSubStringNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstSubStringOrAgainstNamedParam()
			return This.IsAgainstOrAgainstSubStringNamedParam()

		def IsAgainstOrAgainstSubStringNamedParams()
			return This.IsAgainstOrAgainstSubStringNamedParam()

		def IsAgainstSubStringOrAgainstNamedParams()
			return This.IsAgainstOrAgainstSubStringNamedParam()

	def IsAgainstOrAgainstListNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstListOrAgainstNamedParam()
			return This.IsAgainstOrAgainstListNamedParam()

		def IsAgainstOrAgainstListNamedParams()
			return This.IsAgainstOrAgainstListNamedParam()

		def IsAgainstListOrAgainstNamedParams()
			return This.IsAgainstOrAgainstListNamedParam()

	def IsAgainstOrAgainstHashListNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstHashListNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstHashListOrAgainstNamedParam()
			return This.IsAgainstOrAgainstHashListNamedParam()

		def IsAgainstOrAgainstHashListNamedParams()
			return This.IsAgainstOrAgainstHashListNamedParam()

		def IsAgainstHashListOrAgainstNamedParams()
			return This.IsAgainstOrAgainstHashListNamedParam()

	def IsAgainstOrAgainstPairNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstPairNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstPairOrAgainstNamedParam()
			return This.IsAgainstOrAgainstPairNamedParam()

		def IsAgainstOrAgainstPairNamedParams()
			return This.IsAgainstOrAgainstPairNamedParam()

		def IsAgainstPairOrAgainstNamedParams()
			return This.IsAgainstOrAgainstPairNamedParam()

	def IsAgainstOrAgainstSetNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstSetNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstSetOrAgainstNamedParam()
			return This.IsAgainstOrAgainstSetNamedParam()

		def IsAgainstOrAgainstSetNamedParams()
			return This.IsAgainstOrAgainstSetNamedParam()

		def IsAgainstSetOrAgainstNamedParams()
			return This.IsAgainstOrAgainstSetNamedParam()

	def IsAgainstOrAgainstObjectNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstObjectNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAgainstObjectOrAgainstNamedParam()
			return This.IsAgainstOrAgainstObjectNamedParam()

		def IsAgainstOrAgainstObjectNamedParams()
			return This.IsAgainstOrAgainstObjectNamedParam()

		def IsAgainstObjectOrAgainstNamedParams()
			return This.IsAgainstOrAgainstObjectNamedParam()

	#==

	def IsRespectivelyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Respectively )

			return _TRUE_

		else
			return _FALSE_
		ok

	#==

	def IsSeedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Seed )

			return _TRUE_

		else
			return _FALSE_
		ok
	
	#==

	def IsEqualToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EqualTo )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEqualsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Equals )

			return _TRUE_

		else
			return _FALSE_
		ok

	#==

	def IsToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :To )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToTheseNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToThis )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToManyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToMany )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPositionOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOf )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToOrToPositionNamedParam()

		if This.IsToNamedParam() or This.IsToPositionNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsToOrToPositionNamedParams()
			return This.IsToOrToPositionNamedParam()

		def IsToPositionOrToNamedParam()
			return This.IsToOrToPositionNamedParam()

		def IsToPositionOrToNamedParams()
			return This.IsToOrToPositionNamedParam()

		#>

	def IsToPositionOfItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPositionOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPositionOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsFromPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromOrFromPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :FromPosition or This.Item(1) = :From)  )

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsFromOrFromPositionNamedParams()
			return This.IsFromOrFromPositionNamedParam()

		def IsFromPositionOrFromNamedParam()
			return This.IsFromOrFromPositionNamedParam()

		def IsFromPositionOrFromNamedParams()
			return This.IsFromOrFromPositionNamedParam()

		#>

	def IsFromPositionOfItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromPositionOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromPositionOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Of )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :On )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :In )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InA )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsInSideNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :InSide or This.Item(1) = :Inside@) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInSideANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and 
			(This.Item(1) = :InSideA or This.Item(1) = :InsideA@) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInOrInsideNamedParam()
		if This.IsInNamedParam() or This.IsInsideNamedParam()
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsInOrInsideNamedParams()
			return This.IsInOrInsideNamedParam()

		def IsInsideOrInNamedParam()
			return This.IsInOrInsideNamedParam()

		def IsInsideOrInNamedParams()
			return This.IsInOrInsideNamedParam()

	def IsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Where ) and
		   isString( This.Item(2) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WhereXT ) and
		   isString( This.Item(2) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :That ) and
		   isString( This.Item(2) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThatOrWhereNamedParam()
		if This.IsThatNamedParam() or This.IsWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsThatOrWhereNamedParams()
			return This.IsThatOrWhereNamedParam()

		def IsWhereOrThatNamedParam()
			return This.IsThatOrWhereNamedParam()

		def IsWhereOrThatNamedParams()
			return This.IsThatOrWhereNamedParam()

	def IsThatXTOrWhereXTNamedParam()
		if This.IsThatXTNamedParam() or This.IsWhereXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsThatXTOrWhereXTNamedParams()
			return This.IsThatXTOrWhereXTNamedParam()

		def IsWhereXTOrThatXTNamedParam()
			return This.IsThatXTOrWhereXTNamedParam()

		def IsWherextOrThatxtNamedParams()
			return This.IsThatXTOrWhereXTNamedParam()

	def IsPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Position )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :PositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Positions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :PositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThesePositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThesePositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThesePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThesePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPositionOrPositionsNamedParam()
		if This.IsPositionNamedParam() or This.IsPositionsNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsPositionOrPositionsNamedParams()
			return This.IsPositionOrPositionsNamedParam()

	def IsPositionIBOrPositionsibNamedParam()
		if This.IsPositionIBNamedParam() or This.IsPositionsIBNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsPositionIBOrPositionsIBNamedParams()
			return This.IsPositionIBOrPositionsIBNamedParam()

	def IsAlongWithNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AlongWith or This.Item(1) = :AlongWith@)  )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAlongWithTheirNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AlongWithTheir or This.Item(1) = :AlongWithTheir@)  )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOrOrAndNamedParam()
		if This.IsOrNamedParam() or This.AndNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAndOrOrNamedParam()
			return This.IsOrOrAndNamedParam()

	def IsAndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :And or This.Item(1) = :And@)  )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndTheirNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AndTheir or This.Item(1) = :AndTheir@)  )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsOrNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Or )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOrANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrA )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOrAnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrAn )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsNorNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Nor )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWhileNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :While )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNotNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Not )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIfNamedParam()
		if This.NumberOfItems() = 2 and
		   This.Item(1) = :If and
		   isString(This.Item(2))

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIfOrWhereNamedParam()
		return This.IsIfNamedParam() or This.IsWhereNamedParam()

		def IsWhereOrIfNamedParam()
			return This.IsIfOrWhereNamedParam()

		def IsWhereOrIfNamedParams()
			return This.IsIfOrWhereNamedParam()

		def IsIfOrWhereNamedParams()
			return This.IsIfOrWhereNamedParam()

	def IsIfXTOrWhereXTNamedParam()
		return This.IsIfXTNamedParam() or This.IsWhereXTNamedParam()

		def IsWhereXTOrIfXTNamedParam()
			return This.IsIfXTOrWhereXTNamedParam()

		def IsWhereXTOrIfXTNamedParams()
			return This.IsIfXTOrWhereXTNamedParam()

		def IsIfXTOrWhereXTNamedParams()
			return This.IsIfXTOrWhereXTNamedParam()

	def IsWithNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :With or This.Item(1) = :With@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithMany or This.Item(1) = :WithMany@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithOrAndNamedParam()
		if This.IsWithNamedParam() or This.IsAndNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithOrAndNamedParams()
			return This.IsWithOrAndNamedParam()

		def IsAndOrWithNamedParam()
			return This.IsWithOrAndNamedParam()

		def IsAndOrWithNamedParams()
			return This.IsWithOrAndNamedParam()

	def IsWithItemsInNamedParam() 
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :By or This.Item(1) = :By@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithCharsInNamedParam() 
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithCharsIn or This.Item(1) = :WithCharsIn@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	#==

	def IsUsingItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingThisItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisItem)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingItems)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseItems)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsUsingStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingThisStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsUsingSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingSubString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisSubString)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingSubStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsUsingTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseSubStrings)

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsByItemsInNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByItemsIn or This.Item(1) = :ByItemsIn@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingItemsInNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingItemsIn or This.Item(1) = :UsingItemsIn@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithTheirNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithTheir or This.Item(1) = :WithTheir@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :By or This.Item(1) = :By@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByMany or This.Item(1) = :ByMany@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByManyXT or This.Item(1) = :ByManyXT@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingManyXT or This.Item(1) = :UsingManyXT@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithManyXT or This.Item(1) = :WithManyXT@ ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsByOrUsingNamedParam()
		if This.IsByNamedParam() or This.IsUsingNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsByOrUsingNamedParams()
			return This.IsByOrUsingNamedParam()

		def IsUsingOrByNamedParam()
			return This.IsByOrUsingNamedParam()

		def IsUsingOrByNamedParams()
			return This.IsByOrUsingNamedParam()

	#--

	def IsByManyOrWithManyOrUsingManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and

			( This.Item(1) = :ByMany or This.Item(1) = :UsingMany or
			This.Item(1) = :WithMany ) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok


		#--

		def IsByManyOrUsingManyOrWithManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrByManyOrUsingManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrUsingManyOrByManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrByManyOrWithManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrWithManyOrByManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

		#-- ...Param(s) with s

		def IsByManyOrWithManyOrUsingManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

		def IsByManyOrUsingManyOrWithManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrByManyOrUsingManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrUsingManyOrByManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrByManyOrWithManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrWithManyOrByManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

	#--

	def IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
		if This.IsByManyXTNamedParam() or
		   This.IsWithXTNamedParam() or
		   This.IsUsingXTNamedParam()

			return _TRUE_
		else
			return _FALSE_
		ok

		#--

		def IsByManyXTOrUsingManyXTOrWithManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrByManyXTOrUsingManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrUsingManyXTOrByManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrByManyXTOrWithManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrWithManyXTOrByManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

		#-- ...Param(s) with s

		def IsByManyXTOrWithManyXTOrUsingManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

		def IsByManyXTOrUsingManyXTOrWithManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrByManyXTOrUsingManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrUsingManyXTOrByManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrByManyXTOrWithManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrWithManyXTOrByManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

	#==

	def IsByColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :ByCol, :ByCol@ ], This.Item(1)) > 0 )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :ByColumn, :ByColumn@ ], This.Item(1)) > 0 )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :UsingCol, :UsingCol@ ], This.Item(1)) > 0 )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :UsingColumn, :UsingColumn@ ], This.Item(1)) > 0 )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :WithCol, :WithCol@ ], This.Item(1)) > 0 )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
		     ring_find([ :WithColumn, :WithColumn@ ], This.Item(1)) > 0 )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByRow )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithRow )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UsingRow )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsByCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByCell )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithCell )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UsingCell )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithOrByNamedParam()
		return This.IsWithNamedParam() OR This.IsByNamedParam()

		def IsByOrWithNamedParam()
			return This.IsWithOrByNamedParam()

		def IsByOrWithNamedParams()
			return This.IsWithOrByNamedParam()

		def IsWithOrByNamedParams()
			return This.IsWithOrByNamedParam()

	def IsUsingNamedParam()
		if len(This.Content()) = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :Using or This.Item(1) = :Using@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUsingManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingMany or This.Item(1) = :UsingMany@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :At
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtIBNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AtIB
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtOrUsingNamedParam()
		if This.IsAtNamedParam() or This.IsUsingNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingOrAtNamedParam()
			return This.IsAtOrUsingNamedParam()

		def IsUsingOrAtNamedParams()
			return This.IsAtOrUsingNamedParam()

		def IsAtOrUsingNamedParams()
			return This.IsAtOrUsingNamedParam()

	#--

	def IsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisPositionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThesePositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThesePositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThesePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThesePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyPositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtOrAtPositionNamedParam()
		if This.IsAtNamedParam() or
		   This.IsAtPositionNamedParam()

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsAtPositionOrAtNamedParam()
			return This.IsAtOrAtPositionNamedParam()

		def IsAtPositionOrAtNamedParams()
			return This.IsAtOrAtPositionNamedParam()

		def IsAtOrAtPositionNamedParams()
			return This.IsAtOrAtPositionNamedParam()

	def IsAtOrAtPositionsNamedParam()
		if This.IsAtNamedParam() or
		   This.IsAtPositionsNamedParam()

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsAtPositionsOrAtNamedParam()
			return This.IsAtOrAtPositionsNamedParam()

		def IsAtPositionsOrAtNamedParams()
			return This.IsAtOrAtPositionsNamedParam()

		def IsAtOrAtPositionsNamedParams()
			return This.IsAtOrAtPositionsNamedParam()

	#==

	def IsAtItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtSubStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtOrAtSubStringNamedParam()
		if This.IsAtNamedParam() or This.IsAtSubStringNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IfAtSubStringOrAtNamedParam()
			return This.IsAtOrAtSubStringNamedParam()

		def IsAtOrAtSubStringNamedParams()
			return This.IsAtOrAtSubStringNamedParam()

		def IfAtSubStringOrAtNamedParams()
			return This.IsAtOrAtSubStringNamedParam()

	def IsAtThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSubString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSubStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManySubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySubStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManySubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtCharNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisCharNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsBeforePositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforePositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeThisPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeThisPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeManyPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeManyPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeThesePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeThesePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeThisSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeThisSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeTheseSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeTheseSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeThisItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeThisItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeTheseItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeTheseItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

#--

	def IsAfterPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterThisPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterThisPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterThesePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterThesePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterThisSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterThisSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterTheseSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterTheseSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterThisItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterThisItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterTheseItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterTheseItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundThisPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundThisPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundThesePositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundThesePositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundThisSubStringIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundThisSubStringIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundTheseSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundTheseSubStringsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundThisItemIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundThisItemIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundTheseItemsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundtheseItemsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtCharsNamedParam()
		if This.NumberOfItems() = 2 and
		    isString(This.Item(1)) and  This.Item(1) = :AtChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtTheseChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtManyChars

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtNumber

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtThisNumber

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtNumbers

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtTheseNumbers

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtManyNumbers

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtList

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :AtThisList

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtSubListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisSubListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSubList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManySubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtPairNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisPairNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisPair )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThesePairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThesePairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfSubLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfPairs )

			return _TRUE_

		else
			return _FALSE_
		ok
	def IsAtListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfPairs )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfHashLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfHashLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfHashLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfHashLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfHashLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtObjectNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisObjectNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtSectionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSection )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSectionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisSectionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSection )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSectionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManySectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManySectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListOfSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	#TODO // Reorganise them near to IsBeforeSectionNamedParam()

	def IsBeforeSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeSectionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :BeforeSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	#TODO // Reorganise them near to IsBeforeSectionNamedParam()

	def IsAfterSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterSectionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AfterSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAroundSectionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSection )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSectionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSections )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AroundSectionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtRangeNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtRange )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisRangeNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisRange )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAtListOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtThisListOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtTheseListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfRanges )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtManyListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfRanges )

			return _TRUE_

		else
			return _FALSE_
		ok


	#==

	def IsUsingOrAtOrWhereNamedParam()
		# Use IsOneOfTheseNamedParams([ ..., ..., ... ]) instead

		if This.IsUsingNamedParam() or
		   This.IsAtNamedParam() or
		   This.IsWhereNamedParam()

			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsUsingOrWhereOrAtNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
		
		def IsAtOrUsingOrWhereNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsAtOrWhereOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsWhereOrAtOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsWhereOrUsingOrAtNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()

		#--

		def IsUsingOrWhereOrAtNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
		
		def IsAtOrUsingOrWhereNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsAtOrWhereOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsWhereOrAtOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsWhereOrUsingOrAtNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsUsingOrAtOrWhereNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()

		#>

	def IsUsingOrAtOrWhereXTNamedParam()
		# Use IsOneOfTheseNamedParams([ ..., ..., ... ]) instead

		if This.IsUsingNamedParam() or
		   This.IsAtNamedParam() or
		   This.IsWhereXTNamedParam()

			return _TRUE_
		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsUsingOrWhereXTOrAtNamedParam()
			return This.IsUsingOrAtOrWhereXTNamedParam()
		
		def IsAtOrUsingOrWhereXTNamedParam()
			return This.IsUsingOrAtOrWhereXTNamedParam()
	
		def IsAtOrWhereXTOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereXTNamedParam()

		def IsWhereXTOrAtOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereXTNamedParam()
	
		def IsWhereXTOrUsingOrAtNamedParam()
			return This.IsUsingOrAtOrWhereXTNamedParam()

		#--

		def IsUsingOrWhereXTOrAtNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()
		
		def IsAtOrUsingOrWhereXTNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()
	
		def IsAtOrWhereXTOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()

		def IsWhereXTOrAtOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()
	
		def IsWhereXTOrUsingOrAtNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()

		def IsUsingOrAtOrWhereXTNamedParams()
			return This.IsUsingOrAtOrWhereXTNamedParam()

		#>
	#==

	def IsStepNamedParam()

		if This.NumberOfItems() = 2 and

		   isString(This.Item(1)) and
		   This.Item(1) = :Step
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNameNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Name ) and
		   isString(This.Item(2))
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Named ) and
		   isString(This.Item(2))
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNamedAsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NamedAs ) and
		   isString(This.Item(2))
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsRaiseNamedParam()
		if This.NumberOfItems() <= 4 and
		   This.IsHashList() and
		   This.ToStzHashList().KeysQ().IsMadeOfSome([ :Where, :What, :Why, :Todo ]) and
		   This.ToStzHashList().ValuesQ().CheckWXT("isString(@item) and @item != _NULL_")

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnedAsNamedParam()

		if This.NumberOfItems() = 2 and This.Item(1) = :ReturnedAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnedAsNamedParam()

		if This.NumberOfItems() = 2 and This.Item(1) = :AndReturnedAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :Return

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnItAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnItAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnItAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnItAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnThemAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnThemAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnThemAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnThemAs

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturningNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:Returning, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturn, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturningNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturning, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturnNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:ReturnNth, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsReturningNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:ReturningNth, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturnNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturnNth, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndReturningNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturningNth, _FALSE_)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToNCharsNamedParam()
		if This.NumberOfItems() = 2 and
 		   isString(This.Item(1)) and  This.Item(1) = :UpToNChars
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToNItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
 		   ( isString(This.Item(1)) and  This.Item(1) = :UpToNItems )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToOrUpToNItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
 		   ( isString(This.Item(1)) and
			(This.Item(1) = :UpToNItems or This.Item(1) = :UpTo) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsUpToOrUpToNItemsNamedParams()
			return This.IsUpToOrUoToNItemsNamedParam()

		def IsUpToNItemsOrUpToNamedParam()
			return This.IsUpToOrUoToNItemsNamedParam()

		def IsUpToNItemsOrUpToNamedParams()
			return This.IsUpToOrUoToNItemsNamedParam()

	def IsUpToOrUpToNPositionsNamedParam()
		if ( This.NumberOfPositions() = 2 ) and
 		   ( isString(This.Position(1)) and
			(This.Position(1) = :UpToNPositions or This.Position(1) = :UpTo) )
		  
			return _TRUE_

		else
			return _FALSE_
		ok

		def IsUpToOrUpToNPositionsNamedParams()
			return This.IsUpToOrUoToNPositionsNamedParam()

		def IsUpToNPositionsOrUpToNamedParam()
			return This.IsUpToOrUoToNPositionsNamedParam()

		def IsUpToNPositionsOrUpToNamedParams()
			return This.IsUpToOrUoToNPositionsNamedParam()

	def IsBeforeNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :Before )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeItem )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThisItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisItem )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeTheseItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBeforePositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforePosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThisPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforePositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeManyPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeManyPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThesePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThesePositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBeforeSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThisSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeTheseSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThisSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSubStringPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeTheseSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSubStringsPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsAfterSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThisSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterTheseSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStringPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThisSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSubStringPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStringsPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterTheseSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSubStringsPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBeforeSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeThisSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeTheseSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsAfterSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThisSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterTheseSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBeforeOrAtNamedParam()
		if This.IsBeforeNamedParam() or This.IsAtNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAtOrBeforeNamedParam()
			return This.IsBeforeOrAtNamedParam()

	def IsAfterNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :After )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThese )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterMany )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterItem )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThisItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisItem )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterTheseItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThisPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterPositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterThesePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThesePositions )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAfterOrAtNamedParam()
		if This.IsAfterNamedParam() or This.IsAtNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAtOrAfterNamedParam()
			return This.IsAfterOrAtNamedParam()

	def IsBeforeOrAfterNamedParam()
		if This.IsBeforeNamedPAram() or This.IsAfterNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAfterOrBeforeNamedParam()
			return This.IsBeforeOrAfterNamedParam()

	def IsWidthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Width )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWithOrUsingNamedParam()
		if This.IsWithNamedParam() or This.IsUsingNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsWithOrUsingNamedParams()
			return This.IsWithOrUsingNamedParam()

		def IsUsingOrWithNamedParam()
			return This.IsWithOrUsingNamedParam()

		def IsUsingOrWithNamedParams()
			return This.IsWithOrUsingNamedParam()

	def IsMadeOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :MadeOf )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthTofirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirst )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthToFirstCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirstChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthToFirstItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirstItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthToLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLast )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthToLastCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLastChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNthToLastItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLastItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :String )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisString )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Number )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisNumber )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Numbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Char )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Chars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsThisItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisList )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisObject )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Item )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Items )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Items )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Strings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSubStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsThisSubStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisSubStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSubStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseSubStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseSubStringsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSubStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSubStringsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Between )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenXT )

			return _TRUE_

		else
			return _FALSE_
		ok	

	def IsBetweenIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenIBSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenIBS )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenS )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCS )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenPositionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPositionIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPositionsIB )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsBetweenRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRow )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRows )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenRowsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsBetweenColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCol )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumn )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	def IsBetweenColAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColAt )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnAtNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnAt )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	def IsBetweenColAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnAtPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnAtPosition )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok
	
	def IsBetweenColsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnsAtPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAtPosition )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	def IsBetweenColsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnsAtPositionsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAtPositions )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	def IsBetweenColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCols )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumns )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	def IsBetweenColsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsBetweenColumnsAtNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAt )
	
				return _TRUE_
	
			else
				return _FALSE_
			ok

	#--

	def IsFromPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsItemFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsItemsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok


	def IsBetweenItemNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItem )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromItemPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsStringFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenString )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsCharFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsFromPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCharPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenChar )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFirstPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FirstPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsLastPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :LastPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Strings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :theseStringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsTheseStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStringsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAndColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndCol )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumn )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColat )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColumnAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColumnAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColNamed )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndColumnNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnNamed )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Cols )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColumnsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Columns )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColumnsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColumnsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsColumnsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColumnsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAndRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRow )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndRowAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRowAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndRowAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRowAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsRowsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsRowsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsRowsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAtPositions )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :This )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndThis )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndThat )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsEvalNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Eval )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEvaluateNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Evaluate )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEvalFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvalFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEvaluateFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvaluateFrom )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEvalDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvalDirection )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEvaluationDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvaluationDirection )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOrThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrThis )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOrThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrThat )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSubstringOrSubstringsNamedParam()
		if This.IsSubStringNamedParam() or
		   This.IsSubStringsNamedParam()

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsSubStringsOrSubStringNamedParam()
			return This.IsSubstringOrSubstringsNamedParam()

		#--

		def IsSubstringOrSubstringsNamedParams()
			return This.IsSubstringOrSubstringsNamedParam()

		def IsSubStringsOrSubStringNamedParams()
			return This.IsSubstringOrSubstringsNamedParam()


	def IsThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThisSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBetweenSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BetweenSubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedBySubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBySubString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseSubStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAndSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBetweenSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BetweenSubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBetweenSubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BetweenSubStringsIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedBySubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBySubStrings )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedBySubStringsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBySubStringsIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBoundedByNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBy )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedByIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedByIB )

			return _TRUE_
		else
			return _FALSE_
		ok


	def IsIsBoundedByNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :IsBoundedBy )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsBoundsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Bounds )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundsIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBoundedByOrBoundsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Bounds or This.Item(1) = :BoundedBy) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBoundsOrBoundedByNamedParam()
			return This.IsBoundedByOrBoundsNamedParam()

	def IsBoundedByIBOrBoundsIBNamedParam()
		if This.IsBoundedByIBNamedParam() or This.IsBoundsIBNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBoundsIBOrBoundedByIBNamedParam()
			return This.IsBoundedByIBOrBoundsIBNamedParam()

	#==

	def IsSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Section )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThisSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThisSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SectionIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsThisSectionIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThisSectionIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Sections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsTheseSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :TheseSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SectionsIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsTheseSectionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :TheseSectionsIB )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsOfSubSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSectionOrInSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Section or This.Item(1) = :InSection) )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsSectionsOrInSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Sections or This.Item(1) = :InSections) )

			return _TRUE_
		else
			return _FALSE_
		ok

		def IsSectionsOrInSectionsNamedParams()
			return This.IsSectionsOrInSectionsNamedParam()

	def IsToSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToSection )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToSections )

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsListSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ListSize )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStringSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StringSize )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNumberOfItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NumberOfItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsNumberOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NumberOfChars )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAListOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfNItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAListOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfSizeN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAListOfSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfSize )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAListOfNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAListOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOf )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAStringOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAStringOfN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInAStringOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAStringOfSizeN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInListOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfNItems )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInListOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfSizeN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInListOfSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfSize )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInListOfNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfN )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInListOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOf )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInStringOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InStringOf )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsInStringOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InStringOfSizeN )

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Start )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartOfList )

			return _TRUE_
		else
			return _FALSE_
		ok


	def IsEndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :End )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsEndOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :EndOfList )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsEndOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :EndOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsFromStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStart )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsFromStartOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStartOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsFromStartOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStartOfList )

			return _TRUE_
		else
			return _FALSE_
		ok


	def IsFromEndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEnd )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsFromEndOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEndOfList )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsFromEndOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEndOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsStartingAtCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtChar )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartingAtCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtCharAt )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartingAtCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtCharAtPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartingAtItemNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItem )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartingAtItemAtNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItemAt )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsStartingAtItemAtPositionNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItemAtPosition )

			return _TRUE_
		else
			return _FALSE_
		ok

	#--

	def IsToEndNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEnd )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToEndOfStringNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEndOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToEndOfListNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEndOfList )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStart )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToStartofListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStartOfList )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsToStartofStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStartOfString )

			return _TRUE_
		else
			return _FALSE_
		ok

	#==

	def IsOfSizeNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSize )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSizeNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Size )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsDoNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Do )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Until )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilCharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilCharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUntilItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok


	def IsUntilXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUptoNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpTo )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUptoPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

		# Misspelled form

		def IsUpToPosionNamedParam()
			return This.IsUptoPositionNamedParam()

	def IsUpToNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :UpToN or This.Item(1) = :UpToN@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToCharAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToCharAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToItemAt )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUpToItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToItemAtPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsUnderNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Under )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsExpressionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Expression )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNChars )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNItems )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNStrings )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNNumbers )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNLists )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNObjects )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsLastSepNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :LastSep or This.Item(1) = :LastSep@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToEach or This.Item(1) = :ToEach@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeEach or This.Item(1) = :BeforeEach@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterEach or This.Item(1) = :AfterEach@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToNth or This.Item(1) = :ToNth@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToFirst or This.Item(1) = :ToFirst@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToLast or This.Item(1) = :ToLast@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterNth or This.Item(1) = :AfterNth@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterFirst or This.Item(1) = :AfterFirst@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterLast or This.Item(1) = :AfterLast@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeNth or This.Item(1) = :BeforeNth@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThese )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsBeforeManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeMany )

			return _TRUE_
		else
			return _FALSE_
		ok


	def IsBeforeFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeFirst or This.Item(1) = :BeforeFirst@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeLast or This.Item(1) = :BeforeLast@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Around or This.Item(1) = :Around@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundPosition or This.Item(1) = :AroundPosition@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundPositions or This.Item(1) = :AroundPositions@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundSubString or This.Item(1) = :AroundSubString@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundSubStrings or This.Item(1) = :AroundSubStrings@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AroundThese )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAroundManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AroundMany )

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAroundEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundEach or This.Item(1) = :AroundEach@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundNth or This.Item(1) = :AroundNth@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundFirst or This.Item(1) = :AroundFirst@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundLast or This.Item(1) = :AroundLast@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Each or This.Item(1) = :Each@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :First or This.Item(1) = :First@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Last or This.Item(1) = :Last@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsConcatenatedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Concatenated or This.Item(1) = :Concatenated@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsConcatenatedUsingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ConcatenatedUsing or This.Item(1) = :ConcatenatedUsing@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsConcatenatedWithNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ConcatenatedWith or This.Item(1) = :ConcatenatedWith@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNChars or This.Item(1) = :EachNChars@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNItems or This.Item(1) = :EachNItems@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNStrings or This.Item(1) = :EachNStrings@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNNumbers or This.Item(1) = :EachNNumbers@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNLists or This.Item(1) = :EachNLists@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNPairsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNPairs or This.Item(1) = :EachNPairs@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEachNObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNObjects or This.Item(1) = :EachNObjects@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Direction or This.Item(1) = :Direction@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsGoingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Going or This.Item(1) = :Going@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsDirectionOrGoingNamedParam()
		if This.IsDirectionNamedParam() or This.IsGoingNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsGoingOrDirectionNamedParam()
			return This.IsDirectionOrGoingNamedParam()

		#--

		def IsDirectionOrGoingNamedParams()
			return This.IsDirectionOrGoingNamedParam()

		def IsGoingOrDirectionNamedParams()
			return This.IsDirectionOrGoingNamedParam()

	def IsComingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Coming or This.Item(1) = :Coming@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSteppingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Stepping or This.Item(1) = :Stepping@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	
	def IsUsingOrWithOrByNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Using or This.Item(1) = :With or This.Item(1) = :By ) )

			return _TRUE_

		else
			return _FALSE_
		ok

		#< @FunctionAlternativeForms

		def IsUsingOrByOrWithNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrWithOrUsingNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrUsingOrWithNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrByOrUsingNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrUsingOrByNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		#--

		def IsUsingOrWithOrByNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsUsingOrByOrWithNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrWithOrUsingNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrUsingOrWithNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrByOrUsingNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrUsingOrByNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		#>

	def IsUsingOrWithOrByOrWhereNamedParam()
		if This.IsUsingOrWithOrByNamedParam() or This.IsWhereNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsUsingOrWithOrByOrWhereNamedParams()
			return This.IsUsingOrWithOrByOrWhereNamedParam()

	def IsNextNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Next or This.Item(1) = :Next@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNextNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :NextNth or This.Item(1) = :NextNth@  or 
			 This.Item(1) = :NthNext or This.Item(1) = :NthNext@) )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNthNextNamedParam()
			return This.IsNextNthNamedParam()

	def IsPreviousNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Previous or This.Item(1) = :Previous@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPreviousNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :PreviousNth or This.Item(1) = :PreviousNth@  or 
			 This.Item(1) = :NthPrevious or This.Item(1) = :NthPrevious@) )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNthPreviousNamedParam()
			return This.IsPreviousNthNamedParam()

	#--

	def IsExactlyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Exactly or This.Item(1) = :Exactly@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsMoreThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :MoreThen or This.Item(1) = :MoreThen@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsLessThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :LessThen or This.Item(1) = :LessThen@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfThese or This.Item(1) = :OfThese@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseSubStrings or This.Item(1) = :OfTheseSubStrings@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseNumbers or This.Item(1) = :OfTheseNumbers@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseLists or This.Item(1) = :OfTheseLists@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseObjects or This.Item(1) = :OfTheseObjects@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseChars or This.Item(1) = :OfTheseChars@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsOfTheseLettersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseLetters or This.Item(1) = :OfTheseLetters@ ) )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsAndOrAndPositionOrAndSubStringNamedParam()
		if This.IsAndNamedParam() or
		   This.IsAndPositionNamedParam() or
		   This.IsAndSubstringNamedParam()

			return _TRUE_
		else
			return _FALSE_
		ok

	def IsAndOrAndSubStringOrAndPositionNamedParam()
		return This.IsAndOrAndPositionOrAndSubStringNamedParam()

	#--

	def IsAndOrAndPositionOrAndSubStringNamedParams()
		return This.IsAndOrAndPositionOrAndSubStringNamedParam()

	def IsAndOrAndSubStringOrAndPositionNamedParams()
		return This.IsAndOrAndSubStringOrAndPositionNamedParam()

		#==

	def IsAtCharsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtCharsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtCharsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtCharsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtCharsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtCharsWhereXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtCharsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtCharsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtSubStringsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtSubStringsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtSubStringsWherexT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAtSubStringsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtSubStringsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--
	
	def IsBeforeCharsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeCharsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeCharsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeCharsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeCharsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeCharsWhereXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeCharsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeCharsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsWhereXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeSubStringsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	#--
	
	def IsAfterCharsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterCharsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterCharsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterCharsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterCharsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterCharsWhereXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterCharsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterCharsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AftersubStringsWhere )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringsWNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AftersubStringsW )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringsWhereXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AftersubStringsWhereXT )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterSubStringsWXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AftersubStringsWXT )

			return _TRUE_

		else
			return _FALSE_
		ok



	def IsAtCharsWhereXTOrAtCharsWXTNamedParam()
		if This.IsAtCharsWhereXTNamedParam() or This.IsAtCharsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAtCharsWXTOrAtCharsWhereXTNamedParam()
			return This.IsAtCharsWXTOrAtCharsWhereXTNamedParam()

		#--

		def IsAtCharsWhereXTOrAtCharsWXTNamedParams()
			return This.IsAtCharsWhereXTOrAtCharsWXTNamedParam()

		def IsAtCharsWXTOrAtCharsWhereXTNamedParams()
			return This.IsAtCharsWXTOrAtCharsWhereXTNamedParam()


	def IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
		if This.IsBeforeCharsWhereXTNamedParam() or This.IsBeforeCharsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBeforeCharsWXTOrBeforeCharsWhereXTNamedParam()
			return This.IsBeforeCharsWXTOrBeforeCharsWhereXTNamedParam()

		#--

		def IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParams()
			return This.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()

		def IsBeforeCharsWXTOrBeforeCharsWhereXTNamedParams()
			return This.IsBeforeCharsWXTOrBeforeCharsWhereXTNamedParam()

	def IsAfterCharsWhereXTOrAfterCharsWXTNamedParam()
		if This.IsAfterCharsWhereXTNamedParam() or This.IsAfterCharsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAfterCharsWXTOrAfterCharsWhereXTNamedParam()
			return This.IsAfterCharsWXTOrAfterCharsWhereXTNamedParam()

		#--

		def IsAfterCharsWhereXTOrAfterCharsWXTNamedParams()
			return This.IsAfterCharsWhereXTOrAfterCharsWXTNamedParam()

		def IsAfterCharsWXTOrAfterCharsWhereXTNamedParams()
			return This.IsAfterCharsWXTOrAfterCharsWhereXTNamedParam()

	def IsAtSubStringsWhereXTOrAtCharsWXTNamedParam()
		if This.IsAtSubstringsWhereXTNamedParam() or This.IsAtSubstringsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAtSubstringsWXTOrAtSubstringsWhereXTNamedParam()
			return This.IsAtSubstringsWXTOrAtSubstringsWhereXTNamedParam()

		#--

		def IsAtSubstringsWhereXTOrAtSubstringsWXTNamedParams()
			return This.IsAtSubstringsWhereXTOrAtSubstringsWXTNamedParam()

		def IsAtSubstringsWXTOrAtSubstringsWhereXTNamedParams()
			return This.IsAtSubstringsWXTOrAtSubstringsWhereXTNamedParam()

	def IsBeforeSubStringsWhereXTOrBeforSubStringsWXTNamedParam()
		if This.IsBeforeSubstringsWhereXTNamedParam() or This.IsBeforeSubstringsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsBeforeSubstringsWXTOrBeforeSubstringsWhereXTNamedParam()
			return This.IsBeforeSubstringsWXTOrBeforeSubstringsWhereXTNamedParam()

		#--

		def IsBeforeSubstringsWhereXTOrBeforeSubstringsWXTNamedParams()
			return This.IsBeforeSubstringsWhereXTOrBeforeSubstringsWXTNamedParam()

		def IsBeforeSubstringsWXTOrBeforeSubstringsWhereXTNamedParams()
			return This.IsBeforeSubstringsWXTOrBeforeSubstringsWhereXTNamedParam()

	def IsAfterSubStringsWhereXTOrAfterSubstringsWXTNamedParam()
		if This.IsAfterSubstringsWhereXTNamedParam() or This.IsAfterSubstringsWXTNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsAfterSubstringsWXTOrAfterSubstringsWhereXTNamedParam()
			return This.IsAfterSubstringsWXTOrAfterSubstringsWhereXTNamedParam()

		#--

		def IsAfterSubstringsWhereXTOrAfterSubstringsWXTNamedParams()
			return This.IsAfterSubstringsWhereXTOrAfterSubstringsWXTNamedParam()

		def IsAfterSubstringsWXTOrAfterSubstringsWhereXTNamedParams()
			return This.IsAfterSubstringsWXTOrAfterSubstringsWhereXTNamedParam()

	#--

	def IsForwardNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Forward )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBackwardNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Backward )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsForwardOrBackwardNamedParam()
		if This.IsForwardNamedParam() or This.IsBackwardNamedParam()
			return _TRUE_
		else
			return FALE
		ok

		def IsForwardOrBackwardNamedParams()
			return This.IsForwardOrBAckwardNamedParam()

		def IsBackwardOrforwardNamedParam()
			return This.IsForwardOrBAckwardNamedParam()

		def IsBackwardOrforwardNamedParams()
			return This.IsForwardOrBAckwardNamedParam()

	def IsJumpNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Jump )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsInOrOfNamedParam()
		if This.IsInNamedParam() or This.IsOfNamedParam()
			return _TRUE_
		else
			return _FALSE_
		ok

		def IsOfOrInNamedParam()
			return IsInOrOfNamedParam()

		def IsInOrOfNamedParams()
			return IsInOrOfNamedParam()

		def IsOfOrInNamedParams()
			return IsInOrOfNamedParam()

	def IsNameOrNamedNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Name or This.Item(1) = :Named ) )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNameOrNamedNamedParams()
			return This.IsNameOrNamedNamedParam()

	def IsStartOrStartAtOrStaringAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Start or This.Item(1) = :StartAt or This.Item(1) = :StartingAt )
		    )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStartOrStartAtOrStaringAtNamedParams()
			return This.IsStartOrStartAtOrStaringAtNamedParam()

	def IsEndOrEndAtOrEndingAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :End or This.Item(1) = :EndAt or This.Item(1) = :EndingAt )
		    )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsEndOrEndAtOrEndingAtNamedParams()
			return This.IsEndOrEndAtOrEndingAtNamedParam()

	def IsNStepNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NStep )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsNStepsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NStep )

			return _TRUE_

		else
			return _FALSE_
		ok


	def IsStepsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Steps )

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsStepOrNSetpNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and

		   ( This.Item(1) = :End or This.Item(1) = :Step or This.Item(1) = :NStep )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStepOrNSetpNamedParams()
			return This.IsStepOrNSetpNamedParam()

	def IsStepsOrNSetpsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1) and
		   ( This.Item(1) = :End or This.Item(1) = :Steps or This.Item(1) = :NSteps ) )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStepsOrNSetpsNamedParams()
			return This.IsStepsOrNSetpsNamedParam()

	def IsStepOrStepsOrNStepOrNStepsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and

		   ( This.Item(1) = :Step or
		     This.Item(1) = :Steps or
		     This.Item(1) = :NStep or
		     This.Item(1) = :NSteps )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStepOtNStepOrStepsOrNStepsNamedParam()
			return This.IsStepOrStepsOrNStepOrNStepsNamedParam()

		#--

		def IsStepOrStepsOrNStepOrNStepsNamedParams()
			return This.IsStepOrStepsOrNStepOrNStepsNamedParam()

		def IsStepOtNStepOrStepsOrNStepsNamedParams()
			return This.IsStepOrStepsOrNStepOrNStepsNamedParam()

	def IsThanNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :Than

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsSeparatorNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :Separator

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsFirstCharsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :FirstChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFirstNCharsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :FirstNChars or This.Item(1) = :NFirstChars )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNFirstCharsNamedParam()
			return This.IsFirstNCharsNamedParam()

	def IsFirstNItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :FirstNChars or This.Item(1) = :NFirstItems )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNFirstItemsNamedParam()
			return This.IsFirstNItemsNamedParam()

	#--

	def IsLastCharsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :LastChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsLastNCharsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :LastNChars or This.Item(1) = :NLastChars )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNLastCharsNamedParam()
			return This.IsLastNCharsNamedParam()

	def IsLastNItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :LastNChars or This.Item(1) = :NLastItems )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsNLastItemsNamedParam()
			return This.IsLastNItemsNamedParam()

	def IsStartingAtOrAfterNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :StartingAt or This.Item(1) = :After )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStartingAtOrAfterNamedParams()
			return IsStartingAtOrAfterNamedParam()

		def IsAfterOrStartingAtNamedParam()
			return IsStartingAtOrAfterNamedParam()

		def IsAfterOrStartingAtNamedParams()
			return IsStartingAtOrAfterNamedParam()

	def IsStartingAtOrBeforeNamedParam()

		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :StartingAt or This.Item(1) = :Before )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsStartingAtOrBeforeNamedParams()
			return IsStartingAtOrBeforeNamedParam()

		def IsBeforeOrStartingAtNamedParam()
			return IsStartingAtOrBeforeNamedParam()

		def IsBeforeOrStartingAtNamedParams()
			return IsStartingAtOrBeforeNamedParam()

	def IsAtOrAtThisPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :At or This.Item(1) = :AthThisPosition )

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsAtThisPositionOrAtNamedParam()
			return This.IsAtThisPositionOrAtNamedParam()

	def IsAfterManyPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AfterManyPositions

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterManyPositionsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AfterManyPositionsIB

			return _TRUE_

		else
			return _FALSE_
		ok

	#--

	def IsToEndOfWordNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :ToEndOfWord

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndOfWordNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :EndOfWord

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToEndOfLineNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :ToEndOfLine

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndOfLineNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :EndOfLine

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToEndOfSentenceNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :ToEndOfSentence

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsEndOfSentenceNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :EndOfSentence

			return _TRUE_

		else
			return _FALSE_
		ok

#~~~~~~~~

	def IsUpToNBoundsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :UpToNBounds

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIsBoundOfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :IsBoundOf

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIsFirstBoundOfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :IsFirstBoundOf

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIsLastBoundOfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :IsLastBoundOf

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIsLeftBoundOfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :IsLeftBoundOf

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsIsRightBoundOfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :IsRightBoundOf

			return _TRUE_

		else
			return _FALSE_
		ok

#--

	def IsBeforeCharNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :BeforeChar

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBeforeCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :BeforeChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterCharNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AfterChar

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAfterCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AfterChars

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundCharNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AroundChar

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAroundCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :AroundChars

			return _TRUE_

		else
			return _FALSE_
		ok

#--

	def IsBeforePositonNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :BeforePosition

			return _TRUE_

		else
			return _FALSE_
		ok

#--

	def IsBeforSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :BeforeSubStrings

			return _TRUE_

		else
			return _FALSE_
		ok

#-

	def IsPositionOrSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   (This.Item(1) = :Position or This.Item(1) = :SubString)

			return _TRUE_

		else
			return _FALSE_
		ok	

		def IsSubStringOrPositionNamedParam()
			return This.IsPositionOrSubStringNamedParam()


#--

	def IsFromPathNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :FromPath

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToPathNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :ToPath

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsFromOrFromPathNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :FromPath or This.Item(1) = :From)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsToOrToPathNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :ToPath or This.Item(1) = :To)

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsAmongNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :Among

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsBetweenOrFromNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   ( This.Item(1) = :Between or This.Item(1) = :From)

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsFromOrBetweenNamedParam()
			return This.IsBetweenOrFromNamedParam()

	def IsLikeNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :Like

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsPatternNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :Pattern

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsGroupNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :Group

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWhenNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :When

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsForNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :For

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsForEachNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   This.Item(1) = :ForEach

			return _TRUE_

		else
			return _FALSE_
		ok

	def IsWhenOrIfNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   (This.Item(1) = :When or This.Item(1) = :If)

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsIfOrWhenNamedParam()
			return This.IsWhenOrIfNamedParam()

	def IsWhenOrForNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   (This.Item(1) = :When or This.Item(1) = :For)

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsForOrWhenNamedParam()
			return This.IsWhenOrForNamedParam()

	def IsIfOrForNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   (This.Item(1) = :If or This.Item(1) = :For)

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsForOrIfNamedParam()
			return This.IsForOrIfNamedParam()

	def IsIfOrForOrWhenNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and
		   (This.Item(1) = :If or This.Item(1) = :For or This.Item(1) = :When)

			return _TRUE_

		else
			return _FALSE_
		ok

		def IsIfOrWhenOrForNamedParam()
			return This.IsIfOrForOrWhenNamedParam()

		def IsWhenOrIfOrForNamedParam()
			return This.IsIfOrForOrWhenNamedParam()

		def IsWhenOrForOrIfNamedParam()
			return This.IsIfOrForOrWhenNamedParam()

		def IsForOrIfOrWhenNamedParam()
			return This.IsIfOrForOrWhenNamedParam()

		def IsForOrWhenOrIfNamedParam()
			return This.IsIfOrForOrWhenNamedParam()

#WARNING: All the Is...NamedParam() functions will be moved
# to the dedicated stzNamedParams.ring file.

#~> Once this migration is complete, stzList.ring will be
# cleaned up and these functions will be removed.  
