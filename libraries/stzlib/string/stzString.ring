#-------------------------------------------------------------------------#
# 		   SOFTANZA LIBRARY (V1.0) - STZSTRING		          #
# 	An accelerative library for Ring applications, and more!	  #
#-------------------------------------------------------------------------#
#									  #
# 	Description	: The class for managing Unicode strings          #
#	Version		: V1.0 (2020-2024)				  #
#	Author		: Mansour Ayouni (kalidianow@gmail.com)		  #
#								          #
#-------------------------------------------------------------------------#

/*
	#TODO Add:
	QStringRef methods

	TODO: use QStringView for read-only operations, and QByteArray
	for UT8-only string
	#--> Better performance.

	#Todo:
	Get inspiration from the python ftfy library to add Unicode text
	cleansing in Softanza
	link: https://ftfy.readthedocs.io
*/

_cMarquerChar = "#"

  /////////////////////
 ///   FUNCTIONS   ///
/////////////////////

func StzStringQ(str)
	return new stzString(str)

	#< @FunctionMisspelledForm

	func StzSrtringQ(str)
		return StzStringQ(str)

func StzNamedString(paNamed)
	if CheckParams()
		if NOT (isList(paNamed) and Q(paNamed).IsPairOfStrings())
			StzRaise("Incorrect param type! paNamed must be a pair of strings.")
		ok
	ok

	oStr = new stzString(paNamed[2])
	oStr.SetName(paNamed[1])
	return ostr

	func StzNamedStringQ(paNamed)
		return StzNamedString(paNamed)

	func StzNamedStringXTQ(paNamed)
		return StzNamedString(paNamed)

func StzStringMethods()
	return Stz(:String, :Methods)

func StzStringAttributes()
	return Stz(:String, :Attributes)

func StzStringClassName()
	return Stz(:String, :ClassName)

	func StzStringClass()
		return StzStringClassName()

func IsNotString(pcStr)
	return NOT isString(pcStr)

	func IsNotAString(pcStr)
		return IsNotString(pcStr)

	func @IsNotString(pcStr)
		return IsNotString(pcStr)

	func @IsNotAString(pcStr)
		return IsNotString(pcStr)

func @IsAlpha(cStr)
	return StzStringQ(cStr).IsAlpha()

	#< @FunctionAlternativeForms

	func IsAlphabetical(cStr)
		return @IsAlpha(cStr)

	func @IsAlphabetical(cStr)
		return @IsAlpha(cStr)

	#--

	func IsAlphabetic(cStr)
		return @IsAlpha(cStr)

	func @IsAlphabetic(cStr)
		return @IsAlpha(cStr)

	#>

func @IsAlnum(cStr)
	return StzStringQ(cStr).IsAlnum()

	#< @FunctionAlternativeForms

	func IsAlphaNumerical(cStr)
		return @IsAlnum(cStr)

	func @IsAlphaNumerical(cStr)
		return @IsAlnum(cStr)

	#--

	func IsAlphaNumeric(cStr)
		return @IsAlnum(cStr)

	func @IsAlphanumeric(cStr)
		return @IsAlnum(cStr)

	#>

func IsNullString(cStr)
	if isString(cStr) and cStr != NULL
		return TRUE
	else
		return FALSE
	ok

	#< @FunctionAlternativeForms

	func IsEmptyString(cStr)
		return IsNullString(cStr)

	func ANullString(pcStr)
		return IsNullString(cStr)

	func IsAnEmptyString(cStr)
		return IsNullString(cStr)

	#--

	func @IsNullString(cStr)
		return IsNullString(cStr)

	func @IsEmptyString(cStr)
		return IsNullString(cStr)

	func @ANullString(pcStr)
		return IsNullString(cStr)

	func @IsAnEmptyString(cStr)
		return IsNullString(cStr)

	#==

	func IsNull(cStr)
		return IsNullString(cStr)

	func IsEmpty(cStr)
		return IsNullString(cStr)

	#--

	func @IsNull(cStr)
		return IsNullString(cStr)

	func @IsEmpty(cStr)
		return IsNullString(cStr)

	#>

func IsNonNullString(cStr)
	return NOT IsNullString(cStr)

	#< @FunctionAlternativeForms

	func IsNonEmptyString(cStr)
		return IsNonNullString(cStr)

	func ANonNullString(pcStr)
		return IsNonNullString(cStr)

	func IsANonEmptyString(cStr)
		return IsNonNullString(cStr)

	#--

	func @IsNonNullString(cStr)
		return IsNonNullString(cStr)

	func @IsNonEmptyString(cStr)
		return IsNonNullString(cStr)

	func @ANonNullString(pcStr)
		return IsNonNullString(cStr)

	func @IsANonEmptyString(cStr)
		return IsNonNullString(cStr)

	#>

func IsBlank(pcStr)
	return StzStringQ(pcStr).IsMadeOfSpaces()

	#< @FunctionAlternativeForms

	func IsBlankString(pcStr)
		return IsBlank(pcStr)

	func IsABlankString(pcStr)
		return IsBlank(pcStr)

	#--

	func @IsBlank(pcStr)
		return IsBlank(pcStr)

	func @IsBlankString(pcStr)
		return IsBlank(pcStr)

	func @IsABlankString(pcStr)
		return IsBlank(pcStr)

	#>

func StzSplitCS(cStr, cSubStr, bCaseSensitive)
	#NOTE // We could call the stzSplt() function in the CORE layer
	# that does the same thing and contains the same code!
	# But since the code small let's rewerite again here and gain
	# the independence between layers.

	oQStr = new QString2()
	oQStr.append(cStr)
	
	oQStrList = oQStr.split(cSubStr, 0, bCaseSensitive)
	
	acResult = []
	for i = 0 to oQStrList.size()-1
		acResult + oQStrList.at(i)	
	next

	return acResult

func StzSplit(cStr, cSubStr)
	return StzSplitCS(cStr, cSubStr, 0)

#--

# Trim function (to use instead of the one provided by the standard library)

func StzTrim(cStr)
	oQStr = new QString2()
	oQStr.append(cStr)

	cResult = oQStr.trimmed()
	return cResult

func StzTrimLeft(cStr)
	return StzStringQ(cStr).TrimmedLeft()

	func @TrimLeft(cStr)
		return StzStringQ(cStr).TrimmedLeft()

func StzTrimRight(cStr)
	return StzStringQ(cStr).TrimmedRight()

	func @TrimRight(cStr)
		return StzStringQ(cStr).TrimmedRight()

func StzTrimStart(cStr)
	return StzStringQ(cStr).TrimmedFromStart()

	func TrimStart(cStr)
		return StzStringQ(cStr).TrimmedFromStart()

	func @TrimStart(cStr)
		return StzStringQ(cStr).TrimmedFromStart()

	func StzTrimFromStart(cStr)
		return StzStringQ(cStr).TrimmedFromStart()

	func TrimFromStart(cStr)
		return StzStringQ(cStr).TrimmedFromStart()

	func @TrimFromStart(cStr)
		return StzStringQ(cStr).TrimmedFromStart()

func StzTrimEnd(cStr)
	return StzStringQ(cStr).TrimmedFromEnd()

	func TrimEnd(cStr)
		return StzStringQ(cStr).TrimmedFromEnd()

	func @TrimEnd(cStr)
		return StzStringQ(cStr).TrimmedFromEnd()

	func StzTrimFromEnd(cStr)
		return StzStringQ(cStr).TrimmedFromEnd()

	func TrimFromEnd(cStr)
		return StzStringQ(cStr).TrimmedFromEnd()

	func @TrimFromEnd(cStr)
		return StzStringQ(cStr).TrimmedFromEnd()

#--

func StringIsEmpty(pcStr)
	return pcStr = ""

func StringIsNull(pcStr)
	return pcStr = ""

func StzStringToQString(oStr)
	return oStr.QStringObject()
	
func StringIsLocaleAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLocaleAbbreviation()
	
	func @IsLocaleAbbreviation(cStr)
		return StringIsLocaleAbbreviation(cStr)

func StringIsLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageAbbreviation()

	func @IsLanguageAbbreviation(cStr)
		return StringIsLanguageAbbreviation(cStr)

func StringIsShortLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortLanguageAbbreviation()

	func @IsShortLanguageAbbreviation(cStr)
		return StringIsShortLanguageAbbreviation(cStr)

func StringIsLongLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongLanguageAbbreviation()

	func @IsLongLanguageAbbreviation(cStr)
		return StringIsLongLanguageAbbreviation(cStr)

func StringIsLanguageName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageName()

	func @IsLanguageName(cStr)
		return StringIsLanguageName(cStr)

func StringIsLanguageNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageNumber()

	func @IsLanguageNumber(cStr)
		return StringIsLanguageNumber(cStr)

func StringIsCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryAbbreviation()

	func @IsCountryAbbreviation(cStr)
		return StringIsCountryAbbreviation(cStr)

func StringIsCountryName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryName()

	func @IsCountryName(cStr)
		return StringIsCountryName(cStr)

func StringIsCountryNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryNumber()

	func @IsCountryNumber(cStr)
		return StringIsCountryNumber(cStr)

func StringIsShortCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortCountryAbbreviation()

	func @IsShortCountryAbbreviation(cStr)
		return StringIsShortCountryAbbreviation(cStr)

func StringIsLongCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongCountryAbbreviation()

	func @IsLongCountryAbbreviation(cStr)
		return StringIsLongCountryAbbreviation(cStr)

func StringIsScriptAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptAbbreviation()

	func @IsScriptAbbreviation(cStr)
		return StringIsScriptAbbreviation(cStr)

func StringIsScriptName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptName()

	func @IsScriptName(cStr)
		return StringIsScriptName(cStr)

func StringIsScriptNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptNumber()

	func @IsScriptNumber(cStr)
		return StringIsScriptNumber(cStr)

func StringIsLowercase(cStr)
	return StzStringQ(cStr).IsLowercase()

	func @IsLowercase(cStr)
		return StringIsLowercase(cStr)

func StringIsUppercase(cStr)
	return StzStringQ(cStr).IsUppercase()

	func @IsUppercase(cStr)
		return StringIsUppercase(cStr)

func StringLowercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Lowercased()
	
	func StringLowercase(cStr)
		return StringLowercased(cStr)

	func @Lowercased(cStr)
		return StringLowercased(cStr)

	func @Lowercase(cStr)
		return StringLowercased(cStr)

func StringUppercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Uppercased()
	
	func StringUppercase(cStr)
		return StringUppercased(cStr)

	func @Uppercased(cStr)
		return StringUppercased(cStr)

	func @Uppercase(cStr)
		return StringUppercased(cStr)

func StringTitlecased(cStr)
	oStr = new stzString(cStr)
	return oStr.Titlecased()
	
	func StringTitlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecased(cStr)
		return StringTitlecased(cStr)

	func @Titlecased(cStr)
		return StringTitlecased(cStr)
	
	func @Titlecase(cStr)
		return StringTitlecased(cStr)

#===

func StringAlignXT(cStr, nWidth, cChar, cDirection)
	oString = new stzString(cStr)
	return oString.AlignXTQ(nWidth, cChar, cDirection).Content()
	
	func @AlignXT(cStr, nWidth, cChar, cDirection)
		return StringAlignXT(cStr, nWidth, cChar, cDirection)

	func AlignXT(cStr, nWidth, cChar, cDirection)
		return StringAlignXT(cStr, nWidth, cChar, cDirection)

#--

func StringLeftAlign(cStr, nWidth)
	return StringAlignXT(cStr, nWidth, " ", :Left)

	func StringAlignLeft(cStr, nWidth)
		return StringLeftAlign(cStr, nWidth)

	func LeftAlign(cStr, nWidth)
		return StringLeftAlign(cStr, nWidth)

	func AlignLeft(cStr, nWidth)
		return StringLeftAlign(cStr, nWidth)

	func @LeftAlign(cStr, nWidth)
		return StringLeftAlign(cStr, nWidth)

	func @AlignLeft(cStr, nWidth)
		return StringLeftAlign(cStr, nWidth)

func StringLeftAlignXT(cStr, nWidth, cChar)
	return StringAlignXT(cStr, nWidth, cChar, :Left)

	func StringAlignLeftXT(cStr, nWidth, cChar)
		return StringLeftAlignXT(cStr, nWidth, cChar)

	func LeftAlignXT(cStr, nWidth, cChar)
		return StringLeftAlignXT(cStr, nWidth, cChar)

	func AlignLeftXT(cStr, nWidth, cChar)
		return StringLeftAlignXT(cStr, nWidth, cChar)

	func @LeftAlignXT(cStr, nWidth, cChar)
		return StringLeftAlignXT(cStr, nWidth, cChar)

	func @AlignLeftXT(cStr, nWidth, cChar)
		return StringLeftAlignXT(cStr, nWidth, cChar)

#--

func StringRightAlign(cStr, nWidth)
	return StringAlignXT(cStr, nWidth, " ", :Right)

	func StringAlignRight(cStr, nWidth)
		return StringRightAlign(cStr, nWidth)

	func RightAlign(cStr, nWidth)
		return StringRightAlign(cStr, nWidth)

	func AlignRight(cStr, nWidth)
		return StringRightAlign(cStr, nWidth)

	func @RightAlign(cStr, nWidth)
		return StringRightAlign(cStr, nWidth)

	func @AlignRight(cStr, nWidth)
		return StringRightAlign(cStr, nWidth)

func StringRightAlignXT(cStr, nWidth, cChar)
	return StringAlignXT(cStr, nWidth, cChar, :Right)

	func StringAlignRightXT(cStr, nWidth, cChar)
		return StringRightAlignXT(cStr, nWidth, cChar)

	func RightAlignXT(cStr, nWidth, cChar)
		return StringRightAlignXT(cStr, nWidth, cChar)

	func AlignRightXT(cStr, nWidth, cChar)
		return StringRightAlignXT(cStr, nWidth, cChar)

	func @RightAlignXT(cStr, nWidth, cChar)
		return StringRightAlignXT(cStr, nWidth, cChar)

	func @AlignRightXT(cStr, nWidth, cChar)
		return StringRightAlignXT(cStr, nWidth, cChar)
#--

func StringCenterAlign(cStr, nWidth)
	return StringAlignXT(cStr, nWidth, " ", :Center)

	func StringAlignCenter(cStr, nWidth)
		return StringCenterAlign(cStr, nWidth)

	func CenterAlign(cStr, nWidth)
		return StringCenterAlign(cStr, nWidth)

	func AlignCenter(cStr, nWidth)
		return StringCenterAlign(cStr, nWidth)

	func @CenterAlign(cStr, nWidth)
		return StringCenterAlign(cStr, nWidth)

	func @AlignCenter(cStr, nWidth)
		return StringCenterAlign(cStr, nWidth)

func StringCenterAlignXT(cStr, nWidth, cChar)
	return StringAlignXT(cStr, nWidth, cChar, :Center)

	func StringAlignCenterXT(cStr, nWidth, cChar)
		return StringCenterAlignXT(cStr, nWidth, cChar)

	func CenterAlignXT(cStr, nWidth, cChar)
		return StringCenterAlignXT(cStr, nWidth, cChar)

	func AlignCenterXT(cStr, nWidth, cChar)
		return StringCenterAlignXT(cStr, nWidth, cChar)

	func @CenterAlignXT(cStr, nWidth, cChar)
		return StringCenterAlignXT(cStr, nWidth, cChar)

	func @AlignCenterXT(cStr, nWidth, cChar)
		return StringCenterAlignXT(cStr, nWidth, cChar)
#===

func StringRepeat(cStr, n)
	oString = new stzString(cStr)
	return oString.RepeatedNTimes(n)
	
	func @Repeat(cStr, n)
		return StringRepeat(cStr, n)

func StringNumberOfChars(cStr)
	oString = new stzString(cStr)
	return oString.NumberOfChars()
	
	func @NumberOfChars(cStr)
		return StringNumberOfChars(cStr)

func StringReverseChars(cStr)
	oString = new stzString(cStr)
	return oString.CharsReversed()
	
	func @ReverseChars(cStr)
		return StringReverseChars(cStr)

func StringIsWord(cStr)
	oString = new stzString(cStr)
	return oString.IsWord()
	
	func @IsWord(cStr)
		return StringIsWord(cStr)

func StringContains(pcStr, pcSubStr)
	return StzStringQ(pcStr).Contains(pcSubStr)
	
	func @Contains(pcStr, pcSubStr)
		return StringContains(pcStr, pcSubStr)

func StringNumberOfOccurrence(pcStr, pcSubStr)
	return StzStringQ(pcStr).NumberOfOccurrence(pcSubStr)
	
	func @NumberOfOccurrence(pcStr, pcSubStr)
		return StringNumberOfOccurrence(pcStr, pcSubStr)

func StringToUnicodes(pcStr)
	return StzStringQ(pcStr).Unicodes()
		
	func @ToUnicodes(pcStr)
		return StringToUnicodes(pcStr)

# Some functions used mainly in natural-code

func UppercaseOf(cStr)
	return StzStringQ(cStr).Uppercased()

	func UppercaseIn(cStr)
		return UppercaseOf(cStr)

func LowercaseOf(cStr)
	return StzStringQ(cStr).Lowercased()

	func LowercaseIn(cStr)
		return LowercaseOf(cStr)

func FoldcaseOf(cStr)
	return StzStringQ(cStr).Foldcase()

	func FoldcaseIn(cStr)
		return FoldcaseOf(cStr)

func NthCharOf(n, cStr)
	return StzStringQ(cStr)[n]

	func NthCharIn(n, cStr)
		return NthCharOf(n, cStr)

func NthLetterOf(n, cStr)
		aOnlyLetters = StzStringQ(cStr).OnlyLetters()
		return aOnlyLetters[n]

	func NthLetterIn(n, cStr)
		return NthLetterOf(n, cStr)

func StringIsArabicWord(pcStr)
	return StzStringQ(pcStr).IsArabicWord()

func StringIsCharName(pcStr)
	return StzStringQ(pcStr).IsCharName()

# Used for natural-coding

func Text(pcStr)
	#NOTE: In the future, there will be a difference
	# between String and Text
	if isString(pcStr)
		return pcStr
	ok

func NumberOfCharsOf(pcStr)
	return StzStringQ(pcStr).NumberOfChars()

	func NumberOfCharsIn(pcStr)
		return NumberOfCharsOf(pcStr)

func BothStringsAreEqualCS(pcStr1, pcStr2, pCaseSensitive)
	return StringsAreEqualCS( [ pcStr1, pcStr2 ], pCaseSensitive )

func BothStringsAreEqual(pcStr1, pcStr2)
	return BothStringsAreEqualCS(pcStr1, pcStr2, TRUE)

func StringsAreEqualCS(pacStr, pCaseSensitive)
	if NOT @IsListOfStrings(pacStr)
		stzRaise("Incorrect param type! pacStr must b a list of strings!")
	ok

	if NOT len(pacStr) > 1
		stzRaise("You must provide at least two strings pacStr!")
	ok

	# Resolving pCaseSensitive

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if isString(pCaseSensitive)
		if Q(pCaseSensitive).IsOneOfThese([
			:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

			pCaseSensitive = TRUE
			
		but Q(pCaseSensitive).IsOneOfThese([
			:CaseInSensitive, :NotCaseSensitive, :NotCS,
			:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

			pCaseSensitive = FALSE
		ok

	ok

	if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
		stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
	ok

	# Doing the job

	bResult = TRUE
	nLen = len(pacStr)

	if pCaseSensitive = TRUE
		
		cFirstStr = StzStringQ(pacStr[1]).Lowercased()
		
		for i = 2 to nLen
			if StzStringQ(pacStr[i]).Lowercased() != cFirstStr
				bResult = FALSE
				exit
			ok 
		next

		return bResult
	else

		cFirstStr = pacStr[1]
		
		for i = 1 to nLen
			if pacStr[i] != cFirstStr
				bResult = FALSE
				exit
			ok
		next

	ok

	return bResult

func StringsAreEqual(paStr)
	return StringsAreEqualCS(paStr, TRUE)

func RemoveDiacritics(pcStr)
	return StzStringQ(pcStr).DiacriticsRemoved()

func StringCases()
	return [ :Lowercase, :Uppercase, :Capitalcase, :Titlecase, :Foldercase ]

func StringCase(pcStr)

	return StzStringQ(pcStr).StringCase()

func Interpolate(pcStr)
	return Q(pcStr).Interpolated()

	#< @FunctionMisspelledForm

	func Interpoltate(pcStr)
		return Intrepolate(pcStr)

	func Intrepolate(pcStr)
		return Interpolate(pcStr)

	#>

func NCopies(n, p)
	if isList(p) and Q(p).IsFromOrOfNamedParam()
		p = p[2]
	ok

	return Q(p).CopiedNTimes(n)

	func 2Copies(p)
		return NCopies(2, p)
	
	func 3Copies(p)
		return NCopies(3, p)

	func 4Copies(p)
		return NCopies(4, p)

	func 5Copies(p)
		return NCopies(3, p)

func WithoutSpaces(pcStr)
	cResult = StzSrtringQ(pcStr).WithoutSpaces()
	#NOTE: StzSrtringQ() is misspelled but Softanza recognizes it!

	return cResult

	func @WithoutSpaces(pcStr)
		return WithoutSpaces(pcStr)

	#< @FunctionMisspelledForms

	func WithoutSapces(pcStr)
		return WithoutSpaces(pcStr)

	func @WithoutSapces(pcStr)
		return WithoutSpaces(pcStr)

	#>

func IsMarquer(cStr)
	if CheckParams()
		if NOT isString(cStr)
			StzRaise("Incorrect param type! cStr must be a string.")
		ok
	ok

	return Q(cStr).IsMarquer()

	func IsAMarquer(cStr)
		return IsMarquer(cStr)

	func StringIsMarquer(cStr)
		return IsMarquer(cStr)

	func StringIsAMarquer(cStr)
		return IsMarquer(cStr)

	func @IsMarquer(cStr)
		return IsMarquer(cStr)

	func @IsAMarquer(cStr)
		return IsMarquer(cStr)

	func @StringIsMarquer(cStr)
		return IsMarquer(cStr)

	func @StringIsAMarquer(cStr)
		return IsMarquer(cStr)

func BothAreMarquers(pcStr1, pcStr2)
	if BothAreStrings(pcStr1, pcStr2) and
	   Q(pcStr1).IsMarquer() and Q(pcStr2).IsMarquer()

		return TRUE
	else
		return FALSE
	ok

	func @BothAreMarquers(pcStr1, pcStr2)
		return BothAreMarquers(pcStr1, pcStr2)

func IsNumberInString(str)
	return StzStringQ(str).IsNumberInString()

	func @IsNumberInstring(str)
		return IsNumberInString(str)

func IsIntegerInString(str)
	return StzStringQ(str).IsIntegerInString()

	func @IsIntegerInstring(str)
		return IsIntegerInString(str)

func IsNumberOrListInString(str)
	return StzStringQ(str).IsNumberOrListInString()

	func IsStringOrNumberInString(str)
		return IsNumberOrListInString(str)

	func @IsNumberOrListInString(str)
		return IsNumberOrListInString(str)

	func @IsStringOrNumberInString(str)
		return IsNumberOrListInString(str)

func IsRealInString(str)
	return StzStringQ(str).IsRealInString()

	func @IsRealInstring(str)
		return IsRealInString(str)

func @IsPalindrome(p)
	if isList(p)
		if len(p) < 2
			return FALSE
		ok

		return StzListQ(p).IsPalindrome()

	but isString(p)
		oStr = new stzString(p)
		if oStr.NumberOfChars() < 2
			return FALSE
		ok

		return StzStringQ(p).IsPalindrome()
	else
		StzRaise("Incorrect param type! p must be a string or list.")
	ok

	def IsPalindrom(p)
		return @IsPalindrome(p)

	func @IsPalindrom(p)
		return @IsPalindrome(p)

	func IsMirrored(p)
		return @IsPalindrome(p)

	func @IsMirrored(p)
		return @IsPalindrome(p)

func @IsPunct(p)
	if isString(p)
		return StzStringQ(p).IsPunct()

	but isList(p) and @IsListOfChars(p)
		#TODO
	else
		StzRaise("Incorrect param type! p must be a string or list of chars.")
	ok

#--

func MarquerChar()
	return _cMarquerChar

	func DefaultMarquerChar()
		return _cMarquerChar

	func @MarquerChar()
		return _cMarquerChar

	func Marquer()
		return _cMarquerChar

	func @Marquer()
		return _cMarquerChar

func SetMarquerChar(c)
	if NOT (isString(c) and IsChar(c))
		StzRaise("Incorrect param type! c must be a char.")
	ok

	_cMarquerChar = c

	#NOTE // A marquer char can be set at the global level or string object level

	func SetDefaultMarquerChar()
		_cMarquerChar = c

	func @SetMarquerChar()
		_cMarquerChar = c

	func SetMarquer()
		_cMarquerChar = c

	func @SetMarquer()
		_cMarquerChar = c

  /////////////////
 ///   CLASS   ///
/////////////////

class stzString from stzObject

	@oQString
	@cMarquer = DefaultMarquerChar()

	@aConstraints = []

	@cLanguage = :English	# Set explicitly using SetLanguage()
				#TODO (future): Infere the language from the string

	// Initializes the content of the softanza string object
	def init(pcStr)

		if CheckParams()
			if NOT ( isString(pcStr) or @IsQString(pcStr) or
				 (isList(pcStr) and Q(pcStr).IsPairOfStrings()) )

				StzRaise("Can't create the stzString object! pcStr must be a string, a QString object, or a pair of strings.")
			ok

			if IsQString(pcStr)
				@oQString = pcStr
				return

			but isList(pcStr) and Q(pcStr).IsPairOfStrings() # Named string
				@cVarName = pcStr[1] # Inherited from stzObject
				@oQString = new QString2()
				@oQString.append(pcStr[2])
				return
			ok

		ok

		@oQString = new QString2()
		@oQString.append(pcStr)

	  #==========================#
	 #   CHECKING CONSTRAINTS   #
	#==========================#
	#TODO: Generalize this feature to other classes

	def EnforcedConstraints()
		return @@aConstraints

		def Constraints()
			return This.EnforcedConstraints()

	def VerifyConstraint(pcConstraintName)

		@str = This.Content()

		cCondition = Constraints()[ :OnStzString ][ pcConstraintName ]

		if cCondition = NULL
			stzRaise("Inexsitant contraint!")
		ok

		CompileConstraint(cCondition)

		StzStringQ(cCondition) {

			ReplaceCS("@string", @str, :CS = FALSE)
			Simplify()
			RemoveTheseBounds("{", "}")

			cCondition = Content()
		}

		cCode  = 'bResult = ""+ (' + cCondition + ')'
		eval(cCode)

		if bResult = FALSE
			stzRaise([
				:Where = "stzString.ring > VerifyCondition()",
				:What  = "Execution is cancelled by Softanza",
				:Why   = "A constraint on the string object is not verified!",
				:Todo  = "Check that constraint (" + pcName + ") and adjust your logic accordingly ;)"

			])
		ok

	def VerifyConstraints()
		bResult = TRUE

		for aPair in This.Constraints()
			cConstraintName = aPair[1]
			This.VerifyConstraint(cConstraintName) = FALSE
			
		next

	  #=======================================#
	 #     GETTING CONTENT OF THE STRING     #
	#=======================================#

	// Returns the string's content
	def Content()

		return @oQString.left(@oQString.count())

		#< @FunctionFluentForm

		def ContentQ()
			return This

		#>

		#< @FunctionAlternativeForm

		def Value()
			return This.Content()

			def ValueQ()
				return This.ContentQ()
	
		def String()
			return This.Content()

			def StringQ() # Same as Copy()
				return new stzString( This.String() )

		#>

	def QStringObject()
		return @oQString

		def ToQStringObject()
			return This.QStringObject()

		def ToQString()
			return This.QStringObject()

	  #=======================================#
	 #  GETTING A COPY OF THE STRING OBJECT  #
	#=======================================#

	def Copy()
		return new stzString( This.String() )

	def ReversedCopy()
		return This.ReverseQ()

	  #========================================#
	 #  CHECKING IF THE STRING IS PALINDROME  #
	#========================================#

	def IsPalindromeCS(pCaseSensitive)
		if This.NumberOfChars() < 2
			return FALSE
		ok

		cReversed = This.Reversed()
		if This.IsEqualtToCS( cReversed, pCaseSensitive) = TRUE
			return TRUE
		else
			return FALSE
		ok


		def IsPalindromCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

		def IsMirroredCS(pCaseSensitive)
			return This.IsPalindromeCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsPalindrome()
		return This.IsPalindromeCS(TRUE)

		def IsPalindrom()
			return This.IsPalindrome()

		def IsMirrored()
			return This.ISPalindrome()

	  #==================================#
	 #  GETTING THE CASE OF THE STRING  #
	#==================================#

	def StringCase()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		if This.IsLowercase()
			return :Lowercase

		but This.IsUppercase()
			return :Uppercase

		but This.IsCapitalcase()
			return :Capitalcase

		but This.IsTitlecase()
			return :Titlecase

		but This.IsCaseFold()
			return :Casefold

		else
			return :Hybridcase
		ok

		#< @FunctionAlternativeForms

		def CharCase()
			return This.StringCase()

		def CharsCase()
			return This.StringCase()

		def Kase()
			return This.StringCase()

		def WordCase()
			return This.StringCase()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF THE STRING HAS THE SAME CASE AS AN OTHER GIVEN STRING  #
	#---------------------------------------------------------------------#

	def HasSameCaseAs(pcOtherStr)
		return This.CharCase() = StzStringQ(pcOtherStr).CharCase()

		def HasSameCharCaseAs(pcOtherStr)
			return This.HasSameCaseAs(pcOtherStr)

		#< @FunctionPassiveForm

		def HasDifferentCaseAs(pcOtherStr)
			return NOT This.HasSameCaseAs(pcOtherStr)

		def HasDifferentCharCase(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

		def HasNoSameCaseAs(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

			def HasNoSameCharCaseAs(pcOtherStr)
				return This.HasNoSameCaseAs(pcOtherStr)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING IS IN HYBRID CASE  #
	#--------------------------------------------#

	def IsHybridcase()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		bResult = Q( This.StringCase() ).IsNotOneOfThese([ StringCases() ])
		return bResult

		def IsHybridCased()
			return This.IsHybridcase()

	  #===========================================#
	 #   APPENDING THE STRING WITH A SUBSTRING   #
	#===========================================#

	def AppendWith(pcStr)

		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		cResult = This.String() + pcStr
		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def AppendWithQ(pcStr)
			This.AppendWith(pcStr)
			return This
	
		#>

		#< @FunctionAlternative

		def Append(pcStr)
			if isList(pcStr) and Q(pcStr).IsWithOrByNamedParam()
				pcStr = pcStr[2]
			ok

			This.AppendWith(pcStr)

			def AppendQ(pcStr)
				This.Append(pcStr)
				return This
	
		#>

	def AppendedWith(pcStr)
		cResult = This.Copy().AppendWithQ(pcStr).Content()
		return cResult

		def Appended(pcStr)
			cResult = This.Copy().AppendQ(pcStr).Content()
			return cResult

	  #-------------------------------------#
	 #   APPENDING THE STRING FROM START   #
	#-------------------------------------#

	def Prepend(pcOtherStr)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithOrByNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		cResult = pcOtherStr + This.String()
		This.Update( cResult )

		#< @FunctionFluentForm

		def PrpendQ(pcOtherStr)
			This.Prepend(pcOtherStr)
			return This
	
		#>

	def Prepended(pcOtherStr)
		return This.Copy().PrependQ(pcOtherStr).Content()

	  #=================================#
	 #  ADDING A SUBSTRING --EXTENDED  #
	#=================================#

	def AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("Ring programin language")
		o1.AddXT("g", :To = "programmin")

		? o1.Content()
		#--> Ring programming language
		*/

		if isList(pcSubStr)
			oSubStr = new stzList(pcSubStr)

			# Adding after

			if oSubStr.IsOneOfTheseNamedParams([ :After, :AfterEach, :To, :ToEach  ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after nth

			but oSubStr.IsOneOfTheseNamedParams([ :AfterNth, :ToNth ])
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]
				This.ReplaceNthCS(n, pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after first

			but oSubStr.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				pcSubStr = pcSubStr[2]
				This.ReplaceFirstCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after last

			but oSubStr.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				pcSubStr = pcSubStr[2]
				This.ReplaceLastCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after these/many

			but oSubStr.IsOneOfTheseNamedParams([ :AfterThese, :ToThese, :AfterMany, :toMany ])
				pcSubStr = pcSubStr[2]
				if NOT isList(pcSubStr)
					StzRaise("Incorrect param type! pcSubStr must be a list.")
				ok

				acTemp = []
				nLen = len(pcSubStr)
				for i = 1 to nLen
					acTemp + (pcSubStr[i] + pcNewSubStr)
				next

				This.ReplaceManyByManyCS(pcSubStr, acTemp, pCaseSensitive)

			#==

			# Adding before

			but oSubStr.IsOneOfTheseNamedParams([ :Before, :BeforeEach ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before nth

			but oSubStr.IsBeforeNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)
		
			# Adding before first

			but oSubStr.IsBeforeFirstNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before last

			but oSubStr.IsBeforeLastNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			#==

			# Adding around

			but oSubStr.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)

				else	
					This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around nth

			but oSubStr.IsAroundNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok
		
			# Adding around first

			but oSubStr.IsAroundFirstNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around last

			but oSubStr.IsAroundLastNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			ok

		ok

		def AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def AddedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def AddXT(pcNewSubStr, pcSubStr)
		This.AddCSXTQ(pcNewSubStr, pcSubStr, TRUE)

		def AddXTQ(pcNewSubStr, pcSubStr)
			This.AddXT(pcNewSubStr, pcSubStr)
			return This

	def AddedXT(pcNewSubStr, pcSubStr)
		return This.Copy().AddXTQ(pcNewSubStr, pcSubStr).Content()

	   #--------------------------------------------------------------------#
	  #   ADDING A SUBSTRING AFTER A POSITION, MANY POSITIONS, A SECTION,  #
	 #   MANY SECTIONS, OR AFTER THE OCCURRENCES OF AN OTHER SUBSTRING    #
	#--------------------------------------------------------------------#

	#TODO
	# Add these functions

	def AddAfter()
		StzRaise("Function not yet implemented!")

	def AddAfterPosition()
		StzRaise("Function not yet implemented!")

	def AddAfterPositions()
		StzRaise("Function not yet implemented!")

	def AddAfterSection()
		StzRaise("Function not yet implemented!")

	def AddAfterSections()
		StzRaise("Function not yet implemented!")

	def AddAfterSubString()
		StzRaise("Function not yet implemented!")

	def AddAfterSubStrings()
		StzRaise("Function not yet implemented!")

	def AddAfterNthOccurrenceOfSubString()
		StzRaise("Function not yet implemented!")

	def AddAfterTheseOccurrencesOfSubString()
		StzRaise("Function not yet implemented!")

	   #---------------------------------------------------------------------#
	  #   ADDING A SUBSTRING BEFORE A POSITION, MANY POSITIONS, A SECTION,  #
	 #   MANY SECTIONS, OR AFTER THE OCCURRENCES OF AN OTHER SUBSTRING     #
	#---------------------------------------------------------------------#

	#TODO
	# Add these functions

	def AddBefore()
		StzRaise("Function not yet implemented!")

	def AddBeforePosition()
		StzRaise("Function not yet implemented!")

	def AddBeforePositions()
		StzRaise("Function not yet implemented!")

	def AddBeforeSection()
		StzRaise("Function not yet implemented!")

	def AddBeforeSections()
		StzRaise("Function not yet implemented!")

	def AddBeforeSubString()
		StzRaise("Function not yet implemented!")

	def AddBeforeSubStrings()
		StzRaise("Function not yet implemented!")

	def AddBeforeNthOccurrenceOfSubString()
		StzRaise("Function not yet implemented!")

	def AddBeforeTheseOccurrencesOfSubString()
		StzRaise("Function not yet implemented!")

	   #--------------------------------------------------------------------#
	  #  ADDING A SUBSTRING AROUND A SECTION, MANY SECTIONS, A SUBSTRING,  #
	 #  OR MANY SUBSTRINGS (BOUNDING THEM WITH THE SUBSTRING)             #
	#--------------------------------------------------------------------#
	
	#TODO
	# Add these functions

	def AddAround()
		StzRaise("Function not yet implemented!")

	def AddAroundSection()
		StzRaise("Function not yet implemented!")

	def AddAroundSections()
		StzRaise("Function not yet implemented!")

	def AddAroundSubString()
		StzRaise("Function not yet implemented!")

	def AddAroundSubStrings()
		StzRaise("Function not yet implemented!")

	  #=================================================#
	 #  EXTENDING THE STRING WITH THE GIVEN SUBSTRING  #
	#=================================================#

	def ExtendWith(pSubStr)
		if CheckParams()
			if isList(pSubStr)
				This.ExtendWithMany(pSubStr)
				return
			ok
	
			if NOT isString(pSubStr)
				StzRaise("Incorrect param type! pSubStr must be a string.")
			ok
		ok

		This.AppendWith(pSubStr)

		#< @FunctionFluentForm

		def ExtendWithQ(pSubStr)
			This.ExtendWith(pSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithSubString(pSubStr)
			This.ExtendWith(pSubStr)

			def ExtendWithSubStringQ(pSubStr)
				This.ExtendWithSubString(pSubStr)
				return This

		#>

	def ExtendedWith(pSubStr)
		aResult = This.Copy().ExtendWithQ(pSubStr).Content()
		return aResult

		def ExtendedWithSubString(pSubStr)
			return This.ExtendedWith(pSubStr)

	  #---------------------------------------------#
	 #  EXTENDING THE STRING WITH MANY SUBSTRINGS  #
	#---------------------------------------------#

	def ExtendWithMany(pacSubStr)
		if CheckParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		This.AppendWith( QR(pacSubStr, :stzListOfStrings).Concatenated() )

		#< @FunctionFluentForm

		def ExtendWithManyQ(pacSubStr)
			This.ExtendWithMany(pacSubStr)

		#>

		#< @FunctionAlternativeForms

		def ExtendWithTheseSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithThese(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		#>

	def ExtendedWithMany(pacSubStr)
		cResult = This.Copy().ExtendWithManyQ(pacSubStr).Content()
		return cResult

		def ExtendedWithTheseSubStrings(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

		def ExtendedWithThese(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

	  #-----------------------------------#
	 #  EXTENDING THE STRING TO N CHARS  #
	#-----------------------------------#

	def ExtendToPosition(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nLen = This.NumberOfItems()

		This.AppendWith( Q(" ").RepeatedNTimes( n - nLen ) )
		
		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if CheckParams()
				if isList(n) and
				   ( Q(n).IsPositionNamedParam() or Q(n).IsToNCharsNamedParam() )
	
					n = n[2]
				ok
			ok

			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNChars(n)
			This.ExtendToPosition(n)
			
			def ExtendToNCharsQ(n)
				This.ExtendToNChars(n)
				return This

		def Extend(n)
			if CheckParams()
				if isList(n) and Q(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNChars ])
					n = n[2]
				ok
			ok

			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		cResult = This.Copy().ExtendToPositionQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNChars(n)
			return This.ExtendedToPosition(n)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToPositionWith(n, pcChar)

		if CheckParams()
			if isString(pcChar) and pcChar = :CharsRepeated
				This.ExtendToPositionWithCharsRepeated(n)
				return
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if NOT ( isString(pcChar) and Q(pcChar).IsChar() )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		nLen = This.NumberOfChars()

		if n > nLen
			This.AppendWith( Q(pcChar).RepeatedNTimes(n - nLen) )
		ok

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToWithQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsWithQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#--

		def ExtendToPositionUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToPositionUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToUsing(n, pcChar)
			This.ExtendToPositionUsing(n, pcChar)

			def ExtendToUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsUsingQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#--

		def ExtendToPositionBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToPositionByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToBy(n, pcChar)
			This.ExtendToPositionBy(n, pcChar)

			def ExtendToByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		def ExtendToNCharsBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
			def ExtendToNCharsByQ(n, pcChar)
				return This.ExtendToPositionWithQ(n, pcChar)

		#>


	def ExtendedToPositionWith(n, pcChar)
		cResult = This.Copy().ExtendToPositionWithQ(n, pcChar)
		return This

		#< @FunctionAlternativeForms

		def ExtendedToWith(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToNCharsWith(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)
			
		#--

		def ExtendedToPositionUsing(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToUsing(n, pcChar)
			This.ExtendToPositionUsing(n, pcChar)

		def ExtendedToNCharsUsing(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
		#--

		def ExtendedToPositionBy(n, pcChar)
			This.ExtendedToPositionWith(n, pcChar)

		def ExtendedToBy(n, pcChar)
			This.ExtendToPositionBy(n, pcChar)

		def ExtendedToNCharsBy(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			
		#>

		#< @FunctionMisspelledForm

		def ExtendtedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE STRING CHARS  #
	#--------------------------------------------------------------------------#

	def ExtendToPositionWithCharsRepeated(n)
		This.ExtendToPositionWithCharsIn(n, This.Chars())

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsRepeatedQ(n)
			This.ExtendToPositionWithCharsRepeated(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToWithCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		def ExtendToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToPositionByRepeadingCharsQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)


		def ExtendToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToByRepeatingCharsQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)


		#--

		def ExtendToByCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToByCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		def ExtendToUsingCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

			def ExtendToUsingCharsRepeatedQ(n)
				return This.ExtendToPositionWithCharsRepeatedQ(n)

		#>

	def ExtendedToPositionWithCharsRepeated(n)
		cResult = This.Copy().ExtendToPositionWithCharsRepeatedQ(n).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToWithCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToPositionByRepeadingChars(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToByRepeatingChars(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		#--

		def ExtendedToByCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		def ExtendedToUsingCharsRepeated(n)
			return This.ExtendedToPositionWithCharsRepeated(n)

		#>

	  #-------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE GIVEN CHARS  #
	#-------------------------------------------------------------------------#

	def ExtendToPositionWithCharsIn(n, pacChars)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if NOT ( isList(pacChars) and Q(pacChars).IsListOfChars() )
				StzRaise("Incorrect param type! pacChars must be a list or chars.")
			ok
		ok

		nLen = len(pacChars)
		nTemp = n - nLen

		cTemp = ""

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				cTemp += pacChars[j]
			next
		ok

		This.ExtendWith(cTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsInQ(n, pacChars)
			This.ExtendToPositionWithCharsIn(n, pacChars)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtendToWithCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToWithCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		def ExtendToByCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToByCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		def ExtendToUsingCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToUsingCharsInQ(n, pacChars)
				return This.ExtendToPositionWithCharsInQ(n, pacChars)

		#>

	def ExtendedToPositionWithCharsIn(n, pacChars)
		cResult = This.Copy().ExtendToPositionWithCharsInQ(n, pacChars).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedToWithCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		def ExtendedToByCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		def ExtendedToUsingCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToNCharsXT(n, pUsing)
		if isList(pUsing) and Q(pUsing).IsUsingOrByOrWithNamedParam()
			pUsing = pUsing[2]
		ok

		This.ExtendToNCharsUsing(n, pUsing)

		#< @FunctionFluentFom

		def ExtendToNCharsXTQ(n, pUsing)
			This.ExtendToNCharsXT(n, pUsing)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToNPositionsXT(n, pUsing)
			This.ExtendToNCharsXT(n, pUsing)

		#>

	def ExtendedToNCharsXT(n, pUsing)
		cResult = This.ExtendToNCharsXTQ(n, pUsing).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToNPositionsXT(n, pUsing)
			This.ExtendedToNCharsXT(n, pUsing)

		#>

	  #-----------------------------------------#
	 #  EXTENDING THE STRING - A GENERAL FORM  #
	#-----------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :With = "DE")
		o1.Show()
		#--> "ABCDE"

		EXAMPLE 2

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :ToPosition = 5 )
		o1.Show()
		#--> "ABCDE  "

		EXAMPLE 3

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
		o1.Show()
		#--> "ABCDEAB"

		EXAMPLE 4

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> "ABCDE**"

		EXAMPLE 5

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :WithCharsIn = [ "D", "E" ])
		o1.Show()
		#--> "ABCDEDE"

		EXAMPL 6

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToNChars = 7, :Withc = "." )
		o1.Show()
		#--> "ABC...."

		*/

		if isString(n) and n = :String

			# Case 1: o1.ExtendXT( :String, :With = "DE")
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		# Case ExtendXT( :ToNChars, 5 )
		but isString(n) and n = :ToNChars and isNumber(pWith)
			This.ExtendToPosition(n)

		# Case ExtendXT( :ToNChars = 5, :Using = "." )
		but isList(n) and Q(n).IsToNCharsNamedParam()
			if isList(pWith) and Q(pWith).IsUsingOrWithOrByNamedParam()
				pwith = pWith[2]
			ok

			if NOT isString(pWith)
				StzRaise("Incorrect param type! pWith must be a string.")
			ok

			This.ExtendToNCharsUsing(n[2], pWith)

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if isList(pWith) and Q(pWith).IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeated(n[2])
					#NOTE this is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    Q(pWith).IsOneOfThese([
				:ByRepeatingChars, :WithCharsItemsRepeated, :ByCharsRepeated ] )

				if isList(n) and Q(n).IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithCharsRepeated(n)
				return

			# Case 5: o1.ExtendXT( :ToPosition = 5, :WithCharsIn = "DE")
			but Q(pWith).IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

		#< @FunctionFluentForm
	
		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		cResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return cResult

	  #--------------------------------------------#
	 #  SHRINKING THE STRING TO A GIVEN POSITION  #
	#============================================#

	def ShrinkTo(n)
		if CheckParams()
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsNCharsNamedParam() )
	
				n = n[2]
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveSection( n+1, nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNCharsQ(n)
				This.ShrinkToNChars(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================#
	 #     LOWERCASING THE STRING    #
	#===============================#

	def ApplyLowercase() # Understand it as a verb, an action on main string!
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toLower(This.String()) )

		#< @FunctionFluentForm

	 	// Transforms the string to lowercase AND Returns the lowercased
		// stzString object to take other actions on it!
		def ApplyLowercaseQ() # Q for Queue -> a chain of actions
			This.ApplyLowercase()
			return This

		#>

		#< @FunctionAlternativeForm

		def Lowercase() # Understand it as a verb that "lowercases" the string
			This.ApplyLowercase()

			def LowercaseQ()
				This.Lowercase()
				return This
	
		#>

		#< @FunctionMisspelledForm

		def Lowcase()
			This.ApplyLowercase()

		def ApplyLowcase()
			This.ApplyLowercase()

		#>

	def Lowercased()
		cResult = This.Copy().LowercaseQ().Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedQ()
			if This.Lowercased()
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms
			
		def ToLowercase()
			return This.Lowercased()

			def ToLowercaseQ()
				if This.Lowercased()
					return This
				else
					return AFalseObject()
				ok
		#--

		def LowercaseB()
			return This.Lowercased()

			def LowercaseBQ()
				if This.Lowercased()
					return This
				else
					return AFalseObject()
				ok

		#>

	  #-------------------------------------------------#
	 #     LOWERCASING THE STRING IN A GIVEN LOCALE    #
	#-------------------------------------------------#

	// Tranforms the string to LOCALE-SENSITIVE lowercase
	def ApplyLowercaseInLocale(pcLocale)
		/*
		Apply the special cases documented in unicode here:
		--> http://unicode.org/Public/UNIDATA/SpecialCasing.txt

		*/

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToLowercase(This.String()) )

		#< @FunctionFluentForm

		def ApplyLowercaseInLocaleQ(pcLocale)
			This.ApplyLowercaseInLocale(pcLocale)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def LowercaseInLocale(pLocale) # Understand it as a verb that "lowercases" the string in the givan locale
			This.ApplyLowercaseInLocale(pLocale)

			def LowercaseInLocaleQ(pLocale)
				This.LowercaseInLocale(pLocale)
				return This
	
		#>

		#< @FunctionMisspelledForm

		def ApplyLowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)

		def LowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)
			
		#>

	def LowercasedInLocale(pcLocale)
		cResult = This.Copy().LowercaseInLocaleQ(pcLocale).Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedInLocaleQ(pLocale)
			return new stzString( This.LowercasedInLocale(pLocale) )

		#>

		#< @FunctionMisspelledForm

		def LowcasedInLocale(pcLocale)
			return This.LowercasedInLocale(pcLocale)

		#>

	  #----------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE  #
	#----------------------------------------#

	def IsLowercase()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		if This.Lowercased() = This.String()
			return TRUE
		else
			return FALSE
		ok


		#< @FunctionFluentForm

		def IsLowerercaseQ()
			if This.IsLowercase()
				return new stzString(This.Content())
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForm

		def IsLowercased()
			return This.IsLowercase()

			def IsLowercasedQ()
				return This.IsLowerercaseQ()

		def IsLower()
			return This.IsLowercase()

			def IsLowerQ()
				return This.IsLowerercaseQ()

		def IsInLowercase()
			return This.IsLowercase()

			def InLowercaseQ()
				return This.IsLowerercaseQ()

		def IsInALowercase()
			return This.IsLowercase()

			def IsInALowercasQ()
				return This.IsLowerercaseQ()

		#>

		#< @FunctionNegativeForms

		def IsNotLowercase()
			return NOT This.IsLowercase()

		def IsNotLowercased()
			return This.IsNotLowercase()

		def IsNotLower()
			return This.IsNotLowercase()

		def IsNotInLowercase()
			return This.IsNotLowercase()

		def IsNotInALowercase()
			return This.IsNotLowercase()

		#>

		#< @FunctionMisspelledForms

		def IsLowcased()
			return This.IsLowercase()

		def IsLowcase()
			return This.IsLowercase()

		def IsLowarcase()
			return This.IsLowercase()

		#--

		def InLowarcase()
			return This.IsLowercase()

		def InLowercase()
			return This.IsLowercase()

		#>

	  #----------------------------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE IN A GIVEN LOCALE  #
	#----------------------------------------------------------#

	def IsLowercaseInLocale(pLocale)
		bResult = StzLocaleQ(pLocale).StringLowercased(This.String()) = This.String() #TODO: replace with DefaultLocale
		return bResult

		#< @FunctionAlternativeForms

		def IsLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

		#< @FunctionMisspelledForm

		def IsLowcaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

	  #-------------------------------------------------------------#
	 #  CHECHINK IF THE STRING IS THE LOWERCASE OF A GIVEN STRING  #
	#-------------------------------------------------------------#

	def IsLowercaseOf(pcStr)
		return StzStringQ(pcStr).Lowercased() = This.String()

	def IsLowercaseOfXT(pcStr, paLocale)
		/* Example
		Q("many").IsLowercaseOfXT("MANY", :InThisLocale = "fr_FR")
		*/
	
		if NOT ( isList(paLocale) and len(paLocale) = 2 )
			stzRaise("Incorrect format!")
		ok
	
		if NOT isString(paLocale[1])
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( Q(paLocale[1]).IsOneOfThese([ :InThisLocale, :InLocale ]) )
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( isString(paLocale[2]) or (isList([paLocale[2]]) and len(paLocale[2]) = 2) )
			stzRaise("Incorrect format!")
		ok
	
		if isString(paLocale[2]) and NOT StzStringQ(paLocale[2]).IsLocaleAbbreviation()
			stzRaise("Incorrect format!")
		ok
	
		if isList(paLocale[2]) and NOT StzListQ(paLocale[2]).IsLocaleList()
			stzRaise("Incorrect format!")
		ok
	
		return Q(pcStr).LowercasedInLocale(paLocale[2]) = This.String()

	  #===============================#
	 #     UPPERCASING THE STRING    #
	#===============================#

	def ApplyUppercase()
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toUpper(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseQ()
			This.ApplyUppercase()
			return This
	
		#>

		#< @FunctionAlternativeForm

		def Uppercase() # Understand it as a verb that "uppercases" the string
			This.ApplyUppercase()

			def UppercaseQ()
				return This.ApplyUppercaseQ()

		def UppercaseIt()
			This.ApplyUppercase()

			def UppercaseItQ()
				return This.ApplyUppercaseQ()

		#>

		#< @FunctionFutureForms

		def UppercaseF()
			@AddFuture(:Uppercase)

			def UppercaseFQ()
				@AddFuture(:Uppercase)
				return This

		def UppercaseFF()
			@ExecuteFutureXT(This, FutureOrder())

			def UppercaseFFQ()
				@ExecuteFutureXT(This, FutureOrder())
				return This
		#--

		def UppercasingF(pcStr)
			@AddFuture(:Uppercase)

			def UppercasingFQ(pcStr)
				@AddFuture(:Uppercase)
				return new stzString(pcStr)

		def UppercasingFF(pcStr)
			@ExecuteFutureXT(This, FutureOrder())

			def UppercasingFFQ(pcStr)
				@ExecuteFutureXT(This, FutureOrder())
				return new stzString(pcStr)

		#>

	def Uppercased()
		return This.Copy().UppercaseQ().Content()

		#< @FunctionFluentForm

		def UppercasedQ()
			if This.IsUppercased()
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms
			
		def ToUppercase()
			return This.Uppercased()

				def ToUppercaseQ()
					if This.Uppercased()
						return This
					else
						return AFalseObject()
					ok
		#--

		def UppercaseB()
			return This.Uppercased()

			def UpperBQ()
				if This.Uppercased()
					return This
				else
					return AFalseObject()
				ok

		#>

	// Tranforms the string to LOCALE-SENSITIVE UPPERCase
	def ApplyUppercaseInLocale(pcLocale)

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToUpperCase(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseInLocaleQ(pcLocale)
			This.ApplyUppercaseInLocale(pcLocale)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseInLocale(pLocale) # Understand it as a verb that "uppercases" the string in the givan locale
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInLocaleQ(pLocale)
				This.ApplyUppercaseInLocale(pLocale)
				return This
	
		def LocaleUppercase(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def LocaleUppercaseQ(pLocale)
				This.LocaleUppercase(pLocale)
				return This

		def UppercaseIn(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInQ(pLocale)
				This.UppercaseIn(pLocale)
				return This

		#>

	def UppercasedInLocale(pLocale)
		return This.Copy().UppercaseInLocaleQ(pLocale).Content()

		#< @FunctionAlternativeForms

		def LocaleUppercased(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercasedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		def toLocaleUppercase(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercadedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		#>

	def IsUppercase()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		if This.Uppercased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionFluentForm
		# Useful in Natural-Coding, like for example:
		# Q("RING").IsAStringQ().WichQ().IsUppercaseQ().AndQ().ContainingQ(TheLetter("I"))
		#--> TRUE

		def IsUpperercaseQ()
			if This.IsUppercase()
				return new stzString(This.Content())
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsUppercased()
			return This.IsUppercase()

			def IsUppercasedQ()
				return This.IsUpperercaseQ()

		def IsUpper()
			return This.IsUppercase()

			def IsUpperQ()
				return This.IsUpperercaseQ()

		def IsInUppercase()
			return This.IsUppercase()

			def IsInUppercaseQ()
				return This.IsUpperercaseQ()

		def InUppercase()
			return This.IsUppercase()

			def InUppercaseQ()
				return This.IsUpperercaseQ()

		#>

		#< @FunctionFutureForms

		def IsUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsIsUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsUppercasedF()
			@AddFutureXT(:Uppercase, @FutureOrder())
		
			def IsUppercasedFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsUpperF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsUpperFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def IsInUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())

			def IsInUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#--

		def InUppercaseF()
			@AddFutureXT(:Uppercase, @FutureOrder())
	
			def IsUppercaseFQ()
				@AddFutureXT(:Uppercase, @FutureOrder())
				return This
	
		#>

	def IsUppercaseInLocale(pLocale)

		if This.UppercasedInLocale(pLocale) = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsUppercasedInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#--

		def IsUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUppercasedIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#>

	def IsUppercaseOf(pcStr)
		return Q(pcStr).UppercaseQ().IsEqualTo(This.Content())

	def IsUppercaseOfInLocale(pcStr, pLocale)
		return This.UppercasedInLocale(pLocale) = pcStr

	  #---------------------------------------#
	 #  UPPERCASING A SECTION IN THE STRING  #
	#=======================================#

	def UppercaseSection(n1, n2)
		cUpper = This.SectionQ(n1, n2).Uppercased()
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionQ(n1, n2)
			This.UppercaseSection(n1, n2)
			return This

	def SectionUppercased(n1, n2)
		cResult = This.Copy().UppercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInUppercase(n1, n2)
			return This.SectionUppercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def UppercaseSectionInLocale(n1, n2, pLocale)
		cUpper = This.SectionQ(n1, n2).UppercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionInLocaleQ(n1, n2, pLocale)
			This.UppercaseSection(n1, n2)
			return This

		def UppercaseSectionIn(n1, n2, pLocale)
			return This.UppercaseSectionInQ(n1, n2, pLocale)

			def UppercaseSectionInQ(n1, n2, pLocale)
				This.UppercaseSectionIn(n1, n2)
				return This

	def SectionUppercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().UppercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInUppercaseInLocale(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionUppercasedIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionInUppercaseIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  UPPERCASING MANY SECTIONS IN THE STRING  #TODO: Check for performance!
	#-------------------------------------------#

	def UppercaseSections(anSections)
		if CheckParams()
			if NOT (isList(anSections) and Q(anSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(anSections)

		for i = 1 to nLen
			cUpper = This.SectionQ(anSections[i][1], anSections[i][2]).Uppercased()
			This.ReplaceSection(anSections[i][1], anSections[i][2], cUpper)
		next

		def UppercaseSectionsQ(anSections)
			This.UppercaseSections(anSections)
			return This

	def SectionsUppercased(anSections)
		cResult = This.Copy().UppercaseSectionsQ(anSections).Content()
		return cResult

		def SectionsInUppercase(anSections)
			return This.SectionsUppercased()

	#-- WITH LOCALE SENSITIVITY

	def UppercaseSectionsInLocale(anSections, pLocale)
		if CheckParams()
			if NOT (isList(anSections) and Q(anSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(anSections)

		for i = 1 to nLen
			cUpper = This.SectionQ(anSections[i][1], anSections[i][2]).UppercasedInLocale(pLocale)
			This.UppercaseSection(anSections[i][1], anSections[i][2], cUpper)
		next

		def UppercaseSectionsInLocaleQ(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)
			return This

		def UppercaseSectionsIn(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)

			def UppercaseSectionsInQ(anSections, pLocale)
				This.UppercaseSectionsIn(anSections, pLocale)
				return This

	def SectionsUppercasedInLocale(anSections, pLocale)
		cResult = This.Copy().UppercaseSectionsInLocaleQ(anSections, pLocale).Content()
		return cResult

		def SectionsInUppercaseInLocale(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsUppercasedIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsInUppercaseIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

	  #---------------------------------------#
	 #  LOWERCASING A SECTION IN THE STRING  #
	#=======================================#

	def LowercaseSection(n1, n2)
		cLower = This.SectionQ(n1, n2).Lowercased()
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionQ(n1, n2)
			This.LowercaseSection(n1, n2)
			return This

	def SectionLowercased(n1, n2)
		cResult = This.Copy().LowercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInLowercase(n1, n2)
			return This.SectionLowercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def LowercaseSectionInLocale(n1, n2, pLocale)
		cLower = This.SectionQ(n1, n2).LowercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionInLocaleQ(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)
			return This

		def LowercaseSectionIn(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)

			def LowercaseSectionInQ(n1, n2, pLocale)
				This.LowercaseSectionIn(n1, n2, pLocale)
				return This

	def SectionLowercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().LowercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInLowercaseInLocale(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionLowercasedIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionInLowercaseIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  LOWERCASING MANY SECTIONS IN THE STRING  #TODO: Check for performance!
	#-------------------------------------------#

	def LowercaseSections(paSections)
		if CheckParams()
			if NOT (isList(paSections) and Q(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)

		for i = 1 to nLen
			cLower = This.SectionQ(paSections[i][1], paSections[i][2]).Lowercased()
			This.ReplaceSection(paSections[i][1], paSections[i][2], cLower)
		next

		def LowercaseSectionsQ(paSections)
			This.LowercaseSections(paSections)
			return This

	def SectionsLowercased(paSections)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercase(paSections)
			return SectionsLowercased(paSections)

	#-- WITH LOCALE SENSITIVITY

	def LowercaseSectionsInLocale(paSections, pLocale)
		if CheckParams()
			if NOT (isList(paSections) and Q(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)

		for i = 1 to nLen
			cLower = This.SectionQ(paSections[i][1], paSections[i][2]).LowercasedInLocale(pLocale)
			This.LowercaseSection(paSections[i][1], paSections[i][2], cLower)
		next

		def LowercaseSectionsInLocaleQ(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)
			return This

		def LowercaseSectionsIn(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)

			def LowercaseSectionsInQ(paSections, pLocale)
				This.LowercaseSectionsIn(paSections, pLocale)
				return This

	def SectionsLowercasedInLocale(paSections, pLocale)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercaseInLocale(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsLowercasedIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsInLowercaseIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

	  #-----------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def UppercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSections(aSections)

		#< @FunctionFluentForm

		def UppercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.UppercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseCSXT(pcSubStr, pCaseSensitive)
			This.UppercaseSubStringCS(pcSubStr, pCaseSensitive)

			def UppercaseCSXTQ(pcSubStr, pCaseSensitive)
				return This.UppercaseSubStringCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringUppercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubString(pcSubStr)
		This.UppercaseSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluetForm

		def UppercaseSubStringQ(pcSubStr)
			This.UppercaseSubStringCSQ(pcSubStr, TRUE)

		#>

		#< @FunctionAlternativeForms

		def UppercaseXT(pcSubStr)
			This.UppercaseSubString(pcSubStr)

			def UppercaseXTQ(pcSubStr)
				return This.UppercaseSubStringQ(pcSubStr)

		#>

	def SubStringUppercased(pcSubStr)
		cResult = This.Copy().UppercaseSubStringQ(pcStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

		def SubStringInUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSectionsInLocale(aSections, pLocale)

		#< @FunctionFluentForm

		def UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def UppercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

		def UppercaseInCSXT(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def UppercaseInCSXTQ(pcSubStr, pLocale, pCaseSensitive)
				return This.UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringUppercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubStringInLocale(pcSubStr, pLocale)
		This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, TRUE)

		#< @FunctionFluentForm

		def UppercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, TRUE)

		#>

		#< @FunctionAlternativeForms

		def UppercaseSubStringIn(pcSubStr, pLocale)
			This.UppercaseSubStringInLocale(pcSubStr, pLocale)

			def UppercaseSubStringInQ(pcSubStr, pLocale)
				This.UppercaseSubStringIn(pcSubStr, pLocale)
				return This

		def UppercaseInXT(pcSubStr, pLocale)
			This.UppercaseSubStringInLocale(pcSubStr, pLocale)

			def UppercaseInXTQ(pcSubStr, pLocale)
				return This.UppercaseSubStringInLocaleQ(pcSubStr, pLocale)

		#>

	#-- @FunctionPassiveForms

	def SubStringUppercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().UppercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringToUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		#>

	  #-----------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def LowercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSections(aSections)

		#< @FunctionAlternativeForms

		def LowercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.LowercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def LowercaseCSXT(pcSubStr, pCaseSensitive)
			This.LowercaseSubStringCS(pcSubStr, pCaseSensitive)

			def LowercaseCSXTQ(pcSubStr, pCaseSensitive)
				return This.LowercaseSubStringCSQ(pcSubStr, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringLowercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubString(pcSubStr)
		This.LowercaseSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def LowercaseSubStringQ(pcSubStr)
			This.LowercaseSubStringCSQ(pcSubStr, TRUE)

		#>

		#< @FunctionAlternativeForm

		def LowercaseXT(pcSubStr)
			This.LowercaseSubString(pcSubStr)

			def LowercaseXTQ(pcSubStr)
				return This.LowercaseSubStringQ(pcSubStr)

		#>

	#-- @FunctionPassiveForm

	def SubStringLowercased(pcSubStr)
		cResult = This.Copy().LowercaseSubStringQ(pcStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

		def SubStringInLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSectionsInLocale(aSections, pLocale)

		#< @FunctionFluentForm

		def LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def LowercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

		def LowercaseInCSXT(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def LowercaseInCSXTQ(pcSubStr, pLocale, pCaseSensitive)
				return This.LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringLowercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubStringInLocale(pcSubStr, pLocale)
		This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, TRUE)

		#< @FunctonFluentForm

		def LowercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, TRUE)

		#>

		#< @FunctionAlternativeForms

		def LowercaseSubStringIn(pcSubStr, pLocale)
			This.LowercaseSubStringInLocale(pcSubStr, pLocale)

			def LowercaseSubStringInQ(pcSubStr, pLocale)
				This.LowercaseSubStringIn(pcSubStr, pLocale)
				return This

		def LowercaseInXT(pcSubStr, pLocale)
			This.LowercaseSubStringInLocale(pcSubStr, pLocale)

			def LowercaseInXTQ(pcSubStr, pLocale)
				return This.LowercaseSubStringInLocaleQ(pcSubStr, pLocale)
		#>

	#-- @FunctionPassiveForm

	def SubStringLowercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().LowercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringToLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringLowercasedIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		#>

	  #================================#
	 #     CAPITALIZING THE STRING    #
	#================================#

	def ApplyCapitalcase()
		if This.IsEmpty()
			return
		ok

		# Getting the positions of the words in the string
		#TODO: delegate the work to stzText when ready

		anPos = This.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]
		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)

		ok

		nLen = len(anPos)

		for i = 1 to nLen
			cCapChar = This.CharQ(anPos[i]).Uppercased()
			This.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		#< @FunctionFluentForm

		def ApplyCapitalcaseQ()
			This.ApplyCapitalcase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Capitalcase() # Understand it as a verb that "capitalcases" the string
			This.ApplyCapitalcase()

			def CapitalcaseQ()
				This.Capitalcase()
				return This

		def Capitalise()
			This.ApplyCapitalcase()

			def CapitaliseQ()
				This.Capitalise()
				return This

		def Capitalize()
			This.ApplyCapitalcase()

			def CapitalizeQ()
				This.Capitalize()
				return This

		#>	
	
	def CapitalCased()
		return This.Copy().ApplyCapitalCaseQ().Content()

		def CapitalCaseApplied()
			return This.CapitalCased()

		def Capitalised()
			return This.CapitalCased()

		def Capitalized()
			return This.CapitalCased()

		def ToCapitalCase()
			return This.CapitalCased()

		def InCapitalCase()
			return This.CapitalCased()

	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyCapitalCaseInLocale(pLocale)
		# Lowercasing all the string first

		oStr = This.Copy().LowercaseQ()

		# Getting the positions of the words in the string
		#TODO: delegate the work to stzText when ready

		anPos = oStr.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]

		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)
			anPos = ring_sort(anPos)
		ok

		nLen = len(anPos)

		for i = 1 to nLen
			
			cCapChar = oStr.CharAtPositionQR(anPos[i], :stzString).
						UppercasedInLocale(pLocale)

			oStr.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		This.Update( oStr.Content() )

		#< @FunctionFluentForm

		def ApplyCapitalcaseInLocaleQ(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def CapitalcaseInLocale(pLocale) # Understand it as a verb that "capitalcases" the string in the givan locale
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInLocaleQ(pLocale)
				This.CapitalcaseInLocale(pLocale)
				return This

		def CapitaliseInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInLocaleQ(pLocale)
				This.CapitaliseInLocale(pLocale)
				return This

		def CapitalizeInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInLocaleQ(pLocale)
				This.CapitalizeInLocale(pLocale)
				return This
		#--

		def ApplyCapitalCaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def ApplyCapitalCaseInQ(pLocale)
				This.ApplyCapitalCaseIn(pLocale)
				return This

		def CapitalcaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInQ(pLocale)
				This.CapitalcaseIn(pLocale)
				return This

		def CapitaliseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInQ(pLocale)
				This.CapitaliseIn(pLocale)
				return This

		def CapitalizeIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInQ(pLocale)
				This.CapitalizeIn(pLocale)
				return This

		#>
		
	def CapitalCasedInLocale(pLocale)
		return This.Copy().CapitalCaseInLocaleQ(pLocale).Content()

		#< @FunctionFluentForm

		def CapitalcasedInLocaleQ()
			return new stzString( This.CapitalCasedInLocale() )

		#>

		#< @FunctionAlternativeForms

		def CapitalisedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def CapitalizedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseIn(pLocale)
			return CapitalcasedInLocale(pLocale)

		#>

	def IsCapitalcase()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		if This.CapitalCased() = This.String()
			return TRUE
		else
			return FALSE
		ok
		
		#< @FunctionAlternativeForms

		def IsCapitalCased()
			return This.IsCapitalcase()

		def IsCapitalised()
			return This.IsCapitalcase()

		def IsCapitalized()
			return This.IsCapitalcase()

		def IsInCapitalcase()
			return This.IsCapitalcase()

		#>

	def IsCapitalcaseOf(pcStr)
		return This.Capitalcased() = pcStr

	def IsCapitalcaseOfInLocale(pcStr, pLocale)
		return This.CapitalcasedInLocale(pLocale) = pcStr

		def IsCapitalcaseOfIn(pcStr, pLocale)
			return This.IsCapitalcaseOfInLocale(pcStr, pLocale)

	  #=============================#
	 #   TITLECASING THE STRING    #
	#=============================#

	def ApplyTitlecase()
		oLocale = new stzLocale( "C" )
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseQ()
			This.ApplyTitlecase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Titlecase() # Understand it as a verb that "titlecases" the string
			This.ApplyTitleCase()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def Titelise()
			This.ApplyTitleCase()

			def TiteliseQ()
				This.Titelise()
				return This

		def Titelize()
			This.ApplyTitleCase()

			def TitelizeQ()
				This.Titelize()
				return This
		#>	

	def TitleCased()
		return This.Copy().ApplyTitleCaseQ().Content()

		def Titelised()
			return This.TitleCased()
	
		def Titelized()
			return This.TitleCased()

		def InTitlecase()
			return This.TitleCased()
	
	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyTitlecaseInLocale(pLocale)
		oLocale = new stzLocale(pLocale)
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseInLocaleQ(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def TitlecaseInLocale(pLocale) # Understand it as a verb that "titlecases" the string in the givan locale
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInLocaleQ(pLocale)
				This.TitlecaseInLocale(pLocale)
				return This
		
		def TiteliseInLocale(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInLocaleQ(pLocale)
				This.TiteliseInLocale(pLocale)
				return This

		def TitelizeInLocale(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInLocaleQ(pLocale)
				This.TitelizeInLocale(pLocale)
				return This

		#--

		def ApplyTitlecaseInLocaleIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def ApplyTitlecaseInLocaleInQ(pLocale)
				This.ApplyTitlecaseInLocaleIn(pLocale)
				return This

		def TitlecaseIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInQ(pLocale)
				This.TitlecaseIn(pLocale)
				return This
		
		def TiteliseIn(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInQ(pLocale)
				This.TiteliseIn(pLocale)
				return This

		def TitelizeIn(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInQ(pLocale)
				This.TitelizeIn(pLocale)
				return This

		#>
			
	def TitlecasedInLocale(pLocale)
		return This.Copy().TitleCaseInLocaleQ(pLocale).Content()

		def TitlecasedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)


	def IsTitlecase()
		if NOT This.ContainsLatinLetters()
			return NULL
		ok

		if This.TitleCased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsTitlecased()
			return This.IsTitlecase()

		def IsTitelised()
			return This.IsTitlecase()

		def IsTitelized()
			return This.IsTitlecase()

		def IsInTitlecase()
			return This.IsTitlecase()

		#>

	def IsTitlecaseOf(pcStr)
		return This.Titlecased() = pcStr

	  #================================#
	 #    CASEFOLDING THE STRING      #
	#================================#

	/*
	INFO
	----

	The casefold() method is an aggressive lower() method which
	converts strings to case folded strings for caseless matching.
	
	WARNING:
	--------

	Review the Qt behaviour regarding QString.toCaseFolded() method.

	In fact, when writing:

	? StzStringQ("der Flu").CaseFolded()

	We should have as result:

	"der fluss"

	since "" is casefolded to "ss" in german.

	But, Qt don't do that!
	
	*/

	// Transforms the string to casefolded style
	def CaseFold() # Understand it as a verb that "casefolds" the string
		This.Update( This.CaseFolded() )

		#< @FunctionFluentForm

		def CaseFoldQ()
			This.CaseFold()
			return This
	
		#>

	def CaseFolded()
		return @oQString.toCasefolded()

	def IsCaseFolded()
		if NOT This.ContainsLatinLetters()
			return NULL

		ok

		if This.Copy().CaseFolded() = This.Content()
			return TRUE
		else
			return FALSE
		ok

		return bResult

		#< @FunctionAlternativeForm

		def IsCaseFold()
			return This.IsCaseFolded()

		#>

	def IsCaseFoldedOf(pcStr)
		return This.CaseFolded() = pcStr

	  #================================#
	 #   CHECKING IF STRING IS WORD   #
	#================================#
	#TODO: should move to stzText

	def IsWord()

		if This.IsEmpty() or This.IsNumberInString()
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsNotLetter() and
			   oChar.IsNotNumber() and
			   c != HyphenShort() and
			   c != HyphenLong() and
			   c != Underscore() and
			   oChar.IsNotArabic7arakah() and
			   c != ArabicTamdeed()

				bResult = FALSE
				exit
			ok

		next

		return bResult

	def IsArabicWord()
		bResult = This.ToStzText().IsArabicWord()
		return bResult

	def IsLatinWord()
		bResult = This.ToStzText().IsLatinWord()
		return bResult

	  #-------------------------------------#
	 #   CHECKING IF STRING IS STOPWORD    #
	#-------------------------------------#
	#TODO: Should move to stzText

	def IsStopWord()
		return StopWordsQ().Contains(This.Lowercased())

	def IsStopWordIn(pcLang)
		bResult = This.ToStzText().IsStopWordIn(pcLang)
		return bResult

	def LanguageIfStopWord()
		cResult = This.ToStzText().LanguageIfStopWord()
		return cResult

	  #===================================================#
	 #  NUMBER OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#===================================================#

	def NumberOfSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return 0
		ok

		# Resolving pCaseSensitive

		if CheckParams()

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if isString(pCaseSensitive)
				if Q(pCaseSensitive).IsOneOfThese([
					:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])
	
					pCaseSensitive = TRUE
				
				but Q(pCaseSensitive).IsOneOfThese([
					:CaseInSensitive, :NotCaseSensitive, :NotCS,
					:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])
	
					pCaseSensitive = FALSE
				ok
	
			ok
	
			if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
				stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
			ok
		ok

		# Doing the job

		nResult = 0

		if pCaseSensitive = TRUE
			n = This.NumberOfChars()
			nResult = n * (n + 1) / 2
	
		else
			#TODO (Future): Think of a numeric solution
			acSubStrCS = This.SubStringsCS(FALSE)
			nResult = len(acSubStrCS)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def HowManySubstringsCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		def HowManySubstringCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStrings()
		return This.NumberOfSubStringsCS(TRUE)

		#< @FunctionAlternativeForms

		def HowManySubstrings()
			return This.NumberOfSubStrings()

		def HowManySubstring()
			return This.NumberOfSubStrings()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#=============================================================#

	def SubStringsCS(pCaseSensitive)
		#NOTE: Got help from Google Bard for the basic algorithm used here

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )

				if pCaseSensitive = TRUE
					acResult + cSubStr

				else

					if ring_find(acResult, cSubStr) = 0
						acResult + cSubStr
					ok
				ok
			next
		next
		
		 return acResult


		#< @FunctionFluentForm

		def SubStringsCSQ(pCaseSensitive)
			return This.SubStringsCSQR(pCaseSensitive, :stzList)

		def SubStringsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStrings()
		return This.SubStringsCS(TRUE)

		#< @FunctionFluentForm

		def SubStringsQ()
			return This.SubStringsQR(:stzList)

		def SubStringsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStrings() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------#
	 #  LIST OF UNIQUE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------#

	def UniqueSubStringsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen
				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
	
				if ring_find(acResult, cSubStr) = 0
					acResult + cSubStr
				ok

			next
		next

		return acResult

		def SubStringsCSU(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

		def SubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStrings()
		return This.UniqueSubStringsCS(TRUE)

		def SubStringsU()
			return This.UniqueSubStrings()

		def SubStringsWithoutDuplication()
			return This.UniqueSubStrings()

	  #---------------------------------------------#
	 #  NUMBER OF UNIQUE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------#

	def NumberOfUniqueSubStringsCS(pCaseSensitive)
		return len( This.UniqueSubStringsCS(pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfSubStringsCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringsCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringCSU(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#--

		def NumberOfSubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStrings()
		return This.NumberOfUniqueSubStringsCS(TRUE)

		#< @FunctionAlternativeForms

		def NumberOfSubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstrings()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstring()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringU()
			return This.NumberOfUniqueSubStrings()

		#--

		def NumberOfSubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		#>

	  #----------------------------------------------------------#
	 #  POSITIONS OF ALL THE POSSIBLE SUBSTRINGS IN THE STRING  #
	#==========================================================#

	def FindAllSubStringsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		anResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				if pCaseSensitive = TRUE
					if ring_find(anResult, i) = 0
						anResult + i
					ok
					acSubStr + cSubStr
				else

					if ring_find(acSubStr, cSubStr) = 0
						if ring_find(anResult, i) = 0
							anResult + i
						ok
						acSubStr + cSubStr
					ok
				ok
			next
		next
		
		 return anResult

		#< @FunctionAlternativeForms

		def FindAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def AllSubStringsPositionsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#--

		def FindAllSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def AllSubStringsPositionsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#==

		def FindSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfPossibleSubStringsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def SubStringsPositionsCS(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#--

		def FindSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def FindPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def PositionsOfPossibleSubStringsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		def SubStringsPositionsCSZ(pCaseSensitive)
			return This.FindAllSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllSubStrings()
		return This.FindSubStringsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindAllPossibleSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfAllSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfAllPossibleSubStrings()
			return This.FindAllSubStrings()

		def AllSubStringsPositions()
			return This.FindAllSubStrings()

		#--

		def FindAllSubStringsZ()
			return This.FindAllSubStrings()

		def FindAllPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfAllSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfAllPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def AllSubStringsPositionsZ()
			return This.FindAllSubStrings()

		#==

		def FindSubStrings()
			return This.FindAllSubStrings()

		def FindPossibleSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfSubStrings()
			return This.FindAllSubStrings()

		def PositionsOfPossibleSubStrings()
			return This.FindAllSubStrings()

		def SubStringsPositions()
			return This.FindAllSubStrings()

		#--

		def FindSubStringsZ()
			return This.FindAllSubStrings()

		def FindPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfSubStringsZ()
			return This.FindAllSubStrings()

		def PositionsOfPossibleSubStringsZ()
			return This.FindAllSubStrings()

		def SubStringsPositionsZ()
			return This.FindAllSubStrings()

		#>

	   #------------------------------------------------------------#
	  #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	 #   THE STRING AND RETURNING THEM AS SECTIONS                #
	#------------------------------------------------------------#

	def FindAllSubStringsAsSectionsCS(pCaseSensitive)
		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				if pCaseSensitive = TRUE
					aResult + [ i, j ]
					acSubStr + cSubStr
				else

					if ring_find(acSubStr, cSubStr) = 0
						aResult + [ i, j ]
						acSubStr + cSubStr
					ok
				ok
			next
		next
		
		 return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#--

		def FindSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindAllSubStringsAsSectionsCS(pCaseSensitive)

		def FindSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindPossibleSubStringsCSZZ(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllSubStringsAsSections()
		return This.FindAllSubStringsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsZZ()
			return This.FindSubStringsAsSections()

		def FindAllPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def FindAllPossibleSubStringsZZ()
			return This.FindSubStringsAsSections()

		#--

		def FindSubStringsAsSections()
			return This.FindAllSubStringsAsSections()

		def FindSubStringsZZ()
			return This.FindSubStringsAsSections()

		def FindPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def FindPossibleSubStringsZZ()
			return This.FindSubStringsAsSections()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING ALL POSSIBLE SUBSTRINGS IN THE STRINGS VERIFYING A GIVEN CONDITION  #                  #
	#==============================================================================#

	def FindAllSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCS(pcCondition, pCaseSensitive)
		anResult = U( This.FindManyCS(acSubStrings, pCaseSensitive) )
		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		#--

		def FindWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsW(pcCondition)
		return This.FindAllSubStringsWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindAllPossibleSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		#--

		def FindSubStringsW(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindSubStringsWZ(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindPossibleSubStringsW(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		def FindPossibleSubStringsWZ(pcCondition)
			return This.FindAllSubStringsWCS(pcCondition)

		#--

		def FindW(pcCondition)
			return This.FindAllSubStringsW(pcCondition)

		#>


	  #----------------------------------------------------------------------------------------------#
	 #  FINDING ALL POSSIBLE SUBSTRINGS IN THE STRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #                  #
	#----------------------------------------------------------------------------------------------#

	def FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = U( This.FindManyCS(acSubStrings, pCaseSensitive) )
		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsWXT(pcCondition)
		return This.FindAllSubStringsWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindAllPossibleSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		#--

		def FindSubStringsWXT(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindPossibleSubStringsWXT(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		def FindPossibleSubStringsWXTZ(pcCondition)
			return This.FindAllSubStringsWCSXT(pcCondition)

		#--

		def FindWXT(pcCondition)
			return This.FindAllSubStringsWXT(pcCondition)

		#>

	    #------------------------------------------------------------#
	   #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	  #   THE STRING WHERE A GIVEN CONDITION IS VERIFIED AND       #
	 #   RETURNING THEM AS SECTIONS                               #
	#============================================================#

	def FindAllSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCS(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSubStrings, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		#--

		def FindWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		def FindAsSectionsWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsAsSectionsW(pcCondition)
		return This.FindAllSubStringsAsSectionsWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindAllPossibleSubStringsAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindAllPossibleSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#--

		def FindSubStringsAsSectionsW(pcCondition)
			return This.FindAllSubStringsAsSectionsW(pcCondition)

		def FindSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindPossibleSubStringsAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsWCS(pcCondition)

		def FindPossibleSubStringsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#--

		def FindWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		def FindAsSectionsWZZ(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#>

	    #------------------------------------------------------------#
	   #   FINDING ALL THE POSITIONS OF ALLPOSSIBLE SUBSTRINGS IN   #
	  #   THE STRING WHERE A GIVEN CONDITION IS VERIFIED AND       #
	 #   RETURNING THEM AS SECTIONS -- WXT/EXTENDED               #
	#============================================================#

	def FindAllSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
		acSubStrings = This.SubStringsWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSubStrings, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindAllPossibleSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindAllSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindPossibleSubStringsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#--

		def FindWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		def FindAsSectionsWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def FindAllSubStringsAsSectionsWXT(pcCondition)
		return This.FindAllSubStringsAsSectionsWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindAllPossibleSubStringsAsSectionsWXT(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindAllPossibleSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		#--

		def FindSubStringsAsSectionsWXT(pcCondition)
			return This.FindAllSubStringsAsSectionsWXT(pcCondition)

		def FindSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindPossibleSubStringsAsSectionsWXT(pcCondition)
			return This.FindSubStringsAsSectionsWCSXT(pcCondition)

		def FindPossibleSubStringsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		#--

		def FindWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		def FindAsSectionsWXTZZ(pcCondition)
			return This.FindSubStringsAsSectionsWXT(pcCondition)

		#>

	  #===============================================#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR POSITIONS  #
	#===============================================#
	#TODO : Check performance
	#UPDATE: Done

	def AllSubStringsCSZ(pCaseSensitive)

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				nPos = ring_find(acSubStr, cSubStr)
				if nPos = 0
					aResult + [ cSubStr, [ i ] ]
					acSubStr + cSubStr

				else
					aResult[nPos][2] + i
				ok

			next
		next
		
		 return aResult

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#--

		def SubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def SubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#== Adding U

		def AllSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#--

		def SubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def SubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsCSUZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def PossibleSubStringsAndTheirPositionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#== Adding Unique

		def UniqueSubStringsCSZ(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		def UniqueSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.AllSubStringsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AllSubStringsZ()
		return This.AllSubStringsCSZ(TRUE)

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsZ()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#--

		def SubStringsZ()
			return This.AllSubStringsZ()

		def SubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		def PossibleSubStringsZ()
			return This.AllSubStringsZ()

		def PossibleSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#== Adding U

		def AllSubStringsUZ()
			return This.AllSubStringsZ()

		def AllSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsUZ()
			return This.AllSubStringsZ()

		def AllPossibleSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		#--

		def SubStringsUZ()
			return This.AllSubStringsZ()

		def SubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		def PossibleSubStringsUZ()
			return This.AllSubStringsZ()

		def PossibleSubStringsAndTheirPositionsU()
			return This.AllSubStringsZ()

		#== Adding Unique

		def UniqueSubStringsZ()
			return This.AllSubStringsZ()

		def UniqueSubStringsAndTheirPositions()
			return This.AllSubStringsZ()

		#>

	  #----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR SECTIONS  #
	#----------------------------------------------#
	#TODO : Check performance
	#UPDATE: Done

	def AllSubStringsCSZZ(pCaseSensitive)

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		aResult = []
		acSubStr = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				nPos = ring_find(acSubStr, cSubStr)

				if nPos = 0
					aResult + [ cSubStr, [ [ i, j ] ] ]
					acSubStr + cSubStr

				else
					aResult[nPos][2] + [ i, j ]
				ok

			next
		next
		
		 return aResult

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#--

		def SubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def SubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#== Adding U

		def AllSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def AllPossibleSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#--

		def SubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def SubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsCSUZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def PossibleSubStringsAndTheirSectionsCSU(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#== Adding Unique

		def UniqueSubStringsCSZZ(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		def UniqueSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.AllSubStringsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AllSubStringsZZ()
		return This.SubStringsCSZZ(TRUE)

		#< @FunctionAlternativeForm

		def AllSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsZZ()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#--

		def SubStringsZZ()
			return This.AllSubStringsZZ()

		def SubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		def PossibleSubStringsZZ()
			return This.AllSubStringsZZ()

		def PossibleSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#== Adding U

		def AllSubStringsUZZ()
			return This.AllSubStringsZZ()

		def AllSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsUZZ()
			return This.AllSubStringsZZ()

		def AllPossibleSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		#--

		def SubStringsUZZ()
			return This.AllSubStringsZZ()

		def SubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		def PossibleSubStringsUZZ()
			return This.AllSubStringsZZ()

		def PossibleSubStringsAndTheirSectionsU()
			return This.AllSubStringsZZ()

		#== Adding Unique

		def UniqueSubStringsZZ()
			return This.AllSubStringsZZ()

		def UniqueSubStringsAndTheirSections()
			return This.AllSubStringsZZ()

		#>

	  #------------------------------------------------------#
	 #  GETTING THE LIST OF ALL SUBSTRINGS MADE OF N CHARS  #
	#======================================================#

	def SubStringsOfNCharsCS(n, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)


		for i = 1 to nLen
			for j = i to nLen
				if n = j-i+1
					cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
					acResult + cSubStr
				ok
			next
		next

		return acResult

		def SubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.SubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOfNChars(n)
		return This.SubStringsOfNCharsCS(n, TRUE)

		def SubStringsMadeOfNChars(n)
			return This.SubStringsOfNChars(n)

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-------------------------------------------------------------#

	def UniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Early check

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			cContent = ring_lower(cContent)
		ok

		QStringContent = new QString2()
		QStringContent.append(cContent)

		for i = 1 to nLen
			for j = i to nLen
				if n = j-i+1
					cSubStr = QStringContent.mid( (i - 1) , (j - i + 1) )
				
					if ring_find(acResult, cSubStr) = 0
						acResult + cSubStr
					ok
				ok
			next
		next

		return acResult

		#< @FunctionAlternativeForms

		def UniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsWithoutDuplicationMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#--

		def SubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsMadeOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def WithoutDuplicationMadeOfNCharsCSU(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESITIVITY

	def UniqueSubStringsOfNChars(n)
		return This.UniqueSubStringsOfNCharsCS(n, TRUE)

		#< @FunctionAlternativeForms

		def UniqueSubStringsMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsWithoutDuplicationMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		#--

		def SubStringsOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsMadeOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		def WithoutDuplicationMadeOfNCharsU(n)
			return This.UniqueSubStringsOfNChars(n)

		#>

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS MADE OF N CHARS  #
	#----------------------------------------------------#

	def NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.SubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsOfNChars(n)
		return This.NumberOfSubStringsOfNCharsCS(n, TRUE)

		def NumberOfSubStringsMadeOfNChars(n)
			return This.NumberOfSubStringsOfNChars(n)

	  #-----------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-----------------------------------------------------------#

	def NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfUniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManyUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#--

		def NumberOfSubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def NumberOfSubStringsMadeOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManySubStringsOfNCharsCSU(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsOfNChars(n)
		return This.NumberOfUniqueSubStringsOfNCharsCS(n, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfUniqueSubStringsMadeOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)
	
		def HowManyUniqueSubStringsOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		#--

		def NumberOfSubStringsOfNCharsU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		def NumberOfSubStringsMadeOfNCharsU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)
	
		def HowManySubStringsOfNCharsCU(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		#>

#TODO: Add these functions
# def FindSubStringsOfNChars()
# def FindSubStringsOfNCharsZZ()
# def SubStringsOfNCharsZ()
# def SubStringsOfNCharsZZ()

	  #----------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#================================================================#

	def NumberOfSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = len( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsW(pcCondition)
		return This.NumberOfSubStringsWCS(pcCondition, TRUE)

	  #-------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS VERIFYING A GIVEN CONDITION -- WX/EXTENDED  #
	#-------------------------------------------------------------------------------#

	def NumberOfSubStringsWCSXT(pcCondition, pCaseSensitive)
		nResult = len( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsWXT(pcCondition)
		return This.NumberOfSubStringsWCSXT(pcCondition, TRUE)

	  #-----------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#=======================================================================#

	def NumberOfUniqueSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = len( This.UniqueSubStringsWCS(pcCondition, pCaseSensitive) )
		return nResult

		def NumberOfSubStringsWCSU(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsW(pcCondition)
		return This.NumberOfUniqueSubStringsWCS(pcCondition, TRUE)

		def NumberOfSubStringsWU(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------------------#

	def NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)
		nResult = len( This.UniqueSubStringsWCSXT(pcCondition, pCaseSensitive) )
		return nResult

		def NumberOfSubStringsWCSXTU(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)

		def NumberOfSubStringsWCSUXT(pcCondition, pCaseSensitive)
			return This.NumberOfUniqueSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsWXT(pcCondition)
		return This.NumberOfUniqueSubStringsWCSXT(pcCondition, TRUE)

		def NumberOfSubStringsWXTU(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

		def NumberOfSubStringsWUXT(pcCondition)
			return This.NumberOfUniqueSubStringsW(pcCondition)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	#=====================================================================================#

	def SubStringsWCS(pcCondition, pCaseSensitive)
		acResult = This.SubStringsCSQ(pCaseSensitive).ItemsW(pcCondition)
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringsW(pcCondition)
		return This.SubStringsWCS(pcCondition, TRUE)

	  #-----------------------------------------------------------------------------------------------------#
	 #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------------------------#

	def SubStringsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SubStringsCSQ(pCaseSensitive).ItemsWXT(pcCondition)
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXT(pcCondition)
		return This.SubStringsWCSXT(pcCondition, TRUE)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR POSITIONS -- WZ/EXTENSION                                         #
	#=====================================================================================#

	def SubStringsWCSZ(pcCondition, pCaseSensitive)

		acSubStr = U( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		anPos = This.FindManyCS(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, anPos ])

		return aResult

		def SubStringsAndTheirPositionsWCS(pcCondition, pCaseSensitive)
			return This.SubStringsAndTheirPositionsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWZ(pcCondition)
		return This.SubStringsWCSZ(pcCondition, TRUE)

		def SubStringsAndTheirPositionsW(pcCondition)
			return This.SubStringsAndTheirPositionsW(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR POSITIONS -- WXTZ/EXTENSION                                       #
	#-------------------------------------------------------------------------------------#

	def SubStringsWCSXTZ(pcCondition, pCaseSensitive)

		acSubStr = U( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		anPos = This.FindManyCS(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, anPos ])

		return aResult

		def SubStringsAndTheirPositionsWCSXT(pcCondition, pCaseSensitive)
			return This.SubStringsAndTheirPositionsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXTZ(pcCondition)
		return This.SubStringsWCSXTZ(pcCondition, TRUE)

		def SubStringsAndTheirPositionsWXT(pcCondition)
			return This.SubStringsAndTheirPositionsWXT(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR SECTIONS -- WZZ/EXTENSION                                         #
	#=====================================================================================#

	def SubStringsWCSZZ(pcCondition, pCaseSensitive)

		acSubStr  = U( This.SubStringsWCS(pcCondition, pCaseSensitive) )
		aSections = This.FindManyCSZZ(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, aSections ])

		return aResult

		def SubStringsAndTheirSectionsWCS(pcCondition, pCaseSensitive)
			return This.SubStringsWCSZZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWZZ(pcCondition)
		return This.SubStringsWCSZZ(pcCondition, TRUE)

		def SubStringsAndTheirSectionsW(pcCondition)
			return This.SubStringsWZZ(pcCondition)

	   #-------------------------------------------------------------------------------------#
	  #  GETTING THE LIST OF POSSIBLE SUBSTRINGS IN THE STRING VERIFYING A GIVEN CONDITION  #
	 #  ALONG WITH THEIR SECTIONS -- WXZZ/EXTENSION                                        #
	#=====================================================================================#

	def SubStringsWCSXTZZ(pcCondition, pCaseSensitive)

		acSubStr  = U( This.SubStringsWCSXT(pcCondition, pCaseSensitive) )
		aSections = This.FindManyCSZZ(acSubStr, pCaseSensitive)
		aResult = @Association([ acSubStr, aSections ])

		return aResult

		def SubStringsAndTheirSectionsWCSXT(pcCondition, pCaseSensitive)
			return This.SubStringsWCSXTZZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsWXTZZ(pcCondition)
		return This.SubStringsWCSXTZZ(pcCondition, TRUE)

		def SubStringsAndTheirSectionsWXT(pcCondition)
			return This.SubStringsWXTZZ(pcCondition)

	  #----------------------------------------------------#
	 #  GETTING THE GIVEN SUBSTRINGS AND THEIR POSITIONS  #
	#====================================================#

	def TheseSubStringsCSZ(pacSubStr, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		aSubStrU = U( pacSubStr ) # U removes duplicates
		anPos = This.FindManyCS(aSubStrU, pCaseSensitive)
		aResult = @Association([ aSubStrU, anPos ])

		return aResult


		def TheseSubStringsAndTheirPositionsCS(pacSubStr, pCaseSensitive)
			return This.TheseSubStringsCSZ(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsZ(pacSubStr)
		return This.TheseSubStringsCSZ(pacSubStr, TRUE)

		def TheseSubStringsAndTheirPositions(pacSubStr)
			return This.TheseSubStringsZ(pacSubStr)

	  #---------------------------------------------------#
	 #  GETTING THE GIVEN SUBSTRINGS AND THEIR SECTIONS  #
	#---------------------------------------------------#

	def TheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		aSubStrU = U( pacSubStr ) # U removes duplicates
		anPos = This.FindManyCSZZ(aSubStrU, pCaseSensitive)
		aResult = @Association([ aSubStrU, anPos ])

		return aResult

		def TheseSubStringsAndTheirSectionsCS(pacSubStr, pCaseSensitive)
			return This.TheseSubStringsCSZZ(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsZZ(pacSubStr)
		return This.TheseSubStringsCSZZ(pacSubStr, TRUE)

		def TheseSubStringsAndTheirSections(pacSubStr)
			return This.TheseSubStringsZZ(pacSubStr)

	  #================================================#
	 #  FINDING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#================================================#

	def FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		aAntiSections = This.FindAntiSections(aSections)
		nLen = len(aAntiSections)

		anResult = []

		for i = 1 to nLen
			anResult + aAntiSections[1][1]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringsExceptCSZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindAllExceptCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindExceptCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		def FindAllButCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsExcept(pacSubStr)
		return This.FindSubStringsExceptCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringsExceptZ(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindSubStringsOtherThan(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindSubStringsOtherThanZ(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindExcept(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindAllExcept(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		def FindAllBut(pacSubStr)
			return This.FindSubStringsExcept(pacSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#==============================================================#

	def FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindAntiSections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindSubStringsOtherThanCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindExceptAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindAllExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindAllButCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSubStringsExceptAsSectionsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsExceptAsSections(pacSubStr)
		return This.FindSubStringsExceptAsSectionsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringsExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindSubStringsOtherThanAsSections(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindSubStringsOtherThanZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindExceptAsSections(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindAllExceptZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		def FindAllButZZ(pacSubStr)
			return This.FindSubStringsExceptAsSections(pacSubStr)

		#>

	  #------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#================================================#

	def SubStringsExceptCS(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def SubStringsExceptTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def OtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def OtherThanTheseCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExcept(pacSubStr)
		return This.SubStringsExceptCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringsExceptThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def SubStringsOtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def SubStringsOtherThanThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def Except(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def ExceptThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def OtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def OtherThanThese(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED ALONG WITH THEIR POSITIONS  #
	#===========================================================================#

	def SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acSubStr = This.Sections(aSections)

		anPos = []
		nLen = len(aSections)
		for i = 1 to nLen
			anPos + aSections[i][1]
		next

		aResult = Association([ acSubStr, anPos ])
		return aResult

		return acResult

		#< @FunctionAlternativeForms

		def SubStringsAndTheirPositionsExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZ(pacSubStr, pCaseSensitive)

		def SubStringsAndTheirPositionsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		def ExceptCSZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExceptZ(pacSubStr)
		return This.SubStringsExceptCSZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringsAndTheirPositionsExcept(pacSubStr)
			return This.SubStringsExceptZ(pacSubStr)

		def SubStringsOtherThanZ(pacSubStr)
			return This.SubStringsExceptZ(pacSubStr)

		def SubStringsAndTheirPositionsOtherThan(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		def ExceptZ(pacSubStr)
			return This.SubStringsExcept(pacSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING ALL SUBSTRINGS EXCEPT THOSE PROVIDED ALONG WITH THEIR SECTIONS  #
	#==========================================================================#

	def SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		acSubStr = This.Sections(aSections)

		aResult = Assocation([ acSubStr, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def SubStringsAndTheirSectionsExceptCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def SubStringsOtherThanCSZZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def SubStringsAndTheirSectionsOtherThanCS(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		def ExceptCSZZ(pacSubStr, pCaseSensitive)
			return This.SubStringsExceptCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsExceptZZ(pacSubStr)
		return This.SubStringsExceptCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringsAndTheirSectionsExcept(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def SubStringsOtherThanZZ(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def SubStringsAndTheirSectionsOtherThan(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		def ExceptZZ(pacSubStr)
			return This.SubStringsExceptZZ(pacSubStr)

		#>

	  #=================#
	 #      LINES      #
	#=================#

	def LinesCS(pCaseSensitive)
		return This.SplitCS(NL, pCaseSensitive)

		#< @FunctionFluentForm

		def LinesCSQ(pCaseSensitive)
			return This.LinesCSQR(pCaseSensitive, pCaseSensitive)

		def LinesCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.LinesCS(pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.LinesCS(pCaseSensitive))

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
	#-- WIHTOUT CASESENSITIVITY

	def Lines()
		return This.LinesCS(TRUE)

		#< @FunctionFluentForms

		def LinesQ()
			return This.LinesQR(:stzList)

		def LinesQR(pcReturnType)
			return This.LinesCSQR(TRUE, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  GETTING THE NUMBER OF LINES IN THE STRING  #
	#---------------------------------------------#

	def NumberOfLinesCS(pCaseSensitive)
		return len(This.LinesCS(pCaseSensitive))

		def HowManyLinesCS(pCaseSensitive)
			return This.NumberOfLinesCS(pCaseSensitive)

		def CountLinesCS(pCaseSensitive)
			return This.NumberOfLinesCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def NumberOfLines()
		return This.NumberOfLinesCS(TRUE)

		def HowManyLines()
			return This.NumberOfLines()

		def CountLines()
			return This.NumberOfLines()

	  #----------------#
	 #  UNIQUE LINES  #
	#================#

	def UniqueLinesCS(pCaseSensitive)
		acResult = This.LinesCSQ(pCaseSensitive).DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForm

		def UniqueLinesCSQ(pCaseSensitive)
			return This.UniqueLinesCSQR(pCaseSensitive, :stzList)

		def UniqueLinesCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueLinesCS(pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueLinesCS(pCaseSensitive))

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LinesCSU(pCaseSensitive)
			return This.UniqueLinesCS(pCaseSensitive)

			def LinesCSQU(pCaseSensitive)
				return This.LinesCSQRU(pCaseSensitive, :stzList)

			def LinesCSQRU(pCaseSensitive, pcReturnType)
				return This.UniqueLinesCSQR(pCaseSensitive, pcReturnType)

		def LinesWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueLinesCS(pCaseSensitive)

			def LinesWithoutDuplicationCSQ(pCaseSensitive)
				return This.LinesWithoutDuplicationCSQR(pCaseSensitive, :stzList)

			def LinesWithoutDuplicationCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueLinesCSQR(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UniqueLines()
		return This.UniqueLinesCS(TRUE)

		#< @FunctionFluentForm

		def UniqueLinesQ()
			return This.UniqueLinesQR(:stzList)

		def UniqueLinesQR(pcReturnType)
			return This.UniqueLinesCSQR(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def LinesU()
			return This.UniqueLines()

			def LinesQU()
				return This.LinesQRU(:stzList)

			def LinesQRU(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		def LinesWithoutDuplication()
			return This.UniqueLines()

			def LinesWithoutDuplicationQ()
				return This.LinesWithoutDuplicationQR(:stzList)

			def LinesWithoutDuplicationQR(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		#>

	  #----------------------------------------------------#
	 #  GETTING THE UNIQUE NUMBER OF LINES IN THE STRING  #
	#----------------------------------------------------#

	def NumberOfUniqueLinesCS(pCaseSensitive)
		return len(This.UniqueLinesCS(pCaseSensitive))

		#< @FunctionAlternativeForms

		def HowManyUniqueLinesCS(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def CountUniqueLinesCS(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		#--

		def NumberOfLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def HowManyLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		def CountLinesCSU(pCaseSensitive)
			return This.NumberOfUniqueLinesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfUniqueLines()
		return This.NumberOfUniqueLinesCS(TRUE)

		#< @FunctionAlternativeForms

		def HowManyUniqueLines()
			return This.NumberOfUniqueLines()

		def CountUniqueLines()
			return This.NumberOfUniqueLines()

		#--

		def NumberOfLinesU()
			return This.NumberOfUniqueLines()

		def HowManyLinesU()
			return This.NumberOfUniqueLines()

		def CountLinesU()
			return This.NumberOfUniqueLines()

		#>

	  #-------------------------------------#
	 #  GETTING THE NUMBER OF EMPTY LINES  #
	#=====================================#

	def NumberOfEmptyLinesCS(pCaseSensitive)
		acLines = This.LinesCS(pCaseSensitive)
		nLen = len(acLines)

		nResult = 0

		for i = 1 to nLen
			if ring_trim(acLines[i]) = ""
				nResult++
			ok
		next

		return nResult


		#< @FunctionAlternativeForms

		def HowManyEmptyLinesCS(pCaseSensitive)
			return This.NumberOfEmptyLinesCS(pCaseSensitive)

		def HowManyEmptyLineCS(pCaseSensitive)
			return This.NumberOfEmptyLinesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfEmptyLines()
		return This.NumberOfEmptyLinesCS(TRUE)

		#< @FunctionAlternativeForms

		def HowManyEmptyLines()
			return This.NumberOfEmptyLines()

		def HowManyEmptyLine()
			return This.NumberOfEmptyLines()

		#>

	  #--------------------------------------------#
	 #  REMOVING THE EMPTY LINES FROM THE STRING  #
	#============================================#

	def RemoveEmptyLinesCS(pCaseSensitive)
		acLines = This.LinesCS(pCaseSensitive)
		nLen = len(acLines)

		cResult = ""

		for i = 1 to nLen
			if NOT ring_trim(acLines[i]) = ""
				cResult += acLines[i] + NL
			ok
		next

		cResult = StzStringQ(cResult).LastCharRemoved()
		This.UpdateWith(cResult)


		#< @FunctionFluentForm

		def RemoveEmptyLinesCSQ(pCaseSensitive)
			This.RemoveEmptyLinesCS(pCaseSensitive)
			return This

		#>

	def EmptyLinesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveEmptyLinesCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveEmptyLines()
		This.RemoveEmptyLinesCS(TRUE)

		#< @FunctionFluentForm

		def RemoveEmptyLinesQ()
			return This.RemoveEmptyLinesCSQ(TRUE)

		#>

	def EmptyLinesRemoved()
		return This.EmptyLinesRemovedCS(TRUE)

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#==========================================#

	def RemoveLinesWCS(pcCondition, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(This[@i]).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		cResult = This.LinesCSQR(pCaseSensitive, :stzListOfStrings).
			       RemoveWQ(pCaseSensitive, pcCondition).
			       ConcatenatedUsing(NL)

		This.Update(cResult)

		#< @FunctionFluentForm

		def RemoveLinesWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLinesWCS(pcCondition, pCaseSensitive)
			return This

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLinesW(pcCondition)
		This.RemoveLinesWCS(pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveLinesWQ(pcCondition)
			This.RemoveLinesW(pcCondition)
			return This

		#>

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#==========================================#

	def RemoveLinesWCSXT(pcCondition, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(@line).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		cResult = This.LinesCSQR(pCaseSensitive, :stzListOfStrings).
			       RemoveWXTQ(pCaseSensitive, pcCondition).
			       ConcatenatedUsing(NL)

		This.Update(cResult)

		#< @FunctionFluentForm

		def RemoveLinesWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLinesWCSXT(pcCondition, pCaseSensitive)
			return This

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLinesWXT(pcCondition)
		This.RemoveLinesWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveLinesWXTQ(pcCondition)
			This.RemoveLinesWXT(pcCondition)
			return This

		#>

	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS NUMBERS  #
	#===========================================#

	def ContainsNumbers()
		acDigits = "0" : "9"
		nLen = len(acDigits)

		cContent = This.Content()
		bResult = FALSE

		for i = 1 to nLen
			n = This.FindFirst(acDigits[i])
			if n > 0
				bResult = TRUE
				exit
			ok
		next

		return bResult

	#TODO
	# Add ContainsNumbersXT() that finds other types of numbers other then decimal

	  #===============================#
	 #  GETTING AND SETTING MARQUER  #
	#===============================#

	func MarquerChar()
		return @cMarquer
		
		func Marquer()
			return @cMarquer
	
	func SetMarquerChar(c)
		if NOT (isString(c) and IsChar(c))
			StzRaise("Incorrect param type! c must be a char.")
		ok
	
		@cMarquer = c
	
		#NOTE // A marquer char can be set at the global level or string object level
	
		func SetMarquer()
			@cMarquer = c

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MARQUERS  #
	#============================================#

	def ContainsMarquers()
		if This.NumberOfMarquers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #---------------------------------------#
	 #  CHECKING IF THE STRING IS A MARQUER  #
	#=======================================#

	def IsMarquer()

		nLen = This.NumberOfChars()

		if nLen < 2
			return FALSE
		ok

		if NOT This.FirstChar() = "#"
			return FALSE
		ok

		if NOT This.SectionQ(2, nLen).IsNumberInString()
			return FALSE
		ok
 
		return TRUE

		def IsAMarquer()
			return This.IsMarquer()

	  #----------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING  #
	#==============================================#

	def Marquers()
		cMarquerChar = This.Marquer()

		oCopy = This.AddQ(" ")
		nLenStr = oCopy.NumberOfChars()
		
		anPos = oCopy.Find(cMarquerChar)
		nLenPos = len(anPos)
		
		if nLenPos = 0
			return []
		ok
		
		if anPos[nLenPos] != cMarquerChar
			anPos + nLenStr
		ok
		
		
		acResult = []
		
		for i = 1 to nLenPos
			n1 = anPos[i]+1
			n2 = anPos[i+1]-1
			cMarquer = ""
		
			for j = n1 to n2
				char = oCopy.@oQString.mid(j-1, 1)
		
				if char = "0" or char = "1" or char = "2" or
				   char = "3" or char = "4" or char = "5" or
				   char = "6" or char = "7" or char = "8" or
				   char = "9"
		
					cMarquer += char
				else
					exit
				ok
				
			next
		
			if cMarquer != ""
				acResult + (cMarquerChar + cMarquer)
			ok
		next
		
		return acResult

		def MarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.Marquers())

			on :stzList
				return new stzList(This.Marquers())

			other
				stzRaise("Unsupported return type!")
			off

	  #---------------------------------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING -- WITHOUT DUPLICATION  #
	#=====================================================================#

	def UniqueMarquers()
		return StzListQ(This.Marquers()).UniqueItems()

		#< @FunctionFluentForms

		def UniqueMarquersQ()
			return This.UniqueMarquersQR(:stzList)

		def UniqueMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueMarquers())

			on :stzList
				return new stzList(This.UniqueMarquers())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SetOfMarquers()
			return This.UniqueMarquers()

			def SetOfMarquersQ()
				return This.UniqueMarquersQ()

			def SetOfMarquersQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersU()
			return This.UniqueMarquers()

			def MarquersUQ()
				return This.UniqueMarquersQ()

			def MarquersUQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersWithoutDuplication()
			return This.UniqueMarquers()

			def MarquersWithoutDuplicationQ()
				return This.UniqueMarquersQ()

			def MarquersWithoutDuplicationQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE MARQUERS ~> WITHOUT DUPLICATION  #
	#----------------------------------------------------------------#

	def NumberOfUniqueMarquers()
		nResult = len( This.UniqueMarquers() )
		return nResult

		def NumberOfMarquersU()
			return This.NumberOfUniqueMarquers()

	  #------------------------------------------------#
	 #  GETTING THE NUMBER OF MARQUERS IN THE STRING  #
	#================================================#

	def NumberOfMarquers()
		return len(This.Marquers())

		def CountMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquer()
			return This.NumberOfMarquers()

	  #-------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS IN EACH MARQUER IN THE STRING  #
	#=============================================================#

	def NumberOfCharsInEachMarquer()
		acMarquers = This.Marquers()
		nLen = len(acMarquers)

		aResult = []
		for i = 1 to nLen
			aResult + len(acMarquers[i])
		next

		return aResult

		#< @FunctionAlternativeForms

		def SizeOfEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def MarquersNumbersOfChars()
			return This.NumberOfCharsInEachMarquer()

		def CountCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		#>

	  #-------------------------------#
	 #   MFINDING ARQUERS POSITIONS  #
	#===============================#

	def FindMarquers()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? FindMarquers()
			#--> [ 12, 25, 44, 66 ]
		
		}
		*/

		acMarquers = This.Marquers()
		aResult = []

		n = 1

		for cMarquer in acMarquers
			n = This.FindNextOccurrence( cMarquer, n )
			/* WARNING: Don't use:
			n = This.FindNextMarquer(cMarquer)
			--> Circular call --> Stackoverflow
			*/
			aResult + n
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindMarquersZ()
			return This.FindMarquers()

		def MarquersOccurrences()
			return This.FindMarquers()

		def MarquersPositions()
			return This.FindMarquers()

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#================================================#

	def MarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersAndPositions() " Use MarquersZ() instead
			#--> [ "#1" = 12, "#2" = 25 , "#3" = 44, "#1" = 66 ]
		
		}
		*/

		aResult = Association([ This.Marquers(), This.MarquersPositions() ]).
		return aResult

		#< @FunctionAlternativeForms

		def MarquersAndTheirPositions()
			return This.MarquersAndPositions()

		def MarquersAndOccurrences()
			return This.MarquersAndPositions()

		def MarquersAndTheirOccurrences()
			return This.MarquersAndPositions()

		def MarquersZ()
			return This.MarquersAndPositions()

		#>

	  #-------------------------------------------------------#
	 #   UNIQUE MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#=======================================================#

	def UniqueMarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? UniqueMarquersAndPositions() # Use MarquersUZ() instead
			#--> [ "#1" = [12, 66], "#2" = [26], "#3" = [44] ]
		
		}
		*/
		acMarquers = This.UniqueMarquers()
		nLen = len(acMarquers)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindAll(acMarquers[i])
			aResult + [ acMarquers[i], anPos ]
		next

		return aResult
		

		#< @FunctionAlternativeForms

		def UniqueMarquersAndTheirPositions()
			return This.UniqueMarquersAndPositions()

		def UniqueMarquersAndOccurrences()
			return This.MarquersAndPositions()

		def UniqueMarquersAndTheirOccurrences()
			return This.UniqueMarquersAndPositions()

		def MarquersUZ()
			return This.UniqueMarquersAndPositions()

		def UniqueMarquersZ()
			return This.UniqueMarquersAndPositions()

		def MarquersAndPositionsU()
			return This.UniqueMarquersAndPositions()

		def MarquersAndTheirPositionsU()
			return This.UniqueMarquersAndPositions()

		#>

	  #----------------------------#
	 #      FINDING A MARQUER     #
	#============================#

	def OccurrencesOfMarquer(pcMarquer)

		aResult = This.UniqueMarquersAndTheirPositions()[pcMarquer]
			# ~> Or you can simply say: This.MarquersZU()[pcMarquer]

		if isString(aResult) and aResult = NULL
			return []
		else
			return aResult
		ok

		#< @FunctionFluentForm

		def OccurrencesOfMarquerQ(pcMarquer)
			return This.OccurrencesOfMarquerQR(pcMarquer, :stzList)

		def OccurrencesOfMarquerQR(pcMarquer, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.OccurrencesOfMarquer(pcMArquer) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.OccurrencesOfMarquer(pcMArquer) )

			other
				stzRaise("Unsupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def PositionsOfMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def PositionsOfThisMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfThisMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfThisMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def MarquerPositions(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def MarquerPositionsQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def MarquerPositionsQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def FindMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def FindThisMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindThisMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindThisMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

			#>

	  #-------------------------------------#
	 #    GETTING A MARQUER BY POSITION    #
	#=====================================#

	def MarquerByPosition(pnPosition)
		aMarquers = This.MarquersAndTheirPositionsU()
		nLen = len(aMarquers)

		cResult = ""

		for i = 1 to nLen
			n = ring_find(aMarquers[i][2], pnPosition)
			if n > 0
				cResult = aMarquers[i][1]
				exit
			ok
		next

		return cResult

		def MarquerByPositionQ(pnPosition)
			return new stzString( This.MarquerByPosition() )

		def MarquerByOccurrence(pnPosition)
			return This.MarquerByPosition(pnPosition)

			def MarquerByOccurrenceQ(pnPosition)
				return new stzString( This.MarquerByOccurrence(pnPosition) )

	  #-------------------------------------------#
	 #    GETTING A MARQUER BY MANY POSITIONS    #
	#===========================================#

	def MarquerByPositions(panPos)
		cMarquer = This.MarquerByPosition(panPos[1])
		anPos = This.FindMarquer(cMarquer)

		cResult = ""

		if StzListQ(panPos).IsIncludedIn(anPos)
			cResult = cMarquer
		ok

		return cResult


		def MarquerByOccurrences(panPos)
			return This.MarquerByPositions(panPos)

	  #-------------------------------------------#
	 #    GETTING MARQUERS BY THEIR POSITIONS    #
	#===========================================#

	def MarquersByPositions(panPos)
		oHash = new stzHashList( MarquersUZ() )
		acResult = oHash.KeysByValues(panPos)

		return acResult

		def MarquersByOccurrences(panPos)
			return This.MarquersByPositions(panPos)

	  #----------------------------------#
	 #   FINDING MARQUERS AS SECTIONS   #
	#==================================#

	def FindMarquersZZ()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? FindMarquersZZ()
			#--> [  [12, 13], [ 25, 26],  [44, 45], [66, 67]  ]
		
		}
		*/

		anStartPos  = This.FindMarquers()
		anNbOfChars = This.MarquersNumbersOfChars()

		aResult = []

		for i = 1 to len(anStartPos)
			aResult + [ anStartPos[i], anStartPos[i] + anNbOfChars[i] - 1 ]
		next

		return aResult


		#< @FunctionAlternativeForm

		def FindMarquersAsSections()
			return This.FindMarquersZZ()

		def MarquersSections()
			return This.FindMarquersZZ()
		
		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR SECTIONS -- ZZ/Extended   #
	#================================================#

	def MarquersAndSections()

		aResult = Association([ This.Marquers(), This.MarquersSections() ])
		return aResult

		#< @FunctionFluentForm

		def MarquersAndSectionsQ()
			return This.MarquersAndSectionsQR(:stzList)

		def MarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndSections() )

			on :stzHashList
				return new stzHashList( This.MarquersAndSections() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZ()
			return This.MarquersAndSections()

			def MarquersZZQ()
				return This.MarquersAndSectionsQ()

			def MarquersZZQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		def MarquersAndTheirSections()
			return This.MarquersAndSections()

			def MarquersAndTheirSectionsQ()
				return This.MarquersAndSectionsQ()

			def MarquersAndTheirSectionsQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		#>

	  #-------------------------------------------------------#
	 #  UNIQUE MARQUERS AND THEIR SECTIONS -- ZZU/Extended   #
	#=======================================================#

	def UniqueMarquersAndSections()

		aMarquers = This.MarquersAndTheirSections()
		nLen = len(aMarquers)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			cMarquer = aMarquers[i][1]
			aSection = aMarquers[i][2]

			if ring_find(acSeen, cMarquer) = 0

				aResult + [ cMarquer, [ aSection ] ]
				acSeen + cMarquer

			else

				aResult[cMarquer] + aSection
			ok

		next
		
		return aResult

		#< @FunctionFluentForm

		def UniqueMarquersAndSectionsQ()
			return new stzList(This.UniqueMarquersAndSections())

		def UniqueMarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndSections() )

			on :stzList
				return new stzList( This.UniqueMarquersAndSections() )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZU()
			return This.UniqueMarquersAndSections()

			def MarquersZZUQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersZZUQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUZZ()
			return This.UniqueMarquersAndSections()

			def MarquersUZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def UniqueMarquersAndTheirSections()
			return This.UniqueMarquersAndSections()

			def UniqueMarquersAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def UniqueMarquersandTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersUAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationZZ()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		#>
	
	  #-----------------------------------------#
	 #    SORTING MARQUERS INSIDE THE STRING   #
	#=========================================#

	def MarquersAreSorted()
		bResult = StzListQ(This.Marquers()).ItemsAreSorted()
		return bResult

	def MarquersSortingOrder()
		bResult = StzListQ(This.Marquers()).SortingOrder()
		return bResult

	def MarquersAreUnsorted()
		bResult = StzListQ(This.Marquers()).ItemsAreUnsorted()
		return bResult

		def MarquersAreNotSorted()
			return This.MarquersAreUnsorted()

	def MarquersAreSortedInAscending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInAscending()
		return bResult

	def MarquersAreSortedInDescending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInDescending()
		return bResult

	#--

	def MarquersSortedInAscending()
		aResult = StzListQ(This.Marquers()).SortedInAscending()
		return aResult

		def MarquersSorted()
			return This.MarquersSortedInAscending()
	
	def UniqueMarquersSortedInAscending()
		aResult = StzListQ(This.UniqueMarquers()).SortedInAscending()
		return aResult

		def UniqueMarquersSorted()
			return This.UniqueMarquersSortedInAscending()

		def MarquersSortedInAscendingU()
			return This.UniqueMarquersSortedInAscending()

		def UniqueMarquersSortedU()
			return This.UniqueMarquersSortedInAscending()

	#--

	def MarquersSortedInDescending()
		aResult = StzListQ(This.Marquers()).SortedInDescending()
		return aResult

	def UniqueMarquersSortedInDescending()
		aResult = StzListQ(This.UniqueMarquers()).SortedInDescending()
		return aResult

		def MarquersSortedInDescendingU()
			return This.UniqueMarquersSortedInDescending()

	#--

	def MarquersPositionsSortedInAscending()
		aResult = StzListQ(This.MarquersPositions()).SortedInAscending()
		return aResult

		def MarquersPositionsSorted()
			return This.MarquersPositionsSortedInAscending()

	#--

	def MarquersPositionsSortedInDescending()
		aResult = StzListQ(This.MarquersPositions()).SortedInDescending()
		return aResult

	#--

	def MarquersAndPositionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		anPos = This.MarquersPositionsSortedInAscending()

		aResult = Association([ acMarquers, anPos ])

		return aResult

		def MarquersSortedInAscendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedInAscending()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersSortedZ()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingZ()
			return This.MarquersAndPositionsSortedInAscending()

	def UniqueMarquersAndPositionsSortedInAscending()

		aUniqueMarquers = This.UniqueMarquersSortedInAscending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAll(aUniqueMarquers[i]) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInAscendingAndTheirPositions()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersAndTheirPositionsSortedInAscending()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersSortedZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def UniqueMarquersSortedInAscendingZ()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		#--

		def MarquersAndPositionsSortedInAscendingU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingAndTheirPositionsU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedInAscendingU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedZU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		def MarquersSortedInAscendingZU()
			return This.UniqueMarquersAndPositionsSortedInAscending()

		#>

	#--

	def MarquersAndPositionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		anPos = This.MarquersPositionsSortedInDescending()

		aResult = StzPairOfListsQ( acMarquers, anPos ).Associate()

		return aResult

		def MarquersSortedInDescendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedInDescending()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingZ()
			return This.MarquersAndPositionsSortedInDescending()

	def UniqueMarquersAndPositionsSortedInDescending()

		aUniqueMarquers = This.UniqueMarquersSortedInDescending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAll(aUniqueMarquers[i]) ]
		next

		return aResult


		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInDescendingAndTheirPositions()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def UniqueMarquersAndTheirPositionsSortedInDescending()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def UniqueMarquersSortedInDescendingZ()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		#--

		def MarquersAndPositionsSortedInDescendingU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingAndTheirPositionsU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedOInDescendingU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		def MarquersSortedInDescendingZU()
			return This.UniqueMarquersAndPositionsSortedInDescending()

		#>

	#--

	def MarquersAndSectionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		nLen = len(acMarquers)

		anPos = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLen
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPos[i]
			n2 = n1 + nLenMarquer - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def MarquersSortedInAscendingAndTheirSections()
			return This.MarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingZZ()
			return This.MarquersAndSectionsSortedInAscending()

		def MarquersSortedZZ()
			return This.MarquersAndSectionsSortedInAscending()

		#>

	def UniqueMarquersAndSectionsSortedInAscending()

		aUniqueMarquers = This.UniqueMarquersSortedInAscending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAsSections(aUniqueMarquers[i]) ]
		next

		return aResult


		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInAscendingAndTheirSections()
			return This.UniqueMarquersAndSecionsSortedInAscending()

		def UniqueMarquersAndTheirSectionsSortedInAscending()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def UniqueMarquersSortedInAscendingZZ()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		#--

		def MarquersAndSectionsSortedInAscendingU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingAndTheirSectionsU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersAndTheirSectionsSortedOInAscendingU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedInAscendingZZU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		def MarquersSortedZZU()
			return This.UniqueMarquersAndSectionsSortedInAscending()

		#>

	#--

	def MarquersAndSectionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		nLenMarquers = len(acMarquers)

		anPos = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLenMarquers
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPos[i]
			n2 = n1 + nLenMarquers - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def MarquersSortedInDescendingAndTheirSections()
			return This.MarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingZZ()
			return This.MarquersAndSectionsSortedInDescending()

		#>

	def UniqueMarquersAndSectionsSortedInDescending()

		aUniqueMarquers = This.UniqueMarquersSortedInDescending()
		nLen = len(aUniqueMarquers)

		aResult = []

		for i = 1 to nLen
			aResult + [ aUniqueMarquers[i], This.FindAsSections(aUniqueMarquers[i]) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UniqueMarquersSortedInDescendingAndTheirSections()
			return This.UniqueMarquersAndSecionsSortedInDescending()

		def UniqueMarquersAndTheirSectionsSortedInDescending()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def UniqueMarquersSortedInDescendingZZ()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		#--

		def MarquersAndSectionsSortedInDescendingU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingAndTheirSectionsU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersAndTheirSectionsSortedOInDescendingU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		def MarquersSortedInDescendingZZU()
			return This.UniqueMarquersAndSectionsSortedInDescending()

		#>

	#--

	def SortMarquersInAscending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInAscending()
			? Content()
		}

		# !--> My name is #1, may age is #2, and my job is #3.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		/* Reminder
		#--> [ "#1" = [12, 13], "#1" = [26, 27], "#2" = [44, 45], "#3" = [66, 67] ]
		*/

		for i = len(aMarquersSections) to 1 step -1
			cMarquer = aMarquersSections[i][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInAscendingQ()
			This.SortMarquersInAscending()
			return This

		def SortMarquers()
			This.SortMarquersInAscending()

			def SortMarquersQ()
				This.SortMarquers()
				return This

		def SortMarquersUp()
			This.SortMarquersInAscending()

			def SortMarquersUpQ()
				This.SortMarquers()
				return This

	def StringWithMaquersSortedInAscending()
		cResult = This.Copy().SortMarquersInAscendingQ().Content()
		return cResult

		def StringWithMarquersSorted()
			return This.StringWithMaquersSortedInAscending()

		def StringWithMarquersSortedUp()
			return This.StringWithMaquersSortedInAscending()

	def SortMarquersInDescending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInDescending()
			? Content()
		}

		# !--> My name is #3, may age is #2, and my job is #1.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersSections)

		/* Reminder
		Q("My name is #2, may age is #1, and my job is #3.") {
			? MarquersAndSections()
		}

		#--> [ "#1" = [12, 13], "#2" = [27, 28], "#3" = [45, 46]  ]
		*/

		for i = nLen to 1 step - 1
			cMarquer = aMarquersSections[nLen - i + 1][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInDescendingQ()
			This.SortMarquersInDescending()
			return This

		def SortDownMarquers()
			This.SortMarquersInDescending()
	
			def SortDownMarquersQ()
				This.SortDownMarquers()
				return This

	def StringWithMaquersSortedInDescending()
		cResult = This.Copy().SortMarquersInDescendingQ().Content()
		return cResult

		def StringWithMaquersSortedDown()
			return This.StringWithMaquersSortedInDescending()

	  #--------------------------------------------#
	 #  REPLACING MARQUERS WITH GIVEN SUBSTRINGS  #
	#============================================#

	def ReplaceMarquers(pacSubStr)
		if CheckParams()
			if isList(pacSubStr) and Q(pacSubStr).IsWithOrByNamedParam()
				pacSubStr = pacSubStr[2]
			ok
		ok

		aMarquersXT = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersXT)

		nMin = Min([ len(pacSubStr), nLen ])

		for i = nLen to 1 step -1
			
			cMarquer = aMarquersXT[i][1]

			This.ReplaceAll(cMarquer, pacSubStr[i])
		next

		def ReplaceMarquersQ(pacSubStr)
			This.ReplaceMarquers(pacSubStr)
			return This

	def MarquersReplaced(pacSubStr)
		return This.Copy().ReplaceMarquersQ(pacSubStr).Content()

		#< @FunctionMisspelledForm

		def MarquersRepalced(pacSubStr)
			return This.MarquersReplaced(pacSubStr)

		#>

	  #------------------------------------------#
	 #    REPLACING SUBSTRINGS WITH MARQUERS    #
	#==========================================#

	def ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

		acSubStr = StzListQ(pacSubStr).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(acSubStr)

		acMarquers = []

		cMarquer = This.Marquer()
		for i = 1 to nLen
			acMarquers + ( cMarquer + i )
		next

		This.ReplaceManyByManyCS(acSubStr, acMarquers, pCaseSensitive)

		def ReplaceSubstringsWithMarquersCSQ(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)
			return This

		def MarkTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

			def MarkTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.MarkTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def MarkSubStringsCS(pacSubStr, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubStr, pCaseSensitive)

			def MarkSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.MarkSubStringsCS(pacSubStr, pCaseSensitive)
				return This

	def SubstringsReplacedWithMarquersCS(pacSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubstringsWithMarquersCSQ(pacSubStr, pCaseSensitive).Content()
		return cResult

		def SubstringsMarquedCS(pacSubStr, pCaseSensitive)
			return This.SubstringsReplacedWithMarquersCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubstringsWithMarquers(pacSubStr)
		This.ReplaceSubstringsWithMarquersCS(pacSubStr, TRUE)

		def MarkTheseSubStrings(pacSubStr)
			This.ReplaceSubstringsWithMarquers(pacSubStr)

			def MarkTheseSubStringsQ(pacSubStr)
				This.MarkTheseSubStrings(pacSubStr)
				return This

		def MarkSubStrings(pacSubStr)
			This.ReplaceSubstringsWithMarquers(pacSubStr)

			def MarkSubStringsQ(pacSubStr)
				This.MarkSubStrings(pacSubStr)
				return This

	def SubstringsReplacedWithMarquers(pacSubStr)
		return This.SubstringsReplacedWithMarquersCS(pacSubStr, TRUE)

		def SubstringsMarqued(pacSubStr)
			return This.SubstringsReplacedWithMarquers(pacSubStr)

	  #------------------------#
	 #    PARSING MARQUERS    #
	#========================#

	#TODO : Add these functions	
	# 	NthMarquerZ(n)
	# 	NthMarquerZZ(n)
	
	# 	NextNthMarquerZZ(n, nStart)
	# 	PreviousNthMarquerZZ(n, nStart)

	def NthMarquer(n)
		if CheckParams()
			if NOT isNumber(n)
				stzRaise("Incorrect param type! n should be a number.")
			ok
		ok

		try
			return This.Marquers()[n]
		catch
			return NULL
		done

		def NthMarquerQ(n)
			return new stzString( This.NthMarquer(n) )

	def FirstMarquer()
		return This.NthMarquer(1)

		def FirstMarquerQ()
			return new stzString( This.LastMarquer() )

		#-- MISSPELLED

		def FristMarquer()
			return This.FirstMarquer()

			return This.FristMArquerQ()
				return This.FirstMarquerQ()

	def LastMarquer()
		n = This.NumberOfMarquers()
		acResult = This.Marquers()[ n ]
		return acResult

		def LastMarquerQ()
			return new stzString( This.LastMarquer() )

	  #------------------------------#
	 #    FINDING THE NTH MARQUER   #
	#==============================#

	def FindNthMarquer(n)
		if CheckParams()
			if isString(n)
				if n = :First or n = :FirstMarquer
					n = 1
				but n = :Last or n = :LastMarquer
					n = This.NumberOfMarquers()
				ok
			ok
		ok

		return This.FindNthOccurrence( n, This.Marquer() )

		def NthMarquerOccurrence(n)
			return This.FindNthMarquer(n)

		def NthMarquerPosition(n)
			return This.FindNthMarquer(n)

		def PositionOfNthMarquer(n)
			return This.FindNthMarquer(n)

	def FindFirstMarquer()
		return This.FindNthMarquer(1)

		#< @FunctionAlternativeForms

		def FirstMarquerOccurrence()
			return This.FindFirstMarquer()

		def FirstMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFirstMarquer()
			return This.FindFirstMarquer()

		#>

		#< @FunctionMisspelledForms

		def FindFristMarquer()
			return This.FindFirstMarquer()

		def FristMarquerOccurrence()
			return This.FindFirstMarquer()

		def FristMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFristMarquer()
			return This.FindFirstMarquer()

		#>

	def FindLastMarquer()
		return This.FindNthMarquer(This.NumberOfMarquers())

		def LastMarquerOccurrence()
			return This.FindLastMarquer()

		def LastMarquerPosition()
			return This.FindLastMarquer()

		def PositionOfLastMarquer()
			return This.FindLastMarquer()


	  #--------------------------------------------------#
	 #    NEXT MARQUERS STARTING AT A GIVEN POSITION    #
	#==================================================#

	def NextMarquers(pnStartingAt)
		if CheckParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		nLen =  This.NumberOfChars()
		acResult = This.SectionQ(pnStartingAt, nLen).Marquers()
		return acResult

		#< @FunctionFluentForms

		def NextMarquersQ(pnStartingAt)
			return This.NextMarquersQR(pnstartingAt, :stzList)

		def NextMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NextMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.NextMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextMarquersST(pnStartingAt)
			return This.NextMarquers(pnStartingAt)

			def NextMarquersSTQ(pnStartingAt)
				return This.NextMarquersQ(pnStartingAt)

			def NextMarquersSTQR(pnStartingAt, pcReturnType)
				return This.NextMarquersQR(pnStartingAt, pcReturnType)

		#>

	  #--------------------------------------#
	 #    RETURNING THE NTH NEXT MARQUER    #
	#======================================#

	def NthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> #3
		*/

		if CheckParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		nLen = This.NumberOfChars()
		oStr = This.SectionQ(pnStartingAt, nLen)
		cResult = oStr.Marquers()[ n ]
		return cResult

		#< @FunctionFluentForm

		def NthNextMarquerQ(n, pnStartingAt)
			return new stzString( This.NthNextMarquer(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def NextNthMarquer(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		#--

		def NthNextMarquerST(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NthNextMarquerSTQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		def NextNthMarquerST(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerSTQ(n, pnStartingAt)
				return This.NthNextMarquerQ(n, pnStartingAt)

		#>

	  #------------------------------------#
	 #    FINDING THE NTH NEXT MARQUER    #
	#====================================#

	def FindNthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> 44
		*/

		if CheckParams()

			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT (isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok

		ok

		nLen = This.NumberOfChars()
		oStr = This.SectionQ(pnStartingAt, nLen)

		nPos = oStr.MarquersPositions()[ n ] + pnStartingAt - 1
		
		return nPos

		#< @FunctionAlternativeForms

		def FindNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		#--

		def FindNthNextMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def FindNextNthMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrenceS(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPositionST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPositionST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquerST(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------#
	 #    NTH NEXT MARQUER, ALONG WITH ITS POSITION    #
	#=================================================#

	def NthNextMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthNextMarquer(n, pnStartingAt)
		nPosition = This.FindNthNextMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthNextMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthNextMarquerAndItsPositionQR(n, pnStartingAt,  :stzList)

		def NthNextMarquerAndItsPositionQR(n, pnStartingAt,  pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQ(n, pnStartingAt)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

		def NextNthMarque(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#--

		def NthNextMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

		def NextNthMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

		def NextNthMarquerSTZ(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    FINDING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def FindNextMarquer(pnStartingAt)
		return This.FindNthNextMarquer(1, pnStartingAt)

		#< @FunctionAlternativeForms

		def NextMarquerPosition(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquer(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrence(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		#--

		def FindNextMarquerST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerPositionST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquerST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrenceST(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    GETTING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def NextMarquer(pnStartingAt)
		return This.NthNextMarquer(1, pnStartingAt)

		#< @FunctionFluentForm

		def NextMarquerQ(pnStartingAt)
			return new stzString( This.NextMarquer(pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def NextMarquerST(pnStartingAt)
			return This.NextMarquer(pnStartingAt)

			def NextMarquerSTQ(pnStartingAt)
				return new stzString( This.NextMarquer_S(pnStartingAt) )

		#>

	  #--------------------------------------------------------------------------#
	 #    GETTING NEXT MARQUER AND ITS POSITION STARTING AT A GIVEN POSITION    #
	#==========================================================================#

	def NextMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.NextMarquer(pnStartingAt)
		nPosition = This.NextMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def NextMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.NextMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def NextMarquerAndItsOccurrence(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

			def NextMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.NextMarquerAndItsOccurrence(pnStartingAt) )

		def NextMarquerZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		#--

		def NextMarquerAndItsOccurrenceST(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		def NextMarquerSTZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		#>

	  #---------------------------------#
	 #    GETTING PREVIOUS MARQUERS    #
	#=================================#

	def PreviousMarquers(pnStartingAt)
		if CheckParams()
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0 )
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		acResult = This.SectionQ(1, pnStartingAt).Marquers()
		return acResult

		#< @FunctionFluentForms

		def PreviousMarquersQ(pnStartingAt)
			return This.PreviousMarquersQR(pnstartingAt, :stzList)

		def PreviousMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquersST(pnStartingAt)
			return This.PreviousMarquers(pnStartingAt)

			def PreviousMarquersSTQ()
				return This.PreviousMarquersQ()

			def PreviousMarquersSTQR(pnStartingAt, pcReturnType)
				return This.PreviousMarquersQR(pnstartingAt, pcReturnType)

		#>

	  #------------------------------------#
	 #    GETTING NTH PREVIOUS MARQUER    #
	#====================================#

	def NthPreviousMarquer(n, pnStartingAt)
		nPos = This.FindNthPreviousMarquer(n, pnStartingAt)

		return This.MarquerByPosition(nPos)
		
		#< @FunctionFluentForm

		def NthPreviousMarquerQ(n, pnStartingAt)
			return new stzString( This.NthPreviousMarquer(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousNthMarquer(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

			def PreviousNthMarquerQ(n, pnStartingAt)
				return new stzString( This.PreviousNthMarquer(n, pnStartingAt) )

		#--

		def NthPreviousMarquerST(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerST(n, pnStartingAt)
			return This.PreviousNthMarquer(n, pnStartingAt)

		#>

	  #------------------------------------#
	 #    FINDING NTH PREVIOUS MARQUER    #
	#====================================#

	def FindNthPreviousMarquer(n, pnStartingAt)
		if CheckParams()
	
			if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		oStr = This.SectionQ(1,  pnStartingAt)

		anPos = oStr.MarquersPositions()
		nLenPos = len(anPos)

		nResult = 0

		n = nLenPos - n + 1
		if n >= 1 and n <= nLenPos
			nResult = anPos[n]
		ok

		return nResult
		
		#< @FunctionAlternativeForm

		def FindPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#--

		def FindNthPreviousMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def FindPreviousNthMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrenceST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPositionST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPositionST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquerST(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING NTH PREVIOUS MARQUER  ALONG WITH ITS POSITION -- Z/Extended   #
	#=========================================================================#

	def NthPreviousMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthPreviousMarquer(n, pnStartingAt)
		nPosition = This.FindNthPreviousMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthPreviousMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)

		def NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def PreviousNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		#--

		def NthPreviousMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerAndItsPositionST(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerSTZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerSTZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #------------------------------#
	 #   FINDING PREVIOUS MARQUER   #
	#==============================#

	def FindPreviousMarquer(pnStartingAt)
		return This.FindNthPreviousMarquer(1, pnStartingAt)

		#< @FunctionAlternativeForms

		def PreviousMarquerPosition(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquer(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrence(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		#--

		def FindPreviousMarquerST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerPositionST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquerST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrenceST(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		#>

	  #------------------------------#
	 #   GETTING PREVIOUS MARQUER   #
	#==============================#

	def PreviousMarquer(pnStartingAt)
		return This.NthPreviousMarquer(1, pnStartingAt)

		#< @FunctionFluentForm

		def PreviousMarquerQ(pnStartingAt)
			return new stzString( This.PreviousMarquer(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerST(pnStartingAt)
			return This.PreviousMarquer(pnStartingAt)

		#>

	  #--------------------------------------------------------------------#
	 #   FINDING PREVIOUS MARQUER ALONG WITH ITS POSITION -- Z/Extension  #
	#====================================================================#

	def PreviousMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.PreviousMarquer(pnStartingAt)
		nPosition = This.PreviousMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def PreviousMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.PreviousMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerAndItsOccurrence(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.PreviousMarquerAndItsOccurrence(pnStartingAt) )

		def PreviousMarquerZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		#--

		def PreviousMarquerAndItsPositionST(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		def PreviousMarquerAndItsOccurrenceST(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		def PreviousMarquerSTZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

		#>

	  #===========================================================#
	 #   CHECKING IF THE STRING CONTAINS DUPLICATED SUBSTRINGS   #
	#===========================================================#

	def ContainsDuplicatedSubStringsCS(pCaseSensitive)

		if This.NumberOfDuplicatesCS(pCaseSensitive) > 0
			return TRUE
		else
			return FALSE
		ok

		def ContainsDuplicatesCS(pCaseSensitive)
			return This.ContainsDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedSubStrings()
		return This.ContainsDuplicatedSubStringsCS(TRUE)
	
		def ContainsDuplicates()
			return This.ContainsDuplicatedSubStrings()

	  #----------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED IN THE STRING   #
	#----------------------------------------------------------------#

	def ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		return bResult

		def ContainsDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicated(pcSubStr)
		return This.ContainsDuplicatedCS(pcSubStr, TRUE)

		def ContainsDuplicatedSubString(pcSubStr)
			return This.ContainsDuplicated(pcSubStr)

	  #-----------------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED N-TIMES IN THE STRING  #
	#-----------------------------------------------------------------------#

	def ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def SubStringIsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedNTimes(n, pcSubStr)
		return This.ContainsDuplicatedNTimesCS(n, pcSubStr, TRUE)

		def SubStringIsDuplicatedNTimes(n, pcSubStr)
			return This.ContainsDuplicatedNTimes(n, pcSubStr, pItem)

	  #-----------------------------------------------------------------------#
	 #   HOW MANY TIMES A GIVEN SUBSTRING IS DUPLICATED INSIDE THE STRING?   #
	#-----------------------------------------------------------------------#

	def NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		nResult =  This.SubStringsCSQ(pCaseSensitive).
				NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfTimesSubStringIsDuplicated(pcSubStr)
		return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicated(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#--

		def NumberOfDuplicatesOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOf(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING THE EXISTENCE OF NON DUPLICATED SUBSTRINGS IN THE STRING  #
	#=====================================================================#

	def ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

		bResult = This.SubStringsCSQ(pCaseSensitive).
			       ContainsNonDuplicatedItemsCS(pCaseSensitive)

		return bResult

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedsubStrings()
		return This.ContainsNonDuplicatedSubStringsCS(TRUE)

		def ContainsNoDuplications()
			return This.ContainsNonDuplicatedSubStrings()

	  #-------------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsCS(pCaseSensitive)
		acResult = This.Copy().RemoveDuplicatedSubStringsCSQ(pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedISubStrings()
		return This.NonDuplicatedSubStringsCS(TRUE)

	  #---------------------------------------#
	 #  NUMBER OF NON DUPLICATED SUBSTRINGS  #
	#---------------------------------------#

	def NumberOfNonDuplicatedSubStringsCS(pCaseSensitive)
		nResult = This.SubStringsCSQ(pCaseSensitive).NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedSubStrings()
		return This.NumberOfNonDuplicatedSubStringsCS(TRUE)

	  #-------------------------------------#
	 #  FINDING NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------#

	def FindNonDuplicatedSubStringsCS(pCaseSensitive)
		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)
		anResult = []

		for i = 1 to nLen
			# By defintion, a non duplicated substring apprears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			anResult + nPos
		next

		anResult = Q(anResult).Sorted()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedSubStrings()
		return This.FindNonDuplicatedSubStringsCS(TRUE)

	  #-------------------------------------------------#
	 #  NON DUPLICATED SUBSTRINGS AND THEIR POSITIONS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated substrings appears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			aResult + [ acNonDuplicated[i], nPos ]
		next

		return aResult

		def NonDuplicatedSubstringsCSZ(pCaseSensitive)
			return This.NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedSubStringsAndTheirPositions()
		return This.NonDuplicatedSubStringsAndTheirPositionsCS(TRUE)

		def NonDuplicatedSubStringsZ()
			return This.NonDuplicatedSubStringsAndTheirPositions()

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)

		nResult = len( This.DuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(TRUE)

		#< @functionAlternativeForms

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		#>

	  #----------------------#
	 #  FINDING DUPLICATES  #
	#----------------------#

	def FindDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesCSXT(pCaseSensitive)
		anResult = Q(anPos).ToSet()
		return anResult

		def FindDuplicatesCSZ(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(TRUE)

		def FindDuplicatesZ()
			return This.FindDuplicates()

	  #----------------------------------#
	 #  FINDING DUPLICATES -- EXTENDED  #
	#----------------------------------#

	# This extended form keeps the positions even if they are duplicated
	#TODO: Illistrate it with an example.

	def FindDuplicatesCSXT(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()
		return anResult

		def FindDuplicatesCSXTZ(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesCSXT(TRUE)

		def FindDuplicatesXTZ()
			return This.FindDuplicatesXT()

	  #----------------------------------#
	 #  FINDING DUPLICATES AS SECTIONS  #
	#----------------------------------#

	def FindDuplicatesAsSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		nLen = len(acDuplicates)

		aResult = []

		for i = 1 to nLen
			aSections = This.FindAsSectionsCSQ(acDuplicates[i], pCaseSensitive).
					 FirstItemRemoved()

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = QR(aResult, :stzListOfPairs).Sorted()
		return aResult

		#< @FunctionAlternativeForm

		def FindDuplicatesCSZZ(pCaseSensitive)
			return This.FindDuplicatesAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesAsSections()
		return This.FindDuplicatesAsSectionsCS(TRUE)

		#< @FunctionAlternativeForm

		def FindDuplicatesZZ()
			return This.FindDuplicatesAsSections()

		#>

	  #--------------#
	 #  DUPLICATES  #
	#--------------#

	def DuplicatesCS(pCaseSensitive)
		
		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = This.Section(i, j)

				if Q(acResult).ContainsNoCS(cSubStr, pCaseSensitive) and
				   This.NumberOfOccurrenceCS(cSubStr, TRUE) > 1

					acResult + cSubStr
				ok

			next
		next
		
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(TRUE)

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR POSITIONS -- Z/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirPositionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesCSXT(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZ(pCaseSensitive)
			return This.DuplicatesAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirPositions()
		return This.DuplicatesAndTheirPositionsCS(TRUE)

		def DuplicatesZ()
			return This.DuplicatesAndTheirPositions()

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR SECTIONS -- ZZ/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZZ(pCaseSensitive)
			return This.DuplicatesAndTheirSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirSections()
		return This.DuplicatesAndTheirSectionsCS(TRUE)

		def DuplicatesZZ()
			return This.DuplicatesAndTheirSections()

	  #---------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		anResult = []
		anPos = This.FindOccurrenceCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			anResult = Q(anPos).FirstItemRemoved()
		ok

		return anResult
		

		def PositionsOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubString(pcSubStr)
		return This.FindDuplicatesOfSubStringCS(pcSubStr, TRUE)

		def PositionsOfDuplicatesOfSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

	  #---------------------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING AS SECTIONS   #
	#---------------------------------------------------------#

	def FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = []
		anPos = This.FindOccurrencesAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			aResult = Q(anPos).FirstItemRemoved()
		ok

		return aResult
		
		def FindDuplicatesOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubStringAsSections(pcSubStr)
		return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, TRUE)

		def FindDuplicatesOfSubStringZZ(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

	  #-------------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE STRING   #
	#===========================================#

	def RemoveDuplicatesCS(pCaseSensitive)

		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

	def DuplicatesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return cResult

		def WithoutDuplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(TRUE)

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

		def WithoutDuplicates()
			return This.DuplicatesRemoved()

		def WithoutDuplication()
			return This.DuplicatesRemoved()

		def WithoutDuplications()
			return This.DuplicatesRemoved()

  	  #----------------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN SUBSTRING   #
	#----------------------------------------------#

	def RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

			def RemoveDuplicatesOfThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisSubstringRemovedCS(pcSubStr, pCaseSensitive)
			return This.DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubString(pcSubStr)
		This.RemoveDuplicatesOfSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringQ(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcsubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubString(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcSubStr)

			def RemoveDuplicatesOfThisSubStringQ(pcSubStr)
				This.RemoveDuplicatesOfThisSubString(pcSubStr)
				return This

		#>

	def DuplicatesOfSubStringRemoved(pcSubStr)
		return This.DuplicatesOfSubStringRemovedCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisSubStringRemoved(pcSubStr)
			return This.DuplicatesOfSubStringRemoved(pcSubStr)

		#>

	  #--------------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN SUBSTRINGS   #
	#--------------------------------------------------#

	def RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param! paItems must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(pacSubStr[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsCSQ(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

			def RemoveDuplicatesOfTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubStrings(pacSubStr)
		This.RemoveDuplicatesOfSubStringsCS(pacSubStr, TRUE)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsQ(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOfTheseSubStrings(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)

			def RemoveDuplicatesOfTheseSubStringsQ(pacSubStr)
				This.RemoveDuplicatesOfTheseSubStrings(pacSubStr)
				return This

		#>

	  #===============================================#
	 #   TRANSFORMING THE STRING TO A STZTEXTOBJECT  #
	#===============================================#

	def ToStzText()
		return new stzText( This.String() )

	  #===============================================#
	 #      NUMBER OF OCCURRENCE OF A SUBSTRING      #
	#===============================================#

	def NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		if CheckParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok

		ok

		nResult = -1 + This.SplitCSQ(pcSubStr, pCaseSensitive).NumberOfItems()
		return nResult

		#< @FunctionFluentForm

		def NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def NumberOfOccurrenceOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)

		def NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def CountCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def CountCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def HowManyCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def HowManyCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pcSubStr)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		return NumberOfOccurrenceCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def NumberOfOccurrenceQ(pcSubStr)
			return new stzNumber( This.NumberOfOccurrence(pcSubStr) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrences(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOf(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesOfQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOfOccurrenceOf(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)

		def NumberOfOccurrenceOfSubstring(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOfSubstring(pcSubStr)
			return This.NumberOfOccurrenceOfSubstring(pcSubStr)

			def NumberOfOccurrencesOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def Count(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def CountQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def HowMany(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def HowManyQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING N (OR MORE) TIMES IN THE LIST  #
	#==============================================================#

	def SubStringsOccurringNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		acResult = This.SubStringsQ().ItemsOccurringNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringAtLeastNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringAtLeastNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringNTimes(n)
		return This.SubStringsOccurringNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesQ(n)
			return new stzList( This.SubStringsOccurringNTimes(n) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimes(n) # One r instead of 2
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccuringNTimesQ(n)
				return This.SubStringsOccurringNTimesQ(n)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNTimesOrMore(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringNTimesOrMoreQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		def SubStringsOccurringNTimesAndMore(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringNTimesAndMoreQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		def SubStringsOccurringAtLeastNTimes(n)
			return This.SubStringsOccurringNTimes(n)

			def SubStringsOccurringAtLeastNTimesQ(n)
				return This.SubStringsOccuringNTimesQ(n)

		#>

	  #------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING EXACTLY N TIMES IN THE LIST  #
	#------------------------------------------------------------#

	def SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		acResult = This.SubStringsQ().ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringExactlyNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringExactlyNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringExactlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringExactlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringExactlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringExactlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#--

		def SubStringsOccurringOnlyNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringOnlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccurringOnlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.SubStringsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringOnlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.SubStringsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringExactlyNTimes(n)
		return This.SubStringsOccurringExactlyNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def SubStringsOccurringExactlyNTimesQ(n)
			return This.SubStringsOccurringExactlyNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringExactlyNTimes(n) # One r instead of 2
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccuringExactlyNTimesQ(n)
				return This.SubStringsOccurringExactlyNTimesQ(n)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringExactlyNTimesOrMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringExactlyNTimesOrMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringExactlyNTimesAndMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringExactlyNTimesAndMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		#--

		def SubStringsOccurringOnlyNTimes(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringOnlyNTimesOrMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesOrMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		def SubStringsOccurringOnlyNTimesAndMore(n)
			return This.SubStringsOccurringExactlyNTimes(n)

			def SubStringsOccurringOnlyNTimesAndMoreQ(n)
				return This.SubStringsOccuringExactlyNTimesQ(n)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING MORE THAN N TIMES IN THE LIST  #
	#--------------------------------------------------------------#

	def SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		acResult = This.SubStringsQ().ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNoLessThanNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccuringNoLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringMoreThanNTimes(n)
		return This.SubStringsOccurringMoreThanNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def SubStringsOccurringMoreThanNTimesQ(n)
			return This.SubStringsOccurringMoreThanNTimes(n)

		#>

		#< @FunctionAlternativeForm

		def SubStringsOccurringNoLessThanNTimes(n)
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccurringNoLessThanNTimesQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringMoreThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccuringMoreThanNTimesQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		def SubStringsOccuringNoLessThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringMoreThanNTimes(n)

			def SubStringsOccuringNoLessThanNTimesCQ(n)
				return This.SubStringsOccurringMoreThanNTimesQ(n)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING LESS THAN N TIMES IN THE LIST  #
	#--------------------------------------------------------------#

	def SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		acResult = This.SubStringsQ().ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringNoMoreThanNTimesCS(n, pCaseSensitive)
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccurringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def SubStringsOccuringLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringLessThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		def SubStringsOccuringNoMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def SubStringsOccuringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringLessThanNTimes(n)
		return This.SubStringsOccurringLessThanNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def SubStringsOccurringLessThanNTimesQ(n)
			return This.SubStringsOccurringLessThanNTimes(n)

		#>

		#< @FunctionAlternativeForms

		def SubStringsOccurringNoMoreThanNTimes(n)
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccurringNoMoreThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def SubStringsOccuringLessThanNTimes(n)
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccuringLessThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		def SubStringsOccuringNoMoreThanNTimes(n) # One r instead of 2
			return This.SubStringsOccurringLessThanNTimes(n)

			def SubStringsOccuringNoMoreThanNTimesQ(n)
				return This.SubStringsOccurringLessThanNTimesQ(n)

		#>

	  #------------------------------------------------------------#
	 #  GETTING SUBSTRINGS OCCURRING N TIMES OR LESS IN THE LIST  #
	#------------------------------------------------------------#

	def SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive) #TODO: Check for performance
		acResult = This.SubStringsQ().ItemsOccurringNTimesOrLessCS(n, pCaseSensitive)
		return acResult

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesOrLessCSQ(n, pCaseSensitive)
			return new stzList( This.SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesOrLessCS(n, pCaseSensitive) # On r instead of 2
			return This.SubStringsOccurringNTimesOrLessCS(n, pCaseSensitive)

			def SubStringsOccuringNTimesOrLessCSQ(n, pCaseSensitive)
				return This.SubStringsOccurringNTimesOrLessCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOccurringNTimesOrLess(n)
		return This.SubStringsOccurringNTimesOrLessCS(n, TRUE)

		#< @FunctionFluentForm

		def SubStringsOccurringNTimesOrLessQ(n)
			return This.SubStringsOccurringNTimesOrLess(n)

		#>

		#< @FunctionMisspelledForm

		def SubStringsOccuringNTimesOrLess(n) # On r instead of 2
			return This.SubStringsOccurringNTimesOrLess(n)

			def SubStringsOccuringNTimesOrLessQ(n)
				return This.SubStringsOccurringNTimesOrLessQ(n)

		#>

	  #=======================================================#
	 #    CHECKING IF THE STRING IS ONE OF THE RING TYPES    #
	#=======================================================#

	def IsRingType()
		cUPPER = ring_upper(This.Content())

		if cUPPER = "NUMBER" or cUPPER = "STRING" or cUPPER = "LIST" or
		   cUPPER = "OBJECT" or cUPPER = "COBJECT"

			return TRUE

		else
			return FALSE
		ok

		def IsARingType()
			return This.IsRingType()

	  #==============================#
	 #  GETTING THE SIZE IN BYTES   #
	#==============================#

	def NumberOfBytesPerChar()
		aResult = []
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			aResult + [ acChars[i], @MSize(acChars[i]) ]
		next

		return aResult

		#< @FunctionAlternativeFormss

		def CountBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytePerChar()
			return This.NumberOfBytesPerChar()

		def SizeInBytesPerChar()
			return This.NumberOfBytesPerChar()

		def SizeInBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		def CountBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		def NumberOfBytesOfEachChar()
			return This.NumberOfBytesPerChar()

		#>

	  #------------------------------#
	 #   BYTES AND BYTES PER CHAR   #
	#==============================#

	def Bytes()
		return This.ToStzListOfBytes().Content()

		#< @FunctionFluentForms

		def BytesQ()
			return This.ToStzListOfBytes()

		#>
	
		#< @FunctionAlternativeForm

		def ToListOfBytes()
			return This.Bytes()
	
			def ToListOfBytesQ()
				return This.BytesQ()
	
		#>

	def BytesPerChar()
		return This.ToStzListOfBytes().BytesPerChar()

	  #--------------------------------------#
	 #   BYTECODES AND BYTECODES PER CHAR   #
	#--------------------------------------#

	def Bytecodes()
		return This.ToStzListOfBytes().Bytecodes()

	def BytecodesPerChar()
		return This.ToStzListOfBytes().BytecodesPerChar()

	  #--------------------------------------------------------#
	 #   TRANSFORMING THE STRING TO A stzListOfBytes OBJECT   #
	#--------------------------------------------------------#

	def ToStzListOfBytes()
		return new stzListOfBytes( This.String() )

	  #===========================================#
	 #   N RIGHT CHARS RETURNED AS A SUBSTRING   #
	#===========================================#

	def NRightCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return NULL

		but n > nLen
			return This.Conten()

		else
			if This.IsRightToleft()
				cResult = This.Section( 1, n )
			else
				cResult = This.Section( nLen - n + 1, nLen )
			end
					
			return cResult
		ok

		#< @FunctionFluentForm

		def NRightCharsAsSubStringQ(n)
			return new stzString( This.NRightCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NRightCharsAsString(n)
			return This.NRightCharsAsSubString(n)

			def NRightCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

		def RightNCharsAsSubString(n)
			return This.NRightCharsAsSubString(n)
	
			def RightNCharsAsString(n)
				return This.RightNCharsAsSubString(n)

			def RightNCharsAsSubStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

			def RightNCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)
	
		def Right(n)
			return This.NRightCharsAsSubString(n)

			def RightQ(n)
				return This.NRightCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Right2CharsAsSubString()
			return This.NRightCharsAsSubString(2)

			def Right2CharsAsString()
				return This.Right2CharsAsSubString()

			def 2RightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def 2RightCharsAsString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsString()
				return This.NRightCharsAsSubString(2)

		def Right3CharsAsSubString()
			return This.NRightCharsAsSubString(3)

			def Right3CharsAsString()
				return This.Right3CharsAsSubString()

			def 3RightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def 3RightCharsAsString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsString()
				return This.NRightCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLeftCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return NULL

		but n > nLen
			return This.Content()

		else
			if IsRightToleft()
				cResult = Section( nLen - n + 1, nLen )
			else
				cResult = Section( 1, n)
			end
	
			return cResult
		ok

		#< @FunctionFluentForm

		def NLeftCharsAsSubStringQ(n)
			return new stzString( This.NLeftCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLeftCharsAsString(n)
			return This.NLeftCharsAsSubString(n)

			def NLeftCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def LeftNCharsAsSubString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsSubStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)
	
		def LeftNCharsAsString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def Left(n)
			return This.NLeftCharsAsSubString(n)

			def LeftQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Left2CharsAsSubString()
			return This.NLeftCharsAsSubString(2)

			def Left2CharsAsString()
				return This.Left2CharsAsSubString()

			def 2LefthtCharsAsSubString()
				return This.NLefttCharsAsSubString(2)

			def 2LefthtCharsAsString()
				return This.NLefttCharsAsSubString(2)

			def LeftTwoCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def LeftTwoCharsAsString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsString()
				return This.NLeftCharsAsSubString(2)

		def Left3CharsAsSubString()
			return This.NLeftCharsAsSubString(3)

			def Left3CharsAsString()
				return This.Left3CharsAsSubString()

			def 3LeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def 3LeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

		#>

	  #-------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A SUBSTRING   #
	#-------------------------------------------#

	def NFirstCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NRightCharsAsSubString(n)
		else
			return This.NLeftCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsAsSubStringQ(n)
			return new stzString( This.NFirstCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NFirstCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFirstCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FirstNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FirstNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
		#>

		#< @FunctionSpecificForms

		def First2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def First2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def First3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def First3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

		#< @FunctionMisspelledForms

		def NFristCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFristCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FristNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FristNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FristNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FristNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		#-- Specific misspelled forms

		def Frist2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def Frist2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FristCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FristCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FristTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FristTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFristCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFristCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def Frist3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def Frist3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FristCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FristCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FristThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FristThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFristCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFristCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LAST CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLastCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftCharsAsSubString(n)
		else
			return This.NRightCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsAsSubStringQ(n)
			return new stzString( This.NLastCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLastCharsAsString(n)
			return This.NLastCharsAsSubString(n)

			def NLastCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsSubString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsSubStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2CharsAsSubString()
			return This.NLastCharsAsSubString(2)

			def Last2CharsAsString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsString()
				return This.NLastCharsAsSubString(2)

		def Last3CharsAsSubString()
			return This.NLastCharsAsSubString(3)

			def Last3CharsAsString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsString()
				return This.NLastCharsAsSubString(3)

		#>

	  #-----------------------------------------------------------#
	 #   GETTING THE NEXT NTH CHAR STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------#

	def NextNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return NULL
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(1, This.NumberOfChars() - 1)
			if pnStartingAt + n <= This.NumberOfChars()
				cResult = This.CharAt(pnStartingAt + n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def NextNthCharQ(n, pnStartingAt)
			return This.NextNthCharQR(n, pnStartingAt, :stzString)

		def NextNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NextNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.NextNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthNextChar()
			return This.NextNthChar()

			def NthNextCharQ()
				return This.NextNthCharQ(n, pnStartingAt)
	
			def NthNextCharQR(pcReturnType)
				return This.NextNthCharQR(n, pnStartingAt, pcReturnType)

		#--

		def NextNthCharST(n, pnStartingAt)
			return This.NextNthChar(n, pnStartingAt)

			def NextNthCharSTQ(n, pnStartingAt)
				return This.NextNthCharQ(n, pnStartingAt)

			def NextNthCharSTQR(n, pnStartingAt, pcReturnType)
				return This.NextNthCharQR(n, pnStartingAt, pcReturnType)

		def NthNextCharST()
			return This.NextNthChar()

			def NthNextCharSTQ()
				return This.NextNthCharQ(n, pnStartingAt)
	
			def NthNextCharSTQR(pcReturnType)
				return This.NextNthCharQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2ndChar()
			return This.NextNthChar(2)

			def 2ndNextChar()
				return This.NextNthChar(2)

			def NextSecondChar()
				return This.NextNthChar(2)

			def SecondNextChar()
				return This.NextNthChar(2)

		def Next3rdChar()
			return This.NextNthChar(3)

			def 3rdNextChar()
				return This.NextNthChar(3)

			def NextThirdChar()
				return This.NextNthChar(3)

			def ThirdNextChar()
				return This.NextNthChar(3)

		#>

	  #-------------------------------------------------------#
	 #   GETTING THE NEXT CHAR STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------------#

	def NextChar(paStartingAt)
		return This.NextNthChar(1)

		#< @FunctionFluentForm

		def NextCharQ(pnStartingAt)
			return This.NextCharQR(pnStartingAt, :stzString)

		def NextCharQR(pnStartingAt, pcReturnType)
			return This.NextNthCharQR(1, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NextCharST(paStartingAt)
			return This.NextChar(paStartingAt)

			def NextCharSTQ(paStartingAt)
				return This.NextCharQ(pnStartingAt)

			def NextCharSTQR(pnStartingAt, pcReturnType)
				return This.NextCharQR(pnStartingAt, pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #   GETTING THE PREVIOUS NTH CHAR STARTING AT A GIVEN POSITION   #
	#----------------------------------------------------------------#

	def PreviousNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(2, This.NumberOfChars())
			if pnStartingAt - n >= 1
				cResult = This.CharAt(pnStartingAt - n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def PreviousNthCharQ(n, pnStartingAt)
			return This.PreviousNthCharQR(n, pnStartingAt, :stzString)

		def PreviousNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthPreviousChar()
			return This.PreviousNthChar()

			def NthPreviousCharQ()
				return This.NthPreviousCharQR(:stzString)
	
			def NthPreviousCharQR(pcReturnType)
				return This.PreviousNthCharQR(n, pnStartingAt, pcReturnType)

		#--

		def PreviousNthCharST(n, pnStartingAt)
			return This.PreviousNthChar(n, pnStartingAt)

			def PreviousNthCharSTQ(n, pnStartingAt)
				return This.PreviousNthCharQ(n, pnStartingAt)

			def PreviousNthCharSTQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNthCharQ(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2ndChar()
			return This.PreviousNthChar(2)

			def 2ndPreviousChar()
				return This.PreviousNthChar(2)

			def PreviousSecondChar()
				return This.PreviousNthChar(2)

			def SecondPreviousChar()
				return This.PreviousNthChar(2)

		def Previous3rdChar()
			return This.PreviousNthChar(3)

			def 3rdPreviousChar()
				return This.PreviousNthChar(3)

			def PreviousThirdChar()
				return This.PreviousNthChar(3)

			def ThirdPreviousChar()
				return This.PreviousNthChar(3)

		#>

	  #------------------------------------------------------------#
	 #   GETTING THE PREVIOUS CHAR STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------------#

	def PreviousChar(pnStartingAt)
		return This.PreviousNthChar(n, 1)

		#< @FunctionFluentForm

		def PreviousCharQ(pnStartingAt)
			return This.PreviousCharQR(pnStartingAt, :stzString)

		def PreviousCharQR(pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousChar(pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousChar(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off	
		#>

		#< @FunctionAlternativeForm

		def PreviousCharST(pnStartingAt)
			return This.PreviousChar(pnStartingAt)

			def PreviousCharSTQ(pnStartingAt)
				return This.PreviousCharQ(pnStartingAt)

			def PreviousCharSTQR(pnStartingAt, pcReturnType)
				return This.PreviousCharQ(pnStartingAt, pcReturnType)

		#>

	  #------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A SUBSTRING)   #
	#------------------------------------------------------------------------#

	def NextNCharsAsSubString(n, pnStartingAt)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt,  pnStartingAt + n - 1)
		return cResult

		#< @FunctionFluentForm

		def NextNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString(This.NextNCharsAsSubString(n, pnStartingAt))

		#>

		#< @FunctionAlternativeForm

		def NextNCharsAsString(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#--

		def NextNCharsAsSubStringST(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsSubStringSTQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		def NextNCharsAsStringST(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringSTQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Next2CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(2, pnStartingAt)

			def Next2CharsAsString(pnStartingAt)
				return This.Next2CharsAsSubString(pnStartingAt)

			def 2NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def 2NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

		def Next3CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(3, pnStartingAt)

			def Next3CharsAsString(pnStartingAt)
				return This.Next3CharsAsSubString(pnStartingAt)

			def 3NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def 3NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A SUBSTRING  #
	#-------------------------------------------------------------------------#

	def PreviousNCharsAsSubString(n, pnStartingAt)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt - n + 1, pnStartingAt)

		return cResult

		#< @FunctionFluentForm

		def PreviousNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString( This.PreviousNCharsAsSubString(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def PreviousNCharsAsString(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)
	
		#--

		def PreviousNCharsAsSubStringST(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsSubStringSTQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)

		def PreviousNCharsAsStringST(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringSTQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Previous2CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def Previous2CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

		def Previous3CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def Previous3CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)
	
			def PreviousThreeCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def PreviousThreeCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

		#>

	  #===============================================#
	 #   N RIGHT CHARS RETURNED AS A LIST OF CHARS   #
	#===============================================#

	def NRightChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return []

		but n > nLen
			return This.Content()

		ok

		acResult = []

		if This.IsRightToleft()
			acResult = This.SectionQ( 1, n ).Chars()
		else
			acResult = This.SectionQ( nLen - n + 1, nLen ).Chars()
		end
					
		return acResult

		#< @FunctionFluentForm

		def NRightCharsQ(n)
			return This.NRightCharsQR(n, :stzList)

		def NRightCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NRightChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NRightChars(n) )

			on :stzListOfChars
				return new stzListOfchars( This.NRightChars(n) )

			on :stzString
				return new stzString( This.NRightCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def RightNChars(n)
			return This.NRightChars(n)
	
			def RightNCharsQ(n)
				return This.NRightCharsQ(n)

			def RightNCharsQR(n, pcReturnType)
				return This.NRightCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Right2Chars()
			return This.NRightChars(2)

			def 2RightChars()
				return This.NRightChars(2)

			def RightTwoChars()
				return This.NRightChars(2)

			def TwoRightChars()
				return This.NRightChars(2)

	
		def Right3Chars()
			return This.NRightChars(3)

			def 3RightChars()
				return This.NRightChars(3)

			def RightThreeChars()
				return This.NRightChars(3)

			def ThreeRightChars()
				return This.NRightChars(3)

		#>

	  #----------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLeftChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfChars()

		if n = 0
			return []

		but n > nLen
			return This.Content()

		ok

		acResult = []

		if IsRightToleft()
			acResult = SectionQ( nLen - n + 1, nLen ).Chars()
		else
			acResult = SectionQ( 1, n).Chars()
		end
	
		return acResult


		#< @FunctionFluentForm

		def NLeftCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NLeftCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLeftChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLeftChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLeftChars(n) )

			on :stzString
				return new stzString( This.NLeftCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LeftNChars(n)
			return This.NLeftChars(n)
	
			def LeftNCharsQ(n)
				return This.NLeftCharsQ(n)

			def LeftNCharsQR(n, pcReturnType)
				return This.NLeftCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Left2Chars()
			return This.NLeftChars(2)

			def 2LefthtChars()
				return This.NLefttChars(2)

			def LeftTwoChars()
				return This.NLeftChars(2)

			def TwoLeftChars()
				return This.NLeftChars(2)

	
		def Left3Chars()
			return This.NLeftChars(3)

			def 3LeftChars()
				return This.NLeftChars(3)

			def LeftThreeChars()
				return This.NLeftChars(3)

			def ThreeLeftChars()
				return This.NLeftChars(3)

		#>

	  #-----------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A LIST OF CHARS   #
	#-----------------------------------------------#

	def NFirstChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		if This.IsRightToLeft()
			return This.NRightChars(n)
		else
			return This.NLeftChars(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NFirstCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NFirstChars(n) )

			on :stzString
				return new stzString( This.NFirstCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FirstNChars(n)
			return This.NFirstChars(n)
	
			def FirstNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FirstNCharsQR(n, pcReturnType)
				return This.NFirstCharsQR(n, pcReturnType)

		#-- item as alternative of char #TODO generalise it!

		def NFirstItems(n)
			return This.NFirstChars(n)

			def NFirstItemsQ(n)
				return This.NFirstCharsQ(n)

		def FirstNItems(n)
			return This.NFirstChars(n)

			def FirstNItemsQ(n)
				return This.NFirstCharsQ(n)

		#>

		#< @FunctionSpecificForms

		def First2Chars()
			return This.NFirstChars(2)

			def 2FirstChars()
				return This.NFirstChars(2)

			def FirstTwoChars()
				return This.NFirstChars(2)

			def TwoFirstChars()
				return This.NFirstChars(2)

		def First3Chars()
			return This.NFirstChars(3)

			def 3FirstChars()
				return This.NFirstChars(3)

			def FirstThreeChars()
				return This.NFirstChars(3)

			def ThreeFirstChars()
				return This.NFirstChars(3)

		def First4Chars()
			return This.FirstNChars(4)
	
			def 4FirstChars()
				return This.First4Chars()
	
			def FirstFourChars()
				return This.First4Chars()
	
			def FourFirstChars()
				return This.First4Chars()
	
		def First5Chars()
			return This.FirstNChars(5)
	
			def 5FirstChars()
				return This.First5Chars()
	
			def FirstFiveChars()
				return This.First5Chars()
	
			def FiveFirstChars()
				return This.First5Chars()
	
		def First6Chars()
			return This.FirstNChars(6)
	
			def 6FirstChars()
				return This.First6Chars()
	
			def FirstSixChars()
				return This.First6Chars()
	
			def SixFirstChars()
				return This.First6Chars()
	
		def First7Chars()
			return This.FirstNChars(7)
	
			def 7FirstChars()
				return This.First7Chars()
	
			def FirstSevenChars()
				return This.First7Chars()
	
			def SevenFirstChars()
				return This.First7Chars()
	
		def First8Chars()
			return This.FirstNChars(8)
	
			def 8FirstChars()
				return This.First8Chars()
	
			def FirstEightChars()
				return This.First8Chars()
	
			def EightFirstChars()
				return This.First8Chars()
	
		def First9Chars()
			return This.FirstNChars(9)
	
			def 9FirstChars()
				return This.First9Chars()
	
			def FirstNineChars()
				return This.First9Chars()
	
			def NineFirstChars()
				return This.First9Chars()
	
		def First10Chars()
			return This.FirstNChars(10)
	
			def 10FirstChars()
				return This.First10Chars()
	
			def FirstTenChars()
				return This.First10Chars()
	
			def TenFirstChars()
				return This.First10Chars()
	
		#>

		#< @FunctionAlternativeForms

		def FristNChars(n)
			return This.NFirstChars(n)
	
			def FristNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FristNCharsQR(n, pcReturnType)
				return This.NFirstCharsQR(n, pcReturnType)

		#-- specific misspelled forms

		def Frist2Chars()
			return This.NFirstChars(2)

			def 2FristChars()
				return This.NFirstChars(2)

			def FristTwoChars()
				return This.NFirstChars(2)

			def TwoFristChars()
				return This.NFirstChars(2)

		def Frist3Chars()
			return This.NFirstChars(3)

			def 3FristChars()
				return This.NFirstChars(3)

			def FristThreeChars()
				return This.NFirstChars(3)

			def ThreeFristChars()
				return This.NFirstChars(3)

		def Frist4Chars()
			return This.FristNChars(4)
	
			def 4FristChars()
				return This.First4Chars()
	
			def FristFourChars()
				return This.First4Chars()
	
			def FourFristChars()
				return This.First4Chars()
	
		def Frist5Chars()
			return This.FirstNChars(5)
	
			def 5FristChars()
				return This.First5Chars()
	
			def FristFiveChars()
				return This.First5Chars()
	
			def FiveFristChars()
				return This.First5Chars()
	
		def Frist6Chars()
			return This.FirstNChars(6)
	
			def 6FristChars()
				return This.First6Chars()
	
			def FristSixChars()
				return This.First6Chars()
	
			def SixFristChars()
				return This.First6Chars()
	
		def Frist7Chars()
			return This.FirstNChars(7)
	
			def 7FristChars()
				return This.First7Chars()
	
			def FristSevenChars()
				return This.First7Chars()
	
			def SevenFristChars()
				return This.First7Chars()
	
		def Frist8Chars()
			return This.FirstNChars(8)
	
			def 8FristChars()
				return This.First8Chars()
	
			def FristEightChars()
				return This.First8Chars()
	
			def EightFristChars()
				return This.First8Chars()
	
		def Frist9Chars()
			return This.FirstNChars(9)
	
			def 9FristChars()
				return This.First9Chars()
	
			def FristNineChars()
				return This.First9Chars()
	
			def NineFristChars()
				return This.First9Chars()
	
		def Frist10Chars()
			return This.FirstNChars(10)
	
			def 10FristChars()
				return This.First10Chars()
	
			def FristTenChars()
				return This.First10Chars()
	
			def TenFristChars()
				return This.First10Chars()

		#>

	  #----------------------------------------------#
	 #   N LAST CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLastChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftChars(n)
		else
			return This.NRightChars(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsQ(n)
			return This.NLastCharsQR(n, :stzList)

		def NLastCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLastChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLastChars(n) )

			on :stzString
				return new stzString( This.NLastCharsQR(n, :stzListOfStrings).Concatenated() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNChars(n)
			return This.NLastChars(n)
	
			def LastNCharsQ(n)
				return This.NLastCharsQ(n)

			def LastNCharsQR(n, pcReturnType)
				return This.NLastCharsQR(n, pcReturnType)

		#-- item as alternative of char #TODO generalise it!

		def NLastItems(n)
			return This.NLastChars(n)

			def NLastItemsQ(n)
				return This.NLastCharsQ(n)

		def LastNItems(n)
			return This.NLastChars(n)

			def LastNItemsQ(n)
				return This.NLastCharsQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2Chars()
			return This.NLastChars(2)

			def 2LastChars()
				return This.NLastChars(2)

			def LastTwoChars()
				return This.NLastChars(2)

			def TwoLastChars()
				return This.NLastChars(2)

		def Last3Chars()
			return This.NLastChars(3)

			def 3LastChars()
				return This.NLastChars(3)

			def LastThreeChars()
				return This.NLastChars(3)

			def ThreeLastChars()
				return This.NLastChars(3)

		def Last4Chars()
			return This.LastNChars(4)
	
			def 4LastChars()
				return This.Last4Chars()
	
			def LastFourChars()
				return This.Last4Chars()
	
			def FourLastChars()
				return This.Last4Chars()
	
		def Last5Chars()
			return This.LastNChars(5)
	
			def 5LastChars()
				return This.Last5Chars()
	
			def LastFiveChars()
				return This.Last5Chars()
	
			def FiveLastChars()
				return This.Last5Chars()
	
		def Last6Chars()
			return This.LastNChars(6)
	
			def 6LastChars()
				return This.Last6Chars()
	
			def LastSixChars()
				return This.Last6Chars()
	
			def SixLastChars()
				return This.Last6Chars()
	
		def Last7Chars()
			return This.LastNChars(7)
	
			def 7LastChars()
				return This.Last7Chars()
	
			def LastSevenChars()
				return This.Last7Chars()
	
			def SevenLastChars()
				return This.Last7Chars()
	
		def Last8Chars()
			return This.LastNChars(8)
	
			def 8LastChars()
				return This.Last8Chars()
	
			def LastEightChars()
				return This.Last8Chars()
	
			def EightLastChars()
				return This.Last8Chars()
	
		def Last9Chars()
			return This.LastNChars(9)
	
			def 9LastChars()
				return This.Last9Chars()
	
			def LastNineChars()
				return This.Last9Chars()
	
			def NineLastChars()
				return This.Last9Chars()
	
		def Last10Chars()
			return This.LastNChars(10)
	
			def 10LastChars()
				return This.Last10Chars()
	
			def LastTenChars()
				return This.Last10Chars()
	
			def TenLastChars()
				return This.Last10Chars()
	
		#>

	  #---------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A LIST OF CHARS)  #
	#---------------------------------------------------------------------------#

	def NextNChars(n, pnStartingAt)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt, pnStartingAt + n - 1).Chars()
		return acResult

		#< @FunctionFluentForm

		def NextNCharsQ(n, pnStartingAt)
			return This.NextNCharsQR(n, pnStartingAt, :stzList)

		def NextNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NNextChars(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsQ(n, pnStartingAt)
				return This.NNextCharsQR(n, pnStartingAt, :stzList)

			def NNextCharsQR(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQR(n, pnStartingAt, pcReturnType)

		#--

		def NextNCharsST(n, pnStartingAt)
			return This.NNextChars(n, pnStartingAt)

			def NextNCharsSTQ(n, pnStartingAt)
				return This.NextNCharsQ(n, pnStartingAt)

			def NextNCharsSTQR(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQR(n, pnStartingAt, pcReturnType)

		def NNextCharsST(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsSTQ(n, pnStartingAt)
				return This.NNextCharsQR(n, pnStartingAt, :stzList)

			def NNextCharsSTQR(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQR(n, pnStartingAt, pcReturnType)


		#>

		#< @FunctionSpecificForms

		def Next2Chars(pnStartingAt)
			return This.NextNChars(2, pnStartingAt)

			def 2NextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def NextTwoChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def TwoNextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

		def Next3Chars(pnStartingAt)
			return This.NextNChars(3, pnStartingAt)

			def 3NextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def NextThreeChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def ThreeNextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A LIST OF CHARS  #
	#-----------------------------------------------------------------------------#

	def PreviousNChars(n, pnStartingAt)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
	
			if pnStartingAt < 0
				pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
			ok
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt - n + 1, pnStartingAt).Chars()

		return acResult

		#< @FunctionFluentForm

		def PreviousNCharsQ(n, pnStartingAt)
			return This.PreviousNCharsQR(n, pnStartingAt, :stzList)

		def PreviousNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NPreviousChars(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsQ(n, pnStartingAt)
				return This.NPreviousCharsQR(n, pnStartingAt, :stzList)

			def NPreviousCharsQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQR(n, pnStartingAt, pcReturnType)

		#--

		def PreviousNCharsST(n, pnStartingAt)
			return This.NPreviousChars(n, pnStartingAt)

			def PreviousNCharsSTQ(n, pnStartingAt)
				return This.PreviousNCharsQ(n, pnStartingAt)

			def PreviousNCharsSTQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQR(n, pnStartingAt, pcReturnType)

		def NPreviousCharsST(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsSTQ(n, pnStartingAt)
				return This.NPreviousCharsQR(n, pnStartingAt, :stzList)

			def NPreviousCharsSTQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQR(n, pnStartingAt, pcReturnType)
		#>

		#< @FunctionSpecificForms

		def Previous2Chars(pnStartingAt)
			return This.PreviousNChars(2, pnStartingAt)

			def 2PreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def PreviousTwoChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def TwoPreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

		def Previous3Chars(pnStartingAt)
			return This.PreviousNChars(3, pnStartingAt)

			def 3PreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def PreviousThreeChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def ThreePreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

		#>

	  #====================================================#
	 #  INFERING A RING OR SOFTANZA TYPE FROM THE STRING  #
	#====================================================#

	def InfereType()
		cStr = This.Lowercased()

		# Checking if the string correponds to one of the 4 Ring types

		if cStr = :number or cStr = :numbers or Q(cStr).BeginsWith(:Number)
			return :Number
	
		but cStr = :string or cStr = :strings or Q(cStr).BeginsWith(:String)
			return :String
	
		but cStr = :list or cStr = :lists or Q(cStr).BeginsWith(:List) or
		    cStr = :pair or cStr = :pairs or Q(cStr).BeginsWith(:pair)
	
			return :List
	
		but cStr = :object or cStr = :objects or Q(cStr).BeginsWith(:Object)
			return :Object
	
		ok
	
		# Checking if the string correponds to one of the Softanza types

		if Q(cStr).BeginsWithCS("stz", :CS = FALSE)
			acStzClasses = StzClassesXT()
			nLen = len(acStzClasses)

			for i = 1 to nLen
				aPair = acStzClasses[i]
				if aPair[1] = cStr or aPair[2] = cStr
					return aPair[1]
				ok
			next

		but Q("stz" + cStr).IsStzType()
			return "stz" + cStr

		but Q(cStr).IsPluralOfAStzType()
			return PluralToStzType(cStr)

		but Q("stz" + cStr).IsPluralOfAStzType()
			return PluralToStzType("stz" + cStr)

		ok

		#< @FunctionAlternativeForms

		def InfereTypeQ()
			return new stzString( This.InfereType() )

		def InfereStzClass()
			return This.InfereType()

			def InfereStzClassQ()
				return new stzString( This.InfereStzClass() )

		def InfereStzClassName()
			return This.InfereType()

			def InfereStzClassNameQ()
				return new stzString( This.InfereStzClass() )

		#>

	def InferedType()
		return This.InfereType()

		#< @FunctionAlternativeForms

		def InferedStzClass()
			return This.InfereType()

		def InferedStzClassName()
			return This.InfereType()

		#>

	  #----------------------------------------------------#
	 #  INFERING A SOFTANZA CLASS METHOD FROM THE STRING  #
	#----------------------------------------------------#

	def InfereMethod(pcFromStzClass)

		if isList(pcFromStzClass) and
		   Q(pcFromStzClass).IsOneOfTheseNamedParams([ :From, :In, :Of ])
			pcFromStzClass = pcFromStzClass[2]
		ok

		if NOT isString(pcFromStzClass)
			stzRaise("Incorrect param type! pcFromStzClass must be a string.")
		ok

		if Q(pcFromStzClass).IsPluralOfAStzType()
			pcFromStzClass = PluralToStzType(pcFromStzClass)
		ok

		if NOT Q(pcFromStzClass).IsStzClass()
			stzRaise("Syntax error! pcFromStzClass must be a valid Softanza class name.")
		ok

		cCode = 'acTheseMethods = Stz("' +
			Q(pcFromStzClass).FirstNCharsRemoved(3) + '",
			:Methods)'

		eval(cCode)

		cMethod = ""

		oList = new stzList( acTheseMethods )

		if oList.ContainsCS( "is" + This.String(), :CS = FALSE )
			cMethod = "is" + This.String()

		but oList.ContainsCS( "is" + This.LastCharRemoved(), :CS = FALSE )
			cMethod = "is" + This.LastCharRemoved()

		else
			stzRaise("Sorry! Can't infere the method name from the provided string.")
		ok

		return cMethod

		def InfereMethodQ()
			return new stzString( This.InfereMethod() )

	def InferedMethod()
		return InfereMthod()

	  #--------------------------------------------------------------#
	 #    CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	#--------------------------------------------------------------#

	def IsStzClassName()
		acStzClasses = StzClasses()

		n = ring_find( StzClasses(), This.Lowercased() )

		if n > 0
			return TRUE
		else
			return FALSE
		ok

		def IsStzType()
			return This.IsStzClassName()

		def IsStzClass()
			return This.IsStzClassName()

		def IsAStzClassName()
			return This.IsStzClassName()

		def IsAStzType()
			return This.IsStzClassName()

		def IsAStzClass()
			return This.IsStzClassName()

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF ANY SOFTANZA TYPE  #
	#------------------------------------------------------------------#

	def IsPluralOfAStzType()

		if QR( StzTypesXT(), :stzListOfPairs ).
		   SecondItemsQ().
		   ContainsCS( This.Content(), :CaseSensitive = FALSE )

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsPluralOfStzType()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClassName()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClassName()
			return This.IsPluralOfAStzType()

		#--

		def IsStzClassInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassInPlural()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPlural()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPlural()
			return This.IsPluralOfAStzType()

		#>

	   #-------------------------------------------------------------#
	  #   CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	 #   NO MATTER IT WAS IN SINGULAR OR PLURAL FORM               #
	#-------------------------------------------------------------#

	def IsStzClassNameXT()
		
		if This.IsStzClassName() or This.IsStzClassNameInPluralForm()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsStzTypeXT()
			return This.IsStzClassNameXT()

		def IsStzClassXT()
			return This.IsStzClassNameXT()

		def IsAStzClassNameXT()
			return This.IsStzClassNameXT()

		def IsAStzTypeXT()
			return This.IsStzClassNameXT()

		def IsAStzClassXT()
			return This.IsStzClassNameXT()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF A GIVEN SOFTANZA TYPE  #
	#----------------------------------------------------------------------#

	def IsPluralOfThisStzType(cType)

		if Q(cType).IsAStzType() and
		   PluralOfThisStzType(cType) = This.String()

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsPluralOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsPluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsThePluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#>

	  #=====================================================================#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER  #
	#=====================================================================#

	#TODO: Unify the bounds fucntions in stzString and stzList

	def FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)
		if CheckParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params types! Both n1 and n2 must be numbers.")
			ok

			if NOT @BothAreNumbers(nCharsBefore, nCharsAfter)
				StzRaise("Incorrect params types! Both nCharsBefore and nCharsAfter must be numbers.")
			ok
		ok

		if nCharsBefore > n1
			nCharsBefore = n1 - 1
		ok

		nLen = This.NumberOfChars()

		if nCharsAfter > nLen - n2
			nCharsAfter = nLen - n2
		ok

		anSectionBefore = [0, 0]

		if nCharsBefore != 0
			anSectionBefore[1] = (n1 - nCharsBefore)
			anSectionBefore[2] = (n1 - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (n2 + 1)
			anSectionAfter[2] = (n2 + nCharsAfter)
		ok

		aResult = [ anSectionBefore, anSectionAfter ]

		return aResult

		#< @FunctionAlternativeForm

		def FindSectionBoundsAsSections(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)

		#>

	def FindSectionBounds(n1, n2, nCharsBefore, nCharsAfter)

		anResult = QR(
			This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter),
			:stzListOfPairs
		).FirstItems()

		return anResult

		def FindSectionBoundsZ(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBounds(n1, n2, nCharsBefore, nCharsAfter)

	def FindSectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
		anResult = QR(
			This.FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter),
			:stzListOfPairs
		).FirstItems()

		return anResult

		def FindSectionBoundsIBZ(n1, n2, nCharsBefore, nCharsAfter)
			return This.FindSectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
			
	  #---------------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	def FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter)
		aSections = This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)

		aSections[1][1]++
		aSections[1][2]++

		aSections[2][1]--
		aSections[2][2]--

		return aSections

	  #---------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER  #
	#=====================================================================#

	def SectionBounds(n1, n2, nCharsBefore, nCharsAfter)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.SectionBounds(10, 13, 2, 3)
		#--> [ "<<", ">>>" ]

		*/

		aSections = This.FindSectionBoundsZZ(n1, n2, nCharsBefore, nCharsAfter)
		acResult = This.Sections(aSections)

		return acResult

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	def SectionBoundsIB(n1, n2, nCharsBefore, nCharsAfter)
		aSections = This.FindSectionBoundsIBZZ(n1, n2, nCharsBefore, nCharsAfter)
		return This.Sections(aSections)

	  #-------------------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, ALONG WITH THEIR POSITIONS  #
	#=================================================================================================#

	def SectionBoundsZ(n1, n2, nCharBefore, nCharsAfter) #TODO: check for performance

		acBounds = This.SectionBounds(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBounds(n1, n2, nCharBefore, nCharsAfter)

		aResult = Associattion([ acBounds, anPos ])
		#NOTE: We've used a misspelled form of Association()
		# function (a one more "t"), but Softanza tolerates it!

		return aResult

		def SectionBoundsAndTheirPositions(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsZ(n1, n2, nCharBefore, nCharsAfter)

	  #-------------------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, ALONG WITH THEIR POSITIONS  #
	#=================================================================================================#

	def SectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter) #TODO: check for performance

		acBounds = This.SectionBounds(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, anPos ])

		return aResult

		def SectionBoundsAndTheirSections(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsZZ(n1, n2, nCharBefore, nCharsAfter)

	   #----------------------------------------------------------------------#
	  #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER,  #
	 #  INCLDUING BOUNDS, ALONG WITH THEIR POSITIONS                        #
	#======================================================================#

	def SectionBoundsIBZ(n1, n2, nCharBefore, nCharsAfter) #TODO: check for performance

		acBounds = This.SectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)
		anPos = This.FindSectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, anPos ])

		return aResult

		def SectionBoundsAndTheirPositionsIB(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsIBZ(n1, n2, nCharBefore, nCharsAfter)

	   #----------------------------------------------------------------------#
	  #  GETTING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER,  #
	 #  INCLDUING BOUNDS, ALONG WITH THEIR SECTIONS                         #
	#======================================================================#

	def SectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter) #TODO: check for performance

		acBounds  = This.SectionBoundsIB(n1, n2, nCharBefore, nCharsAfter)
		aSections = This.FindSectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter)

		aResult = Association([ acBounds, aSections ])
		return aResult

		def SectionBoundsAndTheirSectionsIB(n1, n2, nCharBefore, nCharsAfter)
			return This.SectionBoundsIBZZ(n1, n2, nCharBefore, nCharsAfter)

	  #---------------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A SECTION, N CHARS BEFORE AND N CHARS AFTER, INCLUDING BOUNDS  #
	#=======================================================================================#

	# A more expressive, but less performant, alternative to SectionsBounds()

	def Sit(paPositionOrSection, paHarvest)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.Sit(
			:OnSection = [10, 13],
			:Harvest = [ :NCharsBefore = 2, :NCharsAfter = 3 ]
		)

		#--> [ "<<", ">>>" ]

		*/

		# Checking params

		if CheckParams()

			if isList(paPositionOrSection) and
				Q(paPositionOrSection).IsOneOfTheseNamedParams([
					:On, :OnPosition, :OnSection,
					:In, :InPosition, :InSection,
					:Position, :Section
				])
	
				paPositionOrSection = paPositionOrSection[2]
			ok
	
			if isNumber(paPositionOrSection)
	
				aTemp = []
				aTemp + paPositionOrSection
				aTemp + paPositionOrSection
	
				paPositionOrSection = aTemp
			ok
	
			if NOT ( isList(paPositionOrSection) and
				 Q(paPositionOrSection).IsPairOfNumbers() )
	
				stzRaise("Incorrect param! paPositionOrSection must be a position (number) or a section (pair of numbers).")
			ok
	
			aSection = paPositionOrSection
			bReturnSections = FALSE
	
			if isList(paHarvest) and
			   Q(paHarvest).IsOneOfTheseNamedParams([
	
					:Harvest, :AndHarvest,
					:AndThenHarvest, :ThenHarvest,
	
					:Yield, :AndYield,
					:AndThenYield, :ThenYield,
	
					:HarvestSection, :AndHarvestSection,
					:AndThenHarvestSection, :ThenHarvestSection,
	
					:YieldSection, :AndYieldSection,
					:AndThenYieldSection, :ThenYieldSection,
	
					:HarvestSections, :AndHarvestSections,
					:AndThenHarvestSections, :ThenHarvestSections,
	
					:YieldSections, :AndYieldSections,
					:AndThenYieldSections, :ThenYieldSections ])
	
				if Q(paHarvest[1]).ContainsCS(:Section, :CS = FALSE)
					bReturnSections = TRUE
				ok
	
				paHarvest = paHarvest[2]
			ok
	
			if NOT len(paHarvest) = 2
				stzRaise("Incorrect param! paHarvest must be a list of 2 items.")
			ok
	
			if isList(paHarvest[1]) and Q(paHarvest[1]).IsNCharsBeforeNamedParam()
				paHarvest[1] = paHarvest[1][2]
			ok
	
			if isList(paHarvest[2]) and Q(paHarvest[2]).IsNCharsAfterNamedParam()
				paHarvest[2] = paHarvest[2][2]
			ok
	
			if NOT @BothAreNumbers(paHarvest[1], paHarvest[2])
				stzRaise("Incorrect param! paHarvest must be a pair of numbers.")
			ok
	
		ok

		#-- Doing the job

		nCharsBefore = paHarvest[1]
		if nCharsBefore > aSection[1] - 1
			nCharsBefore = aSection[1] - 1
		ok

		nLen = This.NumberOfChars()
		nCharsAfter  = paHarvest[2]
		if nCharsAfter > nLen - aSection[2]
			nCharsAfter = nLen - aSection[2]
		ok

		anSectionBefore = [0, 0]

		if nCharsBefore != 0
			anSectionBefore[1] = (aSection[1] - nCharsBefore)
			anSectionBefore[2] = (aSection[1] - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (aSection[2] + 1)
			anSectionAfter[2] = (aSection[2] + nCharsAfter)
		ok

		if bReturnSections
			aResult = [ anSectionBefore, anSectionAfter ]
			
		else
			aResult = This.Sections([ anSectionBefore, anSectionAfter ])
		ok

		return aResult

		#< @FunctionAlternativeForms

		def SitIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SitOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Settle(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SettleIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def SettleOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Enclose(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def EncloseIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def EncloseOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Occuppy(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def OccuppyIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def OccuppyOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def Stay(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def StayIn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		def StayOn(paPositionOrSection, paHervest)
			return This.Sit(paPositionOrSection, paHervest)

		#>

	#TODO: Add these alternatives

	def SitOnSection(n1, n2, paHarvest)
		return This.Sit([n1, n2], paHarvest)

		#< @FunctionAlternativeForms

		def SitOnSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitOnSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def SitInSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitInSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def SitInSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def StayInSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayOnSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayInSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def StayInSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def EncloseSection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def EncloseSectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def EncoloseSectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#--

		def OccuppySection(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def OccuppySectionAndHarvest(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		def OccuppySectionAndYield(n1, n2, paHarvest)
			return This.SitOnSection(n1, n2, paHarvest)

		#>

	def SitAndYield(paPositionOrSection, paHarvest)
		return This.Sit(paPositionOrSection, paHarvest)

		#< @FunctionAlternatives

		def StayAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def EncloseAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def OccuppyAndYield(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		#--

		def SitAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def StayAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def EncloseAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		def OccuppyAndHarvest(paPositionOrSection, paHarvest)
			return This.SitAndYield()

		#>

	def SitOnPosition(n, paHarvest)
		return This.Sit(n, paHarvest)

		def SitInPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def SitAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def StayInPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def StayAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def EnclosePosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)

		def EncloseAtPosition(n, paHarvest)
			return This.SitOnPosition(n, paHarvest)


	def SitOnPositionAndYield(n, paHarvest)
		return This.Sit(n, paHarvest)

		#< @FunctionAlternativeForms

		def SitInPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def SitAtPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayOnPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayInPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayAtPositionAndYield(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		#--

		def SitAtPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayOnPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayInPositionAndHaervest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		def StayAtPositionAndHarvest(n, paHarvest)
			return This.SitOnPositionAndYield(n, paHarvest)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF MANY SECTIONS, N CHARS BEFORE AND N CHARS AFTER  # 
	#-------------------------------------------------------------------------#

	def SectionsBounds(paSections, nCharsBefore, nCharsAfter)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> and [[happy]]] day!")

		o1.SectionsBounds([ [10, 13], [24, 28] ], 2, 3)
		#--> [ ["<<", ">>>"], ["[[", "]]]"] ]

		*/

		if CheckParams()
			if NOT (isList(paSections) and Q(paSections).IsListOfPairsOfNumbers())
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acResult = []

		nLenSections = len(paSections)

		for i = 1 to nLenSections

			n1 = paSections[i][1]
			n2 = paSections[i][2]

			if nCharsBefore > n1
				nCharsBefore = n1 - 1
			ok
	
			nLenStr = This.NumberOfChars()
	
			if nCharsAfter > nLenStr - n2
				nCharsAfter = nLenStr - n2
			ok
	
			anSectionBefore = [0, 0]
	
			if nCharsBefore != 0
				anSectionBefore[1] = (n1 - nCharsBefore)
				anSectionBefore[2] = (n1 - 1)
			ok
	
			anSectionAfter = [0, 0]
			if anSectionAfter != 0
				anSectionAfter[1] = (n2 + 1)
				anSectionAfter[2] = (n2 + nCharsAfter)
			ok
				
			acResult + This.Sections([ anSectionBefore, anSectionAfter ])
		next

		return acResult

		#< @FunctionAlternativeForm

		def ManySectionsBounds(paSections, nCharsBefore, nCharsAfter)
			return This.SectionsBounds(paSections, nCharsBefore, nCharsAfter)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF MANY SECTIONS, RESPECTIVELY, N CHARS BEFORE AND N CHARS AFTER  # 
	#---------------------------------------------------------------------------------------#

	  #==============================#
	 #     BOUNDS OF THE STRING     #
	#==============================#

	// Verifies if the string is bounded by one or two substrings

	def IsBoundedByCS(pacBounds, pCaseSensitive)
		/* EXAMPLE

		# Case 1 : Checking if the string is bounded by ONE substring

		o1 = new stzString("--")
		? o1.IsBoundedBy("-") #--> TRUE

		# Case 1 : Checking if the string is bounded by TWO substrings

		o1 = new stzString("-_")
		? o1.IsBoundedBy([ "-", "_" ]) #--> TRUE

		# Case 3 : A special case to check if the string is bounded
		# by one or two substrings, INSIDE an other string

		? Q("").IsBoundedBy([ "-", :In = "--" ])
		#--> TRUE

		*/

		# Managing this special syntax:
		# ? Q("").IsBoundedBy([ "-", :In = "--" ])

		if isList(pacBounds) and Q(pacBounds).IsPair() and
		   isList(pacBounds[2]) and Q(pacBounds[2]).IsPair()

			if Q(pacBounds[2]).IsInNamedParam()
				return This.IsBoundedByInCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			but Q(pacBounds[2]).IsAndNamedParam()
				pacBounds[2] = pacBounds[2][2]
			ok

		ok

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a list of pairs.")
		ok

		if This.BeginsWithCS(cBound1, pCaseSensitive) and
		   This.EndsWithCS(cBound2, pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsBoundedBy(pacBounds)
		return This.IsBoundedByCS(pacBounds, TRUE)

	   #--------------------------------------------------------#
	  #  CHECKING IF THE STRING IS BOUNDED BY A GIVEN PAIR OF  #
	 #  SUBSTRINGS INSIDE A GIVEN STRING                      #
	#--------------------------------------------------------#

	def IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		/* EXAMPLE 1

		? Q("").IsBoundedByXT([ "-", :In = "--" ])
		#--> TRUE

		EXAMPLE 2

		o1 = new stzString("")
		? o1.IsBoundedByIn([ "-", "-" ], :In = "... -- ...")
		#--> TRUE

		*/

		if isString(pacBounds)
			aTemp = []
			aTemp + pacBounds + pacBounds

			pacBounds = aTemp
		ok

		if NOT ( isList(pacBounds) and Q(pacBounds).IsPairOfStrings() )
			StzRaise("Incorrect param type! paBounds must be a pair of strings.")
		ok


		if isList(pIn) and Q(pIn).IsInOrInsideNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pIn must be a string or list.")
		ok

		bResult = FALSE

		if isString(pIn)

			oStr = new stzString(pIn)
			bResult = oStr.SubStringIsBoundedByCS( This.String(), pacBounds, pCaseSensitive )

		but isList(pIn) and Q(pIn).IsListOfStrings()

			#TODO
			StzRaise("Currently, the function works only on one string. List of strings are not supported.")
		ok
	
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundedByCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenCSIB(pacBounds, pIn, pCaseSensitive)

			if NOT ( isList(pacBounds) and len(pacBounds) = 2 )
				StzRaise("Incorrect param! pacBounds must be a list of 2 items.")
			ok

			acBounds = []

			if isString(pacBounds[1])
				acBounds + pacBounds[1]
			ok

			if isString(pacBounds[2])
				acBounds + pacBounds[2]

			but isList(pacBounds[2]) and
			   Q(pacBounds[2]).IsAndNamedParam() and
			   isString(pacBounds[2][2])

				acBounds + pacBounds[2][2]
				
			ok

			if NOT Q(acBounds).IsPairOfStrings()
				StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
			ok

			bResult = This.IsBoundedByInCS(acBounds, pIn, pCaseSensitive)

			return bResult

		def IsBoundedByInCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenInCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBetweenInCSIB(pacBounds, pIn, pCaseSensitive)

		#--

		def IsBoundedByCSXT(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenCSXT(pacBounds, pIn, pCaseSensitive)
			return This.IsBetweenCSIB(pacBounds, pIn, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def IsBoundedByIn(pacBounds, pIn)
		return This.IsboundedByInCS(pacBounds, pIn, TRUE)

		#< @FunctionAlternativeForm

		def IsBoundedByIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenIB(pacBounds, pIn)
			return This.IsBetweenCSIB(pacBounds, pIn, TRUE)

		def IsBoundedByInIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenInIB(pacBounds, pIn)
			return This.IsBetweenCSIB(pacBounds, pIn, TRUE)

		#--

		def IsBoundedByXT(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenXT(pacBounds, pIn)
			return This.IsBetweenIB(pacBounds, pIn)

		#>

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDING OF A GIVEN STRING INSIDE ANOTHER STRING  #
	#------------------------------------------------------------------------------#

	def IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("_")
		? o1.IsBoundOf("world", :In = "hello _world_ and <world>!")
		#--> TRUE
		*/

		if CheckParams()
			if isList(pcInStr) and Q(pcInStr).IsInNamedParam()
				pcInStr = pcInStr[2]
			ok

			if NOT isString(pcInStr)
				StzRaise("Incorrect param type! pcInStr must be a string.")
			ok
		ok

		cBounded = This.String() + pcSubStr + This.String()
		bResult = StzStringQ(pcInStr).ContainsCS(cBounded, pCaseSensitive)

		return bResult

		#< @FunctionAlternativeForms

		def IsBoundOfCSXT(pcSubStr, pcInStr, pCaseSensitive)
			return This.IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)

		def IsBoundOfInCS(pcSubStr, pcInStr, pCaseSensitive)
			if CheckParams()	
				if NOT isString(pcInStr)
					StzRaise("Incorrect param type! pcInStr must be a string.")
				ok
			ok
			return This.IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESNESITUVURT

	def IsBoundOf(pcSubStr, pcInStr)
		bResult = This.IsBoundOfCS(pcSubStr, pcInStr, TRUE)
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundOfXT(pcSubStr, pcInStr)
			return This.IsBoundOf(pcSubStr, pcInStr)

		def IsBoundOfIn(pcSubStr, pcInStr)
			return This.IsBoundOfCS(pcSubStr, pcInStr, TRUE)

		#>

	#==

	def IsFirstBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).FirstBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsFirstBoundOf(pcOtherStr)
		return This.IsFirstBoundOfCS(pcOtherStr, TRUE)

	#==

	def IsLastBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LastBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

		def IsSecondBoundOfCS(pcOtherStr, pCaseSensitive)
			return This.IsLastBoundOfCS(pcOtherStr, pCaseSensitive)

	def IsLastBoundOf(pcOtherStr)
		return This.IsLastBoundOfCS(pcOtherStr, TRUE)

		def IsSecondBoundOf(pcOtherStr)
			return This.IsLastBoundOf(pcOtherStr)

	#==

	def IsLeftBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LeftBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsLeftBound(pcOtherStr)
		return This.IsLetfBoundOfCS(pcOtherStr, TRUE)

	#==

	def IsRightBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).RightBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsRightBoundOf(pcOtherStr)
		return This.IsRightBoundOfCS(pcOtherStr, TRUE)

	  #------------------------------------#
	 #     ADDING BOUNDS TO THE STRING    #
	#====================================#

	def AddBounds(pacBounds)
		if NOT ( isString(pacBounds) or ( isList(pacBounds) and len(pacBounds) = 2) )
			StzRaise("Incorrect param type! pacBounds must be a string or a pair.")
		ok

		if isList(pacBounds[2]) and Q(pacBounds[2]).IsAndNamedParam()
			pacBounds[2] = pacBounds[2][2]
		ok

		if NOT isString(pacBounds[1])
			StzRaise("Incorrect param type! the first item of pacBounds must be a string.")
		ok

		if isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		but isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			StzRaise("Incorrect param type! pacBounds must tbe a string or pair of strings.")
		ok

		cResult = cBound1 + This.String() + cBound2
		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def AddBoundsQ(pacBounds)
			This.AddBounds(pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundWithQ(pacBounds)
				return This.AddBoundsQ(pacBounds)

		def BoundItWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundItWithQ(pacBounds)
				return This.AddBoundsQ(pacBounds)

		#>

	def StringWithBoundsAdded(pacBounds)
		cResult = This.Copy().AddBoundsQ(pacBounds).Content()

		#< @FunctionAlternativeForms

		def StringBoundedWith(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		def BoundedWith()
			return This.StringWithBoundsAdded(pacBounds)

		def BoundsAdded()
			return This.StringWithBoundsAdded(pacBounds)

		def StringBoundedBy(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		#>

	  #------------------------------------------#
	 #  BOUNDING A SECTION WITH TWO SUBSTRINGS  #
	#------------------------------------------#

	def BoundSection(n1, n2, pacBounds)
		if CheckParams()
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

			if isList(pacBounds) and Q(pacBounds).IsWithOrUsingOrByNamedParam()
				pacBounds = pacBounds[2]
				if isList(pacBounds[2]) and Q(pacBounds[2]).IsAndNamedParam()
					pacBounds[2] = pacBounds[2][2]
				ok
			ok

			if isString(pacBounds)
				pacTemp = []
				pacTemp + pacBounds + pacBounds
				pacBounds = pacTemp
			ok

			if NOT ( isList(pacBounds) and @IsPairOfStrings(pacBounds) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		aSection = ring_sort([n1, n2])
		n1 = aSection[1]
		n2 = aSection[2]

		This.InsertAfterPosition(n2, pacBounds[2])
		This.InsertBeforePosition(n1, pacBounds[1])

		#< @FunctionFluentForm

		def BoundSectionQ(n1, n2, pacBounds)
			This.BoundSection(n1, n2, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAroundSection(pacBounds, n1, n2)
			This.BoundSection(n1, n2, pacBounds)

			def InsertAroundSectionQ(pacBounds, n1, n2)
				return This.BoundSectionQ(n1, n2, pacBounds)

		def AddBoundsToSection(pacBounds, n1, n2)
			This.BoundSection(n1, n2, pacBounds)

			def AddBoundsToSectionQ(pacBounds, n1, n2)
				return This.BoundSectionQ(pacBounds, n1, n2)

		def AddBoundToSection(pcBound, n1, n2)
			This.BoundSection(n1, n2, pcBound)

			def AddBoundToSectionQ(pcBound, n1, n2)
				return This.BoundSectionQ(n1, n2, pcBound)

		#>

	def SectionBounded(n1, n2, pacBounds)
		acResult = This.Copy().BoundSectionQ(n1, n2, pacBounds).Content()
		return acResult

		#< @FunctionAlternativeForms

		def InsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def SubStringsInsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def SubStringInsertedAroundSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def BoundsAddedToSection(pacBounds, n1, n2)
			return This.SectionBounded(n1, n2, pacBounds)

		def BoundAddedToSection(pcSubStr, n1, n2)
			return This.SectionBounded(n1, n2, pcSubStr)

		#>

	  #----------------------------------------------#
	 #  BOUNDING MANY SECTIONS WITH TWO SUBSTRINGS  #
	#----------------------------------------------#

	def BoundSections(aSections, pacBounds)
		if CheckParams()
			if NOT (isList(aSections) and @IsListOfPairsOfNumbers(aSections))
				StzRaise("Incorrect param type! aSections must be a list of pairs of numbers.")
			ok

			if isList(pacBounds) and Q(pacBounds).IsWithOrUsingOrByNamedParam()
				pacBounds = pacBounds[2]
				if isList(pacBounds[2]) and Q(pacBounds[2]).IsAndNamedParam()
					pacBounds[2] = pacBounds[2][2]
				ok
			ok

			if isString(pacBounds)
				pacTemp = []
				pacTemp + pacBounds + pacBounds
				pacBounds = pacTemp
			ok

			if NOT ( isList(pacBounds) and @IsPairOfStrings(pacBounds) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		aSections = StzListOfPairsQ(aSections).Sorted()
		nLen = len(aSections)

		if nLen = 0
			return

		but nLen = 1
			This.BoundSection(aSections[1][1], aSections[1][2], pacBounds)
			return
		ok

		# If some sections are included in others then remove them
		#TODO
		# Turn this to a method RemoveIncluded() in stzListOfPairs

		aSectionsXT = [] + aSections[1]
		for i = 2 to nLen
			if ( aSections[i][1] > aSections[i-1][1] and aSections[i][1] < aSections[i-1][2] ) and
			   ( aSections[i][2] > aSections[i-1][1] and aSections[i][2] < aSections[i-1][2] )

				// do nothing
			else

				aSectionsXT + aSections[i]
			ok
		next

		# Inserting the bounds around the sections

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
			n1 = aSectionsXT[i][1]
			n2 = aSectionsXT[i][2]

			This.InsertAfterPosition(n2, pacBounds[2])
			This.InsertBeforePosition(n1, pacBounds[1])
		next

		#< @FunctionFluentForm

		def BoundSectionsQ(aSections, pacBounds)
			This.BoundSections(aSections, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAroundSections(pacBounds, aSections)
			This.BoundSections(aSections, pacBounds)

			def InsertAroundSectionsQ(pacBounds, aSections)
				return This.BoundSectionsQ(aSections, pacBounds)

		def AddBoundsToSections(pacBounds, aSections)
			This.BoundSections(aSections, pacBounds)

			def AddBoundsToSectionsQ(pacBounds, aSections)
				return This.BoundSectionsQ(aSections, pacBounds)

		def AddBoundToSections(pcSubStr, aSections)
			This.BoundSections(aSections, pcSubStr)

			def AddBoundToSectionsQ(pcSubStr, aSections)
				return This.BoundSectionsQ(aSections, pcSubStr)

		#>

	def SectionsBounded(aSections, pacBounds)
		acResult = This.Copy().BoundSectionsQ(aSections, pacBounds).Content()
		return acResult

		#< @FunctionAlternativeForms

		def InsertedAroundSections(pacBounds, aSections)
			return This.SectionsBounded(aSections, pacBounds)

		def BoundsAddedToSections(pacBounds, aSections)
			return This.SectionsBounded(aSections, pacBounds)

		def BoundAddedToSections(pcSubStr, aSections)
			return This.SectionsBounded(pcSubStr, aSections)

		#>

	  #------------------------------------------------#
	 #  BOUNDING A SUBSTRING BY TWO OTHER SUBSTRINGS  #
	#------------------------------------------------#

	def BoundCS(pcSubStr, pacBounds, pCaseSensitive)
		
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.BoundSections(aSections, pacBounds)

		#< @FunctionFluentForm

		def BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringCSQ(pcSubStr, pacBounds, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def InsertAroundSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def InsertAroundSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def AddBoundsToSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def AddBoundsToSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def AddBoundToSubStringCS(pacBounds, pcSubStr, pCaseSensitive)
			This.BoundCS(pcSubStr, pacBounds, pCaseSensitive)

			def AddBoundToSubStringCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundCSQ(pcSubStr, pacBounds, pCaseSensitive)

		#>


	def SubStringBoundedCS(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().BoundCSQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

		def BoundsAddedToSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.SubStringBoundedCS(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Bound(pcSubStr, pacBounds)
		This.BoundCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionFluentForm

		def BoundQ(pcSubStr, pacBounds)
			This.Bound(pcSubStr, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubString(pcSubStr, pacBounds)
			This.Bound(pcSubStr, pacBounds)

			def BoundSubStringQ(pcSubStr, pacBounds)
				return This.BoundQ(pcSubStr, pacBounds)

		def InsertAroundSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def InsertAroundSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		def AddBoundsToSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def AddBoundsToSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		def AddBoundToSubString(pacBounds, pcSubStr)
			This.Bound(pcSubStr, pacBounds)

			def AddBoundToSubStringQ(pacBounds, pcSubStr)
				return This.BoundQ(pcSubStr, pacBounds)

		#>

	def SubStringBounded(pcSubStr, pacBounds)
		return This.SubStringBoundedCS(pcSubStr, pacBounds, TRUE)

		def BoundsAddedToSubString(pcSubStr, pacBounds)
			return This.SubStringBounded(pcSubStr, pacBounds)

	  #----------------------------------------------------#
	 #  BOUNDING MANY SUBSTRINGS BY TWO OTHER SUBSTRINGS  #
	#----------------------------------------------------#

	def BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)
		This.BoundSections(aSections, pacBounds)

		#< @FunctionFluentForm

		def BoundManyCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundManyCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStringsCS(pacSubStr, pacBounds, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringsCSQ(pacSubStr, pacBounds, pCaseSensitive)
				return This.BoundManyCSQ(pcSubStr, pacBounds, pCaseSensitive)

		def InsertAroundSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def InsertAroundSubStringsCSQ(pacBounds, pacSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		def AddBoundsToSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def AddBoundsToSubStringsCSQ(pacBounds, pacSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		def AddBoundToSubStringsCS(pacBounds, pacSubStr, pCaseSensitive)
			This.BoundManyCS(pacSubStr, pacBounds, pCaseSensitive)

			def AddBoundToSubStringsCSQ(pacBounds, pcSubStr, pCaseSensitive)
				return This.BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive)

		#>


	def SubStringsBoundedCS(pacSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().BoundManyCSQ(pacSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

		def BoundsAddedToSubStringsCS(pacSubStr, pacBounds, pCaseSensitive)
			return This.SubStringsBoundedCS(pacSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def BoundMany(pacSubStr, pacBounds)
		This.BoundManyCS(pacSubStr, pacBounds, TRUE)

		#< @FunctionFluentForm

		def BoundManyQ(pcSubStr, pacBounds)
			This.BoundMany(pcSubStr, pacBounds)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoundSubStrings(pacSubStr, pacBounds)
			This.BoundMany(pacSubStr, pacBounds)

			def BoundSubStringsQ(pacSubStr, pacBounds)
				return This.BoundManyQ(pcSubStr, pacBounds)

		def InsertAroundSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def InsertAroundSubStringsQ(pacBounds, pacSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		def AddBoundsToSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def AddBoundsToSubStringsQ(pacBounds, pacSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		def AddBoundToSubStrings(pacBounds, pacSubStr)
			This.BoundMany(pacSubStr, pacBounds)

			def AddBoundToSubStringsQ(pacBounds, pcSubStr)
				return This.BoundManyQ(pacSubStr, pacBounds)

		#>

	def SubStringsBounded(pacSubStr, pacBounds)
		cResult = This.Copy().BoundManyQ(pacSubStr, pacBounds).Content()
		return cResult

		def BoundsAddedToSubStrings(pacSubStr, pacBounds)
			return This.SubStringsBounded(pacSubStr, pacBounds)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY TWO OTHER SUBSTRINGS  #
	#====================================================================#

	def SubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		/* EXAMPLES

		o1 = new stzString("aaaaa bbbbb")
		
		? o1.SubStringIsBoundedBy("", "aa") #--> TRUE

		? o1.SubStringIsBoundedBy("", "bb") #--> TRUE
		
		? o1.SubStringIsBoundedBy("", [ "aa", "aaa" ] ) #--> TRUE

		*/

		if CheckParams() = TRUE
			if isList(pacBounds)
				if len(pacBounds) != 2
					pacBounds = Q(pacBounds).Pairified()
				ok

			but isString(pacBounds)
				aTemp = []
				aTemp  + pacBounds + pacBounds
				pacBounds = aTemp
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		# Doing the job

		if IsListOfPairs(pacBounds)
			nLen = len(pacBounds)
			bResult = TRUE

			for i = 1 to nLen
				bResult = This.SubStringIsBoundedByCS(pcSubStr, pacBounds[i], pCaseSensitive)
			next

			return bResult
		ok

		nLen1 = Q(pacBounds[1]).NumberOfChars()
		nLen2 = Q(pacBounds[2]).NumberOfChars()

		aSections = This.FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		bResult = FALSE

		for i = 1 to nLen

			acEffectiveBounds = This.Sit( :OnSection = aSections[i], :AndYield = [ nLen1, nLen2 ])

			if Q(acEffectiveBounds[1]).IsEqualToCS(pacBounds[1], pCaseSensitive) and
			   Q(acEffectiveBounds[2]).IsEqualToCS(pacBounds[2], pCaseSensitive)

				bResult = TRUE
				exit
			ok
		next

		return bResult
		

	def SubStringIsBoundedBy(pcSubStr, pacBounds)
		return This.SubStringIsBoundedByCS(pcSubStr, pacBounds, TRUE)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY MANY PAIRS OF SUBSTRINGS  #
	#------------------------------------------------------------------------#
	
	def SubStringIsBoundedByManyCS(pcSubStr, pacPairsOfBounds, pCaseSensitive)
		#TODO: Add "These" as alternative of "Many"

		/* EXAMPLE

		? o1.SubStringIsBoundedBy("", [ [ "aa","aaa" ], ["bb","bbb"] ]) #--> TRUE

		*/

		if NOT isList(pacPairsOfBounds)
			StzRaise("Incorrect param type! pacPairsOfBounds must be a list.")
		ok

		bResult = TRUE
		
		nLen = len(pacPairsOfBounds)
		for i = 1 to nLen
			if NOT This.SubStringIsBoundedByCS(pcSubStr, pacPairsOfBounds[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBoundedByMany(pacSubStr, pacPairsOfBounds)
		return This.SubStringIsBoundedByManyCS(pacSubStr, pacPairsOfBounds, TRUE)

	  #=====================================================================================#
	 #  CHECKING IF A SUBSTRING COMES BEFORE AN OTHER SUBSTRING OR POSITION IN THE STRING  #
	#=====================================================================================#

	def SubStringIsBeforeCS(pcSubStr, p, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p)
			oParam = Q(p)
			if oParam.IsPositionNamedParam()
				return This.SubStringIsBeforePositionCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsSubStringNamedParam()
				return This.SubStringIsBeforeSubStringCS(pcSubStr, p[2], pCaseSensitive)
			ok
		ok

		if isNumber(p)
			return This.SubStringIsBeforePositionCS(pcSubStr, p, pCaseSensitive)
		but isString(p)
			return This.SubStringIsBeforeSubStringCS(pcSubStr, p, pCaseSensitive)
		else
			StzRaise("Incorrect param! p must be a number or a string.")
		ok

		#< @FunctionAlternativeForm

		def SubStringComesBeforeCS(pcSubStr, p, pCaseSensitive)
			return This.SubStringIsBeforeCS(pcSubStr, p)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBefore(pcSubStr, p)
		return This.SubStringIsBeforeCS(pcSubStr, p, TRUE)

		#< @FunctionAlternativeForm

		def SubStringComesBefore(pcSubStr, p)
			return This.SubStringIsBefore(pcSubStr, p)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsBeforePositionCS(pcSubStr, n, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos < n
			return TRUE
		else
			return FALSE
		ok

		def SubStringComesBeforePositionCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringIsBeforePositionCS(pcSubStr, n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBeforePosition(pcSubStr, n)
		return This.SubStringIsBeforePositionCS(pcSubStr, n, TRUE)

		def SubStringComesBeforePosition(pcSubStr, n)
			return This.SubStringIsBeforePosition(pcSubStr, n)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		nOtherPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)

		if nPos < nOtherPos
			return TRUE
		else
			return FALSE
		ok

		def SubStringComesBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBeforeSubString(pcSubStr, pcOtherSubStr)
		return This.SubStringIsBeforeSubStringCS(pcSubStr, pcOtherSubStr, TRUE)

		def SubStringComesBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.SubStringIsBeforeSubString(pcSubStr, pcOtherSubStr)

	  #------------------------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING COMES AFTER AN OTHER SUBSTRING OR POSITION IN THE STRING  #
	#====================================================================================#

	def SubStringIsAfterCS(pcSubStr, p, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p)
			oParam = Q(p)
			if oParam.IsPositionNamedParam()
				return This.SubStringIsAfterPositionCS(pcSubStr, p[2], pCaseSensitive)

			but oParam.IsSubStringNamedParam()
				return This.SubStringIsAfterSubStringCS(pcSubStr, p[2], pCaseSensitive)
			ok
		ok

		if isNumber(p)
			return This.SubStringIsAfterPositionCS(pcSubStr, p, pCaseSensitive)

		but isString(p)
			return This.SubStringIsAfterSubStringCS(pcSubStr, p, pCaseSensitive)

		else
			StzRaise("Incorrect param! p must be a number or a string.")
		ok

		#< @FunctionAlternativeForm

		def SubStringComesAfterCS(pcSubStr, p, pCaseSensitive)
			return This.SubStringIsAfterCS(pcSubStr, p)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfter(pcSubStr, p)
		return This.SubStringIsAfterCS(pcSubStr, p, TRUE)

		#< @FunctionAlternativeForm

		def SubStringComesAfter(pcSubStr, p)
			return This.SubStringIsAfter(pcSubStr, p)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsAfterPositionCS(pcSubStr, n, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		if nPos > n
			return TRUE
		else
			return FALSE
		ok

		def SubStringComesAfterPositionCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringIsAfterPositionCS(pcSubStr, n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfterPosition(pcSubStr, n)
		return This.SubStringIsAfterPositionCS(pcSubStr, n, TRUE)

		def SubStringComesAfterPosition(pcSubStr, n)
			return This.SubStringIsAfterPosition(pcSubStr, n)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		nOtherPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)

		if nPos > nOtherPos
			return TRUE
		else
			return FALSE
		ok

		def SubStringComesAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsAfterSubString(pcSubStr, pcOtherSubStr)
		return This.SubStringIsAfterSubStringCS(pcSubStr, pcOtherSubStr, TRUE)

		def SubStringComesAfterSubString(pcSubStr, pcOtherSubStr)
			return This.SubStringIsAfterSubString(pcSubStr, pcOtherSubStr)

	  #---------------------------------------------------------------------------------------------#
	 #  CHECKING IF A SUBSTRING COMES BETWEEN TWO OTHER SUBSTRINGS OR POSITIONS INSIDE THE STRING  #
	#=============================================================================================#

	def SubStringIsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(p1)
			oP1 = Q(p1)
			if oP1.IsPositionsNamedParam()
				if isList(p2) and Q(p2).IsAndNamedParam()
					p2 = p2[2]
				ok

				return This.SubStringIsBetweenPositionsCS(pcSubStr, p1[2], p2, pCaseSensitive)

			but oP1.IsSubStringsNamedParam()
				if isList(p2) and Q(p2).IsAndNamedParam()
					p2 = p2[2]
				ok

				return This.SubStringIsBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)
			ok
		ok

		if BothAreNumbers(p1, p2)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, p1, p2, pCaseSensitive)

		but BothAreStrings(p1, p2)
			return This.SubStringIsBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)

		else
			StzRaise("Incorrect params types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionAlternativeForm

		def SubStringComesBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.SubStringIsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetween(pcSubStr, p1, p2)
		return This.SubStringIsBetweenCS(pcSubStr, p1, p2, TRUE)

		#< @FunctionAlternativeForm

		def SubStringComesBetween(pcSubStr, p1, p2)
			return This.SubStringIsBetween(pcSubStr, p1, p2)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE A GIVEN POSITION IN THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		bResult = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def SubStringComesBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		def SubStringComesInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		def SubStringComesInsideSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, p2CaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetweenPositions(pcSubStr, n1, n2)
		return This.SubStringIsBetweenPositionsCS(pcSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def SubStringComesBetweenPositions(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		def SubStringComesInSection(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		def SubStringComesInsideSection(pcSubStr, n1, n2)
			return This.SubStringIsBetweenPositions(pcSubStr, n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE SUBSTRING COMES BEFORE AN OTHER SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("---...**---")
		
		? o1.SubStringComesBetween("...", "", "**")
		#--> TRUE
		
		? o1.SubStringComesBetween("...", "**", "")
		#--> TRUE

		*/

		if CheckParams()
			if isList(pcSubStr1) and Q(pcSubStr1).IsSubStringsNamedParam()
				pcSubStr1 = pcSubStr1[2]
			ok
	
			if isList(pcSubStr2) and Q(pcSubStr2).IsAndNamedParam()
				pcSubStr2 = pcSubStr2[2]
			ok
		ok

		n1 = This.FindFirstCS(pcSubStr1, pCaseSensitive)
		n2 = This.FindLastCS(pcSubStr2, pCaseSensitive)
		bOk1 = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)

		n1 = This.FindFirstCS(pcSubStr2, pCaseSensitive)
		n2 = This.FindLastCS(pcSubStr1, pCaseSensitive)
		bOk2 = This.SectionQ(n1, n2).ContainsCS(pcSubStr, pCaseSensitive)

		bResult = bOk1 or bOk2

		return bResult

		def SubStringComesBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, p2CaseSensitive)
			return This.SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, p2CaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
		return This.SubStringIsBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		def SubStringComesBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This.SubStringIsBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

	  #=============================================================================#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING BY RETURNING THEIR SECTIONS  #
	#=============================================================================#

	def FindBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		aSection1 = [1, 1]
		if This.HasLeadingCharsCS(pCaseSensitive)
			aSection1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		ok

		aSection2 = [1, 1]
		if This.HasTrailingCharsCS(pCaseSensitive)
			aSection2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ aSection1, aSection2 ]
		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindStringBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCSZZ(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBoundsAsSections()
		return This.FindBoundsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSections()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()

		#--

		def FindBoundsZZ()
			return This.FindBoundsAsSections()

		def FindStringBoundsZZ()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsZZ()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondoundsZZ()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsZZ()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsZZ()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsZZ()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsZZ()
				return This.FindBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		aResult = [
			This.FindTrailingCharsAsSectionCS(pCaseSensitive),
			This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindSecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBoundsAsSections()
		return This.FindLastAndFirstBoundsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		#--

		def FindLastAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindSecondAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsZZ()
			return This.FindLastAndFirstBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0], [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftAndRightBoundsAsSections()
		return This.FindLeftAndRightBoundsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSections()
			return This.FindLeftAndRightBoundsAsSections()

		#--

		def FindLeftAndRightBoundsZZ()
			return This.FindLeftAndRightBoundsAsSections()

		def FindStringLeftAndRightBoundsZZ()
			return This.FindLeftAndRightBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen = 0 or nLen = 1
			return [ [0,0] , [0,0] ]
		ok

		if NOT This.HasLeadingAndTrailingChars()
			aResult = [ [1, 1], [nLen, nLen] ]
			return aResult
		ok

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSectionsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#--

		def FindRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		def FindStringRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightAndLeftBoundsAsSections()
		return This.FindRightAndLeftBoundsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSections()
			return This.FindRightAndLeftBoundsAsSections()

		#--

		def FindRightAndLeftBoundsZZ()
			return This.FindRightAndLeftBoundsAsSections()

		def FindStringRightAndLeftBoundsZZ()
			return This.FindRightAndLeftBoundsAsSections()

		#>

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDED (HAS BOUNDS)  #
	#==================================================#

	def IsBoundedCS(pCaseSensitive)
		if This.NumberOfChars() > 2
			return TRUE
		else
			return FALSE
		ok

		def HasBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

		def ContainsBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsBounded()
		return This.IsBoundedCS(TRUE)

		def HasBounds()
			return This.IsBounded()

		def ContainsBounds()
			return This.HasBounds()

	  #-------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def FindBoundsCS(pCaseSensitive)
		#TODO
		# Reveiew it! Many be non accurate

		aResult = [
			This.FindLeadingCharsCS(pCaseSensitive),
			This.FindTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBounds()
		return This.FindBoundsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringBounds()
			return This.FindBounds()

		def FindFirstAndLastBounds()
			return This.FindBounds()

			def FindFirstAndSecondBounds()
				return This.FindBounds()
	
		def FindFirstAndLastStringBounds()
			return This.FindBounds()

			def FindFirstAndSecondStringBounds()
				return This.FindBounds()
	
		def FindStringFirstAndLastBounds()
			return This.FindBounds()

			def FindStringFirstAndSecondBounds()
				return This.FindBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLastAndFirstBoundsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsCS(pCaseSensitive),
			This.FindLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBounds()
		return This.FindLastAndFirstBoundsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringLastAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLeftAndRightBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringLeftAndRightBoundsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsCS(pCaseSensitive)

	#--

	def FindLeftAndRightBounds()
		return This.FindLeftAndRightBoundsCS(TRUE)

		def FindStringLeftAndRightBounds()
			return This.FindLeftAndRightBounds()

	  #--------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindRightAndLeftBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)
			
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringRightAndLeftBoundsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsCS(pCaseSensitive)

	#--

	def FindRightAndLeftBounds()
		return This.FindRightAndLeftBoundsCS(TRUE)

		def FindStringRightAndLeftBounds()
			return This.FindRightAndLeftBounds()

	  #-------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def BoundsCS(pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("<<Ring>>")
		? o1.Bounds()
		#--> [ "<<", ">>" ]

		EXAMPLE 2

		o1 = new stzString("---Ring___")
		? o1.Bounds()
		#--> [ "---, "___" ]

		EXAMPLE 3

		o1 = new stzString("Ring")
		? o1.Bounds()
		#--> [ "R", "g" ]

		*/

		acResult = []

		if This.ContainsLeadingAndTrailingCharsCS(pCaseSensitive)

			acResult = [
				This.LeadingCharsAsStringCS(pCaseSensitive),
				This.TrailingCharsAsStringCS(pCaseSensitive)
			]

		else

			acResult = [ This.FirstChar(), This.LastChar() ]
		ok

		return acResult

		#< @FunctionAlternativeForms

		def StringBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def FirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFristAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def Bounds()
		return This.BoundsCS(TRUE)

		#< @FunctionAlternativeForms

		def StringBounds()
			return This.Bounds()

		def FirstAndLastBounds()
			return This.Bounds()

		def StringFirstAndLastBounds()
			return This.Bounds()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBounds()
			return This.Bounds()

		def StringFristAndLastBounds()
			return This.Bounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LastAndFirstBoundsCS(pCaseSensitive)
		acResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FirstBoundCS(pCaseSensitive)
		]

		return acResult

		#< @FunctionAlternatoveForms

		def SecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringLastAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBounds()
		return This.LastAndFirstBoundsCS(TRUE)

		#< @FunctionAlternatoveForms

		def SecondAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringLastAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringSecondAndFirstBounds()
			return This.LastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LeftAndRightBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = This.LastBoundCS(pCaseSensitive)

		else
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = Thus.FirstBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringLeftAndRightBoundsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBounds()
		return This.LeftAndRightBoundsCS(TRUE)

		def StringLeftAndRightBounds()
			return This.LeftAndRightBoundsCS()

	  #--------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def RightAndLeftBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = This.FirstBoundCS(pCaseSensitive)

		else
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = Thus.LastBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringRightAndLeftBoundsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBounds()
		return This.RightAndLeftBoundsCS(TRUE)

		def StringRightAndLeftBounds()
			return This.RightAndLeftBoundsCS()

	  #------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#========================================================================#

	def BoundsCSZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def FirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def FristAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFristAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFristAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZ()
		return This.BoundsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositions()
			return This.BoundsZ()

		def StringBoundsZ()
			return This.BoundsZ()

		def StringBoundsAndTheirPositions()
			return This.BoundsZ()

		#--

		def FirstAndLastBoundsZ()
			return This.BoundsZ()

		def FirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFirstAndLastBoundsZ()
			return This.BoundsZ()

		def StringFirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsZ()
			return This.BoundsZ()

		def FristAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFristAndLastBoundsZ()
			return This.BoundsZ()

		def StringFristAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------------------#

	def BoundsCSZZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def FirstAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def FristAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFristAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFristAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZZ()
		return This.BoundsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirSections()
			return This.BoundsZZ()

		def StringBoundsZZ()
			return This.BoundsZZ()

		def StringBoundsAndTheirSrctions()
			return This.BoundsZZ()

		#--

		def FirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def FirstAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>


		#< @FunctionMisspelledForms

		def FristAndLastBoundsZZ()
			return This.BoundsZZ()

		def FristAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFristAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFristAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZ()
		return This.LastAndFirstBoundsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

		def LastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def SecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsZ()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZZ()
		return This.LastAndFirstBoundsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

		def LastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def SecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsZZ()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZ()
		return This.LeftAndrightBoundsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsZ()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZZ()
		return This.LeftAndRightBoundsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndrightBoundsZZ()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ(pCaseSensitive)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZ()
		return This.RightAndLeftBoundsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsZ()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZZ()
		return This.RightAndLeftBoundsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSections()
		return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsZZ()
			return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsAndTheirSections()
			return This.RightAndLeftBoundsZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING  #
	#=========================================#

	def FindFirstBoundCS(pCaseSensitive)
		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			return 1
		else
			return 0
		ok

		def FindStringFirstBoundCS(pCaseSensitive)
			return This.FindFirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBound()
		return This.FindFirstBoundCS(TRUE)

		def FindStringFirstBound()
			return This.FindFirstBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			anResult + 1 + n
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringFirstBoundAsSectionCS(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		#--

		def FindFirstBoundCSZZ(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		def FindStringFirstBoundCSZZ(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBoundAsSection()
		return This.FindFirstBoundAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringFirstBoundAsSection()
			return This.FindFirstBoundAsSection()

		#--

		def FindFirstBoundZZ()
			return This.FindFirstBoundAsSection()

		def FindStringFirstBoundZZ()
			return This.FindFirstBoundAsSection()

		#>

	  #-----------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING  #
	#-----------------------------------------#

	def FirstBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[1]
		return cResult

		def StringFirstBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

		#-- MISSPELLED

		def FristBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

		def StringFristBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstBound()
		return This.FirstBoundCS(TRUE)

		def StringFirstBound()
			return This.FirstBound()

		#-- MISSPELLED

		def FristBound()
			return This.FirstBound()

		def StringFristBound()
			return This.FirstBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def FirstBoundCSZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def FristBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFristBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFristBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZ()
		return This.FirstBoundCSZ(TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFirstBoundZ()
			return This.FirstBoundZ()

		def StringFirstBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

		#< @FunctionMisspelledForms

		def FristBoundZ()
			return This.FirstBoundZ()

		def FristBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFristBoundZ()
			return This.FirstBoundZ()

		def StringFristBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def FirstBoundCSZZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundCSZZ(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FristBoundCSZZ(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def FristBoundAndItsSectionCS(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def StringFristBoundCSZZ(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		def StringFristBoundAndItsSectionCS(pCaseSensitive)
			return This.FirstBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZZ()
		return This.FirstBoundCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFirstBoundZZ()
			return THis.FirstBoundZZ()

		def StringFirstBoundAndItsSection()
			return THis.FirstBoundZZ()

		#>

		#< @FunctionMisspelledForms

		def FristBoundZZ()
			return This.FirstBoundZZ()

		def FristBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFristBoundZZ()
			return This.FirstBoundZZ()

		def StringFristBoundAndItsSection()
			return This.FirstBoundZZ()

		#>

		#TODO: Complete to add misspelled forms to all functions
		# containing First in their names

	  #----------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING  #
	#========================================#

	def FindLastBoundCS(pCaseSensitive)
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			return This.NumberOfChars() - n + 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindStringLastBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindStringSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBound()
		return This.FindLastBoundCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBound()
			return This.FindLastBound()

		def FindSecondBound()
			return This.FindLastBound()

		def FindStringSecondBound()
			return This.FindLastBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			nLen = This.NumberOfChars()
			anResult + (nLen - n + 1) + nLen
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#--

		def FindLastBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringLastBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundCSZZ(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBoundAsSection()
		return This.FindLastBoundAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		#--

		def FindLastBoundZZ()
			return This.FindLastBoundAsSection()

		def FindStringLastBoundZZ()
			return This.FindLastBoundAsSection()

		def FindSecondBoundZZ()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundZZ()
			return This.FindLastBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING  #
	#----------------------------------------#

	def LastBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[2]
		return cResult

		#< @FunctionAlternativeForms

		def StringLastBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def SecondBoundCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def StringSecondBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBound()
		return This.LastBoundCS(TRUE)

		#< @FunctionAlternativeForms

		def StringLastBounds()
			return This.LastBound()

		def SecondBound()
			return This.LastBound()

		def StringSecondBounds()
			return This.LastBound()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LastBoundCSZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZ(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def LastBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def SecondBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZ()
		return This.LastBoundCSZ(TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZ()
			return This.LastBoundZ()

		def LastBoundAndItsPosition()
			return This.LastBoundZ()

		def SecondBoundAndItsPosition()
			return This.LastBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LastBoundCSZZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZZ(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def LastBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def SecondBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZZ()
		return This.LastBoundCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZZ()
			return This.LastBoundZZ()

		def LastBoundAndItsSection()
			return This.LastBoundZZ()

		def SecondBoundAndItsSection()
			return This.LastBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING  #
	#========================================#

	def FindLeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundCSZ(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		def FindStringLeftBoundCS(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		def FindStringLeftBoundCSZ(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBound()
		return This.FindLeftBoundCS(TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundZ()
			return This.FindLeftBound()

		def FindStringLeftBound()
			return This.FindLeftBound()

		def FindStringLeftBoundZ()
			return This.FindLeftBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLeftBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindStringLeftBoundAsSectionCS(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		#--

		def FindLeftBoundCSZZ(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		def FindStringLeftBoundCSZZ(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBoundAsSection()
		return This.FindLeftBoundAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindStringLeftBoundAsSection()
			return This.FindLeftBoundAsSection()

		#--

		def FindLeftBoundZZ()
			return This.FindLeftBoundAsSection()

		def FindStringLeftBoundZZ()
			return This.FindLeftBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING  #
	#----------------------------------------#

	def LeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[1]

		else # case IsRightToLeft()
			return This.BoundsCS(pCaseSensitive)[2]
		ok


		def StringLeftBoundCS(pCaseSensitive)
			return This.LeftBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftBound()
		return This.LeftBoundCS(TRUE)

		def StringLeftBound()
			return This.LeftBound()

	  #----------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LeftBoundCSZ(pCaseSensitive)
		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundCSZ(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundAbdItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZ()
		return This.LeftBoundCSZ(TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPosition()
			return This.LeftBoundZ()

		def StringLeftBoundZ()
			return This.LeftBoundZ()

		def StringLeftBoundAbdItsPosition()
			return This.LeftBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LeftBoundCSZZ(pCaseSensitive)

		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundCSZZ(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundAbdItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZZ()
		return This.LeftBoundCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSection()
			return This.LeftBoundZZ()

		def StringLeftBoundZZ()
			return This.LeftBoundZZ()

		def StringLeftBoundAbdItsSection()
			return This.LeftBoundZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING  #
	#=========================================#

	def FindRightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundCSZ(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		def FindStringRightBoundCS(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		def FindStringRightBoundCSZ(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightBound()
		return This.FindRightBoundCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundZ()
			return This.FindRightBound()

		def FindStringRightBound()
			return This.FindRightBound()

		def FindStringRightBoundZ()
			return This.FindRightBound()

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindRightBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundCSZZ(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		def FindStringRightBoundAsSectionCS(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		def FindStringRightBoundCSZZ(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightBoundAsSection()
		return This.FindRightBoundAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundZZ()
			return This.FindRightBoundAsSection()

		def FindStringRightBoundAsSection()
			return This.FindRightBoundAsSection()

		def FindStringRightBoundZZ()
			return This.FindRightBoundAsSection()

		#>

	  #-----------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING  #
	#-----------------------------------------#

	def RightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[2]

		else # case IsRightToRight()
			return This.BoundsCS(pCaseSensitive)[1]
		ok

		def StringRightBoundCS(pCaseSensitive)
			return This.RightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightBound()
		return This.RightBoundCS(TRUE)

		def StringRightBound()
			return This.RightBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def RightBoundCSZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundCSZ(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZ()
		return This.RightBoundCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsPosition()
			return This.RightBoundZ()

		def StringRightBoundZ()
			return This.RightBoundZ()

		def StringRightBoundAndItsPosition()
			return This.RightBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def RightBoundCSZZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundCSZZ(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZZ()
		return This.RightBoundCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsSection()
			return This.RightBoundZZ()

		def StringRightBoundZZ()
			return This.RightBoundZZ()

		def StringRightBoundAndItsSection()
			return This.RightBoundZZ()

		#>

	  #---------------------------------#
	 #  REMOVING BOUNDS OF THE STRING  #
	#=================================#

	def RemoveStringBoundsCS(pCaseSensitive)

		if This.IsBoundedCS(pCaseSensitive)
			aSections = This.FindStringBoundsAsSectionsCS(pCaseSensitive)
			This.RemoveSections(aSections)
		ok

		#< @FunctionFluentForm

		def RemoveStringBoundsCSQ(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveBoundsCSQ(pCaseSensitive)
				This.RemoveBoundsCS(pCaseSensitive)
				return This
	
		#--

		def RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveStringFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndSecondBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#>

	def StringBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveStringBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringFirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringFirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringSecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def SecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringRightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def RightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringBounds()
		return This.RemoveStringBoundsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveStringBoundsQ()
			This.RemoveStringBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBounds()
			This.RemoveStringBounds()

			def RemoveBoundsQ()
				This.RemoveBounds()
				return This
	
		#--

		def RemoveStringFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndLastBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		def RemoveStringFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndSecondBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		#--

		def RemoveFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndLastBoundsQ()
				This.RemoveFirstAndLastBounds()
				return This

		def RemoveFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndSecondBoundsQ()
				This.RemoveFirstAndSecondBounds()
				return This

		#--

		def RemoveStringLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringLastAndFirstBoundsQ()
				This.RemoveStringLastAndFirstBounds()
				return This

		def RemoveStringSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringSecondAndFirstBoundsQ()
				This.RemoveStringSecondAndFirstBounds()
				return This

		#--

		def RemoveLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveLastAndFirstBoundsQ()
				This.RemoveLastAndFirstBounds()
				return This

		def RemoveSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveSecondAndFirstBoundsQ()
				This.RemoveSecondAndFirstBounds()
				return This

		#--

		def RemoveStringLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveStringLeftAndRightBoundsQ()
				This.RemoveStringLeftAndRightBounds()
				return This

		#--

		def RemoveLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveLeftAndRightBoundsQ()
				This.RemoveLeftAndRightBounds()
				return This

		#--

		def RemoveStringRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveStringRightAndLeftBoundsQ()
				This.RemoveStringRightAndLeftBounds()
				return This

		#--

		def RemoveRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveRightAndLeftBoundsQ()
				This.RemoveRightAndLeftBounds()
				return This

		#>

	def StringBoundsRemoved()
		cResult = This.Copy().RemoveStringBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringFirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringFirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def LastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringSecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def SecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		def LeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringRightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		def RightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		#>

	  #--------------------------------------#
	 #  REMOVING LEFT BOUND OF THE STRING   #
	#======================================#

	def RemoveStringLeftBoundCS(pCaseSensitive)
	
		cBounds = This.LeftBoundCS(pCaseSensitive)
		This.RemoveFromLeftCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundCSQ(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundCS(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)

			def RemoveLeftBoundCSQ(pCaseSensitive)
				This.RemoveLeftBoundCS(pCaseSensitive)
				return This

		#>

	def StringLeftBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pCaseSensitive).Content()
		return cResult

		def LeftBoundRemovedCS(pCaseSensitive)
			return This.StringLeftBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLeftBound()
		This.RemoveStringLeftBoundCS(TRUE)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundQ()
			This.RemoveStringLeftBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBound()
			This.RemoveStringLeftBound()

			def RemoveLeftBoundQ()
				This.RemoveLeftBound()
				return This

		#>

	def StringLeftBoundRemoved()
		cResult = This.Copy().RemoveStringLeftBoundQ().Content()
		return cResult

		def LeftBoundRemoved()
			return This.StringLeftBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringRightBoundCS(pCaseSensitive)
	
		cBounds = This.RightBoundCS(pCaseSensitive)
		This.RemoveFromRightCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringRightBoundCSQ(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundCS(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)

			def RemoveRightBoundCSQ(pCaseSensitive)
				This.RemoveRightBoundCS(pCaseSensitive)
				return This

		#>

	def StringRightBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pCaseSensitive).Content()
		return cResult

		def RightBoundRemovedCS(pCaseSensitive)
			return This.StringRightBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringRightBound()
		This.RemoveStringRightBoundCS(TRUE)

		#< @FunctionFluentForm

		def RemoveStringRightBoundQ()
			This.RemoveStringRightBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBound()
			This.RemoveStringRightBound()

			def RemoveRightBoundQ()
				This.RemoveRightBound()
				return This

		#>

	def StringRightBoundRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundQ().Content()
		return cResult

		def RightBoundRemoved()
			return This.StringRightBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING FIRST BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringFirstBoundCS(pCaseSensitive)
	
		cBounds = This.FirstBoundCS(pCaseSensitive)
		This.RemoveFromStartCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundCSQ(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundCS(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)

			def RemoveFirstBoundCSQ(pCaseSensitive)
				This.RemoveFirstBoundCS(pCaseSensitive)
				return This

		#>

	def StringFirstBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pCaseSensitive).Content()
		return cResult

		def FirstBoundRemovedCS(pCaseSensitive)
			return This.StringFirstBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringFirstBound()
		This.RemoveStringFirstBoundCS(TRUE)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundQ()
			This.RemoveStringFirstBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBound()
			This.RemoveStringFirstBound()

			def RemoveFirstBoundQ()
				This.RemoveFirstBound()
				return This

		#>

	def StringFirstBoundRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundQ().Content()
		return cResult

		def FirstBoundRemoved()
			return This.StringFirstBoundRemoved()

	  #--------------------------------------#
	 #  REMOVING LAST BOUND OF THE STRING   #
	#--------------------------------------#

	def RemoveStringLastBoundCS(pCaseSensitive)
	
		cBounds = This.LastBoundCS(pCaseSensitive)
		This.RemoveFromEndCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLastBoundCSQ(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveLastBoundCSQ(pCaseSensitive)
				This.RemoveLastBoundCS(pCaseSensitive)
				return This


		def RemoveStringSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveStringSecondBoundCSQ(pCaseSensitive)
				This.RemoveStringSecondBoundCS(pCaseSensitive)
				return This

		def RemoveSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveSecondBoundCSQ(pCaseSensitive)
				This.RemoveSecondBoundCS(pCaseSensitive)
				return This

		#>

	def StringLastBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def StringSecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def SecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLastBound()
		This.RemoveStringLastBoundCS(TRUE)

		#< @FunctionFluentForm

		def RemoveStringLastBoundQ()
			This.RemoveStringLastBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBound()
			This.RemoveStringLastBound()

			def RemoveLastBoundQ()
				This.RemoveLastBound()
				return This


		def RemoveStringSecondBound()
			This.RemoveStringLastBound()

			def RemoveStringSecondBoundQ()
				This.RemoveStringSecondBound()
				return This

		def RemoveSecondBound()
			This.RemoveStringLastBound()

			def RemoveSecondBoundQ()
				This.RemoveSecondBound()
				return This

		#>

	def StringLastBoundRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemoved()
			return This.StringLastBoundRemoved()

		def StringSecondBoundRemoved()
			return This.StringLastBoundRemoved()

		def SecondBoundRemoved()
			return This.StringLastBoundRemoved()

		#>

	  #--------------------------------------#
	 #  FINDING THE GIVEN SUBSTRING BOUNDS  #
	#======================================#

	def FindTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = []

		for i = 1 to nLen step 2

			# Checking the bounds

			if aSections[i][2] - aSections[i][1] + 1 != nLenBound1
				loop
			ok

			if aSections[i+1][2] - aSections[i+1][1] + 1 != nLenBound2
				loop
			ok

			if NOT This.SectionQ(aSections[i][1], aSections[i][2]).IsEqualToCS(cBound1, pCaseSensitive)
				loop
			ok

			if NOT This.SectionQ(aSections[i+1][1], aSections[i+1][2]).IsEqualToCS(cBound2, pCaseSensitive)
				loop
			ok

			# Checking the substring

			n1 = aSections[i][2]+1
			n2 = aSections[i+1][1]-1

			if NOT (n2 - n1 + 1 = nLenSubStr)
				loop
			ok

			if This.SectionQ(n1, n2).IsEqualToCS(pcSubStr, pCaseSensitive)
				anResult + aSections[i][1] + aSections[i+1][1]
			ok
		next

		return anResult

		def FindTheseSubStringBoundsCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringBounds(pcSubStr, pacBounds)
		return This.FindTheseSubStringBoundsCS(pcSubStr, pacBounds, TRUE)

		def FindTheseSubStringBoundsZ(pcSubStr, pacBounds)
			return This.FindTheseSubStringBounds(pcSubStr, pacBounds)

	  #------------------------------------------------------#
	 #  FINDING THE GIVEN SUBSTRING BOUNDS -- ZZ/EXTENSION  #
	#------------------------------------------------------#

	def FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = []

		for i = 1 to nLen step 2

			# Checking the bounds

			if aSections[i][2] - aSections[i][1] + 1 != nLenBound1
				loop
			ok

			if aSections[i+1][2] - aSections[i+1][1] + 1 != nLenBound2
				loop
			ok

			if NOT This.SectionQ(aSections[i][1], aSections[i][2]).IsEqualToCS(cBound1, pCaseSensitive)
				loop
			ok

			if NOT This.SectionQ(aSections[i+1][1], aSections[i+1][2]).IsEqualToCS(cBound2, pCaseSensitive)
				loop
			ok

			# Checking the substring

			n1 = aSections[i][2]+1
			n2 = aSections[i+1][1]-1

			if NOT (n2 - n1 + 1 = nLenSubStr)
				loop
			ok

			if This.SectionQ(n1, n2).IsEqualToCS(pcSubStr, pCaseSensitive)
				aResult + aSections[i] + aSections[i+1]
			ok
		next

		return aResult

		def FindTheseSubStringBoundsAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringBoundsZZ(pcSubStr, pacBounds)
		return This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, TRUE)

		def FindTheseSubStringBoundsAsSections(pcSubStr, pacBounds)
			return This.FindTheseSubStringBoundsZZ(pcSubStr, pacBounds)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR POSITIONS  #
	#=====================================================================================#

	#NOTE #AI #CHATGPT
	# This function has been designed by the aid of ChatGPT

	def FindTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
		/* EXAMPLE

		#                       5     11             26        36    42
		o1 = new stzString("The <<Ring>> programming <<language>> is <<Waooo!>>")
		? o1.FindTheseBounds("<<", ">>")

		*/

		nLen = This.NumberOfChars()
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()
		nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

		anResult = []
		nPos = 1

		while nPos < nLen

	        	n1 = This.FindFirstSTCS(pcBound1, nPos, pCaseSensitive)

	        	if n1 = 0
	            		exit
	       		 ok

	        	n2 = This.FindFirstSTCS(pcBound2, n1 + nLenBound1, pCaseSensitive)
	       		if n2 = 0
	            		exit
			ok
	        
	       		anResult + n1 + n2      
	        	nPos = n2
	    	end
	    
	   	return anResult


		#< @FunctionAlternativeForms

		def FindTheseBoundsCSZ(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseBounds(pcBound1, pcBound2)
		return This.FindTheseBoundsCS(pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForms

		def FindTheseBoundsZ(pcBound1, pcBound2)
			return This.FindTheseStringBounds(pcBound1, pcBound2)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR SECTIONS  #
	#------------------------------------------------------------------------------------#

	#NOTE #AI #CHATGPT
	# This function has been designed by the aid of ChatGPT

	def FindTheseBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

		nLen = This.NumberOfChars()
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()
		nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

		aResult = []
		nPos = 1

		while nPos < nLen

	        	n1 = This.FindFirstSTCS(pcBound1, nPos, pCaseSensitive)

	        	if n1 = 0
	            		exit
	       		 ok

	        	n2 = This.FindFirstSTCS(pcBound2, n1 + nLenBound1, pCaseSensitive)
	       		if n2 = 0
	            		exit
			ok
	        
	       		aResult + [ n1, n1 + nLenBound1 - 1 ] + [ n2, n2 + nLenBound2 - 1 ]     
	        	nPos = n2
	    	end
	    
	   	return aResult


		#< @FunctionAlternativeForms

		def FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseBoundsZZ(pcBound1, pcBound2)
		return This.FindTheseBoundsCSZZ(pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForms

		def FindTheseBoundsAsSections(pcBound1, pcBound2)
			return This.FindTheseBoundsZZ(pcBound1, pcBound2)

		#>

	  #--------------------------------------------------------#
	 #  REMOVING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING  #
	#========================================================#

	def RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def TheseBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseBounds(pcBound1, pcBound2)
		return This.RemoveTheseBoundsCS(pcBound1, pcBound2, TRUE)

		#< @FunctionFluentForm

		def RemoveTheseBoundsQ(pcBound1, pcBound2)
			This.RemoveTheseBounds(pcBound1, pcBound2)
			return This

		#>

	def TheseBoundsRemoved(pcBound1, pcBound2)
		cResult = This.Copy().RemoveTheseBoundsQ(pcBound1, pcBound2).Content()
		return cResult

	  #---------------------------------#
	 #  SWAPPING BOUNDS OF THE STRING  #
	#=================================#

	def SwapBoundsCS(pCaseSensitive)
		aSections = This.FindBoundsAsSectionsCS(pCaseSensitive)
		This.SwapSections( aSections[1], aSections[2] )

		#< @FunctionFluentForm

		def SwapBoundsCSQ(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBoundsCS(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)

			def SwapStringBoundsCSQ(pCaseSensitive)
				This.SwapStringBoundsCS(pCaseSensitive)
				return This

		#>

	def BoundsSwappedCS(pCaseSensitive)
		cResult = This.Copy(). SwapBoundsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SwapBounds()
		return This.SwapBoundsCS(TRUE)

		#< @FunctionFluentForm

		def SwapBoundsQ()
			This.SwapBounds()
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBounds()
			This.SwapBounds()

			def SwapStringBoundsQ()
				This.SwapStringBounds()
				return This

		#>

	def BoundsSwapped()
		cResult = This.Copy(). SwapBoundsQ().Content()
		return cResult

		def StringBoundsSwapped()
			return This.BoundsSwapped()


	  #=========================================================#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		n = This.NumberOfChars()
		# To be sure n exceeds the size of the largest bound, since we know that
		# the called function returns all the chars in this case

		aResult = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSections(pcSubStr)
		return This.FindSubStringBoundsAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsZZ(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		def FindBoundsOfAsSections(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		def FindBoundsOfZZ(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS AS SECTIONS - UP TO N CHARS - OF A GIVEN SUBSTRING IN THE STRING  #
	#=======================================================================================#

	def FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)
		#< @MotherFunctionOf = FindAsSectionsCS() #>

		if checkParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		# Getting the list of chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr,  pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen
			
			nTemp = 0

			n1 = aSections[i][1]
			c = acChars[n1-1]
			
			for j = n1 - 2 to 1 step - 1
				nTemp++
				if nTemp = n or acChars[j] != c
					exit
				ok
			next

			# Empty chars can't be part of a bound

			if NOT @trim(This.Section(j + 1, n1 - 1)) = ""
				aResult + [ j + 1, n1 - 1 ]
			ok

			#--

			nTemp = 0

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				nTemp++
				if nTemp = n or acChars[j] != c
					exit
				ok
			next

			# Empty chars can't be part of a bound

			if NOT @trim(This.Section(n1 + 1, j - 1)) = ""
				aResult + [ n1 + 1, j - 1 ]
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsCSZZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCSZZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsUpToNCharsAsSections(pcSubStr, n)
		return This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n,  TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsZZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNCharsAsSections(pcSubStr, n)

		def FindBoundsOfUpToNCharsAsSections(pcSubStr, n)
			return This.FindSubStringBoundsUpToNCharsAsSections(pcSubStr, n)

		def FindBoundsOfUpToNCharsZZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNCharsAsSections(pcSubStr, n)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS - UP TO N CHARS - OF A GIVEN SUBSTRING IN THE STRING  #
	#===========================================================================#

	def FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)
		aSections = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, n, pCasseSensitive)
		anResult = StzListOfPairsQ(aSections).FirstItems()
		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsCSZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCS(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		def FindBoundsOfUpToNCharsCSZ(pcSubStr, n,  pCaseSensitive)
			return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsUpToNChars(pcSubStr, n)
		return This.FindSubStringBoundsUpToNCharsCS(pcSubStr, n,  TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsUpToNCharsZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		def FindBoundsOfUpToNChars(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		def FindBoundsOfUpToNCharsZ(pcSubStr, n)
			return This.FindSubStringBoundsUpToNChars(pcSubStr, n)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS - UP TO N CHARS - OF A GIVEN SUBSTRING IN THE STRING -- XT #
	#--------------------------------------------------------------------------------#

	def FindSubStringBoundsAsSectionsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
		if CheckParams()
			if isList(pUpToNChars) and Q(pUpToNChars).IsUpToNCharsNamedParam()
				pUpToNChars = pUpToNChars[2]
			ok

			if NOT isNumber(pUpToNChars)
				StzRaise("Incorrect param type! pUpToNChars must be a number.")
			ok
		ok

		aResult = This.FindSubStringBoundsUpToNCharsAsSectionsCS(pcSubStr, pUpToNChars,  pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSXTZZ(pcSubStr, pUpToNChars,  pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, pUpToNChars,  pCaseSensitive)

		def FindBoundsOfAsSectionsCSXT(pcSubStr, pUpToNChars,  pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, pUpToNChars,  pCaseSensitive)

		def FindBoundsOfCSXTZZ(pcSubStr, pUpToNChars,  pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, pUpToNChars,  pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSectionsXT(pcSubStr, pUpToNChars)
		return This.FindSubStringBoundsAsSectionsCSXT(pcSubStr, pUpToNChars,  TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsXTZZ(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, pUpToNChars)

		def FindBoundsOfAsSectionsXT(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, pUpToNChars)

		def FindBoundsOfXTZZ(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsAsSectionsXT(pcSubStr, pUpToNChars)

		#>

	  #---------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def FindSubStringBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBounds(pcSubStr)
		return This.FindSubStringBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsZ(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		def FindBoundsOf(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		def FindBoundsOfZ(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

		#>

	  #-------------------------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING -- IB/EXTENSION  #
	#-------------------------------------------------------------------------#

	def FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundsCSIBZZ(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSIB(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		def FindBoundsOfCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSIB(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsIB(pcSubStr)
		return This.FindSubStringBoundsCSIB(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsIBZ(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		def FindBoundsOfIB(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		def FindBoundsOfIBZ(pcSubStr)
			return This.FindSubStringBoundsIB(pcSubStr)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING  #
	#=================================================================#

	def FindBoundedSubStringCS(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		anResult = []

		for i = 1 to nLen step 2
			anResult + anSections[i][2]++
		next

		return anResult

		def FindBoundedSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubString(pcSubStr)
		return This.FindBoundedSubStringCS(pcSubStr, TRUE)

		def FindBoundedSubStringZ(pcSubStr)
			return This.FindBoundedSubString(pcSubStr)

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------#

	def FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ anSections[i][2]++, anSections[i+1][1]-- ]
		next

		return aResult

		def FindBoundedSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringZZ(pcSubStr)
		return This.FindBoundedSubStringCSZZ(pcSubStr, TRUE)

		def FindBoundedSubStringAsSections(pcSubStr)
			return This.FindBoundedSubStringZZ(pcSubStr)

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- IB/EXTENSION  #
	#=================================================================================#

	def FindBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
		anSections = This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		anResult = []

		for i = 1 to nLen step 2
			anResult + anSections[i][2]++
		next

		return anResult

		def FindBoundedSubStringCSIBZ(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSIB(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringIB(pcSubStr)
		return This.FindBoundedSubStringCSIB(pcSubStr, TRUE)

		def FindBoundedSubStringIBZ(pcSubStr)
			return This.FindBoundedSubStringIB(pcSubStr)

	  #-----------------------------------------------------------------------------------#
	 #  FINDING THE GEIVEN SUBSTRING WHEN IT IS BOUNDED IN THE STRING -- IBZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------#

	def FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		anSections = This.FindSubStringBoundsCSZZ(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ anSections[i][1], anSections[i+1][2] ]
		next

		return aResult

		def FindBoundedSubStringAsSectionsCSIB(pcSubStr, pCaseSensitive)
			return This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindBoundedSubStringIBZZ(pcSubStr)
		return This.FindBoundedSubStringCSIBZZ(pcSubStr, TRUE)

		def FindBoundedSubStringAsSectionsIB(pcSubStr)
			return This.FindBoundedSubStringZZIB(pcSubStr)

	  #=================================================================================#
	 #  FINDING THE BOUNDS - UP TO N CHARS -- OF A GIVEN SUBSTRING IN THE STRING -- XT #
	#=================================================================================#

	def FindSubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
		if CheckParams()
			if isList(pUpToNChars) and Q(pUpToNChars).IsUpToNCharsNamedParam()
				pUpToNChars = pUpToNChars[2]
			ok

			if NOT isNumber(pUpToNChars)
				StzRaise("Incorrect param type! pUpToNChars must be a number.")
			ok
		ok

		aResult = This.FindSubStringBoundsUpToNCharsCS(pcSubStr, pUpToNChars, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundsCSXTZ(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

		def FindBoundsOfCSXT(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

		def FindBoundsOfCSXTZ(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.FindSubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsXT(pcSubStr, pUpToNChars)
		return This.FindSubStringBoundsCSXT(pcSubStr, pUpToNChars, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundsXTZ(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsXT(pcSubStr, pUpToNChars)

		def FindBoundsOfXT(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsXT(pcSubStr, pUpToNChars)

		def FindBoundsOfXTZ(pcSubStr, pUpToNChars)
			return This.FindSubStringBoundsXT(pcSubStr, pUpToNChars)

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS BOUNDS OF A GIVEN SUBSTRING  #
	#===============================================================#

	def ContainsBoundsOfCS(pcSubStr, pCaseSensitive)
		if len( This.BoundsOfCS(pcSubStr, pCaseSensitive) ) > 0
			return TRUE

		else
			return FALSE
		ok

		def SubStringIsBoundedCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

		def SubStringHasBoundsCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundsOf(pcSubStr)
		return This.ContainsBoundsOfCS(pcSubStr, TRUE)

		def SubStringIsBounded(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

		def SubStringHasBounds(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#===========================================================================#

	def FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringFirstBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringFirstBoundsAsSections(pcSubStr)
		return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		def FindFirstBoundsAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		#--

		def FindSubStringFirstBoundsZZ(pcSubStr)
			return This.FindSubStringFirstBoundsSections(pcSubStr)

		def FindFirstBoundsOfZZ(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		def FindFirstBoundsZZ(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#==

		def FindSubStringLastBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLastBoundsAsSections(pcSubStr)
		return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#==

		def FindSubStringLastBoundsZZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBoundsOfZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsZZ(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringLeftBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsOfAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLeftBoundsAsSections(pcSubStr)
		return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#--

		def FindSubStringLeftBoundsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsOfAsSectionsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSectionsZZ(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringRightBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringRightBoundsAsSections(pcSubStr)
		return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		def FindRightBoundsAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		#--

		def FindSubStringRightBoundsZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsZZ(pcSubStr)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringFirstBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringFirstBounds(pcSubStr)
		return This.FindSubStringFirstBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOf(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBounds(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#--

		def FindSubStringFirstBoundsZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBoundsOfZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBoundsZ(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForsm

		def FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#==

		def FindLastBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLastBounds(pcSubStr)
		return This.FindSubStringLastBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForsm

		def FindLastBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#==

		def FindLastBoundsOfZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOfZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsZ(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringLeftBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLeftBounds(pcSubStr)
		return This.FindSubStringLeftBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOf(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBounds(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#--

		def FindSubStringLeftBoundsZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBoundsOfZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBoundsZ(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringRightBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCSZ(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringRightBounds(pcSubStr)
		return This.FindRightBoundsOfCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOf(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBounds(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#--

		def FindSubStringRightBoundsZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBoundsOfZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBoundsZ(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def SubStringBoundsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<Ring>>, the beautiful ((Ring))!")
		? o1.BoundsOf("Ring")
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def BoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQR(pcSubStr, pCaseSensitive, :stzList)

			def BoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBounds(pcSubstr)
		return This.SubStringBoundsCS(pcSubstr, TRUE)

		#< @FunctionAlternativeForms

		def BoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def BoundsOfQ(pcSubStr)
				return This.BoundsOfCSQ(pcSubStr, TRUE)

			def BoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfCSQR(pcSubStr, TRUE, pcReturnType)

		#--

		def SubStringFirstAndLastBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndLastBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndLastBoundsQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def SubStringFirstAndSecondBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndSecondBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndSecondBoundsQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def FirstAndLastBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndLastBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndLastBoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def FirstAndSecondBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndSecondBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndSecondBoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE FIRST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#-------------------------------------------------------------#

	def SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def FirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringFirstBounds(pcSubStr)
		return This.SubStringFirstBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundsOf(pcSubStr)
			return This.SubStringFirstBounds(pcSubStr)

		def FirstBounds(pcSubStr)
			return This.FirstBoundsCS(pcSubStr, TRUE)

		#>

	  #------------------------------------------------------------#
	 #  GETTING THE LAST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#------------------------------------------------------------#

	def SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def LastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def LastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.LastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringLastBounds(pcSubStr)
		return This.SubStringLastBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def LastBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SubStringSecondBounds(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SecondBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		#--

		def LastBounds(pcSubStr)
			return This.LastBoundsCS(pcSubStr, TRUE)

		def SecondBounds(pcSubStr)
			return This.LastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def LeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringLeftBounds(pcSubStr)
		return This.SubStringLeftBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundsOf(pcSubStr)
			return This.SubStringLeftBounds(pcSubStr)

		def LeftBounds(pcSubStr)
			return This.LeftBoundsCS(pcSubStr, TRUE)
 
		#>

	  #------------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUNDS OF A GIVEN SUBSTRIG INSIDE THE STRING  #
	#------------------------------------------------------------------#

	def SubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightBoundsOfCS(pcsubStr, pCaseSensitive)
			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def RightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringRightBounds(pcSubStr)
		return This.SubStringRightBoundsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def RightBoundsOf(pcsubStr)
			return This.SubStringRightBounds(pcSubStr)

		def RightBounds(pcSubStr)
			return This.RightBoundsCS(pcSubStr, TRUE)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS, UP TO N CHARS, OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================================#

	def SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<<Ring>>>, the beautiful (((Ring)))!")
		? o1.BoundsOfUpToNchars("Ring", 2)
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfUptoNcharsAsSectionsCS(pcSubStr, n, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, :stzList)

		def SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def BoundsUpToNCharsOfCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, :stzList)

			def BoundsOfUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndLastBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndLastBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndSecondBoundsUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def SubStringFirstAndSecondBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def FirstAndLastBoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def FirstAndLastBoundsOfUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfUpToNCharsCS(pcSubStr, n, pCaseSensitive)
			return This.SubStringBoundsUpToNCharsCS(pcSubStr, n, pCaseSensitive)

			def FirstAndSecondBoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)
				return This.BoundsOfUpToNCharsCSQ(pcSubStr, n, pCaseSensitive)

			def FirstAndSecondBoundsOfUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsUpToNCharsCSQR(pcSubStr, n, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBoundsUpToNChars(pcSubstr, n)
		return This.SubStringBoundsUpToNCharsCS(pcSubstr, n, TRUE)

		#< @FunctionAlternativeForms

		def BoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def BoundsUpToNCharsOfQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQR(pcSubStr, n, :stzList)

			def BoundsOfUpToNCharsQR(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def SubStringFirstAndLastBoundsUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def SubStringFirstAndLastBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)

		def SubStringFirstAndSecondBoundsUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def SubStringFirstAndSecondBoundsUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def SubStringFirstAndSecondBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)

		def FirstAndLastBoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def FirstAndLastBoundsOfUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def FirstAndLastBoundsOfUpToNCharsQR(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)

		def FirstAndSecondBoundsOfUpToNChars(pcSubStr, n)
			return This.SubStringBoundsUpToNChars(pcSubStr, n)

			def FirstAndSecondBoundsOfUpToNCharsQ(pcSubStr, n)
				return This.BoundsOfUpToNCharsQ(pcSubStr, n)

			def FirstAndSecondBoundsOfUpToNCharsQR(pcSubStr, n, pcReturnType)
				return This.SubStringBoundsUpToNCharsQR(pcSubStr, n, pcReturnType)

		#>

	  #-------------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS, UP TO N CHARS, OF A GIVEN SUBSTRING IN THE STRING -- XT  #
	#-------------------------------------------------------------------------------#

	def SubStringBoundSCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<<Ring>>>, the beautiful (((Ring)))!")
		? o1.BoundsOfXT("Ring", :UpToNChars = 2)
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, :stzList)

		def SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

			def BoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
				return This.BoundsOfCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, :stzList)

			def BoundsOfCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

			def FirstAndLastBoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)

			def FirstAndLastBoundsOfCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfCSXT(pcSubStr, pUpToNChars, pCaseSensitive)
			return This.SubStringBoundsCSXT(pcSubStr, pUpToNChars, pCaseSensitive)

			def FirstAndSecondBoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)
				return This.BoundsOfCSXTQ(pcSubStr, pUpToNChars, pCaseSensitive)

			def FirstAndSecondBoundsOfCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSXTQR(pcSubStr, pUpToNChars, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBoundsXT(pcSubstr, pUpToNChars)
		return This.SubStringBoundsCSXT(pcSubstr, pUpToNChars, TRUE)

		#< @FunctionAlternativeForms

		def BoundsOfXT(pcSubStr, pUpToNChars)
			return This.SubStringBoundsXT(pcSubStr, pUpToNChars)

			def BoundsXTOfQ(pcSubStr, pUpToNChars)
				return This.BoundsOfXTQR(pcSubStr, pUpToNChars, :stzList)

			def BoundsOfXTQR(pcSubStr, pUpToNChars, pcReturnType)
				return This.SubStringBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsXT(pcSubStr, pUpToNChars)
			return This.SubStringBoundsXT(pcSubStr, pUpToNChars)

			def SubStringFirstAndLastBoundsXTQ(pcSubStr, pUpToNChars)
				return This.BoundsOfXTQ(pcSubStr, pUpToNChars)

			def SubStringFirstAndLastBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)
				return This.SubStringBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)

		def SubStringFirstAndSecondBoundsXT(pcSubStr, pUpToNChars)
			return This.SubStringBoundsXT(pcSubStr, pUpToNChars)

			def SubStringFirstAndSecondBoundsXTQ(pcSubStr, pUpToNChars)
				return This.BoundsOfXTQ(pcSubStr, pUpToNChars)

			def SubStringFirstAndSecondBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)
				return This.SubStringBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)

		def FirstAndLastBoundsOfXT(pcSubStr, pUpToNChars)
			return This.SubStringBoundsXT(pcSubStr, pUpToNChars)

			def FirstAndLastBoundsOfXTQ(pcSubStr, pUpToNChars)
				return This.BoundsOfXTQ(pcSubStr, pUpToNChars)

			def FirstAndLastBoundsOfXTQR(pcSubStr, pUpToNChars, pcReturnType)
				return This.SubStringBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)

		def FirstAndSecondBoundsOfXT(pcSubStr, pUpToNChars)
			return This.SubStringBoundsXT(pcSubStr, pUpToNChars)

			def FirstAndSecondBoundsOfXTQ(pcSubStr, pUpToNChars)
				return This.BoundsOfXTQ(pcSubStr, pUpToNChars)

			def FirstAndSecondBoundsOfXTQR(pcSubStr, pUpToNChars, pcReturnType)
				return This.SubStringBoundsXTQR(pcSubStr, pUpToNChars, pcReturnType)

		#>

	  #------------------------------------#
	 #  REMOVING BOUNDS OF THE SUBSTRING  #
	#====================================#

	def RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)


		#< @FunctionFluentForm

		def RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsOfCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr,pCaseSensitive)

			def RemoveSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSecondAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringLeftAndRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftAndRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringRightAndLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightAndLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndLastBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLastAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SecondAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLeftAndRightBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LeftAndRightBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringRightAndLeftBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def RightAndLeftBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringBounds(pcSubStr)
		return This.RemoveSubStringBoundsCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringBoundsQ(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveBoundsOfQ(pcSubStr)
				This.RemoveBoundsOf(pcSubStr)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndLastBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		def RemoveSubStringFirstAndSecondBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndSecondBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		#--

		def RemoveFirstAndLastBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveFirstAndLastBoundsOfQ(pcSubStr)
				This.RemoveFirstAndLastBoundsOf(pcSubStr)
				return This

		def RemoveFirstAndSecondBoundsOf(pcSubStr)
			This.RemoveSubStringBoundsOf(pcSubStr)

			def RemoveFirstAndSecondBoundsOfQ(pcSubStr)
				This.RemoveFirstAndSecondBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLastAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubSt)

			def RemoveSubStringLastAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringLastAndFirstBounds(pcSubStr)
				return This

		def RemoveSubStringSecondAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringSecondAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringSecondAndFirstBounds(pcSubStr)
				return This

		#--

		def RemoveLastAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLastAndFirstBoundsOfQ(pcSubStr)
				This.RemoveLastAndFirstBoundsOf(pcSubStr)
				return This

		def RemoveSecondAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSecondAndFirstBoundsOfQ(pcSubStr)
				This.RemoveSecondAndFirstBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLeftAndRightBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringLeftAndRightBoundsQ(pcSubStr)
				This.RemoveSubStringLeftAndRightBounds(pcSubStr)
				return This

		#--

		def RemoveLeftAndRightBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLeftAndRightBoundsOfQ(pcSubStr)
				This.RemoveLeftAndRightBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringRightAndLeftBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringRightAndLeftBoundsQ(pcSubStr)
				This.RemoveSubStringRightAndLeftBounds(pcSubStr)
				return This

		#--

		def RemoveRightAndLeftBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveRightAndLeftBoundsOfQ(pcSubStr)
				This.RemoveRightAndLeftBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndLastBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringFirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLastAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LastAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringSecondAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SecondAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLeftAndRightBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LeftAndRightBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringRightAndLeftBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def RightAndLeftBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#>

	  #----------------------------------------#
	 #  REMOVING LEFT BOUND OF THE SUBSTRING  #
	#========================================#

	def RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLeftBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		def LeftBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBounds()
		This.RemoveSubStringLeftBoundsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsQ()
			This.RemoveSubStringLeftBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBounds(pcSubStr)
			This.RemoveLeftBoundsCS(pcSubStr, TRUE)

			def RemoveLeftBoundsQ(pcSubStr)
				This.RemoveLeftBounds(pcSubStr)
				return This

		def RemoveLeftBoundsOf(pcSubStr)
			This.RemoveSubStringLeftBounds(pcSubStr)

			def RemoveLeftBoundsOfQ(pcSubStr)
				This.RemoveLeftBoundsOf(pcSubStr)

		#>

	def SubStringLeftBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLeftBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemoved()
			return This.SubStringLeftBoundsRemoved()

		def LeftBoundOfsRemoved()
			return This.SubStringLeftBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringRightBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		def RightBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBounds()
		This.RemoveSubStringRightBoundsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsQ()
			This.RemoveSubStringRightBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBounds(pcSubStr)
			This.RemoveRightBoundsCS(pcSubStr, TRUE)

			def RemoveRightBoundsQ(pcSubStr)
				This.RemoveRightBounds(pcSubStr)
				return This

		def RemoveRightBoundsOf(pcSubStr)
			This.RemoveSubStringRightBounds(pcSubStr)

			def RemoveRightBoundsOfQ(pcSubStr)
				This.RemoveRightBoundsOf(pcSubStr)

		#>

	def SubStringRightBoundsRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemoved()
			return This.SubStringRightBoundsRemoved()

		def RightBoundOfsRemoved()
			return This.SubStringRightBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING FIRST BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringFirstBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		def FirstBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBounds()
		This.RemoveSubStringFirstBoundsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsQ()
			This.RemoveSubStringFirstBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBounds(pcSubStr)
			This.RemoveFirstBoundsCS(pcSubStr, TRUE)

			def RemoveFirstBoundsQ(pcSubStr)
				This.RemoveFirstBounds(pcSubStr)
				return This

		def RemoveFirstBoundsOf(pcSubStr)
			This.RemoveSubStringFirstBounds(pcSubStr)

			def RemoveFirstBoundsOfQ(pcSubStr)
				This.RemoveFirstBoundsOf(pcSubStr)

		#>

	def SubStringFirstBoundsRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemoved()
			return This.SubStringFirstBoundsRemoved()

		def FirstBoundOfsRemoved()
			return This.SubStringFirstBoundsRemoved()

		#>

	  #----------------------------------------#
	 #  REMOVING LAST BOUND OF THE SUBSTRING  #
	#----------------------------------------#

	def RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLastBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		def LastBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBounds()
		This.RemoveSubStringLastBoundsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsQ()
			This.RemoveSubStringLastBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBounds(pcSubStr)
			This.RemoveLastBoundsCS(pcSubStr, TRUE)

			def RemoveLastBoundsQ(pcSubStr)
				This.RemoveLastBounds(pcSubStr)
				return This

		def RemoveLastBoundsOf(pcSubStr)
			This.RemoveSubStringLastBounds(pcSubStr)

			def RemoveLastBoundsOfQ(pcSubStr)
				This.RemoveLastBoundsOf(pcSubStr)

		#>

	def SubStringLastBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemoved()
			return This.SubStringLastBoundsRemoved()

		def LastBoundOfsRemoved()
			return This.SubStringLastBoundsRemoved()

		#>

	  #-----------------------------------------------------#
	 #  REMOVING A SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS  #
	#=====================================================#

	def RemoveBoundedSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundedSubStringCSZZ(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveBoundedSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveBoundedSubStringCS(pcSubStr, pCaseSensitive)
			return This

	def BoundedSubStringRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveBoundedSubStringCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveBoundedSubString(pcSubStr)
		This.RemoveBoundedSubStringCS(pcSubStr, TRUE)

		def RemoveBoundedSubStringQ(pcSubStr)
			This.RemoveBoundedSubString(pcSubStr)
			return This

	def BoundedSubStringRemoved(pcSubStr)
		cResult = This.Copy().RemoveBoundedSubStringQ(pcSubStr)
		return This

	  #---------------------------------------------------------------------#
	 #  REMOVING A SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#---------------------------------------------------------------------#

	def RemoveBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundedSubStringCSIBZZ(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveBoundedSubStringCSIBQ(pcSubStr, pCaseSensitive)
			This.RemoveBoundedSubStringCSIB(pcSubStr, pCaseSensitive)
			return This

	def BoundedSubStringRemovedCSIB(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveBoundedSubStringCSIBQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveBoundedSubStringIB(pcSubStr)
		This.RemoveBoundedSubStringCSIB(pcSubStr, TRUE)

		def RemoveBoundedSubStringIBQ(pcSubStr)
			This.RemoveBoundedSubStringIB(pcSubStr)
			return This

	def BoundedSubStringRemovedIB(pcSubStr)
		cResult = This.Copy().RemoveBoundedSubStringIBQ(pcSubStr)
		return This

	  #-------------------------------------------------------#
	 #  REMOVING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS  #
	#=======================================================#

	def RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindTheseSubStringBoundsCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveTheseSubStringBoundsCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVE

	def RemoveTheseSubStringBounds(pcSubStr, pacBounds)
		This.RemoveTheseSubStringBoundsCS(pcSubStr, pacBounds, TRUE)

		def RemoveTheseSubStringBoundsQ(pcSubStr, pacBounds)
			This.RemoveTheseSubStringBounds(pcSubStr, pacBounds)
			return This

	  #----------------------------------------#
	 #  SWAPPING BOUNDS OF A GIVEN SUBSTRING  #
	#========================================#

	def SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		aPairsOfSections = Q(aSections).SplitToListsOfNItems(2)
		nLen = len(aPairsOfSections)

		for i = 1 to nLen
			This.SwapSections(aPairsOfSections[i][1], aPairsOfSections[i][2])
		next

		#< @FunctionFluentForm

		def SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def SubStringLastAndFirstBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def FirstAndLastBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStringBounds(pcSubStr)
		This.SwapSubStringBoundsCS(pcSubStr, TRUE)
	
		#< @FunctionFluentForm

		def SwapSubStringBoundsQ(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapBoundsOfQ(pcSubStr)
				This.SwapBoundsOf(pcSubStr)
				return This

		#--

		def SwapSubStringFirstAndLastBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringFirstAndLastBoundsQ(pcSubStr)
				This.SwapSubStringFirstAndLastBounds(pcSubStr)
				return This

		def SwapSubStringLastAndFirstBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringLastAndFirstBoundsQ(pcSubStr)
				This.SwapSubStringLastAndFirstBounds(pcSubStr)
				return This

		#--

		def SwapFirstAndLastBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapFirstAndLastBoundsOfQ(pcSubStr)
				This.SwapFirstAndLastBoundsOf(pcSubStr)
				return This

		def SwapLastAndFirstBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapLastAndFirstBoundsOfQ(pcSubStr)
				This.SwapLastAndFirstBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsSwapped(pcSubStr)
		cResult = This.Copy().SwapSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def SubStringLastAndFirstBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def FirstAndLastBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def LastAndFirstBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#>

	  #========================================================================================#
	 #  FINDING ANY SUBSTRING BETWEEN THE FIRST AND LAST OCCURRENCES OF TWO GIVEN SUBSTRINGS  #
	#========================================================================================#

	def FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		n1 = This.FindFirstOccurrenceCS(pcBound1, pCaseSensitive) + nLen1
		n2 = This.FindLastOccurrenceCS(pcBound2, pCaseSensitive) - 1

		if n2 < n1
			nTemp = n2
			n2 = n1
			n1 = nTemp
		ok

		aResult = [ n1, n2 ]
		return aResult

		#< @FunctionAlternativeForms

		def FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		def FindAnyBetweenCSZZ(pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSection(pcBound1, pcBound2)
		return This.FindBetweenAsSectionCS(pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForms

		def FindAnyBetweenAsSection(pcBound1, pcBound2)
			return This.FindBetweenAsSection(pcBound1, pcBound2)

		def FindAnyBetweenZZ(pcBound1, pcBound2)
			return This.FindBetweenAsSection(pcBound1, pcBound2)

		#>

	  #=======================================================#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=======================================================#

	def RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		aSection = This.FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSection(aSection[1], aSection[2])

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		def RemoveBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

			def RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
				return This.RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)

		#>

	def AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetween(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCS(pcBound1, pcBound2, TRUE)


	def AnyBetweenRemoved(pcBound1, pcBound2)
		acResult = This.Copy().RemoveAnyBetweenCSQ(pcBound1, pcBound2).Content()
		return acResult

	  #-------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#-------------------------------------------------------------------#
	#--> Bounds are also removed (TODO: Generalise this feature)

	def RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetweenIB(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, TRUE)

	def AnyBetweenRemovedIB(pcBound1, pcBound2)
		acResult = This.Copy().RemoveBetweenIBQ(pcBound1, pcBound2).Content()
		return acResult

	  #============================================================#
	 #     REMOVING LEFT BOUND OF A SUBSTRING FROM THE STRING     #
	#============================================================#

	def RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.LeftNChars( nLenSubStr ) = pcSubStr
			This.ReplaceFirstOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			return This
		#>


		#< @FunctionAlternativeForms

		def RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBound(pcSubStr)
		This.RemoveSubStringLeftBoundCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundQ(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveLeftBoundOfQ(pcSubStr)
				This.RemoveLeftBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLeftBound(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachSubStringLeftBoundQ(pcSubStr)
				This.RemoveEachSubStringLeftBound(pcSubStr)
				return This

		def RemoveEachLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachLeftBoundOfQ(pcSubStr)
				This.RemoveEachLeftBoundOf(pcSubStr)
				return This

		#>

	def SubStringLeftBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLeftBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemoved(pcSubStr)
			return This.SubStringLeftBoundRemoved(pcSubStr)

		#>

	  #--------------------------------------------#
	 #    REMOVING RIGHT BOUND FROM THE STRING    #
	#--------------------------------------------#

	def RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.RightNChars( nLenSubStr ) = pcSubStr
			This.ReplaceLastOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringrightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult


		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBound(pcSubStr)
		This.RemoveSubStringRightBoundCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundQ(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOf(pcSubStr)
			This.RemoveSubStringrightBound(pcSubStr)

			def RemoveRightBoundOfQ(pcSubStr)
				This.RemoveRightBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringRightBound(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachSubStringRightBoundQ(pcSubStr)
				This.RemoveEachSubStringRightBound(pcSubStr)
				return This

		def RemoveEachRightBoundOf(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachRightBoundOfQ(pcSubStr)
				This.RemoveEachRightBoundOf(pcSubStr)
				return This

		#>

	def RightSubStringBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringRightBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemoved(pcSubStr)
			return This.SubStringRightBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   REMOVING FIRST BOUND FROM THE STRING    #
	#-------------------------------------------#

	def RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() than...
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm
	
		def RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBound(pcSubStr)
		This.RemoveSubStringFirstBoundCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveFirstBoundOfQ(pcSubStr)
				This.RemoveFirstBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringFirstBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringFirstBoundQ(pcSubStr)
				This.RemoveEachSubStringFirstBound(pcSubStr)
				return This

		def RemoveEachFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveEachFirstBoundOfQ(pcSubStr)
				This.RemoveEachFirstBoundOf(pcSubStr)
				return This

		#>


	def SubStringFirstBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringFirstBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemoved(pcSubStr)
			return This.SubStringFirstBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REMOVING EACH LAST BOUND OF A SUBSTRING FROM THE STRING   #
	#-------------------------------------------------------------#

	def RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() then...
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def EachSubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBound(pcSubStr)
		This.RemoveSubStringLastBoundCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveLastBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSecondBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSubStringSecondBoundQ(pcSubStr)
				This.RemoveSubStringSecondBound(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLastBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringLastBoundQ(pcSubStr)
				This.RemoveEachSubStringLastBound(pcSubStr)
				return This

		def RemoveEachLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachLastBoundOfQ(pcSubStr)
				This.RemoveEachLastBoundOf(pcSubStr)
				return This

		def RemoveEachSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSecondBoundOfQ(pcSubStr)
				This.RemoveEachSecondBoundOf(pcSubStr)
				return This

		def RemoveEachSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringSecondBoundQ(pcSubStr)
				This.RemoveEachSubStringSecondBound(pcSubStr)
				return This

		#>

	def SubStringLastBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLastBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def SubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def EachSubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CHECKING OF THE STRING CONTAINS THE GIVEN BOUNDS   #
	#------------------------------------------------------#

	def ContainsTheseBoundsCS(pacBounds, pCaseSensitive)
		if NOT ( isList(pacBounds) and Q(pacBounds).IsAPairOfStrings() )
			StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
		ok

		if (NOT This.ContainsCS(pacBounds[1])) or
		   (NOT This.ContainsCS(pacBounds[2]))

			return FALSE
		ok

		n1 = This.FindFirstCS(pacBounds[1])
		n2 = This.FindFirstCS(pacBounds[2])

		if n1 < n2
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseBounds(pacBounds)
		return This.ContainsTheseBoundsCS(pacBounds, TRUE)

	  #============================#
	 #   REPEATED LEADING CHARS   #
	#============================#

	def RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> 'eee'
			'exeeeeeTUNIS' 	--> ''
		*/

		nLen = This.NumberOfCharsCS(pCaseSensitive)

		if nLen = 0 or nLen = 1
			return ""
		ok

		if NOT This.CharQ(1).IsEqualToCS( This.Char(2), pCaseSensitive)
			return ""
		ok

		cResult = ""
	
		bContinue = TRUE
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = FALSE
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = FALSE
			ok

		end

		n = i
		if i > 2
			n--
		ok

		cResult = This.Section(1, n)
		return cResult

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedLeadingCharsAsStringCS(pCaseSensitive)
			ThisRepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedLeadingCharsCSXT(pCaseSensitive)
			ThisRepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)

		def LeadingRepeatedCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		def LeadingCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingCharsAsSubString()
		return This.RepeatedLeadingCharsAsSubStringCS(TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringQ()
			return new stzString( This.RepeatedLeadingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsSubStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		#--

		def RepeatedLeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsStringQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		#--

		def RepeatedLeadingCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		def LeadingRepeatedCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()
	
		def LeadingCharsXT()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsXTQ()
				return This.RepeatedLeadingCharsAsSubStringQ()

		#>

	  #--------------------------------------#
	 #  LEADING SUBSTRING AND ITS POSITION  #
	#--------------------------------------#

	def LeadingSubStringCSZ(pCaseSensitive)
		cSubStr = This.LeadingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		return [ cSubStr, 1 ]

		def LeadingSubStringAndItsPositionCS(pCaseSensitive)
			return This.LeadingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeadingSubStringZ()
		return This.LeadingSubStringCSZ(TRUE)

		def LeadingSubStringAndItsPosition()
			return This.LeadingSubStringZ()

	  #-------------------------------------#
	 #  LEADING SUBSTRING AND ITS SECTION  #
	#-------------------------------------#

	def LeadingSubStringCSZZ(pCaseSensitive)
		cSubStr = This.LeadingSubStringCS(pCaseSensitive)
		aSection = This.FindLeadingSubStringCSZZ(pCaseSensitive)

		if cSubStr = ""
			return []
		ok

		return [ cSubStr, aSection ]

		def LeadingSubStringAndItsSectionCS(pCaseSensitive)
			return This.LeadingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeadingSubStringZZ()
		return This.LeadingSubStringCSZZ(TRUE)

		def LeadingSubStringAndItsSection()
			return This.LeadingSubStringZZ()

	  #----------------------------#
	 #   REPEATED LEADING CHARS   #
	#----------------------------#

	def RepeatedLeadingCharsCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> [ 'e', 'e', 'e' ]
			'exeeeeeTUNIS' 	--> []
		*/

		nLen = This.NumberOfCharsCS(pCaseSensitive)
		if nLen = 0 or nLen = 1
			return ""
		ok

		if NOT This.CharQ(1).IsEqualToCS( This.Char(2), pCaseSensitive )
			return []
		ok

		acResult = []
	
		bContinue = TRUE
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = FALSE
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = FALSE
			ok

		end

		n = i
		if i > 2
			n--
		ok

		acResult = This.CharsInSection(1, n)
		return acResult

		#< @FunctionFluentForm

		def RepeatedLeadingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedLeadingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingRepeatedCharsCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsCSQ(pCaseSensitive)
	
		def LeadingCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingCharsCSQ(pCaseSensitive)
				return This.RepeatedLeadingCharsCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChars()
		return This.RepeatedLeadingCharsCS(TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsQ()
			return new stzList( This.RepeatedLeadingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChars()
			return This.RepeatedLeadingChars()

			def LeadingRepeatedCharsQ()
				return This.RepeatedLeadingCharsQ()
	
		def LeadingChars()
			return This.RepeatedLeadingChars()

			def LeadingCharsQ()
				return This.RepeatedLeadingCharsQ()
	
		#>

	  #-------------------------------------#
	 #  GETTING THE REPEATED LEADING CHAR  #
	#-------------------------------------#

	def RepeatedLeadingCharCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return This.Char(1)
		else
			return NULL
		ok

		#< @FunctionFleuntForms

		def RepeatedLeadingCharCSQ(pCaseSensitive)
			return This.RepeatedLeadingCharCSQR(pCaseSensitive, :stzChar)

		def RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedLeadingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingRepeatedCharCSQ(pCaseSensitive)
				return This.LeadingRepeatedCharCSQR(pCaseSensitive, :stzChar)
	
		def LeadingCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingCharCSQ(pCaseSensitive)
				return This.LeadingCharCSQR(pCaseSensitive, :stzString)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChar()
		return This.RepeatedLeadingCharCS(TRUE)


		#< @FunctionFleuntForms

		def RepeatedLeadingCharQ()
			return This.RepeatedLeadingCharQR(:stzString)

		def RepeatedLeadingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingChar())

			on :stzString
				return new stzString(This.RepeatedLeadingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChar()
			return This.RepeatedLeadingChar()

			def LeadingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingRepeatedCharQ()
				return This.LeadingRepeatedCharQR(:stzChar)
	
		def LeadingChar()
			return This.RepeatedLeadingChar()

			def LeadingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingCharQ()
				return This.LeadingCharQR(:stzChar)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED LEADING CHARS IN THE STRING  #
	#--------------------------------------------------------------#

	def NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0

		if This.ContainsLeadingCharsCS(pCaseSensitive)
			nResult = This.LeadingCharsCSQ(pCaseSensitive).NumberOfChars()
		ok

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def NumberOfLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
	
		def CountLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def CountLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedLeadingChars()
		return This.NumberOfRepeatedLeadingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def NumberOfLeadingChars()
			return This.NumberOfRepeatedLeadingChars()
	
		def CountLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChar()
			return This.NumberOfRepeatedLeadingChars()

		def CountLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChar()
			return This.NumberOfRepeatedLeadingChars()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED LEADING CHAR IN THE STRING  #
	#---------------------------------------------------------------------#

	def RepeatedLeadingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)

		def LeadingCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedLeadingCharIs(c)
		return This.RepeatedLeadingCharIsCS(c, TRUE)

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIs(c)
			return This.RepeatedLeadingCharIs(c)

		def LeadingCharIs(c)
			return This.RepeatedLeadingCharIs(c)
	
		#>

	  #----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED LEADING CHAR  #
	#====================================================#

	def HasRepeatedLeadingCharsCS(pCaseSensitive)
		if This.LeadingSubStringCS(pCaseSensitive) != NULL
			return TRUE
		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasLeadingSubStringCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#== adding A

		def HasALeadingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasALeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def HasARepeatedLeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsARepeatedLeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsALeadingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsALeadingCharCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingChars()
		return This.HasRepeatedLeadingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def HasLeadingSubString()
			return This.HasRepeatedLeadingChars()

		def HasLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def HasLeadingChars()
			return This.HasRepeatedLeadingChars()

		#--

		def ContainsRepeatedLeadingChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingChars()
			return This.HasRepeatedLeadingChars()

		#== adding A

		def HasALeadingRepeatedChar()
			return This.HasRepeatedLeadingChars()

		def HasALeadingChar()
			return This.HasRepeatedLeadingChars()

		#--

		def HasARepeatedLeadingChar()
			return This.HasRepeatedLeadingChars()

		def ContainsARepeatedLeadingChar()
			return This.HasRepeatedLeadingChars()

		def ContainsALeadingRepeatedChar()
			return This.HasRepeatedLeadingChars()

		def ContainsALeadingChar()
			return This.HasRepeatedLeadingChars()

		#>

	  #-----------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS  # 
	#===============================================#

	def FindRepeatedLeadingCharsCS(pCaseSensitive)

		nLen = @oQString.count()

		if nLen < 2
			return []
		ok

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		return 1:n

		#< @FunctionALternativeForm

		def FindLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

		def FindLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingChars()
		return This.FindRepeatedLeadingCharsCS(TRUE)

		#< @FunctionALternativeForm

		def FindLeadingChars()
			return This.FindRepeatedLeadingChars()

		def FindLeadingCharsZ()
			return This.FindRepeatedLeadingChars()

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS AND RETURNING THEM AS SECTION  # 
	#-----------------------------------------------------------------------------#

	def FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		anResult = [ 1, n ]

		return anResult

		#< @FunctionAlternativeForms

		def FindLeadingSubStringCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingSubStringAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		def FindLeadingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingCharsAsSection()
		return This.FindRepeatedLeadingCharsAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindLeadingSubStringZZ()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingSubStringAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingCharsZZ()
			return This.FindRepeatedLeadingCharsAsSection()

		def FindLeadingCharsAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------#

	def RepeatedLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZ()
		return This.RepeatedLeadingCharsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsZ()
			return This.RepeatedLeadingCharsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR SECTION  #
	#-----------------------------------------------------------#

	def RepeatedLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZZ()
		return This.RepeatedLeadingCharsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsZZ()
			return This.RepeatedLeadingCharsZZ()

		#>

	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING CHARS   #
	#=====================================#

	def RemoveRepeatedLeadingCharsCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingCharsCSQ()
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingSubStringCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingSubStringCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#==

		#== Char (without an "s")

		def RemoveRepeatedLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveRepeatedLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#-- adding ANY

		def RemoveAnyRepeatedLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyRepeatedLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		def RemoveAnyLeadingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyLeadingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()
	
		def RemoveanyLeadingCharCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveAnyLeadingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedLeadingCharsCSQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedLeadingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingCharsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeadingSubStringRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#==

		def RepeatedLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#--

		def AnyRepeatedLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def AnyLeadingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def AnyLeadingCharRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingChars()
		This.RemoveRepeatedLeadingCharsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveRepeatedLeadingCharsQ()
			This.RemoveRepeatedLeadingChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLeadingSubString()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingSubStringQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveLeadingRepeatedChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharsQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveLeadingChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharsQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#== Char (without an "s")

		def RemoveRepeatedLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveRepeatedLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveLeadingRepeatedChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#-- adding ANY

		def RemoveAnyRepeatedLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyRepeatedLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		def RemoveAnyLeadingRepeatedChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyLeadingRepeatedCharQ()
				return This.RemoveRepeatedLeadingCharsQ()
	
		def RemoveanyLeadingChar()
			This.RemoveRepeatedLeadingChars()

			def RemoveAnyLeadingCharQ()
				return This.RemoveRepeatedLeadingCharsQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedLeadingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingCharsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeadingSubStringRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingRepeatedCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#==

		def RepeatedLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingRepeatedCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#--

		def AnyRepeatedLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def AnyLeadingRepeatedCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def AnyLeadingCharRemoved()
			return This.RepeatedLeadingCharsRemoved()

		#>

	  #=============================#
	 #   REPEATED TRAILING CHARS   #
	#=============================#

	def RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)
		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = @oQString.count()
		cLastChar = @oQString.mid(nLenStr-1, 1)

		cResult = ""

		for i = 1 to n
			cResult += cLastChar
		next

		return cResult

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def RepeatedTrailingSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingRepeatedSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		#==

		def TrailingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsSubStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedTrailingCharsAsStringCS(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#--

		def RepeatedTrailingCharsCSXT(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)

		def TrailingRepeatedCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		def TrailingCharsAsStringCSXT(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSXTQ(pCaseSensitive)
				return This.RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharsAsSubString()
		return This.RepeatedTrailingCharsAsSubStringCS(TRUE)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringQ()
			return new stzString( This.RepeatedTrailingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def RepeatedTrailingSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingRepeatedSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#==

		def TrailingRepeatedCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsSubStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		#--

		def RepeatedTrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingRepeatedCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsStringQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#--

		def RepeatedTrailingCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		def TrailingRepeatedCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()
	
		def TrailingCharsXT()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsXTQ()
				return This.RepeatedTrailingCharsAsSubStringQ()

		#>

	  #-----------------------------#
	 #   REPEATED TRAILING CHARS   #
	#-----------------------------#

	def RepeatedTrailingCharsCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = @oQString.count()
		cLastChar = @oQString.mid(nLenStr-1, 1)
		acResult = []

		for i = 1 to n
			acResult + cLastChar
		next

		return acResult


		#< @FunctionFluentForm

		def RepeatedTrailingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedTrailingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingRepeatedCharsCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsCSQ(pCaseSensitive)

		def TrailingCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingCharsCSQ(pCaseSensitive)
				return This.RepeatedTrailingCharsCSQ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChars()
		return This.RepeatedTrailingCharsCS(TRUE)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsQ()
			return new stzList( This.RepeatedTrailingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedChars()
			return This.RepeatedTrailingChars()

			def TrailingRepeatedCharsQ()
				return This.RepeatedTrailingCharsQ()
	
		def TrailingChars()
			return This.RepeatedTrailingChars()

			def TrailingCharsQ()
				return This.RepeatedTrailingCharsQ()
	
		#>

	  #--------------------------------------#
	 #  GETTING THE REPEATED TRAILING CHAR  #
	#--------------------------------------#

	def RepeatedTrailingCharCS(pCaseSensitive)

		nLen = This.NumberOfChars()
		if nLen < 2
			return ""
		ok

		cLastChar = @oQString.mid(nLen-1, 1)
		cBeforeLastChar = @oQString.mid(nLen-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return cLastChar
		else
			return ""
		ok

		#< @FunctionFleuntForms

		def RepeatedTrailingCharCSQ(pCaseSensitive)
			return This.RepeatedTrailingCharCSQR(pCaseSensitive, :stzChar)

		def RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedTrailingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedTrailingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)

			def TrailingRepeatedCharCSQ(pCaseSensitive)
				return This.TrailingRepeatedCharCSQR(pCaseSensitive, :stzChar)
	
		def TrailingCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)

			def TrailingCharCSQ(pCaseSensitive)
				return This.TrailingCharCSQR(pCaseSensitive, :stzChar)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChar()
		return This.RepeatedTrailingCharCS(TRUE)


		#< @FunctionFleuntForms

		def RepeatedTrailingCharQ()
			return This.RepeatedTrailingCharQR(:stzString)

		def RepeatedTrailingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedTrailingChar())

			on :stzString
				return new stzString(This.RepeatedTrailingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedChar()
			return This.RepeatedTrailingChar()

			def TrailingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

			def TrailingRepeatedCharQ()
				return This.TrailingRepeatedCharQR(:stzChar)
	
		def TrailingChar()
			return This.RepeatedTrailingChar()

			def TrailingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

			def TrailingCharQ()
				return This.TrailingCharQR(:stzChar)
	
		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED TRAILING CHARS IN THE STRING  #
	#---------------------------------------------------------------#

	def NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		nLen = This.NumberOfChars()

		if nLen < 2
			return 0
		ok

		cLastChar = @oQString.mid(nLen-1, 1)
		cBeforeLastChar = @oQString.mid(nLen-2, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return 0
		ok

		n = 0

		for i = nLen to 1 step - 1
			cChar = @oQString.mid(i-1, 1)
			if NOT StzStringQ(cChar).IsEqualToCS(cLastChar, pCaseSensitive)
				exit
			else
				n++
			ok
		next

		return n

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def NumberOfTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
	
		def CountTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def CountTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def HowManyTrailingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedTrailingChars()
		return This.NumberOfRepeatedTrailingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def NumberOfTrailingChars()
			return This.NumberOfRepeatedTrailingChars()
	
		def CountTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingRepeatedChar()
			return This.NumberOfRepeatedTrailingChars()

		def CountTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

		def HowManyTrailingChar()
			return This.NumberOfRepeatedTrailingChars()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED TRAILING CHAR IN THE STRING  #
	#----------------------------------------------------------------------#

	def RepeatedTrailingCharIsCS(c, pCaseSensitive)
		nLen = This.NumberOfChars()

		if nLen < 2
			return FALSE
		ok

		cLastChar = @oQString.mid(nLen-1, 1)
		cBeforeLastChar = @oQString.mid(nLen-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive) and
		   StzStringQ(c).IsEqualToCS(cLastChar, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)

		def TrailingCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedTrailingCharIs(c)
		return This.RepeatedTrailingCharIsCS(c, TRUE)

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharIs(c)
			return This.RepeatedTrailingCharIs(c)

		def TrailingCharIs(c)
			return This.RepeatedTrailingCharIs(c)
	
		#>

	  #-----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED TRAILING CHAR  #
	#=====================================================#

	def HasRepeatedTrailingCharsCS(pCaseSensitive)

		nLen = This.NumberOfChars()

		if nLen < 2
			return FALSE
		ok

		cLastChar = @oQString.mid(nLen-1, 1)
		cBeforeLastChar = @oQString.mid(nLen-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return TRUE
		else
			return FALSE

		ok

		#< @FunctionAlternativeForms

		def HasTrailingSubStringCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)
		
		def HasTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#== adding A

		def HasATrailingSubStringCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasATrailingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasATrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def HasARepeatedTrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsARepeatedTrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsATrailingRepeatedCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsATrailingCharCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedTrailingChars()
		return This.HasRepeatedTrailingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def HasTrailingSubString()
			return This.HasRepeatedTrailingChars()

		def HasTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def HasTrailingChars()
			return This.HasRepeatedTrailingChars()

		#--

		def ContainsRepeatedTrailingChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingChars()
			return This.HasRepeatedTrailingChars()

		#== adding A

		def HasATrailingSubString()
			return This.HasRepeatedTrailingChars()

		def HasATrailingRepeatedChar()
			return This.HasRepeatedTrailingChars()

		def HasATrailingChar()
			return This.HasRepeatedTrailingChars()

		#--

		def HasARepeatedTrailingChar()
			return This.HasRepeatedTrailingChars()

		def ContainsARepeatedTrailingChar()
			return This.HasRepeatedTrailingChars()

		def ContainsATrailingRepeatedChar()
			return This.HasRepeatedTrailingChars()

		def ContainsATrailingChar()
			return This.HasRepeatedTrailingChars()

		#>

	  #------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS  # 
	#================================================#

	def FindRepeatedTrailingCharsCS(pCaseSensitive)

		nLenStr = @oQString.count()

		if nLenStr < 2
			return []
		ok

		cLastChar = @oQString.mid(nLenStr-1, 1)
		cBeforeLastChar = @oQString.mid(nLenStr-2, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return []
		ok

		n = 0
		for i = nLenStr to 1 step -1
			if StzStringQ(@oQString.mid(i-1, 1)).IsEqualToCS(cLastChar, pCaseSensitive)
				n++
			else
				exit
			ok
		next

		anResult = (nLenStr-n+1) : nLenStr
		return anResult


		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		def FindTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		def FindTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingChars()
		return This.FindRepeatedTrailingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsZ()
			return This.FindRepeatedTrailingChars()

		def FindTrailingChars()
			return This.FindRepeatedTrailingChars()

		def FindTrailingCharsZ()
			return This.FindRepeatedTrailingChars()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS AND RETURNING THEM AS SECTION  # 
	#------------------------------------------------------------------------------#

	def FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		nLenStr = @oQString.count()

		if nLenStr < 2
			return []
		ok

		cLastChar = @oQString.mid(nLenStr-1, 1)
		cBeforeLastChar = @oQString.mid(nLenStr-2, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			return []
		ok

		n = 0
		for i = nLenStr to 1 step -1
			if StzStringQ(@oQString.mid(i-1, 1)).IsEqualToCS(cLastChar, pCaseSensitive)
				n++
			else
				exit
			ok
		next

		aResult = [ (nLenStr-n+1), nLenStr ]
		return aResult


		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		def FindTrailingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		def FindTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingCharsAsSection()
		return This.FindRepeatedTrailingCharsAsSectionCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingCharsZZ()
			return This.FindRepeatedTrailingCharsAsSection()

		def FindTrailingCharsAsSection()
			return This.FindRepeatedTrailingCharsAsSection()

		def FindTrailingCharsZZ()
			return This.FindRepeatedTrailingCharsAsSection()

		#>

	  #----------------------------------#
	 #  FINDING THE TRAILING SUBSTRING  #
	#==================================#

	def FindTrailingSubStringCS(pCaseSensitive)
		aSection = This.FindTrailingCharsCSZZ(pCaseSensitive)
		if len(aSection) = 0
			return 0
		else
			return aSection[1]
		ok

		def FindTrailingSubStringCSZ(pCaseSensitive)
			return This.FindTrailingSubStringCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTrailingSubString()
		return This.FindTrailingSubStringCS(TRUE)

		def FindTrailingSubStringZ()
			return This.FindTrailingSubString()

	  #-------------------------------------------------#
	 #  FINDING THE TRAILING SUBSTRING -- ZZ/EXTENDED  #
	#-------------------------------------------------#

	def FindTrailingSubStringCSZZ(pCaseSensitive)
		aSection = This.FindTrailingCharsCSZZ(pCaseSensitive)
		if len(aSection) = 0
			return []
		else
			return aSection
		ok

		def FindTrailingSubStringAsSectionCS(pCaseSensitive)
			return This.FindTrailingSubStringCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTrailingSubStringZZ()
		return This.FindTrailingSubStringCSZZ(TRUE)

		def FindTrailingSubStringAsSection()
			return This.FindTrailingSubStringZZ()

	  #----------------------------------------------------------#
	 #  GETTING THE TRAILING SUBSTRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------#

	def TrailingSubStringCSZ(pCaseSensitive)

		cSubStr = This.TrailingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		nPos = This.FindTrailingSubStringCS(pCaseSensitive)

		aResult = [ cSubStr, nPos ]
		return aResult


		def TrailingSubStringAndItsPositionCS(pCaseSensitive)
			return This.TrailingSubStringCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TrailingSubStringZ()
		return This.TrailingSubStringCSZ(TRUE)

		def TrailingSubStringAndItsPosition()
			return This.TrailingSubStringZ()

	  #---------------------------------------------------------#
	 #  GETTING THE TRAILING SUBSTRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------#

	def TrailingSubStringCSZZ(pCaseSensitive)

		cSubStr = This.TrailingSubStringCS(pCaseSensitive)
		if cSubStr = ""
			return []
		ok

		anSection = This.FindTrailingSubStringCSZZ(pCaseSensitive)

		aResult = [ cSubStr, anSection ]
		return aResult


		def TrailingSubStringAndItsSectionCS(pCaseSensitive)
			return This.TrailingSubStringCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TrailingSubStringZZ()
		return This.TrailingSubStringCSZZ(TRUE)

		def TrailingSubStringAndItsSection()
			return This.TrailingSubStringZZ()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR POSITION  #
	#=============================================================#

	def RepeatedTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZ()
		return This.RepeatedTrailingCharsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsZ()
			return This.RepeatedTrailingCharsZ()

		#>

	  #------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR SECTION  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsCSZZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZZ()
		return This.RepeatedTrailingCharsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsZZ()
			return This.RepeatedTrailingCharsZZ()

		#>

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING CHARS   #
	#======================================#

	def RemoveRepeatedTrailingCharsCS(pCaseSensitive)

		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingCharsCSQ()
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingSubStringCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingSubStringCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#--

		def RemoveTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharsCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#== Char (without an "s")

		def RemoveRepeatedTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveRepeatedTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		def RemoveTrailingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#-- adding ANY

		def RemoveAnyRepeatedTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyRepeatedTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		def RemoveAnyTrailingRepeatedCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyTrailingRepeatedCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()
	
		def RemoveanyTrailingCharCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveAnyTrailingCharCSQ(pCaseSensitive)
				return This.RemoveRepeatedTrailingCharsCSQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def TrailingSubStringRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#--

		def TrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#==

		def RepeatedTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#--

		def AnyRepeatedTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def AnyTrailingRepeatedCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def AnyTrailingCharRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingChars()
		This.RemoveRepeatedTrailingCharsCS(TRUE)

		#< @FunctionFluentForm

		def RemoveRepeatedTrailingCharsQ()
			This.RemoveRepeatedTrailingChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveTrailingSubString()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingSubStringQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#--

		def RemoveTrailingRepeatedChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharsQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveTrailingChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharsQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		#== Char (without an "s")

		def RemoveRepeatedTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveRepeatedTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		def RemoveTrailingRepeatedChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#-- adding ANY

		def RemoveAnyRepeatedTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyRepeatedTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		def RemoveAnyTrailingRepeatedChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyTrailingRepeatedCharQ()
				return This.RemoveRepeatedTrailingCharsQ()
	
		def RemoveanyTrailingChar()
			This.RemoveRepeatedTrailingChars()

			def RemoveAnyTrailingCharQ()
				return This.RemoveRepeatedTrailingCharsQ()

		#>

	#-- @FunctionPassiveForm

	def RepeatedTrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedTrailingCharsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def TrailingSubStringRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#--

		def TrailingRepeatedCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()	

		#==

		def RepeatedTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingRepeatedCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#--

		def AnyRepeatedTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def AnyTrailingRepeatedCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def AnyTrailingCharRemoved()
			return This.RepeatedTrailingCharsRemoved()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING AND TRAILING CHARS  # 
	#============================================================#

	def FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfChars() - n + 1
		ok
		
		anResult = [ n1, n2 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingChars()
		return This.FindRepeatedLeadingAndTrailingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsZ()
			return This.FindRepeatedLeadingAndTrailingChars()

		def FindLeadingAndTrailingChars()
			return This.FindRepeatedLeadingAndTrailingChars()

		def FindLeadingAndTrailingCharsZ()
			return This.FindRepeatedLeadingAndTrailingChars()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING AND LEADING CHARS  # 
	#============================================================#

	def FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfCharsCS(pCaseSensitive) - n + 1
		ok

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok
		
		anResult = [ n2, n1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingChars()
		return This.FindRepeatedTrailingAndLeadingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsZ()
			return This.FindRepeatedTrailingAndLeadingChars()

		def FindTrailingAndLeadingChars()
			return This.FindRepeatedTrailingAndLeadingChars()

		def FindTrailingAndLeadingCharsZ()
			return This.FindRepeatedTrailingAndLeadingChars()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED LEADING AND TRAILING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok
		
		# Composing the result

		aResult = [ [ nLead1, nLead2], [ nTrail1, nTrail2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		def FindLeadingAndTrailingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingCharsAsSections()
		return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedLeadingAndTrailingCharsZZ()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		def FindLeadingAndTrailingCharsAsSections()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		def FindLeadingAndTrailingCharsZZ()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED TRAILING AND LEADING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok
		
		# Composing the result

		aResult = [ [ nTrail1, nTrail2], [ nLead1, nLead2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		def FindTrailingAndLeadingCharsAsSectionsCSZZ(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingCharsAsSections()
		return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindRepeatedTrailingAndLeadingCharsZZ()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		def FindTrailingAndLeadingCharsAsSections()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		def FindTrailingAndLeadingCharsAsSectionsZZ()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED LEADING AND TRAILING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingAndTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingAndTrailingCharsZ()
		return This.RepeatedLeadingAndTrailingCharsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsZ()
			return This.RepeatedLeadingAndTrailingCharsZ()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZ()
		return This.RepeatedTrailingAndLeadingCharsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsZ()
			return This.RepeatedTrailingAndLeadingCharsZ()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZZ()
		return This.RepeatedTrailingAndLeadingCharsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsZZ()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		#>

	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING CHARS   #
	#==================================================#

	def RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingAndTrailingCharsCSQ()
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)

		def LeadingAndTrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingAndTrailingChars()
		This.RemoveRepeatedLeadingAndTrailingCharsCS(TRUE)

		def RemoveRepeatedLeadingAndTrailingCharsQ()
			This.RemoveRepeatedLeadingAndTrailingChars()
			return This

		def RemoveLeadingAndTrailingRepeatedChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingRepeatedCharsQ()
				This.RemoveLeadingAndTrailingRepeatedChars()
				return This
	
		def RemoveLeadingAndTrailingChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingCharsQ()
				This.RemoveLeadingAndTrailingChars()
				return This
	
	def RepeatedLeadingAndrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsQ().Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

		def LeadingAndTrailingCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()
		
	  #----------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS LEADING AND TRAILING CHARS  #
	#----------------------------------------------------------#

	def HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.HasRepeatedTrailingCharsCS(pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingAndTrailingChars()
		return This.HasRepeatedLeadingAndTrailingCharsCS(TRUE)

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#--

		def ContainsRepeatedLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#>

	  #--------------------------------------------#
	 #   REMOVING A GIVEN REPEATED LEADING CHAR   #
	#============================================#

	def RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
		if This.LeadingCharCSQ(pCaseSensitive).IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedLeadingCharCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingCharCS(c, pCaseSensitive)
				return This

	#-- @FunctionPassiveForm

	def ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisLeadingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def ThisLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedLeadingChar(c)
		if This.RepeatedLeadingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedLeadingCharCS(c, TRUE)
		ok

		def RemoveThisRepeatedLeadingCharQ(c)
			This.RemoveThisRepeatedLeadingChar(c)
			return This

		def RemoveThisLeadingRepeatedChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingRepeatedCharQ(c)
				This.RemoveThisLeadingRepeatedChar(c)
				return This

		def RemoveThisLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingCharQ(c)
				This.RemoveThisLeadingChar(c)
				return This

	def ThisRepeatedLeadingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharQ(c).Content()
		return cResult

		def ThisLeadingRepeatedCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def ThisLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

	  #---------------------------------------------#
	 #   REMOVING A GIVEN REPEATED TRAILING CHAR   #
	#---------------------------------------------#

	def RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
		#< QtBased >

		nLenStr = @oQString.count()
		if nLenStr < 2
			return
		ok

		cLastChar = @oQString.mid(nLenStr-1, 1)

		if NOT StzStringQ(cLastChar).IsEqualToCS(c, pCaseSensitive)
			return
		ok

		cBeforeLastChar = @oQString.mid(nLenStr-2, 1)

		if StzStringQ(cLastChar).IsEqualToCS(cBeforeLastChar, pCaseSensitive)
			aSection = This.FindRepeatedTrailingCharsCSZZ(pCaseSensitive)
			This.RemoveSection(aSection[1], aSection[2])
		ok

		#< @FunctionAlternativeForms

		def RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingCharCS(c, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForm

	def ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		def ThisTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedTrailingChar(c)
		This.RemoveThisRepeatedTrailingCharCS(c, TRUE)

		#< @FunctionAlternativeForms

		def RemoveThisRepeatedTrailingCharQ(c)
			This.RemoveThisRepeatedTrailingChar(c)
			return This

		def RemoveThisTrailingRepeatedChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingRepeatedCharQ(c)
				This.RemoveThisTrailingRepeatedChar(c)
				return This

		def RemoveThisTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingCharQ(c)
				This.RemoveThisTrailingChar(c)
				return This

		#>

	#-- @FunctionPassiveForm

	def ThisRepeatedTrailingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharQ(c).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingRepeatedCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def ThisTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		#>

	  #--------------------------------------------------------#
	 #   REMOVING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#========================================================#

	def RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
		This.RemoveThisRepeatedLeadingCharCS(c1, pCaseSensitive)
		This.RemoveThisRepeatedTrailingCharCS(c2, pCaseSensitive)
		
		def RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			return This

		def RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndRepeatedCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
				return This

		def RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

		def TheseLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
		This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, TRUE)

		def RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
			return This

		def RemoveTheseLeadingAndRepeatedChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndRepeatedCharsQ(c1, c2)
				This.RemoveTheseLeadingAndRepeatedChars(c1, c2)
				return This

		def RemoveTheseLeadingAndTrailingChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndTrailingCharsQ(c1, c2)
				This.RemoveTheseLeadingAndTrailingChars(c1, c2)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)

		def TheseLeadingAndTrailingCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
	
	  #==========================================#
	 #   REPLACING EACH REPEATED LEADING CHAR   #
	#==========================================#

	def ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("aaaAAAH RING!").
		ReplaceEachLeadingCharCS( :With = "O", TRUE)
		--> Gives: "OOOAAAH RING!"

		StzStringQ("aaaAVAR").
		ReplaceEachLeadingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "OOOOOOH RING!"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			This.ReplaceSection(
				1, n,
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.REachepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingChar(cNewSubStr)

		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingCharQ(cNewSubStr)
				This.ReplaceEachLeadingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachLeadingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedLeadingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachLeadingCharEachReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

		def EachLeadingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

	  #----------------------------------#
	 #   REPLACING EACH TRAILING CHAR   #
	#----------------------------------#

	def ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", TRUE)
		--> Gives: "RINGaaaOOO"

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "RINGOOOOOO"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n > 0
			nStart = This.NumberOfChars() - n + 1
			This.ReplaceSection(
				nStart, This.NumberOfChars(),
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedTrailingChar(cNewSubStr)

		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedTrailingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingCharQ(cNewSubStr)
				This.ReplaceEachTrailingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachTrailingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedTrailingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

		def EachTrailingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

	  #-----------------------------------------------#
	 #   REPLACING EACH LEADING AND TRAILING CHARS   #
	#-----------------------------------------------#

	def ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		#-- Char withous "s"

		def ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingandTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChars(cNewSubStr)
				return This

		#-- Char without "s"

		def ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChar(cNewSubStr)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingOrLeadingChar(cNewSubStr)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		return This.ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplace(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplace(cNewSubStr)

		def EachLeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharsReplaced()
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#>

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceFirstNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, TRUE)

		def ReplaceRepeatedLeadingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)
			return This

		def ReplaceLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)

			def ReplaceLeadingCharsQ(cNewSubStr)
				This.ReplaceLeadingChars(cNewSubStr)
				return This

	def RepeatedLeadingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedLeadingCharsQ(cNewSubStr).Content()

		def LeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingCharReplaced(wNewSubStr)

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceLastNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedTrailingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, TRUE)

		def ReplaceRepeatedTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)
			return This

		def ReplaceTrailingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)

			def ReplaceTrailingCharsQ(cNewSubStr)
				This.ReplaceTrailingChars(cNewSubStr)
				return This

	def RepeatedTrailingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedTrailingCharsQ(cNewSubStr).Content()

		def TrailingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingCharReplaced(wNewSubStr)

	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------#
	
	def ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingChars(cNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingRepeatedCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingRepeatedCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

	  #---------------------------------------------#
	 #   REPLACING A GIVEN REPEATED LEADING CHAR   #
	#---------------------------------------------#

	def ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if NOT This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return
		ok

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfLeadingChars()
			This.ReplaceFirstNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisLeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingChar(c, cNewSubStr)
				return This

		def ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceRepeatedLeadingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingCharQ(c, cNewSubStr)
				This.ReplaceLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceLeadingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedLeadingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def ThisLeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#>

	  #----------------------------------------------#
	 #   REPLACING A GIVEN REPEATED TRAILING CHAR   #
	#----------------------------------------------#

	def ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfTrailingChars()
			This.ReplaceLastNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisTrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingChar(c, cNewSubStr)
				return This

		def ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceRepeatedTrailingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingCharQ(c, cNewSubStr)
				This.ReplaceTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceTrailingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedTrailingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def ThisTrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#>

	  #---------------------------------------------------------#
	 #   REPLACING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------------#

	def ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
	
		This.ReplaceThisRepeatedLeadingCharCS(c1, cNewSubStr, pCaseSensitive)
		This.ReplaceThisRepeatedTrailingCharCS(c2, cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
			This.ReplaceTheseRepeatedTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

				These.ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This
		
		#>

	def TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

		These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

				These.ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
				return This

		#>

	def TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		#>

	  #===============================#
	 #     FORWARD TO END OF LINE    #
        #===============================#

	def ForwardToEndOfLine(nStart)

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		bInside = TRUE
		cResult = ""
		i = nStart - 1

		while bInside
			i++
						 
			if i = This.NumberOfChars() or
			   This.CharAtQ(i).IsLineSeparator()
			   
				bInside = FALSE

			else
				cResult += This.NthChar(i)
			ok	
		end

		return cResult

		#< @FunctionFluentForm
	
		def ForwardToEndOfLineQ(nStart)
			return new stzString( This.ForwardToEndOfLine(nStart) )
	
		#>

	  #----------------------------------#
	 #     BACKWARD TO START OF LINE    #
        #----------------------------------#

	def BackwardToStartOfLine( nStart )

		/* Example:
	
			o1 = new stzString( "Mohammed Ali
				Ben Salah" )
			? o1.BackwardToStartOfLine( :StartingAt = 16 ) #--> Ben
			
		*/

		# Enabling the :StartingAt syntax

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		# Checking the range of possible values for nStart param

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		# Computing the rest of the line

		bInside = TRUE
		cResult = ""
		i = nStart + 1

		while bInside
			i--
					 
			if i = 0 or This.CharAtQ(i).IsLineSeparator()

				bInside = FALSE
			
			else
				cResult += This.NthChar(i)
			ok
				
		end

		return StringReverse(cResult)

		#< @FunctionFluentForm

		def BackwardToStartOfLineQ( nStart )
			return new stzString( This.BackToStartOfLine( nStart ) )
	
		#>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~ LASTMILE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


	  #============================================================================#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#============================================================================#

	def ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		if len(anPos) > 0
			return TRUE
		else
			return FALSE
		ok

		def ContainsBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.ContainsSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		def ContainsBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.ContainsSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BETWEEN TWO GIVEN POSITIONS  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		anPos = This.FindSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		if len(anPos) > 0
			return TRUE
		else
			return FALSE
		ok

		def ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBetweenPositions(pcSubStr, n1, n2)
		return This.ContainsSubStringBetweenPositionsCS(pcSubStr, n1, n2, TRUE)

		def ContainsBetweenPositions(pcSubStr, n1, n2)
			return This.ContainsSubStringBetweenPositions(pcSubStr, n1, n2)

	  #-----------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#===================================================================================#

	def NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nResult = len(This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive))
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyOccurrencesOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyTimeSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowManyTimesSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def HowOftenSubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)
		return This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyOccurrencesOfSubStringBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyTimeSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowManyTimesSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		def HowOftenSubStringIsBoundedBy(pcSubStr, pacBounds)
			return This.NumberOfOccurrenceOfSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	  #-------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------------#

	def ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		# Checking params

		if CheckParams()
			if isList(pacBounds) and len(pacBounds) = 2 and
			   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and pacBounds[2][1] = :And
				aTemp = []
				aTemp + pacBounds[1] + pacBounds[2][2]
				pacBounds = aTemp
			ok
				
			if NOT (isString(pacBounds) or (isList(pacBounds) and Q(pacBounds).IsPairOfStrings()) )
				StzRaise("Incorrect params types! pacBounds must be a string or pair of strings.")
			ok
		ok

		# Doing the job

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		aSections = This.FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

		nLen = len(aSections)
		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		# Looping over the sections and checking wether their bounds
		# correspond to cBound1 and cBound2

		bResult = FALSE

		cBound1 = cBound1
		cBound2 = cBound2

		if IsCaseSensitive(pCaseSensitive)
			cBound1 = Q(cBound1).Lowercased()
			cBound2 = Q(cBound2).Lowercased()
		ok

		for i = 1 to nLen
			
			acBounds = This.SectionBounds(aSections[i][1], aSections[i][2], nLenBound1, nLenBound2)

			if acBounds[1] = cBound1 and acBounds[2] = cBound2

				bResult = TRUE
				exit

			ok

		next

		return bResult

		#< @FunctionAlternativeForm

		def ContainsThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringBoundedBy(pcSubStr, pacBounds)
		return This.ContainsSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def ContainsThisSubStringBoundedBy(pcSubStr, pacBounds)
			return This.ContainsSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	   #--------------------------------------------------------------#
	  #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO  #
	 #  OTHER SUBSTRINGS STARTING AT A GIVEN POSITION               #
	#--------------------------------------------------------------#

	def ContainsSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = This.NumberOfChars()
		bResult = This.SectionQ(pnStartingAt, nLen).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		return bResult

		def ContainsSubStringBoundedBySartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.ContainsSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

		def ContainsSubStringBoundedBySartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

	   #-------------------------------------------------------------------------#
	  #  CHECKING IF THE STRING CONTAINS A SUBSTRING BOUNDED BY TWO OTHER       #
	 #  SUBSTRINGS STARTING AT A GIVEN POSITION -- GOiNG IN A GIVEN DIRECTION  #
	#-------------------------------------------------------------------------#

	def ContainsSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = This.NumberOfChars()
		cDirection = @Direction(pcDirection)

		if cDirection = :Forward
			bResult = This.SectionQ(pnStartingAt, nLen).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		else
			bResult = This.SectionQ(1, pnStartingAt).ContainsSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		ok

		return bResult


		def ContainsSubStringBoundedByStartingAtDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.ContainsSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringBoundedBySD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.ContainsSubStringBoundedBySDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)


		def ContainsSubStringBoundedByStartingAtD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.ContainsSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

	  #---------------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=================================================================================#

	def NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nResult = len( This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceOfSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceOfSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		def NumberOfOccurrencesOfSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
			return This.NumberOfOccurrenceBetween(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	   #---------------------------------------------------------------#
	  #  GETTING THE NUMBER OF OCCURRENCES OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION            #
	#---------------------------------------------------------------#

	def NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nResult = len( This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrenceBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedBySTCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#==

		def NumberOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByStartingAtCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringBoundedByStartingAtCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.NumberOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringBoundedByS(pcSubStr, pacBounds, pnStartingAt)
		return This.NumberOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

		def NumberOfOccurrenceBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByST(pcSubStr,pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrencesOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#==

		def NumberOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrenceOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
	
		#-- Occurrences (with s)
	
		def NumberOfOccurrencesBoundedByStartingAt(pcSubStr,pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def NumberOfOccurrencesOfSubStringBoundedByStartingAt(pcSubStr, pacBounds, pnStartingAt)
			return This.NumberOfSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#=======================================================================================#

	def ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		bResult = ( This.NumberOfOccurrenceBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive) = n )

		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def ContainsNOccurrenceBetweenCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def ContainsNOccurrencesBetweenCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)
		return This.ContainsNOccurrencesOfSubStringBetweenCS(n, pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		def ContainsNOccurrenceBetween(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		def ContainsNOccurrencesBetween(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringBetween(n, pcSubStr, pcSubStr1, pcSubStr2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#------------------------------------------------------------------------------------------#

	def ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
		bResult = ( This.NumberOfOccurrenceboundedByCS(pcSubStr, pacBounds, pCaseSensitive) = n )
		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsNOccurrenceBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsNOccurrencesBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrenceOfSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrenceBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		def ContainsExactlyNOccurrencesBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringboundedBy(n, pcSubstr, pacBounds)
		return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsNOccurrenceBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedByCS(n, pcSubStr, pacBounds)

		def ContainsNOccurrencesBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrenceOfSubStringBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrenceBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		def ContainsExactlyNOccurrencesBoundedBy(n, pcSubStr, pacBounds)
			return This.ContainsNOccurrencesOfSubStringboundedBy(n, pcSubStr, pacBounds)

		#>

	  #----------------------------------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------------------------------------------------------#

	def ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		bResult = ( This.NumberOfOccurrenceboundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive) = n )
		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsNOccurrenceBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsNOccurrencesBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrenceOfSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrenceBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def ContainsExactlyNOccurrencesBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrencesOfSubStringboundedByST(n, pcSubstr, pacBounds, pnStartingAt)
		return This.ContainsNOccurrencesOfSubStringboundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def ContainsNOccurrenceOfSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsNOccurrenceBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedBySCST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsNOccurrencesBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def ContainsExactlyNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrenceOfSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrenceBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		def ContainsExactlyNOccurrencesBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.ContainsNOccurrencesOfSubStringboundedByST(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #========================================================#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST  #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING       #
	#========================================================#

	def FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		/* EXAMPLE 1:

		#                            +--.------------.--------+
		#                            |  13           26       |
		#                            V  |            |        V
		o1 = new stzString("bla bla [[  word bla bla word bla ]] no word bla")
		? o1.FindSubStringBetweenCS("word", "[[", "]]", :CaseSensitive = FALSE)
		#--> [ 13, 26 ]

		EXAMPLE 2:

		#                            +--.--------..-----.--------+
		#                            |  13       xx     29       |
		#                            V  |        !!     |        V
		o1 = new stzString("bla bla [[  word bla [[ bla word bla ]] no word bla")
		? o1.FindSubStringBetweenCS("word", "[[", "]]", :CaseSensitive = FALSE)
		#--> [ 13, 29 ]

		EXAMPLE 3:

		#                     |4|               
		o1 = new stzString("12*A*67*A*")
		? o1.FindSubStringBetween("A", "*", "*")
		#--> [4]


		EXAMPLE 4:

		#TODO add an example using positions FindSubStringBetween("ring", 5, 30)
		
		*/

		# Doing the job

		if CheckParams()
			if isList(pcSubStr1) and
				( StzListQ(pcSubStr1).IsPositionOrPositionsNamedParam() or
				StzListQ(pcSubStr1).IsSubStringOrSubStringsNamedParam() )

				pcSubStr1 = pcSubStr1[2]
			ok

			if isList(pcSubStr2) and
				StzListQ(pcSubStr2).IsAndOrAndPositionOrAndSubStringNamedParam()

				pcSubStr2 = pcSubStr2[2]
			ok

			if NOT ( @AreBothStrings(pcSubStr1, pcSubStr2) or
				 @AreBothNumbers(pcSubStr1, pcSubStr2) )

				StzRaise("Incorrect param type! pcSubStr1, pcSubStr2 must be both strings or numbers.")
			ok
		ok

		n1 = pcSubStr1
		n2 = pcSubStr2

		if @BothAreStrings(pcSubStr1, pcSubStr2)

			n1 = This.FindFirstCS(pcSubStr1, pCaseSensitive)

			if n1 = 0
				return []
			ok

			n1 += StzStringQ(pcSubStr1).NumberOfChars()

			#--

			n2 = This.FindLastCS(pcSubStr2, pCaseSensitive)

			if n2 = 0
				return []
			ok

			n2--

		else // @bothAreNumbers()

			if n1 = 0 or n2 = 0
				return []
			ok

			n1 += 1
			n2 -= 1
		ok

		anResult = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetween(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#--

		def FindBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#>

	   #----------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST    #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING -- IB   #
	#----------------------------------------------------------#

	def FindSubStringBetweenCSIB(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr1 = StzSubStringQ(pcSubStr1).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + (anPos[i] - nLenSubStr1)
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenCSIBZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBetweenCSIBZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenIB(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSIB(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenIBZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		#--

		def FindBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		def FindBetweenIBZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)

		#>

	   #------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN    #
	 #  SUBSTRING AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING  #
	#==============================================================================#

	def BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		if CheckParams()
			if isList(pSubStrOrPos2) and Q(pSubStrOrPos2).IsAndNamedParam()
				pSubStrOrPos2 = pSubStrOrPos2[2]
			ok
		ok

		if NOT ( @BothAreStrings(pSubStrOrPos1, pSubStrOrPos2) or @BothAreNumbers(pSubStrOrPos1, pSubStrOrPos2) )
			StzRaise("Incorrect params types! pSubStrOrPos1 and pSubStrOrPos2 must be both strings or numbers.")
		ok

		if @BothAreStrings(pSubStrOrPos1, pSubStrOrPos2)

			n1 = This.FindFirstOccurrenceCS(pSubStrOrPos1, pCaseSensitive)

			if n1 = 0
				return ""
			else
				n1 += StzStringQ(pSubStrOrPos1).NumberOfChars()
			ok


			n2 = This.FindLastOccurrenceCS(pSubStrOrPos2, pCaseSensitive)

			if n2 = 0
				return ""
			else
				n2--
			ok

		else // @BothAreNumber

			n1 = pSubStrOrPos1
			n1++

			n2 = pSubStrOrPos2
			n2--
		ok

		cResult = This.Section(n1, n2)
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def Between(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, TRUE)

		#< @FunctionAlternativeForm

		def SubStringBetween(pSubStrOrPos1, pSubStrOrPos2)
			return This.Between(pSubStrOrPos1, pSubStrOrPos2)

		#>

	   #--------------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	 #  AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- IB/EXTENDED     #
	#======================================================================================#

	def BetweenCSIB(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		aSection = This.FindBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		cResult = This.Section(aSection)

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIB(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSIB(pSubStrOrPos1, pSubStrOrPos2, TRUE)

	   #-----------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING BETWEEN THE FIRST     #
	 #  AND LAST OCCURRENCE OF AN OTHER giVEN SUBSTRING -- IBZZ  #
	#-----------------------------------------------------------#

	def FindSubStringBetweenCSIBZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(aSection)
		nLen1 = StzStringQ(pcSubStr1).NumberOfChars()
		nLen2 = StzStringQ(pcSubStr2).NumberOfChars()
		aResult = []

		for i = 1 to nLen
			aResult + [ aSection[i][1] - nLen1, aSection[i][2] + nLen2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubStringBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenIBZZ(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSIBZZ(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForms

		def FindBetweenIBZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubStringBetweenIBZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN         #
	 #  SUBSTRING AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- ZZ #
	#===================================================================================#

	def BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		cSubStr = This.BetweenCS(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		aResult = [ cSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForm

		def SubStringBetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def BetweenZZ(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSZZ(pSubStrOrPos1, pSubStrOrPos2, TRUE)

		#< @FunctionAlternativeForm

		def SubStringBetweenZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenZZ(pSubStrOrPos1, pSubStrOrPos2)

		#>

	   #--------------------------------------------------------------------------------------#
	  #  GETTING THE SUBSTRING BETWEEN THE END OF THE FIRST OCCURRENCE OF A GIVEN SUBSTRING  #
	 #  AND THE START OF THE LAST OCCURRENCE OF AN OTHER GIVEN SUBSTRING -- IBZZ/EXTENDED   #
	#======================================================================================#

	def BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		cSubStr = This.BetweenCSIB(SubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
		aSection = This.FindSubStringBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		aResult = [ cSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForms

		def AnyBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		def SubStringBetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)
			return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
		return This.BetweenCSIBZZ(pSubStrOrPos1, pSubStrOrPos2, TRUE)

		#< @FunctionAlternativeForms

		def AnyBetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)

		def SubStringBetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)
			return This.BetweenIBZZ(pSubStrOrPos1, pSubStrOrPos2)

		#>

	  #======================================================================#
	 #  FINDING OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#======================================================================#

	def FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
? @@(pcSubStr)
		# Checking params

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pacBounds) and len(pacBounds) = 2 and
			   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and pacBounds[2][1] = :And
				aTemp = []
				aTemp + pacBounds[1] + pacBounds[2][2]
				pacBounds = aTemp
			ok

			if NOT ( isString(pacBounds) or (isList(pacBounds) and Q(pacBounds).IsPairOfStrings()) )
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		ok

		# Doing the job

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfSrrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()

		anPos = This.FindAllCS( cBound1 + pcSubStr + cBound2, pCaseSensitive )

		anResult = []

		if len(anPos) > 0
			anResult = QR(anPos, :stzListOfNumbers).AddedToEach(nLenBound1)
		ok

		return anResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)
	
		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubstringBoundedBy(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindSubStringBoundedBy(pcSubStr, pacBound)
	
		#>

	  #------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#==================================================================#

	def FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		anPos = This.FindSubStringBetweenCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		nLenStr = Q(pcSubStr).NumberOfChars()
		nLenPos = len(anPos)

		aResult = []

		for i = 1 to nLenPos
			aResult + [ anPos[i], anPos[i] + nLenStr - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#--

		def FindBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		def FindBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)
		return This.FindSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		#--

		def FindBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		def FindBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)
			return This.FindSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#---------------------------------------------------------------------#

	def FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		anPos = This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLenStr = Q(pcSubStr).NumberOfChars()
		nLenPos = len(anPos)

		aResult = []

		for i = 1 to nLenPos
			aResult + [ anPos[i], anPos[i] + nLenStr - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		anPos = This.FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(anPos)

		nLenBound1 = 0

		if isString(pacBounds)
			nLenBound1 = Q(pacBounds).NumberOfChars()
		else
			nLenBound1 = Q(pacBounds[1]).NumberOfChars()
		ok

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] - nLenBound1)
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindSubStringBoundedByCSIB(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByIB(pcSubStr, pacBounds)
	
		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS #
	#-------------------------------------------------------------------------------------#

	def FindSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(aSections)

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2]  + nLenBound2
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm
	
		def FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindSubStringBouondedByCSIBZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBooundedByAsSectionsIB(pcSubStr, pacBounds)
			return This.FindSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------------------#

	def FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nLast = This.NumberOfChars()
		anPos = This.SectionQ(pnStartingAt, nLast).FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLen = len(anPos)

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] + pnStartingAt - 1 )
		next

		return anResult

		#< @FunctionalternativeForms
	
		def FindSubStringBoundedBySCSTZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySCST(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#==================================================================================================#

	def FindSubStringBoundedBySCSTZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		anPos = This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(anPos)
		nLenStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByAsSectionsSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounded, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBoundedByAsSectionsST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BOUNDED BY TWO OTHER SUBSTRING STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------------------#

	def FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		anPos = This.FindSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(anPos)
		nLenStr = Q(pcSubStr).NumberOfChars()

		nLenBound1 = 0
		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()
		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
		ok

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] - nLenBound1 )
		next

		return anResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------------------------#
	 #  FINDING A SUBSTRING (AS SECTIONS) BOUNDED BY TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION INCLUDING BOUNDS  #
	#===================================================================================================================#

	def FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		aSections = This.FindSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLen = len(aSections)

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else // Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = Q(cBound1).NumberOfChars()
		nLenBound2 = Q(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2] + nLenBound2
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByAsSectionsSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms
	
		def FindSubStringBoundedByAsSectionsSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=====================================================================================================#

	def FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		nLast = This.NumberOfChars()
		oSection = This.SectionQ(pnStartingAt, nLast)

		cBound1 = ""
		cBound2 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds
		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		cBounded = cBound1 + pcSubStr + cBound2
		nLenBounded = Q(cBounded).NumberOfChars()
		nStart = pnStartingAt
		bContinue = TRUE
		nTimes = 0

		nResult = 0

		while bContinue

			nPos = oSection.FindNextSCS(cBounded, nStart, pCaseSensitive)

			if nPos != 0

				nTimes++

				if nTimes = n
					nResult = nPos + nLenBounded
					bContinue = FALSE

				else
					nStart = nPos + nLenBounded
				ok

			else
				bContinue = FALSE
			ok
		end

		if nResult > 0
			nResult -= StzStringQ(cBound1).NumberOfChars()
		ok

		return nResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#--------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(1, pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBetweenAsSectionsCS(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#--

		def FindNextBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenAsSectionsCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#==

		def FindNextSubStringBetweenSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBetweenAsSectionsSTCS(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		def FindNextBetweenAsSectionsSTCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBetweenZZ(pcSubStr,pcSubStr1, pcSubStr2, pnStartingAt)
		return This.FindNextSubStringBetweenCSZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextSubStringBetweenAsSections(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#--

		def FindNextBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenAsSectionsZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#==

		def FindNextSubStringBetweenSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextSubStringBetweenAsSectionsST(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		def FindNextBetweenAsSectionsSTZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)
			return This.FindNextSubStringBetweenZZ(pcSubStr, pcSubStr1, pcSubStr2, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=================================================================================================#

	def FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedByCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySCSTZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedByZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=========================================================================================================#

	def FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		nLast = This.NumberOfChars()
		oSection = This.SectionQ(1, pnStartingAt)

		cBound1 = ""
		cBound2 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds
		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		cBounded = cBound1 + pcSubStr + cBound2
		nLenBound1= Q(cBound1).NumberOfChars()

		nStart = pnStartingAt
		bContinue = TRUE
		nTimes = 0

		nResult = 0

		while bContinue

			nPos = oSection.FindPreviousSCS(cBounded, nStart, pCaseSensitive)

			if nPos != 0

				nTimes++

				if nTimes = n
					nResult = nPos + nLenBound1
					bContinue = FALSE

				else
					nStart = nPos
				ok

			else
				bContinue = FALSE
			ok
		end

		return nResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousNthSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-------------------------------------------------------------------------------------------------------------------------#

	def FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=====================================================================================================#

	def FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nResult = This.FindPreviousNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedBy(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedBy(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindPreviousSubStringBoundedByCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		anResult = This.FindPreviousNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForm

		def FindPreviousSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByZZ(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSZZ(pcSubStr, pcBound1, pcBound2, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindPreviousSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#==========================================================================================================================#

	def FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nResult = this.FindNextNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedByZIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNextNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByZIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #------------------------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION AND INCLUDING BOUNDS -- ZZ/EXTENSION  #
	#------------------------------------------------------------------------------------------------------------------------------------------#

	def FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindNextNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthNextSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNextNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthNextSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=================================================================================================#

	def FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNextSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByIB(1, pcSubStr, pacBounds, pnStartingAt)

		#< @FunctionAlternativeForms

		def FindNextSubStringBoundedByZIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextNthSubStringBoundedByIB(1, pcSubStr, pacBounds, pnStartingAt)

		def FindNextSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------------------------------------#
	 #  FINDING NEXT OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------------------------------------#

	def FindNextSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNextNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNextSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNextNthSubStringBoundedByIBZZ(1, pcSubStr, pacBounds, pnStartingAt)

		#< @FunctionAlternativeFroms

		def FindNextSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindNextSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION  #
	#=========================================================================================================#

	def FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nResult = This.FindPreviousNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedByIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIB(n, pcSubStr, pacBounds, pnStartingAt)


		#>

	  #-------------------------------------------------------------------------------------------------------------------------#
	 #  FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS STARTING AT A GIVEN POSITION -- ZZ/EXTENSION  #
	#-------------------------------------------------------------------------------------------------------------------------#

	def FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		nPos = This.FindPreviousNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenStr-1 ]

		return anResult


		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthPreviousSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNthPreviousSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthPreviousSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	  #------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  STARTING AT A GIVEN POSITION  #
	#======================================================================================================#

	def FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindPreviousNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindPreviousSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindPreviousSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSIB(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedByZIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindPreviousSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		def FindPreviousSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------------------------------------------------------------------#
	 #  FINDING PREVIOUS OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  STARTING AT A GIVEN POSITION -- ZZ/EXTENDED  #
	#---------------------------------------------------------------------------------------------------------------------#

	def FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindPreviousNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindPreviousSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindPreviousSubStringBoundedByIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	  #================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#================================================================#

	def FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if CheckParams()
			if NOT ( ( isString(pcBound1) or isNumber(pcBound1) ) and
				 ( isString(pcBound2) or isNumber(pcBound2) ) )

				StzRaise("Incorrect params types! pcBound1 and pcBound2 must be strings or numbers.")
			ok
		ok

		n1 = 0
		n2 = 0

		if isString(pcBound1)
			n1 = This.FindFirstCS(pcBound1, pCaseSensitive)

		else // isNumber()
			n1 = pcBound1
		ok

		if isString(pcBound2)
			n2 = This.FindLastCS(pcBound2, pCaseSensitive)

		else // isNumber()
			n2 = pcBound2
		ok

		nResult = This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm
	
		def FindNthSubStringBetweenCSZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindNthBetweenCSZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForm
	
		def FindNthSubStringBetweenZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		#--

		def FindNthBetween(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		def FindNthBetweenZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#-------------------------------------------------------------------#

	def FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isString(pacBounds) or ( isList(pacBounds) and @IsPairOfStrings(pacBounds) ) )
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		# Getting the bounds in two separate strings

		cBound1 = ""
		cBound2 = ""

		if isList(pacBounds)
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else // isString()
			cBound1 = pacBounds
			cBound1 = pacBounds
		ok

		# Getting the bounded substring

		cBounded = cBound1 + pcSubStr + cBound2

		# Doing the job

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nResult = This.FindNthCS(n, cBounded, pCaseSensitive) + nLenBound1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByCSZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindNthBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBound, pCaseSensitives)

		def FindNthBoundedByCSZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBound, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBy(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBound)

		#--

		def FindNthBoundedBy(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBound)

		def FindNthBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedBy(n, pcSubStr, pacBound)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING ANY NTH SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------#

	def FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		nResult = 0
		anPos = This.FindTheseBoundsCS(pacBounds, pCaseSensitive)

		if n <= len(anPos)
			cBound1 = @Bounds(pacBounds)[1]
			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nResult = anPos[n] + nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindAnyNthSubBoundedByCS(n, pacBounds, pCaseSensitive)
			return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)

		def FindAnyNthBoundedByCSZ(n, pacBounds, pCaseSensitive)
			return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyNthSubStringBoundedBy(n, pacBounds)
		return This.FindAnyNthSubStringBoundedByCS(n, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindAnyNthBoundedBy(n, pacBounds)
			return This.FindAnyNthSubStringBoundedBy(n, pacBounds)

		def FindAnyNthBoundedByZ(n, pacBounds)
			return This.FindAnyNthSubStringBoundedBy(n, pacBounds)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#=====================================================================#

	def FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
	
		#--

		def FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindFirstBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
	
		#--

		def FindFirstBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindFirstBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#---------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCS(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindFirstBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBy(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBound)

		#--

		def FindFirstBoundedBy(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBounds)

		def FindFirstBoundedByZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedBy(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BETWEEN TWO SUBSTRINGS  #
	#=================================================================#

	#TODO: check performance!

	def FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCS(nLast, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
	
		#--

		def FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindLastBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
	
		#--

		def FindLastBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)

		def FindLastBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2s)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO SUBSTRINGS  #
	#--------------------------------------------------------------------#

	def FindLastSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCS(nLast, pcSubStr, pacBounds, pCaseSensitive)


		#< @FunctionAlternativeForm

		def FindLastSubStringBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCS(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindLastBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByCSZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBoundedBy(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSubStringBoundedByZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(pcSubStr, pacBound)

		#--

		def FindLastBoundedBy(n, pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(n, pcSubStr, pacBounds)

		def FindLastBoundedByZ(n, pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedBy(n, pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------#
	  #   FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO   #
	 #   OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS     #
	#=======================================================#

	def FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nPos = This.FindNthSubStringBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = [ nPos, nPos + nLenSubStr - 1 ]

		return aResult

		#< @FunctionAlternativeForms
	
		def FindNthSubStringBetweenAsSectionCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindNthBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthSubStringBetweenCSZZ(n, pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForms
	
		def FindNthSubStringBetweenAsSection(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		#--

		def FindNthBetweenZZ(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		def FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthSubStringBetweenZZ(n, pcSubStr, pcBound1, pcBound2)

		#>

	   #--------------------------------------------------------#
	  #   FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY     #
	 #   TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#=======================================================#

	def FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)
		if nPos = 0
			return []
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ nPos, nPos + nLenSubstr - 1 ]

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindNthBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		def FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		#--

		def FindNthBoundedByZZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		def FindNthBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByZZ(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)

		nResult = this.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if nResult > 0

			nLenBound1 = 0

			if isString(pacBounds)
				nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

			else
				nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			ok

			nResult -= nLenBound1
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindNthBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#--

	def FindNthSubStringBoundedByIB(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIB(n, pcSubStr, pacBound)

		#--

		def FindNthBoundedByIBZ(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIBZ(n, pcSubStr, pacBounds)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER             #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
		if nPos = 0
			return []
		ok

		cBound1 = ""
		cBound2 = ""

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		n1 = nPos
		n2 = nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1
		aResult = [ n1, n2 ]

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindNthBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		def FindNthBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds)
		return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsIB(n, pcSubStr, pacBounds)
			return This.FindNthSubStringBoundedByIBZZ(n, pcSubStr, pacBounds)

		#>

	   #----------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  OTHER SUBSTRINGS STARTING AT A GIVEN POSITION     #
	#====================================================#

	def FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok
		ok

		nPos = This.SectionQ(pnStartingAt, This.NumberOfChars()).
			FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		if nPos = 0
			return 0
		ok

		nResult = nPos + pnStartingAt - 1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSIVITY

	def FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedByS(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS       #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos = 0
			return []
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedByAsSectionSTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByAsSectionST(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #---------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS  #
	#===============================================================#

	def FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		cBound1 = ""

		if isString(pacBounds)
			cBound1 = pacBounds

		else
			cBound1 = pacBounds[1]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		nResult = nPos - nLenBound1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTIBZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIB(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS   #
	#===================================================================================#

	def FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		aResult = []
		nPos = This.FindNthSubStringBoundedBySTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		if nPos > 0

			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
			aResult = [ nPos, nPos + nLenSubStr - 1 ]

		ok

		return aResult


		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindNthBoundedByAsSectionSTCSIB(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindNthBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionsSTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindNthBoundedByAsSectionSTIB(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		def FindNthBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)
			return This.FindNthSubStringBoundedBySTIBZZ(n, pcSubStr, pacBounds, pnStartingAt)

		#>

	#NOTE
	# ...Between...() functions are not DIRECTION-aware and thus can not have an D() extension
	# Also, the same functions can't have an ST() ewtension for :StartingAt

	   #----------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION   #
	#----------------------------------------------------#

	def FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		
		cDirection = @Direction(pcDirection)

		if cDirection = "forward"
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, pacBounds, pCaseSensitive)

		but cDirection = "backward"
			nLen = This.NumberOfChars()
			return This.FindNthPreviousSubStringBoundedBySCS(n, pcSubStr, pacBounds, nLen, pCaseSensitive)

		else
			StzRaise("Incorrect param! pcDirection must be a string containg :Forward or :Backward.")

		ok

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDCSZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByDCSZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByDZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByD(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS          #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		anResult = [ nPos, (nPos + nLenSubStr - 1) ]

		return anResult


		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDCSZZ(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByAsSectionD(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDZZ(n, pcSubStr, pacBounds, pcDirection)

		#>
	
	   #--------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedByDCS(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nLenBound1 = 0
		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()

		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		nResult = nPos - nLenBound1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDCSIBZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByDCSIBZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByDIBZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByDIBZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindNthSubStringBoundedByDIB(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING  #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   # 
	#-------------------------------------------------------------------------------#

	def FindNthSubStringBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nPos = This.FindNthSubStringBoundedByDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		nLenBound1 = 0
		nLenBound2 = 0

		if isString(pacBounds)
			nLenBound1 = StzStringQ(pacBounds).NumberOfChars()
			nLenBound2 = nLenBound1
		else
			nLenBound1 = StzStringQ(pacBounds[1]).NumberOfChars()
			nLenBound2 = StzStringQ(pacBounds[2]).NumberOfChars()
		ok

		anResult = [ nPos, (nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1) ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionDCSIB(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIBZZ(n, pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		#--

		def FindNthBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		def FindNthBoundedByAsSectionDIB(n, pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(n, pcSubStr, pacBounds, pcDirection)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION            #
	#-------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		cDirection = @Direction(pcDirection)

		if cDirection = :Forward
			return This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		else // :Backward
			return This.FindNthPreviousSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		ok

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDCSZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedBySTDCSZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedBySTDZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING       #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionSTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedByAsSectionSTD(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-----------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING  #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS            #
	#-----------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCS(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		cBound1 = ""
		if isString(pacBounds)
			cBound1 = pacBounds
		else
			cBound1 = pacBounds[1]
		ok

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		nResult = nPos - nLenBound1
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedBySTDCSIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedBySTDIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindNthBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedBySTDIBZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-----------------------------------------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN   #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS  #
	#-----------------------------------------------------------------------------------------------#

	def FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindNthSubStringBoundedBySTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		anResult = [ nPos, nPos + nLenSubStr - 1 ]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthBoundedByAsSectionSTDCSIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindNthSubStringBoundedBySTDCSIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBoundedByAsSectionSTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindNthBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindNthBoundedByAsSectionSTDIB(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindNthSubStringBoundedBySTDIBZZ(n, pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BETWEEN TWO  #
	 #  OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS      #
	#=======================================================#

	def FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm
	
		def FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindFirstBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindFirstBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForm
	
		def FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#--

		def FindFirstBetweenZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		def FindFirstBetweenAsSections(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY   #
	 #  TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#-------------------------------------------------------#

	def FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSZZ(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindFirstBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedByZZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		def FindFirstBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIB(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindFirstBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		def FindFirstBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSIB(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBound)

		#--

		def FindFirstBoundedByIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBound)

		def FindFirstBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIB(pcSubStr, pacBound)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER           #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIBZZ(1, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindFirstBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindFirstSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#--

		def FindFirstBoundedByIBZZ(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		def FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	   #------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCS(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS         #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)
	
		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedByAsSectionsST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS   #
	#----------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIB(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindFirstSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS     #
	#-------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindFirstBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindNthSubStringBoundedBySTCSIBZZ(1, pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindFirstBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySIBZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindFirstBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindFirstSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION     #
	#------------------------------------------------------#

	def FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCS(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS            #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSZZ(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER  #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS    #
	#----------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIB(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)
		return This.FindFirstSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindFirstSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING  #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS     # 
	#---------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIBZZ(1, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindNthSubStringBoundedByDCSIBZZ(1, pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindFirstBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		def FindFirstBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION              #
	#---------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCS(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING     #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSZZ(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @functionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @functionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING  #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS              #
	#-------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSIB(1, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN  #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   #
	#------------------------------------------------------------------------------------------------#

	def FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nPos = This.FindFirstSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		if nPos = 0
			return []
		else
			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

			if isString(pacBounds)
				cBound1 = pacBounds
				cBound2 = pacBounds
			else
				cBound1 = pacBounds[1]
				cBound2 = pacBounds[2]
			ok

			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nLenBound2 = StzStringQ(cBound2).NumberOfChars()

			anResult = [ nPos, nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1 ]
			return anResult
		ok

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindFirstBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindFirstSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindFirstBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindFirstBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindFirstSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BETWEEN TWO  #
	 #  OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS     #
	#======================================================#

	def FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLast = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindNthSubStringBetweenCSZZ(nLast, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#< @FunctionAlternativeForm
	
		def FindLastSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#--

		def FindLastBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)
		return This.FindLastSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, TRUE)

		#< @FunctionAlternativeForm
	
		def FindLastSubStringBetweenAsSection(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#--

		def FindLastBetweenZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		def FindLastBetweenAsSection(pcSubStr, pcBound1, pcBound2)
			return This.FindLastSubStringBetweenZZ(pcSubStr, pcBound1, pcBound2)

		#>

	   #-------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY    #
	 #  TWO OTHER SUBSTRINGS AND RETURNING THEM AS SECTIONS  #
	#-------------------------------------------------------#

	def FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindLastBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		#--

		def FindLastBoundedByZZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		def FindLastBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByZZ(pcSubStr, pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		nResult = This.FindNthSubStringBoundedByCSIB(n, pcSubStr, pacBounds, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#--

		def FindLastBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		def FindLastBoundedByCSIBZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBound, pCaseSensitives)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSIB(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBound)

		#--

		def FindLastBoundedByIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBound)

		def FindLastBoundedByIBZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIB(pcSubStr, pacBound)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER            #
	 #  SUBSTRINGS INCLUDING BOUNDS AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-------------------------------------------------------------------------#

	def FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByCSIBZZ(n, pcSubStr, pacBounds, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindLastBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		def FindLastBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)
		return This.FindLastSubStringBoundedByCSIBZZ(pcSubStr, pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#--

		def FindLastBoundedByIBZZ(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		def FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastSubStringBoundedByIBZZ(pcSubStr, pacBounds)

		#>

	   #------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY   #
	 #  TWO OTHER SUBSTRINGS STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------#

	def FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCS(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedBySTCSZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedByST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedBySTZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #--------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  STARTING AT A GIVEN POSITION AND RETURNING POSITIONS AS SECTIONS        #
	#--------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		n = This.NumberOfOccurrenceOfSubStringBoundedBySCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSZZ(n, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedByAsSectionSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedByAsSectionST(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTCSZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGSSTARTING AT A GIVEN POSITION AND INCLUDING BOUNDS   #
	#----------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLast = this.NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIB(nLast, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedBySTCSIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSIB(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedBySTIBZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	   #------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS STARTING   #
	 #  AT A GIVEN POSITION, INCLUDING BOUNDS, AND RETURNING THE POSITIONS AS SECTIONS    #
	#------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTCSIBZZ(nLast, pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#--

		def FindLastBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		def FindLastBoundedByAsSectionSTCSIB(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
		return This.FindLastSubStringBoundedBySTCSIBZZ(pcSubStr, pacBounds, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#--

		def FindLastBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		def FindLastBoundedByAsSectionSTIB(pcSubStr, pacBounds, pnStartingAt)
			return This.FindLastSubStringBoundedBySTIBZZ(pcSubStr, pacBounds, pnStartingAt)

		#>

	   #-----------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY  #
	 #  TWO OTHER SUBSTRINGS GOING IN A GIVEN DIRECTION    #
	#-----------------------------------------------------#

	def FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCS(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByDCSZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCS(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByDZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByD(pcSubStr, pacBounds, pcDirection)

		#>

	   #--------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	 #  GOING INA GIVEN DIRECTION AND RETURNING POSITIONS AS SECTIONS           #
	#--------------------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSZZ(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionDCS(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSZZ(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByDZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByAsSectionD(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #----------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER   #
	 #  SUBSTRINGS GOING IN A GIVEN DIRECTION AND INCLUDING BOUNDS    #
	#----------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIB(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByDCSIBZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSIB(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByDIBZ(pcSubStr, pacBounds, pcDirection)
			return This.FindLastSubStringBoundedByDIB(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS GOING   #
	 #  IN A GIVENDIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS     # 
	#---------------------------------------------------------------------------------#

	def FindLastSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceOfSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		return This.FindNthSubStringBoundedByDCSIBZZ(nLast, pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionDCSIB(pcSubStr, pacBounds, pcDirection, pCaseSensitive)
			return This.FindBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
		return This.FindLastSubStringBoundedByDCSIBZZ(pcSubStr, pacBounds, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#--

		def FindLastBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		def FindLastBoundedByAsSectionDIB(pcSubStr, pacBounds, pcDirection)
			return This.FindBoundedByDIBZZ(pcSubStr, pacBounds, pcDirection)

		#>

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS   #
	 #  STARTING AT A GIVEN POSITION AND GOING IN A GIVEN DIRECTION              #
	#---------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nLen = This.NumberOfChars()
		cDirection = @Direction(pcDirection)
		n = @StartingAt(pnStartingAt)

		if n = :First
			n = 1
		but n = :Last
			n = nLen
		ok

		if cDirection = :Forward
			nResult = This.SectionQ(pnStartingAt, nLen).FindLastSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			nResult += pnStartingAt - 1

		else // :Backward
			nResult = This.SectionQ(1, pnStartingAt).FindFirstSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		ok

		return nResult
		
		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedByTSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedBySTDCSZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedBySTDZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING      #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING POSITIONS AS SECTIONS  #
	#----------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nPos = FindLastSubStringBoundedBySTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		anResult = []

		if nPos > 0
			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
			anResult = [ nPos, nPos + nLenSubStr - 1 ]
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionSTDCS(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDC(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedByAsSectionSTD(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #-------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING   #
	 #  AT A GIVEN POSITION, GOING IN A GIVEN DIRECTION, AND INCLUDING BOUNDS              #
	#-------------------------------------------------------------------------------------#

	def FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceBoundedBySTCS(pcSubStr,pacBounds, pnStartingAt, pCaseSensitive)
		return This.FindNthSubStringBoundedBySTDCSIB(nLast, pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedBySTDCSIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedBySTDIBZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGSS STARTING AT A GIVEN   #
	 #  POSITION, GOING IN A GIVEN DIRECTION, INCLUDING BOUNDS, AND RETURNING POSITIONS AS SECTIONS   #
	#================================================================================================#

	def FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		nPos = This.FindLastSubStringBoundedBySTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			cBound1 = ""
			cBound2 = ""

			if isString(pacBounds)
				cBound1 = pacBounds
				cBound2 = pacBounds

			else
				cBound1 = pacBounds[1]
				cBound2 = pacBounds[2]
			ok

			nLenBound1 = StzStringQ(cBound1).NumberOfChars()
			nLenBound2 = StzStringQ(cBound2).NumberOfChars()

			nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

			anResult = [ nPos, ( nPos + nLenBound1 + nLenSubStr + nLenBound2 - 1 ) ]
			return anResult
		ok

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindLastBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastBoundedByAsSectionSTDCSIB(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
		return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDCSIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#--

		def FindLastBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		def FindLastBoundedByAsSectionSTDIB(pcSubStr, pacBounds, pnStartingAt, pcDirection)
			return This.FindLastSubStringBoundedBySTDIBZZ(pcSubStr, pacBounds, pnStartingAt, pcDirection)

		#>

	  #=========================================================================================#
	 #  CHECKING IF THE STRING CONTAINS ANY SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#=========================================================================================#

	def ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)

		n1 = This.FindFirstCS(acBounds[1], pCaseSensitive)
		if n1 = 0
			return FALSE
		ok

		n2 = This.FindFirstCS(acBounds[2], pCaseSensitive)
		if n2 = 0
			return FALSE
		ok

		if n2 > n1
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def ContainsBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def ContainsAtLeastASubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.ContainsSubstringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubstringsBoundedBy(pacBounds)
		return This.ContainsSubstringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def ContainsAnySubStringBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		def ContainsBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		def ContainsAtLeastASubStringBoundedBy(pacBounds)
			return This.ContainsSubstringsBoundedBy(pacBounds)

		#>

	  #--------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS BOUNDED BY THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------------#

	def NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		nResult = len( This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def HowManyOccurrenceOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)


		def HowManyOccurrencesOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfOccurrencesOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def NumberOfOccurrenceOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManySubStringBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManySubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		def HowManyOccurrenceOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)


		def HowManyOccurrencesOfSubStringsBoundedBy(pacBounds)
			return This.NumberOfSubStringsBoundedBy(pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#=================================================================#

	def FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		aSections = This.FindTheseBoundsCSZZ(cBound1, cBound2, pCaseSensitive)

		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen step 2
			anResult + aSections[i][2]++
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindAnyBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def FindBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedBy(pacBounds)
		return This.FindSubStringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringsBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindSubStringsBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnySubStringsBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindAnyBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindAnyBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#--

		def FindBoundedBy(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		def FindBoundedByZ(pacBounds)
			return This.FindSubStringsBoundedBy(pacBounds)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- ZZ/EXTENSION  #
	#=================================================================================#

	def FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		aSections = This.FindTheseBoundsCSZZ(cBound1, cBound2, pCaseSensitive)

		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen step 2
			aResult + [ aSections[i][2]++, aSections[i+1][1]-- ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def FindBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByZZ(pacBounds)
		return This.FindSubStringsBoundedByCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnySubStringsBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#--

		def FindAnyBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnyBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#==

		def FindAnySubStringBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindAnySubStringsBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#--

		def FindBoundedByZZ(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		def FindBoundedByAsSections(pacBounds)
			return This.FindSubStringsBoundedByZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS  #
	#-----------------------------------------------------------------#

	def SubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		acResult = []

		if nLen > 0
			acResult = This.Sections(aSections)
		ok

		return acResult


		#< @FunctionAlternativeForms

		def BoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnyBoundedByCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedBy(pacBounds)
		return This.SubStringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def BoundedBy(pacBounds)
			return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringsBoundedBy(acBounds)
			return This.SubStringsBoundedBy(pacBounds)

		def AnyBoundedBy(pacBounds)
			return This.SubStringsBoundedBy(pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------------------------#

	def SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		anPos = []
		for i = 1 to nLen
			anPos + aSections[i][1]
		next

		aResult = @Association([ This.Sections(aSections), anPos ])
		return aResult



		#< @FunctionAlternativeForms

		def BoundedByCSZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSZ(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirPositionsCS(acBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByZ(pacBounds)
		return This.SubStringsBoundedByCSZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def BoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnySubStringsBoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnyBoundedByZ(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirPositions(pacBounds)
			return This.SubStringsBoundedByZ(pacBounds)

		def AnySubStringsBoundedByAndTheirPositions(acBounds)
			return This.SubStringsBoundedByCSZ(pacBounds)

		#>
	
	  #-------------------------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRING BOUNDED BY ONE OR TWO OTHER SUBSTRINGS ALONG WITH THEIR SECCTIONS  #
	#-------------------------------------------------------------------------------------------#

	def SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		aResult = @Association([ This.Sections(aSections), aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def BoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def SubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVTY

	def SubStringsBoundedByZZ(pacBounds)
		return This.SubStringsBoundedByCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def BoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnySubStringsBoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnyBoundedByZZ(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		#--

		def SubStringsBoundedByAndTheirSections(pacBounds)
			return This.SubStringsBoundedByZZ(pacBounds)

		def AnySubStringsBoundedByAndTheirSections(acBounds)
			return This.SubStringsBoundedByCSZZ(pacBounds)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- IB/EXTENSION  #
	#=================================================================================#

	def FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos = This.FindSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		nLen = len(anPos)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + ( anPos[i] - nLenBound1 )
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def FindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnySubStringBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByIB(pacBounds)
		return This.FindSubStringsBoundedByCSIB(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def FindSubStringsBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnySubStringBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def FindBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnyBoundedByIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		def FindAnyBoundedByIBZ(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING THE SUBSTRINGS BOUNDED BY ONE OR TWO OTHER SUBSTRINGS -- IBZZ/EXTENSION  #
	#-----------------------------------------------------------------------------------#

	def FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		aSections = This.FindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] - nLenBound1
			n2 = aSections[i][2] + nLenBound2

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSenitive)

		#--

		def FindAnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def FindBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def FindAnyBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBoundedByIBZZ(pacBounds)
		return This.FindSubStringsBoundedByCSIBZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindAnySubStringBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def FindAnySubStringBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnySubStringsBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def FindBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnyBoundedByIBZZ(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		def FindAnyBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIBZZ(pacBounds)

		#>

	  #----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#----------------------------------------------------------------------#

	def SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aSections = This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def AnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByCSIB(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		#--

		def AnySubStringBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringsBoundedByAsSectionsIB(pacBounds)
			return This.FindSubStringsBoundedByIB(pacBounds)

		#--

		def BoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		def AnyBoundedByIB(pacBounds)
			return This.SubStringsBoundedByIB(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZ/EXTENSION  #
	#-----------------------------------------------------------------------#

	def SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		acSubStr = This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos  = This.FindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		nLen = len(acSubStr)

		bCaseSensitive = @CaseSensitive(pCaseSensitive)

		if bCaseSensitive = FALSE
			for i = 1 to nLen
				acSubStr[i] = ring_lower(acSubStr[i])
			next
		ok

		#--

		aResult = []
		acSeen = []

		for i = 1 to nLen
			nFound = ring_find(acSeen, acSubStr[i])
			if nFound = 0
				aResult + [ acSubStr[i], anPos[i] ]
				acSeen + acSubStr[i]
			
			else
				n = ring_find(acSeen, acSubStr[i])
				aResult[n] + anPos[i]

			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBZ(pacBounds)
		return This.SubStringsBoundedByCSIBZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnySubStringsBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		#--

		def BoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnyBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE SUBSTRINGS BOUNDED BY THE GIVEN BOUNDS -- IBZZ/EXTENSION  #
	#------------------------------------------------------------------------#

	def SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		acSubStr   = This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections  = This.FindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		nLen = len(acSubStr)

		bCaseSensitive = @CaseSensitive(pCaseSensitive)

		if bCaseSensitive = FALSE
			for i = 1 to nLen
				acSubStr[i] = ring_lower(acSubStr[i])
			next
		ok

		#--

		aResult = []
		acSeen = []

		for i = 1 to nLen
			nFound = ring_find(acSeen, acSubStr[i])
			if nFound = 0
				aResult + [ acSubStr[i], aSections[i] ]
				acSeen + acSubStr[i]
			
			else
				n = ring_find(acSeen, acSubStr[i])
				aResult[n] + aSections[i]

			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByCSIBZZ(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#==

		def SubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def BoundedByAsSectionsCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnyBoundedByAsSectionsCSIB(pacBounds, pCaseSenitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBoundedByIBZZ(pacBounds)
		return This.SubStringsBoundedByCSIBZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def AnySubStringBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		def AnySubStringsBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByCSIBZZ(pacBounds)

		#==

		def SubStringsBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#--

		def BoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		def AnyBoundedByAsSectionsIB(pacBounds)
			return This.SubStringsBoundedByBZZ(pacBounds)

		#>

	  #===================================================================================#
	 #  DEEP-FINDING OCCURRENCES OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#===================================================================================#

	def DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()
		if nLenBound2 > 1
			nLenBound2++
		ok

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ([ cBound1, cBound2 ], pCaseSensitive)

		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] + nLenBound1
			anResult + n1
		next

		return anResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def DeepFindBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#==

		func DeepFindSubStringsCS(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def DeepFindCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		#--

		func DeepFindSubStringsCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		def DeepFindCSZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepFindSubStringsBoundedBy(pacBounds)
		return This.DeepFindSubStringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepFindBoundedBy(pacBounds)
			return This.DeepFindSubStringsBoundedBy(pacBounds)

		#--

		def DeepFindSubStringsBoundedByZ(pacBounds)
			return This.DeepFindSubStringsBoundedByCS(pacBounds)

		def DeepFindBoundedByZ(pacBounds)
			return This.DeepFindSubStringsBoundedBy(pacBounds)

		#==

		func DeepFindSubStrings(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedBy(pacBounds)

		def DeepFind(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		#--

		func DeepFindSubStringsZ(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		def DeepFindZ(pacBounds)
			return This.DeepFindSubStrings(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- ZZ/EXTENDED  #
	#-----------------------------------------------------------------------------------------------#
	# Bounding substrings are NOT counted in the result

	def DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound1 = StzStringQ(cBound1).NumberOfChars()
		nLenBound2 = StzStringQ(cBound2).NumberOfChars()
		if nLenBound2 > 1
			nLenBound2++
		ok

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		nLen = len(aSections)

		aResult = []

		for i = 1 to nLen
			n1 = aSections[i][1] + nLenBound1
			n2 = aSections[i][2] - nLenBound2
			if nLenBound2 > 1
				n2++
			ok

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def DeepFindBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		def DeepFindCSZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		def DeepFindAsSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepFindSubStringsBoundedByZZ(pacBounds)
		return This.DeepFindSubStringsBoundedByCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByZZ(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		#--

		def DeepFindSubStringsBoundedByAsSections(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		def DeepFindBoundedByAsSections(pacBounds)
			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		#==

		#==

		def DeepFindSubStringsZZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByZZ(pacBounds)

		def DeepFindSubStringsAsSections(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		def DeepFindZZ(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		def DeepFindAsSections(pacBounds)
			return This.DeepFindSubStringsZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult


		#< @FunctionAlternativeForms

		def DeepSubStringsCS(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedBy(pacBounds)
		return This.DeepSubStringsBoundedByCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStrings(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundsOrBoundedByNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedBy(pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- Z/EXTENDED   #
	#--------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
		acSubStr = This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		anPos = This.DeepFindSubStringsBoundedByCS(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsCSZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByZ(pacBounds)
		return This.DeepSubStringsBoundedByCSZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositions(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByZ(pacBounds)

		def DeepSubStringsAndTheirPositions(pacBounds)
			return This.DeepSubStringsZ(pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- ZZ/EXTENDED  #
	#--------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
		acSubStr  = This.DeepSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsCSZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSZZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByZZ(pacBounds)
		return This.DeepSubStringsBoundedByCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSections(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByZZ(pacBounds, pCaseSensitive)

		#==

		def DeepSubStringsZZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByZZZ(pacBounds)

		def DeepSubStringsAndTheirSections(pacBounds)
			return This.DeepSubStringsZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IB/EXTENDED  #
	#===============================================================================================#

	def DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		anResult = StzListOfPairsQ(aSections).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def DeepFindBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSIBZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAndTheirPositionsIBCS(pacBounds, pCaseSensitive)
			return This.DeepDindSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindSubStringsBoundedByIB(pacBounds)
		return This.DeepFindSubStringsBoundedByCSIB(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByIB(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		#--

		def DeepFindSubStringsBoundedByIBZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		def DeepFindBoundedByIBZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIB(pacBounds)

		#==

		def DeepFindSubStringsIBZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByIBZ(pacBounds)

		def DeepFindSubStringsAndTheirPositionsIB(pacBounds)
			return This.DeepDindSubStringsIBZ(pacBounds)

		#>

	  #-------------------------------------------------------------------------------------------------#
	 #  DEEP-FINDING SECTIONS OF SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZZ/EXTENDED  #
	#-------------------------------------------------------------------------------------------------#

	def DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		# Getting the bouning substrings

		acBounds = @Bounds(pacBounds)
		cBound1 = acBounds[1]
		cBound2 = acBounds[2]

		nLenBound2 = StzStringQ(cBound2).NumberOfChars()

		# Doing the job (using a numerical solution based of the bounds positions)

		nNumberOfSections = This.NumberOfOccurrenceCS(cBound1, pCaseSensitive)

		aList1 = This.FindAllCS(cBound1, pCaseSensitive)
		nLenList1 = len(aList1)
		if nLenList1 = 0
			return []
		ok
		
		aList2 = This.FindAllCS(cBound2, pCaseSensitive)
		nLenList2 = len(aList2)
		if nLenList2 = 0
			return []
		ok

		nLenBound2--
		for i = 1 to nLenList2
			aList2[i] += nLenBound2
		next

		aList = aList1
		for i = 1 to nLenList2
			aList + aList2[i]
		next

		aList = ring_sort(aList)

		nLenList = len(aList)
		aSections = []

		while TRUE

			for i = 2 to nLenList

				if ring_find(aList1, aList[i-1]) > 0 and
				   ring_find(aList2, aList[i]) > 0

					aSections + [ aList[i-1], aList[i] ]
					if len(aSections) = nNumberOfSections
						exit 2
					ok

				ok
			next

			aList = Q(aList).ManyRemoved(Q(aSections).Merged())
			nLenList = len(aList)

		end

		return aSections

		#< @FunctionAlternativeForms

		def DeepFindBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#--

		def DeepFindSubStringsBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepFindBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#==

		def DeepFindSubStringsCSIBZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepFindSubStringsAndTheirSectionsIBCS(pacBounds, pCaseSensitive)
			return This.DeepDindSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindSubStringsBoundedByIBZZ(pacBounds)
		return This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepFindBoundedByIBZZ(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		#--

		def DeepFindSubStringsBoundedByAsSectionsIB(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		def DeepFindBoundedByAsSectionsIBpacBounds(pacBounds)
			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		#==

		def DeepFindSubStringsIBZZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepFindSubStringsBoundedByIBZZ(pacBounds)

		def DeepFindSubStringsAndTheirSectionsIB(pacBounds)
			return This.DeepDindSubStringsIBZZ(pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)
		return acResult

		#< @FunctionAlternativeForms

		def DeepSubStringsCSIB(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIB(pacBounds)
		return This.DeepSubStringsBoundedByCSIB(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStringsIB(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIB(pacBounds)

		#>

	  #----------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZ/EXTENDED   #
	#----------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
		acSubStr = This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		anPos = This.DeepFindSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepSubStringsCSIBZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirPositionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSIBZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIBZ(pacBounds)
		return This.DeepSubStringsBoundedByCSIBZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirPositionsIB(pacBounds)
			return This.DeepSubStringsBoundedByIBZ(pacBounds)

		def DeepSubStringsIBZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIBZ(pacBounds)

		def DeepSubStringsAndTheirPositionsIB(pacBounds)
			return This.DeepSubStringsIBZ(pacBounds)

		#>

	  #----------------------------------------------------------------------------------------#
	 # GETTING THE DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO BOUNDING SUBSTRINGS -- IBZZ/EXTENDED  #
	#----------------------------------------------------------------------------------------#

	def DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		acSubStr  = This.DeepSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.DeepFindSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult


		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsCSIBZZ(pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def DeepSubStringsAndTheirSectionsCSIB(pacBounds, pCaseSensitive)
			return This.DeepSubStringsCSIBZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBoundedByIBZZ(pacBounds)
		return This.DeepSubStringsBoundedByCSIBZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def DeepSubStringsBoundedByAndTheirSectionsIB(pacBounds)
			return This.DeepSubStringsBoundedByIBZZ(pacBounds)

		def DeepSubStringsIBZZ(pacBounds)
			if isList(pacBounds) and Q(pacBounds).IsBoundedByOrBoundsNamedParam()
				pacBounds = pacBounds[2]
			ok

			return This.DeepSubStringsBoundedByIBZZ(pacBounds)

		def DeepSubStringsAndTheirSectionsIB(pacBounds)
			return This.DeepSubStringsIBZZ(pacBounds)

		#>


~~~~~~~~~~~~~

	  #==============================================================#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS  #
	#==============================================================#

	def FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		anResult = This.AntiFindCS(pacBounds, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms


		def FindNestedSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		def FindNestedCSZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStrings(pacBounds)
		return This.FindNestedSubStringsCS(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedBy(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedBoundedBy(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNested(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		#==

		def FindNestedSubStringsZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedSubStringsBoundedByZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedBoundedByZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		def FindNestedZ(pacBounds)
			return This.FindNestedSubStrings(pacBounds)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING NESTED SUBSTRINGS ENCLOSED BETWEN TWO GOVEN BOUNDS -- ZZ/EXTENSION  #
	#==============================================================================#

	def FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aResult = This.AntiFindCSZZ(pacBounds, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedCSZZ(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)


		#==

		def FindNestedSubStringsAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedSubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def FindNestedAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNestedSubStringsZZ(pacBounds)
		return This.FindNestedSubStringsCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForms

		def FindNestedSubStringsBoundedByZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedBoundedByZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedZZ(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		#==

		def FindNestedSubStringsAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedSubStringsBoundedByAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedBoundedByAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		def FindNestedAsSections(pacBounds)
			return This.FindNestedSubStringsZZ(pacBounds)

		#>

	  #----------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS  #
	#----------------------------------------------------------#

	def NestedSubStringsCS(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		aSections = This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStrings(pacBounds)
		return This.NestedSubStringsCS(pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedBy(pacBounds)
			return This.NestedSubStrings(pacBounds)

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- Z/EXTENDED  #
	#------------------------------------------------------------------------#

	def NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCS(pacBounds, pCaseSensitive)
		anPos = This.FindNestedSubStringsCS(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, anPos ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirPositionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsZ(pacBounds)
		return This.NestedSubStringsCSZ(pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByZ(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		#--

		def NestedSubStringsAndTheirPositions(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirPositions(pacBounds)
			return This.NestedSubStringsZ(pacBounds)

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NESTED SUBSTRINGS BETWEEN TWO GIVEN BOUNDS -- ZZ/EXTENDED  #
	#-------------------------------------------------------------------------#

	def NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		if isList(pacBounds) and StzListQ(pacBounds).IsBoundedByNamedParam()
			pacBounds = pacBounds[2]
		ok

		acSubStr = This.NestedSubStringsCS(pacBounds, pCaseSensitive)
		aSections = This.FindNestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		aResult = @Association([ acSubStr, aSections ])

		return aResult

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#--

		def NestedSubStringsAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		def NestedSubStringsBoundedByAndTheirSectionsCS(pacBounds, pCaseSensitive)
			return This.NestedSubStringsCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NestedSubStringsZZ(pacBounds)
		return This.NestedSubStringsCSZZ(pacBounds, TRUE)

		#< @FunctionAlternativeForm

		def NestedSubStringsBoundedByZZ(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		#--

		def NestedSubStringsAndTheirSections(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		def NestedSubStringsBoundedByAndTheirSections(pacBounds)
			return This.NestedSubStringsZZ(pacBounds)

		#>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~ LASTMILE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# TODO: Adding the ...BoundedBy... and ...Between... functions in stzList

	  #=============================================#
	 #   GETTING A RANDOM POSITION IN THE STRING   #
	#=============================================#

	#TODO: Add

	# 	RandomPositions()			RandomChars()
	# 	NRandomPositions()			NRandomChars()

	# 	RandomPositionsGreaterThan()		RandomCharsAfter()
	# 	NRandomPositionsGreaterThan()		NRandomCharsAfter()

	# 	RandomPositionsLessThan()		RandomCharsBefore()
	# 	NRandomPositionsLessThan()		NRandomCharsBefore()

	# 	RandomPositionsExcept()			RandomCharsExcept()
	# 	NRandomPositionsExcept()		NRandomCharsExcept()

	def RandomPosition()

		nResult = ARandomNumberBetween(1, This.NumberOfChars())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPosition()
			return This.RandomPosition()

		def APosition()
			return This.RandomPosition()

		def AnyPosition()
			return This.RandomPosition()

		#>

	  #--------------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING GREATER THAN THE ONE PROVIDED  #
	#--------------------------------------------------------------------------#

	def RandomPositionGreaterThan(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfChars()

		if NOT ( n >= 1 and n < nLen - 1 )
			StzRaise("Out of range! n must be >= 1 and < (nLen-1).")
		ok

		nResult = ARandomNumberBetween(n+1, This.NumberOfChars())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def RandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def ARandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		#--

		def APositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def APositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionAfter(n)
			return This.RandomPositionGreaterThan(n)
		
		#>

	  #-----------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING LESS THAN THE ONE PROVIDED  #
	#-----------------------------------------------------------------------#

	def RandomPositionLessThan(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfChars()

		if NOT ( n > 1 and n <= nLen )
			StzRaise("Out of range! n must be > 1 and < nLen.")
		ok

		nResult = ARandomNumberBetween(1, n - 1)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def RandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		def ARandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#--

		def APositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def APositionBefore(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE STRING EXECEPT THE ONE PROVIDED  #
	#---------------------------------------------------------------------#

	def RandomPositionExcept(n)

		if checkParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		aNumbers = Q( 1:This.NumberOfChars() ) - n
		nResult = ARandomNumberIn(aNumbers)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def RandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def ARandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#--

		def APositionExcept(n)
			return This.RandomPositionExcept(n)

		def APositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#>

	  #-----------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING   #
	#=========================================#

	def RandomChar()

		cResult = This.CharAtPosition( This.RandomPosition() )
		return cResult

		#< @functionAlternativeForms

		def ARandomChar()
			return This.RandomChar()

		#--

		def AChar()
			return This.RandomChar()

		def AnyChar()
			return This.RandomChar()

		#>

	  #--------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING AFTER THE PROVIDED POSITION  #
	#--------------------------------------------------------------------#

	def RandomCharAfterPosition(n)

		cResult = This.CharAt( This.RandomPositionGreaterThan(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		#--

		def ACharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		def AnyCharAfterPosition(n)
			return This.RandomCharAfterPosition(n)

		#>

	  #---------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING AFTER THE PROVIDED POSITION OR SUBSTRING  #
	#---------------------------------------------------------------------------------#

	def RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)
		if NOT @IsNumberOrString(pPosOrSubStr)
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.RandomCharAfterPosition(pPosOrSubStr)
		else
			nPos = This.FindFirstCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterPosition(nPos)
		ok

		#< @FunctionAlternativeForms

		def ARandomCharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		#--

		def ACharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		def AnyCharAfterCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharAfterCS(pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharAfter(pPosOrSubStr)
		return This.RandomCharAfterCS(pPosOrSubStr, TRUE)

		#< @functionAlternativeForms

		def ARandomCharAfter(pPosOrSubStr)
			return This.RandomCharAfter(pPosOrSubStr)

		#--

		def ACharAfter(pPosOrSubStr)
			return This.RandomCharAfter(pPosOrSubStr)

		def AnyCharAfter(pPosOrSubStr)
			return This.RandomCharAfterCS(pPosOrSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING BEFORE THE PROVIDED POSITION  #
	#---------------------------------------------------------------------#

	def RandomCharBeforePosition(n)

		cResult = This.CharAt( This.RandomPositionLessThan(n) )
		return cResult

		#< @functionAlternativeForms

		def ARandomCharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		#--

		def ACharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		def AnyCharBeforePosition(n)
			return This.RandomCharBeforePosition(n)

		#>

	  #----------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING BEFORE THE PROVIDED POSITION OR SUBSTRING  #
	#----------------------------------------------------------------------------------#

	def RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)
		if NOT @IsNumberOrString(pPosOrSubStr)
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.RandomCharBeforePosition(pPosOrSubStr)
		else
			nPos = This.FindFirstCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforePosition(nPos)
		ok

		#< @functionAlternativeForms

		def ARandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		#--

		def ACharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		def  AnyCharBeforeCS(pPosOrSubStr, pCaseSensitive)
			return This.RandomCharBeforeCS(pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharBefore(pPosOrSubStr)
		return This.RandomCharBeforeCS(pPosOrSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ARandomCharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		#--

		def ACharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		def  AnyCharBefore(pPosOrSubStr)
			return This.RandomCharBefore(pPosOrSubStr)

		#>

	  #--------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING EXECEPT THE PROVIDED ONE OR  #
	#  EXCEPT THE ONE AT THE POSITION PROVIDED                           #
	#-------------------------------------------------------------------#

	def RandomCharExceptCS(pPosOrChar, pCaseSensitive)
		if NOT @IsNumberOrChar(pPosOrChar)
			StzRaise("Incorrect param type! pPosOrChar must be a number or char.")
		ok

		if isNumber(pPosOrChar)
			return This.RandomCharExceptPosition(pPosOrChar)

		else
			return This.RandomCharExceptCharCS(pPosOrChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def ARandomCharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		#--

		def ACharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		def AnyCharExceptCS(pPosOrChar, pCaseSensitive)
			return This.RandomCharExceptCS(pPosOrChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomCharExcept(pPosOrChar)
		return This.RandomCharExceptCS(pPosOrChar, TRUE)

		#< @FunctionAlternativeForms

		def ARandomCharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		#--

		def ACharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		def AnyCharExcept(pPosOrChar)
			return This.RandomCharExcept(pPosOrChar)

		#>

	  #---------------------------------------------------------------------------------#
	 #   GETTING A RANDOM CHAR IN THE STRING EXECEPT THE ONE AT THE POSITION PROVIDED  #
	#---------------------------------------------------------------------------------#

	def RandomCharExceptPosition(n)
		cResult = This.CharAt( This.RandomPositionExcept(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanPosition(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		def RandomCharOtherThanCharAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharOtherThanCharAt(n)
			return This.RandomCharExceptPosition(n)

		#--

		def RandomCharExceptAt(n)
			return This.RandomCharExceptPosition(n)

		def ARandomCharExceptAt(n)
			return This.RandomCharExceptPosition(n)

		#==

		def ACharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def ACharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def ACharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		#--

		def AnyCharExceptPosition(n)
			return This.RandomCharExceptPosition(n)

		def AnyCharExceptCharAtPosition(n)
			return This.RandomCharExceptPosition(n)

		def AnyCharExceptCharAt(n)
			return This.RandomCharExceptPosition(n)

		#>

	  #---------------------------------------------------------------#
	 #  GETTING A RANDOM CHAR IN THE STRING EXCEPT THE ONE PROVIDED  #
	#---------------------------------------------------------------#

	def RandomCharExceptCharCS(pcChar, pCaseSensitive)
		if NOT ( isString(pcChar) and @IsChar(pcChar) )
			StzRaise("Incorrect param type! pcChar must be a char.")
		ok

		anPos = This.FindAllCS(pcChar, pCaseSensitive)
		anPos = Q(1: This.NumberOfChars()) - Many(anPos)
		nPos = ARandomNumberIn( anPos )
		cResult = This.CharAt(nPos)
		return cResult

		#< @FunctionAlternativeForms

		def ARandomCharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		#--

		def ACharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		def AnyCharExceptCharCS(pcChar, pCaseSensitive)
			return This.RandomCharExceptCharCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomCharExceptChar(pcChar)
		return This.RandomCharExceptCharCS(pcChar, TRUE)

		#< @FunctionAlternativeForms

		def ARandomCharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		#--

		def ACharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		def AnyCharExceptChar(pcChar)
			return This.RandomCharExceptChar(pcChar)

		#>

	  #--------------------------------------------#
	 #  GETTING A RANDOM SECTION FROM THE STRING  #
	#============================================#

	def RandomSection()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aResult = This.Section(n1, n2)

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSection()
			return This.RandomSection()

		def AnyRandomSection()
			return This.RandomSection()

		def ASection()
			return This.RandomSection()

		def AnySection()
			return This.RandomSection()

		#--

		def RandomSubString()
			return This.RandomSection()

		def ARandomSubString()
			return This.RandomSection()

		def AnyRandomSubString()
			return This.RandomSection()

		def ASubString()
			return This.RandomSection()

		def AnySubString()
			return This.RandomSection()

		#>

	  #--------------------------------------------------------------------#
	 #  GETTING A RANDOM SECTION FROM THE STRING ALONG WITH ITS POSITION  #
	#--------------------------------------------------------------------#

	def RandomSectionZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, [ n1, n2 ] ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZ()
			return This.RandomSectionZ()

		def AnyRandomSectionZ()
			return This.RandomSectionZ()

		def ASectionZ()
			return This.RandomSectionZ()

		def AnySectionZ()
			return This.RandomSectionZ()

		#--

		def RandomSubStringZ()
			return This.RandomSectionZ()

		def ARandomSubStringZ()
			return This.RandomSectionZ()

		def AnyRandomSubStringZ()
			return This.RandomSectionZ()

		def ASubStringZ()
			return This.RandomSectionZ()

		def AnySubStringZ()
			return This.RandomSectionZ()

		#==

		def RandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ASectionAndItsPosition()
			return This.RandomSectionZ()

		def AnySectionAndItsPosition()
			return This.RandomSectionZ()

		#--

		def RandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSubStringAndItsPosition()
			return This.RandomSectionZ()

		def ASubStringAndItsPosition()
			return This.RandomSectionZ()

		def AnySubStringAndItsPosition()
			return This.RandomSectionZ()

		#>


	  #------------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS (AS POSITIONS) FROM THE STRING  #
	#============================================================#

	#TODO: Add "Position" as an misspelled form of "Position"

	def NRandomSectionsAsPositions(n)
		n = NRandomNumberIn(n, 1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok
			
			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def NSectionsAsPositions(n)
			return This.NRandomSectionsAsPositions(n)

		#>

	  #---------------------------------------------#
	 #  GETTING N RANDOM SECTIONS FROM THE STRING  #
	#---------------------------------------------#

	def NRandomSections(n)
		aSections = This.NRandomSectionsAsPositions(n)
		aResult = This.Sections(aSections)

		return aResult

	  #------------------------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS FROM THE STRING ALONG WITH THEIR POSITIONS  #
	#------------------------------------------------------------------------#

	def NRandomSectionsZ(n)
		aSections = This.NRandomSectionsAsPositions(n)
		aResult = Association([ This.Sections(aSections), aSections ])

		return aResult

		def NRandomSectionsAndTheirPositions(n)
			return This.NRandomSectionsZ(n)

	  #------------------------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS (AS PAIRS OF POSITIONS) FROM THE STRING  #
	#========================================================================#

	def SomeRandomSectionsAsPairsOfPositions()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ n1, n2 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsAsPairsOfPositions()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def AnySectionsAsPairsOfPositions()
			return This.SomeRandomSectionsAsPairsOfPositions()

		#--

		def SomeRandomSectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def SomeSectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		def AnySectionsAsPairsOfNumbers()
			return This.SomeRandomSectionsAsPairsOfPositions()

		#>

	  #----------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS AND THEIR POSITIONS  #
	#----------------------------------------------------#

	def SomeRandomSectionsZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsZ()
			return This.SomeRandomSectionsZ()

		def AnySectionsZ()
			return This.SomeRandomSectionsZ()

		#--

		def SomeRandomSectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def SomeSectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def AnySectionsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		#==

		def SomeRandomSubStringsZ()
			return This.SomeRandomSectionsZ()

		def SomeSubStringsZ()
			return This.SomeRandomSectionsZ()

		def AnySubStringsZ()
			return This.SomeRandomSectionsZ()

		#--

		def SomeRandomSubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def SomeSubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		def AnySubStringsAndTheirPositions()
			return This.SomeRandomSectionsZ()

		#>

	  #---------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS AND THEIR SECTIONS  #
	#---------------------------------------------------#

	def SomeRandomSectionsZZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []

		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)

			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [n1, n2] ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SomeSectionsZZ()
			return This.SomeRandomSectionsZZ()

		def AnySectionsZZ()
			return This.SomeRandomSectionsZZ()

		#--

		def SomeRandomSectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def SomeSectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def AnySectionsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		#==

		def SomeRandomSubStringsZZ()
			return This.SomeRandomSectionsZZ()

		def SomeSubStringsZZ()
			return This.SomeRandomSectionsZZ()

		def AnySubStringsZZ()
			return This.SomeRandomSectionsZZ()

		#--

		def SomeRandomSubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def SomeSubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		def AnySubStringsAndTheirSections()
			return This.SomeRandomSectionsZZ()

		#>

	  #------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS FROM THE STRING  #
	#================================================#

	def SomeRandomSections()
		aSections = This.SomeRandomSectionsAsPairsOfNumbers()
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def SomeSections()
			return This.SomeRandomSections()

		def AnySections()
			return This.SomeRandomSections()

		#>

	  #================================================#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING   #
	#================================================#

	def SectionCS(n1, n2, pCaseSensitive)

		#TODO // Rethink the necessity of all these named params,
		# what practical value they provide, and in what performance cost!

		#UPDATE // Programmer can skip the param checks by setting SetCheckPrams(FALSE)

		nLen = This.NumberOfChars()

		if CheckParams()

			# Managing the use of :From and :To named params
	
			if isList(n1) and
			   StzListQ(n1).IsOneOfTheseNamedParams([
					:From, :FromPosition, :FromCharAt, :FromCharAtPosition,

					:Start, :FromStart,
					:StartingAt, :StartingAtPosition,
					:StartingAtCharAt, :StartingAtCharAtPosition,

					:Between, :BetweenPosition, :BetweenCharAt,
					:BetweenCharAtPosition,

					:BetweenPositions, :BetweeChartsAtPosition
					])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   StzListQ(n2).IsOneOfTheseNamedParams([
					:To, :ToPosition, :ToCharAt, :ToCharAtPosition,
					:ToEndOfWord, :ToEndOfLine, :ToEndOfSentence,

					:EndOfWord, :EndOfLine, :EndOfSentence,

					:End, :ToEnd,
					:Until, :UntilPosition, :UntilCharAt, :UntilCharAtPosition,
					:UpTo, :UpToPosition, :UpToCharAt, :UpToCharAtPosition,

					:And,

					:StartingAt, :StartingAtPosition, :StartingAtCharAt, :StartingAtCharAtPosition					])

				n2 = n2[2]

			ok
	
			# Managing the use of :NthToFirst named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstChar ])
	
				n1 = n1[2] + 1
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstChar ])
	
				n2 = n2[2] + 1
			ok
	
			# Managing the use of :NthToLast named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastChar ])
	
				n1 = nLen - n1[2]
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastChar ])
	
				n2 = nLen - n2[2]
	
			but isList(n2) and Q(n2).IsStoppingAtNamedParam()
	
				n2 = n2[2]
			ok
	
			# Managing the case of :First and :Last keywords
	
			if isString(n1)
				if Q(n1).IsOneOfThese([
					:First, :FirstChar,
					:FromFirst, :FromFirstChar
				])

					n1 = 1
	
				but Q(n1).IsOneOfThese([
					:Last, :LastChar,
					:ToLast, :ToLastChar
				])

					n1 = nLen
	
				but n1 = :@
					n1 = n2

				else
					n1 = This.FindFirstCS(n1, pCaseSensitive)
				ok
			ok
		
			if isString(n2)
				if Q(n2).IsOneOfThese([
					:End, :Last, :LastChar, :EndOfString,
					:ToEnd, :ToLast, :ToLastChar, :ToEndOfString
					])

					n2 = nLen
	
				but Q(n2).IsOneOfThese([
					:First, :FirstChar,
					:FromFirst, :FromFirstChar
					])

					n2 = 1
	
	
				but n2 = :@
					n2 = n1

				but n2 = :EndOfWord or n2 = :EndOfSentence or n2 = :EndOfLine
					# Do nothing here, will be managed later
				else
					nLen2 = StzStringQ(n2).NumberOfChars()
					n2 = This.FindLastCS(n2, pCaseSensitive) + nLen2 - 1
				ok
			ok

			if n1 = :@ and n2 = :@
				n1 = 1
				n2 = nLen
			ok

			# Managing the case of :EndOfSentence, :EndOfLine, and :EndOfWord keywords
	
			if n1 > 0 and n2 = :EndOfSentence

				n2 = nLen
				for i = 1 to nLen
					if @oQString.mid(i-1, 1) = "."
						n2 = i
						exit
					ok
				next

				return This.Section(n1, n2)
			ok
	
			if n1 > 0 and n2 = :EndOfLine

				n2 = nLen-1
				for i = 1 to nLen
					if @oQString.mid(i-1, 1) = NL
						n2 = i-2
						exit
					ok
				next
				return This.Section(n1, n1 + n2 - 2)		
			ok

			if n1 > 0 and n2 = :EndOfWord #TODO // should move to stzText?

				n2 = nLen-1
				for i = 1 to nLen
					if @oQString.mid(i-1, 1) = " "
						n2 = i-2
						exit
					ok
				next

				return This.Section(n1, n1 + n2 - 2)
			ok

			# Params must be numbers
	
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params! n1 and n2 must be numbers.")
			ok

			#TODO // do same behavior in stzList.Section()
			#TODO // Add SectionXT() that allows using out of index params and return accurate results

		ok

		#NOTE // When positions are given in inversed order, the same
		# section as if they were not inverted is returned, so:
		#--> Q("ring").Section(1,3) and .Section(3,1) both return "rin"

		# In some languages, like Pyhton for example, reverting the positions,
		# inverts the section. So:
		#--> Q("ring").Section(1,3) returns "rin" but .Section(3,1) returns 'nir"

		# If you need to use this feature in Softanza, use the eXTended form of Section(),
		# like this :
		#--> Q("ring").SectionXT(3,1) and it will return "nir"

		anTemp = ring_sort([ n1, n2 ])
		n1 = anTemp[1]
		n2 = anTemp[2]

		# params must be in range

		if NOT 	( ( n1 >= 1 and n1 <= nLen ) and
			   ( n2 >= 1 and n2 <= nLen ) )
				
			StzRaise("Indexes out of range! n1 and n2 must be inside the string.")
		ok

		if n1 = n2
			cResult = This.Char(n1)
			
		but n1 < n2
			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		else // n2 < n1
			# Swapping n1 and n2
			nTemp = n1
			n1 = n2
			n2 = nTemp

			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		ok

		return cResult

		#< @FunctionFluentForm

		def SectionCSQ(n1, n2, pCaseSensitive)
			return new stzString( This.SectionCS(n1, n2, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SliceCS(n1, n2, pCaseSensitive)
			return This.SectionCS(n1, n2, pCaseSensitive)

			#< @FunctionFluentForm

			def SliceCSQ(n1, n2, pCaseSensitive)
				return This.SectionCSQ(n1, n2, pCaseSensitive)

			#>
		#>	

	#-- WITHOUT CASESENSITIVITY

	def Section(n1, n2)
		cResult = This.SectionCS(n1, n2, TRUE)
		return cResult


		def SectionQ(n1, n2)
			return new stzString(This.Section(n1, n2))

		def Slice(n1, n2)
			return This.Section(n1, n2)

			def SliceQ(n1, n2)
				return new stzString(This.Slice(n1, n2))

	  #-------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- Z/EXTENDED  #
	#-------------------------------------------------------------#

	def SectionCSZ(n1, n2, pCaseSensitive)
		if CheckParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSZ(n1, n2, pCaseSensitive)
			return This.SectionCSZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZ(n1, n2)
		return This.SectionCSZ(n1, n2, TRUE)

		def SliceZ(n1, n2)
			return SectionZ(n1, n2)

	  #--------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- ZZ/EXTENDED  #
	#--------------------------------------------------------------#

	def SectionCSZZ(n1, n2, pCaseSensitive)
		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = This.NumberOfChars()
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSZZ(n1, n2, pCaseSensitive)
			return This.SectionCSZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZZ(n1, n2)
		return This.SectionCSZZ(n1, n2, TRUE)

		def SliceZZ(n1, n2)
			return SectionZZ(n1, n2)

	  #-------------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTended form  #
	#===================================================================#

	def SectionCSXT(n1, n2, pCaseSensitive)

		# This is an extended form of Section() that supports
		# two fency features (that we find in other languages like Python):
		# 	~> n1 and n2 can be negative numbers, and hence their values are counted from the end
		# 	~> n1 can be greater then n2, and hence the section is reversed.

		nLen = This.NumberOfCharsCS(pCaseSensitive)

		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = nLen
			ok

			#==

			if isList(n2) and Q(n2).IsUpToNCharsNamedParam()
				return This.Range(n1, n2[2])
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		# Managing negative values

		if n1 < 0
			n1 = nLen + n1 + 1
			# Be careful : + n1 and not - n1 because n1 is already negative!
		ok

		if n2 < 0
			n2 = nLen + n2 + 1
		ok

		# Managing the case where n1 > n2 --> section reversed

		if n1 > n2
			cResult = This.SectionCSQ(n2, n1, pCaseSensitive).Reversed()

		else
			cResult = This.SectionCS(n2, n1, pCaseSensitive)
		ok

		return cResult

		def SliceCSXT(n1, n2, pCaseSensitive)
			return This.SectionCSXT(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXT(n1, n2)
		return This.SectionCSXT(n1, n2, TRUE)

		def SliceXT(n1, n2)
			return This.SectionXT(n1, n2)

	  #---------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZ form  #
	#---------------------------------------------------------------#

	def SectionCSXTZ(n1, n2, pCaseSensitive)
		if CheckParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSXTZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZ(n1, n2)
		return This.SectionCSXTZ(n1, n2, TRUE)

		def SliceXTZ(n1, n2)
			return This.SectionXTZ(n1, n2)

	  #----------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZZ form  #
	#----------------------------------------------------------------#

	def SectionCSXTZZ(n1, n2, pCaseSensitive)
		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfString)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfString)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSXTZZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZZ(n1, n2)
		return This.SectionCSXTZZ(n1, n2, TRUE)

		def SliceXTZZ(n1, n2)
			return This.SectionXTZZ(n1, n2)

	#TODO : RangeZ(), RangeZZ(), RangeXT(), RangeXTZ(), and RangeXTZZ()

	  #-----------------------------------#
	 #   GETTING A RANGE OF THE STRING   #
	#===================================#

	// Returns a subset of the string starting from nStart and ranging over nRange Chars
	def RangeCS(nStartPos, nRange, pCaseSensitive)

		if CheckParams()
			if NOT isNumber(nRange)
				StzRaise("Incorrect param type! nRange must be a number.")
			ok
		
			if isNumber(nStartPos)
	
				if nStartPos < 0
					nStartPos = This.NumberOfChars() + nStartPos + 1
				ok
		
				if nStartPos = 0 or nRange = 0
					return NULL
				ok
			ok
		ok

		# Doing the job

		cResult = ""

		if nRange > 0
			if CheckParams() and isString(nStartPos)
				nStartPos = This.FindFirstCS(nStartPos, pCaseSensitive)
			ok

			cResult = This.SectionCS( nStartPos, nStartPos + nRange -1, pCaseSensitive )

		else
			n1 = nStartPos + nRange + 1

			if n1 > 0
				cResult = This.SectionCS( n1, nStartPos, pCaseSensitive )
			ok	
		ok

		return cResult

		#< @FunctionFluentForm

		def RangeCSQ(nStartPos, nRange, pCaseSensitive)
			return new stzString( This.RangeCS(nStartPos, nRange, pCaseSensitive) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRangeCS(paParams, pCaseSensitive)
			
			// Default values
			nStartPos = 1
			nRange = This.NumberOfChars()

			// Reading the params
			if StzListQ(paParams).IsRangeNamedParam()
				if isNumber(paParams[ :Start ])
					nStartPos = paParams[ :Start ]
				ok

				if isNumber(paParams[ :Range ])
					nRange = paParams[ :Range ]
				ok

				return This.RangeCS(nStartPos, nRange, pCaseSensitive)
			else
				stzRaise("Incorrect params!")
			ok

		#>

		#< @FunctionInfoForm

		def infRangeCS(pCaseSensitive)
			return [
				:Syntax = "Range(pnstart, pnRange, pCaseSensitive)",
				:Description = "Returns pnRange chars starting at pnStart position",
				:ReturnType = "STRING",
				:NumberOfParams = 3,
				:Params = [
					[
						:Param = "pnStart",
						:Type = "NUMBER",
						:Description = "Start position",
						:Default = 1
					],
					[
						:Param = "pnRange",
						:Type = "NUMBER",
						:Description = "Number of chars of the range",
						:Default = This.NumberOfChars()
					],
					[
						:Param = "pCaseSensitive",
						:Type = "BOOLEAN",
						:Description = "If the first param is a string, apply or not case sensitivity",
						:Default = TRUE
					]
				]
			]
		#>

		#< @FunctionDefaultForm

		def dftRangeCS(pCaseSensitive)
			return This.nmdRangeCS([ :Start = 1, :Range = This.NumberOfChars(), pCaseSensitive ])

		#>

		#< @FunctionExampleForm

		def expRangeCS(pCaseSensitive)
			return 	'StzStringQ("The Ring programming language").RangeCS("ring", 11, :CS = FALSE)' + NL +
				'--> "Ring programming"'

		#>

		#< @FunctionRandomForm

		def rndRangeCS(pCaseSensitive)
			nStart = random( This.NumberOfChars() )
			nRange = random( This.NumberOfChars() - nStart )

			return 	'This.RangeCS(' + nStart + ', ' + nRange + ', ' + pCaseSensitive + ')' + NL +
				'--> ' + This.RangeCS(nStart, nRange, pCaseSensitive)

		#>

		#< @FunctionTestForm

		def tstRangeCS(pCaseSensitive)
			nCases = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfTestCases ]
			nSucceeded = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfSuccessfulCases ]
			nFailed = This.tstRangeCSXT(pCaseSensitive)[ :NumberOfFailedCases ]


			if nCases = 0
				return "Failed! (" + nFailed + "/" + nCases + ")"

			but nFailed = 0
				return "SUCCESS! (" + nSucceeded + "/" + nCases + ")"
			ok

			if nSucceeded != 0
				return "FAILED! (" + nFailed + "/" + nCases + ")"
			ok

		def tstRangeCSXT(pCaseSensitive)
			aTestCases = [
			['StzStringQ("Ringorialand").Range(9, 4)' , 'land'],
			['StzStringQ("Ringorialand").Range(1, 4)' , 'Ring'],
			['StzStringQ("Ringorialand").Range(4, 6)' , 'gorial']
			]

			aSucceeded = []
			aFailed = []
			i = 0

			for aTest in aTestCases
				i++
				cCode = "cResult = " + aTest[1]

				try
					 eval(cCode)

					if cResult = aTest[2]
						aSucceeded + i
					else
						aFailed + i
					ok
				catch
					aFailed + i
				done
			next
			
			aResult = [
				:NumberOfTestCases = len(aTestCases),
				:NumberOfSuccessfulCases = len(aSucceeded),
				:NumberOfFailedCases = len(aFailed),

				:SuccessfulCases = aSucceeded,
				:FailedCases = aFailed,

				:TestCases = aTestCases
			]

			return aResult

		#>

	#-- WTIHOUT CASESENSITIVITY

	def Range(nStartPos, nRange)
		return This.RangeCS(nStartPos, nRange, TRUE)

		#< @FunctionFluentForm

		def RangeQ(nStartPos, nRange)
			return new stzString( This.Range(nStartPos, nRange) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRange(paParams)
			return This.nmdRangeCS(paParams, TRUE)

		#>

		#< @FunctionInfoForm

		def infRange()
			return This.infRangeCS(TRUE)

		#>

		#< @FunctionDefaultForm

		def dftRange()
			return This.dftRangeCS(TRUE)


		#>

		#< @FunctionExampleForm

		def expRange()
			return This.expRangeCS(TRUE)

		#>

		#< @FunctionRandomForm

		def rndRange()
			return This.rndRangeCS(TRUE)

		#>

		#< @FunctionTestForm

		def tstRange()
			return This.tstRangeCS(TRUE)

		def tstRangeXT()
			return This.tstRangeCSXT(TRUE)

		#>

	  #---------------------------------------------#
	 #  GETTING A RANGE OF THE STRING -- EXTENDED  #
	#---------------------------------------------#

	def RangeCSXT(nStartPos, nRange, pCaseSensitive)
		aResult = [ This.RangeCS(nStartPos, nRange, pCaseSensitive), [nStartPos, nRange] ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RangeXT(nStartPos, nRange)
		return This.RangeCSXT(nStartPos, nRange, TRUE)

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #TODO: Add CaseSensitivity
	#---------------------------------------#

	def Sections(paSections)

		if isString(paSections) or
			(isList(paSections) and
				(Q(paSections).IsOfNamedParam() or
					Q(paSections).IsOfSubStringNamedParam() ) )

			return This.FindAsSections(paSections)
		ok

		if NOT 	( isList(paSections) and
				Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsQ(paSections)
			return This.SectionsQR(paSections, :stzList)

		def SectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Sections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Sections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

			def ManySectionsQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySectionsQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def Slices(paSections)
			return This.Sections(paSections)

			def SlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def SlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def ManySlices(paSections)
			return This.Sections(paSections)

			def ManySlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- EXTENDED  #
	#--------------------------------------------------#

	def SectionsXT(paSections)
		if CheckParams()
			if NOT (isList(paSections) and IsListOfPairs(paSections))
				StzRaise("Incorrect param type! paSections must be a list of pairs.")
			ok
		ok

		nLen = len(paSections)
		acResult = []

		for i = 1 to nLen
			cSection = This.SectionXT( paSections[i][1], paSections[i][2] )
			acResult + cSection
		next

		return acResult

		#< @FunctionFluentForm

		def SectionsXTQ(paSections)
			return This.SectionsXTQR(paSections, pcReturnType)

		def SectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

			def ManySectionsXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySectionsXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

			def SlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def SlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

			def ManySlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		#>

	  #----------------------------------------------------------#
	 #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def NumberOfAntiSections(paSections)
		nResult = len( StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content() )

		return nResult

		#< @FunctionAlternativeForms

		def CountAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSection(paSections)
			return This.NumberOfAntiSections(paSections)

		#>

	   #-------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND  #
	 #  RETURNING THEM AS PAIRS OF NUMBERS                         #
	#-------------------------------------------------------------#

	def FindAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
			  FindAntiSectionsQ(paSections).
			  Content()

		return aResult

		#< @FunctionFluentForm

		def FindAntiSectionsQ(paSections)
			return new stzList( This.FindAntiSections(paSections) )

		#>

		#< @FunctionAlternativeForms

		def FindAntiSectionsZZ(paSections)
			return This.FindAntiSections(paSections)

			def FindAntiSectionsZZQ(paSections)
				return This.FindAntiSectionsQ(paSections)

		def AntiSectionsAsPairsOfNumbers(paSections)
			return This.FindAntiSections(paSections)

			def AntiSectionsAsPairsOfNumbersQ(paSections)
				return This.FindAntiSectionsQ(paSections)
		#>

	  #----------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("ABCDEFGHIJ")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ "AB", "F", "IJ" ]
		*/

		aResult = This.Sections( This.AntiSectionsAsPairsOfNumbers(paSections) )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return This.AntiSectionsQR(paSections, pcReturnType)

		def AntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThan(paSections)
			return This.AntiSections(paSections)

			def SectionsOtherThanQ(paSections)
				return This.AntiSectionsQ(paSections)
	
			def SectionsOtherThanQR(paSections, pcReturnType)
				return This.AntiSectionsQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#---------------------------------------------------------------------#

	def AntiSectionsXT(paSections)

		aAntiSections = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content()

		aResult = This.SectionsXT( aAntiSections )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsXTQ(paSections)
			return This.AntiSectionsXTQR(paSections, pcReturnType)

		def AntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThanXT(paSections)
			return This.AntiSectionsXT(paSections)

			def SectionsOtherThanXTQ(paSections)
				return This.AntiSectionsXTQ(paSections)
	
			def SectionsOtherThanXTQR(paSections, pcReturnType)
				return This.AntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------#
	 #   GETIING NTH ANTI-SECTION OF A GIVEN SET OF SECTIONS   #
	#---------------------------------------------------------#

	def NthAntiSection(n, paSections)
		if n = :First or n = :FirstAntiSection
			n = 1
		but n = :Last or n = :LastAntiSection
			n = This.NumberOfAntiSections(paSections)
		ok

		return This.AntiSections(paSections)[n]

	def FirstAntiSection(paSections)
		return This.NthAntiSections(1, paSections)

	def LastAntiSection(paSections)
		return This.NthAntiSection(:Last, paSections)

	  #-------------------------------------------------------------------#
	 #   FINDING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#

	def FindAsSectionsAndAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
				FindAsSectionsAndAntiSectionsQ(paSections).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def FindAsSectionsAndAntiSectionsZZ(paSections)
			return This.FindAsSectionsAndAntiSections(paSections)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#
		
	def SectionsAndAntiSections(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections( aSectionsAntiSections )

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncluding(paSections)
			return This.SectionsAndAntiSections(paSections)

			def AllSectionsIncludingQ(paSections)
				return This.SectionsAndAntiSectionsQ(paSections)
	
			def AllSectionsIncludingQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#------------------------------------------------------------------------------#
		
	def SectionsAndAntiSectionsXT(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		nLen = len(aSectionsAntiSections)

		aResult = []

		for i = 1 to nLen
			aSection = aSectionsAntiSections[i]
			aResult + [ This.Section(aSection[1], aSection[2]), aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsXTQ(paSections)
			return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncludingXT(paSections)
			return This.SectionsAndAntiSectionsXT(paSections)

			def AllSectionsIncludingXTQ(paSections)
				return This.SectionsAndAntiSectionsXTQ(paSections)
	
			def AllSectionsIncludingXTQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------#
	 #   GENERATING ALL POSSIBLE SECTIONS BETWEEN TOW SUBSTRINGS  #
	#------------------------------------------------------------#

	def SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TAYOUBTA")
		? o1.SectionsFromTo( :From = "T", :To = "A" )
		#--> [ "TA", "TAYOUBTA", "TA" ]

		*/

		if isList(pcSubStr1) and Q(pcSubStr1).IsFromNamedParam()
			pcSubStr1 = pcSubStr1[2]
		ok

		if isList(pcSubStr2) and Q(pcSubStr2).IsToNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		anSections = []

		anPos1 = This.FindAllCS(pcSubStr1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pcSubStr2, pCaseSensitive) #--> [ 2, 8 ]

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		def AllPossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AllPossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SectionsFromTo(pcSubStr1, pcSubStr2)
		return This.SectionsFromToCS(pcSubStr1, pcSubStr2, TRUE)

		def AllPossibleSectionsFromTo(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def AllPossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSectionsFromTo(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2)

	  #--------------------------------------#
	 #   GETTING MANY RANGES OF THE STRING  #
	#--------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

	  #====================================#
	 #  INSERTING SUBSTRINGS -- EXTENDED  #TODO / ADD OTHER FORMS
	#====================================#

	def InsertXT(pcSubStr, paOptions)
		/*
		o1 = new stzString("99999999999")
		o1.InsertXT("_", [ :After, :EachNChars = 3, :Going = :Forward ])

		? o1.Content()
		#--> 99_999_999_999

		#--

		o1 = new stzString("99999999999")
		o1.InsertXT([".", "_"], [ :Repeat, :After, :EachNChars = 2, :Going = :Forward ])

		? o1.Content()
		#--> 9_99.99_99.99_99

		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(paOptions)

			oOptions = new stzList(paOptions)

			# Case : Q("999999").InsertXT("-", :EachNChars = 2) --> 99-99-99
			if oOptions.IsOneOfTheseNamedParams([ :Step, :EachNChars ])

				This.SpacifyXT(
					:Using = pcSubStr,
					:EachNChars = paOptions[2],
					:Going = :Forward)

			# Add other cases here

			but oOptions.IsBetweenNamedParam()
				This.InsertSubStringBetween(pcSubStr, paOptions[2][1], paOptions[2][2])

			but oOptions.IsBetweenSubStrings()
				cSubStr1 = paOptions[2][1]
				cSubStr2 = paOptions[2][2]

				if NOT ( isString(cSubStr1) and isString(cSubStr1) )
					StzRaise("Incorrect param type! You should provide two substrings.")
				ok

				This.InsertSubStringBetweenSubStrings(pcSubStr, paOptions[2][1], paOptions[2][2])

			but oOptions.IsBetweenPositions()
				n1 = paOptions[2][1]
				n2 = paOptions[2][2]

				if NOT ( isNumber(n1) and isNumber(n2) )
					StzRaise("Incorrect param type! You should provide two numbers.")
				ok

				This.InsertSubStringBetweenPositions(pcSubStr, paOptions[2][1], paOptions[2][2])

				
			else
				StzRaise("Unsupported syntax!")
			ok
		ok


		#< @FunctionFluentForm

		def InsertXTQ(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubStringXT(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)

			def InsertSubStringXTQ(pcSubStr, paOptions)
				This.InsertSubStringXT(pcSubStr, paOptions)
				return This

		#>

	def SubStringInsertedXT(pcSubStr, paOptions)
		cResult = This.Copy().InsertXTQ(pcSubStr, paOptions).Content()
		return cResult

	  #---------------------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS   #
	#===============================================================#

	def InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if CheckParams()

			if isList(p1)
				oTempList = new stzList(p1)

				if oTempList.IsPositionOrPositionsNamedParam() or
				   oTempList.IsSubStringOrSubStringsNamedParam()

					p1 = p1[2]
				ok

			but isList(p2)
				oTempList = new stzList(p2)

				if oTempList.IsAndOrAndPositionOrAndSubStringNamedParam()

					p2 = p2[2]
				ok
			ok

		ok

		if isNumber(p1) and isNumber(p2)
			This.InsertSubStringBetweenPositions(pcSubStr, p1, p2)

		but isString(p1) and isString(p2)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, p1, p2, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)
			This.InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def InstertBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			This.InsertSubStringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

			def InstertBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)
				return This.InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def SubStringInsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
		cResult = This.Copy().InsertSubStringBetweenCSQ(pcSubStr, p1, p2, pCaseSensitive).Content()
		return cResult

		def InsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.SubStringInsertedBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

	#== WITHOUT CASESENSITIVITY

	def InsertSubStringBetween(pcSubStr, p1, p2)
		This.InsertSubStringBetweenCS(pcSubStr, p1, p2, TRUE)

		#< @FunctionFluentForm

		def InsertSubStringBetweenQ(pcSubStr, p1, p2)
			This.InsertSubStringBetween(pcSubStr, p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBetween(pcSubStr, p1, p2)
			This.InsertSubStringBetween(pcSubStr, p1, p2)

			def InsertBetweenQ(pcSubStr, p1, p2)
				return This.InsertSubStringBetweenQ(pcSubStr, p1, p2)

		#>

	#-- @FunctionPassiveForm

	def SubStringInsertedBetween(pcSubStr, p1, p2)
		return This.SubStringInsertedBetweenCS(pcSubStr, p1, p2, TRUE)

		def InsertedBetween(pcSubStr, p1, p2)
			return This.SubStringInsertedBetween(pcSubStr, p1, p2)

	  #--------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO SUBSTRINGS   #
	#--------------------------------------------------#

	def InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
		if CheckParams()
			if NOT ( isString(pcSubStr) and isString(pcSubStr1) and isString(pcSubStr2) )
				StzRaise("Incorrect param types! pcSubStr, pcSubStr1 and pcSubStr2 must be all strings.")
			ok
		ok

		if EarlyChecks()
			if pcSubStr = "" or
			   pcSubStr1 = "" or
			   pcSubStr = ""

				return
			ok
		ok

		# Doing the job

		aSections = This.FindAnyBoundedByAsSectionsCS([ pcSubStr1, pcSubStr2 ], pCaseSensitive)
		This.ReplaceSections(aSections, pcSubStr)

		#< @FunctionFluentForm

		def InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

		#>	

		#< @FunctionAlternativeForm

		def InsertBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
			This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

			def InsertBetweenSubStringsCSQ(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
				return This.InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def InsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertSubStringBetweenSubStringsCSQ(pcSubStr, pcSubStr1, pcSubStr2, pCaseSensitive).Content()
		return cResult

		def SubStringInsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)
			return This.InsertedBetweenSubStringsCS(pcSubStr1, pcSubStr2, pcSubStr, pCaseSensitive)

	#== WITHOUT CASESENSITIVITY

	def InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

		This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		#< @FunctionFluentForm

		def InsertSubStringBetweensubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)
			This.InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			This.InsertSubStringBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

			def InsertBetweenSubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)
				return This.InsertSubStringBetweenSubStringsQ(pcSubStr, pcSubStr1, pcSubStr2)

		#>

	#-- @FunctionPassiveForm

	def InsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
		return This.InsertSubStringBetweenSubStringsCS(pcSubStr, pcSubStr1, pcSubStr2, TRUE)

		def SubStringInsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)
			return This.InsertedBetweenSubStrings(pcSubStr, pcSubStr1, pcSubStr2)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BETWEEN TWO POSITIONS   #
	#-------------------------------------------------#

	def InsertSubStringBetweenPositions(pcSubStr, n1, n2)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if isList(n1) and StzListQ(n1).IsPositionOrPositionsNamedParam()
				n1 = n1[2]
			ok

			if isList(n2) and StzListQ(n2).IsAndNamedParam()
				n2 = n2[2]
			ok

			if NOT (isNumber(n1) and isNumber(n2))
				StzRaise("Incorrect params types! n1 and n2 must be both numbers.")
			ok
		ok

		if EarlyChecks()
			if pcSubStr = "" or n1 < 0 or n2 > This.NumberOfChars()
				return
			ok
		ok

		# Doing the job

		This.ReplaceSection(n1, n2, pcSubStr)

		#< @FunctionFluentForm

		def InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2)
			This.InsertSubStringBetweenPositions(pcSubStr, n1, n2)
			return This
		#>

		#< @FunctionAlternativeForms

		def InsertBetweenPositions(pcSubStr, n1, n2)
			This.InsertSubStringBetweenPositions(pcSubStr, n1, n2)

			def InsertBetweenPositionsQ(pcSubStr, n1, n2)
				return This.InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2)

		#>

	#-- @FunctionPassiveForms

	def InstertedBetweenPositions(pcSubStr, n1, n2)
		cResult = This.Copy().InsertSubStringBetweenPositionsQ(pcSubStr, n1, n2).Content()

		def SubStringInstertedBetweenPositions(pcSubStr, n1, n2)
			return This.InstertedBetweenPositions(pcSubStr, n1, n2)

	  #------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS   #
	#================================================#

	def InsertBeforeEachNChars(n, pcSubStr)
		This.InsertBeforeEachNCharsXT(n, pcSubStr, :FromEndToStart)

		def InsertBeforeEachNCharsQ(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)
			return This

		def InsertSubStringBeforeEachNChars(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)

			def InsertSubStringBeforeEachNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEachNChars(n, pcSubStr)
				return This

	def SubStringInsertedBeforeEachNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEachNCharsQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS -- EXTENDED  #
	#-----------------------------------------------------------#

	def InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		This.InsertXT( pcSubStr, [ :After, :EachNChars = 3, :Going = :Forward ])

		def InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			return This

		def InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)

			def InsertSubStringBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
				This.InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
				return This

	def SubStringInsertedBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		cResult = This.Copy().InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection).Content()
		return cResult

	  #-------------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE OR AFTER A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def Insert(pcSubStr, pWhere)
		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pWhere)
			if Q(pWhere).IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pWhere[2], pcSubStr)
				return

			but Q(pWhere).IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pWhere[2], pcSubStr)
				return
			ok
		else
			This.InsertBefore(pWhere, pcSubStr)
		ok

		#< @FunctionFluentForm

		def InsertQ(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubString(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)

			def InserSubStringQ(pcsubStr, pWhere)
				This.InsertSubString(pcSubStr, pWhere)
				return This
		
		#>

	def SubStringInserted(pcSubStr, pWhere)
		cResult = This.Copy().InsetSubStringQ(pcSubStr, pWhere).Content()
		return cResult


	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE A GIVEN POSITION   #
	#----------------------------------------------------#

	/* Inserts a substring:

	 	- in a given position inside the string
	 	  Note: in this case, if nPos > NumberOfChars()
		  --> string is extended with white spaces

		- or, before the occurrence of a given substring
	*/
	 
	def InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)
		if isString(nPos)
			This.InsertSubstringBeforeSubStringCS(nPos, pcSubStr, pCaseSensitive)
			return

		but isList(nPos) and Q(nPos).IsListOfStrings()
			This.InsertSubStringsBeforeSubStringCS(nPos, pCSubStr, pCaseSensitive)
			return

		but isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertSubStringBeforePositions(nPos, pcSubStr)
			return
		ok

		# else

		if isList(nPos) and Q(nPos).IsPositionNamedParam()
			nPos = nPos[2]
		ok

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertBeforeThesePositions(nPos, pcSubStr)
			return
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		@oQString.insert(nPos-1, pcSubStr)

		# The string has changed, check constraints...
		//This.VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforePosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertBeforePositionQ(nPos, pcSubStr)
				This.InsertBeforePosition(nPos, pcSubStr)
				return This

		def InsertAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)
				return This

		def InsertAtPosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtPosiitonQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)
				return This

		#--

		def InsertSubStringBeforeCS(nPos, pcSubStr, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)

			def InsertSubStringBeforeCSQ(nPos, pcSubStr, pCaseSensitive)
				return This

		def InserSubStringtBeforePosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringBeforePositionQ(nPos, pcSubStr)
				This.InsertBeforePosition(nPos, pcSubStr)
				return This

		def InsertSubStringAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringAtQ(nPos, pcSubStr)
				This.InsertSubStringAt(nPos, pcSubStr)
				return This

		def InsertSubStringAtPosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringAtPosiitonQ(nPos, pcSubStr)
				This.InsertSubStringAt(nPos, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeCS(nPos, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforePosition(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		def SubStringInsertedAt(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		def SubStringInsertedAtPosition(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		#>

	#-- WITHOUT CASESENSITIVITY

	def InsertBefore(nPos, pcSubStr)
		This.InsertBeforeCS(nPos, pcSubStr, TRUE)

		def InsertBeforeQ(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)
			return This

		def InsertSubStringBefore(nPos, pcSubStr)
			This.InsertSubStringBeforeCS(nPos, pcSubStr, TRUE)

			def InsertSubStringBeforeQ(nPos, pcSubStr)
				This.InsertSubStringBefore(nPos, pcSubStr)
				return This

	def SubStringInsertedBefore(nPos, pcSubStr)
		cResult = This.Copy().InsertBeforeQ(nPos, pcSubStr).Content()
		return cResult

	   #-----------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A   #
	 #    GIVEN CONDITION APPLIED ON THE STRING SUBSTRINHGS      #
	#===========================================================#

	def InsertBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>
		
	def InsertedBeforeSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeSubStringsW(pcCondition, pcSubStr)
		return This.InsertBeforeSubStringsWCS(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWQ(pcCondition, pcSubStr)
			This.InsertBeforeSubStringsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeSubStringsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeSubStringsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING SUBSTRINGS -- WXT/EXTENDED   #
	#------------------------------------------------------------------#

	def InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeSubStringsWXT(pcCondition, pcSubStr)
		return This.InsertBeforeSubStringsWCSXT(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeSubStringsWXTQ(pcCondition, pcSubStr)
			This.InsertBeforeSubStringsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeSubStringsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeSubStringsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#========================================================#

	def InsertBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeCharsW(pcCondition, pcSubStr)
		return This.InsertBeforeCharsWCS(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeCharsWQ(pcCondition, pcSubStr)
			This.InsertBeforeCharsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeCharsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING CHARS -- WXT/EXTENDED        #
	#------------------------------------------------------------------#

	def InsertBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.InsertBeforePositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedBeforeCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertBeforeCharsWXT(pcCondition, pcSubStr)
		return This.InsertBeforeCharsWCSXT(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeCharsWXTQ(pcCondition, pcSubStr)
			This.InsertBeforeCharsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedBeforeCharsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeCharsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING AFTER A GIVEN POSITION    #
	#====================================================#

	def InsertAfter(nPos, pcSubStr)
		#< QtBased | Uses QString.insert() >

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertAtPositions(anPos, pcSubStr)
		ok

		@oQString.insert(nPos, pcSubStr)

		//VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertAfterQ(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAfterPosition(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertAfterePositionQ(nPos, pcSubStr)
				This.InsertAfterPosition(nPos, pcSubStr)
				return This

		def InsertSubStringAfter(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertSubStringAfterQ(nPos, pcSubStr)
				This.InsertSubStringAfter(nPos, pcSubStr)
				return This

		def InsertSubStringAfterPosition(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertSubStringAfterPositionQ(nPos, pcSubStr)
				This.InsertSubStringAfterPosition(nPos, pcSubStr)
				return This

		#>

	def SubStringInsertedAfter(nPos, pcSubStr)
		cResult = This.Copy().InsertAfterQ(nPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterPosition(nPos, pcSubStr)
			return This.SubStringInsertedAfter(nPos, pcSubStr)


	   #-----------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A   #
	 #    GIVEN CONDITION APPLIED ON THE STRING SUBSTRINHGS      #
	#===========================================================#

	def InsertAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterSubStringsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubStringsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterSubStringsW(pcCondition, pcSubStr)
		return This.InsertAfterSubStringsWCS(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterSubStringsWQ(pcCondition, pcSubStr)
			This.InsertAfterSubStringsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterSubStringsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterSubStringsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING SUBSTRINGS -- WXT/EXTENDED   #
	#------------------------------------------------------------------#

	def InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindSubStringsWCSXT(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterSubStringsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubStringsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterSubStringsWXT(pcCondition, pcSubStr)
		return This.InsertAfterSubStringsWCSXT(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterSubStringsWXTQ(pcCondition, pcSubStr)
			This.InsertAfterSubStringsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterSubStringsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterSubStringsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#========================================================#

	def InsertAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterCharsWCS(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterCharsW(pcCondition, pcSubStr)
		return This.InsertAfterCharsWCS(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterCharsWQ(pcCondition, pcSubStr)
			This.InsertAfterCharsW(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterCharsW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	   #------------------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER  A POSITION DEFINED BY A GIVEN    #
	 #    CONDITION  APPLIED ON THE STRING CHARS -- WXT/EXTENDED        #
	#------------------------------------------------------------------#

	def InsertAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.InsertAfterPositions( anPos, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive)
			This.InsertAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
			return This

		#>

	def InsertedAfterCharsWCSXT(pcCondition, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def InsertAfterCharsWXT(pcCondition, pcSubStr)
		return This.InsertAfterCharsWCSXT(pcCondition, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterCharsWXTQ(pcCondition, pcSubStr)
			This.InsertAfterCharsWXT(pcCondition, pcSubStr)
			return This

		#>

	def InsertedAfterCharsWXT(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterCharsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (BEFORE) EVERY N CHARS   #
	#===================================================#

	def InsertBeforeEveryNChars(n, pcSubStr)
		if CheckParams()
			if NOT isNumber(n)
				stzRaise("Incorrect param! n must be a number.")
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok
		ok

		nLen = StzStringQ(pcSubStr)
		anPos = []

		if n = 1
			anPos + 1

		else
		
			for i = (nLen + 1) to This.NumberOfChars() step n
				anPos + ( i - 1 )
			next
		ok

		This.InsertBeforeThesePositions(anPos, pcSubStr)

		#< @FunctionFluentForm

		def InsertBeforeEveryNCharsQ(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms
	
		def InsertSubStringBeforeEveryNChars(n, pcSubStr)
			This.InsertEveryNChars(n, pcSubStr)

			def InsertSubStringBeforeEveryNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEveryNChars(n, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeEveryNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEveryNCharsQ(n, pcSubStr).Content()
		return cResult

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (AFTER) EVERY N CHARS    #
	#---------------------------------------------------#

	def InsertAfterEveryNChars(n, pcSubStr)

		if CheckParams()

			if NOT isNumber(n)
				stzRaise("Incorrect param! n must be a number.")
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param! pcSubStr must be a string.")
			ok

		ok

		nLen = StzStringQ(pcSubStr).NumberOfChars()
		anPos = []

		if n > 1
			for i = 1 to This.NumberOfChars() - nLen - 1 step n
				anPos + ( i + 1 )
			next
		ok

		This.InsertAfterThesePositions(anPos, pcSubStr)

		#< @FunctionFluentForm

		def InsertAfterEveryNCharsQ(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertSubStringAfterEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)

		def InsertEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)
	
		def InsertSubStringEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertSubStringEveryNCharsQ(n, pcSubStr)
				return This.InsertAfterEveryNCharsQ(n, pcSubStr)

		#>

	def SubStringInsertedAfterEachNCHars(n, pcSubStr)
		cResult = This.Copy().InsertAfterEveryNCharsQ(n, pcSubStr).Content()
		return cResult

		def SubStringInsertedEveryNChars(n, pcSubStr)
			return This.SubStringInsertedAfterEachNCHars(n, pcSubStr)

	  #------------------------------------------------#
	 #   INSERTING A SUBSTRING AFTER MANY POSITIONS   #
	#================================================#

	 def InsertAfterPositions(panPos, pcSubStr)
		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPos = ring_sort(panPos)
		nLen = len(anPos)

		for i = nLen to 1 step -1
			This.InsertAfter(anPos[i], pcSubStr)
		next

		#< @FunctionFluentForm

		def InsertAfterPositionsQ(panPos, pcSubStr)
			This.InsertAfterPositions(panPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterManyPositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertAfterManyPositionsQ(panPos, pcSubstr)
				This.InsertAfterManyPositions(panPos, pcSubstr)
				return This

		def InsertAfterThesePositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertAfterThesePositionsQ(panPos, pcSubstr)
				This.InsertAfterThesePositions(panPos, pcSubstr)
				return This

		#--

		def InsertSubStringAfterPositions(panPos, pcSubStr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterPositionsQ(panPos, pcSubStr)
				This.InsertSubStringAfterPositions(panPos, pcSubStr)
				return This

		def InsertSubStringAfterManyPositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterManyPositionsQ(panPos, pcSubstr)
				This.InsertSubStringAfterManyPositions(panPos, pcSubstr)
				return This

		def InsertSubStringAfterThesePositions(panPos, pcSubstr)
			This.InsertAfterPositions(panPos, pcSubStr)

			def InsertSubStringAfterThesePositionsQ(panPos, pcSubstr)
				This.InsertSubStringAfterThesePositions(panPos, pcSubstr)
				return This

		#>

	def SubStringInsertedAfterThesePositions(anPos, pcSubStr)
		cResult = This.Copy().InsertAfterThesePositionsQ(panPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterManyPositions(anPos, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPos, pcSubStr)

		def SubStringInsertedAfterPositions(anPos, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPos, pcSubStr)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BEFORE MANY POSITIONS   #
	#-------------------------------------------------#

	 def InsertBeforePositions(panPos, pcSubStr)

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		anPos = StzListOfNumbersQ(panPos).SubStructFromEachQ(1).Content()
		This.InsertAfterThesePositions(anPos, pcSubStr)

		#< @FunctionFluentForm

		def InsertBeforePositionsQ(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeManyPositions(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)

		def InsertBeforeThesePositions(panPos, pcSubStr)

			This.InsertBeforePositions(panPos, pcSubStr)
			
		#--

		def InsertSubStringBeforePositions(panPos, pcSubStr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforePositionsQ(panPos, pcSubStr)
				This.InsertSubStringBeforePositions(panPos, pcSubStr)
				return This

		def InsertSubStringBeforeManyPositions(panPos, pcSubstr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforeManyPositionsQ(panPos, pcSubstr)
				This.InsertSubStringBeforeManyPositions(panPos, pcSubstr)
				return This

		def InsertSubStringBeforeThesePositions(panPos, pcSubstr)
			This.InsertBeforePositions(panPos, pcSubStr)

			def InsertSubStringBeforeThesePositionsQ(panPos, pcSubstr)
				This.InsertSubStringBeforeThesePositions(panPos, pcSubstr)
				return This

		#>

	def SubStringInsertedBeforeThesePositions(anPos, pcSubStr)
		cResult = This.Copy().InsertBeforeThesePositionsQ(panPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedBeforeManyPositions(anPos, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPos, pcSubStr)

		def SubStringInsertedBeforePositions(anPos, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPos, pcSubStr)


	  #-----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING BEFORE EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#=============================================================================#

	def InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(cSubStr, pCaseSensitive)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ( anPos ).AddToEachQ(nLenSubStr).Content()
			aParts = This.SplitBeforePositions(anPos)
	
			cResult = StzPairOfListsQ( aParts, ListOfNTimes(len(aParts)-1, pcNewSubStr) ).AlternateQ().ToStzListOfStrings().Concatenate()
		
			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
					return This

		#--

		def InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeSubstring(pcSubStr, pcNewSubStr)
		This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		def InsertBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE NTH       #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )


		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING AFTER EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#============================================================================#

	def InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		acParts = This.SplitCS(pcSubStr, pCaseSensitive)
		cResult = ""

		for i = 1 to len(acParts)-1
			cResult += (acParts[i] + pcSubStr + pcNewSubStr)
		next

		This.Update( cResult + acParts[ len(acParts) ] )

		#< @FunctionFluentForm

		def InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This	
	
		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def InsertAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#--

		def InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterSubstring(pcSubStr, pcNewSubStr)
		This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		def InsertAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedAfterEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER THE NTH   #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)

	   #-----------------------------------------------------#
	  #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION      #
	 #  BY CONCATNEATING THEM ACCORDING TO A GIVEN FORMAT  #
	#====================================================#

	def InsertSubstringsXT( nPos, aSubStr, paOptions)
		/*
		Example:
	
		o1 = new stzString("All our software versions must be updated!")
		# Defining the position of insertion
		nPosition = o1.PositionAfterSubstring("versions") + 1
			
		# Inserting the list of string using extended configuration
		? o1.InsertListOfSubstringsXT(
			nPosition, [ "V1", "V2", "V3", "V4", "V5" ],
			
			[
			:cInsertBeforOrAfter = :Before,
			:OpeningChar = "(",
			:ClosingChar = ")", 
		
			:MainSeparator = ",",
			:AddSpaceAfterSeparator = TRUE,
			
			:LastSeparator = "and",
			:AddLastToMainSeparator = TRUE,
			
			:SpaceOption = :optEnsureLeadingSpace + :optEnsureTrailingSpace
			])
	
		Gives :
		All our software versions (V1, V2, V3, V4, and V5) must be updated!
		*/
	
		# Setting the default options
			
		cInsertBeforeOrAfter = :Before
		cOpeningChar = "("
		cClosingChar = ")"
			
		cMainSeparator = ","
		bAddSpaceAfterSeparator = TRUE
					
		cLastSeparator = NULL
		bAddLastToMainSeparator = FALSE
			
		cSpaceOption = :AddLeadingSpace + :AddTrailingSpace
	
		# Verifying the syntax of the options provided
		if NOT ( len(paOptions) = 0 or
			 ( len(paOptions) = 1 and paOptions[1] = :Default) )
	
			aPossibleOptions = [ :InsertBeforeOrAfter, :OpeningChar, :ClosingChar, :MainSeparator,
				  :AddSpaceAfterSeparator, :LastSeparator, :AddLastToMainSeparator,
				  :SpaceOption ]
		
			oHash = new stzHashList(paOptions)
			aListOfProvidedOptions = oHash.Keys()
		
			oListOfProvidedOptions = new stzList(aListOfProvidedOptions)
		
			if NOT oListOfProvidedOptions.IsMadeOfSome(aPossibleOptions)
				stzRaise(stzStringError(:UnsupportedOptionsWhileInsertingListOfStrings))
			ok
		
			# If some options are provided then we take them
			#NOTE : if len(paOptions) = 0 or paOptions = [ :Default ] then we preserve
			# the default options already defined
				
			cInsertBeforeOrAfter = paOptions[ :InsertBeforeOrAfter ]	
			cOpeningChar = paOptions[ :OpeningChar ]
			cClosingChar = paOptions[ :ClosingChar ]
					
			cMainSeparator = paOptions[ :MainSeparator ]
			bAddSpaceAfterSeparator = paOptions[ :AddSpaceAfterSeparator ]
		
			cLastSeparator = paOptions[ :LastSeparator ]
			bAddLastToMainSeparator = paOptions[ :AddLastToMainSeparator ]
		
			cSpaceOption = paOptions[ :SpaceOption ]
		ok
	
		# At this level, all the options are defined
		# Beginning the substring construction but the opening char
	
		cSubStr = cOpeningChar
			
		# Checking the behavior of the first inserted substring in regard of adjacent left space

		if NOT cSpaceOption = :DoNothing
			if cSpaceOption = :AddLeadingSpace or
			   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
			   cSpaceOption = :AddTrailingSpace + :AddLeadingSpace
	
				if nPos > 1 and This.NthChar(nPos - 1) != " "
					cSubStr = " " + cOpeningChar
				ok
			ok
		ok
	
		# Looping over the list of strings to concatenate them
		# depending on the logic defined by the options
	
		for i = 1 to len(aSubStr)
			# we add the string itslef
			cSubStr += aSubStr[i]
	
			# while we are not on the last item, or
			# we are on the last item but we are not asked
			# to use an alternative separator at the end
	
			if i < len(aSubStr) - 1 OR
			   (i = len(aSubStr)-1 and cLastSeparator = NULL)
	
				# Add the main separator after each string
				cSubStr += cMainSeparator
	
				# Add space after separator if required
				if bAddSpaceAfterSeparator = TRUE
						cSubstr += " "
				ok	
	
			# When reaching the last string, and an alternative
			# separator must be used (it's not null), we check
			# if we should use this last separator alone or
			# in addition to the main separator
	
			but i = len(aSubStr) - 1
	
				if bAddLastToMainSeparator = TRUE
					cSubStr += cMainSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
	
				if cLastSeparator != NULL
					cSubStr += cLastSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
			ok		
		next
	
		# Add the closing char to get the final substring
	
		cSubStr += cClosingChar
	
		# Checking the option of leaving the trailing space
	
		if cSpaceOption = :AddTrailingSpace or
		   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
		   cSpaceOption = :AddTrailiningSpace + :AddLeadingSpace
	
			cSubStr += " "
		ok
	
		if cInsertBeforeOrAfter = :After
			nPos++
		ok

		# Doing the job!

		This.InsertBefore(nPos, cSubStr)
	
		#< @FunctionFluentForm
		
		def InsertSubstringsXTQ( nPos, aSubStr, paOptions)
			This.InsertSubstringsXT( nPos, aSubStr, paOptions)
			return This
		
		#>

		#< @FunctionAlternativeForms

		def InsertManyXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManyXTQ(nPos, aSubStr, paOptions)
				This.InsertManyXT(nPos, aSubStr, paOptions)
				return This

		def InsertManySubStringsXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManySubStringsXTQ(nPos, aSubStr, paOptions)
				This.InsertManySubStringsXT(nPos, aSubStr, paOptions)
				return This

		#>

	def SubstringsInsertedXT(nPos, aSubStr, paOptions)
		cResult = This.Copy().InsertSubstringsXTQ( nPos, aSubStr, paOptions).Content()
		return cResult

		def ManySubStringsInsertedXT(nPos, aSubStr, paOptions)
			return This.SubstringsInsertedXT(nPos, aSubStr, paOptions)

	  #-----------------------------------------------------------------------#
	 #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION BY CONCATNEATING THEM  #
	#=======================================================================#

	def InsertSubstrings(nPos, aSubStr)
		This.InsertSubstringsXT( nPos, aSubStr, [:Default] )
	
		#< @FunctionFluentForm
		
		def InsertSubstringsQ(nPos, aSubStr)
			This.InsertSubstrings(nPos, aSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#TODO: Add "These" as alternative of "Many"

		def InsertMany(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManyQ(nPos, aSubStr)
				This.InsertMany(nPos, aSubStr)
				return This

		def InsertManySubStrings(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManySubStringsQ(nPos, aSubStr)
				This.InsertManySubStrings(nPos, aSubStr)
				return This

		#>

	def SubstringsInserted(nPos, aSubStr)
		cResult = This.Copy().InsertSubstringsQ(nPos, aSubStr).Content()
		return cResult

		def ManySubStringsInserted(nPos, aSubStr)
			return This.SubstringsInserted(nPos, aSubStr)

	  #=================================================#
	 #     REPLACING ALL OCCURRENCES OF A SUBSTRING    #
	#=================================================#
	
	def ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = YES | @QtBased #>

		/* Example:
	
		StzStringQ("Tunis is the town of my memories.") {
			ReplaceAll("Tunis", "Niamey" )
			? Content()
		}
		#--> Niamey is the town of my memories.
	
		*/

		if CheckParams()

			# Checking the pcSubStr param
	
			if isList(pcSubStr)

				This.ReplaceManyCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return
			ok
	
			if NOT isString(pcSubstr)
				stzRaise("Incorrect param typs! pcSubstr must be a string.")
			ok
	
			# Checking the correctness of pcNewSubStr param
	
			if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithOrUsingOrByNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok

			if isList(pcNewSubStr)
				return This.ReplaceByManyCS(pcSubStr, pcNewSubStr[2], pCaseSensitive)
			ok

			#--

			bWellFormed = FALSE
	
			if isString(pcNewSubStr)
				bWellFormed = TRUE
			ok
	
			# Checking the correctness of pCaseSensitive param
	
			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
				stzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSe).")
			ok

		ok

		# Doing the job

		@oQString.replace_2(pcSubStr, pcNewSubStr, pCaseSensitive)

	
		#< @FunctionFluentForm
		
		def ReplaceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionMisspelledForm

		#TODO: Add Repalce as a misspelled form to all Replace...() functions

		def RepalceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Replace(pcSubStr, pcNewSubStr)
		This.ReplaceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm
		
		def ReplaceQ(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionMisspelledForm

		#TODO: Add Repalce as a misspelled form to all Replace...() functions

		def Repalce(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)

		#>

	def SubStringReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceSubStringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	  #---------------------------------#
	 #     REPLACING FIRST N CHARS     #
	#---------------------------------#

	def ReplaceFirstNChars(n, pcNewSubStr)
		This.ReplaceSection(1, n, pcNewSubStr)

		def ReplaceFirstNCharsQ(n, pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)
			return This

		def ReplaceNFirstChars(pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)

			def ReplaceNFirstCharsQ(pcNewSubStr)
				This.ReplaceNFirstChars(pcNewSubStr)
				return This

	def FirstNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceFirstNCharsQ(n, pcNewSubStr).Content()

		def NFirstCharsReplaced(pcNewSubStr)
			return This.FirstNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LAST N CHARS     #
	#--------------------------------#

	def ReplaceLastNChars(n, pcNewSubStr)
		This.ReplaceSection(This.NumberOfChars() - n + 1, :LastChar, pcNewSubStr)

		def ReplaceLastNCharsQ(n, pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)
			return This

		def ReplaceNLastChars(pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)

			def ReplaceNLastCharsQ(pcNewSubStr)
				This.ReplaceNLastChars(pcNewSubStr)
				return This

	def LastNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLastNCharsQ(n, pcNewSubStr).Content()

		def NLastCharsReplaced(pcNewSubStr)
			return This.LastNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LEFT N CHARS     #
	#--------------------------------#

	def ReplaceLeftNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceFirstNChars(n, pcNewSubStr)

		else
			This.ReplaceLastNChars(n, pcNewSubStr)
		ok

		def ReplaceLeftNCharsQ(n, pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)
			return This

		def ReplaceNLeftChars(pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)

			def ReplaceNLeftCharsQ(pcNewSubStr)
				This.ReplaceNLeftChars(pcNewSubStr)
				return This

	def LeftNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLeftNCharsQ(n, pcNewSubStr).Content()

		def NLeftCharsReplaced(pcNewSubStr)
			return This.LeftNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING RIGHT N CHARS    #
	#--------------------------------#

	def ReplaceRightNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceLastNChars(n, pcNewSubStr)

		else
			This.ReplaceFirstNChars(n, pcNewSubStr)
		ok

		def ReplaceRightNCharsQ(n, pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)
			return This

		def ReplaceNRightChars(pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)

			def ReplaceNRightCharsQ(pcNewSubStr)
				This.ReplaceNRightChars(pcNewSubStr)
				return This

	def RightNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceRightNCharsQ(n, pcNewSubStr).Content()

		def NRightCharsReplaced(pcNewSubStr)
			return This.RightNCharsReplaced(pcNewSubStr)

	  #-------------------------------#
	 #     REPLACING MIDDLE CHAR     #
	#-------------------------------#

	def ReplaceMiddleChar(pcNewSubStr)
		nPos = This.FindMiddleChar()
		This.ReplaceSection(nPos, nPos, pcNewSubStr)

		def ReplaceMiddleCharQ(pcNewSubStr)
			This.ReplaceMiddleChar(pcNewSubStr)
			return This

	def MiddleCharReplaced(pcNewSubStr)
		cResult = This.Copy().ReplaceMiddleCharQ(pcNewSubStr).Content()
		return cResult

	  #-------------------------------------------#
	 #     REPLACING MANY SUBSTRINGS AT ONCE     #
	#===========================================#

	def ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzString( "a + b - c / d = 0")
		o1.ReplaceMany( ["+", "-", "/" ], :By = "*" )
		? o1.Content()
	
		#--> "a * b * c * d = 0"	
		*/

		if CheckParams()

			if NOT ( isList(pacSubStr) and
				 @IsListOfStrings(pacSubStr) )
	
				stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
	
			if isList(pNewSubStr) and Q(pNewSubStr).IsWithOrByNamedParam()
				pNewSubStr = pNewSubStr[2]
			ok
	
			if isList(pNewSubStr)
				return This.ReplaceManyByManyCS(pacSubStr, pNewSubStr, pCaseSensitive)
			ok
	
			if NOT isString(pNewSubStr)
				stzRaise("Incorrect param type! pNewSubStr must be a string.")
			ok

		ok

		# Doing the job

		pacSubStr = Q(pacSubStr).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(pacSubStr)
		
		for i = 1 to nLen
			This.ReplaceCS( pacSubStr[i], pNewSubStr, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceTheseCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		def ReplaceAllOfTheseCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		def ReplaceManySubstringsCS(pacSubStr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceManySubstringsCSQ(pacSubStr, pNewSubstr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		#--

		def ReplaceSubStringsCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceManyCS(pacSubStr, pNewSubstr, pCaseSensitive)

			def ReplaceSubStringsCSQ(pacSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceManyCSQ(pacSubStr, pNewSubstr, pCaseSensitive)

		#>

	def ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
		acResult = This.Copy().ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def SubStringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def TheseSubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def TheseReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(pacSubstr, pcNewSubstr)
		This.ReplaceManyCS( pacSubstr, pcNewSubstr, TRUE )

		#< @FunctionFluentFormn

		def ReplaceManyQ(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)
			return This
		#>

		#< @FunctionAlternativeForm
	
		def ReplaceThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceAllOfThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceAllOfTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceManySubstrings(pacSubstr, pNewSubstr)
			This.ReplaceMany(pacSubstr, pNewSubstr)

			def ReplaceManySubstringsQ(pacSubstr, pNewSubstr)
				This.ReplaceManySubstrings(pacSubstr, pNewSubstr)
				return This

		#--

		def ReplaceSubStrings(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubStr, pNewSubstr)

			def ReplaceSubStringsQ(pacSubStr, pcNewSubStr)
				return This.ReplaceManyQ(pacSubStr, pNewSubstr)

		def ReplaceTheseSubStrings(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubStr, pNewSubstr)

			def ReplaceTheseSubStringsQ(pacSubStr, pcNewSubStr)
				return This.ReplaceManyQ(pacSubStr, pNewSubstr)


		#>

	def ManySubstringsReplaced(pacSubstr, pNewSubstr)
		acResult = This.Copy().ReplaceManySubstringsQ(pacSubstr, pNewSubstr).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def SubStringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def TheseSubstringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def TheseReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		#>

	  #--------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS  #
	#--------------------------------------------#

	def ReplaceByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE

		o1 = new stzString("ring php ruby ring python ring")
		o1.ReplaceByMany("ring", :By = [ "", "", "" ])
	
		? o1.Content() #--> " php ruby  python "

		*/

		if isList(pacNewSubStr) and Q(pacNewSubStr).IsWithOrByNamedParam()
			pacNewSubStr = pacNewSubStr[2]
		ok

		if NOT Q(pacNewSubStr).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nMin = Min([ len(anPos), len(pacNewSubStr) ])
	
		for i = nMin to 1 step -1
			n = anPos[i]
			cNewSubStr = pacNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceSubStringByManyCSQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringByManyCSQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplaceByTheseCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceByTheseSubStringsCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseSubStringsCS(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSQ(pcSubStr, pacNewSubStr, pCaseSensitive).Conten()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def TheseSubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisSubStringReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseSubStringsCS(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, pCaseSensitive)

		#>
		
	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pcSubStr, pacNewSubStr)
		This.ReplaceByManyCS(pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceByManyQ(pcSubStr, pacNewSubStr)
			return This.ReplaceByManyCSQ(pcSubStr, pacNewSubStr, TRUE)

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByMany(cSubStr, pacNewSubStr)
			This.ReplaceByMany(cSubStr, pacNewSubStr)

			def ReplaceSubStringByManyQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyQ(pcSubStr, pacNewSubStr)

		def ReplaceThisSubStringByMany(cSubStr, pacNewSubStr)
			This.ReplaceByMany(cSubStr, pacNewSubStr)

			def ReplaceThisSubStringByManyQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyQ(pcSubStr, pacNewSubStr)

		#--

		def ReplaceByThese(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceByTheseSubStrings(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByThese(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseSubStrings(cSubStr, pacNewSubStr)
			return This.ReplaceByMany(cSubStr, pacNewSubStr)

		#>

	#< @FunctionPassiveForms

	def ReplacedByMany(pcSubStr, pacNewSubStr)
		return This.ReplacedByManyCS(pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByMany(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		#--

		def ReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def SubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def TheseSubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisSubStringReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByThese(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseSubStrings(pcSubStr, pacNewSubStr)
			return This.ReplacedByMany(pcSubStr, pacNewSubStr)

		#>

	#>

	  #--------------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS -- EXTENDED (RETURN TO FIRST)  #
	#--------------------------------------------------------------------------#

	def ReplaceByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> "#1 php #2 ruby #1 python #2"

		*/

		if CheckParams()

			if isList(pacNewSubStr) and Q(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT Q(pacNewSubStr).IsListOfStrings()
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok

		ok

		# doing the job

		anPos = This.FindCSQ(pcSubStr, pCaseSensitive).SortedInDescending()
		nLen = len(anPos)

		acNewSubStrings = StzListQ(pacNewSubStr).SortedInDescending()
		nLen2 = len(acNewSubStrings)
	
		n = 0
		for i = 1 to nLen
			nPos = anPos[i]
			n++
			if n > nLen2
				n = 1
			ok

			cNewSubStr = acNewSubStrings[n]
			This.ReplaceSubStringAtPositionNCS(nPos, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

		#< @FunctionFluentForm

		def ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceSubStringByManyCSXTQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringByManyCSXTQ(cSubStr, pacNewSubStr, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplaceByTheseCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceByTheseSubStringsCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCSXT(cSubStr, pacNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringByTheseSubStringsCSXT(cSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplaceByManyCS(cSubStr, pacNewSubStr, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, pCaseSensitive).Conten()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		#--

		def ReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def SubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def TheseSubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def TheseSubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
 
		def ThisSubStringReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisSubStringReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		def ThisReplacedByTheseSubStringsCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, pCaseSensitive)

		#>
		
	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pcSubStr, pacNewSubStr)
		This.ReplaceByManyCSXT(pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceByManyXTQ(pcSubStr, pacNewSubStr)
			return This.ReplaceByManyCSXTQ(pcSubStr, pacNewSubStr, TRUE)

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringByManyXT(cSubStr, pacNewSubStr)
			This.ReplaceByManyXT(cSubStr, pacNewSubStr)

			def ReplaceSubStringByManyXTQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyXTQ(pcSubStr, pacNewSubStr)

		def ReplaceThisSubStringByManyXT(cSubStr, pacNewSubStr)
			This.ReplaceByManyXT(cSubStr, pacNewSubStr)

			def ReplaceThisSubStringByManyXTQ(cSubStr, pacNewSubStr)
				return This.ReplaceByManyXTQ(pcSubStr, pacNewSubStr)

		#--

		def ReplaceByTheseXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceByTheseSubStringsXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		def ReplaceThisSubStringByTheseSubStringsXT(cSubStr, pacNewSubStr)
			return This.ReplaceByManyXT(cSubStr, pacNewSubStr)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyXT(pcSubStr, pacNewSubStr)
		return This.ReplacedByManyCSXT(pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByManyXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		#--

		def ReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def SubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def TheseSubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def TheseSubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)
 
		def ThisSubStringReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisSubStringReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		def ThisReplacedByTheseSubStringsXT(pcSubStr, pacNewSubStr)
			return This.ReplacedByManyXT(pcSubStr, pacNewSubStr)

		#>

	#>

	  #------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS  #
	#------------------------------------------------------#

	def ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp ring kandaji")
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "", "", "" ])

		? o1.Content() #--> " qt  pyhton  csharp "
		*/

		if CheckParams()
	
			if isList(pacNewSubStr) and Q(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT (isList(pacNewSubStr) and @IsListOfStrings(pacNewSubStr))
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok

		ok

		# Doing the job

		acSubStr = StzListQ(pacSubStr).WithoutDuplication()	
		nLenSubStr = len(acSubStr)
		nLenNewSubStr = len(pacNewSubStr)

		if NOT ( nLenSubStr = nLenNewSubStr )
			StzRaise("Incorrect values! nLenSubStr and pacNewSubStr must have the same size.")
		ok

		for i = 1 to nLenSubStr
			This.ReplaceCS(acSubStr[i], pacNewSubStr[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceManyByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceManySubStringsByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceManySubStringsByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplaceByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSQ(pacSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringsReplaceByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplaceByManyCS(pacSubStr, pacNewSubStr, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(pacSubStr, pacNewSubStr)
		This.ReplaceManyByManyCS(pacSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceManyByManyQ(pacSubStr, pacNewSubStr)
			This.ReplaceManyByMany(pacSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByMany(pacSubStr, pacNewSubStr)
			This.ReplaceManyByMany(pacSubStr, pacNewSubStr)

			def ReplaceManySubStringsByManyQ(pacSubStr, pacNewSubStr)
				This.ReplaceManySubStringsByMany(pacSubStr, pacNewSubStr)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplaceByMany(pacSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceManyByManyQ(pacSubStr, pacNewSubStr).Content()
		return cResult

		def SubStringsReplaceByMany(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplaceByMany(pacSubStr, pacNewSubStr)

	#>

	  #------------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS -- XT  #
	#------------------------------------------------------------#
	# XT ~> Return to beginning if all the other substrings are replaced

	def ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp zai")
		o1.ReplaceManyByManyXT([ "ring", "softanza", "kandaji", "zai" ], :By = [ "", "" ])
		
		? o1.Content()
		#  qt  pyhton  csharp 

		*/

		if CheckParams()
	
			if isList(pacNewSubStr) and Q(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT (isList(pacNewSubStr) and @IsListOfStrings(pacNewSubStr))
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok	

		ok

		# Doing the job

		acSubStr = StzListQ(pacSubStr).WithoutDupplication()
		nLenSubStr = len(pacSubStr)
		nLenNewSubStr = len(pacNewSubStr)

		# Extending or shrinking acNewSubStr, if necessary, so it has
		# the same size as acSubStr

		if nLenNewSubStr < nLenSubStr
			acNewSubStr = pacNewSubStr
			n = 0
			for i = nLenNewSubStr + 1 to nLenSubStr
				n++
				if n > nLenNewSubStr
					n = 1
				ok
				acNewSubStr + pacNewSubStr[n]
			next
		else
			acNewSubStr = []
			for i = 1 to nLenSubStr
				acSubStr + pacNewSubStr[i]
			next
		ok

		# Calling the noral function

		This.ReplaceManyByManyCS(acSubStr, acNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceManyByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceManySubStringsByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceManySubStringsByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplaceByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSXTQ(pacSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringsReplaceByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)
			return This.ManySubStringsReplaceByManyCSXT(pacSubStr, pacNewSubStr, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByManyXT(pacSubStr, pacNewSubStr)
		This.ReplaceManyByManyCSXT(pacSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceManyByManyXTQ(pacSubStr, pacNewSubStr)
			This.ReplaceManyByManyXT(pacSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManySubStringsByManyXT(pacSubStr, pacNewSubStr)
			This.ReplaceManyByManyXT(pacSubStr, pacNewSubStr)

			def ReplaceManySubStringsByManyXTQ(pacSubStr, pacNewSubStr)
				This.ReplaceManySubStringsByManyXT(pacSubStr, pacNewSubStr)
				return This

		#>

	#< @FunctionPassiveForm

	def ManySubStringsReplaceByManyXT(pacSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceManyByManyXTQ(pacSubStr, pacNewSubStr).Content()
		return cResult

		def SubStringsReplaceByManyXT(pacSubStr, pacNewSubStr)
			return This.ManySubStringsReplaceByManyXT(pacSubStr, pacNewSubStr)

	#>

	  #------------------------------------------#
	 #     REPLACING SUBSTRING AT POSITION N    #
	#==========================================#

	def ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect pram type! pcSubStr must be a string.")
			ok
		ok

		# Doing the job

		nLen = StzStringQ(pcSubStr).NumberOfChars()

		if This.RangeQ(n, nLen).IsEqualToCS(pcSubStr, pCaseSensitive)
			This.ReplaceRange(n, nLen, pcNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#--

		def ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			if isList(n)
				This.ReplaceSubStringAtPositionsCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return
			ok

			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubStringAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	def SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def SubStringAtPositionReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplacedAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplacedAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
				return This

		def ReplaceAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceAtPositionQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)

		#--

		def ReplaceAt(n, pcSubStr, pcNewSubStr)
			This.ReplaceAtCS(n, pcSubStr, pcNewSubStr, TRUE)

			def ReplaceAtQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceAtQCS(n, pcSubStr, pcNewSubStr, TRUE)

		def ReplaceSubStringAt(n, pcSubStr, pcNewSubStr)
			This.ReplaceAt(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtQ(n, pcSubStr, pcNewSubStr)
				return This.ReplaceAtQ(n, pcSubStr, pcNewSubStr)

		#>

	def SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, TRUE).Content()
		return cResult

		#< @FunctionalternativeForms

		def SubStringAtPositionReplaced(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		def ReplacedAtPosition(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		def SubStringReplacedAtPosition(n, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)

		#--

		def ReplacedAt(n, pcSubStr, pcNewSubStr)
			cResult = This.Copy().ReplaceAtCSQ(n, pcSubStr, pcNewSubStr, TRUE).Content()
			return cResult

		def SubStringReplacedAt(n, pcSubStr, pcNewSubStr)
			return This.ReplacedAt(n, pcSubStr, pcNewSubStr)

		#>

	  #--------------------------------------------------------------#
	 #   REPLACING A SUBSTRING OCCURRENCES BY AN OTHER SUBSTRING    #
	#--------------------------------------------------------------#

	def ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring ruby ring php ring")
		o1.ReplaceSubstringAtPositions([ 1, 20 ], "ring", :By = "")

		? o1.Content()
		#--> " ruby ring php "
		*/

		anPos = StzListQ(panPos).SortedInDescending()
		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceSubStringAtPositionNCS(anPos[i], pcSubStr, pcNewSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
		
		#>

	def SubStringAtPositionsReplacedCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def ReplacedAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionsReplacedCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringReplacedAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionsReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtPositions(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositions(panPos, pcSubStr, pcNewSubStr)

			def ReplaceAtPositionsQ(panPos, pcSubStr, pcNewSubStr)
				return This.ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)

		#>

	def SubStringAtPositionsReplaced(panPos, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)
		return cResult

		#< @FunctionAlternativeforms

		def ReplacedAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionsReplaced(panPos, pcSubStr, pcNewSubStr)

		def SubStringReplacedAtPositions(panPos, pcSubStr, pcNewSubStr)
			return This.SubStringAtPositionsReplaced(n, pcSubStr, pcNewSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING AT A SOME GIVEN POSITIONS BY MANY OTHER SUBSTRINGS    #
	#-------------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE 1
		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceSubstringAtPositionsByMany([ 10, 20, 32], "ring", :By = [ "", "", "" ])

		? o1.Content() #--> "ring php  ruby  python  csharp ring"

		EXAMPLE 2

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrencesByMany([ 1, 3, 5], "ring", :By = [ "#1", "#3", "#5" ])
	
		? o1.Content() #--> "#1 php ring ruby #3 python ring csharp #5"
		*/

		if CheckParams()

			if isList(pacNewSubStr) and Q(pacNewSubStr).IsWithOrByNamedParam()
				pacNewSubStr = pacNewSubStr[2]
			ok
	
			if NOT ( isList(pacNewSubStr) and @IsListOfStrings(pacNewSubStr) )
				stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
			ok

		ok

		# Keeping only the adequate number of positsions and new substrings
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new substrings

		nMin = Min([ len(panPos), len(pacNewSubStr) ])

		anPos 	= Q(panPos).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings	= Q(pacNewSubStr).SectionQ(1, nMin).SortedInDescending()

		# Doing the job

		for i = 1 to nMin
			nPos = anPos[i]
			cNewSubStr = acNewSubStrings[i]

			This.ReplaceSubStringAtPositionNCS(nPos, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

	#< @FunctionPassiveForms

	def SubStringAtThesePositionsReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionsByMany(panPos, pcSubStr, pacNewSubStr)
		This.ReplaceSubStringAtPositionsByManyCS(panPos, pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceSubStringAtPositionsByManyQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceSubStringAtPositionsByMany(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

	#< @FunctionPassiveForm

	def SubStringAtThesePositionsReplacedByMany(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult

	#>

	  #-----------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#=======================================================================#

	def ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionsCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesCSQ(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceTheseOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def OccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
		aResult = This.Copy().ReplaceOccurrencesCSQ(panPos, pcSubStr, pcNewSubStr, pCaseSensitive).Content()
		return aResult

		def TheseOccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedCS(panOccurr, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)
		This.ReplaceOccurrencesCS(panOccurr, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionsQ(panPos, pcSubStr, pcNewSubStr)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrences(panOccurr, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurr, pcSubStr, pcNewSubStr)

			def ReplaceTheseOccurrencesQ(panOccurr, pcSubStr, pcNewSubStr)
				This.ReplaceTheseOccurrences(panOccurr, pcSubStr, pcNewSubStr)
				return This

		#>

	def OccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)
		aResult = This.Copy().ReplaceOccurrencesQ(panPos, pcSubStr, pcNewSubStr).Content()
		return aResult

		def TheseOccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)
			return This.OccurrencesReplaced(panOccurr, pcSubStr, pcNewSubStr)

	  #-----------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsByManyCS(anPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesByManyCSQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceTheseOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	def OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def TheseOccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
		this.ReplaceOccurrencesByManyCS(panOccurr, pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceTheseOccurrencesByManyQ(panOccurr, pcSubStr, pacNewSubStr)
				This.ReplaceTheseOccurrencesByMany(panOccurr, pcSubStr, pacNewSubStr)
				return This

		#>

	def OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceOccurrencesByManyQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult 

		def TheseOccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByMany(panPos, pcSubStr, pacNewSubStr)

	  #-----------------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS -- XT  #
	#-----------------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsByManyCSXT(anPos, pcSubStr, pacNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)

			def ReplaceTheseOccurrencesByManyCSXTQ(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				This.ReplaceTheseOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, pCaseSensitive)
				return This

		#>

	def OccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSXTQ(panPos, pcSubStr, pacNewSubStr, pCaseSensitive).Content()
		return cResult

		def TheseOccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)
			return This.OccurrencesReplacedByManyCSXT(panPos, pcSubStr, pacNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
		this.ReplaceOccurrencesByManyCSXT(panOccurr, pcSubStr, pacNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panPos, pcSubStr, pacNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
			This.ReplaceOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)

			def ReplaceTheseOccurrencesByManyXTQ(panOccurr, pcSubStr, pacNewSubStr)
				This.ReplaceTheseOccurrencesByManyXT(panOccurr, pcSubStr, pacNewSubStr)
				return This

		#>

	def OccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)
		cResult = This.Copy().ReplaceOccurrencesByManyXTQ(panPos, pcSubStr, pacNewSubStr).Content()
		return cResult 

		def TheseOccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)
			return This.OccurrencesReplacedByManyXT(panPos, pcSubStr, pacNewSubStr)

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubString@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content() #--> "#1 php #2 ruby #3 pyhton #4"

		*/

		if isList(pcDynamicStr) and Q(pcDynamicStr).IsWithOrByNamedParam()
			pcDynamicStr = pcDynamicStr[2]
		ok

		if NOT isString(pcDynamicStr)
			stzRaise("Incorrect param! pacNewSubStr must be a list of strings.")
		ok	

		anPos = This.FindAllCSQ(pcSubStr, pCaseSensitive).SortedInDescending()


		@SubString = pcSubStr

		@NumberOfOccurrences = len(anPos)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		acNewSubStr = []

		for @Position in anPos

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPos[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPos[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicStr = StzStringQ(pcDynamicStr).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempStr = ( ' + cDynamicStr + ' )'
			eval(cCode)

			acNewSubStr + cTempStr

		next

		acNewSubStr = StzListQ(acNewSubStr).SortedInDescending()
	
		i = 0
		for @Position in anPos
			i++
			cNewSubStr = acNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(@Position, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringCS@Q(pcSubStr, pcDynamicStr, pCaseSensitive)
			This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubString@(pcSubStr, pcDynamicStr)
		This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, TRUE)

		def ReplaceSubString@Q(pcSubStr, pcDynamicStr)
			This.ReplaceSubString@(pcSubStr, pcDynamicStr)
			return This

	  #---------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION   #
	#===================================================#

	#TODO : Generalize the CS check to all W() functions in the library

	def ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringW("ring", :Where = '{ Q(@i).IsMultipleOf(10) }', :With = "")

		? o1.Content() #--> "ring php  ruby  pyhton ring"

		*/

		aSections = This.FindSubStringWCSZZ(pcSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		def ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringReplacedWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, TRUE)

		def ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
			return This

	def SubStringReplacedW(pcSubStr, pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------#

	def ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringWXT("ring", :Where = '{ Q(@Position).IsMultipleOf(10) }', :With = "")

		? o1.Content() #--> "ring php  ruby  pyhton ring"

		*/

		aSections = This.FindSubStringWCSXTZZ(pcSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		def ReplaceSubStringWCSXTQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringReplacedWCSXT(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringWCSXTQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringWXT(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCSXT(pcSubStr, pcCondition, pcNewSubStr, TRUE)

		def ReplaceSubStringWXTQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringWXT(pcSubStr, pcCondition, pcNewSubStr)
			return This

	def SubStringReplacedWXT(pcSubStr, pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringWXTQ(pcSubStr, pcCondition, pcNewSubStr).Content()
		return cResult

	  #---------------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS) #
	#=======================================================================================#

	def ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

		#>

		#< @FunctionALternativeForm

		def ReplaceThisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

			def ReplaceThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
				return This.ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		#>

		#< @FunctionPassiveForm

		def SubStringBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			cResult = This.Copy().ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive).Content()
			return cResult

		#>

	#--- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, TRUE)

		#< @FunctionFluentForm

		def ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

		#>

		#< @FunctionALternativeForm

		def ReplaceThisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

			def ReplaceThisBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
				return This.ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		#>

		#< @FunctionPassiveForm

		def SubStringBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			cResult = This.Copy().ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr).Content()
			return cResult

		#>

	  #-----------------------------------------------------------------------#
	 #  REPLACING THE SUBSTRING BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  #
	#-----------------------------------------------------------------------#

	def ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		if CheckParams()
			if NOT ( @BothAreStrings(pcBound1, pcBound2) or @BothAreNumbers(pcBound1, pcBound2) )
				StzRaise("Incorrect params types! pcBound1, pcBound2 must be both strings or numbers.")
			ok
		ok

		n1 = 0
		n2 = 0

		if @BothAreStrings(pcBound1, pcBound2)

			n1 = This.FindFirstCS(pcBound1, pCaseSensitive)
			if n1 = 0
				return
			else
				n1 += StzStringQ(pcBound1).NumberOfChars()
			ok

			n2 = This.FindFirstCS(pcBound2, pCaseSensitive)
			if n2 = 0
				return
			else
				n2 += StzStringQ(pcBound2).NumberOfChars() - 1
			ok

		else // @BothAreNumbers

			n1 = pcBound1
			n2 = pcBound2

			if n1 = 0 or n1 = This.NumberOfChars() Or n2 < 2 or n1 = n2
				return
			ok
				
			n1++
			n2--

		ok

		This.ReplaceSection(n1, n2, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceBetweenCS(pcBound1, pcBound2, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

		#>


	#------------

	#TODO
	#Add
	# def ReplaceIBS() # Include Bounds Starting At

	  #----------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A GIVEN SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#==================================================================================#

	def ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
		return This.ReplaceSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceThisSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByQ(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- IB() #
	#-----------------------------------------------------------------------------------#
	# ~> Bounds are also replaced not only the sunstrings

	def ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)
	
		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceSubStringsBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringsBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceThisSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceThisSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
		This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternataiveForms

		def ReplaceSubStringsBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceSubStringsBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)

		def ReplaceThisSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)

			def ReplaceThisSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				return This.ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#===========================================================#

	def ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceAnySubStringsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnySubStringsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnyBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)
		return This.ReplaceAnySubStringBoundedByCS(pacBounds, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceSubStringsBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceSubStringsBoundedByQ(pacBounds, pcNewSubStr)
				This.ReplaceSubStringsBoundedBy(pacBounds, pcNewSubStr)
				return This

		def ReplaceAnySubStringsBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceAnySubStringsBoundedByQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)

		def ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pacBounds, pcNewSubStr)

			def ReplaceAnyBoundedByQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByQ(pacBounds, pcNewSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#
	# ~> Bounds are also replaced not only the sunstrings

	def ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnySubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnySubStringsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceAnyBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
				return This.ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)
		return This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnySubStringsBoundedByIB(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)

			def ReplaceAnySubStringsBoundedByIBQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)

		def ReplaceAnyBoundedByIB(pacBounds, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pacBounds, pcNewSubStr)

			def ReplaceAnyBoundedByIBQ(pacBounds, pcNewSubStr)
				return This.ReplaceAnySubStringBoundedByIBQ(pacBounds, pcNewSubStr)

		#>

	  #==============================================================#
	 #  REPLACING A SUBSTRING -- EXTENDED (NNC : NEAR-NATURAL CODE  #
	#==============================================================#

	def ReplaceCSXT(p1, p2, p3, pCaseSensitive)

		# Q("/\__/\/\__/\__").ReplaceXT("", [], :With = "*")
		if ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		   ( ( (isList(p2)   and len(p2) = 0) or
		     ( isString(p2) and p2 = "") or
		     (isNumber(p2) and p2 = 0) ) ) AND

		   ( isString(p3) or (isList(p3)   and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCS(p1, p3, pCaseSensitive)
			return

		#  Q("*** rin* ***").ReplaceXT("*", :In = "rin*", :With = "g")
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and
		    ( isList(p2) and Q(p2).IsInOrInSideNamedParam() )
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1)
				p1 = p1[2] // "*"
			ok

		 	p2 = p2[2] // "rin*"

			if isList(p3)
				p3 = p3[2] // "g"
			ok

			cNewSubStr = Q(p2).ReplaceCSQ(p1, p3, pCaseSensitive).Content() // "ring"

			aSections = This.FindAsSectionsCS(p2, pCaseSensitive)
			This.ReplaceSections(aSections, cNewsubStr)


		# Q("/\__/\/\__/\__").ReplaceXT("", :With = "*", [])
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		    ( isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam() ) ) AND

		    ( ( (isList(p3)   and len(p3) = 0) or
		      (isString(p3) and p3 = "") or
		      (isNumber(p3) and p3 = 0) ) )

			This.ReplaceCS(p1, p2, pCaseSensitive)
			return

		# Q("_/\__/\__/__/\_").ReplaceXT(:Nth = 4, "", :With = "\")
		but ( isNumber(p1) or
		    ( isList(p1) and Q(p1).IsNthNamedParam() ) ) and

		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and

		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1) and Q(p1).IsNthNamedParam()
				p1 = p1[2]
			ok

			This.ReplaceNthCS(p1, p2, p3, pCaseSensitive)

		# Q("_/\__/\__/__/\_").ReplaceXT(:First, "", :With = "\")
		but ( isString(p1) and p1 = :First) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCSXT(1, p2, p3, pCaseSensitive)

		# Q("_/\__/\__/__/\_").ReplaceXT(:Last, "", :With = "\")
		but ( isString(p1) and p1 = :Last) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
			This.ReplaceCSXT(n, p2, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :AtPosition = 2, :With = "_")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtPositionNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionNamedParam()
				p2 = p2[2]
			ok
			
			This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :AtPositions = [2, 7], :With = "~")
		but ( isString(p1) ) and

		    ( (isList(p2) and Q(p2).IsListOfNumbers() ) or
		      (isList(p2) and Q(p2).IsAtPositionsNamedParam()) ) and

		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionsNamedParam()
				p2 = p2[2]
			ok

			This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :At = [2, 7], :With = "~")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtNamedParam()
				p2 = p2[2]
			ok

			if isNumber(p2)
				This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

			but isList(p2) and Q(p2).isListOfNumbers()
				This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)
			ok

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :Between = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok
			
		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedBy = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCS(p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCSIB(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok

		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCSIB(p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT("", :Between = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCS(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok
			
		# Q("Bla bla //, and bla!").ReplaceXT("", :BoundedBy = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCS(p1, p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCSIB(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok

		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCSIB(p1, p2, p3, pCaseSensitive)

		#--
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		#-- Allowing :BoundedBy along with :Between

		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			but isString(p2)

				This.ReplaceAnyBetweenCS(p2, p2, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a string, or a pair of strings or numbers.")
			ok
			
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok

		ok

	#-- WITHOUT CASESENSITIVITY

	def ReplaceXT(p1, p2, p3)
		This.ReplaceCSXT(p1, p2, p3, TRUE)

	  #-----------------------------------------------------------------------#
	 #  REPLACING ALL SUBSTRINGS EXCEPT THOSE PROVIDED BY A GIVEN SUBSTRING  #
	#=======================================================================#

	def ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("--Ring--&__Softanza__")

		o1.ReplaceAllExcept([ "Ring", "&", "Softanza" ], :With = AHeart() )
		? o1.Content()
		#--> Ring&Softanza

		*/

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionAlternativeForms

		def ReplaceSubStringsExceptCSZ(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsOtherThanCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsOtherThanCSZ(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllButCS(pacSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)
		This.ReplaceSubStringsExceptCS(pacSubStr, pcNewSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ReplaceSubStringsExceptZ(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceSubStringsOtherThan(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceSubStringsOtherThanZ(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceExcept(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceAllExcept(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		def ReplaceAllBut(pacSubStr, pcNewSubStr)
			This.ReplaceSubStringsExcept(pacSubStr, pcNewSubStr)

		#>

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
	
		o1 = new stzString("...12...1212...121212...")
		? o1.SubStringsMadeOf("12")
		#--> [ "12", "1212", "121212" ]
	
		*/
	
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)
		
		return acResult
		
		def MadeOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOf(pcSubStr)
		return This.SubStringsMadeOfCS(pcSubStr, TRUE)
	
		def MadeOf(pcSubStr)
			return This.SubStringsMadeOf(pcSubStr)

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = This.SectionsXT(aSections)
		return aResult

		def MadeOfCSXT(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOfXT(pcSubStr)
		return This.SubStringsMadeOfCSXT(pcSubStr, TRUE)
	
		def MadeOfXT(pcSubStr)
			return This.SubStringsMadeOfXT(pcSubStr)

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anResult = [ anPos[1] ]
		for i = 2 to nLen
			if anPos[i] - anPos[i-1] = nLenSubStr
				loop
			ok

			anResult + anPos[i]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		#--

		def FindMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCSZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMadeOf(pcSubStr)
		return This.FindMadeOfCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		#--

		def FindMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOfZ(pcSubStr)
			return This.FindMadeOf(pcSubStr)
		#>

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		#                      4   8 1   4 6 8   2
		o1 = new stzString("...12..1212..121212..12.")
		? @@( o1.FindMadeOf("12") )
		#--> [ 4, 8, 10, 14, 16, 18 ]

		*/

		# Preparing some values we need

		nLenStr = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		cFirstChar = Q(pcSubStr).FirstChar()

		# Finding the positions of pcSubStr in the string

		anPos = This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenPos = len(anPos)

		aResult = []
		
		# For each position
		for i = 1 to nLenPos

			# we start parsing the string from that position
			n = anPos[i]
			nNext = 0
			if i < nLenPos
				nNext = anPos[i+1]
			ok

			# if the char we are parsing does not belong to
			# pcSubStr, then we stop the parsing and return
			# the section (done for each position)

			while TRUE
				n += nLenSubStr
				if n > nLenStr or
				   (nNext != 0 and n >= nNext)
					exit
				ok
		
				if NOT This.CharQ(n).IsEqualToCS(cFirstChar, pCaseSensitive)
					aTempSection = [ anPos[i], (n-1) ]

					if len(aResult) > 0 and
					   anPos[i] = aResult[len(aResult)][1]

						aResult[len(aResult)][2] = (n-1)

					else
						aResult + [ anPos[i], (n-1) ]
					ok
				ok

				
			end
		next
		
		return aResult

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfCSZZ(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#--  WITHOUT CASESENSITIVITY

	def FindMadeOfAsSections(pcSubStr)
		return This.FindMadeOfAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		#--

		def FindMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def FindSubStringsMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfZZ(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		#>

	  #==============================================================#
	 #   REPLACING A CHAR AT A GIVEN POSITION BY A GIVEN SUBSTRING  #
	#==============================================================#

	#TODO : Add case sensitivity

	def ReplaceCharAtPosition(n, pcNewSubStr)
		#< @MotherFunction = ReplaceSection() > @QtBased = TRUE #>

		This.ReplaceSection(n, n, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceCharAtPositionQ(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceCharAt(n, pcNewSubStr)
			if isList(n) and Q(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtQ(n, pcNewSubStr)
				This.ReplaceCharAt(n, pcNewSubStr)
				return This

		def ReplaceCharAtPositionN(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceCharAtThisPosition(n, pcNewSubStr)
				return This

		#--

		def ReplaceAnyCharAtPosition(pc, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtPositionQ(pc, pcNewSubStr)
				This.ReplaceAnyCharAtPosition(pc, pcNewSubStr)
				return This

		def ReplaceAnyCharAt(n, pcNewSubStr)
			if isList(n) and Q(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtQ(n, pcNewSubStr)
				This.ReplaceAnyCharAt(n, pcNewSubStr)
				return This

		def ReplaceAnyCharAtPositionN(n, pcNewSubStr)
			This.ReplaceAnyCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceAnyCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceAnyCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceAnyCharAtPosition(n, pcNewSubStr)

			def ReplaceAnyCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceAnyCharAtThisPosition(n, pcNewSubStr)
				return This

		#>

	def CharReplacedAtPosition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		cResult = This.Copy().ReplaceCharAtPositionQ(n, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharReplacedAtThisPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def CharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		#--

		def AnyCharReplacedAtPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def AnyCharReplacedAtThisPosition(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		def AnyCharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPosition(n, pcNewSubStr)

		#>

		#TODO: Add Position as a misspelling of Position
		#TODO: Add Repalce as misspelling of Replace

	  #-------------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	#TODO : Add case sensitivity

	def ReplaceCharsAtPositions(panPos, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(panPos) and len(panPos) = 0
			return
		ok

		# Checking the correctness of panPos param

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param! panPos must be list of numbers.")
		ok

		anPos = Q(panPos).SortedInDescending()

		for n in anPos
			This.ReplaceCharAtPositionN(n, pcNewSubStr)
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsQ(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAt(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceCharsAtThesePositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#--

		def ReplaceAnyCharsAtPositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceAnyCharsAt(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		def ReplaceAnyCharsAtThesePositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#>

		#< @FunctionMisspelledForm

		def RepalceCharsAtPositions(panPos, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPos, pcNewSubStr)

		#>

	def CharsReplacedAtPositions(panPos, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsQ(panPos, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharsReplacedAtThesePositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def CharsAtThesePositionsReplaced(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		#--

		def AnyCharsReplacedAtPositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def AnyCharsReplacedAtThesePositions(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		def AnyCharsAtThesePositionsReplaced(panPos, pcNewSubStr)
			return This.CharsReplacedAtPositions(panPos, pcNewSubStr)

		#>
	  #-----------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	#TODO: Add case sensitivity

	def ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE
		o1 = new stzString("ab3de6gh9")
		o1.ReplaceCharsAtPositionsByMany([3, 6, 9], [ "c", "f", "i" ])

		? o1.Content() #--> "abcdefghi"
		*/

		anPos = StzListOfNumbersQ(panPos).SortedInDescending()

		nMin = Min([ len(anPos), len(pacNewSubStr) ])
		anPos = StzListQ(anPos).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStr).SectionQ(1, nMin).SortedInDescending()

		i = 0

		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceCharAtPosition(anPos[i], acNewSubStrings[i])
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsByManyQ(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAtByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceCharsAtThesePositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		#--

		def ReplaceAnyCharsAtPositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceAnyCharsAtByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		def ReplaceAnyCharsAtThesePositionsByMany(panPos, pacNewSubStr)
			This.ReplaceCharsAtPositionsByMany(panPos, pacNewSubStr)

		#>

	def CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsByManyQ(panPos, pacNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharsReplacedAtThesePositionsByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def CharsAtThesePositionsReplacedByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		#--

		def AnyCharsReplacedAtPositionsByMany(panPos, pacNewSubStr)
			This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def AnyCharsReplacedAtThesePositionsByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		def AnyCharsAtThesePositionsReplacedByMany(panPos, pacNewSubStr)
			return This.CharsReplacedAtPositionsByMany(panPos, pacNewSubStr)

		#>

		#TODO: Add Positions as a misspelling of Positions

	  #--------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#====================================================================#

	#TODO # Add case sensitivty

	def ReplaceCharsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		#< @MotherFunctions:
		#	This.FindCharsW() > @RingBased
		#	This.ReplaceSection() > @QtBased
		#>

		/*
		Example:

		StzStringQ( "Text processing with Ring" ) {

			ReplaceAllCharsW(
				:Where = '{ This[@i] = "i" }',
				:With = "*"
			)

			? Content()
		}

		--> Returns: "Text process*ng w*th R*ng"
		*/

		# Checking the correctness of the pcCondition param
			#--> Not necessary! It will be done by the
			# mother function FindAllCharsW()

		# Checking the correctness of the pcNewSubStr param
			#--> Not necceary! It will be done by the
			# called function ReplaceCharsAtPositions()

		# Doing the job

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.ReplaceCharsAtPositions(anPos, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceCharsWCSQ(pCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceCharsWCS(pCondition, pcNewSubStr, pCaseSensitive)
			return This

		#>

	def CharsReplacedWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceCharsWCSQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceCharsW(pcCondition, pcNewSubStr)
		This.ReplaceCharsWCS(pcCondition, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceCharsWQ(pCondition, pcNewSubStr)
			This.ReplaceCharsW(pCondition, pcNewSubStr)
			return This

		#>

	def CharsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------#

	def ReplaceCharsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.ReplaceCharsAtPositions(anPos, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceCharsWCSXTQ(pCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceCharsWCSXT(pCondition, pcNewSubStr, pCaseSensitive)
			return This

		#>

	def CharsReplacedWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceCharsWCSXTQ(pcCondition, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceCharsWXT(pcCondition, pcNewSubStr)
		This.ReplaceCharsWCSXT(pcCondition, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceCharsWXTQ(pCondition, pcNewSubStr)
			This.ReplaceCharsWXT(pCondition, pcNewSubStr)
			return This

		#>

	def CharsReplacedWXT(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsWXTQ(pcCondition, pcSubStr).Content()
		return cResult

	  #-------------------------------------------------------------------------------#
	 #  REPLACING ALL SUSBSTRINGS OBEYING TO A GIVEN CONDITION BY A GIVEN SUBSTRING  #
	#===============================================================================#

	def ReplaceSubStringsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringsAsSectionsWCS(pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		def ReplaceSubStringsWCSQ(pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsWCS(pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringsReplacedWCS(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringsWCSQ(pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsW(pcCondition, pcNewSubStr)
		This.ReplaceSubStringsCSW(pcCondition, pcNewSubStr, TRUE)

		def ReplaceSubStringsWQ(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsW(pcCondition, pcNewSubStr)
			return This

	def SubStringsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringsWQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #-----------------------------------------------------------------------------------------------#
	 #  REPLACING ALL SUSBSTRINGS OBEYING TO A GIVEN CONDITION BY A GIVEN SUBSTRING -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------------------------#

	def ReplaceSubStringsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		aSections = This.FindSubStringsAsSectionsWCSXT(pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		def ReplaceSubStringsWCSXTQ(pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	def SubStringsReplacedWCSXT(pcCondition, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringsWCSXTQ(pcCondition, pcNewSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsWXT(pcCondition, pcNewSubStr)
		This.ReplaceSubStringsCSWXT(pcCondition, pcNewSubStr, TRUE)

		def ReplaceSubStringsWXTQ(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsWXT(pcCondition, pcNewSubStr)
			return This

	def SubStringsReplacedWXT(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringsWXTQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #----------------------------------------------------#
	 #     REPLACING THE NTH OCCURRENCE OF A SUBSTRING    #
	#====================================================#

	def ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok
	
		if n = :First
			n = 1
	
		but n = :Last
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
		ok
	
		n = This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
	
		if n > 0
			oSubStr = new stzString(pcSubStr)
			This.ReplaceSection( n, n + oSubStr.NumberOfChars()-1, pcNewSubStr)
		ok
	
		#< @FunctionFluentForm
	
		def ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		def ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def NthOccurrenceReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()


	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This
	
		#>

		def ReplaceNth(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)

			def ReplaceNthQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNth(n, pcSubStr, pcNewSubStr)
				return This

	def NthOccurrenceReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr).Content()

	  #-------------------------------------------------#
	 #    REPLACING FIRST OCCURRENCE OF A SUBSTRING    #
	#-------------------------------------------------#

	def ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternative

		def ReplaceFirst(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceFirstQ(pcSubStr, pcNewSubStr)
				This.ReplaceFirst(pcSubStr, pcNewSubStr)
				return This

		#>

	def FirstOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	  #--------------------------------------------------#
	 #     REPLACING LAST OCCURRENCE OF A SUBSTRING     #
	#--------------------------------------------------#

	def ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, TRUE)

		#< @FunctionFluentForm

		def ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def ReplaceLast(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceLastQ(pcSubStr, pcNewSubStr)
				This.ReplaceLast(pcSubStr, pcNewSubStr)
				return This

		#>

	def LastOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2] + 1, pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :First or :FirstOccurrence
				nStart = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			on :FirstPosition or :FirstChar
				nStart = 1

			off
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def NextNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, TRUE)

		def ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

	def NextNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def NextOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, TRUE)

		def ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	   #--------------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                        #
	#--------------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplacePreviousNthOccurrence(2, :Of = "ring", :StartingAtOccurrence = 3, :By = "")
		
		? o1.Content() #-->  php ring ruby ring python ring
		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2], pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :Last or :LastOccurrence
				nStart = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

			on :LastPosition or :LastChar
				nStart = This.NumberOfChars()

			off
		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def PreviousNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, TRUE)

		def ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

	def PreviousNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def PreviousOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, TRUE)

		def ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	  #----------------------------------------------------#
	 #  REPLACING THE FIRST N OCCURRENCES OF A SUBSTRING  #
	#----------------------------------------------------#

	def ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(anPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceFirstNOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNFirstOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstNOccurrencesCSQ(n, pcNewSubStr, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
		This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, TRUE)

		def ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)

			def ReplaceNFirstOccurrencesQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
				return This

	def FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr).Content()

		def NFirstOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
			return This.FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)

	  #========================#
	 #   REPLACING NTH CHAR   # 
	#========================#

	def ReplaceNthChar(n, pSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if n = :LastChar or n = :EndOfString or n = :Last
			n = This.NumberOfChars()

		but n = :FirstChar or n = :StartOfString or n = :First
			n = 1
		ok

		if isList(pSubStr) and
		   len(pSubStr) = 2 and
		   StzListQ(pSubStr).IsPairOfStrings()

			if pSubStr[1] = :With
				pSubStr = pSubStr[2]

			ok
		ok

		This.ReplaceSection(n, n , pSubStr)

		#< @FunctionFluentForm

		def ReplaceNthCharQ(n, pcSubStr)
			This.ReplaceNthChar(n, pcSubStr)
			return This

		#>

	def NthCharReplaced(n, pValue)
		cResult = This.Copy().ReplaceNthCharQ(n, pValue).Content()
		return cResult

	  #-----------------------------------------------#
	 #  REPLACING FIRST CHAR WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def ReplaceFirstChar(pcSubStr)
		This.ReplaceNthChar(1, pcSubStr)

		def ReplaceFirstCharQ(pcSubStr)
			This.ReplaceFirstChar(pcSubStr)
			return This

	def FirstCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #----------------------------------------------#
	 #  REPLACING LAST CHAR WITH A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def ReplaceLastChar(pcSubStr)
		This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)

		def ReplaceLastCharQ(pcSubStr)
			This.ReplaceLastChar(pcSubStr)
			return This

	def LastCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #------------------------------------------------------------#
	 #  REPLACING NTH GIVEN CHAR (IF ANY) WITH A GIVEN SUBSTRING  #
	#------------------------------------------------------------#

	def ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)

		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.ReplaceNthChar(n, pcSubStr)
		ok

		def ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive)
			This.ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)
			return This

	def ThisNthCharReplacedCS(n, cChar, pcSubStr, pCaseSensitive)
		return This.Copy().ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisNthChar(n, cChar, pcSubStr)
		This.ReplaceThisNthCharCS(n, cChar, pcSubStr, TRUE)

		def ReplaceThisNthCharQ(n, cChar, pcSubStr)
			This.ReplaceThisNthChar(n, cChar, pcSubStr)
			return This

	def ThisNthCharReplaced(n, cChar, pcSubStr)
		return This.Copy().ReplaceThisNthCharQ(n, cChar, pcSubStr).Content()

	  #-----------------------------------------------------------------#
	 #  REPLACING A GIVEN FIRST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#-----------------------------------------------------------------#

	def ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.FirstCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(1, pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisFirstCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisFirstChar(c, pcSubStr)
		This.ReplaceThisFirstCharCSQ(c, pcSubStr, TRUE)

		def ReplaceThisFirstCharQ(c, pcSubStr)
			This.ReplaceThisFirstChar(c, pcSubStr)
			return This

	def ThisFirstCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisFirstCharQ(c, pcSubStr).Content()

	  #----------------------------------------------------------------#
	 #  REPLACING A GIVEN LAST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#----------------------------------------------------------------#

	def ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.LastCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisLastCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisLastChar(c, pcSubStr)
		This.ReplaceThisLastCharCSQ(c, pcSubStr, TRUE)

		def ReplaceThisLastCharQ(c, pcSubStr)
			This.ReplaceThisLastChar(c, pcSubStr)
			return This

	def ThisLastCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisLastCharQ(c, pcSubStr).Content()

	  #--------------------------#
	 #    REPLACING ALL CHARS   # 
	#--------------------------#

	def ReplaceAllChars(pcSubStr)

		if isList(pcSubStr) and Q(pcSubStr).IsWithNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		cResult = ""
		for i = 1 to This.NumberOfChars()
			cResult += pcSubStr
		next

		This.Update( cResult )

		#< @FunctionFluentForm

		def ReplaceAllCharsQ(pcSubStr)
			This.ReplaceAllChars(pcSubStr)
			return This

		#>

	def AllCharsReplaced(pcSubStr)
		cResult = This.Copy().ReplaceAllCharsQ(pcSubStr).Content()
		return cResult

	  #================================#
	 #    INTERPOLATING THE STRING    # 
	#================================#

	def Interpolate()
		/* EXAMPLE

		max = RingMaxIntegerXT()
		min = RingMinIntegerXT()

		? Q("The range of integers is {min} to {max}").Interpolated();
		
		#--> The range of integers is '-999_999_999_999_999' to
		     '999_999_999_999_999'

		NOTE the use of the XT() extension to return the number
		spacified by "_"

		*/

		aSectionsXT = This.SubStringsBoundedByZZ(["{", "}"])
		#--> [ [ "min", [ 27, 29 ] ], [ "max", [ 36, 38 ] ] ]

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
		
			cVar	 = aSectionsXT[i][1]
			cCode	 = 'cValue	 = (' + cVar + ' )'
			eval(cCode)
		
			n1 = aSectionsXT[i][2][1] - 1
			n2 = aSectionsXT[i][2][2] + 1
			
			This.ReplaceSection(n1, n2, cValue)

		next

		#< @FunctionFluentForm

		def InterpolateQ()
			This.Interpolate()
			return This

		#>

		#< @FunctionMisspelledForms

		def Interpoltate()
			return This.Interpolate()

			def InterpoltateQ()
				This.Interpoltate()
				return This

		def Intrepolate()
			return This.Interpolate()

			def IntrepolateQ()
				This.Interpoltate()
				return This
		#>
			
	def Interpolated()
		return This.Copy().InterpolateQ().Content()

		#< @FunctionMisspelledForm

		def Interpoltated()
			return This.Interpolated()

		def Intrepolatef()
			return This.Interpolated()

		#>
		
	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS MARKERS  #
	#===========================================#
	#TODO: Reorganize it with similar functions

	def ContainsMarkers()
		/*
		? StzString('My kids are #1, #2, and #3!').ContainsMarkers() --> TRUE
		*/

		if This.NumberOfMarkers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #=============================================#
	 #    CHECKING IF THE STRING IS A RING CODE    # 
	#=============================================#

	def IsValidRingCode()

		try
			eval(This.Copy().Content())
			return TRUE
		catch
			return FALSE
		done

		def IsEvaluableRingCode()
			return This.IsValidRingCode()

		def IsRingCode()
			return This.IsValidRingCode()

	  #------------------------------------------------#
	 #    EXECUTING RING CODE HOSTED IN THE STRING    # 
	#------------------------------------------------#

	def Execute()
		if This.IsValidRingCode()
			eval(This.String())
		ok

		def Run()
			This.Execute()

	def ExecuteAndReturn()
		if This.StartsWithCS("return ", :CS = FALSE)
			eval(This.String())
		else
			cCode = "return " + This.String()
			eval(cCode)
		ok

		def RunAndReturn()
			This.ExecuteAndReturn()

	  #----------------------------#
	 #     CLEARING THE STRING    #
	#----------------------------#

	def Clear()
		This.UpdateWith("")

		#< @FunctionFluentForm

		// Clears the string and return it as a StzObject
		// to take other actions on it
		def ClearQ()
			This.Clear()
			return This

		#>

	  #---------------------------------------------------------#
	 #  VERIFYING IF THE STRING IS EMPTY (NULL IN RING TERMS)  #
	#---------------------------------------------------------#

	def IsEmpty()
		return This.Content() = ""
		
	  #-----------------------#
	 #  RESIZING THE STRING  #
	#-----------------------#

	def Resize(n)
		cResult = NULL

		if n <= NumberOfChars()
			cResult = This.FirstNChars(n)
		else
			cResult = This.ExtendToNChars(n, :Using = " ")
		ok

		This.Update(cResult)
		
		#< @FunctionFluentForm

		def ResizeQ(n)
			This.Resize(n)
			return This
	
		#>

	  #-----------------------------------------------#
	 #  ADDING A SUBSTRING AT THE END OF THE STRING  #
	#-----------------------------------------------#

	def AddSubString(pcSubStr)
		This.UpdateWith( This.Content() + pcSubStr )

	  #------------------------------------------#
	 #  ADDING A CHAR AT THE END OF THE STRING  #
	#------------------------------------------#

	def AddChar(c)
		if isString(c) and Q(c).IsChar()
			This.AddSubString(c)
		else
			stzRaise("Incorrect param type! c must be a char.")
		ok


	  #-----------------------#
	 #  UPDATING THE STRING  #
	#-----------------------#

	def Update(pcNewStr)
		#< QtBased | Uses QString.clear() and QString.append() >

		if isList(pcNewStr) and Q(pcNewStr).IsWithOrByOrUsingNamedParam()
			pcNewStr = pcNewStr[2]
		ok
	
		@oQString.clear()
		@oQString.append(pcNewStr)

		//This.VerifyConstraints()

		#< @FunctionFluentForm

		def UpdateQ(pcNewStr)
			This.Update(pcNewStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(pcNewStr)
			This.Update(pcNewStr)

			def UpdateWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def UpdateBy(pcNewStr)
			This.Update(pcNewStr)

			def UpdateByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def UpdateUsing(pcNewStr)
			This.Update(pcNewStr)

			def UpdateUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		#--

		def Fill(pcNewStr)
			This.Update(pcNewStr)

			def FillQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def FillWith(pcNewStr)
			This.Update(pcNewStr)

			def FillWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def FillBy(pcNewStr)
			This.Update(pcNewStr)

			def FillByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def FillUsing(pcNewStr)
			This.Update(pcNewStr)

			def FillUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
		#>

	def Updated(pcNewStr)
		return pcNewStr

		#< @FunctionAlternativeForms

		def UpdatedWith(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedBy(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#--

		def Filled(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledWith(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledBy(pcNewStr)
			return This.Updated(pcNewStr)

		def FilledUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#>

	  #========================================#
	 #     CONTAINING ONLY SPACES & LETTERS   #
	#========================================#
	#TODO: Reorganize it with similar functions


	def ContainsOnlySpaces() #NOTE # this is different from ContainsSpaces()
		
		if This.Trimmed() = ""
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfSpaces()
			return This.ContainsOnlySpaces()

		def IsMadeOfOnlySpaces()
			return This.ContainsOnlySpaces()

		def IsBlank()
			return This.ContainsOnlySpaces()

		#>

	def ContainsOnlyLetters() #NOTE # this is different from ContainsLetters()
		aoChars = This.CharsQ().ToListOfStzChars() #NOTE # this is different from ToStzListOfChars()
		nLen = len(aoChars)

		bResult = TRUE

		for i = 1 to nLen
			if NOT aoChars[i].IsLetter()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAlphabetic()
			return This.ContainsOnlyLetters()

		def IsAplhabetical()
			return This.ContainsOnlyLetters()

		def IsAlpha()
			return This.ContainsOnlyLetters()

		def IsMadeOfOnlyLetters()
			return This.ContainsOnlyLetters()

		def IsMadeOfLetters()
			return This.ContainsOnlyLetters()

		def AllCharsAreLetters()
			return This.ContainsOnlyLetters()

		#>

	def ContainsLettersAndNumbers()
		if This.ContainsLetters() or This.ContainsNumbers()
			return TRUE
		else
			return FALSE
		ok

		def ContainsNumbersAndLetters()
			return This.ContainsLettersAndNumbers() 

		def IsMadeOfNumbersAndLetters()
			return This.ContainsLettersAndNumbers() 

		def IsMadeOfLettersAndNumbers()
			return This.ContainsLettersAndNumbers() 

	def ContainsOnlyLettersOrNumbers()
		if This.ContainsOnlyLetters() or This.ContainsOnlyNumbers()
			return TRUE
		else
			return FALSE
		ok

		def ContainsOnlyNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

		def IsMadeOfOnlyNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

		def IsMadeOfNumbersOrLetters()
			return This.ContainsOnlyLettersOrNumbers()

	def ContainsOnlyLettersAndNumbers()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)

		bResult = TRUE

		for i = 1 to nLen
			if NOT aoChars[i].IsLetterOrNumber()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#<@ FunctionAlternativeForms

		def ContainsOnlyNumbersAndLetters()
			return This.ContainsOnlyLettersAndNumbers()

		def IsMadeOfOnlyLettersAndNumbers()
			return This.ContainsOnlyLettersAndNumbers()

		def IsMadeOfOnlyNumbersAndLetters()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNum()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNumerical()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlphaNumeric()
			return This.ContainsOnlyLettersAndNumbers()

		def IsAlNum()
			return This.ContainsOnlyLettersAndNumbers()

		#>

	  #=========================================================#
	 #  CHEHCKING IF THE STRING STARTS WITH A GIVEN SUBSTRING  #
	#=========================================================#

	def StartsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.startsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.startsWith(pcSubStr, pCaseSensitive)
		return bResult


		def BeginsWithCS(pcSubStr, pCaseSensitive)
			return This.StartsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(pcSubStr)
		return This.StartsWithCS(pcSubStr, TRUE)

		def BeginsWith(pcSubStr)
			return This.StartsWith(pcSubStr)

	  #----------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.BeginsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESNESITIVITY

	def BeginsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, TRUE)

		def StartsWithOneOfThese(paSubStr)
			return This.BeginsWithOneOfThese(paSubStr)

	  #--------------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#--------------------------------------------------------------------#

	def StartsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		if NOT @BothAreStrings(pSubStr1, pSubStr2)
			stzRaise("Incorrect params types! Both pSubStr1 and pSubStr2 must be strings.")
		ok

		return This.StartsWithOneOfTheseCS([pSubStr1, pSubStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWithEither(pSubStr1, pSubStr2)
		return This.StartsWithEitherCS(pSubStr1, pSubStr2, TRUE)

	  #----------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH A GIVEN GIVEN SUBSTRING  #
	#----------------------------------------------------------#

	def EndsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses oQString.endsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.endsWith(pcSubStr, pCaseSensitive)
		return bResult


		def FinishsWithCS(pcSubStr, pCaseSensitive)
				return This.EndsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(pcSubStr)
		return @oQString.endsWith(pcSubStr, 0)

		def FinishsWith(pcSubStr)
			return This.EndsWith()

	  #--------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------#

	def EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.EndsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def FinishsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, TRUE)

		def FinsihsWithOneOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

	  #------------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#------------------------------------------------------------------#

	def EndsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		return This.EndsWithOneOfTheseCS([ pSubStr1, pSubStr2], pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def EndsWithEither(pSubStr1, pSubStr2)
		return This.EndsWithEitherCS(pSubStr1, pSubStr2, TRUE)

	  #====================================================#
	 #  GETTING THE SUBSTRING OCCURRENCE BY ITS POSITION  #
	#====================================================#

	def SubStringOccurrenceByPositionCS(nPos, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.SubStringOccurrenceByPosition(9, "ring") #--> 2
		*/

		nResult = 0

		anPos = This.FindSubStringCS(pcSubStr, pCaseSensitive)
		i = 0
		for n in anPos
			i++
			if n = nPos
				nResult = i
				exit
			ok
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringOccurrenceByPosition(nPos, pcSubStr)
		return This.SubStringOccurrenceByPositionCS(nPos, pcSubStr, TRUE)

	  #=============================================#
	 #   FINDING THE NTH OCCURRENCE OF SUBSTRING   #
	#=============================================#

	def FindNthCS(n, pcSubstr, pCaseSensitive) #--> Returns 0 if nothing found

		# Resolving the pcSubStr param

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be as a string.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Early-checking for better performance (in case of!)

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		# Resolving the n param

		if isString(n)
			cNLowercased = Q(n).Lowercased()
			if cNLowercased = :First or cNLowercased = :FirstOccurrence
				n = 1

			but cNLowercased = :Last or cNLowercased = :LastOccurrence
				n = This.NumberOfOccurrenceCs(pcSubStr, pCaseSensitive)

			else
				n = 0
			ok
		ok

		# Doing the job

		nResult = 0

		nPos = 1
		for i = 1 to n

			nResult = This.QStringObject().indexOf(pcSubStr, nPos - 1, pCaseSensitive) + 1

			if nResult = 0
				exit
			ok

			nPos = nResult + 1
		next

		return nResult

		#< @FunctionAlternativeForm

		def FindNthCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)

		def FindNthSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)

		def FindNthSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCS(n, pcSubStr, pCaseSensitive)
 
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNth(n, pcSubstr)
		return This.FindNthCS(n, pcSubstr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthZ(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		def FindNthSubString(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		def FindNthSubStringZ(n, pcSubStr)
			return This.FindNth(n, pcSubStr)

		#>

	  #===============================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING AND RETURNING THE POSITION AS SECTION  #
	#===============================================================================#

	def FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)

		anResult = [ nPos, (nPos + Q(pcSubStr).NumberOfChars() - 1) ]
		return anResult

		#< @FunctionAlternativeForms

		def FindNthOccurrenceOfSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceOfSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		def FindNthOccurrenceCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSection(n, pcSubStr)
		return This.FindNthAsSectionCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthOccurrenceOfSubStringAsSection(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceAsSection(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		#--

		def FindNthZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceOfSubStringZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		def FindNthOccurrenceZZ(n, pcSubStr)
			return This.FindNthAsSection(n, pcSubStr)

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindFirstOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindFirstCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFirstOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSection(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSection(pcSubStr)
		return This.FindFirstAsSectionCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#--

		def FindFirstZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceOfSubStringZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindFirstOccurrenceZZ(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#--

		def FindAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindLastOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindFLastOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def FindLasteAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSection(pcSubStr)
		return This.FindLastAsSectionCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindFLastOccurrenceAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#--

		def FindLastZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindLastOccurrenceOfSubStringZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		def FindLastOccurrenceZZ(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

		#< @FunctionMisspelledForm

		def FindLasteAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

	  #============================================#
	 #  FINDING THE ANTI-SECTIONS OF A SUBSTRING  #
	#============================================#

	def AntiFindCSZZ(pcSubStr, pCaseSensitive)
		# Works both for one string or many

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSections( This.FindCSZZ(pcSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		#--

		def AntiFindSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		def AntiFindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.AntiFindCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindZZ(pcSubStr)
		return This.AntiFindAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def AntiFindAsSections(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		#--

		def AntiFindSubStringZZ(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		def AntiFindSubStringAsSections(pcSubStr)
			return This.AntiFindZZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  FINDING THE ONLY ANTI-SECTION (IF ANY) OF A SUBSTRING  #
	#---------------------------------------------------------#
	# @SpecialForm of AntiFindAsSections (without s at the end)

	def AntiFindAsSectionCS(pcSubStr, pCaseSensitive)
		aSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult = []
		if len(aSections) > 0
			aResult = aSections[1]
		ok

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.AntiFindAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSection(pcSubStr)
		return This.AntiFindAsSectionCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def AntiFindSubStringAsSection(pcSubStr)
			return This.AntiFindAsSection(pcSubStr)

		#>

	  #------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS  #
	#================================================#

	def AntiFindManyCS(pacSubStr, pCaseSensitive)

		aSections = This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)
		nLen = len(aSections)

		anResult = []

		for i = 1 to nLen
			anResult + aSections[i][1]
		next

		return anResult

		#< @FunctionAlternativeForms

		def AntiFindManyCSZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindMany(pcSubStr)
		return This.AntiFindManyCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def AntiFindManyZ(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		#--

		def AntiFindManySubStrings(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		def AntiFindManySubStringsZ(pacSubStr)
			return This.AntiFindMany(pacSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE ANTI-SECTIONS OF MANY SUBSTRINGS -- ZZ/EXTENDED  #
	#---------------------------------------------------------------#

	def AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		aResult = StzListQ(1:This.NumberOfChars()).
			FindAntiSections( This.FindManyCSZZ(pacSubStr, pCaseSensitive) )

		return aResult

		#< @FunctionAlternativeForms

		def AntiFindManyAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#--

		def AntiFindManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		def AntiFindManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#==

		def AntiFindTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		def AntiFindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.AntiFindManyCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AntiFindManyZZ(pcSubStr)
		return This.AntiFindManyAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def AntiFindManyAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#--

		def AntiFindManySubStringsZZ(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		def AntiFindManySubStringsAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#==

		def AntiFindTheseSubStringsZZ(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		def AntiFindTheseSubStringsAsSections(pacSubStr)
			return This.AntiFindManyZZ(pacSubStr)

		#>

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- D/Extented  #
	#===================================================#

	def FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		# Checking prams

		if isString(n)
			if n = :Default or n = :First or n = :FirstOccurrence
				n = 1

			but n = :Last or n = :LastOccurrence
				n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Default, :Forward, and :Backward.")
		ok

		# Doing the job

		nPos = This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSubStringDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		def FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		def FindNthSubStringAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionDZZ(n, pcSubStr, pcDirection)
		return This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSubStringDZZ(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		def FindNthAsSectionD(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		def FindNthSubStringAsSectionD(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

		#>

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- D/Extented  #
	#-----------------------------------------------------#

	def FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(1, pcSubStr, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindFirstSubStringAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringDZZ(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		def FindFirstAsSectionD(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		def FindFirstSubStringAsSectionD(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- D/Extented  #
	#----------------------------------------------------#

	def FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindLastAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		def FindLastSubStringAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastADZZ(pcSubStr, pcDirection)
		return This.FindLastDCSZZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringDZZ(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		def FindLastAsSectionD(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		def FindLastSubStringAsSectionD(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

		#>

	  #====================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- SD/Extented  #
	#====================================================#

	def FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if isList(pcDirection) and
			   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
	
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and
				 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )
	
				StzRaise("Incorrect param! pcDirection must be a string. " +
					 "Allowed values are :Default, :Forward, :Backward.")
			ok

		ok

		# Doing the job

		aResult = This.FindNthAsSectionSCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSubStringSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindNthSubStringAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSubStringSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def FindNthAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def FindNthSubStringAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		#>

	  #------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- SD/Extented  #
	#------------------------------------------------------#

	def FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCSZZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSubStringAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindFirstAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindFirstSubStringAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #-----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- SD/Extented  #
	#-----------------------------------------------------#

	def FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSTDCSZZ(nLast, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSubStringAsSectionSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindLastAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FindLastSubStringAsSectionSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- S/Extented  #
	#===================================================#

	def FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSubStringAsSectionSTCS(n, pcSubStr, pnSatrtingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindNthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindNthSubStringSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthAsSectionSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionST(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSubStringAsSectionST(n, pcSubStr, pnSatrtingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		def FindNthSTZZ(n, pcSubStr, pnStartingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		def FindNthSubStringSTZZ(n, pcSubStr, pnStartingAt)
			return This.FindNthAsSectionST(n, pcSubStr, pnStartingAt)

		#>

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- S/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSTCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstSubStringAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindFirstSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionST(pcSubStr, pnStartingAt)
		return This.FindFirstAsSectionSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringAsSectionST(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		def FindFirstSTZZ(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		def FindFirstSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FindFirstAsSectionST(pcSubStr, pnStartingAt)

		#>

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- S/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSTCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastSubStringAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
 			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionST(pcSubStr, pnStartingAt)
		return This.FindLastAsSectionSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringAsSectionST(pcSubStr, pnStartingAt)
 			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		def FindLastSTZZ(pcSubStr, pnStartingAt)
			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		def FindLastSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FindLastAsSectionST(pcSubStr, pnStartingAt)

		#>

	  #=======================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#=======================================================#

	def NthCSZ(n, pcSubStr, pCaseSensitive)
		anPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.NthCSZ(n, pcSubStr, pCaseSensitive)

		def NthSubStringAndItsPositionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthZ(n, pcSubStr)
		return This.NthCSZ(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def NthSubStringZ(n, pcSubStr)
			return This.NthZ(n, pcSubStr)

		def NthSubStringAndItsPosition(n, pcSubStr)
			return This.NthZ(n, pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#--------------------------------------------------------#

	def NthCSZZ(n, pcSubStr, pCaseSensitive)
		aSection = This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		def NthAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		def NthSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.NthCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthZZ(n, pcSubStr)
		return This.FindNthCSZZ(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def NthSubStringZZ(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		def NthAsSection(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		def NthSubStringAsSection(n, pcSubStr)
			return This.NthZZ(n, pcSubStr)

		#>

	  #=======================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION   #
	#=======================================================================#

	def FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("124578")
		? o1.FindNthS(2, "", :StartingAt = 3)
		#--> 6

		*/

		return This.FindNthSTDCS(n, pcSubStr, pnstartingAt, :Forward, pCaseSensitive)

		def FindNthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthST(n, pcsubStr, pnStartingAt)
		return This.FindNthSTCS(n, pcSubStr, pnStartingAt, TRUE)

		def FindNthSTZ(n, pcsubStr, pnStartingAt)
			return This.FindNthST(n, pcsubStr, pnStartingAt)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def FindFirstSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if CheckParams()

			if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok

			# Resolving pCaseSensitive

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if isString(pCaseSensitive)
				if Q(pCaseSensitive).IsOneOfThese([
					:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])
	
					pCaseSensitive = TRUE
				
				but Q(pCaseSensitive).IsOneOfThese([
					:CaseInSensitive, :NotCaseSensitive, :NotCS,
					:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])
	
					pCaseSensitive = FALSE
				ok
	
			ok
	
			if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
				stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
			ok

		ok
		
		# Doing the job
		
		nResult = This.QStringObject().indexOf(pcSubStr, pnStartingAt - 1, pCaseSensitive) + 1
		return nResult


		def FindFirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstST(pcSubStr, pnStartingAt)
		return This.FindFirstSTCS(pcSubStr, pnStartingAt, TRUE)

		def FindFirstSTZ(pcSubStr, pnStartingAt)
			return This.FindFirstST(pcSubStr, pnStartingAt)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------#

	def FindLastSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSTCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindLastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastST(pcSubStr, pnStartingAt)
		return This.FindLastSTCS(pcSubStr, pnStartingAt, TRUE)

		def FindLastSTZ(pcSubStr, pnStartingAt)
			return This.FindLastST(pcSubStr, pnStartingAt)

	   #==========================================================================#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                           #
	#==========================================================================#

	def FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				else
					n = 0
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
	
			if isList(pcDirection) and
			   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and
				 Q(pcDirection).IsOneOfThese([ :Forward, :Default, :Backward ]) )
	
				StzRaise("Incorrect param! pcDirection must be a string. " + NL +
					 "Allowed values are :Forward, :Backward, and :Default.")
	
			ok
	
			if NOT ( isString(pcDirection) and
				 Q(pcDirection).IsEither(:Forward, :Or = :Backward) )
	
				StzRaise("Incorrect param! pcDirection must be a string. Allowed values are :Forward and :Backward.")
	
			ok

			if isString(n)
	
				if NOT ( isNumber(n) or
					 isString(n) and Q(n).IsOneOfThese([
						:First, :FirstOccurrence, :Last, :LastOccurrence ]) )
	
					StzRaise("Incorrect param! n must be a number or one of these " +
						 "two strings (:First or :Last).")
				ok
	
				if pcDirection = :Forward or pcDirection = :Default
	
					if n = :First or n = :FirstOccurrence
						n = 1
		
					but n = :Last or n = :LastOccurrence
		
						n = This.SectionQ(pnStartingAt, :LastChar).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
					ok
	
				else // Backward
	
					if n = :First or n = :FirstOccurrence
	
						n = This.SectionQ(pnStartingAt, :LastChar).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
		
					but n = :Last or n = :LastOccurrence
						n = This.SectionQ(1, pnStartingAt).
							NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
					ok		
	
				ok
		
		
			ok

		ok

		# doing the job

		nResult = 0

		if pcDirection = :Forward

			nPos  = This.SectionQ(pnStartingAt, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

			if nPos > 0
				nResult = nPos + pnStartingAt - 1
			ok

		else // :Backward

			nResult  = This.FindNthPreviousCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		ok

		return nResult


		def FindNthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSTD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, TRUE)

		def FindNthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSTD(n, pcSubStr, pnStartingAt, pcDirection)

	   #----------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                             #
	#----------------------------------------------------------------------------#

	def FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindFirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSTDCS(pcSubStr, pnStartingAt, pcDirection, TRUE)

		def FindFirstSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSTD(pcSubStr, pnStartingAt, pcDirection)

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                            #
	#---------------------------------------------------------------------------#

	def FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSTDCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FindLastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSTDCS(pcSubStr, pnStartingAt, pcDirection, TRUE)

		def FindLastSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSTD(pcSubStr, pnStartingAt, pcDirection)

	  #===================================================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#===================================================================================#

	def NthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("124578")
		? o1.NthSZ(2, "", :StartingAt = 3)
		#--> [ "", 6 ]
		*/

		aResult = [ pcSubStr, This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult

		def NthSubStringSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NthSTCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSTZ(n, pcsubStr, pnStartingAt)
		return This.NthSTCSZ(n, pcSubStr, pnStartingAt, TRUE)

		def NthSubStringSTZ(n, pcSubStr, pnStartingAt)
			return This.NthSTZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FirstSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstSTZ(pcSubStr, pnStartingAt)
		return This.FirstSTCSZ(pcSubStr, pnStartingAt, TRUE)

		def FirstSubstringSTZ(pcSubStr, pnStartingAt)
			return This.FirstSTZ(pcSubStr, pnStartingAt)

	  #------------------------------------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#------------------------------------------------------------------------------------#

	def LastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZ(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastSubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.LastSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTZ(pcSubStr, pnStartingAt)
		return This.LastSTCSZ(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def LastSubStringSTZ(pcSubStr, pnStartingAt)
			return This.LastSTCSZ(pcSubStr, pnStartingAt)

		#>

	  #=====================================================================================#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZ/EXTENDED  #
	#=====================================================================================#

	def NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSTCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()
		aSection = [ nPos, nPos + nLen - 1 ]

		aResult = [ pcSubStr, aSection ]
		return aResult

		#< @FunctionAlternativeForms

		def NthSubStringSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthAsSectionSTCS(n, pcSubStr, pnSartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		def NthSubStringAsSectionSTCS(n, pcSubStr, pnSartingAt, pCaseSensitive)
			return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthSTZZ(n, pcsubStr, pnStartingAt)
		return This.NthSTCSZZ(n, pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def NthSubStringSTZZ(n, pcSubStr, pnStartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		def NthAsSectionST(n, pcSubStr, pnSartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		def NthSubStringAsSectionST(n, pcSubStr, pnSartingAt)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt)

		#>

	  #--------------------------------------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#--------------------------------------------------------------------------------------#

	def FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FirstSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSubStringAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.FirstSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstSTZZ(pcSubStr, pnStartingAt)
		return This.FirstSTCSZZ(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FirstSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		def FirstAsSectionST(pcSubStr, pnSartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		def FirstSubStringAsSectionST(pcSubStr, pnSartingAt)
			return This.FirstSTZZ(pcSubStr, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTCSZZ(nLast, pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def LastSubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSubStringAsSectionSTCS(pcSubStr, pnSartingAt, pCaseSensitive)
			return This.LastSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTZZ(pcSubStr, pnStartingAt)
		return This.LastSTCSZZ(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def LastSubStringSTZZ(pcSubStr, pnStartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		def LastAsSectionST(pcSubStr, pnSartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		def LastSubStringAsSectionST(pcSubStr, pnSartingAt)
			return This.LastSTZZ(pcSubStr, pnStartingAt)

		#>

	    #===========================================================================#
	   #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #
	#===========================================================================#

	def NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		
		aResult = [ pcSubStr, This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def NthSubStringSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.NthSTDCSZ(n, pcSubStr, pnStartingAt, pcDirection, TRUE)

		def NthSubStringSTDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION                                                     #                           #
	#------------------------------------------------------------------------------#

	def FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.NthSTDCSZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSubstringSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FirstSTDCSZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

		def FirstSubStringSTDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZ(pcSubStr, pnStartingAt, pcDirection)

	    #---------------------------------------------------------------------------#
	   #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #                          #
	#---------------------------------------------------------------------------#

	def LastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccirrenceSCS(pcsubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTDCSZ(nLast, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringSTDCZ(pcSubStr, pnSartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZ(pcSubstr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.LastSTDCSZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

		def LastSubStringSTD(pcSubStr, pnSartingAt, pcDirection)
			return This.LastSTDZ(pcSubstr, pnStartingAt, pcDirection)

	    #===========================================================================#
	   #  GETTING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                     #
	#===========================================================================#

	def NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n1 = This.FindNthSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n2 = n1 + Q(pcSubStr).NumberOfChars() - 1
		aResult = [ pcSubStr, [n1, n2] ]
		return aResult

		#< @FunctionAlternativeFrom

		def NthAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSubStringSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def NthSubStringAsSectionSTDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
 
		#>

	#-- WITHOUT CASESENSITIVITY

	def NthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeFrom

		def NthAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def NthSubStringSTDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTDCSZZ(n, pcSubStr, pnStartingAt, pcDirection)

		def NthSubStringAsSectionSTD(n, pcSubStr, pnStartingAt, pcDirection)
			return This.NthSTZZ(n, pcSubStr, pnStartingAt, pcDirection)
 
		#>
	    #------------------------------------------------------------------------------#
	   #  GETTING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                        #                           #
	#------------------------------------------------------------------------------#

	def FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.NthSTDCSZZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FirstSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSubStringAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)


		def FirstSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FirstAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def FirstSubStringAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.FirstSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	    #----------------------------------------------------------------------------#
	   #  GETTING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING  #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                      #                          #
	#----------------------------------------------------------------------------#

	def LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLast = This.NumberOfOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.NthSTDCSZZ(nLast, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#< @FunctionAlternativeForms

		def LastAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSubStringAsSectionSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.LastSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def LastAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def LastSubStringSTDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		def LastSubStringAsSectionSTD(pcSubStr, pnStartingAt, pcDirection)
			return This.LastSTDZZ(pcSubStr, pnStartingAt, pcDirection)

		#>

	  #======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- EXTENDED   #
	#======================================================#

	def FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		
		? o1.FindNthXT(2, "word", :Between = ["<<", ">>"])
		#--> 43
		
		? o1.FindNthCSXT(2, "WORD", :Between = ["<<", ">>"], :CS = FALSE)
		#--> 43

		? o1.FindNthXT(2, "word", :StartingAt = 5)
		#--> 43

		? o1.FindNthXT(2, "word", [ :Going = :Backward, :StartingAt = 48 ])
		#--> 11

		*/
	
		# Enabling the syntax :BoundedBy = "*"

		if NOT ( isList(paOption) and Q(paOption).IsPair() and isString(paOption[1]))
			StzRaise("Incorrect param type! paOption must ne a pair starting with a string.")
		ok

		oOption = Q(paOption)

		if oOption.IsBoundedByNamedParam()
			return This.FindNthSubStringBoundedByCS(n, pcSubStr, paOption[2], pCaseSensitive)


		# CASE 2: ? o1.NthXT(2, "word", :Between = ["<<",">>"])
		but oOption.IsBetweenNamedParam()
			return This.FindNthSubStringBetweenCS(n, pcSubStr, paOption[1], paOption[2], pCaseSensitive)


		# CASE 3: ? o1.FindNthXT(2, "word", :StartingAt = 5)
		but oOption.IsStartingAtNamedParam()
			return This.FindNthSubStringSCS(n, pcSubStr, paOption[2], pCaseSensitive)

		# Case 4: ? o1.FindNthXT(2, "word"; :GoingFrom = :Backward)
		but oOption.IsGoingFromNamedParam()
			return This.FindNthSubStringDCS(n, pcSubStr, paOption[2], pCaseSensitive)

		else
			stzRaise("Incorrect format!")
		ok

		#< @FunctionAlternativeForms

		def FindNthCSXTZ(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		def FindNthSubstringCSXT(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		def FindNthSubstringCSXTZ(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindNthXT(n, pcSubStr, paOption)
		return This.FindNthCSXT(n, pcSubStr, paOption, TRUE)

		#< @FunctionAlternativeForms

		def FindNthXTZ(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		def FindNthSubstringXT(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		def FindNthSubstringXTZ(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

		#>

	  #-------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#-------------------------------------------------------#

	def FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.FindNthCSXT(1, pcSubStr, paOption, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindFirstSubStringCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindFirstSubStringCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstXT(pcSubStr, paOption)
		return This.FindFirstCSXT(pcSubStr, paOption, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstXTZ(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		def FindFirstSubStringXT(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		def FindFirstSubStringXTZ(pcSubStr, paOption)
			return This.FindFirstXT(pcSubStr, paOption)

		#>

	  #------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#------------------------------------------------------#

	def FindLastCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.FindNthCSXT(:Last, pcSubStr, paOption, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindLastCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindLastSubStringCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		def FindLastSubStringCSXTZ(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastXT(pcSubStr, paOption)
		return This.FindLastCSXT(pcSubStr, paOption, TRUE)

		#< @FunctionAlternativeForms

		def FindLastXTZ(pcSubStr, paOption)
			return This.FindLastXT(pcSubStr, paOption)

		def FindLastSubStringXT(pcSubStr, paOption, pCaseSensitive)
			return This.FindLastXT(pcSubStr, paOption)

		def FindLastSubStringXTZ(pcSubStr, paOption)
			return This.FindLastXT(pcSubStr, paOption)

		#>

	  #============================================#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING   #
	#============================================#

	// Returns the position of the 1st occurrence of the substring inside the string
	// or returns 0 if nothing is found

	def FindFirstCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.FindFirstCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def FirstPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--


		def PositionOfFristOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFristCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFristSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def FristSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FristCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirst(pcSubstr)
		return This.FindFirstCS(pcSubstr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindFirstQ(pcSubStr)
			return new stzNumber( This.FindFirst(pcSubStr) )

		#>

		#< @FunctionAlternativeForms
	
		def FindFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def First(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def FirstPosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirst(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)
	
		#>

		#< @FunctionMisspelledForms

		def FindFrist(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def PositionOfFristOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFrist(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFristSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FristSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def Frist(pcSubStr)
			return This.FindFirst(pcSubStr)

		#>
		
	  #---------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#---------------------------------------------------------#

	def FirstCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def FirstSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstZ(pcSubStr)
		return This.FindFirstCSZ(pcSubStr, TRUE)

		def FirstSubstringZ(pcSubStr)
			return This.FirstZ(pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#

	def FirstCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def FirstOccurrenceCSZZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FirstAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		def FirstOccurrenceOfSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstZZ(pcSubStr)
		return This.FindFirstCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FirstOccurrenceZZ(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceOfSubStringZZ(pcSubStr)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FirstAsSection(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceAsSection(pcSubStr)
			return This.FirstZZ(pcSubStr)

		def FirstOccurrenceOfSubStringAsSection(pcSubStr)
			return This.FirstCSZZ(pcSubStr, pCaseSensitive)

		#>

	  #-------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#-------------------------------------------------------#
	#TODO: Add other alternatives

	def FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		nStart = 1
		if pcDirection = :Backward
			nStart = This.NumberOfChars()
		ok
			
		nResult = FindNthSDCS(n, pcSubStr, nStart, pcDirection, pCaseSensitive)
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNthD(n, pcSubStr, pcDirection)
		return This.FindNthDCS(n, pcSubStr, pcDirection, TRUE)

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#---------------------------------------------------------#
	#TODO: Add other alternatives

	def FindFirstDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(1, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstD(pcSubStr, pcDirection)
		return This.FindFirstDCS(pcSubStr, pcDirection, TRUE)

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#--------------------------------------------------------#
	#TODO: Add other alternatives

	def FindLastDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(:Last, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastD(pcSubStr, pcDirection)
		return This.FindLastDCS(pcSubStr, pcDirection, TRUE)

	  #--------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#--------------------------------------------------------#
	#TODO: Add other alternatives

	def NthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthDZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZ(n, pcSubStr, pcDirection, TRUE)

	  #----------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#----------------------------------------------------------#
	#TODO: Add other alternatives

	def FirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZ(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstDZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionMisspelledForm

		def FistDZ(n, pcSubStr, pcDirection)
			return This.FirstDZ(n, pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#---------------------------------------------------------#
	#TODO: Add other alternatives

	def LastDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.NthDCSZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastDZ(pcSubStr, pcDirection)
		return This.FindLastDCSZ(pcSubStr, pcDirection, TRUE)

	  #---------------------------------------------------------#
	 #  GETTING NTH OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#---------------------------------------------------------#
	#TODO: Add other alternatives

	def NthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthDZZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZZ(n, pcSubStr, pcDirection, TRUE)

	  #-----------------------------------------------------------#
	 #  GETTING FIRST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#-----------------------------------------------------------#
	#TODO: Add other alternatives

	def FirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionMisspelledForm

		def FistDZZ(n, pcSubStr, pcDirection)
			return This.FirstDZZ(n, pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  GETTING LAST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#----------------------------------------------------------#
	#TODO: Add other alternatives

	def LastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.NthDCSZZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LastDZZ(pcSubStr, pcDirection)
		return This.LastDCSZZ(pcSubStr, pcDirection, TRUE)

	  #=================================================#
	 #      FINDING LAST OCCURRENCE OF A SUBSTRING     #
	#=================================================#

	def FindLastCS(pcSubStr, pCaseSensitive)
		#< TODO: @QtBased | Uses QString2.lastIndexOf()

		/* EXAMPLE

		#                      4     0     6    1
		o1 = new stzString("---***---***---***---")
		? o1.FindLast("***")
		#--> 16

		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT This.ContainsCS(pcSubstr, pCaseSensitive)
			return 0
		ok

		n = This.NumberOfOccurrenceCS(pcSubstr, pCaseSensitive)
		nResult = This.FindNthCS(n, pcsubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms
	
		def FindLastOccurrenceCS(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#==

		def FindLastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastOccurrenceCSZ(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#>

	def FindLast(pcSubStr)
		return This.FindLastCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePosition(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLast(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPosition(pcSubStr)
			return This.FindLast(pcSubStr)

		#==

		def FindLastZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastOccurrenceZ(pcSubstr)
			return This.FindLast(pcSubStr)

		def FindLastSubStringZ(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrenceZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePositionZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubStringZ(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPositionZ(pcSubStr)
			return This.FindLast(pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#--------------------------------------------------------#

	def LastCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternativeForm

		def LastSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceOfSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.LastCSZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastZ(pcSubStr)
		return This.FindLastCSZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def LastSubStringZ(pcSubStr)
			return This.LastZ(pcSubStr)

		def LastOccurrenceZ(pcSubStr)
			return This.LastZ(pcSubStr)

		def LastOccurrenceOfSubStringZ(pcSubStr)
			return This.LastZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#---------------------------------------------------------#

	def LastCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForm

		def LastSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceCSZz(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		def LastOccurrenceOfSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.LastCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastZZ(pcSubStr)
		return This.LastCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def LastSubStringZZ(pcSubStr)
			return This.LastZZ(pcSubStr)

		def LastOccurrenceZz(pcSubStr)
			return This.LastZZ(pcSubStr)

		def LastOccurrenceOfSubStringZZ(pcSubStr)
			return This.LastZZ(pcSubStr, pCaseSensitive)

		#>

	  #===================================================================#
	 #   FINDING THE POSITIONS OF THE OCCURRENCES OF A GIVEN SUBSTRING   #
	#===================================================================#

	def FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.FindOccurrences([ 2, 3 ], "ring") #--> [ 9, 17 ]
		*/

		if CheckParams()
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and Q(panOccurr[nLen]).IsAndNamedParam()
				panOccurr[nLen] = panOccurr[nLen][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panOccurr)
				StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
			ok

			if isList(pcSubStr) and Q(pcSubStr).IsOneTheseNamedParams([ :Of, :OfSubString ])
				#NOTE
				# that IsOneTheseNamedParams() is a misspelled form of
				# IsOneOfTheseNamedParams(). I forgot "These" but hopefully
				# Softanza forgave it ;)
	
				pcSubStr = pcSubStr[2]
			ok

		ok

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLenOccurr = len(panOccurr)

		anResult = []
		for i = 1 to nLenOccurr
			anResult + anPos[panOccurr[i]]
		next

		anResult = ring_sort(anResult)
		return anResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesCSZ(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#--

		def FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		def FindOccurrencesCSZ(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesZ(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#--

		def FindOccurrences(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		def FindOccurrencesZ(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN OCCURRENCES OF A SUBSTRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#------------------------------------------------------------------------------------------#

	def FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, pCaseSensitive)

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesZZ(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCSZZ(panOccurr, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesAsSections(panOccurr, pcSubStr)
			return This.FindTheseOccurrencesZZ(panOccurr, pcSubStr)

		#>

	   #=====================================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING,   #
	 #   STARTING AT A GIVEN POSITION, AND GOING IN A GIVEN DIRECTION      #
	#=====================================================================#

	def FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isList(pcDirection) and Q(pcDirection).IsOneOfThese([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward
			anPos = This.SectionQ(pnStartingAt, :LastChar).FindCS(pcSubStr, pCaseSensitive)

			nLen = len(anPos)
			nLenSubStr = Q(pcSubStr).NumberOfChars()
	
			
			for i = 1 to nLen
				anResult + (pnStartingAt + anPos[i] - 1)
			next
	
		else // pcDirection = :Bacward
			anResult = This.SectionQ(1, pnStartingAt).
				 	FindCSQ(pcSubStr, pCaseSensitive).Reversed()

		ok

		return anResult


		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTDCSZ(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTDZ(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING AT A GIVEN   #
	 #   POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING THOSE POSITIONS AS SECTIONS      #
	#----------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		anPos = This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTDCSZZ(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTDZZ(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesAsSectionsSTD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING STARTING AT A GIVEN POSITION                 #
	#==========================================================#

	def FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
		anResult = This.FindTheseOccurrencesSTDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTCSZ(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesST(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesSTCS(panOccurr, pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindTheseOccurrencesSTZ(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesST(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING   #
	 #   AT A GIVEN POSITION AND RETURNING THOSE POSITIONS AS SECTIONS             #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		aResult = This.FindTheseOccurrencesAsSectionsSTDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesSTCSZZ(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsST(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesAsSectionsSTCS(panOccurr, pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindOccurrencesXTSTZZ(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesAsSectionsST(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING GOING IN A GIVEN DIRECTION                   #
	#==========================================================#

	def FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		if CheckParams() = TRUE
			if NOT ( isList(panOccurr) and Q(panOccurr).IsListOfNumbers() )
				StzRaise("Incorrect param type! pabOccurr must be a list of numbers.")
			ok
	
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubString()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(pcDirection) and Q(pcDirection).IsDirectionNamedParam()
				pcDirection = pcDirection[2]
			ok
		ok

		nStartAt = 1

		if pcDirection = :Backward
			nStartAt = This.NumberOfChars()
		ok

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, nStartAt, pcDirection, pCaseSensitive)

		nLen = len(panOccurr)
		anResult = []
		for i = 1 to nLen
			anResult + anPos[panOccurr[i]]
		next

		return anResult


		def FindTheseOccurrencesDCSZ(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, TRUE)

		def FindTheseOccurrencesDZ(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING GOING IN   #
	 #   A GIVEN DIRECTION AND RETURNING THOSE POSITIONS AS SECTIONS               #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		nLen = len(anPos)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []
		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesDCSZZ(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, TRUE)

		#< @FunctionAlternativeForms

		def FindTheseOccurrencesDZZ(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)

		#>

	   #=============================================#
	  #   FINDING NEXT OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION              #
	#=============================================#

	#TODO: Add FindAllNextAsSectionsCS()
	# 	    FindNextAsSectionCS()

	def FindAllNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(pnStartingAt, :LastChar)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		anResult = []

		if len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt).Content()
		ok

		return anResult
		
		def FindAllNextCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindAllNextST(pcSubStr, pnStartingAt)
		return This.FindAllNextSTCS(pcSubStr, pnStartingAt, TRUE)

		def FindAllNextZ(pcSubStr, pnStartingAt)
			return This.FindAllNextST(pcSubStr, pnStartingAt)

	   #-------------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION                  #
	#-------------------------------------------------#

	#TODO:
	# 	def FindAllPreviousAsSection()
	# 	def FindAllNextAsSection()

	def FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(1, pnStartingAt)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPos

		#< @FunctionAlternativeForms

		def FindAllPreviousCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def FindAllPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def FindAllPreviousSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAllPrevious(pcSubStr, pnStartingAt)
		aResult = This.FindAllPreviousCS(pcSubStr, pnStartingAt, TRUE)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllPreviousZ(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		#--

		def FindAllPreviousST(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		def FindAllPreviousSTZ(pcSubStr, pnStartingAt)
			return This.FindAllPrevious(pcSubStr, pnStartingAt)

		#>

	   #=====================================================#
	  #      FINDING NTH NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                   #
	#=====================================================#

	def FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		if CheckParams()

			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if NOT @BothAreNumbers(n, nStart)
				StzRaise("Incorrect param type! n and nStart must be numbers.")
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
	
			ok

		ok

		# Early checks (gains performance for large strings)

		if EarlyChecks()
	
			if pcSubStr = ""
				return 0
			ok
	
			if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
				return 0
			ok
	
			nLen = This.NumberOfChars()
	
			if nStart = nLen
				return 0
			ok

			if n < 1 or n > nLen
				return 0
			ok

			if nStart < 1 or nStart > nLen
				return 0
			ok

			if n = nLen and
			   This.LastCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
				return nLen
			ok

		ok

		# Doint the job

		nResult  = This.SectionQ(nStart, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

		if nResult != 0
			nResult += nStart - 1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthSTCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextSTCSZ( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNextNthSTCSZ( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		def FindNextNthCS( n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextSTCS( n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WYHOUT CASESENSITIVITY

	def FindNthNextST(n, pcSubStr, nStart)
		return This.FindNthNextSTCS(n, pcSubStr, nStart, TRUE)

		#< @FunctionAlternativeForms

		def FindNextNthST( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNthNextSTZ( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNextNthSTZ( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNthNext( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		def FindNextNth( n, pcSubStr, nStart )
			return This.FindNthNextST( n, pcSubStr, nStart )

		#>

	  #--------------------------------------------------------------------------------------#
	 #  FINFING NTH NEXT OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#--------------------------------------------------------------------------------------#

	def FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
		#< @FunctionAlternativeForm

		def FindNthNextCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#--

		def FindNthNextAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthNextSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FindNthNextAsSection(n, pcSubStr, nStart )
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, TRUE)
	
		#< @FunctionAlternativeForm

		def FindNthNextZZ(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart)

		#--

		def FindNthNextAsSectionST(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart )

		def FindNthNextSTZZ(n, pcSubStr, nStart )
			return This.FindNthNextAsSection(n, pcSubStr, nStart )

		#>

	   #=========================================================#
	  #      FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                       #
	#=========================================================#

	def FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		if CheckParams()

			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isString(nStart) and Q(nStart).IsEither(:Last, :Or = :LastChar)
				nStart = This.NumberOfChars()
			ok
	
			if isString(n)
				oNString = Q(n)
	
				if oNString.IsEither(:First, :Or = :FirstOccurrence)
					n = 1
	
				but oNString.IsEither(:Last, :Or = :LastOccurrence)
					n = This.SectionQ(1, nStart).NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
				ok
			ok
	
			if NOT @BothAreNumbers(n, nStart)
				StzRaise("Incorrect param type! n and nStart must be numbers.")
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
	
			ok

		ok

		# Early checks (gains performance for large strings)

		if EarlyChecks()

			if pcSubStr = ""
				return 0
			ok
	
			if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
				return 0
			ok
	
			nLen = This.NumberOfChars()
	
			if nStart = 1
				return 0
			ok
	
			if (NOT Q(n).IsBetween(1, nLen - 1)) or
			   (NOT Q(nStart).IsBetween(n + 1, nLen))
	
				return 0
			ok
	
			if n = nLen and
			   This.FirstCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
				return nLen
			ok

		ok

		# Full check (only occurrences of pcSubStr are parsed, not every char)

		nPos = nStart + 1
		nFound = 0
		i = 0

		while TRUE
			i++
			if i > nLen
				exit
			ok

			nPos = This.FindPreviousCS(pcSubStr, :StartingAt = nPos, pCaseSensitive)

			if nPos = 0
				exit
			else
				nFound++
				if nFound = n
					return nPos
				ok
			ok
		end

		return 0

		#< @FunctionAlternativeForms

		def FindPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
 
		def FindNthPreviousCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def FindPreviousNthSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthSTCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindNthPreviousSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindNthPreviousSTCSZ(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousNth(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindPreviousNthZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		#--

		def FindPreviousNthST(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindPreviousNthSTZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousST(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		def FindNthPreviousSTZ(n, pcSubStr, nStart)
			return This.FindNthPrevious(n, pcSubStr, nStart)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINFING NTH PREVIOUS OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#------------------------------------------------------------------------------------------#

	def FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		nPos = This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult

		#< @FunctionAlternativeForms

		def FindPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthPreviousCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindPreviousNthCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#--

		def FindNthPreviousAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

		def FindPreviousNthAsSectionSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindNthPreviousSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		def FindPreviousNthSTCSZZ(n, pcSubStr, nStart, pCaseSensitive )
			return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FindNthPreviousAsSection(n, pcSubStr, nStart )
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousNthAsSection(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindNthPreviousZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		#--

		def FindNthPreviousAsSectionST(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthAsSectionST(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindNthPreviousSTZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		def FindPreviousNthSTZZ(n, pcSubStr, nStart)
			return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

		#>

	   #-------------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION               #
	#-------------------------------------------------#

	#TODO //Add FindNextW() FindPreviousW()

	def FindNextCS(pcSubStr, nStart, pCaseSensitive)
		#< QTBased | Uses: QString.IndexOf() >

		if CheckParams()

			# Resolving pcSubStr param

			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			# Resolving nStart param

			if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if NOT isNumber(nStart)
				StzRaise("Incorrect param type! nStart must be a number.")
			ok

			# Resolving pCaseSensitive param

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if isString(pCaseSensitive)
				if Q(pCaseSensitive).IsOneOfThese([
					:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])
	
					pCaseSensitive = TRUE
				
				but Q(pCaseSensitive).IsOneOfThese([
					:CaseInSensitive, :NotCaseSensitive, :NotCS,
					:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])
	
					pCaseSensitive = FALSE
				ok
	
			ok
	
			if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
				stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
			ok

		ok

		# Doing the job (Qt-side)

		nResult = QStringObject().indexof(pcSubStr, nStart, pCaseSensitive) + 1

		return nResult
		
		#< @FunctionAlternativeForm

		def FindNextCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		#--

		def FindNextSubStringCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSubStringSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		def FindNextSubStringSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindNextCS(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNext(pcSubStr, nStart)
		return This.FindNextCS(pcSubStr, nStart, TRUE)

		#< @FunctionAlternativeForm

		def FindNextZ(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextST(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSTZ(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		#--

		def FindNextSubString(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSubStringST(pcSubStr, nStart)
			return This.FindNext(pcSubStr, nStart)

		def FindNextSubStringSTZ(pcSubStr, nStart)
			return This.FindNextCS(pcSubStr, nStart)

		#>

	   #-----------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING FROM A GIVEN POSITION N               #
	#-----------------------------------------------------#

	def FindPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckParams()

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

		ok

		if EarlyCheck()

			if pcSubStr = "" or
			   NOT This.ContainsCS(pcSubStr, pCaseSensitive)
	
				return 0
			ok

		ok

		nResult = This.SectionQ(1, pnStartingAt - 1).FindLastCS(pcSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindPreviousCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		#--

		def FindPreviousSubStringCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSubStringSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		def FindPreviousSubStringSTCSZ(pcSubStr, nStart, pCaseSensitive)
			return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPrevious(pcSubStr, nStart)
		return This.FindPreviousCS(pcSubStr, nStart, TRUE)
	
		#< @FunctionAlternativeForm

		def FindPreviousZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousST(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSTZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		#--

		def FindPreviousSubString(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSubStringST(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		def FindPreviousSubStringSTZ(pcSubStr, nStart)
			return This.FindPrevious(pcSubStr, nStart)

		#>

	  #-------------------------------------------------#
	 #      FINDING ALL OCCURRENCES OF A SUBSTRING     #
	#=================================================#

	def FindCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		# Resolving the pcSubStr param

		if CheckParams()

			if isList(pcSubStr) and @IsListOfStrings(pcSubStr)
				return This.FindManyCS(pcSubStr, pCaseSensitive)
			ok
	
			if isList(pcSubStr) and
				( Q(pcSubStr).IsOfNamedParam() or
				  Q(pcSubStr).IsOfSubStringNamedParam() )
	
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				stzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
				return []
			ok
	
			# Resolving pCaseSensitive
	
			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if isString(pCaseSensitive)
				if Q(pCaseSensitive).IsOneOfThese([
					:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])
	
					pCaseSensitive = TRUE
				
				but Q(pCaseSensitive).IsOneOfThese([
					:CaseInSensitive, :NotCaseSensitive, :NotCS,
					:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])
	
					pCaseSensitive = FALSE
				ok
	
			ok
	
			if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
				stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
			ok
		ok

		# Doing the job

		nLenString = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		if nLenString < nLenSubStr
			return []
		ok

		anResult = []

		bContinue = TRUE
		nPos = 0

		while bContinue
			
			nPos = This.QStringObject().indexOf(pcSubStr, nPos, pCaseSensitive) + 1

			if nPos = 0
				bContinue = FALSE
			else
				anResult + nPos
			ok
		end

		return anResult

		#< @FunctionFluentForm

		def FindCSQ(pcSubStr, pCaseSensitive)
				return This.FindCSQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms # See other in botton of file ALTERNATIVES section

		def FindCSZ(pcSubStr, pCaseSensitive)
			return This.FindCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Find(pcSubStr)
		return This.FindCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def FindQ(pcSubStr)
			return This.FindQR(pcSubStr, :stzList)
		
		def FindQR(pcSubStr, pcReturnType)
				return This.FindCSQR(pcSubStr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms : See others in bottom of file

		def FindZ(pcSubStr)
			return This.Find(pcSubStr)

		#>

	  #-------------------------------------------#
	 #  GETTING THE SUBSTRING AND ITS POSITIONS  #
	#===========================================#

	def SubStringCSZ(pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

	#-- WITHOUT CASESENSITIVITY

	def SubStringZ(pcSubStr)
		return This.SubStringCSZ(pcSubStr, TRUE)

	  #------------------------------------------#
	 #  GETTING THE SUBSTRING AND ITS SECTIONS  #
	#------------------------------------------#

	def SubStringCSZZ(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]
		return aResult
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringZZ(pcSubStr)
		return This.SubStringCSZZ(pcSubStr, TRUE)

	  #--------------------------------------------------#
	 #  FINDING POSITIONS OF ANTI-PARTS OF A SUBSTRING  #
	#==================================================#

	def AntiFindCS(pcSubStr, pCaseSensitive)
		anSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(anSections)

		anResult = []
		
		for i = 1 to nLen
			nLenSection = len(anSections[i])
			for j = 1 to nLenSection
				if ring_find(anResult, anSections[i][j]) = 0
					anResult + anSections[i][j]
				ok
			next
		next

		return anResult

		def AntiFindCSZ(pcSubStr, pCaseSensitive)
			return This.AntiFindCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pcSubStr)
		return This.AntiFindCS(pcSubStr, TRUE)

		def AntiFindZ(pcSubStr)
			return This.AntiFind(pcSubStr)

	  #===============================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING IN A GIVEN DIRECTION  #
	#===============================================================#

	def FindDCS(pcSubStr, pcDirection, pCaseSensitive)
		
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		if pcDirection = :Forward or pcDirection = :Default
			return This.FindCS(pcSubStr, pCaseSensitive)

		but pcDirection = :Backward
			return This.FindAllCSQ(pcSubStr, pCaseSensitive).Reversed()

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok

		#< @FunctionFluentForm

		def FindDCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#--

		def FindDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindOccurrencesDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>
 
	#-- WITHOUT CASESENSITIVITY

	def FindD(pcSubStr, pcDirection)
		return This.FindDCS(pcSubStr, pcDirection, TRUE)

		#< @FunctionFluentForm

		def FindDQ(pcSubStr, pcDirection)
			return This.FindDQR(pcSubStr, pcDirection, :stzList)
		
		def FindDQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSQR(pcSubStr, pcDirection, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#--

		def FindDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindOccurrencesDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesDZ(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#>

	   #-----------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                        #
	#-----------------------------------------------------------------------#

	def SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringDCSZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.SubStringDCSZQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def SubStringDCSZQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringDZ(pcSubStr, pcDirection)
		return This.SubStringDCSZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionFluentForm

		def SubStringDZQ(pcSubStr, pcDirection)
			return This.SubStringDZQR(pcSubStr, pcDirection, :stzList)
		
		def SubStringDZQR(pcSubStr, pcDirection, pcReturnType)
				return This.SubStringDCSZQR(pcSubStr, pcDirection, TRUE, pcReturnType)

		#>

	   #-----------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS            #
	#-----------------------------------------------------------------------#

	def SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		if pcDirection = :Forward or pcDirection = :Default
			return [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]

		but pcDirection = :Backward
			return [ pcSubStr, This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed() ]

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok
		

		#< @FunctionFluentForm

		def SubStringDCSZZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.SubStringDCSZZQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def SubStringDCSZZQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringDZZ(pcSubStr, pcDirection)
		return This.FindDCSZZ(pcSubStr, pcDirection, TRUE)

		#< @FunctionFluentForm

		def SubStringDZZQ(pcSubStr, pcDirection)
			return This.SubStringDZZQR(pcSubStr, pcDirection, :stzList)
		
		def SubStringDZZQR(pcSubStr, pcDirection, pcReturnType)
				return This.SubStringDCSZZQR(pcSubStr, pcDirection, TRUE, pcReturnType)

		#>

	  #=========================================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING STARTING FROM A GIVEN POSITION  #
	#=========================================================================#

	/* TODO - FUTURE
	the ..ST() extension here must also mean :StoppingAt
	*/

	def FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if CheckParams()
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok
		ok

		# Doing the job

		nLen = This.NumberOfChars()
		anPos = This.SectionQ(pnStartingAt, nLen).FindCS(pcSubStr, pCaseSensitive)

		anResult = []

		if Len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddedToEach(pnStartingAt - 1)
		ok

		return anResult


		#< @FunctionFluentForm

		def FindSCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindS(pcSubStr, pnStartingAt)
		return This.FindSCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def FindSQ(pcSubStr, pnStartingAt)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSQR(pcSubStr, pnStartingAt, pcReturnType)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)

		#>

		#< @FunctionAlternativeForm

		def FindSTZ(pcSubStr, pnStartingAt)
			return This.FindS(pcSubStr, pnStartingAt)

		#>

	   #-------------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                          #
	#-------------------------------------------------------------------------#

	def SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckParams()

			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		aResult = [ pcSubStr, This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringSTCSZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.SubStringSTCSZQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def SubStringSTCSZQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringSTCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringSTZ(pcSubStr, pnStartingAt)
		return This.SubStringSTCSZ(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def SubStringSTZQ(pcSubStr, pnStartingAt)
			return This.SubStringSTZQR(pcSubStr, pnStartingAt, :stzList)
		
		def SubStringSTZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.SubStringSTCSZQR(pcSubStr, pnStartingAt, TRUE, pcReturnType)

		#>

	   #-------------------------------------------------------------------------#
	  #  GETTING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS              #
	#-------------------------------------------------------------------------#

	def SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		if CheckParams()
			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		aResult = [ pcSubStr, This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def SubStringSTCSZZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.SubStringSTCSZZQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def SubStringSTCSZZQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.SubStringSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringSTZZ(pcSubStr, pnStartingAt)
		return This.SubStringSTCSZZ(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def SubStringSTZZQ(pcSubStr, pnStartingAt)
			return This.SubStringSTZZQR(pcSubStr, pnStartingAt, :stzList)
		
		def SubStringSTZZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.SubStringSTCSZZQR(pcSubStr, pnStartingAt, TRUE, pcReturnType)

		#>

	   #===========================================================================#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                           #
	#===========================================================================#

	def FindSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and 
				 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )
	
				StzRaise("Incorrect param! pcDirection must be a string. " +
					 "Allowed values are :Default, :Forward, and :Backward.")
	
			ok

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward or pcDirection = :Default
			anResult = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		else // pcDirection = :Backward

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

			anResult = This.SectionQ(1, pnStartingAt).
					FindCSQ(pcSubStr, pCaseSensitive).
					Reversed()
		ok

		return anResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCS(pcSubStr, pnStartingAt, pcDirection, TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#-------------------------------------------------------------------------------#

	def FindSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCSZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------#

	def FindSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#==================================================================#

	#TODO // check performance
	# ~> May use the implementation of SubStrings()

	def FindSubStringAsSectionsWCS(pcSubStr, pcCondition, pCaseSensitive)
		if CheckParams()
			if NOT @BothAreSrings(pcSubStr, pcCondition)
				StzRaise("Incorrect param type! pcSubStr and pcCondition must be both strings.")
			ok
		ok

		# Doing the job

		acSubStrZZ = This.SubStringsWCSZZ(pcCondition, pCaseSensitive)
		nLen = len(acSubStrZZ)

		aResult = []

		for i = 1 to nLen
			if acSubStrZZ[i][1] = pcSubStr
				aResult + acSubStrZZ[i][2]
			ok
		next

		#< @FunctionAlternativeForm

		def FindSubStringWCSZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringAsSectionsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSectionsW(pcSubStr, pcCondition)
		return This.FindSubStringAsSectionsWCS(pcSubStr, pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringWZZ(pcCondition)
			return This.FindSubStringAsSectionsW(pcCondition)

		#>

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- WXT/EXETENDED      #
	#------------------------------------------------------------------#

	def FindSubStringAsSectionsWCSXT(pcSubStr, pcCondition, pCaseSensitive)
		if CheckParams()
			if NOT @BothAreSrings(pcSubStr, pcCondition)
				StzRaise("Incorrect param type! pcSubStr and pcCondition must be both strings.")
			ok
		ok

		# Doing the job

		acSubStrZZ = This.SubStringsWCSXTZZ(pcCondition, pCaseSensitive)
		nLen = len(acSubStrZZ)

		aResult = []

		for i = 1 to nLen
			if acSubStrZZ[i][1] = pcSubStr
				aResult + acSubStrZZ[i][2]
			ok
		next

		#< @FunctionAlternativeForm

		def FindSubStringWCSXTZZ(pcCondition, pCaseSensitive)
			return This.FindSubStringAsSectionsWXTCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSectionsWXT(pcSubStr, pcCondition)
		return This.FindSubStringAsSectionsWXTCS(pcSubStr, pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringWXTZZ(pcCondition)
			return This.FindSubStringAsSectionsWXT(pcCondition)

		#>

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#================================================================#

	def FindNthCharWCS(n, pcCondition, pCaseSensitive)
		#TODO
		# Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextCharW() and use it instead.

		if CheckParams()
			if isString(n)
				if n = :FirstChar or n = :First
					n = 1
				but n = :LastChar or n = :Last
					n = len(This.FindCharsWCS(pcCondition, pCaseSensitive))
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthCharWCSZ(n, pcCondition, pCaseSensitive)
			return This.FindNthCharWCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVIE

	def FindNthCharW(n, pcCondition)
		return This.FindNthCharWCS(n, pcCondition, TRUE)

		def FindNthCharWZ(n, pcCondition)
			return This.FindNthCharW(n, pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------------#

	def FindNthCharWXTCS(n, pcCondition, pCaseSensitive)

		if CheckParams()
			if isString(n)
				if n = :FirstChar or n = :First
					n = 1
				but n = :LastChar or n = :Last
					n = len(This.FindCharsWxtcs(pcCondition, pCaseSensitive))
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCharsWXTCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthCharWCSXTZ(n, pcCondition, pCaseSensitive)
			return This.FindNthCharWXTCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVIE

	def FindNthCharWXT(n, pcCondition)
		return This.FindNthCharWXTCS(n, pcCondition, TRUE)

		def FindNthCharWXTZ(n, pcCondition)
			return This.FindNthCharWXT(n, pcCondition)

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#================================================================#

#TODO: Add this function
# def FindNthSubStringWZZ() # returns the nth (conditional substring and its sections)

	def FindNthSubStringWCS(n, pcCondition, pCaseSensitive)
		#TODO: Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextSubStringW() and use it instead.

		if CheckParams()
			if isString(n)
				if n = :FirstSubString or n = :First
					n = 1
				but n = :LastSubString or n = :Last
					n = nLen # In fact, last char is the last substring
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindSubStringsWCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthSubStringWCSZ(n, pcCondition, pCaseSensitive)
			return This.FindNthSubStringWCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringW(n, pcCondition)
		return This.FindNthSubStringWCS(n, pcCondition, TRUE)


		def FindNthSubStringWZ(n, pcCondition)
			return This.FindNthSubStringW(n, pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT  #
	#-----------------------------------------------------------------------#

#TODO: Add this function
# def FindNthSubStringWXTZZ() # returns the nth (conditional substring and its sections)

	def FindNthSubStringWXTCS(n, pcCondition, pCaseSensitive)

		if CheckParams()
			if isString(n)
				if n = :FirstSubString or n = :First
					n = 1
				but n = :LastSubString or n = :Last
					n = nLen # In fact, last char is the last substring
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindSubStringsWXTCS(pcCondition, pCaseSensitive)
		nResult = anPos[n]

		return nResult


		def FindNthSubStringWCSXTZ(n, pcCondition, pCaseSensitive)
			return This.FindNthSubStringWXTCS(n, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringWXT(n, pcCondition)
		return This.FindNthSubStringWXTCS(n, pcCondition, TRUE)


		def FindNthSubStringWXTZ(n, pcCondition)
			return This.FindNthSubStringWXT(n, pcCondition)

	  #------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#==================================================================#

	def FindFirstCharWCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWCS(1, pcCondition, pCaseSensitive)

		def FindFirstCharWCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstCharWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstCharW(pcCondition)
		return This.FindFirstCharWCS(pcCondition, TRUE)

		def FindFirstCharWZ(pcCondition)
			return This.FindFirstCharW(pcCondition)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT #
	#------------------------------------------------------------------------#

	def FindFirstCharWXTCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWXTCS(1, pcCondition, pCaseSensitive)

		def FindFirstCharWXTCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstCharWXTCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstCharWXT(pcCondition)
		return This.FindFirstCharWXTCS(pcCondition, TRUE)

		def FindFirstCharWXTZ(pcCondition)
			return This.FindFirstCharWXT(pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	#=======================================================================#

	def FindFirstSubStringWCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCS(1, pcCondition, pCaseSensitive)

		def FindFirstSubStringWCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstSubStringWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringW(pcCondition)
		return This.FindFirstSubStringWCS(pcCondition, TRUE)

		def FindFirstSubStringWZ(pcCondition)
			return This.FindFirstSubStringW(pcCondition)

	  #-----------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION -- WXT #
	#-----------------------------------------------------------------------------#

	def FindFirstSubStringWXTCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWXTCS(1, pcCondition, pCaseSensitive)

		def FindFirstSubStringWXTCSZ(pcCondition, pCaseSensitive)
			return This.FindFirstSubStringWXTCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSubStringWXT(pcCondition)
		return This.FindFirstSubStringWXTCS(pcCondition, TRUE)

		def FindFirstSubStringWXTZ(pcCondition)
			return This.FindFirstSubStringWXT(pcCondition)

	  #-----------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#=================================================================#

	def FindLastCharWCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWCS(1, pcCondition, pCaseSensitive)

		def FindLastCharWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastCharWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastCharW(pcCondition)
		return This.FindLastCharWCS(pcCondition, TRUE)

		def FindLastCharWZ(pcCondition)
			return This.FindLastCharW(pcCondition)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION -- WXT #
	#-----------------------------------------------------------------------#

	def FindLastCharWXTCS(pcCondition, pCaseSensitive)
		return This.FindNthCharWXTCS(1, pcCondition, pCaseSensitive)

		def FindLastCharWXTCSZ(pcCondition, pCaseSensitive)
			return This.FindLastCharWXTCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastCharWXT(pcCondition)
		return This.FindLastCharWXTCS(pcCondition, TRUE)

		def FindLastCharWXTZ(pcCondition)
			return This.FindLastCharWXT(pcCondition)

	  #----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	#======================================================================#

	def FindLastSubStringWCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWCS(1, pcCondition, pCaseSensitive)

		def FindLastSubStringWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSubStringWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringW(pcCondition)
		return This.FindLastSubStringWCS(pcCondition, TRUE)

		def FindLastSubStringWZ(pcCondition)
			return This.FindLastSubStringW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING VERIFYING A GIVEN CONDITION -- WXT #
	#----------------------------------------------------------------------------#

	def FindLastSubStringWXTCS(pcCondition, pCaseSensitive)
		return This.FindNthSubStringWXTCS(1, pcCondition, pCaseSensitive)

		def FindLastSubStringWXTCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSubStringWXTCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSubStringWXT(pcCondition)
		return This.FindLastSubStringWXTCS(pcCondition, TRUE)

		def FindLastSubStringWXTZ(pcCondition)
			return This.FindLastSubStringWXT(pcCondition)

	  #============================================#
	 #  FINDING MANY SUBSTRINGS IN THE SAME TIME  # 
	#============================================#

	def FindManyCS(pacSubStr, pCaseSensitive)
		/*
		o1 = new stzString("My name is Mansour. What's your name please?")
		? o1.FindManyCS( [ "name", "your", "please" ], TRUE )

		#--> [ [ 4, 33 ], [ 28 ], [ 38 ] ]

		*/

		if CheckParams()
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSubStr = U( pacSubStr )
		nLen = len(acSubStr)

		aResult = []

		for i = 1 to nLen
			aResult + This.FindAllCS(acSubStr[i], pCaseSensitive)
		next

		anResult = Q(aResult).FlattenQ().Sorted()
		return anResult

		#< @FunctionFluentForm

		def FindManyCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, :stzList)
	
		def FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def FindManyCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		#--

		def FindTheseCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindManyCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(pacSubStr)
		return This.FindManyCS(pacSubStr, TRUE)

		#< @FunctionFluentForm

		def FindManyQ(pacSubStr)
			return This.FindManyQR(pacSubStr, :stzList)
	
		def FindManyQR(pacSubStr, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindMany(pacSubStr) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindMany(pacSubStr) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def FindManyZ(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindManySubStrings(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindManySubStringsZ(pacSubStr)
			return This.FindMany(pacSubStr)

		#--

		def FindThese(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseZ(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseSubStrings(pacSubStr)
			return This.FindMany(pacSubStr)

		def FindTheseSubStringsZ(pacSubStr)
			return This.FindMany(pacSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING MANY SUBSTRINGS IN THE SAME TIME -- RETURN POSITIONS AS SECTIONS  # 
	#----------------------------------------------------------------------------#

	def FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		nLenSubStr = len(pacSubStr)

		aResult = []

		for i = 1 to nLenSubStr
			aSections = This.FindAsSectionsCS(pacSubStr[i], pCaseSensitive)

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		if len(aResult) > 0
			aResult = Q(aResult).ToStzListOfPairs().Sorted()
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindManyCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindManyAsSections(pacSubStr)
		return This.FindManyAsSectionsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindManySubStringsAsSections(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindManyZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindManySubStringsZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		def FindTheseSubStringsZZ(pacSubStr)
			return This.FindManyAsSections(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING THE POSITIONS OF ALL THE CHARS IN THE STRING  #
	#========================================================#

	def FindCharsCS(pCaseSensitive)
		acChars  = This.CharsCSU(pCaseSensitive)
		anResult = This.FindTheseSubStringsCS(acChars, pCaseSensitive)
		return anResult

		def FindCharsCSZ(pCaseSensitive)
			return This.FindCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindChars()
		return This.FindCharsCS(TRUE)

		def FindCharsZ()
			return This.FindChars()

	  #---------------------------------------------------#
	 #  REMOVING CHARS AT GIVEN POSITIONS OF THE STRING  #
	#===================================================#

	def RemoveCharsAt(panPos)

		if CheckParams()

			if NOT isList(panPos)
				StzRaise("Incorrect param type! panPos must be a list.")
			ok

			if len(panPos) = 0
				return
			ok

			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLen = len(panPos)
		anPos = ring_sort( U(panPos) )
		

		for i = nLen to 1 step -1
			This.RemoveCharAt(anPos[i]) #TODO // check performance!
		next

		def RemoveCharsAtQ(panPos)
			This.RemoveCharsAt(panPos)
			return This

		def RemoveCharsAtPositions(panPos)
			This.RemoveCharsAt(panPos)

			def RemoveCharsAtPositionsQ(panPos)
				This.RemoveCharsAtPositions(panPos)
				return This

	def CharsAtPositionsRemoved(panPos)
		cResult = This.Copy().RemoveCharsAtQ(panPos).Content()
		return cResult

	  #---------------------------------------------#
	 #  FINDING CHARS VERIFYING A GIVEN CONDITION  #
	#=============================================#

	def FindCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindW(pcCondition)
		return anResult

		def FindCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsW(pcCondition)
		return This.FindCharsWCS(pcCondition, TRUE)

		def FindCharsWZ(pcCondition)
			return This.FindCharsW(pcCondition)

	  #-------------------------------------------------------------#
	 #  FINDING CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#-------------------------------------------------------------#

	def FindCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.CharsCSQ(pCaseSensitive).FindWXT(pcCondition)
		return anResult

		def FindCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindCharsWXT(pcCondition)
		return This.FindCharsWCSXT(pcCondition, TRUE)

		def FindCharsWXTZ(pcCondition)
			return This.FindCharsWXT(pcCondition)

	  #--------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#=============================================================#

	def CharsCSZ(pCaseSensitive)

		aResult = [
			This.CharsCS(pCaseSensitive),
			This.FindCharsCSZ(pCaseSensitive)
		]

		return aResult

		def CharsAndTheirPositionsCS(pCaseSensitive)
			return This.CharsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsZ()
		return This.CharsCSZ(TRUE)

		def CharsAndTheirPositions()
			return This.CharsZ()

	  #-------------------------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING VERIFIFUING A GIVEN CONDITION -- Z/EXTENDED  #
	#===============================================================================#

	def CharsWCSZ(pcCondition, pCaseSensitive)
		acChars = U( This.CharsWCS(pcCondition, pCaseSensitive) )
		anPos = This.FindTheseChars(acChars)

		aResult = @Association([ acChars, anPos ])

		return aResult

		def CharsAndTheirPositionsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCSZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsWZ(pcCondition)
		return This.CharsWCSZ(pcCondition, TRUE)

		def CharsAndTheirPositionsW(pcCondition)
			return This.CharsWZ(pcCondition)

	  #----------------------------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING VERIFIFUING A GIVEN CONDITION -- WXTZ/EXTENDED  #
	#----------------------------------------------------------------------------------#

	def CharsWCSXTZ(pcCondition, pCaseSensitive)
		acChars = U( This.CharsWCSXT(pcCondition, pCaseSensitive) )
		anPos = This.FindTheseChars(acChars)

		aResult = @Association([ acChars, anPos ])

		return aResult

		def CharsAndTheirPositionsWCSXTs(pcCondition, pCaseSensitive)
			return This.CharsWCSXTZ(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CharsWXTZ(pcCondition)
		return This.CharsWCSXTZ(pcCondition, TRUE)

		def CharsAndTheirPositionsWXT(pcCondition)
			return This.CharsWXTZ(pcCondition)

	  #--------------------------------------------#
	 #  FINDING THE POSITIONS OF THE GIVEN CHARS  #
	#============================================#

	def FindTheseCharsCS(pacChars, pCaseSensitive)

		if CheckParams()
			if NOT ( isList(pacChars) and Q(pacChars).IsListOfChars() )
				StzRaise("Incorrect param type! pacChars must be a list of chars.")
			ok
		ok

		acChars  = U( pacChars )
		anResult = This.FindTheseSubStringsCS(acChars, pCaseSensitive)
		return anResult

		def FindTheseCharsCSZ(pCaseSensitive)
			return This.FindCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseChars(pacChars)
		return This.FindtheseCharsCS(pacChars, TRUE)

		def FindTheseCharsZ(pacChars)
			return This.FindChars(pacChars)

	  #--------------------------------------------------------------#
	 #  GETTING ALL CHARS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def TheseCharsCSZ(pacChars, pCaseSensitive)

		aResult = [
			pacChars,
			This.FindTheseCharsCSZ(pacChars, pCaseSensitive)
		]

		return aResult

		def TheseCharsAndTheirPositionsCS(pacChars, pCaseSensitive)
			return This.TheseCharsCSZ(pacChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseCharsZ(pacChars)
		return This.TheseCharsCSZ(pacChars, TRUE)

		def TheseCharsAndTheirPositions(pacChars)
			return This.TheseCharsZ(pacChars)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindSubStringBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindSubstringBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSCS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					return This.FindBeforeSubStringCS(p1, p2[2], pCaseSensitive)

				but isNumber(p2[2])
					return This.FindBeforepositionCS(p1, p2[2], pCaseSensitive)

				ok

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindBeforePositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					return This.FindAfterSubStringCS(p1, p2[2], pCaseSensitive)

				but isNumber(p2[2])
					return This.FindAfterPositionCS(p1, p2[2], pCaseSensitive)

				ok

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAfterPositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitive)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					return This.FindBeforeSubStringCS( p1[2], p2[2], pCaseSensitive )


			 	but isNumber(p2[2])
					return This.FindBeforePositionCS( p1[2], p2[2], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindBeforePosirtionCS( p1[2], p2[2], pCaseSensitive )


			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					return This.FindAfterSubStringCS(p1[2], p2[2], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindCSXT(p1, p2, TRUE)

	  #========#
	 #  NOTE  #
	#========#

	#NOTE
	# These fuctions are defined in stzObject:

	# 	FindFirstNOccurrences(n, pStrOrItem)
	# 	FindFirstNOccurrencesST(n, pcStr, pnStartingAt)
	
	# 	FindLastNOccurrences(n, pStrOrItem)
	# 	FindLastNOccurrencesS(n, pcStr, pnStartingAt)

	# I'm experimenting with this technique of abstraction
	# to make them usable also form stzString and stzList

	#TODO
	# Frankly, I'm not decided yet to keep them or reimplement
	# them in each class apart. Think about the pros and cons!
	
	  #=================================================#
	 #  FINDING THINGS AS SECTIONS, THE EXTENDED FORM  #
	#=================================================#

	def FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindAsSectionsXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByAsSectionsCS(p1, p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				anPos = This.SectionQ(p2[2]).FindCS(p1, pCaseSensitive)
				if len(anPos) = 0
					return []
				ok

				anPos = QR(anPos, :stzListOfNumbers).AddedToEach(p2[2])
				nLen = Q(p1).NumberOfChars()

				aSections = []
				for i = 1 to nLen
					aSections + [ anPos[i], anPos[i] + nLen - 1 ]
				next

				return aSections

			# FindAsSectionsXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsCSXT( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindAsSectionsXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstAsSectionsCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsCSXT( p1, :InSection = [nPos, :LastChar], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

			# FindAsSectionsXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenAsSectionCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedAsSectionByCS(n, p1[2], p2, pCaseSensitive)

			# FindAsSectionsXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthAsSectionCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindAsSectionsXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindAsSectionCSXT( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindAsSectionsCSXT( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindAsSectionsXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					return This.FindAsSectionsCSXT( p1[2], :InSection = [n, :LastChar], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1[2], :InSection = [p2[2], :LastChar], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAsSectionsCSXT( p1[2], :InSection = [ p2[2], :LastChar ], pCaseSensitive )

			# FindAsSectionsXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenAsSectionsCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindAsSectionsXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByAsSectionsCS(p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				aSections = This.SectionQ(p2[1], p2[2]).FindAsSectionsCS(p1, pCaseSensitive)
				nLen = len(aSections)
				nLenSubStr = Q(p2).NumberOfChars()

				aResult = []

				for i = 1 to nLen
					aResult + [ (aSections[i][1] + nLenSubStr - 1), (aSections[i][2] + nLenSubStr - 1) ]
				next

				return aResult
			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionAlternativeForm

		def FindAsSectionCSXT(p1, p2, pCaseSensitive)
		# Without an (s) after Section
		# We need it because some forms
		# return definetly only one section
		# like FindAsSectionXT( :3rd = "*" :InSection = ...)

			return This.FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindAsSectionsXT(p1, p2)
		return This.FindAsSectionsCSXT(p1, p2, TRUE)

	  #==========================================================#
	 #  FINDING OCCURRENCES OF A SIUBSTRING IN A GIVEN SECTION  #
	#==========================================================#
	
	def FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastChar ])
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf, :And, :AndPosition ])
				n2 = n2[2]
			ok

			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastChar ])
					n2 = This.NumberOfChars()
				but Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n2 = 1
				ok
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Early checks

		if This.IsEmpty() or pcSubStr = NULL
			return []
		ok

		if n1 = 0 or n2 = 0
			return []
		ok

		# Doing the job

		anPos = This.SectionQ(n1, n2).FindCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

//		n1 = Min([ n1, n2 ]) #TODO use it when Ring fix

aTemp = []
aTemp + n1 + n2
n1 = Min(aTemp)

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

		#< @FunctionAlternativeForm

		def FindInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pcSubStr, n1, n2)
		return This.FindInSectionCS(pcSubStr, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#--

		def FindSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#--

		def FindBetweenPositions(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringBetweenPositions(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#>

	   #---------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS              #
	#---------------------------------------------------------#

	def FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		if nLenSubStr = 0
			return []
		ok

		anPos = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nLen = len(anPos)

		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult
	
		#< @FunctionAlternativeForm

		def FindInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindBetweenPositionsAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionZZ(pcSubStr, n1, n2)
		return This.FindInSectionAsSectionsCS(pcSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindBetweenPositionsAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS  #
	#=======================================================#
	
	def FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		aSections = This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		nLen = len(aSections)

		if nLen = 0
			return []
		ok

		anResult = StzListOfPairsQ(aSections).FirstItems()
		return anResult

		#< @FunctionAlternativeForms

		def FindInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInTheseSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInTheseSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pcSubStr, paSections)
		return This.FindInSectionsCS(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInManySectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#--

		def FindSubStringInSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#--

		def FindInTheseSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInTheseSections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInTheseSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindSubStringInTheseSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#>

	  #=======================================================================================#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION OR A GIVEN SUBSTRING  #
	#=======================================================================================#

	def FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindBeforePositionCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindBeforeSubStringCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBefore(pcSubStr, pPosOrSubStr)
		return This.FindBeforeCS(pcSubStr, pPosOrSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBefore(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBefore(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		#--

		def FindBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindAllBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeZ(pcSubStr, pPosOrSubStr)
			return This.FindBefore(pcSubStr, pPosOrSubStr)

		#>

	   #-----------------------------------------------------------------------#
	  #   FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION OR   #
	 #   A GIVEN SUBSTRING AND RETURNING THEIM AS SECTIONS -- ZZ/EXTENSION   #
	#-----------------------------------------------------------------------#

	def FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesBeforeCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeAsSections(pcSubStr, pPosOrSubStr)
		return This.FindBeforeAsSectionsCS(pcSubStr, pPosOrSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforeAsSections(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeAsSections(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		#--

		def FindBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindAllBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesBeforeZZ(pcSubStr, pPosOrSubStr)
			return This.FindBeforeAsSections(pcSubStr, pPosOrSubStr)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN POSITION  #
	#==================================================================# 

	def FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		anResult = This.FindInSectionCS(pcSubStr, 1, pnPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePosition(pcSubStr, pnPos)
		return This.FindBeforePositionCS(pcSubStr, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforePosition(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindOccurrencesBeforePosition(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		#--

		def FindBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindAllBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionZ(pcSubStr, pnPos)
			return This.FindBeforePosition(pcSubStr, pnPos)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING BEFORE A GIVEN POSITION  #
	#--------------------------------------------------------------------------------# 

	def FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, 1, pnPos, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePositionAsSections(pcSubStr, pnPos)
		return This.FindBeforePositionAsSectionsCS(pcSubStr, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforePositionAsSections(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionAsSections(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		#--

		def FindBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindAllBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesBeforePositionZZ(pcSubStr, pnPos)
			return This.FindBeforePositionAsSections(pcSubStr, pnPos)

		#>

	  #-------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING BEFORE A GIVEN OTHER SUBSTRING  #
	#=========================================================================# 

	def FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		anResult = This.FindInSectionCS(pcSubStr, 1, nPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeSubString(pcSubStr, pcOtherSubStr)
		return This.FindBeforeSubStringCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubString(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		#--

		def FindBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindAllBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubString(pcSubStr, pcOtherSubStr)

		#>

	  #---------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#---------------------------------------------------------------------------------# 

	def FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		aResult = This.FindInSectionAsSectionsCS(1, nPos, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
		return This.FindBeforeSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		#--

		def FindBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindAllBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesBeforeSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindBeforeSubStringAsSections(pcSubStr, pcOtherSubStr)

		#>

	  #======================================================================================#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION OR A GIVEN SUBSTRING  #
	#======================================================================================#

	def FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindAfterPositionCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindAfterSubStringCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCSZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfter(pcSubStr, pPosOrSubStr)
		return This.FindAfterCS(pcSubStr, pPosOrSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfter(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfter(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		#--

		def FindAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindAllAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterZ(pcSubStr, pPosOrSubStr)
			return This.FindAfter(pcSubStr, pPosOrSubStr)

		#>

	   #-----------------------------------------------------------------------#
	  #   FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION OR    #
	 #   A GIVEN SUBSTRING AND RETURNING THEIM AS SECTIONS -- ZZ/EXTENSION   #
	#-----------------------------------------------------------------------#

	def FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		if NOT (isNumber(pPosOrSubStr) or isString(pPosOrSubStr))
			StzRaise("Incorrect param type! pPosOrSubStr must be a number or a string.")
		ok

		if isNumber(pPosOrSubStr)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		else
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#--

		def FindAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindAllAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		def FindOccurrencesAfterCSZZ(pcSubStr, pPosOrSubStr, pCaseSensitive)
			return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterAsSections(pcSubStr, pPosOrSubStr)
		return This.FindAfterAsSectionsCS(pcSubStr, pPosOrSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterAsSections(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterAsSections(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		#--

		def FindAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindAllAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		def FindOccurrencesAfterZZ(pcSubStr, pPosOrSubStr)
			return This.FindAfterAsSections(pcSubStr, pPosOrSubStr)

		#>

	  #-----------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN POSITION  #
	#=================================================================# 

	def FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		nLen = This.NumberOfChars()
		anResult = This.FindInSectionCS(pcSubStr, pnPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPosition(pcSubStr, pnPos)
		return This.FindAfterPositionCS(pcSubStr, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterPosition(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindOccurrencesAfterPosition(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		#--

		def FindAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindAllAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionZ(pcSubStr, pnPos)
			return This.FindAfterPosition(pcSubStr, pnPos)

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING AFTER A GIVEN POSITION  #
	#-------------------------------------------------------------------------------# 

	def FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
		nLen = This.NumberOfChars()
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, pnPos, nLen, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
			return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPositionAsSections(pcSubStr, pnPos)
		return This.FindAfterPositionAsSectionsCS(pcSubStr, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterPositionAsSections(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionAsSections(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		#--

		def FindAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindAllAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		def FindOccurrencesAfterPositionZZ(pcSubStr, pnPos)
			return This.FindAfterPositionAsSections(pcSubStr, pnPos)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A SUBSTRING AFTER A GIVEN SUBSTRING  #
	#==================================================================# 

	def FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfChars()
		anResult = This.FindInSectionCS(pcSubStr, nPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCSZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterSubString(pcSubStr, pcOtherSubStr)
		return This.FindAfterSubStringCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterSubString(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubString(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		#--

		def FindAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindAllAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubString(pcSubStr, pcOtherSubStr)

		#>

	  #--------------------------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES (AS SECTIONS) OF A SUBSTRING AFTER A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------# 

	def FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfChars()
		aResult = This.FindInSectionAsSectionsCS(pcSubStr, nPos, nLen, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
		return This.FindAfterSubStringAsSectionsCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringAsSections(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		#--

		def FindAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindAllAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		def FindOccurrencesAfterSubStringZZ(pcSubStr, pcOtherSubStr)
			return This.FindAfterSubStringAsSections(pcSubStr, pcOtherSubStr)

		#>

	   #=================================================================#
	  #  FINING NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION,  #
	 #  SECTION, OR GIVEN OTHER SUBSTRING                              #
	#=================================================================#

	#TODO
	# Add FindNNearest(n, pItem, pToPositionSectionOrItem, pCaseSensitive)

	def FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		if CheckParams()
			if NOT isString(pcSubStr)
				StzString("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isNumber(pToPositionSectionOrSubStr) or
				 isList(pToPositionSectionOrSubStr) or
				 isString(pToPositionSectionOrSubStr) )

				StzRaise("Incorrect param type! pToPositionSectionOrSubStr must be " +
					 "a number, a list of numbers, a string or a list.")

			ok
		ok

		if isNumber(pToPositionSectionOrSubStr)
			return This.FindNearestToPositionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		but isString(pToPositionSectionOrSubStr)
			return This.FindNearestToSubStringCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

		else // isList()

			if @IsListOfNumbers(pToPositionSectionOrSubStr)
				return This.FindNearestToPositionsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but @IsPairOfNumbers(pToPositionSectionOrSubStr)
				return This.FindNearestTSectionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but @IsListOfPairsOfNumbers(pToPositionSectionOrSubStr)

				return This.FindNearestToSectionsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
	
			but @IsListOfStrings(pToPositionSectionOrSubStr)
				return This.FindNearestToSubStringsCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
	
			but isList(pToPositionSectionOrSubStr)
				oParam = Q(pToPositionSectionOrSubStr)
		
				if oParam.IsToNamedParam()
					return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToPositionNamedParam()
					return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToPositionsNamedParam()
					return This.FindNearestToPositionsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSectionNamedParam()
		
					n1 = pToPositionSectionOrSubStr[2][1]
					n2 = pToPositionSectionOrSubStr[2][2]
		
					return This.FindNearestToSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		
				but oParam.IsToSectionsNamedParam()
					return This.FindNearestToSectionsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSubStringNamedParam()
					return This.FindNearestToSubStringCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				but oParam.IsToSubStringsNamedParam()
					return This.FindNearestToSubStringsCS(pcSubStr, pToPositionSectionOrSubStr[2], pCaseSensitive)
		
				ok
	
			ok

			return 0
		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNearest(pcSubStr, pToPositionSectionOrSubStr)
		return This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, TRUE)

	   #----------------------------------------------------------------------#
	  #  FINdING NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION,      #
	 #  SECTION, OR GIVEN OTHER SUBSTRING, AND RETURNING THEIM AS SECTIONS  #                           #
	#----------------------------------------------------------------------#

	def FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
		n = This.FindNearestCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestAsSectionCS(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)
			return This.FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestZZ(pcSubStr, pToPositionSectionOrSubStr)
		return This.FindNearestCSZZ(pcSubStr, pToPositionSectionOrSubStr, TRUE)

		def FindNearestAsSection(pcSubStr, pToPositionSectionOrSubStr)
			return This.FindNearestZZ(pcSubStr, pToPositionSectionOrSubStr)

	  #---------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION  #
	#=====================================================================#

	def FindNearestToPositionCS(pcSubStr, pnPos, pCaseSensitive)

		if EarlyCheck()
			if This.NumberOfChars() = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(pnPos)
				if pnPos = :FirstChar
					pnPos = 1
				but pnPos = :LastChar
					pnPos = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok

		ok

		if NOT pnPos > 0 and pnPos < This.NumberOfChars()
			StzRaise("Index out of range!")
		ok

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anDiff = []
		for i = 1 to nLen
			anDiff + Abs(pnPos - anPos[i])
		next

		nResult = anPos[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPosition(pcSubStr, pnPos)
		return This.FindNearestToPositionCS(pcSubStr, pnPos, TRUE)

	   #---------------------------------------------------------------------#
	  #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN POSITION  #
	 #  AND RETURNING IT AS A SECTION                                      #
	#--------------------------------------------------------------------#

	def FindNearestToPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)
		n = This.FindNearestToPositionCS(pcSubStr, pnPos, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestToPositionAsSectionCS(pcSubStr, pnPos, pCaseSensitive)
			return This.FindNearestToPositionCSZZ(pcSubStr, pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionZZ(pcSubStr, pnPos)
		return This.FindNearestToPositionCSZZ(pcSubStr, pnPos, TRUE)

		def FindNearestToPositionAsSection(pcSubStr, pnPos)
			return This.FindNearestToPositionZZ(pcSubStr, pnPos)
	
	  #----------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCES OF A SUBSTRING TO A GIVEN POSITION -- XT  #
	#----------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToPositionCSXT(pcSubStr, pnPos, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok
		ok

		nLenStr = This.NumberOfChars()

		if pnPos < 1 ans pnPos > nLenStr
			StzRaise("Index out of range! pnPost must be inside the string.")
		ok

		anResult = This.FindNearestToSectionCSXT(pcSubStr, pnPos, pnPos, pCaseSensitive)

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionXT(pcSubStr, pnPos)
		return This.FindNearestToPositionCSXT(pcSubStr, pnPos, TRUE)

	  #----------------------------------------------------------------#
	 #  FINDING NEAREST OCCURRENCE OF AN ITEM TO THE GIVEN POSITIONS  #
	#================================================================#

	def FindNearestToPositionsCS(pcSubStr, panPos, pCaseSensitive)
	
		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckParams()

			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return 0
		ok

		anNearest = []
		anDiff = []

		for i = 1 to nLenPos
			anTemp = This.FindNearestToPositionCSXT(pcSubStr, panPos[i], pCaseSensitive)
			nDiff1 = panPos[i] - anTemp[1]
			nDiff2 = anTemp[2] - panPos[i]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

		def FindNearestToPositionsCSZ(pcSubStr, panPos, pCaseSensitive)
			return This.FindNearestToPositionsCS(pcSubStr, panPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositions(pcSubStr, panPos)
		return This.FindNearestToPositionsCS(pcSubStr, panPos, TRUE)

		def FindNearestToPositionsZ(pcSubStr, panPos)
			return This.FindNearestToPositions(pcSubStr, panPos)

	  #--------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN SECTION  #
	#====================================================================#

	def FindNearestToSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(n1)
				if n1 = :FirstChar
					n1 = 1

				but n1 = :LastChar
					n1 = nLenStr
				ok
			ok
			if isString(n2)
				if n2 = :LastChar
					n2 = nLenStr

				but n2 = :FirstChar
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenStr) and (n2 > 0 and n2 < nLenStr) )
			StzRaise("Index out of range! n1 and n2 must be both inside the string.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pcSubStr, n1, pCaseSensitive)
		nDistBefore = n1 - nNearestBefore

		nNearestAfter  = This.SectionQ(n2, nLenStr).
				 FindNearestToPositionCS(pcSubStr, 1, pCaseSensitive) + n2 - 1

		nDistAfter = nNearestAfter - n2
		
		if nDistBefore < nDistAfter
			nResult = nNearestBefore
		else
			nResult = nNearestAfter
		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSection(pcSubStr, n1, n2)
		return This.FindNearestToSectionCS(pcSubStr, n1, n2, TRUE)

	  #-------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN SECTION -- XT #
	#-------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToSectionCSXT(pcSubStr, n1, n2, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(n1)
				if n1 = :FirstChar
					n1 = 1

				but n1 = :LastChar
					n1 = nLenStr
				ok
			ok
			if isString(n2)
				if n2 = :LastChar
					n2 = nLenStr

				but n2 = :FirstChar
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenStr) and (n2 > 0 and n2 < nLenStr) )
			StzRaise("Index out of range! n1 and n2 must be both inside the string.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pcSubStr, n1, pCaseSensitive)

		nNearestAfter  = This.SectionQ(n2, nLenStr).
				 FindNearestToPositionCS(pcSubStr, 1, pCaseSensitive) + n2 - 1

		anResult = [ nNearestBefore, nNearestAfter ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSectionXT(pcSubStr, n1, n2)
		return This.FindNearestToSectionCSXT(pcSubStr, n1, n2, TRUE)

	  #-----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO THE SECTIONS  #
	#-----------------------------------------------------------------#

	def FindNearestToSectionsCS(pcSubStr, paSections, pCaseSensitive)

		nLenStr = This.NumberOfChars()

		if EarlyCheck()
			if nLenStr = 0
				return 0
			ok
		ok

		if CheckParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		nLenSections = len(paSections)
		anNearest = []
		anDiff = []

		for i = 1 to nLenSections
			anTemp = This.FindNearestToSectionCSXT(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nDiff1 = paSections[i][1] - anTemp[1]
			nDiff2 = anTemp[2] - paSections[i][2]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next
		
		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSections(pcSubStr, paSections)
		return This.FindNearestToSectionsCS(pcSubStr, paSections, TRUE)

	  #----------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN OTHER SUBSTRING  #
	#============================================================================#

	def FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcOtherSubStr, pCaseSensitive)
		nResult = This.FindNearestToSectionsCS(pcSubStr, aSections, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubString(pcSubStr, pcOtherSubStr)
		return This.FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, TRUE)

	   #----------------------------------------------------------------------------#
	  #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO A GIVEN OTHER SUBSTRING  #
	 #  AND RETURNING ITS POSITION AS A SECTION                                   #
	#----------------------------------------------------------------------------#

	def FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)
		n = This.FindNearestToSubStringCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		if n = 0
			return []
		ok

		nLenStr = StzStringQ(pcSubStr).NumberOfChars()
		aResult = [ n, n + nLenStr - 1 ]

		return aResult

		def FindNearestToSubStringAsSectionCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubStringZZ(pcSubStr, pcOtherSubStr)
		return This.FindNearestToSubStringCSZZ(pcSubStr, pcOtherSubStr, TRUE)

		def FindNearestToSubStringAsSection(pcSubStr, pcOtherSubStr)
			return This.FindNearestToSubStringZZ(pcSubStr, pcOtherSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF A SUBSTRING TO GIVEN OTHER SUBSTRINGS  #
	#===========================================================================#

	def FindNearestToSubStringsCS(pcSubStr, pacOtherSubStr, pCaseSensitive)
		aSections = This.FindManyAsSectionsCS(pacOtherSubStr, pCaseSensitive)
		nResult = This.FindNearestToSectionsCS(pcSubStr, aSections, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSubStrings(pcSubStr, pacOtherSubStr)
		return This.FindNearestToSubStringsCS(pcSubStr, pacOtherSubStr, TRUE)

	  #======================================================================#
	 #  GETTING NUMBER OF OCCURRENCES OF A SUBSTRING IN THE GIVEN SECTIONS  #
	#======================================================================#

	def NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		nResult = len( This.FindSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive) )
		return nResult

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrenceInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrenceOfSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def NumberOfOccurrencesOfSubStringInTheseSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrencesInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrenceOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def HowManyOccurrencesOfSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceInSections(pcSubStr, paSections)
		return This.NumberOfOccurrenceInSectionsCS(pcSubStr, paSections, TRUE)

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrenceInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrenceOfSubStringInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def NumberOfOccurrencesOfSubStringInTheseSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrenceInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrencesInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrenceOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		def HowManyOccurrencesOfSubStringInSections(pcSubStr, paSections)
			return This.NumberOfOccurrenceInSections(pcSubStr, paSections)

		#>

	   #--------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION               #
	#========================================================#

	def FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindSubStringInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionsZZ(pcSubStr, paSections)
		return This.FindInSectionsCSZZ(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindInSectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		#--

		def FindSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInSectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindSubStringInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		#>

	  #------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#============================================================#

	def FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastChar ])
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastChar ])
					n2 = This.NumberOfChars()
				but Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		nPos = This.SectionQ(n1, n2).FindNthCS(n, pcSubStr, pCaseSensitive)
		nResult = n1 + nPos - 1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthInSectionCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthBeweenPositionsCSIBZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIBZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1+1, n2-1, pCaseSensitive)

		def FindNthBeweenPositionsCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1+1, n2-1, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSection(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCS(n, pcSubStr, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindNthInSectionZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringInSection(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthBeweenPositionsIBZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIBZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositions(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1+1, n2-1)

		def FindNthBeweenPositionsZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1+1, n2-1)

		#>

	   #------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                   #
	#------------------------------------------------------------#

	def FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nPos = This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anResult = [nPos, nPos + nLenSubStr - 1]
		
		return anResult
	
		#< @FunctionAlternativeForm

		def FindNthInSectionAsSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSennsitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringInSectionAsSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindNthBeweenPositionsCSIBZZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsCSIBZZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthBeweenPositionsAsSectionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		def FindNthSubStringBeweenPositionsAsSectionsCSIB(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionZZ(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindNthInSectionAsSection(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		def FindNthSubStringInSectionAsSection(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		#--

		def FindNthBeweenPositionsIBZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsIBZZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthBeweenPositionsAsSectionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		def FindNthSubStringBeweenPositionsAsSectionsIB(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#----------------------------------------------------------#

	def FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)
		aPosZZ = FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
		nLen = len(aPosZZ)

		nResult = 0
		if nLen > 0
			nResult = aPosZZ[1]
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNthInManySectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInSectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#--

		def FindNthSubStringInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInSectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSections(n, pcSubStr, paSections)
		return This.FindNthInSectionsCS(n, pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindNthInManySections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthInSectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthInManySectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#--

		def FindNthSubStringInSections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInManySections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInSectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []
		nCounter = 0

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				nCounter++
				if nCounter = n
					aResult = [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
					exit
				ok
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		#--

		def FindNthSubStringInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInSectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthSubStringInManySectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionsZZ(n, pcSubStr, paSections)
		return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(pcSubStr, paSections)

		def FindNthInManySectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthInManySectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		#--

		def FindNthSubStringInSectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInSectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthSubStringInManySectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#==============================================================#

	def FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindFirstBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSection(pcSubStr, n1, n2)
		return This.FindFirstInSectionCS(pcSubStr, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindFirstInSectionZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringInSection(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		#--

		def FindFirstBetweenPositions(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositions(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		#>

	   #--------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                     #
	#--------------------------------------------------------------#

	def FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindFirstSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindFirstInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstBetweenPositionsAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindFirstSubStringBetweenPositionsAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionZZ(pcSubStr, n1, n2)
		return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsZZ(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindFirstInSectionAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringInSectionAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstBetweenPositionsAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		def FindFirstSubStringBetweenPositionsAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		#>

	  #------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#------------------------------------------------------------#

	def FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindFirstInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindFirstSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSections(pcSubStr, paSections)
		return This.FindFirstInSectionsCS(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstInManySections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstInSectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstInManySectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#--

		def FindFirstSubStringInSections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInManySections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindFirstInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindFirstSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstSubStringInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionsZZ(pcSubStr, paSections)
		return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		#--

		def FindFirstSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInSectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstSubStringInManySectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#=============================================================#

	def FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FinfLastSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FinfLastSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSection(pcSubStr, n1, n2)
		return This.FindLastInSectionCS(pcSubStr, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindLastInSectionZ(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		def FinfLastSubStringInSection(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		def FinfLastSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		#>

	   #-------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                    #
	#-------------------------------------------------------------#

	def FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindLastInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindLastSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindLastSubStringInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionZZ(pcSubStr, n1, n2)
		return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastInSectionAsSection(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		def FindLastSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		def FindLastSubStringInSectionAsSection(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindLastInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindLastSubStringInSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSections(pcSubStr, paSections)
		return This.FindLastInSectionsCS(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindLastInManySections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastInSectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastInManySectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#--

		def FindLastSubStringInSections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInManySections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInSectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastSubStringInManySectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindLastInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindLastSubStringInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastSubStringInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionsZZ(pcSubStr, paSections)
		return This.FindLastInSectionsCSZZ(pcSubStr, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		#--

		def FindLastSubStringInSectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInSectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInManySectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastSubStringInManySectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		#>

	  #===================================================#
	 #   FINDING BY PATTERN (AN ALTERNATIVE TO REGEXP)   #TODO (FUTURE)
	#===================================================#

	// Finds all the occurrences of a given substring in the string
	// depending on the provided format
	def FindPattern(paFormat) // TODO
		/* ... */

		StzRaise("FindPattern() function is not implemented yet!")

	def FindInside(pcTemplate) // TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInside("KLM", 'amc@bmi') #--> 10

		o1.FindInside("KLM", lower("AMC") + '@' + lower("BMI") #-->

		*/

		/* ... */

		StzRaise("FindInside() function is not implemented yet!")

	def FindInsideW(pcTemplate, pcCondition) #TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInsideW("KLM", :Where = [
			'{ @(3).CharsBefore = "amc" }',
			'{ @(3).CharsAfter = "bmi" }'
		])
		*/

		/* ... */

		StzRaise("FindInsideW() function is not implemented yet!")

	def FindInsideWXT(pcTemplate, pcCondition) #TODO
		StzRaise("FindInsideW() function is not implemented yet!")

	  #===============================================================#
	 #  FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS  #
	#===============================================================#

	def FindAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"
		? o1.FindAsSections( "ring" )
		#--> [ [7, 10], [24, 27] ]

		*/

		if isList(pcSubStr)
			return This.FindManyAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		anFirstPos = This.FindCS(pcSubStr, pCaseSensitive)

		aResult = []

		if len(anFirstPos) > 0
			nLen = StzStringQ(pcSubStr).NumberOfChars()
			anLastPos = StzListOfNumbersQ(anFirstPos).AddToEachQ(nLen-1).Content()
	
			aResult = StzListQ(anFirstPos).AssociatedWith(anLastPos)
		ok

		return aResult

		#< @FunctionFlunentForm

		def FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			#TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FindCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindAllAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)


		def FindAllCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def PositionsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSections(pcSubStr)
		return This.FindAsSectionsCS(pcSubStr, TRUE)

		#< @FunctionFluentForms

		def FindAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQR(pcSubStr, :stzList)

		def FindAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsSectionsCSQR(pcSubStr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def FindZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

		def FindSubStringZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

		def FindAllAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)


		def FindAllZZ(pcSubStr)
			return This.FindAsSectionsCS(pcSubStr)

		#--

		def PositionsAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)

		def PositionsZZ(pcSubStr)
			return This.FindAsSections(pcSubStr)

		#--

		def FindSubStringAsSections(pcSubStr)
			return This.FindAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- D/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		aResult = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, TRUE)

		#< @FunctionAlternativeForm

		def FindDZZ(pcSubStr, pcDirection)
			return This.FindAsSectionsD(pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- S/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok
	
			if isString(pnStartingAt)
				if pnStartingAt = :First or pnStartingAt = :FirstChar
					pnStartingAt = 1
	
				but pnStartingAt = :Last or pnStartingAt = :LastChar
					pnStartingAt = This.NumberOfChars()
	
				ok
			ok
	
			if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
				StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
			ok

		ok

		# Doing the job

		aResult = []

		anPos1 = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if len(anPos1) > 0
			anPos2 = StzListOfNumbersQ(anPos1).AddedToEach(Q(pcSubStr).NumberOfChars() - 1)
			aResult = Association([ :Of = anPos1, :And = anPos2 ])
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindSTCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsST(pcSubStr, pnStartingAt)
		return This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def FindSTZZ(pcSubStr, pnStartingAt)
			return This.FindAsSectionsST(pcSubStr, pnStartingAt)

		#>

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                    #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param (because we will use it below)

		if isList(pcSubStr) and Q(pcSubStr).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		anPos = This.FindSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult


	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, TRUE)


	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- Z/EXTENDED                      #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAllSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCSZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- ZZ/EXTENDED                     #
	#--------------------------------------------------------------------#

	def FindAsSectionsSTDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSTDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCSZZ(pcSubStr, pnStartingAt, pcDirection, TRUE)

	  #=====================================================================#
	 #   FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS ANTI-SECTIONS  #
	#=====================================================================#

	def FindAsAntiSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"

		? o1.FindAsSections("ring")
		#--> [ [7, 10], [24, 27] ]

		? o1.FindAsAntiSections("ring")
		#--> [ [1, 6], [11, 23], [28, 28] ]

		*/

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

		#< @FunctionFlunentForm

		def FindAsAntiSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			#TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSections(pcSubStr)
		return This.FindAsAntiSectionsCS(pcSubStr, TRUE)

		def FindAsAntiSectionsQ(pcSubStr)
			return This.FindAsAntiSectionsQR(pcSubStr, :stzList)

		def FindAsAntiSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsAntiSectionsCSQR(pcSubStr, TRUE, pcReturnType)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- D/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, TRUE)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- S/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aSections = This.FindAsSectionsSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsST(pcSubStr, pnStartingAt)
		return This.FindAsAntiSectionsSTCS(pcSubStr, pnStartingAt, TRUE)

	   #--------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS ANTISECTIONS, STARTING FROM A GIVEN  #
	 #  POSITION, AND GOING IN A GIVEN DIRECTION                    #
	#--------------------------------------------------------------#

	def FindAsAntiSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsSTD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsAntiSectionsSTDCS(pcSubStr, pnStartingAt, pcDirection, TRUE)


	  #==============================#
	 #   NTH SUBSTRING -- EXTENDED  # 
	#==============================#

	def NthSubStringXT(n, paOption)

		cOption = ""
		pOption = []

		if isList(paOption) and
		   Q(paOption).IsOneOfTheseNamedParams([ :Between, :BetweenCS, :Where ])

			cOption = paOption[1]
			pOption = paOption[2]
		ok

		if cOption = :Between
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetween(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BetweenCS
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetweenCS(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BoundedBy
			
			if isString(pOption) or
			    ( isList(pOption) and Q(pOption).IsPairOfStrings() )

				return This.NthSubStringBoundedBy(n, pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string or a pair of strings.")
			ok

		but cOption = :Where
			if isString(pOption)
				return This.NthSubStringW(pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string.")
			ok
		else
			stzRaise("Can't proceed. Null or unrecognized option.")
		ok

	  #------------------------------------------------#
	 #   NTH SUBSTRING WHERE A CONDITION IS VERIFIED  # 
	#------------------------------------------------#

	#TODO: Reimplement it for better performance
	#TODO Add cases ensitivity

	def NthSubStringW(n, pcCondition)
		return This.SubStringsW()[n]

	#-- WXT

	def NthSubStringWXT(n, pcCondition)
		return This.SubStringsWXT()[n]

	  #========================================#
	 #  VISUALLY FINDING CHARS IN THE STRING  #
	#========================================#

	def VizFindChar(c)
		if ObjectIsStzChar(c)
			c = c.Content()
		ok

		if NOT ( isString(c) and @IsChar(c) )
			return NULL
		ok

		cResult = @@( This.Content() )
		anPos = This.FindAll( c )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anPos)
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindCharQ(pItem)
			return new stzString( This.VizFindChar(pItem) )

		#>

	  #-----------------------------------------#
	 #      VISUALLY FINDING A SUBSTRING       #
	#-----------------------------------------#

	def VizFindXT(pcSubStr, paOptions)

		# STEP 1: Checking params TYPES

		acPossibleKeys = [
			:CaseSensitive, :CS, :PositionSign, :PositionChar,
			:BlankSign, :Numbered, :Spacified,
			:Boxed, :BoxOptions

		]

		if isString(paOptions)
			if ring_find(acPossibleKeys, paOptions) > 0
				aTemp = [] + [ paOptions, TRUE ]
				paOptions = aTemp
			ok
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT ( isList(paOptions) and IsHashList(paOptions) )
			StzRaise("Incorrect param type! paOptions must be a wellformed hashlist.")
		ok

		nLen = len(paOptions)
		acKeys = []

		for i = 1 to nLen
			acKeys + paOptions[i][1]
		next

		for i = 1 to nLen
			if ring_find(acPossibleKeys, acKeys[i]) = 0
				stzRaise("syntax error! paOptions contains unsupported keys.")
			ok
		next

		# At this level, we are sure pcSubStr is a string and
		# paOptions is a hashlist made of some of the allowed keys for boxing

		# Before going further, Delegate the work to VizFindBoxedXT()
		# when boxing is required

		if ring_find(acKeys, :Boxed) > 0 and
		   isNumber(paOptions[ :Boxed ]) and paOptions[ :Boxed ] = 1

			n = ring_find(acKeys, :boxed)
			del(paOptions, n)

			return This.VizFindBoxedXT(pcSubStr, paOptions)
		ok

		n = ring_find(acKeys, :CS)
		if n > 0 and ring_find(acKeys, :CaseSensitive) > 0
			stzRaise("Incorrect options! :CaseSensitive and its short form :CS must not be used both.")
		ok

		# Unfyiing the :CaseSensitive / :CS keyword

		if n > 0
			paOptions[n][1] = :CaseSensitive
		ok

		# STEP 2: Reading params values

		bCaseSensitive = TRUE
		if ( isString(paOptions[:CaseSensitive]) and paOptions[:CaseSensitive] != NULL ) or
		   ( isNumber(paOptions[:CaseSensitive]) and (paOptions[:CaseSensitive] = 0 or paOptions[:CaseSensitive] = 1)  )

			bCaseSensitive = paOptions[:CaseSensitive]
		ok

		cPositionSign = "^"
		if isString(paOptions[:PositionSign]) and paOptions[:PositionSign] != NULL
			cPositionSign = paOptions[:PositionSign]
		ok

		cBlankSign = "-"
		if isString(paOptions[:BlankSign]) and paOptions[:BlankSign] != NULL
			cBlankSign = paOptions[:BlankSign]
		ok

		bNumbered = FALSE
		if ( isString(paOptions[:Numbered]) and paOptions[:Numbered] != NULL ) or
		   ( isNumber(paOptions[:Numbered]) and ( paOptions[:Numbered] = 0 or paOptions[:Numbered] = 1 )  )

			bNumbered = paOptions[:Numbered]
		ok

		bSpacified = FALSE
		if ( isString(paOptions[:Spacified]) and paOptions[:Spacified] != NULL ) or
		   ( isNumber(paOptions[:Spacified]) and ( paOptions[:Spacified] = 0 or paOptions[:Spacified] = 1 )  )

			bSpacified = paOptions[:Spacified]
		ok

		# STEP 3: Checking the correctness of the provided values

		bCorrect = TRUE
		acWhy = [] # Will host the reasons of the errors

		If NOT ( isNumber(bCaseSensitive) and (bCaseSensitive = 0 or bCaseSensitive = 1) )

			bCorrect = FALSE
			acWhy + ":CaseSensitive option must be a boolean"
		ok

		if NOT ( isString(cPositionSign) and @IsChar(cPositionSign) )

			bCorrect = FALSE
			acWhy + ":PositionSign option must be a char"
		ok

		if NOT ( isString(cBlankSign) and @IsChar(cBlankSign) )

			bCorrect = FALSE
			acWhy + ":BlankSign option must be char"
		ok

		if NOT cPositionSign != cBlankSign

			bCorrect = FALSE
			acWhy + ":PositionSign and :BlankSign options must be different"
		ok

		If NOT ( isNumber(bNumbered) and (bNumbered = 0 or bNumbered = 1) )

			bCorrect = FALSE
			acWhy + ":Numbered option must be a boalean"
		ok

		If NOT ( isNumber(bSpacified) and (bSpacified = 0 or bSpacified = 1) )

			bCorrect = FALSE
			acWhy + ":Spacified option must be a boalean"
		ok

		if NOT bCorrect
			stzRaise([
				:Where	= "stzString.ring > vizFindXT()",
				:What	= StzListOfStringsQ(acWhy).ConcatenatedUsing(", ") + "."
			])
		ok

		# At this level, we are sure the params are well formed
		#--> Let's do the job!

		if bSpacified
			cString =This.Spacified()
		else
			cString = This.Content()
		ok

		oString = new stzString(cString)

		anPos = oString.FindAllCS( pcSubStr, :CS = bCaseSensitive )
		nLen = len(anPos)

		if nLen = 0
			return
		ok

		nLen = oString.NumberOfChars()

		cVizLine = ""
		for i = 1 to nLen

			if ring_find(anPos, i) > 0
				cVizLine += cPositionSign
			else
				cVizLine += cBlankSign
			ok

		next

		cResult = oString.Content() + NL + cVizLine

		 # In case a numbered line is requested

		if bNumbered

			cPosLine = ring_substr2(cVizLine, cBlankSign, " ")

			nLenPos = len(anPos)
			aSections = []

			acPos = []

			for i = 1 to nLenPos
				cPos = ""+ anPos[i]
				acPos + cPos

				nLenNumber = len(cPos)

				n1 = anPos[i]
				n2 = n1 + nLenNumber - 1

				aSections + [ n1, n2 ]
			next

			oStrPosLine = new stzString(cPosLine)
			cPosLine = oStrPosLine.
				   ReplaceSectionsByManyQ(aSections, acPos).
				   Content()
	
			cResult += (NL + cPosLine)
		ok

		
		return cResult

		#< @FunctionFluentForm

		def VizFindXTQ(pcSubStr, paOptions)
			return new stzString( This.VizFindXT(pcSubStr, paOptions) )

		#>

	def VizFind(pcSubStr)
		return This.VizFindXT(pcSubStr, [ :PositionSign = "^" ])

	def VizFindCS(pcSubStr, pCaseSensitive)
		return This.VizFindXT(pcSubStr, [ pCaseSensitive ])
		
	  #-------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING  #
	#===========================================#

	def VizFindBoxedCS(pcSubStr, pCaseSensitive)
		return This.VizFindBoxedCSXT(pcSubStr, [ :Boxed = TRUE ], pCaseSEnsitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxed(pcSubStr)
		return This.VizFindBoxedCS(pcSubStr, TRUE)

	  #-------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING  #
	#-------------------------------------------#

	def VizFindBoxedRoundedCS(pcSubStr, pCaseSensitive)
		return This.VizFindBoxedCSXT(pcSubStr, [ :Boxed = TRUE, :Rounded = TRUE ], pCaseSEnsitive)

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxedRounded(pcSubStr)
		return This.VizFindBoxedRoundedCS(pcSubStr, TRUE)

	  #-------------------------------------------------#
	 #  VISUALLY FINDING AND BOXING A SUBSTRING -- XT  #TODO: Review this
	#-------------------------------------------------#

	def VizFindBoxedCSXT(pcSubstr, paOptions, pCaseSensitive) #TODO

		cBoxed = This.CharsBoxedXT(paOptions + :Hilighted = This.FindCS(pcSubStr, pCaseSensitive))
		return cBoxed

	#-- WITHOUT CASESENSITIVITY

	def VizFindBoxedXT(pcSubstr, paOptions)
		return This.VizFindBoxedCSXT(pcSubstr, paOptions, TRUE)

	
	  #==============================================================#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION  #
	#==============================================================#
	# Distance is given by the number of chars inbetween
	# the starting and target positions are not included
	# To include them, use ...XT() form of the function

	def DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)
		nResult = This.DistanceToSCSXT(pcSubStr, pnStartingAt, pCaseSensitive) - 2
		return nResult

		def DistanceToSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DistanceTo(pcSubStr, pnStartingAt)
		return This.DistanceToCS(pcSubStr, pnStartingAt, TRUE)

		def DistanceToST(pcSubStr, pnStartingAt)
			return This.DistanceTo(pcSubStr, pnStartingAt)

	  #--------------------------------------------------------------------------#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION -- EXTENDED  #
	#--------------------------------------------------------------------------#

	def DistanceToSTCSXT(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		n1 = pnStartingAt
		n2 = 0

		if isString(pcSubStr)
			n2 = This.FindNext(pcSubStr, pnStartingAt, pCaseSensitive)
		
		but isNumber(pcSubStr)
			n1 = pcSubStr

		but isList(pcSubStr)
			if Q(pcSubStr).IsNextNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = This.FindNext(pcSubStr, pnStartingAt + 1, pCaseSensitive)

			but Q(pcSubStr).IsNthNextNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :NextNth, :NthNext ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = This.FindNextNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)
			
				ok

			but Q(pcSubStr).IsPreviousNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = n1
				n1 = This.FindPreviousCS(pcSubStr, pnStartingAt - 1, pCaseSensitive)

			but Q(pcSubStr).IsNthPreviousNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :PreviousNth, :NthPrevious ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = n1
					n1 = This.FindPreviousNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)

				ok

			ok

		ok

		nResult = n2 - n1 + 1

		return nResult

		def DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DistanceToSTXT(pcSubStr, pnStartingAt)
		return This.DistanceToSTCS(pcSubStr, pnStartingAt, TRUE)

		def DistanceToXT(pcSubStr, pnStartingAt)
			return This.DistanceToXT(pcSubStr, pnStartingAt)

	  #======================================================#
	 #  CHECHING IF THE STRING IS EQUAL TO AN OTHER STRING  #
	#======================================================#

	def IsEqualToCS(pcOtherStr, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok
		ok

		cContent = This.Content()

		if IsCaseSensitive(pCaseSensitive) = FALSE
			pcOtherStr = lower(pcOtherStr)
			cContent = This.Lowercased()
		ok

		if pcOtherStr = cContent
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionFluentForm
		# Usded for natural-coding and chains of truth

		def IsEqualToCSQ(pcOtherStr, pCaseSensitive)
			if This.IsEqualToCS(pcOtherStr, pCaseSensitive)
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsEqualCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def IsEqualCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def EqualToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def EqualToCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def EqualsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def EqualsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def HasSameContentAsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def HasSameContentAsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		def HasSameValueAsCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

			def HasSameValueAsCSQ(pcOtherStr, pCaseSensitive)
				return This.IsEqualToCSQ(pcOtherStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsEqualtCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(pcOtherStr)
		return This.IsEqualToCS(pcOtherStr, TRUE)

		#< @FunctionFluentForm

		def IsEqualToQ(pcOtherStr)
			return This.IsEqualToCSQ(pcOtherStr, TRUe)

		#>

		#< @FunctionAlternativeForms

		def EqualTo(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def EqualToQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def Equals(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def EqualsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def HasSameContentAs(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def HasSameContentAsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		def HasSameValueAs(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

			def HasSameValueAsQ(pcOtherStr)
				return This.IsEqualToQ(pcOtherStr)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtTo(pcOtherStr)
			return This.IsEqualTo()

		#>

	  #======================================#
	 #   CONTAINMENT OF A GIVEN SUBSTRING   #
	#======================================#

	def ContainsCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.indexOf() >

		# Checking params

		if isList(pcSubStr)
			return This.ContainsTheseSubStringsCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a STRING, while you are providing a " +
				   ring_type(pcSubStr) + ".")
		ok

		# Resolving pCaseSensitive param

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job (Qt-side)

		nPos = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1

		if nPos > 0
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def ContainsSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#-- Used for chains of truth

		def ContainingCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

			def ContainingCSQ(pcSubStr, pCaseSensitive)
				if This.ContainsCS(pcSubStr, pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionPassiveForm

		def ContainsNoCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		def ConttainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Contains(pcSubStr)
		return This.ContainsCS(pcSubstr, TRUE)

		#< @FunctionAlternativeForm

		def ContainsSubString(pcSubStr)
			return This.Contains(pcSubStr)

		#-- Used for chains of truth

		def Containing(pcSubStr)
			return This.Contains(pcSubStr)

			def ContainingQ(pcSubStr)
				if This.Contains(pcSubStr)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionPassiveForm

		def ContainsNo(pcSubStr)
			return NOT This.Contains(pcSubStr)

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pcSubStr)
			return This.Contains(pcSubStr)

		def Conttains(pcSubStr)
			return This.Contains(pcSubStr)

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS NO ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def ContainsNoOneOfTheseCS(pacSubStr, pCaseSensitive)

		if CheckParams()
			if NOT ( isList(pacSubStr) and IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		nLen = len(pacSubStr)
		bResult = TRUE

		for i = 1 to nLen
			if This.ContainsSubStringCS(pacSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsNoOneOfThese(pacSubStr)
		return This.ContainsNoOneOfTheseCS(pacSubStr, TRUE)

	  #------------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS CONTAINED IN AN OTHER GIVEN STRING   #
	#------------------------------------------------------------------#

	def IsContainedInCS(pcOtherStr, pCaseSensitive)

		if NOT (isString(pcOtherStr) or isList(pcOtherStr))
			StzRaise("Incorrect param type! pcOtherStr must be a string or list.")
		ok

		bResult = Q(pcOtherStr).ContainsCS(This.String(), pCaseSensitive) 
		return bResult

		#< @FunctionAlternativeForms

		def IsIncludedInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		def ExistsInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(pcOtherStr)
		return This.IsContainedInCS(pcOtherStr, TRUE)

		#< @FunctionAlternativeForms

		def IsIncludedIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		def ExistsIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		#>

	  #------------------------------------------------#
	 #   CHECKING CONATAINMENT ON A GIVEN CONDITION   #
	#------------------------------------------------#

	def ContainsCharsWCS(pcCondition, pCaseSensitive)
		/* EXAMPLE

		? Q("__---__").ContainsXT(:CharsWhere, 'Q(This[@i]).IsEither("_", :Or = "-")')
		#--> TRUE
		*/

		bResult = This.CharsCSQ(pCaseSensitive).ContainsW(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsCharsW(pcCondition)
		return This.ContainsCharsWCS(pcCondition, TRUE)

	#==

	def ContainsSubStringsWCS(pcCondition, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsW(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsW(pcCondition)
			return This.ContainsSubStringsWCS(pcCondition, TRUE)

	#== WXT

	def ContainsCharsWCSXT(pcCondition, pCaseSensitive)

		bResult = This.CharsCSQ(pCaseSensitive).ContainsWXT(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsCharsWXT(pcCondition)
		return This.ContainsCharsWCSXT(pcCondition, TRUE)

	#==

	def ContainsSubStringsWCSXT(pcCondition, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsWXT(pcCondition)
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsWXT(pcCondition)
		return This.ContainsSubStringsWCSXT(pcCondition, TRUE)

	  #---------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITION/SUBSTRING  #
	#---------------------------------------------------------------------------------------#

	def ContainsBeforeCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosBefore = p

		if isString(p)
			nPosBefore = This.FindLastCS(p, pCaseSensitive)
		ok

		bResult = This.ContainsInSectionCS(pcSubStr, 1, nPosBefore-1, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsBefore(pcSubStr, p)
		return This.ContainsBeforeCS(pcSubStr, p, TRUE)

	  #--------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITION/SUBSTRING  #
	#--------------------------------------------------------------------------------------#

	def ContainsAfterCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosAfter = p

		if isString(p)
			nPosAfter = This.FindFirstCS(p, pCaseSensitive)
		ok

		nLenSubStr = This.NumberOfChars()
		bResult = This.ContainsInSectionCS(pcSubStr, nPosAfter+1, nLenSubStr, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfter(pcSubStr, p)
		return This.ContainsAfterCS(pcSubStr, p, TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITION  #
	#-----------------------------------------------------------------------------#

	def ContainsBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforePosition(pcSubStr, pnPos)
		return This.ContainsBeforePositionCS(pcSubStr, pnPos, TRUE)

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#------------------------------------------------------------------------------#

	def ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforeSubString(pcSubStr1, pcSubStr2)
		return This.ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, TRUE)

	  #----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITION  #
	#----------------------------------------------------------------------------#

	def ContainsAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterPosition(pcSubStr, pnPos)
		return This.ContainsAfterPositionCS(pcSubStr, pnPos, TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterSubString(pcSubStr1, pcSubStr2)
		return This.ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, TRUE)

	  #---------------------------------------#
	 #   CHECKING CONATAINMENT -- EXTENDED   #
	#---------------------------------------#

	def ContainsCSXT(p1, p2, pCaseSensitive)

		#=== GENERAL

		# ? Q("").ContainsXT(:Chars, []) #--> FALSE
		if This.String() = "" and isString(p1) = :Chars and
		   (  (isList(p2)   and len(p2) = 0) or
		      (isString(p2) and p2 = ""    ) or
		      (isNumber(p2) and p2 = 0     )    )

			return FALSE

		# ? Q("").ContainsXT([], :Chars) #--> FALSE
		but ( (isList(p1)   and len(p1) = 0) or
		      (isString(p1) and p1 = ""    ) or
		      (isNumber(p1) and p1 = 0     )    ) and

		    isString(p2) and p2 = :Chars

			return FALSE

		# ? Q("____").ContainsXT("", "_")
		but BothAreStrings(p1, p2) and
		    NOT Q(p1).IsOneOfThese([
			:CharsW, :CharsWhere, :SubStringsW, :SubStringsWhere
			])

			return This.ContainsTheseCS([p1, p2], pCaseSensitive)
		
		# ? Q("____").ContainsXT("", "_")
		but isString(p1) and isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :And

			return This.ContainsTheseCS([p1, p2[2]], pCaseSensitive)

		# ? Q("______").ContainsXT(2, "")
		but isNumber(p1) and isString(p2)
			return This.ContainsNOccurrencesCS(p1, p2, pCaseSensitive)
		
		# ? Q("______").ContainsXT( :Exactly = 2, "" )
		but isList(p1) and Q(p1).IsExactlyNamedParam()
			return This.ContainsNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("______").ContainsXT( :MoreThen = 1, "")
		but isList(p1) and Q(p1).IsMoreThenNamedParam()
			return This.ContainsMoreThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("______").ContainsXT( :LessThen = 3, "")
		but isList(p1) and Q(p1).IsLessThenNamedParam()
			return This.ContainsLessThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("____").ContainsXT("", [])
		but isString(p1) and isList(p2) and len(p2) = 0 and
			NOT Q(p2).IsWhereNamedParam()

			return This.ContainsCS(p1, pCaseSensitive)

		# ? Q("_--_").ContainsXT("", :BoundedBy = "-")
		# ? Q("_--_").ContainsXT(:SubString = "", :BoundedBy = "-")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and
		    isList(p2) and Q(p2).IsBoundedByNamedParam()

			if isList(p1) and Q(p1).IsSubStringNamedParam()
				p1 = p1[2]
			ok

			return This.ContainsSubStringBoundedByCS(p1, p2[2], pCaseSensitive)
		
		# ? Q("_/\_").ContainsXT("", :Between = ["/", :And = "\"])
		but isString(p1) and isList(p2) and (Q(p2).IsBetweenNamedParam() or Q(p2).IsBoundedByNamedParam())

			if Q(p2[2][2]).IsAndNamedParam()
				aTemp = []
				aTemp + p2[2][1] + p2[2][2][2]
				p2[2] = aTemp
			ok

			if Q(p2[2]).isListOfStrings()

				return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			but Q(p2[2]).isListOfNumbers()
				return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			ok

		but isString(p1) and isList(p2) and
		    Q(p2).IsInSectionNamedParam() and
		    isList(p2[2]) and Q(p2[2]).IsPairOfNumbers()

			return This.containsInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)


		but isString(p1) and isList(p2) and Q(p2).IsBetweenSubStringsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		but isString(p1) and isList(p2) and Q(p2).IsBetweenPositionsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		# ? Q("__--__").ContainsXT(["_", "-", ""], [])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and len(p2) = 0
			return This.ContainsTheseCS(p1, pCaseSensitive)
		
		# ? Q("__--__--__").ContainsXT(["", ""], :BoundedBy = "-")
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBoundedByNamedParam()
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBoundedByCS(p1[i], p2[2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("__/\__/\__").ContainsXT(["", ""], :Between = ["/","\"])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2][2]).IsAndNamedParam()
				p2[2][2] = p2[2][2][2]
			ok
		
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBetweenCS(p1[1], p2[2][1], p2[2][2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("____").ContainsXT([], "")
		but isList(p1) and len(p1) = 0 and isString(p2)
			return This.ContainsCS(p2, pCaseSensitive)
		
		# ? Q("______").ContainsXT( [], :BoundedBy = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBoundedByNamedParam()
			return This.ContainsSubStringsBoundedByCS(p2[2], pCaseSensitive)
		
		# ? Q("__/\__/^^\__").ContainsXT( [], :Between = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok
		
			return This.ContainsSubStringsBetweenCS(p2[2][1], p2[2][2], pCaseSensitive)
			
		#=== CHARS

		# ? Q("__--__").ContainsXT(:Chars, ["_", "-", "_"])
		# ? Q("__--__").ContainsXT(:TheseChars, ["_", "-", "_"])
		but isString(p1) and (p1 = :Chars or p1 = :TheseChars) and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:SomeOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :SomeOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsSomeOfTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:OneOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :OneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsOneOfTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:NoneOfTheseChars, ["A", "*", "B"])
		but isString(p1) and p1 = :NoneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsNoneOfTheseSubStrings(p2)

		# ? Q("__---__").ContainsXT(:CharsWhere, 'Q(This[@i]).IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:CharsW, 'Q(This[@i]).IsEither("_", :Or = "-")')
		but isString(p1) and (p1 = :CharsWhere or p1 = :CharsW) and isString(p2)
			return This.ContainsCharsWXT(p2)
		
		# ? Q("__---__").ContainsXT(:Chars, :Where = 'Q(This[@i]).IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:Chars, Where('Q(This[@i]).IsEither("_", :Or = "-")'))
		# ? Q("__---__").ContainsXT(:Chars, W('Q(This[@i]).IsEither("_", :Or = "-")'))
		but isString(p1) and p1 = :Chars and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return this.ContainsCharsWXT(p2[2])

		#=== SUBSTRINGS

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStrings, ["softanza", :And = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:TheseSubStrings, ["softanza", :And = "ring"])
		but isString(p1) and (p1 = :SubStrings or p1 = :TheseSubStrings) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfTheseSubStrings, ["ring", "php", :Or = "softanza"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfThese, ["ring", "php", "softanza"])
		but isString(p1) and (p1 = :SomeOfTheseSubStrings or p1 = :SomeOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsSomeOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfTheseSubStrings, ["python", "php", :Or = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :OneOfTheseSubStrings or p1 = :OneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsOneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfTheseSubStrings, ["python", "php", :Nor = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :NoneOfTheseSubStrings or p1 = :NoneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsNoneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsWhere, 'Q(@SubString).IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, 'Q(@SubString).IsUppercase()')
		but isString(p1) and (p1 = :SubStringsWhere or p1 = :SubStringsW) and isString(p2)

			return This.ContainsSubStringsWXT(p2)
			
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where = 'Q(@SubString).IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where('Q(@SubString).IsUppercase()') )
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :W('Q(@SubString).IsUppercase()') )
		but isString(p1) and p1 = :SubStringsW and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return This.ContainsSubStringsWXT(p2[2])

		# ? Q("^^^^").ContainsXT("", :AtPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPosition ]) and
		    isNumber(p2[2])

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAt(p2[2], p1)

		# ? Q("^^^^").ContainsXT("", :AtPositions = [1, 4, 7])
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPositions ]) and
		    isList(p2[2]) and Q(p2[2]).IsListOfNumbers()

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAtPositions(p2[2], p1)

		# ? Q("^^^^").ContainsXT("^", :Before = "^")
		# ? Q("^^^^").ContainsXT("^", :Before = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsBeforeNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsBefore(p1, p2[2])

		# ? Q("--^^").ContainsXT("^", :After = "-")
		# ? Q("^^^^").ContainsXT("^", :After = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsAfterNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsAfter(p1, p2[2])

		# ? Q("^^^^").ContainsXT("^", :BeforePosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsBeforePositionNamedParam() and isNumber(p2[2])

			return This.ContainsBefore(p1, :Position = p2[2])

		# ? Q("^^^^").ContainsXT("^", :AfterPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsAfterPositionNamedParam() and isNumber(p2[2])

			return This.ContainsAfter(p1, :Position = p2[2])

		# ? Q("^^^^").ContainsXT("^", :BeforeSubString = "^")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsBeforeSubStringNamedParam() and isString(p2[2])

			return This.ContainsBefore(p1, :SubString = p2[2])

		# ? Q("--^^").ContainsXT("^", :AfterSubString = "-")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsAfterSubStringNamedParam() and isString(p2[2])

			return This.ContainsAfter(p1, :SubString = p2[2])

		# ? Q("1235678").ContainsXT( "", :InSection = [3, 5] )
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsInSectionNamedParam()

			return This.ContainsInSection(p1, p2[2])

		# ? Q("12356890234").Contains( "", :InSections = [ [3,5], [6,8], [10,12] ] )
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) ) ) and

		    isList(p2) and Q(p2).IsInSectionsNamedParam()

			return This.ContainsInSections(p1, p2[2])

		else

			StzRaise("Unsupported syntax")
		ok

	#-- WITOUT CASESENSITIVITY

	def ContainsXT(p1, p2)
		return This.ContainsCSXT( p1, p2, TRUE)

	  #----------------------------------------------#
	 #    CONTAINING ONE OF THE GIVEN SUBSTRINGS    #
	#==============================================#

	def ContainsOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE
		nLen = len(paSubStr)

		for i = 1 to nLen
			if This.ContainsCS( paSubStr[i],  pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#--

		def ContainsOneOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(paSubStr)
		return This.ContainsOneOfTheseCS(paSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsAnyOfThese(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#--

		def ContainsOneOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#>

	  #-------------------------#
	 #    CONTAINING SPACES    #
	#-------------------------#

	def ContainsSpaces()
		return This.Contains(" ")

		#< @FunctionPassiveForm

		def ContainsNoSpaces()
			return NOT This.ContainsSpaces()

		#>

	  #------------------------------------------------#
	 #    CONTAINING BOTH OF THE GIVEN SUBSTRINGS     #
	#================================================#

	def ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		if isList(pcSubStr2) and Q(pcSubStr2).IsAndNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		return This.ContainsEachCS( [pcSubStr1, pcSubStr2], pCaseSensitive )

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pcSubStr1, pcSubStr2)
		return This.ContainsBothCS(pcSubStr1, pcSubStr2, TRUE)
	
	  #----------------------------------------------------------------#
	 #    CONTAINING ONE GIVEN SUBSTRING OR AN OTHER (BUT NOT BOTH)   #
	#----------------------------------------------------------------#

	def ContainsEitherCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		if isList(pcSubStr2) and Q(pcSubStr2).IsOrNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		#NOTE
		# We can solve it quickly like this:
		# return This.ContainsOnlyOneOfTheseCS([ pcStr1, pcStr2 ], pCaseSensitive)

		b1 = This.ContainsCS(pcSubStr1, pCaseSensitive)
		b2 = This.ContainsCS(pcSubStr2, pCaseSensitive)

		if (b1 = 1 and b2 = 0) or (b1 = 0 and b2 = 1)
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsEither(pcSubStr1, pcSubStr2)
		return This.ContainsEitherCS(pcSubStr1, pcSubStr2, TRUE)

	  #--------------------------------------------------#
	 #  CONTAONING ONLY ONE OF THE PROVIDED SUBSTRINGS  #
	#--------------------------------------------------#

	def ContainsOnlyOneOfTheseCS(pacSubStr, pCaseSensitive)
		if CheckParam()
			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		if EarlyCheck()
			if len(pacSubStr) = 0
				return FALSE
			ok
		ok

		acSubStr = @WithoutDuplication(pacSubStr)
		nLen = len(acSubStr)

		anOccurr = []
		
		for i = 1 to nLen
			anOccurr + This.ContainsCS(acSubStr[i], pCaseSensitive)
		next
		
		nOnes  = Q(anOccurr).HowMany(1)
		nZeros = Q(anOccurr).HowMany(0)

		if nOnes = 1 and nZeros = nLen - 1
			return TRUE
		else
			return FALSE
		ok

	#-- WTIHOUT CASESENSITIVITY

	def ContainsOnlyOneOfThese(pacSubStr)
		return This.ContainsOnlyOneOfTheseCS(pacSubStr, TRUE)

	  #---------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING (OR MANY SUBSTRINGS) IN A GIVEN SECTION  #
	#=============================================================================================#

	def ContainsInSectionCS(p, n1, n2, pCaseSensitive)

		# Ckecking params

		if CheckParams()
			if NOT ( isString(p) or ( isList(p) and Q(p).IsListOfStrings() ) )
				StzRaise("Incorrect param type! p must be a string or list of strings.")
			ok
		ok

		# Doing the job

		if isString(p)
			return This.ContainsSubStringInSectionCS(p, n1, n2, pCaseSensitive)

		else
			return This.ContainsManySubStringsInSectionCS(p, n1, n2, pCaseSensitive)
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsInSection(p, n1, n2)
		return This.ContainsInSectionCS(p, n1, n2, TRUE)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING IN A GIVEN SECTION  #
	#------------------------------------------------------------------------#

	def ContainsSubStringInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		bResult = This.SectionQ(n1, n2).ContainsSubStringCS(pcSubStr, pCaseSensitive)
		return bResult

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringInSection(pcSubStr, n1, n2)
		return This.ContainsSubStringInSectionCS(pcSubStr, n1, n2, TRUE)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS THE GIVEN SUBSTRINGS IN A GIVEN SECTION  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)
		bResult = This.Section(n1, n2).ContainsManyCS(pacSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsManyInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsAllTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		def ContainsEachOfTheseSubStringsInSetionCS(pacSubStr, n1, n2, pCaseSensitive)
			return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringsInSection(pacSubStr, n1, n2)
		return This.ContainsSubStringsInSectionCS(pacSubStr, n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsManyInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsAllTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		def ContainsEachOfTheseSubStringsInSetion(pacSubStr, n1, n2)
			return This.ContainsSubStringsInSection(pacSubStr, n1, n2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING (OR MANY SUBSTRINGS) IN MANY SECTIONS  #
	#===========================================================================================#

	def ContainsInSectionsCS(p, panSections, pCaseSensitive)

		# Ckecking params

		if CheckParams()
			if NOT ( isString(p) or ( isList(p) and Q(p).IsListOfStrings() ) )
				StzRaise("Incorrect param type! p must be a string or list of strings.")
			ok
		ok

		# Doing the job

		if isString(p)
			return This.ContainsSubStringInSectionsCS(p, panSections, pCaseSensitive)

		else
			return This.ContainsManySubStringsInSectionsCS(p, panSections, pCaseSensitive)
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsInSections(p, panSections)
		return This.ContainsInSectionsCS(p, panSections, TRUE)

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING IN MANY SECTIONS  #
	#----------------------------------------------------------------------#

	def ContainsSubStringInSectionsCS(pcSubStr, panSections, pCaseSensitive)
		bResult = This.SectionsQ(panSections).EachContainsCS(pcSubStr, pCaseSensitive)
		return bResult

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringInSections(pcSubStr, panSections)
		return This.ContainsSubStringInSectionsCS(pcSubStr, panSections, TRUE)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS THE GIVEN SUBSTRINGS IN MANY SECTIONS  #
	#---------------------------------------------------------------------------#

	def ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)
		bResult = This.SectionsQ(panSections).EachContainsTheseCS(pacSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsManyInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsAllTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		def ContainsEachOfTheseSubStringsInSetionsCS(pacSubStr, panSections, pCaseSensitive)
			return This.ContainsSubStringsInSectionsCS(pacSubStr, panSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def ContainsSubStringsInSections(pcSubStr, panSections)
		return This.ContainsSubStringsInSectionsCS(pcSubStr, panSections, TRUE)

		#< @FunctionAlternativeForms

		def ContainsManySubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsManyInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsAllTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		def ContainsEachOfTheseSubStringsInSetions(pacSubStr, panSections)
			return This.ContainsSubStringsInSections(pacSubStr, panSections)

		#>

	  #=======================================================================#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#=======================================================================#

	def NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)
		/* EXAMPLE
		
		o1 = new stzString("How many <<many>> are there in (many <<many>>): so <<many>>!")
		? o1.NumberOfOccurrenceXT(
			:OfSubString = "many",
			:BetweenSubStrings = ["<<", :and = ">>"]
			# or :BoundedBy = ["<<", :and = ">>"]
		)
		#--> 

		*/

		if isList(pcSubStr) and ( Q(pcSubStr).IsOfNamedParam() or Q(pcSubStr).IsOfSubStringNamedParam() )
			pcSubStr = pcSubStr[2]
		ok

		if isList(pacBetween) and
			( Q(pacBetween).IsBetweenNamedParam() or
			Q(pacBetween).IsBetweenSubstringsNamedParam() or
			Q(pacBetween).IsBoundedByNamedParam() or
			Q(pacBetween).IsBoundedBySubStringsNamedParam() )

			pacBetween = pacBetween[2]
		ok

		if isList(pacBetween) and
			isList(pacBetween[2]) and
			Q(pacBetween[2]).IsAndNamedParam()

				pacBetween[2] = pacBetween[2][2]
		ok

		if NOT ( Q(pacBetween).IsPairOfStrings() or
			
			( isString(pacBetween[1]) and
			   	isList(pacBetween[2]) and
			  	 Q(pacBetween[2]).IsAndNamedParam() and
			   	 isString(pacBetween[2][2]) ) )

			stzRaise("Incorrect param! pacBetween must be a pair of strings.")
		ok

		nResult = This.NumberOfOccurrenceBetweenCS(pcSubStr, pacBetween[1], pacBetween[2], pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, TRUE)

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def ContainsExactlyNOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrences(n, pcSubStr)
		return This.ContainsNOccurrencesCS(n, pcSubStr, TRUE)

		def ContainsExactlyNOccurrences(n, pcSubStr)
			return This.ContainsNOccurrences(n, pcSubStr)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsMoreThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) > n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThenNOccurrences(n, pcSubStr)
		return This.ContainsMoreThenNOccurrencesCS(n, pcSubStr, TRUE)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS LESS THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsLessThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) < n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsLessThenNOccurrences(n, pcSubStr)
		return This.ContainsLessThenNOccurrencesCS(n, pcSubStr, TRUE)

	  #==============================================#
	 #   REMOVING A SUBSTRING AT A GIVEN POSITION   #
	#==============================================#

	def RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		if CheckParams()

			if isList(n) and isList(n)
				This.RemoveSubStringAtPositionsCS(n, pcSubStr, pCaseSensitive)
				return
			ok

		ok

		if This.ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			nRange = StzStringQ(pcSubStr).NumberOfChars()
			This.RemoveRange(n, nRange)
		ok

		#< @FunctionFluentForm

		def RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		#>

	def SubStringAtPositionNRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubsStringAtPositionCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAt(n, pcSubStr)
		This.RemoveSubStringAtPositionCS(n, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtQ(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPosition(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)

		#>

	def SubStringAtPositionNRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveSubsStringAtPositionQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------#
	 #   REMOVING A SUBSTRING AT A SOME GIVEN POSITIONS    #
	#-----------------------------------------------------#

	def RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python rping cshar ring")
		o1.RemoveSubstringAtPositions([ 10, 20, 32, 44 ], "ring")

		? o1.Content() #--> "ring php ruby python csharp"
		*/

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		anPos = Q(panPos).SortedInAscending()

		# Doing the job

		for i = len(anPos) to 1 step -1
			n = anPos[i]

			This.RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemovedCS(panPos, pcSubStr, pCaseSensitive)

		cResult = This.
			  Copy().
			  RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive).
			  Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAtPositions(panPos, pcSubStr)
		This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsQ(panPos, pcSubStr)
			This.RemoveSubStringAtPositions(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemoved(panPos, pcSubStr)
		return This.SubStringAtPositionsRemovedCS(panPos, pcSubStr, TRUE)

	  #================================================#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if ( (isNumber(n)) and (isString(pcSubStr)) ) or
		   ( (isString(n)) and (isNumber(pcSubStr)) )

			return This.ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		but ( isList(n) and Q(n).IsListOfNumbers() and isString(pcSubStr) ) or
		    ( isString(n) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers() )

			return This.ContainsAtPositionsCS(n, pcSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param types! n must be a number and pcSubStr must be a string or vice versa.")
		ok

		def ContainsSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

	def ContainsAt(n, pcSubStr)
		return This.ContainsAtCS(n, pcSubStr, TRUE)

		def ContainsSubStringAt(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

	  #------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(n) and isNumber(pcSubStr)
			temp = pcSubStr
			pcSubStr = n
			n = temp
		ok

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# ? Q("^^^^").ContainsAt(2, "")

		bResult = FALSE
		bContinue = TRUE
		i = 1

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		bResult = ring_find(anPos, n)

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		def SubStringExistsAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPosition(n, pcSubStr)
		return This.ContainsAtPositionCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		def SubStringExistsAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT GIVEN (MANY) POSITIONS   #
	#======================================================#

	def ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		if isList(panPos) and
		   Q(panPos).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			panPos = panPos[2]
		ok

		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(panPos) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers()
			temp = pcSubStr
			pcSubStr = panPos
			panPos = temp
		ok

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
			return This.ContainsSubStringsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
		ok

		bResult = TRUE
		nLen = len(panPos)

		for i = 1 to nLen
			if NOT This.ContainsSubStringAtPositionCS(panPos[i], pcSubStr, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		def ContainsSubStringAtThesePositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPos, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPositions(panPos, pcSubStr)
		return This.ContainsAtPositionsCS(panPos, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositions(panPos, pcSubStr)
			return This.ContainsAtPositions(panPos, pcSubStr)

		def ContainsSubStringAtThesePositions(panPos, pcSubStr)
			return This.ContainsAtPositions(panPos, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   CONTAINING SUBSTRINGS AT GIVEN POSITIONS    #
	#-----------------------------------------------#

	def ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )

			stzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if NOT ( len(panPos) = len(pacSubStr) )
			stzRaise("Incorrect values! panPos and pacSubStr lists must have same number of items.")
		ok

		bResult = TRUE

		#TODO: change for in with for loop --> better performance
		i = 0
		for n in panPos
			i++
			if NOT This.ContainsSubStringAtPosition(n, pacSubStr[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositionsCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		def ContainsSubStringsAtCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		def ContainsManyAtCS(panPos, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsAtPositions(panPos, pacSubStr)
		return This.ContainsSubStringsAtPositionsCS(panPos, pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositions(n, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		def ContainsSubStringsAt(panPos, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		def ContainsManyAt(panPos, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPos, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   CONTAINING SOME (ONE OR MORE) SUBSTRINGS   #
	#----------------------------------------------#

	def ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		bResult = FALSE

		nLen = len(pacSubStr)
		n = 0
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				n++
				if n > 1
					bResult = TRUE
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSomeCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		
		def ContainsSomeOfCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		def ContainsSomeOfTheseCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		def ContainsSomeOfTheseSubStringsCS(pacSubstr, pCaseSensitive)
			return This.ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMore(paSubStr)
		return This.ContainsOneOrMoreCS(paSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsSome(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)
		
		def ContainsSomeOf(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		def ContainsSomeOfThese(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		def ContainsSomeOfTheseSubStrings(pacSubstr)
			return This.ContainsOneOrMore(pacSubStr)

		#>

	  #------------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A SUBSTRING     #
	#------------------------------------------------#

	def ContainsNTimesCS(n, pcSubstr, pCaseSensitive)
		return This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive) = n

		def ContainsNTimesTheSubstringCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNTimesCS(n, pcSubstr, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ContainsNTimes(n, pcSubStr)
		return This.ContainsNTimesCS(n, pcSubstr, TRUE)

		def ContainsNTimesTheSubstring(n, pcSubstr)
			return This.ContainsNTimes(n, pcSubstr)

	  #-------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A CHAR     #
	#-------------------------------------------#

	def ContainsNTimesTheChar(n, pcChar)
		if NOT IsChar(pcChar)
			return FALSE
		ok
		
		return This.ContainsNTimesCS(n, pcChar, :CaseSensitive = FALSE)

	  #-------------------------------------------------#
	 #    CONTAINING ONE OCCURRENCE OF A SUBSTRING     #
	#-------------------------------------------------#

	def ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)
		return This.ContainsNTimesCS(1, pcSubStr, pCaseSensitive)
	
		#< @FunctionAlternativeForms

		def ContainsOnlyOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		def ContainsOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOccurrence(pcSubStr)
		return This.ContainsOneOccurrenceCS(pcSubstr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsOnlyOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		def ContainsOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		#>
			
	  #--------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THAN N OCCURRENCES OF A SUBSTRING  #
	#--------------------------------------------------------------------------#

	def ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n ust be a number.")
			ok

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr ust be a string.")
			ok
		ok

		bResult = FALSE

		bContinue = TRUE
		i = 0
		nPos = 0

		while bContinue
	
			nPos = This.FindFirstSTCS(pcSubStr, nPos + 1, pCaseSensitive)

			if nPos = 0
				bContinue = FALSE
			else
				i++
				if i > n
					bResult   = TRUE
					bContinue = FALSE
				ok
			ok
		end

		return bResult

		def ContainsMoreThenNCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThanNOccurrences(n, pcSubstr)
		return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, TRUE)

		def ContainsMoreThenN(n, pcSubStr)
			return This.ContainsMoreThanNOccurrences(n, pcSubstr)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OR MORE OCCURRENCES OF A SUBSTRING  #
	#------------------------------------------------------------------------#

	def ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)
		bResult = This.ContainsMoreThenNOccurrencesCS(n - 1, pcSubStr, pCaseSensitive)
		return bResult

		def ContainsNOrMoreCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOrMoreOccurrences(n, pcSubstr)
		return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, TRUE)
	
		def ContainsNOrMore(n, pcSubStr)
			return This.ContainsNOrMoreOccurrences(n, pcSubstr)

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS EACH OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	#TODO : Unify alternative namings with ContainsMay() in stzList

	def ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
		bResult = TRUE
		nLen = len(pacSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(pacSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsManyCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsEachOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

		#< @FunctionPassiveForms

		def ContainsNoneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoOneOfCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([ :These, :TheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsNoSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoSubStringCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseSubStrings(pacSubStr)
		return This.ContainsTheseSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def ContainsThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsMany(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEach(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOne(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		#>

		#< @FunctionPassiveForm

		def ContainsNoneOfTheseSubStrings(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoneOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNone(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoOneOf(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubStringOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubString(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #    CONTAINING CHARS IN A GIVEN SCRIPT   #
	#-----------------------------------------#

	def ContainsCharsInScript(pcScript)
		return This.ToStzText().ContainsScript(pcScript)

		#< @FunctionPassiveForm

		def ContainsNocharsInScript(pcScript)
			return NOT This.ContainsCharsInScript(pcScript)

		#>

	  #---------------------------#
	 #    CONTAINING LETTERS     #
	#---------------------------#

	def ContainsLetter(pcLetter)

		if Q(pcLetter).IsAChar() and
		   StzCharQ(pcLetter).IsLetter()

		  	return This.ContainsCS( pcLetter, :CS = FALSE )
		else
			return FALSE
		ok

	def ContainsLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = FALSE

		for i = 1 to nLen
			if aoChars[i].IsLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionPassiveForm

		def ContainsNoLetters()
			return NOT This.ContainsNumbers()

		#>

	def ContainsTheseLetters(pacLetters)
		if CheckParam()
			if NOT isList(pacLetters)
				StzRaise("Incorrect param type! pacLetters must be a alist.")
			ok
		ok

		if NOT @AreLetters(pacLetters)
			StzRaise("Incorrect param type! pacLetters must be a list of letters.")
		ok

		bResult = This.ContainsTheseCS(pacLetters, FALSE)
		return bResult

		def ContainsTheLetters(pacLetters)
			return This.ContainsTheseLetters(pacLetters)

	def ContainsArabicLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = FALSE

		for i = 1 to nLen
			if aoChars[i].IsArabicLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionPassiveForm

		def ContainsNoArabicLetters()
			return NOT This.ContainsArabicNumbers()

		#>

	def ContainsLatinLetters()
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = FALSE

		for i = 1 to nLen
			if aoChars[i].IsLatinLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionPassiveForm

		def ContainsNoLatinLetters()
			return NOT This.ContainsLatinNumbers()

		#>

	def ContainsLettersInScript(pcScript)
		aoChars = This.TolistOfStzChars()
		nLen = len(aoChars)

		bResult = FALSE

		for i = 1 to nLen
			if aoChars[i].IsLetterInScript(pcScript)
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionPassiveForm

		def ContainsNoLettersInScript(pcScript)
			return NOT This.ContainsNumbers(pcScript)

		#>

	  #=========================================#
	 #   SPLITTING THE STRING -- XT/EXTENDED   #
	#=========================================#

	#TODO
	# Add SplitAround(), SplitAroundPosition(), SplitAroundPositions(),
	# SplitAroundSubString(), SplitAroundSubStrings(),
	# SplitAroundSection(), SplitAroundSections()
	
	# Add ..IB() extensions to all those functions

	#todo
	# Make same feature in stzList

	#todo
	# add to...() as alternative of SplitTo..() all over the library


	def SplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pSubStrOrPos) and len(pSubStrOrPos) = 2
				
				if isList(pSubStrOrPos[2]) and Q(pSubStrOrPos[2]).IsAndNamedParam()
					pSubStrOrPos[2] = pSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCS(pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositions(pSubStrOrPos[1], pSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCS(pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNParts(pSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNChars(pSubStrOrPos[2])

			but oParam.IsToPartsOfExactlyNCharsNamedParam()
				return This.SplitToPartsOfExactlyNChars(pSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsXTNamedParam()
				return This.SplitToPartsOfNCharsXT(pSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereNamedParam() or oParam.IsAtCharsWNamedParam()
				return This.SplitAtCharsW(pSubStrOrPos[2])

			but oParam.IsAtCharsWhereXTNamedParam() or oParam.IsAtCharsWXTNamedParam()
				return This.SplitAtCharsW(pSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereNamedParam() or oParam.IsAtSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereXTNamedParam() or oParam.IsAtSubStringsWXTNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			#--

			but oParam.IsBeforeCharsWhereNamedParam() or oParam.IsBeforeCharsWNamedParam()
				return This.SplitBeforeCharsW(pSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereXTNamedParam() or oParam.IsBeforeCharsWXTNamedParam()
				return This.SplitBeforeCharsW(pSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereNamedParam() or oParam.IsBeforeSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereXTNamedParam() or oParam.IsBeforeSubStringsWXTNamedParam()
				return This.SplitBeforeSubStringsW(pSubStrOrPos[2])

			#--

			but oParam.IsAfterCharsWhereNamedParam() or oParam.IsAfterCharsWNamedParam()
				return This.SplitAfterCharsW(pSubStrOrPos[2])

			but oParam.IsAfterCharsWhereXTNamedParam() or oParam.IsAfterCharsWXTNamedParam()
				return This.SplitAfterCharsW(pSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereNamedParam() or oParam.IsAfterSubStringsWNamedParam()
				return This.SplitAtSubStringsW(pSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereXTNamedParam() or oParam.IsAfterSubStringsWXTNamedParam()
				return This.SplitAfterSubStringsW(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitCSXTQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitCSXTQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsCSXT(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXT(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXT(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXT(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXT(pSubStrOrPos)
		return This.SplitCSXT(pSubStrOrPos, TRUE)

		#< @FunctionFluentForm

		def SplitXTQ(pSubStrOrPos)
			return This.SplitXTQR(pSubStrOrPos, :stzList)

		def SplitXTQR(pSubStrOrPos, pcReturnType)
			return This.SplitCSXTQR(pSubStrOrPos, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitsXT(pSubStrOrPos)
			return This.SplitXT(pSubStrOrPos)

			def SplitsXTQ(pSubStrOrPos)
				return This.SplitsXTQR(pSubStrOrPos, :stzList)

			def SplitsXTQR(pSubStrOrPos, pcReturnType)
				return This.SplitXTQR(pSubStrOrPos, pcReturnType)
	
		#>

	def SplittedXT(pSubStrOrPos)
		return This.SplitXT(pSubStrOrPos)

	  #----------------------------------------#
	 #  SPLITTING THE STRING -- XTZ/EXTENDED  #
	#----------------------------------------#

	def SplitCSXTZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSectionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def SplitsCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTZ(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTZQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTZQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTZQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTZQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXTZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZ(pSubStrOrPos)
		return This.SplitCSXTZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def SplitsXTZ(pSubStrOrPos)
			return This.SplitXTZ(pSubStrOrPos)

			def SplitsXTZQ(pSubStrOrPos)
				return This.SplitsXTZQR(pSubStrOrPos, :stzList)

		def SplitsXTZQR(pSubStrOrPos, pcReturnType)
			return This.SplitXTZQR(pSubStrOrPos, pcReturnType)

		#>

	def SplittedXTZ(pSubStrOrPos)
		return This.SplitXTZ(pSubStrOrPos)

	  #-----------------------------------------#
	 #  SPLITTING THE STRING -- XTZZ/EXTENDED  #
	#-----------------------------------------#

	def SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def SplitsCSXTZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

			def SplitsCSXTZZQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSXTZZQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsCSXTZZQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitCSXTZZQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedCSXTZZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZZ(pSubStrOrPos)
		return This.SplitCSXTZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def SplitsXTZZ(pSubStrOrPos)
			return This.SplitXTZZ(pSubStrOrPos)

			def SplitsXTZZQ(pSubStrOrPos)
				return This.SplitsXTZZQR(pSubStrOrPos, :stzList)

		def SplitsXTZZQR(pSubStrOrPos, pcReturnType)
			return This.SplitXTZZQR(pSubStrOrPos, pcReturnType)

		#>

	def SplittedXTZZ(pSubStrOrPos)
		return This.SplitXTZZ(pSubStrOrPos)

	  #-----------------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING OR POSITION  #
	#===============================================#

	def SplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.SplitAtSubStrings(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitAtCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsAtCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SplitsAtCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitAtCSQ(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitsAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		def SplitCS(pSubStrOrPos, pCaseSensitive)

			if isList(pSubStrOrPos) and StzListQ(pSubStrOrPos).IsWithOrByOrUsingNamedParam()
				pSubStrOrPos = pSubStrOrPos[2]
			ok

			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SplitCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitCSQR(pSubStrOrPos, pCaseSensitive, :stzList)
	
			def SplitCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		def SplitsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SplitsCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSQR(pSubStrOrPos, pCaseSensitive, :stzList)
	
			def SplitsCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#--

		def SeparatedByCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

			def SeparatedByCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitsCSQR(pSubStrOrPos, pCaseSensitive, :stzList)
	
			def SeparatedByCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pSubStrOrPos)
		return This.SplitAtCS(pSubStrOrPos, TRUE)

		#< @FunctionAFluentForms

		def SplitAtQ(pSubStrOrPos)
			return This.SplitAtQR(pSubStrOrPos, :stzList)

		def SplitAtQR(pSubStrOrPos, pcReturnType)
			return This.SplitAtCSQR(pSubStrOrPos, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAt(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SplitsAtQ(pSubStrOrPos)
				return This.SplitAtQ(pSubStrOrPos, :stzList)
	
			def SplitsAtQR(pSubStrOrPos, pcReturnType)
				return This.SplitAtQR(pSubStrOrPos, pcReturnType)
	
		def Split(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SplitQ(pSubStrOrPos)
				return This.SplitAtQR(pSubStrOrPos, :stzList)
	
			def SplitQR(pSubStrOrPos, pcReturnType)
				return This.SplitAtQR(pSubStrOrPos, pcReturnType)

		def Splits(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SplitsQ(pSubStrOrPos)
				return This.SplitAtQR(pSubStrOrPos, :stzList)
	
			def SplitsQR(pSubStrOrPos, pcReturnType)
				return This.SplitAtQR(pSubStrOrPos, pcReturnType)

		#--

		def SeparatedBy(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

			def SeparatedByQ(pSubStrOrPos)
				return This.SplitsQR(pSubStrOrPos, :stzList)
	
			def SeparatedByR(pSubStrOrPos, pcReturnType)
				return This.SplitAtQR(pSubStrOrPos, pcReturnType)
		
		#>

	def SplittedAt(pSubStrOrPos)
		return This.SplitAt(pSubStrOrPos)

		def Splitted(pSubStrOrPos)
			return This.SplitAt(pSubStrOrPos)

	  #------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR POSITIONS  #
	#==========================================#

	def SplitsCSZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCS(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCS(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeFroms

		def SplitsAndTheirPositionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZ(pSubStrOrPos, pCaseSensitive)

		#--

		def SplitCSZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZ(pSubStrOrPos)
		return This.SplitsCSZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeFroms

		def SplitsAndTheirPositions(pSubStrOrPos)
			return This.SplitsZ(pSubStrOrPos)

		#--

		def SplitZ(pSubStrOrPos)
			return This.SplitsZ(pSubStrOrPos)

		#>

	  #-----------------------------------------#
	 #  GETTING THE SPLITS AND THEIR SECTIONS  #
	#-----------------------------------------#

	def SplitsCSZZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCS(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		#--

		def SplitCSZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZZ(pSubStrOrPos)
		return This.SplitsCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAndTheirSections(pSubStrOrPos)
			return This.SplitsZZ(pSubStrOrPos)

		#--

		def SplitZZ(pSubStrOrPos)
			return This.SplitsCSZZ(pSubStrOrPos)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR POSITIONS -- U/EXTENSION  #
	#---------------------------------------------------------#

	def SplitsCSUZ(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCSU(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSU(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsCSU(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZU(pSubStrOrPos, pCaseSensitive)

		#--

		def UniqueSplitsCSZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZU(pSubStrOrPos, pCaseSensitive)

		def UniqueSplitsAndTheirPositionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZU(pSubStrOrPos, pCaseSensitive)

		#==

		def SplitCSUZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZU(pSubStrOrPos)
		return This.SplitsCSZU(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsU(pSubStrOrPos)
			return This.SplitsZU(pSubStrOrPos)

		#--

		def UniqueSplitsZ(pSubStrOrPos)
			return This.SplitsZU(pSubStrOrPos)

		def UniqueSplitsAndTheirPositions(pSubStrOrPos)
			return This.SplitsZU(pSubStrOrPos)

		#==

		def SplitUZ(pSubStrOrPos)
			return This.SplitsUZ(pSubStrOrPos)

		#>

	  #-------------------------------------------------------#
	 #  GETTING THE SPLITS AND THEIR SECTIONS -- U/EXTENDED  #
	#-------------------------------------------------------#

	def SplitsCSZZU(pSubStrOrPos, pCaseSensitive)
		acSplits = This.SplitsCSU(pSubStrOrPos, pCaseSensitive)
		anPos = This.FindSplitsCSZZU(pSubStrOrPos, pCaseSensitive)

		aResult = @Association([ acSplits, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsCSZZU(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZU(pSubStrOrPos, pCaseSensitive)

		#--

		def UniqueSplitsCSZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZU(pSubStrOrPos, pCaseSensitive)

		def UniqueSplitsAndTheirSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSZZU(pSubStrOrPos, pCaseSensitive)

		#==

		def SplitCSUZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsCSUZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitsZZU(pSubStrOrPos)
		return This.SplitsCSZZU(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAndTheirPositionsZZU(pSubStrOrPos)
			return This.SplitsZZU(pSubStrOrPos)

		#--

		def UniqueSplitsZZ(pSubStrOrPos)
			return This.SplitsZZU(pSubStrOrPos)

		def UniqueSplitsAndTheirSections(pSubStrOrPos)
			return This.SplitsZZU(pSubStrOrPos)

		#==

		def SplitUZZ(pSubStrOrPos, pCaseSensitive)
			return This.SplitsUZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#===================================#

	def SplitAtPosition(n)

		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtPosition(n)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionQ(n)
			return This.SplitAtPositionQR(n, :stzList)

		def SplitAtPositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitAtThisPositionQ(n)
				return This.SplitAtThisPositionQR(n, :stzList)

			def SplitAtThisPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		#--

		def SplitsAtPosition(n)
			return This.SplitAtPosition(n)

			def SplitsAtPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SplitsAtPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		def SplitsThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitsAtThisPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SplitsAtThisPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		#--

		def SeparatedByPosition(n)
			return This.SplitAtPosition(n)

			def SeparatedByPositionQ(n)
				return This.SplitAtPositionQ(n)

			def SeparatedByPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		#>

	def SplittedAtPosition(n)
		return This.SplitAtPositions(n)

		def SplittedAtThisPosition(n)
			return This.SplitAtPositions(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ(This.NumberOfChars()).SplitAtPositions(anPos)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionsQ(anPos)
			return This.SplitAtPositionsQR(anPos, :stzList)

		def SplitAtPositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtThesePositionsQ(anPos)
				return This.SplitAtThesePositionsQR(anPos, :stzList)
	
			def SplitAtThesePositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		def SplitAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtManyPositionsQ(anPos)
				return This.SplitAtManyPositionsQR(anPos, :stzList)
	
			def SplitAtManyPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		#--

		def SplitsAtPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtPositionsQ(anPos)
				return This.SplitsAtPositionsQR(anPos, :stzList)

			def SplitsAtPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		def SplitsAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtThesePositionsQ(anPos)
				return This.SplitsAtPositionsQR(anPos, :stzList)

			def SplitsAtThesePositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		def SplitsAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitsAtManyPositionsQ(anPos)
				return This.SplitsAtPositionsQR(anPos, :stzList)

			def SplitsAtManyPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		#--

		def SeparatedByPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SeparatedByPositionsQ(anPos)
				return This.SplitAtPositionsQ(anPos)

			def SeparatedByPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)
		#>

	def SplittedAtPositions(anPos)
		return This.SplitAtPositions(anPos)

		#< @FunctionAlternativeForms

		def SplittedAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplittedAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	  #------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING   #
	#====================================#

	def SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if CheckParams()

			if This.IsEmpty()
				return []
			ok
	
			if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
				return This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive)
			ok
	
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
	
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		acResult = QStringListToList( This.QStringObject().split(pcSubStr, 0, pCaseSensitive) )
		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SeparatedBySubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)

			def SeparatedBySubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSQ(pcSubStr, pCaseSensitive)

			def SeparatedBySubStringCSQR(n, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubString(pcSubStr)
		return This.SplitAtSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def SplitAtSubStringQ(pcSubStr)
			return This.SplitAtSubStringQR(pcSubStr, :stzList)

		def SplitAtSubStringQR(pcSubStr, pcReturnType)
			return This.SplitAtSubStringCSQR(pcSubStr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAtSubString(pcSubStr)
			return This.SplitAtSubString(pcSubStr)

			def SplitsAtSubStringQ(pcSubStr)
				return This.SplitAtSubStringQ(pcSubStr)

			def SplitsAtSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQR(pcSubStr, pcReturnType)

		def SplitAtThisSubString(pcSubStr)
			This.SplitAtThisSubStringCS(pcSubStr, TRUE)

			def SplitAtThisSubStringQ(pcSubStr)
				return This.AtThisSubStringQR(pcSubStr, :stzList)
	
			def SplitAtThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQR(pcSubStr, pcReturnType)

		def SplitsAtThisSubString(pcSubStr)
			return This.SplitAtThisSubString(pcSubStr)

			def SplitsAtThisSubStringQ(pcSubStr)
				return This.SplitAtThisSubStringQR(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQR(pcSubStr, pcReturnType)

		#--

		def SeparatedBySubString(pcSubStr)
			return This.SplitAtThisSubString(pcSubStr)

			def SeparatedBySubStringQ(pcSubStr)
				return This.SplitAtThisSubStringQ(pcSubStr)

			def SeparatedBySubStringQR(n)
				return This.SplitAtSubStringQR(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubString(pcSubStr)
		return This.SplitAtSubString(pcSubStr)

		def SplittedAtThisSubString(pcSubStr)
			return This.SplittedAtSubString(pcSubStr)

	  #---------------------------------------------#
	 #  SPLITS AT A SUBSTRING AND THEIR POSITIONS  #
	#---------------------------------------------#

	def SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
		acSplits = This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		anPos = FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		aResult = Association([ acSplits, anPos ])
		return aResult

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSZQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCSz(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSZQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSZQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCSZ(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCSZ(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCSZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringZ(pcSubStr)
		return This.SplitAtSubStringCSZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAtSubStringZ(pcSubStr)
			return This.SplitAtSubStringZ(pcSubStr)

			def SplitsAtSubStringZQ(pcSubStr)
				return This.SplitAtSubStringZQ(pcSubStr)

			def SplitsAtSubStringZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQR(pcSubStr, pcReturnType)

		def SplitAtThisSubStringZ(pcSubStr)
			This.SplitAtThisSubStringCSZ(pcSubStr, TRUE)

			def SplitAtThisSubStringZQ(pcSubStr)
				return This.AtThisSubStringZQR(pcSubStr, :stzList)
	
			def SplitAtThisSubStringZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQR(pcSubStr, pcReturnType)

		def SplitsAtThisSubStringZ(pcSubStr)
			return This.SplitAtThisSubStringZ(pcSubStr)

			def SplitsAtThisSubStringZQ(pcSubStr)
				return This.SplitAtThisSubStringZQR(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZQR(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStringZ(pcSubStr)
		return This.SplitAtSubStringZ(pcSubStr)

		def SplittedAtThisSubStringZ(pcSubStr)
			return This.SplittedAtSubStringZ(pcSubStr)

	  #--------------------------------------------#
	 #  SPLITS AT A SUBSTRING AND THEIR SECTIONS  #
	#--------------------------------------------#

	def SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		acSplits  = This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		aSections = FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		aResult = Association([ acSplits, aSections ])
		return aResult

		#< @FunctionAlternativeForm

		def SplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtSubStringCSZZQ(pcSubStr, pCaseSensitive)

			def SplitsAtSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitAtThisSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSZZQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtThisSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)

			def SplitsAtThisSubStringCSZZQ(pcSubStr, pCaseSensitive)
				return This.SplitAtThisSubStringCSZZQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtThisSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringZZ(pcSubStr)
		return This.SplitAtSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAtSubStringZZ(pcSubStr)
			return This.SplitAtSubStringZZ(pcSubStr)

			def SplitsAtSubStringZZQ(pcSubStr)
				return This.SplitAtSubStringZZQ(pcSubStr)

			def SplitsAtSubStringZZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQR(pcSubStr, pcReturnType)

		def SplitAtThisSubStringZZ(pcSubStr)
			This.SplitAtThisSubStringCSZZ(pcSubStr, TRUE)

			def SplitAtThisSubStringZZQ(pcSubStr)
				return This.AtThisSubStringZZQR(pcSubStr, :stzList)
	
			def SplitAtThisSubStringZZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQR(pcSubStr, pcReturnType)

		def SplitsAtThisSubStringZZ(pcSubStr)
			return This.SplitAtThisSubStringZZ(pcSubStr)

			def SplitsAtThisSubStringZZQ(pcSubStr)
				return This.SplitAtThisSubStringZZQR(pcSubStr, :stzList)
	
			def SplitsAtThisSubStringZZQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringZZQR(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStringZZ(pcSubStr)
		return This.SplitAtSubStringZZ(pcSubStr)

		def SplittedAtThisSubStringZZ(pcSubStr)
			return This.SplittedAtSubStringZZ(pcSubStr)

	  #----------------------------------#
	 #   SPLITTING AT MANY SUBSTRINGS   #
	#==================================#

	def SplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if CheckParams()

			if This.IsEmpty()
				return []
			ok
	
		ok

		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtManyCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)

			def SplitAtManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtTheseSubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtManySubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtManySubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAtSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtManyCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)

			def SplitsAtManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplistAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtTheseSubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAtManySubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitsAtManySubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManyCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStrings(pacSubStr)
		return This.SplitAtSubStringsCS(pacSubStr, TRUE)

		#< @FunctionFluentForm

		def SplitAtSubStringsQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.SplitAtSubStringsCSQR(pcSubStr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitAtMany(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtManyQ(pacSubStr)
				return This.SplitAtSubStringsQ(pcSubStr)

			def SplitAtManyQR(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		def SplitAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtTheseSubStringsQ(pcSubStr)
				return This.SplitAtTheseSubStringsQR(pcSubStr, :stzList)
	
			def SplitAtTheseSubStringsQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		def SplitAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtManySubStringsQ(pcSubStr)
				return This.SplitAtManySubStringsQR(pcSubStr, :stzList)
	
			def SplitAtManySubStringsQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		#--

		def SplitsAtSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtSubStringsQ(pacSubStr)
				return This.SplitAtSubStringsQ(pacSubStr)

			def SplitsAtSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pacSubStr, pcReturnType)

		def SplitsAtMany(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtManyQ(pacSubStr)
				return This.SplitAtSubStringsQ(pcSubStr)

			def SplitsAtManyQR(pacSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		def SplistAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtTheseSubStringsQ(pcSubStr)
				return This.SplitAtTheseSubStringsQR(pcSubStr, :stzList)
	
			def SplitsAtTheseSubStringsQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		def SplitsAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitsAtManySubStringsQ(pcSubStr)
				return This.SplitAtManySubStringsQR(pcSubStr, :stzList)
	
			def SplitsAtManySubStringsQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringsQR(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubStrings(pacSubStr)
		return This.SplitAtSubStrings(pacSubStr)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtMany(pacSubStr)
			return This.SplittedAtSubStrings(pacSubStr)

		#>

	  #----------------------------------#
	 #   SPLITTING AT A GIVEN SECTION   #
	#==================================#

	def SplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionQ(n1, n2)
			return This.SplitAtSectionQR(n1, n2, :stzList)

		def SplitAtSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSection(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSection(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSection(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQR(n1, n2, :stzList)

			def SplitAtThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAtSectionQR(n1, n2, pcReturnType)

		#--

		def SplitsAtSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitsAtSectionQ(n1, n2)
				return This.SplitAtThisSectionQR(n1, n2, :stzList)

			def SplitsAtSectionQR(n1, n2, pcReturnType)
				return This.SplitAtSectionQR(n1, n2, pcReturnType)

		def SplitsAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitsAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQR(n1, n2, :stzList)

			def SplitsAtThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAtSectionQR(n1, n2, pcReturnType)

		#>


	def SplittedAtSection(n1, n2)
		return This.SplitAtSection(n1, n2)

		def SplittedAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

	  #-----------------------------------------------------#
	 #   SPLITTING AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-----------------------------------------------------#

	def SplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionIBQ(n1, n2)
			return This.SplitAtSectionIBQR(n1, n2, :stzList)

		def SplitAtSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQR(n1, n2, :stzList)

			def SplitAtThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQR(n1, n2, pcReturnType)

		#--

		def SplitsAtSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitsAtSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQR(n1, n2, :stzList)

			def SplitsAtSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQR(n1, n2, pcReturnType)

		def SplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitsAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQR(n1, n2, :stzList)

			def SplitsAtThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAtSectionIB(n1, n2)
		return This.SplitAtSectionIB(n1, n2)

		def SplittedAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

	  #--------------------------------#
	 #   SPLITTING AT MANY SECTIONS   #
	#--------------------------------#

	def SplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aTempSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSections(paSections)
		acResult = This.Sections( aTempSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsQ(n1, n2)
			return This.SplitAtSectionsQR(n1, n2, pcReturnType)

		def SplitAtSectionsQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSections(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSections(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSections(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQR(paSections, :stzList)

			def SplitAtTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAtSectionsQR(paSections, pcReturnType)

		#--

		def SplitsAtSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitsAtSectionsQ(paSections)
				return This.SplitAtTheseSectionsQR(paSections, :stzList)

			def SplitsAtSectionsQR(paSections, pcReturnType)
				return This.SplitAtSectionsQR(paSections, pcReturnType)

		def SplitsAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitsAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQR(paSections, :stzList)

			def SplitsAtTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAtSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAtSections(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSections(paSections)
			return This.SplittedAtSections(paSections)

	  #---------------------------------------------------#
	 #   SPLITTING AT MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------#

	def SplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionsIB(paSections)
		acResult = This.Sections( paSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsIBQ(n1, n2)
			return This.SplitAtSectionsIBQR(n1, n2, pcReturnType)

		def SplitAtSectionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionsIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQR(paSections, :stzList)

			def SplitAtTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAtSectionsIBQR(paSections, pcReturnType)

		#--

		def SplitsAtSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitsAtSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQR(paSections, :stzList)

			def SplitsAtSectionsIBQR(paSections, pcReturnType)
				return This.SplitAtSectionsIBQR(paSections, pcReturnType)

		def SplitsAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitsAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQR(paSections, :stzList)

			def SplitsAtTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAtSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAtSectionsIB(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSectionsIB(paSections)
			return This.SplittedAtSections(paSections)

	  #----------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION OR SUBSTRING   #
	#====================================================#

	def SplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.SplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitsBeforeCS(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

			def SplitsBeforeCSQ(pSubStrOrPos, pCaseSensitive)
				return This.SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)

			def SplitsBeforeCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)

		#>


	def SplittedBeforeCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBefore(pSubStrOrPos)
		return This.SplitBeforeCS(pSubStrOrPos, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeQ(pSubStrOrPos)
			return This.SplitBeforeQR(pSubStrOrPos, :stzList)

		def SplitBeforeQR(pSubStrOrPos, pcReturnType)
			return This.SplitBeforeCSQR(pSubStrOrPos, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsBefore(pSubStrOrPos)
			return This.SplitBefore(pSubStrOrPos)

			def SplitsBeforeQ(pSubStrOrPos)
				return This.SplitBeforeQ(pSubStrOrPos)

			def SplitsBeforeQR(pSubStrOrPos, pcReturnType)
				return This.SplitBeforeQR(pSubStrOrPos, pcReturnType)

		#>

	def SplittedBefore(pSubStrOrPos)
		return This.SplitBefore(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitBeforePosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforePositionQ(n)
			return This.SplitBeforePositionQR(n, :stzList)

		def SplitBeforePositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitBeforeThisPositionQ(n)
				return This.SplitBeforeThisPositionQR(n, :stzList)

			def SplitBeforeThisPositionQR(n, pcReturnType)
				return This.SplitBeforePositionQR(n, pcReturnType)

		#--

		def SplitsBeforePosition(n)
			return This.SplitBeforePosition(n)

			def SplitsBeforePositionQ(n)
				return This.SplitBeforePositionQ(n)

			def SplitsBeforePositionQR(n, pcReturnType)
				return This.SplitBeforePositionQR(n, pcReturnType)

		def SplitsBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitsBeforeThisPositionQ(n)
				return This.SplitBeforePositionQ(n)

			def SplitsBeforeThisPositionQR(n, pcReturnType)
				return This.SplitBeforePositionQR(n, pcReturnType)
		#>

	def SplittedBeforePosition(n)
		return This.SplitBeforePosition(n)

		def SplittedBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(anPos)

		if CheckParams()
			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		if This.IsEmpty()
			return []
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult			

		#< @FunctionFluentForms

		def SplitBeforePositionsQ(anPos)
			return This.SplitBeforePositionsQR(anPos, :stzList)

		def SplitBeforePositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThesePositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeThesePositionsQ(anPos)
				return This.SplitBeforThesePositionsQR(anPos, :stzList)

			def SplitBeforeThesePositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		def SplitBeforeManyPositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeManyPositionsQ(anPos)
				return This.SplitBeforeManyPositionsQR(anPos, :stzList)

			def SplitBeforeManyPositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		#>

	def SplittedBeforePositions(anPos)
		return This.SplitBeforePositions(anPos)

		def SplittedBeforeThesePoitions(anPos)
			return This.SplittedBeforePositions(anPos)

		def SplittedBeforeManyPoitions(anPos)
			return This.SplittedBeforePositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitBeforeThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

			def SplitBeforeThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsBeforeSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsBeforeSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsBeforeThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsBeforeThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		#>
				
	def SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubString(pcSubStr)
		return This.SplitBeforeSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeSubStringQ(pcSubStr)
			return This.SplitBeforeSubStringQR(pcSubStr, :stzList)

		def SplitBeforeSubStringQR(pcSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubString(pcSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitBeforeThisSubStringQ(pcSubStr)
				return This.SplitBeforeThisSubStringQR(pcSubStr, :stzList)

			def SplitBeforeThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQR(pcSubStr, pcReturnType)

		#--

		def SplitsBeforeSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitsBeforeSubStringQ(pcSubStr)
				return This.SplitBeforeSubStringQ(pcSubStr)

			def SplitsBeforeSubStringQR(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQ(pcSubStr, pcReturnType)

		def SplitsBeforeThisSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitsBeforeThisSubStringQ(pcSubStr)
				return This.SplitBeforeSubStringQ(pcSubStr)

			def SplitsBeforeThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQ(pcSubStr, pcReturnType)

		#>

	def SplittedBeforeSubString(pcSubStr)
		return This.SplitBeforeSubString(pcSubStr)

		def SplittedBeforeThisSubString(pcSubStr)
			return This.SplittedBeforeSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitsBeforeTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsBeforeManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitsBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStringsCS(pacSubStr, TRUE)
	
		#< @FunctionFluentForms

		def SplitBeforeSubStringsQ(pacSubStr)
			return This.SplitBeforeSubStringsQR(pacSubStr, :stzList)

		def SplitBeforeSubStringsQR(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeTheseSubStringsQ(pacSubStr)
				return This.SplitBeforeThisSubStringsQR(pacSubStr, :stzList)

			def SplitBeforeTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		def SplitBeforeManySubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeManySubStringsQ(pacSubStr)
				return This.SplitBeforeManySubStringsQR(pacSubStr, :stzList)

			def SplitBeforeManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		#--

		def SplitsBeforeSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeSubStringsQ(pacSubStr)
				return This.SplitBeforeSubStringsQ(pacSubStr)

			def SplitsBeforeSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		def SplitsBeforeTheseSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeTheseSubStringsQ(pacSubStr)
				return This.SplitBeforeThisSubStringsQR(pacSubStr, :stzList)

			def SplitsBeforeTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		def SplitsBeforeManySubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitsBeforeManySubStringsQ(pacSubStr)
				return This.SplitBeforeManySubStringsQR(pacSubStr, :stzList)

			def SplitsBeforeManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		#>

	def SplittedBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStrings(pacSubStr)

		def SplittedBeforeTheseSubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

		def SplittedBeforeManySubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION   #
	#--------------------------------------#

	def SplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionQ(n1, n2)
			return This.SplitBeforeSectionQR(n1, n2, :stzList)

		def SplitBeforeSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeThisSectionQR(n1, n2, :stzList)

			def SplitBeforeThisSectionQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQR(n1, n2, pcReturnType)

		#--

		def SplitsBeforeSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitsBeforeSectionQ(n1, n2)
				return This.SplitBeforeSectionQ(n1, n2)

			def SplitsBeforeSectionQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQR(n1, n2, pcReturnType)

		def SplitsBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitsBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeSectionQ(n1, n2)

			def SplitsBeforeThisSectionQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQR(n1, n2, pcReturnType)
		#>

	def SplittedBeforeSection(n1, n2)
		return This.SplitBeforeSection(n1, n2)

		def SplittedBeforeThisSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

	  #--------------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------#

	def SplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionIBQ(n1, n2)
			return This.SplitBeforeSectionIBQR(n1, n2, :stzList)

		def SplitBeforeSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeThisSectionIBQR(n1, n2, :stzList)

			def SplitBeforeThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQR(n1, n2, pcReturnType)

		#--

		def SplitsBeforeSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitsBeforeSectionIBQ(n1, n2)
				return This.SplitBeforeSectionIBQ(n1, n2)

			def SplitsBeforeSectionIBQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQR(n1, n2, pcReturnType)

		def SplitsBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitsBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeSectionIBQ(n1, n2)

			def SplitsBeforeThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQR(n1, n2, pcReturnType)
		#>

	def SplittedBeforeSectionIB(n1, n2)
		return This.SplitBeforeSectionIB(n1, n2)

		def SplittedBeforeThisSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

	  #------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS   #
	#------------------------------------#

	def SplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsQ(paSections)
			return This.SplitBeforeSectionsQR(paSections, :stzList)

		def SplitBeforeSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQR(paSections, :stzList)

			def SplitBeforeTheseSectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		def SplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQR(paSections, :stzList)

			def SplitBeforeManySectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		#--

		def SplitsBeforeSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeSectionsQ(paSections)
				return This.SplitBeforeSectionsQ(paSections)

			def SplitsBeforeSectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		def SplitsBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQR(paSections, :stzList)

			def SplitsBeforeTheseSectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		def SplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitsBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQR(paSections, :stzList)

			def SplitsBeforeManySectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)
		#>

	def SplittedBeforeSections(paSections)
		return This.SplitBeforeSections(paSections)

		def SplittedBeforeTheseSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplittedBeforeManySections(paSections)
			return This.SplittedBeforeSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#------------------------------------------------------#

	def SplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsIBQ(paSections)
			return This.SplitBeforeSectionsIBQR(paSections, :stzList)

		def SplitBeforeSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>


		#< @FunctionAlternativeForms

		def SplitBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQR(paSections, :stzList)

			def SplitBeforeTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		def SplitBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQR(paSections, :stzList)

			def SplitBeforeManySectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		#--

		def SplitsBeforeSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeSectionsIBQ(paSections)
				return This.SplitBeforeSectionsIBQ(paSections)

			def SplitsBeforeSectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		def SplitsBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQR(paSections, :stzList)

			def SplitsBeforeTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		def SplitsBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitsBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQR(paSections, :stzList)

			def SplitsBeforeManySectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedBeforeSectionsIB(paSections)
		return This.SplitBeforeSectionsIB(paSections)

		def SplittedBeforeTheseSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplittedBeforeManySectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

	  #--------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN POSITION OR SUBSTRING  #
	#--------------------------------------------------#

	def SplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitAfterSections(pSubStrOrPos)


			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitAfterCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitsAfterCS(pcSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCS(pcSubStr, pCaseSensitive)

			def SplitsAfterCSQ(pcSubStrOrPos, pCaseSensitive)
				return This.SplitAfterCSQ(pcSubStrOrPos, pCaseSensitive)

			def SplitsAfterCSQR(pcSubStrOrPos, pCaseSensitive, pcReturnType)
				return This.SplitsAfterCSQR(pcSubStrOrPos, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAfterCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfter(pSubStrOrPos)
		return This.SplitAfterCS(pSubStrOrPos, TRUE)

		#< @FunctionFluentForm

		def SplitAfterQ(pSubStrOrPos)
			return This.SplitAfterQR(pSubStrOrPos, :stzList)

		def SplitAfterQR(pSubStrOrPos, pcReturnType)
			return This.SplitAfterCSQR(pSubStrOrPos, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAfter(pcSubStrOrPos)
			return This.SplitAfter(pcSubStr)

			def SplitsAfterQ(pcSubStrOrPos)
				return This.SplitAfterQ(pcSubStrOrPos)

			def SplitsAfterQR(pcSubStrOrPos, pcReturnType)
				return This.SplitsAfterCSQR(pcSubStrOrPos, pcReturnType)

		#>

	def SplittedAfter(pSubStrOrPos)
		return This.SplitAfter(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( n >= 1 and n <= This.NumberOfChars() )
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionQ(n)
			return This.SplitAfterPositionQR(n, :stzList)

		def SplitAfterPositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitAfterThisPositionQ(n)
				return This.SplitAfterThisPositionQR(n, :stzList)

			def SplitAfterThisPositionQR(n, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#--

		def SplitsAfterPosition(n)
			return This.SplitAfterPosition(n)

			def SplitsAfterPositionQ(n)
				return This.SplitAfterPositionQ(n)

			def SplitsAfterPositionQR(n, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		def SplitsAfterthisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitsAfterThisPositionQ(n)
				return This.SplitAfterPositionQ(n)

			def SplitsAfterThisPositionQR(n, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPosition(n)
		return This.SplitAfterPosition(n)

		def SplittedAfterThisPosition(n)
			return This.SplittedAfterPosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		if len(anPos) = 0
			return [ This.Content() ]
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionsQ(anPos)
			return This.SplitAfterPositionsQR(anPos, :stzList)

		def SplitAfterPositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQR(anPos, :stzList)

			def SplitAfterThesePositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		def SplitAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQR(anPos, :stzList)

			def SplitAfterManyPositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#--

		def SplitsAfterPositions(panPos)
			return This.SplitAfterPosirtions(panPos)

			def SplitsAfterPositionsQ(panPos)
				return This.SplitAfterPositionsQ(panPos)

			def SplitsAfterPositionsQR(panPos, pcReturnType)
				return This.SplitsAfterPositionsQR(panPos, pcReturnType)

		def SplitsAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitsAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQR(anPos, :stzList)

			def SplitsAfterThesePositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		def SplitsAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitsAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQR(anPos, :stzList)

			def SplitsAfterManyPositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPositions(anPos)
		return This.SplitAfterPositions(anPos)

		def SplittedAfterThesePositions(anPos)
			return This.SplittedAfterPositions(anPos)

		def SplittedAfterManyPositions(anPos)
			return This.SplittedAfterPositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitAfterThisSubStringQCS(pcSubStr, pCaseSensitive)
				return This.SplitAfterThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

			def SplitAfterThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#--

		def SplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAfterSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAfterSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitsAfterThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)

			def SplitsAfterThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubString(pcSubStr)
		return This.SplitAfterSubStringCS(pcSubStr, TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringQ(pcSubStr)
			return This.SplitAfterSubStringQR(pcSubStr)

		def SplitAfterSubStringQR(pcSubStr)
			return This.SplitAfterThisSubStringCSQR(pcSubStr, :pCaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitAfterThisSubStringQ(pcSubStr)
				return This.SplitAfterThisSubStringQR(pcSubStr, :stzList)

			def SplitAfterThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQR(pcSubStr, pcReturnType)

		#--

		def SplitsAfterSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitsAfterSubStringQ(pcSubStr)
				return This.SplitAfterSubStringQ(pcSubStr)

			def SplitsAfterSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQ(pcSubStr, pcReturnType)

		def SplitsAfterThisSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitsAfterThisSubStringQ(pcSubStr)
				return This.SplitAfterSubStringQ(pcSubStr)

			def SplitsAfterThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQ(pcSubStr, pcReturnType)

		#>

	def SplittedAfterSubString(pcSubStr)
		return This.SplitAfterSubString(pcSubStr)

		def SplittedAfterThisSubString(pcSubStr)
			return This.SplittedAfterSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterTheseSubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterTheseSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterManySubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterManySubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive)

		#--

		def SplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitsAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitsAfterManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)

			def SplitsAfterManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStringsCS(pacSubStr, TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringsQ(pacSubStr)
			return This.SplitAfterSubStringsQR(pacSubStr, :stzList)

		def SplitAfterSubStringsQR(pacSubStr, pcReturnType)
			return This.SplitAfterSubStringsCSQR(pacSubStr, :CaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterTheseSubStringsQ(pacSubStr)
				return This.SplitAfterTheseSubStringsQR(pacSubStr, :stzList)

			def SplitAfterTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		def SplitAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterManySubStringsQ(pacSubStr)
				return This.SplitAfterManySubStringsQR(pacSubStr, :stzList)

			def SplitAfterManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		#--

		def SplitsAfterSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterSubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		def SplitsAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterTheseSubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		def SplitsAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitsAfterManySubStringsQ(pacSubStr)
				return This.SplitAfterSubStringsQ(pacSubStr)

			def SplitsAfterManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		#>

	def SplittedAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

	  #-------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION   #
	#-------------------------------------#

	def SplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSection(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionQ(n1, n2)
			return This.SplitAfterSectionQR(n1, n2)

		def SplitAfterSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitAfterThisSectionQ(n1, n2)
				return This.SplitAfterThisSectionQR(n1, n2, :stzList)

			def SplitAfterThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionQR(n1, n2, pcReturnType)

		#--

		def SplitsAfterSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitsAfterSectionQ(n1, n2)
				return This.SplitAfterSectionQ(n1, n2)

			def SplitsAfteterSectionQR(n1, n2)
				return This.SplitAfterSectionQR(n1, n2)

		#>

	def SplittedAfterSection(n1, n2)
		return This.SplitAfterSection(n1, n2)

		def SplittedAfterThisSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

	  #-------------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-------------------------------------------------------#

	def SplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionIB(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionIBQ(n1, n2)
			return This.SplitAfterSectionIBQR(n1, n2, :stzList)

		def SplitAfterSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSectionIB(n1, n2)
			return This.SplitAfterSectionIB(n1, n2)

			def SplitAfterThisSectionIBQ(n1, n2)
				return This.SplitAfterThisSectionIBQR(n1, n2, :stzList)

			def SplitAfterThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAfterSectionIB(n1, n2)
		return This.SplitAfterSectionIB(n1, n2)

		def SplittedAfterThisSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

	  #-----------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS   #
	#-----------------------------------#

	def SplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsQ(paSections)
			return This.SplitAfterSectionsQR(paSections, :stzList)

		def SplitAfterSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSections(paSections)
			return This.SplitAfteSections(paSections)

			def SplitAfterTheseSectionsQ(paSections)
				return This.SplitAfterTheseSectionsQR(paSections, :stzList)

			def SplitAfterTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAfterSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAfterSections(paSections)
		return This.SplitAfterSections(paSections)

		def SplittedAfterTheseSections(paSections)
			return This.SplittedAfterSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------#

	def SplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsIBQ(paSections)
			return This.SplitAfterSectionsIBQR(paSections, :stzList)

		def SplitAfterSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSectionsIB(paSections)
			return This.SplitAfteSectionsIB(paSections)

			def SplitAfterTheseSectionsIBQ(paSections)
				return This.SplitAfterTheseSectionsIBQR(paSections, :stzList)

			def SplitAfterTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAfterSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAfterSectionsIB(paSections)
		return This.SplitAfterSectionsIB(paSections)

		def SplittedAfterTheseSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=================================================#

	def SplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSQR(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSQR(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCS(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetween(pBound1, pBound2)
		return This.SplitBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenQR(Bound1, pBound2, :stzList)

		def SplitBetweenQR(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetween(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetween(pBound1, pBound2)
		return This.SplitBetween(pBound1, pBound2)

	  #---------------------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	def SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSIBQR(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSIBQR(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenIB(pBound1, pBound2)
		return This.SplitBetweenCSIB(pBound1, pBound2, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenIBQR(Bound1, pBound2, :stzList)

		def SplitBetweenIBQR(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenIB(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenIB(pBound1, pBound2)
		return This.SplitBetweenIB(pBound1, pBound2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS   #
	#------------------------------------#

	def SplitBetweenPositions(n1, n2)
		This.SplitAtSection(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsQ(n1, n2)
			return This.SplitBetweenPositionsQR(n1, n2, :stzList)

		def SplitBetweenPositionsQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositions(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositions(n1, n2)
			return This.SplitBetweenPositions(n1, n2)

			def SplitBetweenThesePositionsQ(n1, n2)
				return This.SplitBetweenThesePositionsQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositions(n1, n2)
		return This.SplitBetweenPositions(n1, n2)

		def SplittedBetweenThesePositions(n1, n2)
			return This.SplittedBetweenPositions(n1, n2)

	  #-------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------#

	def SplitBetweenPositionsIB(n1, n2)
		This.SplitAtSectionIB(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsIBQ(n1, n2)
			return This.SplitBetweenPositionsIBQR(n1, n2, :stzList)

		def SplitBetweenPositionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositionsIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositionsIB(n1, n2)
			return This.SplitBetweenPositionsIB(n1, n2)

			def SplitBetweenThesePositionsIBQ(n1, n2)
				return This.SplitBetweenThesePositionsIBQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsIBQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsIBQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositionsIB(n1, n2)
		return This.SplitBetweenPositionsIB(n1, n2)

		def SplittedBetweenThesePositionsIB(n1, n2)
			return This.SplittedBetweenPositionsIB(n1, n2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO SUBSTRINGS  #
	#------------------------------------#

	def SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pacSubStr, pCaseSensitive)
		acResult = This.SplitBetweenSections(aSections)
		return acResult

		#< @FunctionFluentForms

		def SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBetweenTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBetweenTheseSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBetweenTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturntype)
				return This.SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		acResult = This.Copy().SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive).Content()
		return acResult

		def SplittedBetweenTheseSubStringsCs(pacSubStr, pCaseSensitive)
			return This.SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenSubStrings(pacSubStr)
		return This.SplitBetweenSubStringsCS(pacSubStr, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenSubStringsQ(pacSubStr)
			return This.SplitBetweenSubStringsQR(pacSubStr, :stzList)

		def SplitBetweenSubStringsQR(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStrings(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStrings(pacSubStr)
			return This.SplitBetweenSubStrings(pacSubStr)

			def SplitBetweenTheseSubStringsQ(pacSubStr)
				return This.SplitBetweenTheseSubStringsQR(pacSubStr, :stzList)

			def SplitBetweenTheseSubStringsQR(pacSubStr, pcReturntype)
				return This.SplitBetweenSubStringsQR(pacSubStr, pcReturnType)

		#>


	def SplittedBetweenSubStrings(pacSubStr)
		return This.SplittedBetweenSubStringsCS(pacSubStr, TRUE)

		def SplittedBetweenTheseSubStrings(pacSubStr)
			return This.SplittedBetweenSubStrings(pacSubStr)

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#============================#

	def SplitToNParts(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToNParts(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToNPartsQ(n)
			return This.SplitToNPartsQR(n, :stzList)

		def SplitToNPartsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToNParts(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToNParts(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToNParts(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToNParts(n)
		return This.SplitToNParts(n)

	  #---------------------------------------------#
	 #   SPLITTING TO PARTS OF (EXACTLY) N CHARS   #
	#---------------------------------------------#
	# Remaining part less the n chars is not returned

	def SplitToPartsOfNChars(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfExactlyNPositions(n)

		aResult = This.Sections( aSections )
		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsQ(n)
			return This.SplitToPartsOfNCharsQR(n, :stzList)

		def SplitToPartsOfNCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNChars(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

			def SplitToPartsOfExactlyNCharsQ(n)
				return This.SplitToPartsOfExactlyNCharsQR(n, :stzList)

			def SplitToPartsOfExactlyNCharsQR(n, pcReturnType)
				return This.SplitToPartsOfNCharsQR(n, pcReturnType)

		#>

	def SplittedToPartsOfNChars(n)
		return This.SplitToPartsOfNChars(n)

		def SplittedToPartsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

	  #----------------------------------------------#
	 #   SPLITTING TO PARTS OF N CHARS -- EXTENDED  #
	#----------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def SplitToPartsOfNCharsXT(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfNPositions(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsXTQ(n)
			return This.SplitToPartsOfNCharsXTQR(n, :stzList)

		def SplitToPartsOfNCharsXTQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNCharsXT(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToPartsOfNCharsXT(n)
		return This.SplitToPartsOfNCharsXT(n)

		def SplittedToPartsOfExactlyNCharsXT(n)
			return This.SplitToPartsOfNCharsXT(n)

	  #---------------------------------------------------------#
	 #    SPLITTING AT SUBSTRINGS VERIFYING A GIVEN CONDTION   #
	#=========================================================#

	def SplitAtSubStringsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "IIIiiiMMMmmmAAA" )
		? o1.SplitAtSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "III", "MMM", "AAA" ]
		*/

		aSections = This.FindPartsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAtSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCSQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAtSubStringsWCSQR(pcCondition, pCaseSensitive pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitAtSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStringsW(pcCondition)
		return This.SplitAtSubStringsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAtSubStringsWQ(pcCondition)
			return This.SplitAtSubStringsWQR(pcCondition, :stzList)

		def SplitAtSubStringsWQR(pcCondition, pcReturnType)
			return This.SplitAtSubStringsWCSQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedAtSubStringsW(pcConditon)
		return This.SplitAtSubStringsW(pcCondition)

	  #------------------------------------------------------------------------#
	 #    SPLITTING AT SUBSTRINGS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)
		aSections = This.FindPartsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAtSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAtSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAtSubStringsWCSXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAtSubStringsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtSubStringsWCSXT(pcConditon, pCaseSensitive)
		return This.SplitAtSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def SplitAtSubStringsWXT(pcCondition)
		return This.SplitAtSubStringsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAtSubStringsWXTQ(pcCondition)
			return This.SplitAtSubStringsWXTQR(pcCondition, :stzList)

		def SplitAtSubStringsWXTQR(pcCondition, pcReturnType)
			return This.SplitAtSubStringsWCSXTQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedAtSubStringsWXT(pcConditon)
		return This.SplitAtSubStringsWXT(pcCondition)

	  #-------------------------------------------------------------#
	 #    SPLITTING BEFORE SUBSTRINGS VERIFYING A GIVEN CONDTION   #
	#=============================================================#

	def SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeSubStringsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindPartsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforeSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCSQR(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsWCSQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitBeforeSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStringsW(pcCondition)
		return This.SplitBeforeSubStringsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWQ(pcCondition)
			return This.SplitBeforeSubStringsWQR(pcCondition, :stzList)

		def SplitBeforeSubStringsWQR(pcCondition, pcReturnType)
			return This.SplitBeforeSubStringsWCSQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedBeforeSubStringsW(pcCondition
		return This.SplitBeforeSubStringsW(pcCondition)

	  #----------------------------------------------------------------------------#
	 #    SPLITTING BEFORE SUBSTRINGS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindPartsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforeSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeSubStringsWCSXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStringsWXT(pcCondition)
		return This.SplitBeforeSubStringsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeSubStringsWXTQ(pcCondition)
			return This.SplitBeforeSubStringsWXTQR(pcCondition, :stzList)

		def SplitBeforeSubStringsWXTQR(pcCondition, pcReturnType)
			return This.SplitBeforeSubStringsWCSXTQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedBeforeSubStringsWXT(pcCondition
		return This.SplitBeforeSubStringsWXT(pcCondition)

	  #------------------------------------------------------------#
	 #    SPLITTING AFTER SUBSTRINGS VERIFYING A GIVEN CONDTION   #
	#============================================================#

	def SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAfterSubStringsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindPartsWCSZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCSQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterSubStringsWCSQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterSubStringsWCS(pcCondition, pCaseSensitive)
		return This.SplitAfterSubStringsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStringsW(pcCondition)
		return This.SplitAfterSubStringsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringsWQ(pcCondition)
			return This.SplitAfterSubStringsWQR(pcCondition, :stzList)

		def SplitAfterSubStringsWQR(pcCondition, pcReturnType)
			return This.SplitAfterSubStringsWCSQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedAfterSubStringsW(pcCondition
		return This.SplitAfterSubStringsW(pcCondition)

	  #---------------------------------------------------------------------------#
	 #    SPLITTING AFTER SUBSTRINGS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------#

	def SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAfterSubStringsWXT( 'Q(@SubString).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		aSections = This.FindPartsWCSXTZZ(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterSections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAfterSubStringsWCSXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterSubStringsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfSubStrings
				return new stzListOfSubStrings( This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStringsWXT(pcCondition)
		return This.SplitAfterSubStringsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringsWXTQ(pcCondition)
			return This.SplitAfterSubStringsWXTQR(pcCondition, :stzList)

		def SplitAfterSubStringsWXTQR(pcCondition, pcReturnType)
			return This.SplitAfterSubStringsWCSXTQR(pcCondition, TRUE, pcReturnType)

		#>

	def SplittedAfterSubStringsWXT(pcCondition
		return This.SplitAfterSubStringsWXT(pcCondition)

	  #----------------------------------------------------#
	 #    SPLITTING AT CHARS VERIFYING A GIVEN CONDTION   #
	#====================================================#

	def SplitAtCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAtCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAtCharsWQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAtCharsWCSQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtCharsWCS(pcCondition, pCaseSensitive)
		return This.SplitAtCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtCharsW(pcCondition)
		return This.SplitAtCharsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAtCharsWQ(pcCondition)
			return This.SplitAtCharsWQR(pcCondition, :stzList)

		def SplitAtCharsWQR(pcCondition, pcReturnType)
			return This.SplitAtCharsWCSQR(pcCondition, pcReturnType)


		#>

	def SplittedAtCharsW(pcCondition)
		return This.SplitAtCharsW(pcCondition)

	  #-------------------------------------------------------------------#
	 #    SPLITTING AT CHARS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#-------------------------------------------------------------------#

	def SplitAtCharsWCSXT(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAtCharsWXT( 'Q(@Char).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAtPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAtCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAtCharsWXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAtCharsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtCharsWCSXT(pcCondition, pCaseSensitive)
		return This.SplitAtCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtCharsWXT(pcCondition)
		return This.SplitAtCharsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAtCharsWXTQ(pcCondition)
			return This.SplitAtCharsWXTQR(pcCondition, :stzList)

		def SplitAtCharsWXTQR(pcCondition, pcReturnType)
			return This.SplitAtCharsWCSxtQR(pcCondition, pcReturnType)


		#>

	def SplittedAtCharsWXT(pcCondition)
		return This.SplitAtCharsWXT(pcCondition)

	  #--------------------------------------------------------#
	 #    SPLITTING BEFORE CHARS VERIFYING A GIVEN CONDTION   #
	#========================================================#

	def SplitBeforeCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitBeforeCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeCharsWCSQR(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeCharsWCSQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeCharsWCS(pcConditon, pCaseSensitive)
		return This.SplitBeforeCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeCharsW(pcCondition)
		return This.SplitBeforeCharsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeCharsWQ(pcCondition)
			return This.SplitBeforeCharsWQR(pcCondition, :stzList)

		def SplitBeforeCharsWQR(pcCondition, pcReturnType)
			return This.SplitBeforeCharsWCSQR(pcCondtion, TRUE, pcReturnType)

		#>

	def SplittedBeforeCharsW(pcConditon)
		return This.SplitBeforeCharsW(pcCondition)

	  #-----------------------------------------------------------------------#
	 #    SPLITTING BEFORE CHARS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------#

	def SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitBeforePositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitBeforeCharsWCSXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitBeforeCharsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeCharsWCSXT(pcConditon, pCaseSensitive)
		return This.SplitBeforeCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeCharsWXT(pcCondition)
		return This.SplitBeforeCharsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeCharsWXTQ(pcCondition)
			return This.SplitBeforeCharsWXTQR(pcCondition, :stzList)

		def SplitBeforeCharsWXTQR(pcCondition, pcReturnType)
			return This.SplitBeforeCharsWCSXTQR(pcCondtion, TRUE, pcReturnType)

		#>

	def SplittedBeforeCharsWXT(pcConditon)
		return This.SplitBeforeCharsWXT(pcCondition)

	  #-------------------------------------------------------#
	 #    SPLITTING AFTER CHARS VERIFYING A GIVEN CONDTION   #
	#=======================================================#

	def SplitAfterCharsWCS(pcCondition, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzString( "ABCabcEFGijHI" )
		? o1.SplitAfterCharsW( 'Q(This[@i]).IsLowercase()' )
		#--> [ "ABC", "EFG", "HI" ]
		*/

		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterCharsWCSQ(pcCondition, pCaseSensitive)
			return This.SplitAfterCharsWCSQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterCharsWCSQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCharsWCS(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterCharsWCS(pcConditon, pCaseSensitive)
		return This.SplitAfterCharsWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterCharsW(pcCondition)
		return This.SplitAfterCharsWCS(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAfterCharsWQ(pcCondition)
			return This.SplitAfterCharsWQR(pcCondition, :stzList)

		def SplitAfterCharsWQR(pcCondition, pcReturnType)
			return This.SplitAfterCharsWCSQR(pcCondtion, TRUE, pcReturnType)

		#>

	def SplittedAfterCharsW(pcConditon)
		return This.SplitAfterCharsW(pcCondition)

	  #----------------------------------------------------------------------#
	 #    SPLITTING AFTER CHARS VERIFYING A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------#

	def SplitAfterCharsWCSXT(pcCondition, pCaseSensitive)

		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.SplitAfterPositions(anPos)

		return acResult

		#< @FunctionFluentForms

		def SplitAfterCharsWCSXTQ(pcCondition, pCaseSensitive)
			return This.SplitAfterCharsWCSXTQR(pcCondition, pCaseSensitive, :stzList)

		def SplitAfterCharsWCSXTQR(pcCondition, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterCharsWCSXT(pcConditon, pCaseSensitive)
		return This.SplitAfterCharsWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterCharsWXT(pcCondition)
		return This.SplitAfterCharsWCSXT(pcCondition, TRUE)

		#< @FunctionFluentForms

		def SplitAfterCharsWXTQ(pcCondition)
			return This.SplitAfterCharsWXTQR(pcCondition, :stzList)

		def SplitAfterCharsWXTQR(pcCondition, pcReturnType)
			return This.SplitAfterCharsWCSXTQR(pcCondtion, TRUE, pcReturnType)

		#>

	def SplittedAfterCharsWXT(pcConditon)
		return This.SplitAfterCharsWXT(pcCondition)

	  #----------------------------------------------------------------#
	 #  NTH SUBSTRING AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#================================================================#
	# Utility function used to simplify code in stzListOfStrings

	def NthSubstringAfterSplittingStringUsing(n, cSep)
		#TODO: Remake it using FindNthSplitZZ(n)

		return This.Split(cSep)[n]

		def NthSplit(n, cSep)
			return This.NthSubstringAfterSplittingStringUsing(n, cSep)

	  #========================#
	 #   FINDING THE SPLITS   #
	#========================#

	def FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindSplitsAtCharsW(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereOtBeforeCharsWNamedParam()
				return This.FindSplitsBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereOrAfterCharsWNamedParam()
				return This.FindSplitsAfterCharsW(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereOrAtCharsWNamedParam()
				return This.FindSplitsAtSubStringsW(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereOrBeforeCharsWNamedParam()
				return This.FindSplitsBeforeSubStringsW(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereOrAfterCharsWNamedParam()
				return This.FindSplitsAfterSubStringsW(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharsWhereXTOrAtCharsWXTNamedParam()
				return This.FindSplitsAtCharsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
				return This.FindSplitsBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereXTOrAfterCharsWXTNamedParam()
				return This.FindSplitsAfterCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereXTOrAtCharsWXTNamedParam()
				return This.FindSplitsAtSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereXTOrBeforSubStringsWXTNamedParam()
				return This.FindSplitsBeforeSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereXTOrAfterSubstringsWXTNamedParam()
				return This.FindSplitsAfterSubStringsWXT(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXT(pSubStrOrPos)
		return This.FindSplitsCSXT(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsXTZ(pSubStrOrPos)
			return This.FindSplitsXT(pSubStrOrPos)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================#

	def FindSplitsAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplits(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAt(pSubStrOrPos)
		return This.FindSplitsAtCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtZ(pSubStrOrPos)
			return This.FindSplitsAtCS(pSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN POSITION   #
	#========================================#

	def FindSplitsAtPosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtPosition(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPosition(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtPositionZ(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtThisPositionZ(n)
			return This.FindSplitsAtPosition(n)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AT MANY POSITIONS   #
	#--------------------------------------#

	def FindSplitsAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		#--

		def FindSplitsAtPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtThesePositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING   #
	#=========================================#

	def FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#TODO
		# Add early check where needed in all the library
		# ~> better performance when the function is used in large loops

		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok

		ok

		anResult = This.FindManyCS( U( This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive) ), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSeparatedByCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedByCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubString(pcSubStr)
		return This.FindSplitsAtSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplits(pcSubStr)
			return This.FindSplitsCS(pcSubStr, TRUE)

		def FindSplitsAtThisSubString(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, TRUE)
		#--

		def FindSplitsAtSubStringZ(pcSubStr)
			return This.FindSplitsAtSubStringCS(pcSubStr, TRUE)

		def FindSplitsZ(pcSubStr)
			return This.FindSplitsCS(pcSubStr, TRUE)

		def FindSplitsAtThisSubStringZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, TRUE)

		#--

		def FindSeparatedBy(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedBySubString(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedByZ(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)

		def FindSeparatedBySubStringZs(pcSubStr)
			return This.FindSplitsAtSubString(pcSubStr)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT GIVEN SUBSTRINGS   #
	#----------------------------------------#

	def FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSeparatedBySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)


		def FindSeparatedBySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStrings(pacSubStr)
		return This.FindSplitsAtSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)
	
		def FindSplitsAtManySubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#--

		def FindSplitsAtSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtManySubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#--

		def FindSeparatedBySubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSeparatedBySubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#>

	  #---------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION   #
	#=======================================#

	def FindSplitsAtSectionCS(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSection(n1, n2)
		return This.FindSplitsAtSectionCS(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSection(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#--

		def FindSplitsAtSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		def FindSplitsAtThisSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#==========================================================#

	def FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIB(n1, n2)
		return This.FindSplitsAtSectionCSIB(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindSplitsAtSectionIBZ(n1, n2)
			return This.FindSplitsAtSectionIB(n1, n2)

		def FindSplitsAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS  #
	#====================================#

	def FindSplitsAtSectionsCS(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult
		
		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSections(paSections)
		return This.FindSplitsAtSectionsCS(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSections(paSections)
			return This.FindSplitsAtSections(paSections)

		#--

		def FindSplitsAtSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		def FindSplitsAtTheseSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS -- BOUNDS INCLUDED   #
	#========================================================#

	def FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
	
		ok

		acSplits = This.SplitsAtSectionsIB(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsIB(paSections)
		return This.FindSplitsAtSectionsCSIB(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsIB(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#--

		def FindSplitsAtSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		def FindSplitsAtTheseSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION OR SUBSTRING   #
	#=========================================================#

	def FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBefore(pSubStrOrPos)
		return This.FindSplitsBeforeCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeZ(pSubStrOrPos)
			return This.FindSplitsBefore(pSubStrOrPos)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#============================================#

	def FindSplitsBeforePositionCS(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsBeforePosition(n)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePosition(n)
		return This.FindSplitsBeforePositionCS(n, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPosition(n)
			return This.FindSplitsBeforePosition(n)

		#--

		def FindSplitsBeforePositionZ(n)
			return This.FindSplitsBeforePosition(n)

		def FindSplitsBeforeThisPositionZ(n)
			return This.FindSplitsBeforePosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#==========================================#

	def FindSplitsBeforePositionsCS(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositionsCS(anPos)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositions(anPos)
		return This.FindSplitsBeforePositionsCS(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#--

		def FindSplitsBeforePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeThesePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubString(pcSubStr)
		return This.FindSplitsBeforeSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubString(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		def FindSplitsBeforeThisSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)	

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStrings(pacSubStr)
		return This.FindSplitsBeforeSubStringsCS(pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION   #
	#-------------------------------------------#

	def FindSplitsBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSection(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#--

		def FindSplitsBeforeSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		def FindSplitsBeforeThisSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------#

	def FindSplitsBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIB(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#--

		def FindSplitsBeforeSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		def FindSplitsBeforeThisSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS   #
	#-----------------------------------------#

	def FindSplitsBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSections(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindSplitsBeforeSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeTheseSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionsIB(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#--

		def FindSplitsBeforeSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeTheseSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------#

	def FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindSplitsAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindSplitsAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfter(pSubStrOrPos)
		return This.FindSplitsAfterCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterZ(pSubStrOrPos)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPosition(n)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPosition(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterThisPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositions(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositions(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#--

		def FindSplitsAfterPositionsZ(anPos)
			return This.FindSplitsAfterPositions(anPos)

		def FindSplitsAfterThesePositionsZ(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositionsZ(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubString(pcSubStr)
		return This.FindSplitsAfterSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubString(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#--

		def FindSplitsAfterSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		def FindSplitsAfterThisSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStrings(pacSubStr)
		return This.FindSplitsAfterSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#--

		def FindSplitsAfterSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION  #
	#-----------------------------------------#

	def FindSplitsAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSection(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSection(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#--

		def FindSplitsAfterSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		def FindSplitsAfterThisSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------#

	def FindSplitsAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionIB(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIB(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		#--

		def FindSplitsAfterSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		def FindSplitsAfterThisSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS   #
	#----------------------------------------#

	def FindSplitsAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSections(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#--

		def FindSplitsAfterSectionsZ(paSections)
			return This.FindSplitsAfterSections(paSections)

		def FindSplitsAfterTheseSectionsZ(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------#

	def FindSplitsAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#--

		def FindSplitsAfterSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		def FindSplitsAfterTheseSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================#

	def FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok
		
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetween(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenZ(pBound1, pBound2)
			return This.FindSplitsBetween(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIB(pBound1, pBound2)
		return This.FindSplitsBetweenCSIB(pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenIBZ(pBound1, pBound2)
			return This.FindSplitsBetweenIB(pBound1, pBound2)

		#>

	  #----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS  #
	#----------------------------------------#

	def FindSplitsBetweenPositions(n1, n2)
		This.FindSplitsAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositions(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#--

		def FindSplitsBetweenPositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		def FindSplitsBetweenThesePositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#>
		
	  #------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------#

	def FindSplitsBetweenPositionsIB(n1, n2)
		This.FindSplitsAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#--

		def FindSplitsBetweenPositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		def FindSplitsBetweenThesePositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------#

	def FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		anResult = This.FindSplitsBetweenSections(aSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStrings(pacSubStr)
		return This.FindSplitsBetweenSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStrings(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		def FindSplitsBetweenTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#>

	  #---------------------------------#
	 #    FINDING SPLITS TO N PARTS    #
	#=================================#

	def FindSplitsToNParts(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsToNParts(n)
		return anResult

		def FindSplitsToNPartsZ(n)
			return This.FindSplitsToNParts(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNChars(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfExactlyNPositions(n)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNChars(n)
			return This.FindSplitsToPartsOfNChars(n)

		#--

		def FindSplitsToPartsOfNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		def FindSplitsToPartsOfExactlyNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF N CHARS -- EXTENDED   #
	#----------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsXT(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfNPositionsXT(n)

		return anResult

		def FindSplitsToPartsOfNCharsXTZ(n)
			return This.FindSplitsToPartsOfNCharsXT(n)

	  #-----------------------------------------#
	 #   FINSING SPLITS  AT A GIVEN CONDTION   #
	#=========================================#

	def FindSplitsAtWCS(pcCondition, pCaseSensitive)
		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		acSplits = This.SplitsAtCSQ(pcCondition, pCaseSensitive).ItemsWCS(pcCondition, pCaseSensitive)
		anResult  = This.FindTheseSubStringsCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAtCSW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtW(pcCondition)
		return This.FindSplitsAtWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtWZ(pcCondition)
			return This.FindSplitsAtW(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINSING SPLITS  AT A GIVEN CONDTION -- WXT  #
	#-----------------------------------------------#

	def FindSplitsAtWCSXT(pcCondition, pCaseSensitive)
		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		acSplits = This.SplitsAtCSQ(pcCondition, pCaseSensitive).ItemsWCSXT(pcCondition, pCaseSensitive)
		anResult  = This.FindTheseSubStringsCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWXTCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAtCSXTW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWXT(pcCondition)
		return This.FindSplitsAtWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtWXTZ(pcCondition)
			return This.FindSplitsAtWXT(pcCondition)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE CHARS BEFORE A GIVEN CONDTION   #
	#=========================================================#

	def FindSplitsBeforeCharsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeCharsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeCharsW(pcCondition)
		return This.FindSplitsBeforeCharsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWZ(pcCondition)
			return This.FindSplitsBeforeCharsW(pcCondition)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE CHARS VERIFYING A GIVEN CONDTION -- WXT  #
	#------------------------------------------------------------------#

	def FindSplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeCharsWXT(pcCondition)
		return This.FindSplitsBeforeCharsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeCharsWXTZ(pcCondition)
			return This.FindSplitsBeforeCharsWXT(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE SUBSTRINGS BEFORE A GIVEN CONDTION   #
	#==============================================================#

	def FindSplitsBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeSubStringsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsW(pcCondition)
		return This.FindSplitsBeforeSubStringsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWZ(pcCondition)
			return This.FindSplitsBeforeSubStringsW(pcCondition)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE SUBSTRINGS VERIFYING A GIVEN CONDTION -- WXT  #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsWXT(pcCondition)
		return This.FindSplitsBeforeSubStringsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeSubStringsWXTZ(pcCondition)
			return This.FindSplitsBeforeSubStringsWXT(pcCondition)

		#>


	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER CHARS AFTER A GIVEN CONDTION   #
	#=======================================================#

	def FindSplitsAfterCharsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterCharsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterCharsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterCharsW(pcCondition)
		return This.FindSplitsAfterCharsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWZ(pcCondition)
			return This.FindSplitsAfterCharsW(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING SPLITS AFTER CHARS VERIFYING A GIVEN CONDTION -- WXT  #
	#-----------------------------------------------------------------#

	def FindSplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterCharsWXT(pcCondition)
		return This.FindSplitsAfterCharsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterCharsWXTZ(pcCondition)
			return This.FindSplitsAfterCharsWXT(pcCondition)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER SUBSTRINGS AFTER A GIVEN CONDTION   #
	#============================================================#

	def FindSplitsAfterSubStringsWCS(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterSubStringsWCS(pcCondition, pCaseSensitive)
		anResult = This.FindManyCS(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWCSZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterSubStringsW(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsW(pcCondition)
		return This.FindSplitsAfterSubStringsW(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWZ(pcCondition)
			return This.FindSplitsAfterSubStringsW(pcCondition)

		#>

	  #----------------------------------------------------------------------#
	 #   FINDING SPLITS AFTER SUBSTRINGS VERIFYING A GIVEN CONDTION -- WXT  #
	#----------------------------------------------------------------------#

	def FindSplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.SplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)
		anResult = This.FindManyCSXT(acSubStr, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterSubStringsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsWXT(pcCondition)
		return This.FindSplitsAfterSubStringsWXT(pcCondition)

		#< @FunctionAlternativeForm

		def FindSplitsAfterSubStringsWXTZ(pcCondition)
			return This.FindSplitsAfterSubStringsWXT(pcCondition)

		#>

	  #==================================================#
	 #   FINDING THE SPLITS AS SECTIONS -- ZZ/EXTENDED  #
	#==================================================#

	def FindSplitsCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereNamedParam()
				return This.FindSplitsBeforeCharsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubStringsWhereNamedParam()
				return This.FindSplitsBeforeSubStringsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterCharsWhereNamedParam()
				return This.FindSplitsAfterCharsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterSubStringsWhereNamedParam()
				return This.FindSplitsAfterSubStringsWCSZZ(pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING WHERE -- XT

			but oParam.IsWhereXTOrAtXTWhereXTNamedParam() # TOD add it in stzList
				return This.FindSplitsAtWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTNamedParam()
				return This.FindSplitsBeforeCharsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubStringsWhereXTNamedParam()
				return This.FindSplitsBeforeSubStringsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterCharsWhereXTNamedParam()
				return This.FindSplitsAfterCharsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAfterSubStringsWhereXTNamedParam()
				return This.FindSplitsAfterSubStringsWCSXTZZ(pcSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAsSectionsCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXTZZ(pSubStrOrPos)
		return This.FindSplitsCSXTZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsAsSectionsXT(pSubStrOrPos)
			return This.FindSplitsAsSectionsXTZZ(pSubStrOrPos)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING OR POSITION  #
	#==================================================================#

	def FindSplitsAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtZZ(pSubStrOrPos)
		return This.FindSplitsAtCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSections(pSubStrOrPos)
			return This.FindSplitsAtCSZZ(pSubStr)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN POSITION   #
	#======================================================#

	def FindSplitsAtPositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAtPosition(n)
		aResult = This.FindManyAsSections(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAtPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionZZ(n)
		return This.FindSplitsAtPositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSections(n)
			return This.FindSplitsAtPositionZZ(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY POSITIONS   #
	#----------------------------------------------------#

	def FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.SplitsAtPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAtPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionsZZ(anPos)
		return This.FindSplitsAtPositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#--

		def FindSplitsAtPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtThesePositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING   #
	#=======================================================#

	def FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
	
		ok

		acSplits = U( This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive) )
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSeparatedByCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedByAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSeparatedBySubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringZZ(pcSubStr)
		return This.FindSplitsAtSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsZZ(pcSubStr)
			return This.FindSplitsCSZZ(pcSubStr, TRUE)

		def FindSplitsAtThisSubStringZZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCSZZ(pcSubStr, TRUE)
		#--

		def FindSplitsAtSubStringAsSectionsZZ(pcSubStr)
			return This.FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, TRUE)

		def FindSplitsAsSections(pcSubStr)
			return This.FindSplitsAsSectionsCS(pcSubStr, TRUE)

		def FindSplitsAtThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, TRUE)

		#--

		def FindSeparatedByZZ(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedByAsSections(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedBySubStringZZ(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		def FindSeparatedBySubStringAsSections(pcSubStr)
			return This.FindSplitsAtSubStringZZ(pcSubStr)

		#>


	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT GIVEN SUBSTRINGS   #
	#------------------------------------------------------#

	def FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT @IsListOfStrings(pacSubStr)
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSeparatedBySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSeparatedBySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringsZZ(pacSubStr)
		return This.FindSplitsAtSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)
	
		def FindSplitsAtManySubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAtSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtManySubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#--

		def FindSeparatedBySubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSeparatedBySubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION   #
	#=====================================================#

	def FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionZZ(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		def FindSplitsAtThisSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCSIB(n1, n2, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAtSectionIBZZ(n1, n2)

		def FindSplitsAtThisSectionAsSectionsIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY SECTIONS   #
	#---------------------------------------------------#

	def FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsZZ(paSections, pCaseSensitive)
		return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsZZ(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#--

		def FindSplitsAtSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		def FindSplitsAtTheseSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeZZ(pSubStrOrPos)
		return This.FindSplitsBeforeCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSections(pSubStrOrPos)
			return This.FindSplitsBeforeZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsBeforePositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsBeforePosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionZZ(n)
		return This.FindSplitsBeforePositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionZZ(n)
			return This.FindSplitsBeforePositionZZ(n)

		#--

		def FindSplitsBeforePositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		def FindSplitsBeforeThisPositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionsZZ(anPos)
		return This.FindSplitsBeforePositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#--

		def FindSplitsBeforePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeThesePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

		ok

		acSplits = This.SplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringZZ(pcSubStr)
		return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringZZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)

		def FindSplitsBeforeThisSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)	

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
	
		ok

		acSplits = This.SplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsZZ(pacSubStr)
		return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionZZ(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#----------------------------------------------------------------------------#

	def FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCsIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionIBZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIBZZ(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSZZ(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsZZ(paSections)
		return This.FindSplitsBeforeSectionsCSZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsZZ(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsAsSections(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------------------#

	def FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsBeforeSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsIBZZ(paSections)
		return This.FindSplitsBeforeSectionsCSIBZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN POSITION OR SUBSTRING  #
	#---------------------------------------------------------------------#

	def FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindSplitsAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterZZ(pSubStrOrPos)
		return This.FindSplitsAfterCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSections(pSubStrOrPos)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAfterPosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		def FindSplitsAfterThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionZZ(n)
		return This.FindSplitsAfterPositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionZZ(n)
			return This.FindSplitsAfterPositionZZ(n)

		def FindSplitsAfterThisPositionAsSections(n)
			return This.FindSplitsAfterPositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.plitsAfterPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAfterPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionsZZ(anPos)
		return This.FindSplitsAfterPositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsZZ(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsZZ(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#--

		def FindSplitsAfterPositionsAsSections(anPos)
			return This.FindSplitsAfterPositionsZZ(anPos)

		def FindSplitsAfterThesePositionsAsSections(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsAsSections(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		acSplits = This.SplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringZZ(pcSubStr)
		return This.FindSplitsAfterSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringZZ(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#--

		def FindSplitsAfterSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		def FindSplitsAfterThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsAsSectionsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsZZ(pacSubStr)
		return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAfterSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsAsSectionsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION   #
	#--------------------------------------------------------#

	def FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionZZ(n1, n2)
		return This.FindSplitsAfterSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionZZ(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionIBZZ(n1, n2)
		return This.FindSplitsAfterSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIBZZ(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS   #
	#------------------------------------------------------#

	def FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionsZZ(paSections)
		return This.FindSplitsAfterSectionsCSZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsZZ(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSections(paSections)
			return This.FindSplitsAfterSectionsZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSections(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------#

	def FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESNSITIVITY

	def FindSplitsAfterSectionsIBZZ(paSections)
		return This.FindSplitsAfterSectionsCSIBZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIBZZ(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#====================================================================#

	def FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
				StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
			ok
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = This.FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
			aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCS(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSections(pBound1, pBound2)
			return This.FindSplitsBetweenZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------------------#

	def FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
				StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
			ok
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
			aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIBZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsIB(pBound1, pBound2)
			return This.FindSplitsBetweenIBZZ(pBound1, pBound2)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS  #
	#------------------------------------------------------#

	def FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsZZ(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIBZZ(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO SUBSTRINGS  #
	#-------------------------------------------------------#

	def FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		acSplits = This.SplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStringsZZ(pacSubStr)
		return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		def FindSplitsBetweenTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) TO N PARTS    #
	#===============================================#

	def FindSplitsToNPartsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToNPartsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		def FindSplitsToNPartsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToNPartsCSZZ(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToNPartsZZ(n)
		return This.FindSplitsToNPartsCSZZ(n, TRUE)

		def FindSplitsToNPartsAsSections(n)
			return This.FindSplitsToNPartsZZ(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNCharsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNCharsCSZZ(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsToPartsOfNCharsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		def FindSplitsToPartsOfExactlyNCharsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToPartsOfNCharsZZ(n)
		return This.FindSplitsToPartsOfNCharsCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNCharsZZ(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#--

		def FindSplitsToPartsOfNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		def FindSplitsToPartsOfExactlyNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) TO PARTS OF N CHARS -- EXTENDED   #
	#------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsCSXTZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNCharsXTZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNCharsAsSectionsCSXT(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNCharsCSXTZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY()

	def FindSplitsToPartsOfNCharsXTZZ(n)
		return This.FindSplitsToPartsOfNCharsCSXTZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNCharsAsSectionsXT(n)
			return This.FindSplitsToPartsOfNCharsXTZZ(n)

		#>

	  #-------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDTION   #
	#=======================================================#

	def FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAtWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWZZ(pcCondition)
		return This.FindSplitsAtWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsW(pcCondition)
			return This.FindSplitsAtWZZ(pcCondition)

		#>

	  #------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDTION -- XT  #
	#------------------------------------------------------------#

	def FindSplitsAtWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAtWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWXTCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWXTZZ(pcCondition)
		return This.FindSplitsAtWCSXTZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsWXT(pcCondition)
			return This.FindSplitsAtWXTZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#===========================================================#

	def FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsBeforeWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWZZ(pcCondition)
		return This.FindSplitsBeforeWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsW(pcCondition)
			return This.FindSplitsBeforeWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT BEFORE GIVEN CONDTION -- XT  #
	#-----------------------------------------------------------------#

	def FindSplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWXTCS(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWXTZZ(pcCondition)
		return This.FindSplitsBeforeWCSXTZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWXT(pcCondition)
			return This.FindSplitsBeforeWXTZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AFTER A GIVEN CONDTION   #
	#==========================================================#

	def FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAfterWCSZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWZZ(pcCondition)
		return This.FindSplitsAfterWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsW(pcCondition)
			return This.FindSplitsAfterWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT AFTER GIVEN CONDTION -- XT  #
	#----------------------------------------------------------------#

	def FindSplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)

		acSplits = This.SplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWXTCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSXTZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWXTZZ(pcCondition)
		return This.FindSplitsAfterWCSXTZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWXT(pcCondition)
			return This.FindSplitsAfterWXTZZ(pcCondition)

		#>

	  #===========================#
	 #   FINDING THE NTH SPLIT   #
	#===========================#

	def FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNCharsCS(n, pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindNthSplitAtCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereOrBeforeCharsWNamedParam()
				return This.FindNthSplitBeforeCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereOrAfterCharsWNamedParam()
				return This.FindNthSplitAfterCharsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtSubstringsWhereOrAtCharsWNamedParam()
				return This.FindNthSplitAtSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereOrBeforeSubstringsWNamedParam()
				return This.FindNthSplitBeforeSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereOrAfterSubstringsWNamedParam()
				return This.FindNthSplitAfterSubstringsWCS(n, pcSubStrOrPos[2], pCaseSensitive)

			#--

			but oParam.IsAtCharsWhereXTOrAtCharsWXTNamedParam()
				return This.FindNthSplitAtCharsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
				return This.FindNthSplitBeforeCharsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeCharsWhereXTOrAfterCharsWXTNamedParam()
				return This.FindNthSplitAfterCharsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsAtSubstringsWhereXTOrAtCharsWXTNamedParam()
				return This.FindNthSplitAtSubstringsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereXTOrBeforeSubstringsWXTNamedParam()
				return This.FindNthSplitBeforeSubstringsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBeforeSubstringsWhereXTOrAfterSubstringsWXTNamedParam()
				return This.FindNthSplitAfterSubstringsWXTCS(n, pcSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXT(n, pSubStrOrPos)
		return This.FindNthSplitCSXT(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitXTZ(n, pSubStrOrPos)
			return This.FindNthSplitXT(n, pSubStrOrPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#=======================================================#

	def FindNthSplitAtCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[1], pSubStrOrPos[2], pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pSubStrOrPos[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pSubStrOrPos[2], pCaseSensitive)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCS(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAt(n, pSubStrOrPos)
		return This.FindNthSplitAtCS(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtZ(n, pSubStrOrPos)
			return This.FindNthSplitAtCS(n, pSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN POSITION   #
	#===========================================#

	def FindNthSplitAtPosition(n, nPos) #NOTE: Case sensitivty has no added value here,
					    # since the split is based on position
					    # and there is no use of ...CS() functions
					    # in the implementatin
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isNumber(n, nPos) and (n = 1 or n = 2) )
				StzRaise("Incorrect pram type! n must be a number equal to 1 or 2.")
				# Because after splitting the string at a given position, there will
				# be only two splits, right?
			ok

		ok

		nResult = 0

		if n = 1
			nResult = 1

		but n = 2
			nResult + (nPos + 1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPosition(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtThisPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY POSITIONS   #
	#-----------------------------------------#

	def FindNthSplitAtPositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtPositions(anPos)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nResult += ( nLen + 1 )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#--

		def FindNthSplitAtPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtThesePositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING   #
	#============================================#

	def FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcsubStr must be a string.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()
		acSplits = This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubString(n, pcSubStr)
		return This.FindNthSplitAtSubStringCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplit(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, TRUE)

		def FindNthSplitAtThisSubString(n, pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, TRUE)
		#--

		def FindNthSplitAtSubStringZ(n, pcSubStr)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, TRUE)

		def FindNthSplitZ(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, TRUE)

		def FindNthSplitAtThisSubStringZ(pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, TRUE)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT GIVEN SUBSTRINGS   #
	#-------------------------------------------#

	def FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT (isList(pacSubStr) and @IsListOfStrings(pacSubStr))
				StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtSubStringCS(pcSubStr, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfChars()
			nLenSubStr = StzStringQ(pacSubStr[i]).NumberOfChars()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult


		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStrings(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCS(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)
	
		def FindNthSplitAtManySubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#>

	  #------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION   #
	#==========================================#

	def FindNthSplitAtSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT @AllAreNumbers([n, n1, n2 ])
				StzRaise("Incorrect params type! n, n1 and n2 must all be numbers.")
			ok

			if NOT ( n = 1 or n = 2 )
				StzRaise("Incorrect values ! n must be equal to 1 or 2.")
				# Since the split make two parts only.
			ok
		ok

		if n = 1
			return 1
		
		but n = 2
			return n2 + 1
		ok
		
		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSection(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#--

		def FindNthSplitAtSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		def FindNthSplitAtThisSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------#

	def FindNthSplitAtSectionIB(n, n1, n2)
		nResult = This.FindNthSplitAtSection(n, n1, n2)
		if nResult > 1
			nResult - (n2 - n1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIB(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#--

		def FindNthSplitAtSectionIBZ(n, n1, n2)
			return This.FindNthSplitAtSectionIB(n, n1, n2)

		def FindNthSplitAtThisSectionIBZ(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#>

	  #----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY SECTIONS   #
	#----------------------------------------#

	def FindNthSplitAtSections(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		StzRaise("Feature not implemented yet!")

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSections(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#--

		def FindNthSplitAtSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		def FindNthSplitAtTheseSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------#

	def FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositions(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSection(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSections(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePosition(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositions(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSection(n, pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSections(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBefore(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCS(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeZ(n, pSubStrOrPos)
			return This.FindNthSplitBefore(n, pSubStrOrPos)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitBeforePosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePosition(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPosition(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#--

		def FindNthSplitBeforePositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		def FindNthSplitBeforeThisPositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitBeforePositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#--

		def FindNthSplitBeforePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeThesePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubString(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubString(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)	

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStrings(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION   #
	#----------------------------------------------#

	def FindNthSplitBeforeSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSection(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSection(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		def FindNthSplitBeforeThisSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-----------------------------------------------------------------#

	def FindNthSplitBeforeSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIB(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		def FindNthSplitBeforeThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SECTIONS   #
	#--------------------------------------------#

	def FindNthSplitBeforeSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSections(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSections(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySections(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#--

		def FindNthSplitBeforeSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeTheseSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySectionsZ(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINING NTH SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIB(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIB(paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#--

		def FindNthSplitBeforeSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#----------------------------------------------------------#

	def FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPosition(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSection(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSections(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindNthSplitAfterSubStrings(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSections(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfter(n, pSubStrOrPos)
		return This.FindNthSplitAfterCS(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterZ(n, pSubStrOrPos)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitAfterPosition(n, nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPosition(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterThisPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitAfterPositions(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositions(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositions(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#--

		def FindNthSplitAfterPositionsZ(n, anPos)
			return This.FindNthSplitAfterPositions(n, anPos)

		def FindNthSplitAfterThesePositionsZ(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositionsZ(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitAfterSubStringCS(n, cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubString(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubString(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		def FindNthSplitAfterThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStrings(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION  #
	#--------------------------------------------#

	def FindNthSplitAfterSection(n, n1, n2)

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSection(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSection(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#--

		def FindNthSplitAfterSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		def FindNthSplitAfterThisSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindNthSplitAfterSectionIB(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIB(n, n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		#--

		def FindNthSplitAfterSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		def FindNthSplitAfterThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)


		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS   #
	#-------------------------------------------#

	def FindNthSplitAfterSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSections(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#--

		def FindNthSplitAfterSectionsZ(n, paSections)
			return This.FindNthSplitAfterSections(n, paSections)

		def FindNthSplitAfterTheseSectionsZ(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterSectionsIB(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#--

		def FindNthSplitAfterSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		def FindNthSplitAfterTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=========================================================#

	def FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetween(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetween(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenZ(n, pBound1, pBound2)
			return This.FindNthSplitBetween(n, pBound1, pBound2)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIB(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSIBZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIB(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenIBZ(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIB(n, pBound1, pBound2)

		#>

	  #-------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS  #
	#-------------------------------------------#

	def FindNthSplitBetweenPositions(n, n1, n2)
		This.FindNthSplitAtSection(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositions(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		def FindNthSplitBetweenThesePositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#>
		
	  #---------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIB(n, n1, n2)
		This.FindNthSplitAtSectionIB(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		def FindNthSplitBetweenThesePositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO SUBSTRINGS  #
	#--------------------------------------------#

	def FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindNthSplitBetweenSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStrings(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#>

	  #------------------------------------#
	 #    FINDING NTH SPLIT TO N PARTS    #
	#====================================#

	def FindNthSplitToNParts(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNParts(n, nPos)
		return nResult

		def FindNthSplitToNPartsZ(n, nPos)
			return This.FindNthSplitToNParts(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNChars(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositions(n, nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNChars(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF N CHARS -- EXTENDED   #
	#-------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsXT(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsXT(n, nPos)

		return nResult

		def FindNthSplitToPartsOfNCharsXTZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsXT(n, nPos)

	  #====================================================#
	 #   FINDING THE NTH SPLIT AS SECTION -- ZZ/EXTENDED  #
	#====================================================#

	def FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsZZ(n, pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNCharsZZ(n, pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionCSXT(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXTZZ(n, pSubStrOrPos)
		return This.FindNthSplitCSXTXT(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionXT(n, pSubStrOrPos)
			return This.FindNthSplitXTZZ(n, pSubStrOrPos)

		#>

	  #--------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================================#

	def FindNthSplitAtCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAsSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCSZZ(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtZZ(n, pSubStrOrPos)
		return This.FindNthSplitAtCSZZ(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAtCSZZ(n, pSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#========================================================#

	def FindNthSplitAtPositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPositionAsSection(n, nPos)
			return This.FindNthSplitAtPositionZZ(n, nPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-----------------------------------------------------#

	def FindNthSplitAtPositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#--

		def FindNthSplitAtPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#========================================================#

	def FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringZZ(pcSubStr)
		return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, TRUE)

		def FindNthSplitAtThisSubStringZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, TRUE)
		#--

		def FindNthSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, TRUE)

		def FindNthSplitAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, TRUE)

		def FindNthSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, TRUE)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#--------------------------------------------------------#

	def FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)
	
		def FindNthSplitAtManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtManySubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=======================================================#

	def FindNthSplitAtSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindNthSplitAtSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIBZZ(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSectionIB(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-----------------------------------------------------#

	def FindNthSplitAtSectionsZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSectionsZZ(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#--

		def FindNthSplitAtSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		def FindNthSplitAtTheseSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING NTH SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------------------#

	def FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeZZ(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSection(n, pSubStrOrPos)
			return This.FindNthSplitBeforeZZ(n, pSubStrOrPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitBeforePositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPositionZZ(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#--

		def FindNthSplitBeforePositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		def FindNthSplitBeforeThisPositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitBeforePositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#--

		def FindNthSplitBeforePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeThesePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringZZ(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)	

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindNthSplitBeforeSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsZZ(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#--

		def FindNthSplitBeforeSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSection(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIBZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindNthSplitBeforeSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------------------#

	def FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindNthSplitAfterSubStringsZZ(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterZZ(n, pSubStrOrPos)
		return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterPositionZZ(n, Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPositionZZ(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		def FindNthSplitAfterThisPositionAsSection(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitAfterPositionsZZ(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositionsZZ(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsZZ(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#--

		def FindNthSplitAfterPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterPositionsZZ(anPos)

		def FindNthSplitAfterThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringZZ(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		def FindNthSplitAfterThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsAsSectionCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsAsSectionZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#----------------------------------------------------------#

	def FindNthSplitAfterSectionZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindNthSplitAfterSectionIBZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIBZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n1, n2)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#--------------------------------------------------------#

	def FindNthSplitAfterSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsZZ(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterSectionsZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterSectionsIBZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================================#

	def FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCS(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSection(n, pBound1, pBound2)
			return This.FindNthSplitBetweenZZ(n, pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCSIB(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIBZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionIB(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#--------------------------------------------------------#

	def FindNthSplitBetweenPositionsZZ(n, n1, n2)
		This.FindNthSplitAtSectionZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#>
		
	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIBZZ(n, n1, n2)
		This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIBZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindNthSplitBetweenSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) TO N PARTS    #
	#=================================================#

	def FindNthSplitToNPartsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNPartsZZ(n, nPos)
		return aResult

		def FindNthSplitToNPartsAsSection(n, nPos)
			return This.FindNthSplitToNPartsZZ(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNCharsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositionsZZ(n, nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNCharsZZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsIBZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsIBZZ(n, nPos)

		return aResult

	  #============================#
	 #   FINDING THE LAST SPLIT   #
	#============================#

	def FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharsWhereOrAtCharsWNamedParam()
				return This.FindLastSplitAtCharsW(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereOrBeforeCharsWNamedParam()
				return This.FindLastSplitBeforeCharsW(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereOrAfterCharsWNamedParam()
				return This.FindLastSplitAfterCharsW(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereOrAtSubStringsWNamedParam()
				return This.FindLastSplitAtSubStringsW(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereOrBeforeSubStringsWNamedParam()
				return This.FindLastSplitBeforeSubStringsW(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereOrAfterSubStringsWNamedParam()
				return This.FindLastSplitAfterSubStringsW(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharsWhereXTOrAtCharsWXTNamedParam()
				return This.FindLastSplitAtCharsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeCharsWhereXTOrBeforeCharsWXTNamedParam()
				return This.FindLastSplitBeforeCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterCharsWhereXTOrAfterCharsWXTNamedParam()
				return This.FindLastSplitAfterCharsWXT(pcSubStrOrPos[2])

			but oParam.IsAtSubStringsWhereXTOrAtSubStringsWXTNamedParam()
				return This.FindLastSplitAtSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringsWhereXTOrBeforeSubStringsWXTNamedParam()
				return This.FindLastSplitBeforeSubStringsWXT(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringsWhereXTOrAfterSubStringsWXTNamedParam()
				return This.FindLastSplitAfterSubStringsWXT(pcSubStrOrPos[2])
			ok

		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXT(pSubStrOrPos)
		return This.FindLastSplitCSXT(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitXTZ(pSubStrOrPos)
			return This.FindLastSplitXT(pSubStrOrPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#========================================================#

	def FindLastSplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplit(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAt(pSubStrOrPos)
		return This.FindLastSplitAtCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtZ(pSubStrOrPos)
			return This.FindLastSplitAtCS(pSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN POSITION   #
	#============================================#

	def FindLastSplitAtPosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(nPos)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPosition(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtThisPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY POSITIONS   #
	#------------------------------------------#

	def FindLastSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#--

		def FindLastSplitAtPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtThesePositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING   #
	#=============================================#

	def FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubString(pcSubStr)
		return This.FindLastSplitAtSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplit(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, TRUE)

		def FindLastSplitAtThisSubString(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, TRUE)
		#--

		def FindLastSplitAtSubStringZ(pcSubStr)
			return This.FindLastSplitAtSubStringCS(pcSubStr, TRUE)

		def FindLastSplitZ(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, TRUE)

		def FindLastSplitAtThisSubStringZ(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, TRUE)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT GIVEN SUBSTRINGS   #
	#--------------------------------------------#

	def FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStrings(pacSubStr)
		return This.FindLastSplitAtSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)
	
		def FindLastSplitAtManySubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#--

		def FindLastSplitAtSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtManySubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION   #
	#===========================================#

	def FindLastSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSection(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#--

		def FindLastSplitAtSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		def FindLastSplitAtThisSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindLastSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindLastSplitAtSectionIBZ(n1, n2)
			return This.FindLastSplitAtSectionIB(n1, n2)

		def FindLastSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS   #
	#-----------------------------------------#

	def FindLastSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSections(paSections)
			return This.FindLastSplitAtSections(paSections)

		#--

		def FindLastSplitAtSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		def FindLastSplitAtTheseSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsIB(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#--

		def FindLastSplitAtSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		def FindLastSplitAtTheseSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBefore(pSubStrOrPos)
		return This.FindLastSplitBeforeCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeZ(pSubStrOrPos)
			return This.FindLastSplitBefore(pSubStrOrPos)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPosition(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#--

		def FindLastSplitBeforePositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		def FindLastSplitBeforeThisPositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#--

		def FindLastSplitBeforePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeThesePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubString(pcSubStr)
		return This.FindLastSplitBeforeSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubString(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		def FindLastSplitBeforeThisSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)	

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStrings(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCS(pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSection(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#--

		def FindLastSplitBeforeSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		def FindLastSplitBeforeThisSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIB(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#--

		def FindLastSplitBeforeSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		def FindLastSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS   #
	#---------------------------------------------#

	def FindLastSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSections(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindLastSplitBeforeSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeTheseSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#--

		def FindLastSplitBeforeSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------#

	def FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindLastSplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindLastSplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfter(pSubStrOrPos)
		return This.FindLastSplitAfterCS(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterZ(pSubStrOrPos)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPosition(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterThisPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositions(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositions(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#--

		def FindLastSplitAfterPositionsZ(anPos)
			return This.FindLastSplitAfterPositions(anPos)

		def FindLastSplitAfterThesePositionsZ(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositionsZ(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitAfterSubStringCS(cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubString(pcSubStr)
		return This.FindLastSplitAfterSubStringCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubString(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#--

		def FindLastSplitAfterSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		def FindLastSplitAfterThisSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStrings(pacSubStr)
		return This.FindLastSplitAfterSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION  #
	#---------------------------------------------#

	def FindLastSplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSection(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#--

		def FindLastSplitAfterSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		def FindLastSplitAfterThisSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindLastSplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		#--

		def FindLastSplitAfterSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		def FindLastSplitAfterThisSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)


		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS   #
	#--------------------------------------------#

	def FindLastSplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSections(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#--

		def FindLastSplitAfterSectionsZ(paSections)
			return This.FindLastSplitAfterSections(paSections)

		def FindLastSplitAfterTheseSectionsZ(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindLastSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#--

		def FindLastSplitAfterSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		def FindLastSplitAfterTheseSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#==========================================================#

	def FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetween(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenZ(pBound1, pBound2)
			return This.FindLastSplitBetween(pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIB(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIB(pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenIBZ(pBound1, pBound2)
			return This.FindLastSplitBetweenIB(pBound1, pBound2)

		#>

	  #--------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS  #
	#--------------------------------------------#

	def FindLastSplitBetweenPositions(n1, n2)
		This.FindLastSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositions(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#--

		def FindLastSplitBetweenPositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		def FindLastSplitBetweenThesePositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#>
		
	  #----------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIB(n1, n2)
		This.FindLastSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#--

		def FindLastSplitBetweenPositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		def FindLastSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------#

	def FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStrings(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCS(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStrings(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#>

	  #-------------------------------------#
	 #    FINDING LAST SPLIT TO N PARTS    #
	#=====================================#

	def FindLastSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNParts(nPos)
		return nResult

		def FindLastSplitToNPartsZ(nPos)
			return This.FindLastSplitToNParts(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNChars(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNChars(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#--

		def FindLastSplitToPartsOfNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		def FindLastSplitToPartsOfExactlyNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindLastSplitToPartsOfNCharsXTZ(nPos)
			return This.FindLastSplitToPartsOfNCharsXT(nPos)

	  #------------------------------------------------#
	 #   FINSING LAST SPLIT BEFORE A GIVEN CONDTION   #
	#================================================#

	def FindLastSplitBeforeWCS(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCS(pcCondition, pCaseSensitive)
		nResult = This.FindLastCS(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitBeforeWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeW(pcCondition)
		return This.FindLastSplitBeforeWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWZ(pcCondition)
			return This.FindLastSplitBeforeW(pcCondition)

		#>

	  #------------------------------------------------------#
	 #   FINSING LAST SPLIT BEFORE A GIVEN CONDTION -- WXT  #
	#------------------------------------------------------#

	def FindLastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		nResult = This.FindLastCSXT(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitBeforeWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWXT(pcCondition)
		return This.FindLastSplitBeforeWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWXTZ(pcCondition)
			return This.FindLastSplitBeforeWXT(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINSING LAST SPLIT AFTER A GIVEN CONDTION   #
	#===============================================#

	def FindLastSplitAfterWCS(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCS(pcCondition, pCaseSensitive)
		nResult = This.FindLastCS(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWCSZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitAfterWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterW(pcCondition)
		return This.FindLastSplitAfterWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWZ(pcCondition)
			return This.FindLastSplitAfterW(pcCondition)

		#>

	  #-----------------------------------------------------#
	 #   FINSING LAST SPLIT AFTER A GIVEN CONDTION -- WXT  #
	#-----------------------------------------------------#

	def FindLastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		nResult = This.FindLastCSXT(acSubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWCSXTZ(pcCondition, pCaseSensitive)
			return This.FindLastSplitAfterWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWXT(pcCondition)
		return This.FindLastSplitAfterWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWXTZ(pcCondition)
			return This.FindLastSplitAfterWXT(pcCondition)

		#>

	  #======================================================#
	 #   FINDING THE FIRST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#======================================================#

	def FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindFirstSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindFirstSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindFirstSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindFirstSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindFirstSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindFirstSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindFirstSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharWhereOrAtCharWhereNamedParam()
				return This.FindFirstSplitAtCharWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereOrBeforeCharWNamedParam()
				return This.FindFirstSplitBeforeCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereOrAfterCharWNamedParam()
				return This.FindFirstSplitAfterCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereOrAtSubStringWhereNamedParam()
				return This.FindFirstSplitAtSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereOrBeforeSubStringWNamedParam()
				return This.FindFirstSplitBeforeSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereOrAfterSubStringWNamedParam()
				return This.FindFirstSplitAfterSubStringWZZ(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharWhereXTOrAtCharWherextNamedParam()
				return This.FindFirstSplitAtCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereXTOrBeforeCharXTWNamedParam()
				return This.FindFirstSplitBeforeCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereXTOrAfterCharWXTNamedParam()
				return This.FindFirstSplitAfterCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereXTOrAtSubStringWhereXTNamedParam()
				return This.FindFirstSplitAtSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereXTOrBeforeSubStringWXTNamedParam()
				return This.FindFirstSplitBeforeSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereXTOrAfterSubStringWXTNamedParam()
				return This.FindFirstSplitAfterSubStringWXTZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitXTZZ(pSubStrOrPos)
		return This.FindFirstSplitCSXTZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionXT(pSubStrOrPos)
			return This.FindFirstSplitXTZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#======================================================================#

	def FindFirstSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtZZ(pSubStrOrPos)
		return This.FindFirstSplitAtCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSection(pSubStrOrPos)
			return This.FindFirstSplitAtCSZZ(pSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#==========================================================#

	def FindFirstSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisPositionAsSection(nPos)
			return This.FindFirstSplitAtPositionZZ(nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-------------------------------------------------------#

	def FindFirstSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtThesePositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#--

		def FindFirstSplitAtPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtThesePositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#==========================================================#

	def FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringZZ(pcSubStr)
		return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindFirstSplitAtThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, TRUE)
		#--

		def FindFirstSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindFirstSplitAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindFirstSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, TRUE)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)
	
		def FindFirstSplitAtManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAtSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=========================================================#

	def FindFirstSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionZZ(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAtSectionIBZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindFirstSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSectionsZZ(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#--

		def FindFirstSplitAtSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		def FindFirstSplitAtTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING FIRST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#--------------------------------------------------------------------------#

	def FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeZZ(pSubStrOrPos)
		return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSection(pSubStrOrPos)
			return This.FindFirstSplitBeforeZZ(pSubStrOrPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThisPositionZZ(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#--

		def FindFirstSplitBeforePositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		def FindFirstSplitBeforeThisPositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThesePositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#--

		def FindFirstSplitBeforePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeThesePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringZZ(pcSubStr)
		return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)

		#--

		def FindFirstSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)

		def FindFirstSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#-----------------------------------------------------------#

	def FindFirstSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsZZ(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------------------------#

	def FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindFirstSplitAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterZZ(pSubStrOrPos)
		return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSection(pSubStrOrPos)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisPositionZZ(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		def FindFirstSplitAfterThisPositionAsSection(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThesePositionsZZ(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsZZ(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#--

		def FindFirstSplitAfterPositionsAsSection(anPos)
			return This.FindFirstSplitAfterPositionsZZ(anPos)

		def FindFirstSplitAfterThesePositionsAsSection(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsAsSection(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringZZ(pcSubStr)
		return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindFirstSplitAfterSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		def FindFirstSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionZZ(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindFirstSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsZZ(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSection(paSections)
			return This.FindFirstSplitAfterSectionsZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#========================================================================#

	def FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSection(pBound1, pBound2)
			return This.FindFirstSplitBetweenZZ(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------#

	def FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#----------------------------------------------------------#

	def FindFirstSplitBetweenPositionsZZ(n1, n2)
		This.FindFirstSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#

	def FindFirstSplitBetweenPositionsIBZZ(n1, n2)
		This.FindFirstSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------------------------#

	def FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindFirstSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		def FindFirstSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTION) TO N PARTS    #
	#===================================================#

	def FindFirstSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitToNPartsZZ(nPos)
		return aResult

		def FindFirstSplitToNPartsAsSection(nPos)
			return This.FindFirstSplitToNPartsZZ(nPos)

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindFirstSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindFirstSplitToPartsOfNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		def FindFirstSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#------------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindFirstSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult


	  #----------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) AT A GIVEN CONDTION -- ZZ   #
	#================================================================#

	def FindFirstSplitAtWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAtWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtWZZ(pcCondition)
		return This.FindFirstSplitAtWCSZZ(pcCondition, TRUE)

	  #------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN CONDTION -- WXTZZ  #
	#------------------------------------------------------------------#

	def FindFirstSplitAtWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAtWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtWXTZZ(pcCondition)
		return This.FindFirstSplitAtWCSXTZZ(pcCondition, TRUE)

	  #-------------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION -- ZZ  #
	#===================================================================#

	def FindFirstSplitBeforeWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitBeforeWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeWZZ(pcCondition)
		return This.FindFirstSplitBeforeWCSZZ(pcCondition, TRUE)

	  #----------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION -- WXTZZ  #
	#----------------------------------------------------------------------#

	def FindFirstSplitBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeWXTZZ(pcCondition)
		return This.FindFirstSplitBeforeWCSXTZZ(pcCondition, TRUE)

	  #------------------------------------------------------------------#
	 #   FINSING FIRST SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- ZZ  #
	#==================================================================#

	def FindFirstSplitAfterWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAfterWCS(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterWZZ(pcCondition)
		return This.FindFirstSplitAfterWCSZZ(pcCondition, TRUE)

	  #---------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- WXTZZ  #
	#---------------------------------------------------------------------#

	def FindFirstSplitAfterWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.FirstSplitAfterWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindFirstCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterWXTZZ(pcCondition)
		return This.FindFirstSplitAfterWCSXTZZ(pcCondition, TRUE)

	  #=====================================================#
	 #   FINDING THE LAST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#=====================================================#

	def FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsAtCharWhereOrAtCharWhereNamedParam()
				return This.FindLastSplitAtCharWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereOrBeforeCharWNamedParam()
				return This.FindLastSplitBeforeCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereOrAfterCharWNamedParam()
				return This.FindLastSplitAfterCharWZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereOrAtSubStringWhereNamedParam()
				return This.FindLastSplitAtSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereOrBeforeSubStringWNamedParam()
				return This.FindLastSplitBeforeSubStringWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereOrAfterSubStringWNamedParam()
				return This.FindLastSplitAfterSubStringWZZ(pcSubStrOrPos[2])

			#--

			but oParam.IsAtCharWhereXTOrAtCharWherextNamedParam()
				return This.FindLastSplitAtCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeCharWhereXTOrBeforeCharXTWNamedParam()
				return This.FindLastSplitBeforeCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterCharWhereXTOrAfterCharWXTNamedParam()
				return This.FindLastSplitAfterCharWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAtSubStringWhereXTOrAtSubStringWhereXTNamedParam()
				return This.FindLastSplitAtSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeSubStringWhereXTOrBeforeSubStringWXTNamedParam()
				return This.FindLastSplitBeforeSubStringWXTZZ(pcSubStrOrPos[2])

			but oParam.IsAfterSubStringWhereXTOrAfterSubStringWXTNamedParam()
				return This.FindLastSplitAfterSubStringWXTZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXTZZ(pSubStrOrPos)
		return This.FindLastSplitCSXTZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionXT(pSubStrOrPos)
			return This.FindLastSplitXTZZ(pSubStrOrPos)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#=====================================================================#

	def FindLastSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtZZ(pSubStrOrPos)
		return This.FindLastSplitAtCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSection(pSubStrOrPos)
			return This.FindLastSplitAtCSZZ(pSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#=========================================================#

	def FindLastSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPositionAsSection(nPos)
			return This.FindLastSplitAtPositionZZ(nPos)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#------------------------------------------------------#

	def FindLastSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#--

		def FindLastSplitAtPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtThesePositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#=========================================================#

	def FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringZZ(pcSubStr)
		return This.FindLastSplitAtSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindLastSplitAtThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, TRUE)
		#--

		def FindLastSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindLastSplitAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, TRUE)

		def FindLastSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, TRUE)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringsZZ(pacSubStr)
		return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)
	
		def FindLastSplitAtManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAtSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#========================================================#

	def FindLastSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionZZ(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindLastSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAtSectionIBZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#------------------------------------------------------#

	def FindLastSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsZZ(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#--

		def FindLastSplitAtSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		def FindLastSplitAtTheseSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING LAST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------------------#

	def FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeZZ(pSubStrOrPos)
		return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSection(pSubStrOrPos)
			return This.FindLastSplitBeforeZZ(pSubStrOrPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPositionZZ(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#--

		def FindLastSplitBeforePositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		def FindLastSplitBeforeThisPositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#--

		def FindLastSplitBeforePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeThesePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringZZ(pcSubStr)
		return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)

		def FindLastSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionZZ(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#>

	  #-------------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindLastSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsZZ(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeManySectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#------------------------------------------------------------------------#

	def FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindLastSplitAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterZZ(pSubStrOrPos)
		return This.FindLastSplitAfterCSZZ(pSubStrOrPos, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSection(pSubStrOrPos)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPositionZZ(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		def FindLastSplitAfterThisPositionAsSection(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositionsZZ(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsZZ(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#--

		def FindLastSplitAfterPositionsAsSection(anPos)
			return This.FindLastSplitAfterPositionsZZ(anPos)

		def FindLastSplitAfterThesePositionsAsSection(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsAsSection(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringZZ(pcSubStr)
		return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindLastSplitAfterSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		def FindLastSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringsZZ(pacSubStr)
		return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionZZ(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindLastSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsZZ(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSection(paSections)
			return This.FindLastSplitAfterSectionsZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSection(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=======================================================================#

	def FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSection(pBound1, pBound2)
			return This.FindLastSplitBetweenZZ(pBound1, pBound2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindLastSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#---------------------------------------------------------#

	def FindLastSplitBetweenPositionsZZ(n1, n2)
		This.FindLastSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIBZZ(n1, n2)
		This.FindLastSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindLastSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) TO N PARTS    #
	#==================================================#

	def FindLastSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNPartsZZ(nPos)
		return aResult

		def FindLastSplitToNPartsAsSection(nPos)
			return This.FindLastSplitToNPartsZZ(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindLastSplitToPartsOfNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		def FindLastSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#-----------------------------------------------------------------------------#
	# The remaining part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult


	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDTION -- ZZ  #
	#==================================================================#

	def FindLastSplitAtWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAtWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtWZZ(pcCondition)
		return This.FindLastSplitAtWCSZZ(pcCondition, TRUE)

	  #-----------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN CONDTION -- WXTZZ  #
	#-----------------------------------------------------------------#

	def FindLastSplitAtWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAtWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtWXTZZ(pcCondition)
		return This.FindLastSplitAtWCSXTZZ(pcCondition, TRUE)

	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION -- ZZ  #
	#==================================================================#

	def FindLastSplitBeforeWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWZZ(pcCondition)
		return This.FindLastSplitBeforeWCSZZ(pcCondition, TRUE)

	  #---------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION -- WXTZZ  #
	#---------------------------------------------------------------------#

	def FindLastSplitBeforeWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitBeforeWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeWXTZZ(pcCondition)
		return This.FindLastSplitBeforeWCSXTZZ(pcCondition, TRUE)

	  #------------------------------------------------------------------#
	 #   FINSING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- ZZ   #
	#==================================================================#

	def FindLastSplitAfterWCSZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCS(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWZZ(pcCondition)
		return This.FindLastSplitAfterWCSZZ(pcCondition, TRUE)

	  #--------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- WXTZZ  #
	#--------------------------------------------------------------------#

	def FindLastSplitAfterWCSXTZZ(pcCondition, pCaseSensitive)
		acSubStr = This.LastSplitAfterWCSXT(pcCondition, pCaseSensitive)
		aResult = This.FindLastCSZZ(acSubStr, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterWXTZZ(pcCondition)
		return This.FindLastSplitAfterWCSXTZZ(pcCondition, TRUE)

	  #====================================#
	 #  GETTING THE PARTS OF THE STRING   #
	#====================================#

	def PartsCS(pCaseSensitive)

		# Early Check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ This.Content() ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars of the string and
		# preparing it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		acResult = []

		for i = 2 to nLen

			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
			else
				acResult + cPart
				cPart = acContent[i]
			ok
	
		next
	
		acResult + cPart

		return acResult

		#< @FunctionFluentForms

		def PartsCSQ(pCaseSensitive)
			return This.PartsCSQR(pCaseSensitive, :stzList)

		def PartsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsCS(pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionCS(pCaseSensitive) # A verb: to partition
			return This.PartsCS(pCaseSensitive)

			def PartitionCSQ(pCaseSensitive)
				return This.PartitionCSQR(pCaseSensitive, :stzList)

			def PartitionCSQR(pCaseSensitive, pcReturnType)
				return This.PartsCSQR(pCaseSensitive, pcReturnType)

		def PartionedCS(pCaseSensitive)
			return This.PartsCS(pCaseSensitive)

			def PartionedCSQ(pCaseSensitive)
				return This.PartionedCSQR(pCaseSensitive, :stzList)

			def PartionedCSQR(pCaseSensitive, pcReturnType)
				return This.PartsCSQR(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def Parts()
		return This.PartsCS(TRUE)

		#< @FunctionFluentForms

		def PartsQ()
			return This.PartsQR(:stzList)

		def PartsQR(pcReturnType)
			return This.PartsCSQR(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def Partition() # A verb: to partition
			return This.Parts()

			def PartitionQ()
				return This.PartitionQR(:stzList)

			def PartitionQR(pcReturnType)
				return This.PartsQR(pcReturnType)

		def Partioned()
			return This.Parts()

			def PartionedQ()
				return This.PartionedQR(:stzList)

			def PartionedQR(pcReturnType)
				return This.PartsQR(pcReturnType)

		#>

	  #----------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE STRING  #
	#----------------------------------------------------#

	def FindPartsCS(pCaseSensitive)

		# Eraly check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ 1 ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# them for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		anResult = [ 1 ]

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]
				anResult + i
			ok
	
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindPartsCSZ(pCaseSensitive)
			return This.FindPartsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindParts()
		return This.FindPartsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindPartsZ()
			return This.FindParts()

		#>

	  #----------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE STRING  #
	#----------------------------------------------------#

	def FindPartsAsSectionsCS(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ This.Content() ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		aResult = [ [ 1 ] ]
		nLenResult = 1

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]

				aResult[nLenResult] + (i-1)
				aResult + [ i ]
				nLenResult++
			ok
	
		next

		aResult[ len(aResult) ] + nLen
		return aResult

		#< @FunctionAlternativeForms

		def FindPartAsSectionsCSZ(pCaseSensitive)
			return This.FindPartsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindPartsAsSections()
		return This.FindPartsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindPartAsSectionsZ()
			return This.FindPartsAsSections()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def PartsCSZ(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ This.Content(), [ 1, nLen ] ] ]
		ok

		# Getting the boolean from pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing it
		# for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
				n++
			else
				aResult + [ cPart, i-n-1 ]
				cPart = acContent[i]
				n = 0
			ok
	
		next
	
		aResult + [ cPart, nLen-n ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsCS(pCaseSensitive)
			return This.PartsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZ()
		return This.PartsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def PartAndTheirPositions()
			return This.PartsZ()

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE STRING ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------#

	def PartsCSZZ(pCaseSensitive)

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ This.Content(), [ 1, nLen ] ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Doing the job

		cPart = acContent[1]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				cPart += acContent[i]
				n++
			else
				aResult + [ cPart, [ i-n-1, i-1 ] ]
				cPart = acContent[i]
				n = 0
			ok
	
		next
	
		aResult + [ cPart, [ nLen-n, nLen ] ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsCS(pCaseSensitive)
			return This.PartsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZZ()
		return This.PartsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def PartAndTheirSections()
			return This.PartsZZ()

		#>

	  #---------------------------------------------------------------#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTITION EXPRESSION  #
	#===============================================================#

	/* Note:

	This function analyzes the string, by sequentially partitioning
	its content, using a given "partition expression", a "PartitionExpr",
	for short. Hence, it serves in answering this kind of question:

	How is the string composed in term of some char criteria
	(the char beeing, for example, lowercase or uppercase, or
	left-oriented or right-oriented).

	The PartitionExpr is what we should provide to the method in
	a param as a conditional code containing the @char keyword.

	For example:

	o1 = new stzString("TUNIS gafsa NABEUL beja")
	? o1.PartsUsing( 'Q(@char).CharCase()' ) 

	Uses the CharCase() method in stzChar as a PartitionExpr.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or NULL, then the classification done will return:

	[
		"TUNIS",	# expression value ~> Uppercase
		" ",		# expression value ~> NULL
		"gafsa",	# expression value ~> Lowercase
		" ",		# expression value ~> NULL
		"NABEUL",	# expression value ~> Uppercase
		" ",		# expression value ~> NULL
		"beja"		# expression value ~> Lowercase
	]

	*/

	def PartsUsingCS(pcPartitionExpr, pCaseSensitive)
		/* EXAMPLES

		See example inf the eXTended form PartsUsingXT()

		*/

		aSections = This.FindPartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def PartsUsingCSQ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSQR(pcPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSQR(pcPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsUsingCS(pcPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCS(pcPartitionExpr, pCaseSensitive)

			def PartsWCSQ(pcPartitionExpr, pCaseSensitive)
				return This.PartsUsingCSQ(pcPartitionExpr, pCaseSensitive)

			def PartsWCSQR(pcPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQR(pcPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsing(pcPartitionExpr)
		return This.PartsUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionFluentForms

		def PartsUsingQ(pcPartitionExpr)
			return This.PartsUsingQR(pcPartitionExpr, :stzList)

		def PartsUsingQR(pcPartitionExpr, pcReturnType)
			return This.PartsUsingCSQR(pcPartitionExpr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartsW(pcPartitionExpr)
			return This.PartsUsing(pcPartitionExpr)

			def PartsWQ(pcPartitionExpr)
				return This.PartsUsingQ(pcPartitionExpr)

			def PartsWQR(pcPartitionExpr, pcReturnType)
				return This.PartsUsingQR(pcPartitionExpr, pcReturnType)

		#>

	  #---------------------------------------------------------------------------#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTITION EXPRESSION -- EXTENDED  #
	#===========================================================================#

	def PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		/*
 
		Examples:

		o1 = new stzString("Abc285XY&")
		
		? o1.PartsUsing( 'Q(@char).IsLetter()' )
		#--> [ "Abc" = TRUE, "285" = FALSE, "XY" = TRUE, "&" = FALSE, "" = TRUE ]
		
		? o1.PartsUsing('Q(@char).Orientation()' )
		#--> [ "Abc285XY&" = :LeftToRight, "" = :RightToLeft ]
		
		? o1.PartsUsing( 'Q(@char).IsUppercase()' )
		#--> [ "A" = TRUE, "bc285" = FALSE, "XY" = TRUE, "&" = FALSE ]
		
		? o1.PartsUsing( 'Q(@char).CharCase()' )
		#--> [ "A" = :Uppercase, "bc" = :Lowercase, "285" = NULL, "XY" = :Uppercase, "&" = NULL ]

		*/

		aSections = This.FindPartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def PartsUsingCSXTQ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTQR(pcPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSXTQR(pcPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

			def PartsWCSXTQ(pcPartitionExpr, pCaseSensitive)
				return This.PartsUsingCSXTQ(pcPartitionExpr, pCaseSensitive)

			def PartsWCSXTQR(pcPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQR(pcPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsingXT(pcPartitionExpr)
		return This.PartsUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionFluentForms

		def PartsUsingXTQ(pcPartitionExpr)
			return This.PartsUsingXTQR(pcPartitionExpr, :stzList)

		def PartsUsingXTQR(pcPartitionExpr, pcReturnType)
			return This.PartsUsingCSXTQR(pcPartitionExpr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartsWXT(pcPartitionExpr)
			return This.PartsUsingXT(pcPartitionExpr)

			def PartsWXTQ(pcPartitionExpr)
				return This.PartsUsingXTQ(pcPartitionExpr)

			def PartsWXTQR(pcPartitionExpr, pcReturnType)
				return This.PartsUsingXTQR(pcPartitionExpr, pcReturnType)

		#>

	  #------------------------------------------------------------------------------#
	 #  GETTING THE PARTS USING A PARTITION EXPRESSION ALONG WITH THEIR PARTIONERS  #
	#------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartsAndPartitionersUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ This.Sections(aSections), acPartitioners ])
		return aResult

		#< @FunctionAlternativeForm

		def Parts2UsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsAndPartitionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsAndPartitionersUsing(pcPartitionExpr)
		return This.PartsAndPartitionersUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForm

		def Parts2Using(pcPartitionExpr)
			return This.PartsAndPartitionersUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING THE PARTS USING A PARTITION EXPRESSION ALONG WITH THEIR PARTIONERS -- XT #
	#-----------------------------------------------------------------------------------#

	def PartsAndPartitionersUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ This.Sections(aSections), acPartitioners ])
		return aResult

		#< @FunctionAlternativeForm

		def Parts2UsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsAndPartitionersUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsAndPartitionersUsingXT(pcPartitionExpr)
		return This.PartsAndPartitionersUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForm

		def Parts2UsingXT(pcPartitionExpr)
			return This.PartsAndPartitionersUsingXT(pcPartitionExpr)

		#>

	  #--------------------------------------------------------------------------------#
	 #  GETTING THE PARTIONERS (A GIVEN PARTITION EXPRESSION) ALONG WITH THEIR PARTS  #
	#--------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ acPartitioners, This.Sections(aSections) ])
		return aResult

		#< @FunctionAlternativeForm

		def Partioners2UsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartitionersAndPartsUsing(pcPartitionExpr)
		return This.PartitionersAndPartsUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForm

		def Partioners2Using(pcPartitionExpr)
			return This.PartitionersAndPartsUsing(pcPartitionExpr)

		#>

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE PARTIONERS (A GIVEN PARTITION EXPRESSION) ALONG WITH THEIR PARTS -- XT #
	#-------------------------------------------------------------------------------------#
	#NOTE // A partioner is the value return by the partition expression

	def PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		nLen = len(aSections)

		acPartitioners = []

		for i = 1 to nLen
			acPartitioners + aValues[aSections[i][1]]
		next

		aResult = @Association([ acPartitioners, This.Sections(aSections) ])
		return aResult

		#< @FunctionAlternativeForm

		def Partioners2UsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartitionersAndPartsUsingXT(pcPartitionExpr)
		return This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForm

		def Partioners2UsingXT(pcPartitionExpr)
			return This.PartitionersAndPartsUsingXT(pcPartitionExpr)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING PARTS IN THE STRING UPPON A GiVEN PARTITION EXPRESSION  #
	#==================================================================#

	def FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		anPos = StzListQ(aValues).FindPartsCS(pCaseSensitive)
	
		return anPos

		#< @FunctionAlternativeForms

		def FindPartsUsingCSZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCS(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def FindPartsWCSZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsUsing(pcPartitionExpr)
		return This.FindPartsUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def FindPartsUsingZ(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		#--

		def FindPartsW(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		def FindPartsWZ(pcPartitionExpr)
			return This.FindPartsUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING PARTS IN THE STRING UPPON A GiVEN PARTITION EXPRESSION -- XT #
	#=======================================================================#

	def FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		anPos = StzListQ(aValues).FindPartsCS(pCaseSensitive)

		return anPos
	
		#< @FunctionAlternativeForms

		def FindPartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def FindPartsWCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsUsingXT(pcPartitionExpr)
		return This.FindPartsUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def FindPartsUsingXTZ(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		#--

		def FindPartsWXT(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		def FindPartsWXTZ(pcPartitionExpr)
			return This.FindPartsUsingXT(pcPartitionExpr)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING PARTS, UPON A GIVEN PARTITON EXPERSSESION -- ZZ/EXTENSION  #
	#=====================================================================#

	def FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr)
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
	
		return aSections

		#< @FunctionAlternativeForms

		def FindPartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		def FindPartsAsSectionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsAsSectionsUsing(pcPartitionExpr)
		return This.FindPartsAsSectionsUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def FindPartsUsingZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		#--

		def FindPartsWZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		def FindPartsAsSectionsW(pcPartitionExpr)
			return This.FindPartsAsSectionsUsing(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING PARTS, UPON A GIVEN PARTITON EXPERSSESION -- XTZZ/EXTENSION  #
	#=======================================================================#

	def FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		if CheckParams()
			if isList(pcPartitionExpr) and Q(pcPartitionExpr).IsUsingOrWithOrByOrWhereNamedParam()
				pcPartitionExpr = pcPartitionExpr[2]
			ok

			if NOT isString(pcPartitionExpr)
				StzRaise("Incorrect param type! pcPartitionExpr must be a string.")
			ok

		ok

		# Early check

		nLen = This.NumberOfChars()

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean form pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(pcPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Getting the list of chars and preparing
		# it for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.CharsQ().Lowercased()
		else
			acContent = This.Chars()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		oCode = StzCCodeQ(pcPartitionExpr).TranspileQ()
		cCode = 'value = (' + oCode.Content() + ')'

		aValues = []
		for @i = 1 to nLen
			eval(cCode)
			aValues + value
		next

		nLenValues = len(aValues)

		# Getting the sections hosting the parts

		aSections = StzListQ(aValues).FindPartsCSZZ(pCaseSensitive)
		return aSections

		#< @FunctionAlternativeForms

		def FindPartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#--

		def FindPartsWCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def FindPartsAsSectionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPartsAsSectionsUsingXT(pcPartitionExpr)
		return This.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def FindPartsUsingXTZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		#--

		def FindPartsWXTZZ(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		def FindPartsAsSectionsWXT(pcPartitionExpr)
			return This.FindPartsAsSectionsUsingXT(pcPartitionExpr)

		#>

	  #----------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#==========================================================#

	def PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)
		acParts = This.PartsUsingCS(pcPartitionExpr, pCaseSensitive)
		anPos = This.FindPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		aResult = @Association([ acParts, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirPositionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingZ(pcPartitionExpr)
		return This.PartsUsingCSZ(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsing(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		#--

		def PartsWZ(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		def PartsAndTheirPositionsW(pcPartitionExpr)
			return This.PartsUsingZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING ALONG WITH THEIR POSITIONS -- eXTended  #
	#----------------------------------------------------------------------#

	def PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)
		acParts = This.PartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		anPos = This.FindPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		aResult = @Association([ acParts, anPos ])

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSXTZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirPositionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingXTZ(pcPartitionExpr)
		return This.PartsUsingCSXTZ(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsUsingXT(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		#--

		def PartsWXTZ(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		def PartsAndTheirPositionsWXT(pcPartitionExpr)
			return This.PartsUsingXTZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------------#
	 #  GETTING PARTS IN THE STRING AND RETURNING THEM ALOLG WITH THEIR SECTIONS  #
	#============================================================================#

	def PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)
		aSections = o1.FindPartsAsSectionsUsingCS(pcPartitionExpr, pCaseSensitive)
		acParts = o1.Sections(aSections)

		aResult = @Association([ acParts, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSZZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirSectionsWCS(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingZZ(pcPartitionExpr)
		return This.PartsUsingCSZZ(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsing(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		#--

		def PartsWZZ(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		def PartsAndTheirSectionsW(pcPartitionExpr)
			return This.PartsUsingZZ(pcPartitionExpr)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  gettING PARTS IN THE STRING AND RETURNING THEM ALOLG WITH THEIR SECTIONS -- eXTended  #
	#----------------------------------------------------------------------------------------#

	def PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)
		aSections = o1.FindPartsAsSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		acParts = o1.Sections(aSections)

		aResult = @Association([ acParts, aSections ])
		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		#--

		def PartsWCSXTZZ(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		def PartsAndTheirSectionsWCSXT(pcPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTZZ(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def PartsUsingXTZZ(pcPartitionExpr)
		return This.PartsUsingCSXTZZ(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsUsingXT(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		#--

		def PartsWXTZZ(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		def PartsAndTheirSectionsWXT(pcPartitionExpr)
			return This.PartsUsingXTZZ(pcPartitionExpr)

		#>

	  #------------------------------------------------------------#
	 #  CLASSIFYING THE PARTS USING A GIVEN PARTITION EXPRESSION  #
	#------------------------------------------------------------#

	def ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		# Get the list of partioners (classes) and parts

		aData = This.PartitionersAndPartsUsingCS(pcPartitionExpr, pCaseSensitive)
		nLen = len(aData)

		# Getting the list of classes (partioners)

		acClasses = []
		for i = 1 to nLen
			acClasses + aData[i][1]
		next

		acClasses = U(acClasses)

		# Adding the parts to each class

		aResult = []

		for i = 1 to nLen

			cClass = aData[i][1]
			n = ring_find(acClasses, cClass)

			if n = 0

				aResult + [ cClass, aData[i][2] ]

			else
				nLen2 = len(aData[i][2])

				for j = 1 to nLen2
					aResult[n] + aData[i][2][j]
				next
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def ClassifyUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def ClassifyCS(pcPartitionExpr, pCaseSensitive)
			if CheckParams()
				if isList(pcPartitionExpr) and
				   StzListQ(pcPartitionExpr).IsUsingNamedParam()

					pcPartitionExpr = pcPartitionExpr[2]
				ok
			ok

			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def ClassifyPartsCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyCS(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedUsingCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCS(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedCS(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsCS(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyPartsUsing(pcPartitionExpr)
		return This.ClassifyPartsUsingCS(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def ClassifyUsing(pcPartitionExpr)
			return This.ClassifyPartsUsing(pcPartitionExpr)

		def Classify(pcPartitionExpr)
			return This.ClassifyCS(pcPartitionExpr)

		def ClassifyParts(pcPartitionExpr)
			return This.Classify(pcPartitionExpr)

		def PartsClassifiedUsing(pcPartitionExpr)
			return This.ClassifyPartsUsing(pcPartitionExpr)

		def PartsClassified(pcPartitionExpr)
			return This.Classify(pcPartitionExpr)

		#>

	  #-----------------------------------------------------------------#
	 #  CLASSIFYING THE PARTS USING A GIVEN PARTITION EXPRESSION -- XT #
	#-----------------------------------------------------------------#

	def ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		# Get the list of partioners (classes) and parts

		aData = This.PartitionersAndPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)
		nLen = len(aData)

		# Getting the list of classes (partioners)

		acClasses = []
		for i = 1 to nLen
			acClasses + aData[i][1]
		next

		acClasses = U(acClasses)

		# Adding the parts to each class

		aResult = []

		for i = 1 to nLen

			cClass = aData[i][1]
			n = ring_find(acClasses, cClass)

			if n = 0

				aResult + [ cClass, aData[i][2] ]

			else
				nLen2 = len(aData[i][2])

				for j = 1 to nLen2
					aResult[n] + aData[i][2][j]
				next
			ok
		next

		return aResult

		#< @FunctionAlternativeForms

		def ClassifyUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def ClassifyCSXT(pcPartitionExpr, pCaseSensitive)
			if CheckParams()
				if isList(pcPartitionExpr) and
				   StzListQ(pcPartitionExpr).IsUsingNamedParam()

					pcPartitionExpr = pcPartitionExpr[2]
				ok
			ok

			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def ClassifyPartsCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyCSXT(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedUsingCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsUsingCSXT(pcPartitionExpr, pCaseSensitive)

		def PartsClassifiedCSXT(pcPartitionExpr, pCaseSensitive)
			return This.ClassifyPartsCSXT(pcPartitionExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyPartsUsingXT(pcPartitionExpr)
		return This.ClassifyPartsUsingCSXT(pcPartitionExpr, TRUE)

		#< @FunctionAlternativeForms

		def ClassifyUsingXT(pcPartitionExpr)
			return This.ClassifyPartsUsingXT(pcPartitionExpr)

		def ClassifyXT(pcPartitionExpr)
			return This.ClassifyCSXT(pcPartitionExpr)

		def ClassifyPartsXT(pcPartitionExpr)
			return This.ClassifyXT(pcPartitionExpr)

		def PartsClassifiedUsingXT(pcPartitionExpr)
			return This.ClassifyPartsUsingXT(pcPartitionExpr)

		def PartsClassifiedXT(pcPartitionExpr)
			return This.ClassifyXT(pcPartitionExpr)

		#>

	  #=============================#
	 #     DIVIDING THE STRING     #
	#=============================#

	def Divide(paByDividor)
		if isList(paByDividor) and Q(paByDividor).IsByNamedParam()
			paByDividor = paByDividor[2]
		ok

		return This.DivideBy(paDividor)

	def DivideBy(pDividor)
		
		switch ring_type(pDividor)

		on "NUMBER"
			This.SplitToNParts(n)

		on "STRING"
			n = This.NumberOfOccurrence(pDividor)
			oTempStr = StzStringQ(pDividor) * n
			
			if oTempStr.IsEqualTo(This.String())
				return n
			else
				oTempStr = ( This.Copy() - oTempStr.Content() )
				nLen = oTempStr.NumberOfChars()
				if oTempStr.IsEqualTo( This.Section(1, n) )
					nResult = n + nLen / StzStringQ(pDividor).NumberOfChars()
					return nResult
				else
					return n
				ok
			ok
		off

	  #=====================================#
	 #   GETTING THE CHARS SORTING ORDER   #
	#=====================================#

	def CharsSortingOrder()
		cResult = :Unsorted

		if This.CharsAreSorted()
			if This.CharsAreSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

		def SortingOrder()
			return This.CharsSortingOrder()
			

	  #---------------------------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS SAME CHARS SORTING ORDER AS AN OTHER STRING  #
	#---------------------------------------------------------------------------#

	def HasSameCharsSortingOrderAs(pcOtherStr)

		oTemp = new stzString(pcOtherStr)
		if oTemp.CharsSortingOrder() = This.CharsSortingOrder()
			return TRUE
		else
			return FALSE
		ok

		def HasSameCharsOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

		def HasSameSortingOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

	  #--------------------------------------------------#
	 #  CHECKING OF THE CHARS OF THE STRING ARE SORTED  #
	#--------------------------------------------------#

	def CharsAreSorted()
		if This.CharsAreSortedInAscending() or
		   This.CharsAreSortedInDescending()
			return TRUE
		else
			return FALSE
		ok

		def IsSorted()
			return This.CharsAreSorted()

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE CHARS OF THE STRING ARE SORTED IN ASCENDING  #
	#---------------------------------------------------------------#

	def CharsAreSortedInAscending()
		/*
		The idea is to sort a copy of the string in ascending order
		and then compare the copy to the original string...
		If they are identical, then the string is sorted in ascending order!
		*/

		oSortedInAscending = This.Copy().SortCharsInAscendingQ()
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if NOT AreEqual([ oSortedInAscending[i] , This.Char(i) ])
				return FALSE
			ok
		next

		return TRUE

		def IsSortedInAscending()
			return This.CharsAreSortedInAscending()

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE CHARS OF THE STRING ARE SORTED IN DESCENDING  #
	#----------------------------------------------------------------#

	def CharsAreSortedInDescending()
		/*
		The idea is to reverse the string, and check if its reversed
		copy is sorted in ASCENDING order. If so, then the string itself
		is actually sorted in DESCENDING order!
		*/
		oTemp = new stzString( This.CharsReversed() )
		if oTemp.CharsAreSortedInAscending()
			return TRUE
		else
			return FALSE
		ok

		def IsSortedInDescending()
			return This.CharsAreSortedInDescending()

	  #------------------------------------------------#
	 #  SORTING THE CHARS OF THE STRING IN ASCENDING  #
	#------------------------------------------------#

	def SortCharsInAscending()
		
		acChars = This.Chars()
		nLen = len(acChars)

		acChars = ring_sort(acChars)

		cResult = ""

		for i = 1 to nLen
			cResult += acChars[i]
		next

		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def SortCharsInAscendingQ()
			This.SortCharsInAscending()
			return This

		#>

		#< @FunctionAlternativeForms

		def SortCharsUp()
			This.SortCharsInAscending()

			def SortCharsUpQ()
				return This.SortCharsInAscendingQ()

		def SortInAscending()
			This.SortCharsInAscending()

			def SortInAscendingQ()
				return This.SortCharsInAscendingQ()

		def SortUp()
			This.SortCharsInAscending()

			def SortUpQ()
				return This.SortCharsInAscendingQ()

		def SortChars()
			This.SortCharsInAscending()

			def SortCharsQ()
				return This.SortCharsInAscendingQ()

		def Sort()
			This.SortCharsInAscending()

			def SortQ()
				return This.SortCharsInAscendingQ()

		#>

	#--

	def StringWithCharsSortedInAscending()
		cResult = This.Copy().SortCharsInAscendingQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def SortedInAscending()
			return This.StringWithCharsSortedInAscending()

		def Sorted()
			return This.SortedInAscending()

		def CharSorted()
			return This.SortedInAscending()

		def CharsSortedInAscending()
			return This.SortedInAscending()

		#--

		def SortedUp()
			return This.SortedInAscending()

		def CharSortedUp()
			return This.SortedInAscending()

		def StringWithCharsSortedUp()
			return This.StringWithCharsSortedInAscending()

		#>

	  #-------------------------------------------------#
	 #  SORTING THE CHARS OF THE STRING IN DESCENDING  #
	#-------------------------------------------------#

	def SortCharsInDescending()

		acChars = This.Chars()
		nLen = len(acChars)

		acChars = ring_sort(acChars)

		cResult = ""

		for i = nLen to 1 step - 1
			cResult += acChars[i]
		next

		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def SortCharsInDescendingQ()
			This.SortCharsInDescending()
			return This

		#>

		#< @FunctionAlternativeForms

		def SortCharsDown()
			This.SortCharsInDescending()

			def SortCharsDownQ()
				return This.SortCharsInDescendingQ()

		def SortInDescending()
			This.SortCharsInDescending()

			def SortInDescendingQ()
				return This.SortCharsInDescendingQ()

		def SortDown()
			This.SortCharsInDescending()

			def SortDownQ()
				return This.SortCharsInDescendingQ()
		#>

	#--

	def StringWithCharsSortedInDescending()
		cResult = This.Copy().SortInDescendingQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def StringWithCharsSortedDown()
			return This.StringWithCharsSortedInDescending()

		def SortedInDescending()
			return This.StringWithCharsSortedInDescending()

		def SortedDown()
			return This.StringWithCharsSortedInDescending()

		def CharsSortedInDescending()
			return This.StringWithCharsSortedInDescending()

		def CharsSortedDown()
			return This.StringWithCharsSortedInDescending()

		#>

	  #====================================================#
	 #  COMPARING THE STRING TO AN OTHER PROVIDED STRING  #
	#====================================================#

	def CompareCS(pcOtherStr, pCaseSensitive)

		# Returs :
		# 	0 if the two strings are equal
		# 	-1 if the main tring is lesser then the provided string
		# 	1 if the main string is greater then the provided string

		#NOTE : the comparison is made first by comparing them for equality.
		# If so, 0 is returned. Then, the two strings are put in a list and
		# the list is sorted in ascending. Then first in the list is greater.

		# If you want to perform the comparison in a locale-sensitive way,
		# use ComapreInLocale() instead. WARRING: This function needs the
		# the support of the QCollator class in RingQt.

		if CheckParams()
			if isList(pcOtherStr) and (pcOtherStr).IsWithOrToNamedParam()
				pcOtherStr = pcOtherStr[2]
	
				if NOT isString(pcOtherStr)
					StzRaise("Incorrect param type! pcOtherStr must be a string.")
				ok
			ok
		ok

		# Early check of equality

		if This.IsEqualToCS(pcOtherStr, pCaseSensitive)
			return 0
		ok

		cStr = This.Content()
		oList =  new stzList([ cStr, pcOtherStr ])
		oList.Sort()

		n = oList.FindFirstCS(cStr)

		if n = 1
			return -1
		else
			return 1
		ok

		#< @FunctionAlternativeForms

		def CompareWithCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def CompareToCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		#-- @FunctionPassiveForms

		def ComparedCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def ComparedWithCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		def ComparedToCS(pcOtherStr, pCaseSensitive)
			return This.CompareCS(pcOtherStr, pCaseSensitive)

		#>

	def Compare(pcOtherStr)
		return This.CompareCS(pcOtherStr, TRUE)

		#< @FunctionAlternativeForms

		def CompareWith(pcOtherStr)
			return This.Compare(pcOtherStr)

		def CompareTo(pcOtherStr)
			return This.Compare(pcOtherStr)

		#-- @FunctionPassiveForms

		def Compared(pcOtherStr)
			return This.Compare(pcOtherStr)

		def ComparedWith(pcOtherStr)
			return This.Compare(pcOtherStr)

		def ComparedTo(pcOtherStr)
			return This.Compare(pcOtherStr)

		#>
	
	  #-----------------------------------------------------------#
	 #     COMPARING THE STRING TO OTHER STRINGS USING UNICODE   #
	#===========================================================#
	#TODO: add Casesensitivity support

	# Compares the main string with an other string (based on the unicode code table)
	# --> Use this for internal string comparisons and sorting
	# --> For lists presented to the user, use SystemLocaleCompare()

	# 

	def UnicodeCompareWithCS(pcOtherStr, pCaseSensitive)
		#< QtBased | Uses QString.compare() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nQtValue = @oQString.compare(pcOtherStr, pCaseSensitive)

		if nQtValue = 0
			return :equal
		but nQtValue < 0
			return :less
		else
			return :greater
		ok

	def UnicodeCompareWith(pcOtherStr)
		return This.CompareWithCS(pcOtherStr, TRUE)

	def UnicodeCompareWithInSystemLocale(pcOtherStr)
		nQtResult = @oQString.localeAwareCompare(pcOtherStr)

		if nQtResult = 0
			return :equal
		but nQtResult < 0
			return :less
		but nQtResult > 0
			return :greater
		ok
		/*
		From Qt documentation:
	
		The comparison is performed in a locale- and also
		platform-dependent manner. Use this function to present
		sorted lists of strings to the user.

		NOTE:
		This works only for the current system locale.

		To compare for a defined locale, softanza should rely on
		the QCollator class in RingQt (which is not implemented yet)

		--> TODO: Add QCollator class to RingQt and make CompareWithInLocale()
		*/

	def UnicodeCompareWithInLocale(pcOtherStr, pLocale) #TODO
		// Needs the implementation of QCollator class in RingQt (read comment
		// in SystemLocaleCompareWith() methof above
		StzRaise("Feature unsupported yet!")

	def IsUnicodeEqualTo(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Equal

		def IsUnicodeEqualWith(pcOtherStr)
			return This.IsUnicodeEqualTo(pcOtherStr)

		#< @FunctionPassiveForm

		def IsUnicodeDifferentFrom(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		#>

	def IsUnicodeEqualToInLocale(pcOtherStr, pLocale)
		return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Equal

		def IsUnicodeDifferentFromInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

		def IsNotUnicodeEqualToInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

	def IsUnicodeLessThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Less

		def IsUnicodeLessThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Less
	
	def IsUnicodeGreaterThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Greater

		def IsUnicodeGreaterThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Greater

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS STRICTLY EQUAL TO ANOTHER STRING  #
	#--------------------------------------------------------------#

	def IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
		if This.IsEqualToCS(pcOtherStr, pCaseSensitive) and
		   This.HasSameSortingOrderAs(pcOtherStr)

			return TRUE

		else
			return FALSE
		ok

		def IsStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionPassiveForm

		def IsNotStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsStrictlyDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(pcOtherStr)
		return This.IsStrictlyEqualToCS(pcOtherStr, TRUE)

		def IsStrictlyEqualWith(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#< @FunctionPassiveForm

		def IsNotStrictlyEqualTo(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsNotStrictlyEqualWith(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentFrom(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)
	
		def IsStrictlyDifferentTo(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentOf(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS EQUAL TO ONE OF THE PROVIDED STRINGS  #
	#------------------------------------------------------------------#

	def IsEqualToOneOfTheseCS(pacOtherStr, pCaseSensitive)
		bResult = TRUE
		for str in pacOtherStr
			if NOT This.IsEqualToCS(str, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def IsEqualToOneOfThese(pacOtherStr)
		return This.IsEqualToOneOfTheseCS(pacOtherStr, TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS NEITHER EQUAL TO A GIVEN STRING NOR TO AN OTHER  #
	#-----------------------------------------------------------------------------#

	def IsNeitherCS(pcStr1, pcStr2, pCaseSensitive)
		if CheckParams()
			if isList(pcStr1) and Q(pcStr1).IsEqualToNamedParam()
				pcStr1 = pcStr1[2]
			ok

			if isList(pcStr2) and Q(pcStr2).IsNorNamedParam()
				pcStr2 = pcStr2[2]
			ok

			acStzTypes = [
				:String, :AString, :Char, :AChar, :Number,
				:ANumber, :List, :AList, :Object, :AnObject
			]
			#TODO: Add other stz types

			if @BothAreStrings(pcStr1, pcStr2) and
			   Q(pcStr1).IsOneOfThese(acStzTypes) and
			   Q(pcStr2).IsOneOfThese(acStzTypes)

				return This.@IsNeither(pcStr1, pcStr2)
			ok

			if NOT @BothAreStrings(pcStr1, pcStr2)
				StzRaise("Incorrect param type! pcStr1 and pcStr2 must both be strings.")
			ok
		ok

		bEqualToStr1 = This.IsEqualToCS(pcStr1, pCaseSensitive)
		bEqualToStr2 = This.IsEqualToCS(pcStr2, pCaseSensitive)

		if NOT bEqualToStr1 and NOT bEqualToStr2
			return TRUE
		else
			return FALSE
		ok

		def IsNeitherEqualToCS(pcStr1, pcStr2, pCaseSensitive)
			return This.IsNeitherCS(pcStr1, pcStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVITY

	def IsNeither(pcStr1, pcStr2)
		return This.IsNeitherCS(pcStr1, pcStr2, TRUE)

		def IsNeitherEqualTo(pcStr1, pcStr2)
			return This.IsNeither(pcStr1, pcStr2)

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS SMALLER THAN THE PROVIDED STRING  #
	#--------------------------------------------------------------#

	def IsSmaller(pcOtherStr)

		if CheckParams()

			if isList(pcOtherStr) and Q(pcOtherStr).IsThanNamedParam()
				pcOtherStr = pcOtherStr[2]
			ok

			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok

		ok

		if This.NumberOfChars() < StzStringQ(pcOtherStr).NumberOfChars()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsSmallerThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def IsLessThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		#>

	def IsLarger(pcOtherStr)
		if CheckParams()

			if isList(pcOtherStr) and Q(pcOtherStr).IsThanNamedParam()
				pcOtherStr = pcOtherStr[2]
			ok

			if NOT isString(pcOtherStr)
				StzRaise("Incorrect param type! pcOtherStr must be a string.")
			ok

		ok

		if This.NumberOfChars() > StzStringQ(pcOtherStr).NumberOfChars()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsLargerThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		#>

	def IsQuietEqualTo(pcOtherStr)

		cThisStr = This.Lowercased()
		cOtherStr = lower(pcOtherStr)

		if cThisStr = cOtherStr
			return TRUE
		ok

		nDif = abs(This.NumberOfChars() - StzStringQ(cOtherStr).NumberOfChars())
		n = nDif / This.NumberOfChars()
		
		if n <= QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return TRUE
		ok

		return FALSE

		def IsQuietEqual(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

		def IsApproximativelyEqual(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

		def IsApproximativelyEqualTo(pcOtherStr)
			return This.IsQuietEqualTo(pcOtherStr)

	  #-------------------------------------------------#
	 #     STRING IS A MULTIPLE OF AN OTHER STRING     #
	#-------------------------------------------------#

	def IsMultipleOfCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		n = This.NumberOfOccurrenceCS( pcSubStr, pCaseSensitive )

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsMultipleOf(pcSubStr)
		return This.IsMultipleOfCS(pcSubStr, TRUE)

	def IsNTimesMultipleOfCS(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsNTimesMultipleOf(n, pcSubStr)
		return This.IsNTimesMultipleOfCS(n, pcSubStr, TRUE)

	  #------------------------------------------------#
	 #     STRING IS A SPLITTER OF AN OTHER STRING    #
	#------------------------------------------------#

	def IsSplitterOfCS(pcOtherStr, pCaseSensitive)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		bResult = StzStringQ(pcOtherStr).NumberOfOccurrenceCS( This.String(), pCaseSensitive ) > 1
		return bResult

	def IsSplitterOf(pcOtherStr)
		bResult = This.IsSplitterOfCS(pcOtherStr, TRUE)
		return bResult

	  #---------------------------------------------------#
	 #     STRING IS SPLITTABLE USING AN OTHER STRING    #
	#---------------------------------------------------#

	def IsSplittableUsingCS(pcSubStr)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		return Q(pcSubStr).IsSplitterOfCS( This.String(), pCaseSensitive )

	def IsSplittableUsing(pcSubStr)
		return This.IsSplittableUsingCS(pcSubStr, pCaseSensitive)

	  #==============================#
	 #    REMOVING ALL SUBSTRINGS   # 
	#==============================#

	def RemoveCS(pSubStr, pCaseSensitive)
		if CheckParams()
			if isList(pSubStr)
				if Q(pSubStr).IsListOfStrings()
					This.RemoveManyCS(pSubStr, pCaseSensitive)

				but Q(pSubStr).IsListOfNumbers()
					This.ReloveCharsAtPositions(pSubStr)
				ok
				return
			ok
		ok

		This.ReplaceCS(pSubstr, "", pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveCSQ(pSubStr, pCaseSensitive)
			This.RemoveCS(pSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionFutureForm

		def RemoveCSFF(pSubStr, pCaseSensitive)
			if _cFutureOrder = :Before
				This.RemoveCS(pSubStr, pCaseSensitive)
				@ExecuteActions(@FutureActions(), This)

			but _cFutureOrder = :After
				@ExecuteActions(@FutureActions(), This)
				This.RemoveCS(pSubStr, pCaseSensitive)
			ok

			@CleanFuture()

			def RemoveCSFFQ(pSubStr, pCaseSensitive)
				This.RemoveCSFF(pSubStr, pCaseSensitive)
				return This

		#>			

	def RemovedCS(pSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveCSQ(pSubStr, pCaseSensitive).Content()
		return cResult
		
	#-- WITHOUT CASESENSITIVITY

	def Remove(pcSubStr) # replace with @oQString.remove() when added to RingQt
		This.ReplaceAll(pcSubStr , "")

		def RemoveQ(pcSubStr)
			This.Remove(pcSubStr)
			return This

		#< @FunctionFutureForm

		def RemoveFF(pSubStr)
			return This.RemoveCSFF(pSubStr, TRUE)

			def RemoveFFQ(pSubStr)
				return This.RemoveCSFFQ(pSubStr, TRUE)

		#>		

	def Removed(pSubStr)
		cResult = This.Copy().RemoveQ(pSubStr).Content()
		return cResult

	  #----------------------------------------------#
	 #   REMOVING SOME OCCURRENCES OF A SUBSTRING   #
	#----------------------------------------------#

	def RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("ring __ ring __ ring __ ring")
		o1.RemoveOccurrences([2, 3], "ring")
		? o1.Content() #--> "ring __  __  __ ring"
		*/

		anPos = This.FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtPositionsCS(anPos, pcSubStr, pCaseSensitive)

		def RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This

		def RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

			def RemoveTheseOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
				This.RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

	def TheseOccurrencesRemovedCS(panOccurr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveOccurrences(panOccurr, pcSubStr)
		This.RemoveOccurrencesCS(panOccurr, pcSubStr, TRUE)

		def RemoveOccurrencesQ(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)
			return This

		def RemoveTheseOccurrences(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)

			def RemoveTheseOccurrencesQ(panOccurr, pcSubStr)
				This.RemoveTheseOccurrences(panOccurr, pcSubStr)

	def TheseOccurrencesRemoved(panOccurr, pcSubStr)
		return This.Copy().RemoveOccurrencesQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	  #-------------------------------------------------#
	 #   REMOVING FIRST N OCCURRENCES OF A SUBSTRING   #
	#-------------------------------------------------#

	def RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.RemoveTheseOccurrencesCS( 1 : n, pcSubStr, pCaseSensitive )

		def RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstNOccurrences(n, pcSubStr)
		This.RemoveFirstNOccurrencesCS(n, pcSubStr, TRUE)

		def RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemoved(n, pcSubStr)
			return This.FirstNOccurrencesRemoved(n, pcSubStr)

	  #------------------------------------------------#
	 #   REMOVING LAST N OCCURRENCES OF A SUBSTRING   #
	#------------------------------------------------#

	def RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		nNumberOfOccurr = This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
		n1 = nNumberOfOccurr - n + 1
		This.RemoveTheseOccurrencesCS( n1 : nNumberOfOccurr , pcSubStr, pCaseSensitive )

		def RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastNOccurrences(n, pcSubStr)
		This.RemoveLastNOccurrencesCS(n, pcSubStr, TRUE)

		def RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemoved(n, pcSubStr)
			return This.LastNOccurrencesRemoved(n, pcSubStr)

	  #----------------------------------------------#
	 #   REMOVING MANY SUBSTRING AT THE SAME TIME   #
	#----------------------------------------------#

	def RemoveManyCS(pacSubStr, pCaseSensitive)
		for cSubstr in paCsubstr
			This.RemoveAllCS(cSubstr, pCaseSensitive)
		next

		def RemoveManyCSQ(pacSubStr, pCaseSensitive)
			This.RemoveManyCS(pacSubStr, pCaseSensitive)
			return This

		def RemoveAllOfTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)

		def RemoveTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveTheseCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)

		def RemoveManySubstringsCS(pcSubStr, pCaseSensitive)
			This.RemoveAllCS(pcSubStr, pCaseSensitive)

			def RemoveManySubstringsCSQ(pSubStr, pCaseSensitive)
				return This.RemoveManyCSQ(pacSubStr, pCaseSensitive)


	def ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)
		return This.Copy().RemoveManySubstringsCS(pacSubStr, pCaseSensitive).Content()

		def SubstringsRemovedCS(pacSubStr, pCaseSensitive)
			return This.ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)

	#-- CASESENSITIVE

	def RemoveMany(pacSubStr)
		for cSubstr in paCsubstr
			This.RemoveAll(cSubstr)
		next

		def RemoveManyQ(pacSubStr)
			This.RemoveMany(pacSubstr)
			return This

		def RemoveAllOfThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseQ(pacSubstr)
				return This.RemoveManyQ(pacSubStr)

		def RemoveThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveTheseQ(pacSubstr)
				return This.RemoveManyQ(pacSubStr)

		def RemoveManySubstrings(pcSubStr)
			This.RemoveMany(pacSubStr)

			def RemoveManySubstringsQ(pSubStr)
				return This.RemoveManyQ(pacSubStr)

	def ManySubstringsRemoved(pacSubStr)
		return This.Copy().RemoveManySubstrings(pacSubStr).Content()

		def SubstringsRemoved(pacSubStr)
			return This.ManySubstringsRemoved(pacSubStr)

		def TheseRemoved(pacSubStr)
			return This.ManySubstringsRemoved(pacSubStr)

	  #-------------------------------------------------#
	 #  REMOVING ALL SUBSTRINGS EXCEPT THOSE PROVIDED  #
	#=================================================#

	def RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("--Ring--&__Softanza__")

		o1.RemoveAllExcept([ "Ring", "&", "Softanza" ])
		? o1.Content()
		#--> Ring&Softanza

		*/

		aSections = This.FindSubStringsExceptCSZZ(pacSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringsExceptCSZ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsExceptCSZQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveSubStringsOtherThanCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsOtherThanCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveSubStringsOtherThanCSZ(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveSubStringsOtherThanCSZQ(pacSubStr, pCaseSensitive)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveAllExceptCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveAllExceptCSQ(pacSubStr, pCaseSensitive)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveExceptCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveExceptCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		def RemoveAllButCS(pacSubStr, pCaseSensitive)
			This.RemoveSubStringsExceptCS(pacSubStr, pCaseSensitive)

			def RemoveAllButCSQ(pacSubStr)
				return This.RemoveSubStringsExceptCSQ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringsExcept(pacSubStr)
		This.RemoveSubStringsExceptCS(pacSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringsExceptQ(pacSubStr)
			return This.RemoveSubStringsExceptCSQ(pacSubStr, TRUE)

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringsExceptZ(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveSubStringsExceptZQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveSubStringsOtherThan(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveSubStringsOtherThanQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveSubStringsOtherThanZ(pacSubStr)
			This.RemoveSubStringsExcep(pacSubStr)

			def RemoveSubStringsOtherThanZQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveAllExcept(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveAllExceptQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveExcept(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveExceptQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		def RemoveAllBut(pacSubStr)
			This.RemoveSubStringsExcept(pacSubStr)

			def RemoveAllButQ(pacSubStr)
				return This.RemoveSubStringsExceptQ(pacSubStr)

		#>

	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindSubStringBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenCS(pcSubStr,pcBound1, pcBound2, TRUE)

		def SubStringBetweenRemoved(pcSubStr,pcBound1, pcBound2)
			return This.SubStringBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, TRUE)

	  #---------------------------------------------------------------------------------------#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#---------------------------------------------------------------------------------------#

	def RemoveSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindSubStringBetweenCSIBZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenCSIB(pcSubStr,pcBound1, pcBound2, TRUE)

		def SubStringBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)
			return This.SubStringBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, TRUE)

	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		aSections = This.FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)


	def SubStringBoundedByRemovedCS(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveSubStringBoundedByCS(pcSubStr, pacBounds, TRUE)

		def SubStringBoundedByRemoved(pcSubStr, pacBounds)
			return This.SubStringBoundedByRemovedCS(pcSubStr, pacBounds, TRUE)

	  #===========================================================================#
	 #  REMOVING A SUBSTRING BOUNDED BY TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#===========================================================================#

	def RemoveSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		aSections = This.FindubStringBoundedByAsSectionsSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)

	def SubStringBoundedByRemovedSTCS(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedBySTCSQ(pcSubStr, pacBounds, pnStartingAt, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVE

	def RemoveSubStringBoundedByST(pcSubStr, pacBounds, pnStartingAt)
		This.RemoveSubStringBoundedBySTCS(pcSubStr, pacBounds, pnStartingAt, TRUE)

	def SubStringBoundedByRemovedST(pcSubStr, pacBounds, pnStartingAt)
		cResult = This.Copy().RemoveSubStringBoundedBySTQ(pcSubStr, pacBounds, pnStartingAt).Content()
		return cResult

	  #--------------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#--------------------------------------------------------------------------------------#
	#NOTE: encolsing substrings (bounds) are also removed

	def RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)

		aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pacBounds[1]).NumberOfChars()
		nLen2 = Q(pacBounds[2]).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

	def SubStringBoundedByRemovedCSIB(pcSubStr, pacBounds, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIViTY

	def RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
		return This.RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, TRUE)

	def SubStringBoundedByRemovedIB(pcSubStr, pcBound1, pcBound2)
		return This.RemoveSubStringBoundedByIB(pcSubStr, pacBounds, TRUE)

	  #-------------------------------------------------------#
	 #  REMOVING ANY BOUNDED SUSBSTRING BY THE GIVEN BOUNDS  #
	#=======================================================#

	def RemoveAnySubStringBoundedByCS(pacBounds, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByCSZZ(pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveSubStringsBoundedByCS(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCS(pacBounds, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveAnySubStringBoundedBy(pacBounds)
		This.RemoveAnySubStringBoundedByCS(pacBounds, TRUE)

		def RemoveAnySubStringBoundedByQ(pacBounds)
			This.RemoveAnySubStringBoundedBy(pacBounds)
			return This

	  #-----------------------------------------------------------------------#
	 #  REMOVING ANY BOUNDED SUSBSTRING BY THE GIVEN BOUNDS -- IB/EXTENSION  #
	#-----------------------------------------------------------------------#

	def RemoveAnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByCSIBZZ(pacBounds, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveSubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveAnySubStringBoundedByIB(pacBounds)
		This.RemoveAnySubStringBoundedByCSIB(pacBounds, TRUE)

		def RemoveAnySubStringBoundedByIBQ(pacBounds)
			This.RemoveAnySubStringBoundedByIB(pacBounds)
			return This

	  #-----------------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BOUNDED BY TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------------#

	def RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnySubStringBoundedByAsSectionsSTCS(pacBounds, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveAnySubStringsBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
			This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)

		def RemoveSubStringsBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)
			This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, pCaseSensitive)

	def AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveAnySubStringBoundedBySTCSQ(pacBounds, pnStartingAt, pCaseSensitive).Content()
		return cResult

		def AnySubStringsBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)

		def SubStringsBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.AnySubStringBoundedByRemovedSTCS(pacBounds, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)
		This.RemoveAnySubStringBoundedBySTCS(pacBounds, pnStartingAt, TRUE)

		def RemoveAnySubStringsBoundedByST(pacBounds, pnStartingAt)
			This.RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)

		def RemoveSubStringsBoundedByST(pacBounds, pnStartingAt)
			This.RemoveAnySubStringBoundedByST(pacBounds, pnStartingAt)

	def AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)
		cResult = This.Copy().RemoveAnySubStringBoundedBySTQ(pacBounds, pnStartingAt).Content()
		return cResult

		def AnySubStringsBoundedByRemovedST(pacBounds, pnStartingAt)
			return This.AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)

		def SubStringsBoundedByRemovedST(pacBounds, pnStartingAt)
			return This.AnySubStringBoundedByRemovedST(pacBounds, pnStartingAt)

	  #====================================#
	 #  REMOVING A SUBSTRING -- EXTENDED  #
	#====================================#

	def RemoveCSXT(p1, p2, pCaseSensitive)

		# Q("/\__/\/\__/\__").RemoveXT("", [])
		if isString(p1) and

			( (isList(p2)   and len(p2) = 0) or
			  (isString(p2) and p2 = "") or
			  (isNumber(p2) and p2 = 0) )

			This.RemoveCS(p1, pCaseSensitive)
			return

		# Q("/\__/\/\__/\__").RemoveXT([], "")
		but isString(p2) and

			( (isList(p1)   and len(p1) = 0) or
			  (isString(p1) and p1 = "") or
			  (isNumber(p1) and p1 = 0) )

			This.RemoveCS(p2, pCaseSensitive)
			return

		# Q("/\__/\__/\__/\__").RemoveXT(:Nth = 4, "")
		but isString(p2) and

		    ( isList(p1) and len(p1) = 2 and
		      isString(p1[1]) and p1[1] = :Nth and
		      isNumber(p1[2]) )

			This.RemoveNthCS(p1[2], p2, pCaseSensitive)
		ok


		if isList(p1) and Q(p1).IsEachNamedParam()
			p1 = p1[2]
		ok


		if isList(p2)
			oP2 = new stzList(p2)

			if oP2.IsAtNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				but isList(p2) and Q(p2).IsListOfNumbers()
					This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number or a list of numbers.")
				ok
					
			# Q("^^^^").RemoveXT( "", :AtPosition = 4)
			but oP2.IsAtPositionNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number.")
				ok
	
			#-- Removing at many positions
			#TODO // Add example here for better readability
			but oP2.IsAtPositionsNamedParam()
				p2 = p2[2]
	
				if NOT ( isList(p2) and Q(p2).IsListOfNumbers() )
					stzRaise("Incorrect param type! p2 must be a list of numbers.")
				ok
	
				This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

			# Removing from, Nth from, First from, Last from
			#TODO // Add examples here for better readability
			but oP2.IsFromNamedParam()
				p2 = p2[2]

				# Removing from

				if isString(p1)
					cNewSubStr =  Q(p2) - p1
	
				# Removing Nth from

				but isList(p1) and Q(p1).IsNthNamedParam()
					n = p1[2][1]
					p1 = p1[2][2]

					cNewSubStr = Q(p2).
							RemoveNthCSQ(n, p1, pCaseSensitive).
							Content()

				# Removing first from

				but isList(p1) and Q(p1).IsFirstNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveFirstCSQ(p1, pCaseSensitive).
							Content()

				but isList(p1) and Q(p1).IslastNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveLastCSQ(p1, pCaseSensitive).
							Content()

				ok

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing after
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :After, :AfterEach  ])

				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing after nth
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterNth ])
				n = p2[2][1]
				p2 = p2[2][2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after first
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after last
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing Before
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Before, :BeforeEach  ])

				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before nth
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeNth ])
				n = p2[2][1]
				p2 = p1 + p2[2][2]
				
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing before first
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeFirst, :ToFirst ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before last
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeLast, :ToLast ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing around
			#TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				p2 = p2[2]

				if isList(p1) and Q(p1).IsPairOfStrings()

					This.ReplaceCS(
						(p1[1] + p2 + p1[2]),
						p2,
						pCaseSensitive)

				else	
					This.ReplaceCS(
						(p1 + p2 + p1),
						p2,
						pCaseSensitive)
				ok

			# Removing around nth
			#TODO: Add example here for better readability
			but oP2.IsAroundNthNamedParam()
				
				n = p2[2][1]
				p2 = p2[2][2]

				if isString(n)
					if n = :First
						n = 1

					but n = :Last
						n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
					ok
				ok

				if NOT isNumber(n)
					StzRaise("Incorrect param! n must be a number.")
				ok

				if NOT isString(p2)
					StzRaise("Incorrect param! p2 must be a string.")
				ok

				# Forcing p1 to be a pair of lists

				if isString(p1)
					aTemp = []
					aTemp + p1 + p1
					p1 = aTemp	
				ok

				if NOT ( isList(p1) and @IsPairOfStrings(p1) )
					StzRaise("Incorrect param type! p1 must be a string or a pair of strings.")
				ok

				# Finding the section of the nth substring

				anSection = This.FindNthAsSection(n, p2)
				
				n1 = anSection[1] - Q(p1[1]).NumberOfChars()
				n2 = anSection[2] + Q(p1[2]).NumberOfChars()
				
				# If the substring is really bounded by the substrings to remove
				# then we make the necessary to remove them from the string

				if This.Section(n1, anSection[1] - 1) = p1[1] and
				   This.Section(anSection[2] + 1, n2) = p1[2]
				
					This.ReplaceSection(n1, n2, p2)
				ok

				# Otherwise, we do nothing.

			# Removing around first
			#TODO: Add example for better readability
			but oP2.IsAroundFirstNamedParam()
				RemoveXT(p1, :AroundNth = [1, p2[2]])

			# Removing around last

			but oP2.IsAroundLastNamedParam()
				RemoveXT(p1, :AroundNth = [:Last, p2[2]])

			#-- Removing between

			# Q("__/\/\__/\__").RemoveXT("", :Between = ["/","\"])
			# Q("__/\/\__/\__").RemoveXT("", :BetweenIB = ["/","\"])
			but oP2.IsOneOfTheseNamedParams([
				:Between, :BetweenIB, :BetweenS, :BetweenIBS ])

				cBetween = p2[1]
				p2  = p2[2]

				if isList(p2) and len(p2) = 2 and
				   isList(p2[2]) and p2[2][1] = :And

					p2[2] = p2[2][2]
				ok

				if NOT ( isList(p2) and Q(p2).IsPairOfStrings() )
					stzRaise("Incorrect param type! p2 must be a pair of strings.")
				ok

				if isString(p1) and p1 != ""
					if cBetween = :Between
						This.RemoveSubStringBetweenCS(p1, p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveSubStringBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)
		
					ok

				but (isList(p1) and len(p1) = 0) or
				    (isString(p1) and p1 = "") or
				    (isNumber(p1) and p1 = 0)

					if cBetween = :Between
						This.RemoveAnyBetweenCS(p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveAnyBetweenCSIB(p2[1], p2[2], pCaseSensitive)
		
					ok
	
				ok

	
			# Q("__/\/\__^^^^__").RemoveXT("", :BoundedBy = "^^")
			# Q("__/\/\__^^^^__").RemoveXT("", :BoundedByIB = "^^")
			but oP2.IsBoundedByNamedParam() or
			    oP2.IsBoundedByIBNamedParam()

				cBounded = p2[1]

				cBound1 = ""
				cBound2 = ""

				if isString(p2[2])
					cBound1 = p2[2]
					cBound2 = p2[2]

				but isList(p2[2]) and Q(p2[2]).IsPairOfStrings()
					cBound1 = p2[2][1]
					cBound2 = p2[2][2]

				but isList(p2[2]) and len(p2[2]) = 2 and
				    isString(p2[2][1]) and
				    isList(p2[2][2]) and Q(p2[2][2]).IsAndNamedParam()

					cBound1 = p2[2][1]
					cBound2 = p2[2][2][2]

				ok

				if cBounded = :BoundedBy
					This.RemoveSubStringBoundedByCS( p1, [ cBound1, cBound2 ], pCaseSensitive)

				but cBounded = :BoundedByIB
					This.RemoveSubStringBoundedByCSIB( p1, [ cBound1, cBound2 ], pCaseSensitive)

				ok

			ok
		ok

		def RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.RemoveCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def RemovedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveXT(pcNewSubStr, pcSubStr)
		This.RemoveCSXTQ(pcNewSubStr, pcSubStr, TRUE)

		def RemoveXTQ(pcNewSubStr, pcSubStr)
			This.RemoveXT(pcNewSubStr, pcSubStr)
			return This

	def RemovedXT(pcNewSubStr, pcSubStr)
		return This.Copy().RemoveXTQ(pcNewSubStr, pcSubStr).Content()

	  #---------------------------------------#
	 #   REMOVING CHAR AT A GIVEN POSITION   #
	#---------------------------------------#

	def RemoveCharAtPosition(n)
		This.ReplaceNthChar(n, "")

		def RemoveCharAtPositionQ(n)
			This.RemoveCharAtPosition(n)
			return This

		def RemoveCharAt(n)
			This.RemoveCharAtPosition(n)

			def RemoveCharAtQ(n)
				This.RemoveCharAt(n)
				return This

		def RemoveNthChar(n)
			This.RemoveCharAtPosition(n)

			def RemoveNthCharQ(n)
				This.RemoveNthChar(n)
				return This

	def CharAtPositionNRemoved(n)
		return This.Copy().RemoveCharAtPositionQ(n).Content()

		def CharAtNPositionRemoved(n)
			return This.CharAtPositionRemoved(n)

		def NthCharRemoved(n)
			return This.CharAtPositionRemoved(n)

	  #=========================#
	 #   REMOVING FIRST CHAR   #
	#=========================#

	#TODO #DONE
	# Here, case sensitivity does not apply. But it would be more
	# flexible and permissive to add it, although it has no effect.

	#TODO #FUTURE
	# Add it in all the library functions (future)

	#TODO #DONE
	# Write a narration about it


	def RemoveFirstCharCS(pCaseSensitive)
		This.RemoveNthChar(1)

		def RemoveFirstCharCSQ(pCaseSensitive)
			This.RemoveFirstCharCS(pCaseSensitive)
			return This

	#-- @FunctionPassiveForm

	def FirstCharRemovedCS(pCaseSensitive)
		return This.Copy().RemoveFirstCharCSQ(pCaseSensitive).Content()

	#== WITHOUT CASESENSITIVITY

	def RemoveFirstChar()
		This.RemoveNthChar(1)

		def RemoveFirstCharQ()
			This.RemoveFirstChar()
			return This

	#-- @FunctionPassiveForm

	def FirstCharRemoved()
		return This.Copy().RemoveFirstCharQ().Content()

	  #-----------------------------------------------------------#
	 #  REMOVING ALL LEADING OCCURRENCES OF THE FIRST CHAR - XT  #
	#-----------------------------------------------------------#

	def RemoveFirstCharXT()
		This.RemoveAnyLeadingChar()

		def RemoveFirstCharXTQ()
			This.RemoveFirstCharXT()
			return This

	def FirstCharRemovedXT()
		return This.Copy().RemoveFirstCharXTQ().Content()

	  #-----------------------#
	 #   REMOVING LAST CHAR  #
	#=======================#

	def RemoveLastChar()
		This.RemoveNthChar(This.NumberOfChars())

		def RemoveLastCharQ()
			This.RemoveLastChar()
			return This

	def LastCharRemoved()
		return This.Copy().RemoveLastCharQ().Content()

	  #----------------------------------------------------------#
	 #  REMOVING ALL LEADING OCCURRENCES OF THE LAST CHAR - XT  #
	#----------------------------------------------------------#

	def RemoveLastCharXT()
		This.RemoveAnyTrailingChar()

		def RemoveLastCharXTQ()
			This.RemoveLastCharXT()
			return This

	def LastCharRemovedXT()
		return This.Copy().RemoveLastCharXTQ().Content()

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST CHARS  #
	#==================================#

	def RemoveFirstAndLastChars()
		This.RemoveFirstChar()
		This.RemoveLastChar()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsQ()
			This.RemoveFirstAndLastChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstChars()
			This.RemoveFirstAndLastChars()

			def RemoveLastAndFirstCharsQ()
				This.RemoveLastAndFirstChars()
				return This

		#--

		def RemoveFirstCharAndLastChar()
			This.RemoveFirstAndLastChars()

			def RemoveFirstCharAndLastCharQ()
				This.RemoveFirstCharAndLastChar()
				return This

		def RemoveLastCharAndFirstChar()
			This.RemoveFirstAndLastChars()

			def RemoveLastCharAndFirstCharQ()
				This.RemoveLastCharAndFirstChar()
				return This

		#>

	def FirstAndLastCharsRemoved()
		return This.Copy().RemoveFirstAndLastCharsQ().Content()

		def LastAndFirstCharsRemoved()
			return This.FirstAndLastCharsRemoved()

		#--

		def FirstCharAndLastCharRemoved()
			return This.FirstAndLastCharsRemoved()

		def LastCharAndFirstCharRemoved()
			return This.FirstAndLastCharsRemoved()

	  #---------------------------------------#
	 #   REMOVING FIRST AND LAST CHARS -- XT #
	#=======================================#

	def RemoveFirstAndLastCharsXT()
		This.RemoveFirstCharXT()
		This.RemoveLastCharXT()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsXTQ()
			This.RemoveFirstAndLastCharsXT()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstCharsXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveLastAndFirstCharsXTQ()
				This.RemoveLastAndFirstCharsXT()
				return This

		#--

		def RemoveFirstCharAndLastCharXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveFirstCharAndLastCharXTQ()
				This.RemoveFirstCharAndLastCharXT()
				return This

		def RemoveLastCharAndFirstCharXT()
			This.RemoveFirstAndLastCharsXT()

			def RemoveLastCharAndFirstCharXTQ()
				This.RemoveLastCharAndFirstCharXT()
				return This

		#>

	def FirstAndLastCharsRemovedXT()
		return This.Copy().RemoveFirstAndLastCharsXTQ().Content()

		def LastAndFirstCharsRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

		#--

		def FirstCharAndLastCharRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

		def LastCharAndFirstCharRemovedXT()
			return This.FirstAndLastCharsRemovedXT()

	  #-----------------------#
	 #   REMOVING LEFT CHAR  #
	#=======================#

	def RemoveLeftChar()

		if This.IsLeftToRight()

			This.RemoveFirstChar()
		else
			This.RemoveLastChar()
		ok

		def RemoveLeftCharQ()
			This.RemoveLeftChar()
			return This

	def LeftCharRemoved()
		return This.Copy().RemoveLeftCharQ().Content()

	  #----------------------------#
	 #   REMOVING LEFT CHAR -- XT #
	#----------------------------#

	def RemoveLeftCharXT()

		if This.IsLeftToRight()
			This.RemoveFirstCharXT()
		else
			This.RemoveLastCharXT()
		ok

		def RemoveLeftCharXTQ()
			This.RemoveLeftCharXT()
			return This

	def LeftCharRemovedXT()
		return This.Copy().RemoveLeftCharXTQ().Content()

	  #------------------------#
	 #   REMOVING RIGHT CHAR  #
	#========================#

	def RemoveRightChar()

		if This.IsRightToLeft()
			This.RemoveFirstChar()
		else
			This.RemoveLastChar()
		ok

		def RemoveRightCharQ()
			This.RemoveRightChar()
			return This

	def RightCharRemoved()
		return This.Copy().RemoveRightCharQ().Content()

	  #-----------------------------#
	 #   REMOVING RIGHT CHAR -- XT #
	#-----------------------------#

	def RemoveRightCharXT()

		if This.IsRightToLeft()
			This.RemoveFirstCharXT()
		else
			This.RemoveLastCharXT()
		ok

		def RemoveRightCharXTQ()
			This.RemoveRightCharXT()
			return This

	def RightCharRemovedXT()
		return This.Copy().RemoveRightCharXTQ().Content()

	  #----------------------------------#
	 #   REMOVING LEFT AND RIGHT CHARS  #
	#==================================#

	def RemoveLeftAndRightChars()

		This.RemoveleftChar()
		This.RemoverightChar()

		def RemoveLeftAndRightCharsQ()
			This.RemoveLeftAndRightChars()
			return This

		def RemoveRightAndLeftChars()
			This.RemoveLeftAndRightChars()

			def RemoveRightAndLeftCharsQ()
				return This.RemoveLeftAndRightCharsQ()

	def LeftAndRightChardRemoved()
		return This.Copy().RemoveLeftAndRightChardQ().Content()

		def RightAndLeftCharsRemoved()
			return This.LeftAndRightChardRemoved()

	  #----------------------------------------#
	 #   REMOVING LEFT AND RIGHT CHARS -- XT  #
	#----------------------------------------#

	def RemoveLeftAndRightCharsXT()

		This.RemoveleftCharXT()
		This.RemoverightCharXT()

		def RemoveLeftAndRightCharsXTQ()
			This.RemoveLeftAndRightCharsXT()
			return This

		def RemoveRightAndLeftCharsXT()
			This.RemoveLeftAndRightCharsXT()

			def RemoveRightAndLeftCharsXTQ()
				return This.RemoveLeftAndRightCharsXTQ()

	def LeftAndRightChardRemovedXT()
		return This.Copy().RemoveLeftAndRightChardXTQ().Content()

		def RightAndLeftCharsRemovedXT()
			return This.LeftAndRightChardRemovedXT()

	  #-----------------------------------------------------------------------------#
	 #  REMOVING A GIVEN CHAR AT A GIVEN POSITION (IF ANY) WITH A GIVEN SUBSTRING  #
	#=============================================================================#

	def RemoveThisNthCharCS(n, cChar, pCaseSensitive)
		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.RemoveNthChar(n)
		ok

		def RemoveThisNthCharCSQ(n, cChar, pCaseSensitive)
			This.RemoveThisNthCharCS(n, cChar, pCaseSensitive)
			return This

	def ThisNthCharRemovedCS(n, cChar, pCaseSensitive)
		return This.Copy().RemoveThisNthCharCSQ(n, cChar, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthChar(n, cChar)
		This.RemoveThisNthCharCS(n, cChar, TRUE)

		def RemoveThisNthCharQ(n, cChar)
			This.RemoveThisNthChar(n, cChar)
			return This

	def ThisNthCharRemoved(n, cChar)
		return This.Copy().RemoveThisNthCharQ(n, cChar).Content()

	  #---------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR   #
	#=================================#

	def RemoveThisFirstCharCS(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstChar()
		ok

		def RemoveThisFirstCharCSQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCS(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstChar(c)
		This.RemoveThisFirstCharCS(c, TRUE)

		def RemoveThisFirstCharQ(c)
			This.RemoveThisFirstChar(c)
			return This

	def ThisFirstCharRemoved(c)
		return This.Copy().RemoveThisFirstCharQ(c).Content()

	  #--------------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR -- XT  #
	#--------------------------------------#

	def RemoveThisFirstCharCSXT(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstCharXT()
		ok

		def RemoveThisFirstCharCSXTQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCSXT(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCSXT(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSXTQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstCharXT(c)
		This.RemoveThisFirstCharCSXT(c, TRUE)

		def RemoveThisFirstCharXTQ(c)
			This.RemoveThisFirstCharXT(c)
			return This

	def ThisFirstCharRemovedXT(c)
		return This.Copy().RemoveThisFirstCharXTQ(c).Content()

	  #--------------------------------#
	 #   REMOVING A GIVEN LAST CHAR   #
	#================================#

	def RemoveThisLastCharCS(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastChar()
		ok

		def RemoveThisLastCharCSQ(c, pCaseSensitive)
			This.RemoveThisLastCharCS(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastChar(c)
		This.RemoveThisLastCharCS(c, TRUE)

		def RemoveThisLastCharQ(c)
			This.RemoveThisLastChar(c)
			return This

	def ThisLastCharRemoved(c)
		return This.Copy().RemoveThisLastCharQ(c).Content()

	  #-------------------------------------#
	 #   REMOVING A GIVEN LAST CHAR -- XT  #
	#-------------------------------------#

	def RemoveThisLastCharCSXT(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastCharXT()
		ok

		def RemoveThisLastCharCSXTQ(c, pCaseSensitive)
			This.RemoveThisLastCharCSXT(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCSXT(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSXTQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastCharXT(c)
		This.RemoveThisLastCharCSXT(c, TRUE)

		def RemoveThisLastCharXTQ(c)
			This.RemoveThisLastCharXT(c)
			return This

	def ThisLastCharRemovedXT(c)
		return This.Copy().RemoveThisLastCharXTQ(c).Content()


	  #-------------------------------#
	 #   REMOVING N CHARS FROM LEFT  #
	#===============================#

	def RemoveNCharsFromLeft(n)
		This.RemoveSection(1, n)

		def RemoveNCharsFromLeftQ(n)
			This.RemoveNCharsFromLeft(n)
			return This

		def RemoveNCharsLeft(n)
			This.RemoveNCharsFromLeft(n)

			def RemoveNCharsLeftQ(n)
				return This.RemoveNCharsFromLeftQ(n)

	def NCharsRemovedFromLeft(n)
		return This.Copy(n).RemoveNCharsFromLeftQ(n).Content()

		def NCharsRemovedLeft(n)
			return This.NCharsRemovedFromLeft(n)

	  #--------------------------------#
	 #   REMOVING N CHARS FROM RIGHT  #
	#--------------------------------#

	def RemoveNCharsFromRight(n)
		nLen = This.NumberOfChars()
		This.RemoveSection(nLen - n + 1, nLen)

		def RemoveNCharsFromRightQ(n)
			This.RemoveNCharsFromRight(n)
			return This

		def RemoveNCharsRight(n)
			This.RemoveNCharsFromRight(n)

			def RemoveNCharsRightQ(n)
				return This.RemoveNCharsFromRightQ(n)

	def NCharsRemovedFromRight(n)
		return This.Copy(n).RemoveNCharsFromRightQ(n).Content()

		def NCharsRemovedRight(n)
			return This.NCharsRemovedFromRight(n)

	  #--------------------------------#
	 #   REMOVING N CHARS FROM START  #
	#================================#

	def RemoveNCharsFromStart(n)
		if This.IsLeftToRight()
			This.RemoveSection(1, n)
		else
			nLen = This.NumberOfChars()
			This.RemoveSection(nLen- n + 1, nLen)
		ok

		def RemoveNCharsFromStartQ(n)
			This.RemoveNCharsFromStart(n)
			return This

		def RemoveNCharsStart(n)
			This.RemoveNCharsFromStart(n)

			def RemoveNCharsStartQ(n)
				return This.RemoveNCharsFromStartQ(n)

	def NCharsRemovedFromStart(n)
		return This.Copy(n).RemoveNCharsFromStartQ(n).Content()

		def NCharsRemovedStart(n)
			return This.NCharsRemovedFromStart(n)

	  #------------------------------#
	 #   REMOVING N CHARS FROM END  #
	#------------------------------#

	def RemoveNCharsFromEnd(n)
		if This.IsRightToLeft()
			This.RemoveSection(1, n)
		else
			nLen = This.NumberOfChars()
			This.RemoveSection(nLen- n + 1, nLen)
		ok

		def RemoveNCharsFromEndQ(n)
			This.RemoveNCharsFromEnd(n)
			return This

		def RemoveNCharsEnd(n)
			This.RemoveNCharsFromEnd(n)

			def RemoveNCharsEndQ(n)
				return This.RemoveNCharsFromEndQ(n)

	def NCharsRemovedFromEnd(n)
		return This.Copy(n).RemoveNCharsFromEndQ(n).Content()

		def NCharsRemovedEnd(n)
			return This.NCharsRemovedFromEnd(n)

	  #-------------------------------------------------#
	 #   REMOVING FIRST CHAR UNDER A GIVEN CONDITION   #
	#=================================================#

	def RemoveFirstCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindFirstCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveFirstCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveFirstCharWCS(pcCondition, pCaseSensitive)
			return This

	def FirstCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveFirstCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstCharW(pcCondition)
		This.RemoveFirstCharWCS(pcCondition, TRUE)

		def RemoveFirstCharWQ(pcCondition)
			This.RemoveFirstCharW(pcCondition)
			return This

	def FirstCharRemovedW(pcCondition)
		return This.Copy().RemoveFirstCharWQ(pcCondition).Content()

	  #------------------------------------------------------#
	 #   REMOVING FIRST CHAR UNDER A GIVEN CONDITION -- XT   #
	#-------------------------------------------------------#

	def RemoveFirstCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindFirstCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveFirstCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveFirstCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def FirstCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveFirstCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstCharWXT(pcCondition)
		This.RemoveFirstCharWCSXT(pcCondition, TRUE)

		def RemoveFirstCharWXTQ(pcCondition)
			This.RemoveFirstCharWXT(pcCondition)
			return This

	def FirstCharRemovedWXT(pcCondition)
		return This.Copy().RemoveFirstCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING LAST CHAR UNDER A GIVEN CONDITION   #
	#================================================#

	def RemoveLastCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindLastCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLastCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLastCharWCS(pcCondition, pCaseSensitive)
			return This

	def LastCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLastCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastCharW(pcCondition)
		This.RemoveLastCharWCS(pcCondition, TRUE)

		def RemoveLastCharWQ(pcCondition)
			This.RemoveLastCharW(pcCondition)
			return This

	def LastCharRemovedW(pcCondition)
		return This.Copy().RemoveLastCharWQ(pcCondition).Content()

	  #-----------------------------------------------------#
	 #   REMOVING LAST CHAR UNDER A GIVEN CONDITION -- XT  #
	#-----------------------------------------------------#

	def RemoveLastCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindLastCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLastCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLastCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def LastCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLastCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastCharWXT(pcCondition)
		This.RemoveLastCharWCSXT(pcCondition, TRUE)

		def RemoveLastCharWXTQ(pcCondition)
			This.RemoveLastCharWXT(pcCondition)
			return This

	def LastCharRemovedWXT(pcCondition)
		return This.Copy().RemoveLastCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING LEFT CHAR UNDER A GIVEN CONDITION   #
	#================================================#

	def RemoveLeftCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindLeftCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLeftCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveLeftCharWCS(pcCondition, pCaseSensitive)
			return This

	def LeftCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLeftCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLeftCharW(pcCondition)
		This.RemoveLeftCharWCS(pcCondition, TRUE)

		def RemoveLeftCharWQ(pcCondition)
			This.RemoveLeftCharW(pcCondition)
			return This

	def LeftCharRemovedW(pcCondition)
		return This.Copy().RemoveLeftCharWQ(pcCondition).Content()

	  #-----------------------------------------------------#
	 #   REMOVING LEFT CHAR UNDER A GIVEN CONDITION -- XT  #
	#-----------------------------------------------------#

	def RemoveLeftCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindLeftCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveLeftCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveLeftCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def LeftCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveLeftCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveLeftCharWXT(pcCondition)
		This.RemoveLeftCharWCSXT(pcCondition, TRUE)

		def RemoveLeftCharWXTQ(pcCondition)
			This.RemoveLeftCharWXT(pcCondition)
			return This

	def LeftCharRemovedWXT(pcCondition)
		return This.Copy().RemoveLeftCharWXTQ(pcCondition).Content()

	  #------------------------------------------------#
	 #   REMOVING RIGHT CHAR UNDER A GIVEN CONDITION  #
	#================================================#

	def RemoveRightCharWCS(pcCondition, pCaseSensitive)
		nPos = This.FindRightCharWCS(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveRightCharWCSQ(pcCondition, pCaseSensitive)
			This.RemoveRightCharWCS(pcCondition, pCaseSensitive)
			return This

	def RightCharRemovedWCS(pcCondition, pCaseSensitive)
		return This.Copy().RemoveRightCharWCSQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveRightCharW(pcCondition)
		This.RemoveRightCharWCS(pcCondition, TRUE)

		def RemoveRightCharWQ(pcCondition)
			This.RemoveRightCharW(pcCondition)
			return This

	def RightCharRemovedW(pcCondition)
		return This.Copy().RemoveRightCharWQ(pcCondition).Content()

	  #------------------------------------------------------#
	 #   REMOVING RIGHT CHAR UNDER A GIVEN CONDITION -- XT  #
	#------------------------------------------------------#

	def RemoveRightCharWCSXT(pcCondition, pCaseSensitive)
		nPos = This.FindRightCharWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharAt(nPos)

		def RemoveRightCharWCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveRightCharWCSXT(pcCondition, pCaseSensitive)
			return This

	def RightCharRemovedWCSXT(pcCondition, pCaseSensitive)
		return This.Copy().RemoveRightCharWCSXTQ(pcCondition, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveRightCharWXT(pcCondition)
		This.RemoveRightCharWCSXT(pcCondition, TRUE)

		def RemoveRightCharWXTQ(pcCondition)
			This.RemoveRightCharWXT(pcCondition)
			return This

	def RightCharRemovedWXT(pcCondition)
		return This.Copy().RemoveRightCharWXTQ(pcCondition).Content()

	  #----------------------------#
	 #   REMOVING N FIRST CHARS   #
	#============================#

	def RemoveNFirstChars(n)
		if This.IsRightToLeft()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok
		
		#< @FunctionFluentForm

		def RemoveNFirstCharsQ(n)
			This.RemoveNFirstChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstNChars(n)
			This.RemoveNFirstChars(n)

			#< @FuncFluentForm
	
			def RemoveFirstNCharsQ(n)
				This.RemoveNFirstCharsQ(n)
	
			#>

		#>
	
	def NFirstCharsRemoved(n)
		cResult = This.Copy().RemoveNFirstCharsQ(n).Content()
		return cResult

		def FirstNCharsRemoved(n)
			return This.NFirstCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LAST CHARS   #
	#---------------------------#

	def RemoveNLastChars(n)

		if This.IsLeftToRight()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok	

		#< @FunctionFluentForm

		def RemoveNLastCharsQ(n)
			This.RemoveNLastChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastNChars(n)
			This.RemoveNLastChars(n)

			#< @FuncFluentForm
	
			def RemoveLastNCharsQ(n)
				This.RemoveNLastCharsQ(n)
	
			#>

		#>
	
	def NLastCharsRemoved(n)
		cResult = This.Copy().RemoveNLastCharsQ(n).Content()
		return cResult

		def LastNCharsRemoved(n)
			return This.NLastCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LEFT CHARS   #
	#---------------------------#

	def RemoveNLeftChars(n)
		if This.IsLeftToRight()
			This.RemoveSection( 1, n )

		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNLeftCharsQ(n)
			This.RemoveNLeftChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLeftNChars(n)
			This.RemoveNLeftChars(n)

			#< @FuncFluentForm
	
			def RemoveLeftNCharsQ(n)
				This.RemoveNLeftCharsQ(n)
	
			#>
		#>
	
	def NLeftCharsRemoved(n)
		cResult = This.Copy().RemoveNLeftCharsQ(n).Content()
		return cResult

		def LeftNCharsRemoved(n)
			return This.NLeftCharsRemoved(n)

	  #----------------------------#
	 #   REMOVING N RIGHT CHARS   #
	#----------------------------#

	def RemoveNRightChars(n)
		if This.IsRightToLeft()
			This.RemoveSection( 1, n)
		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNRightCharsQ(n)
			This.RemoveNRightChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveRightNChars(n)
			This.RemoveNRightChars(n)

			#< @FuncFluentForm
	
			def RemoveRightNCharsQ(n)
				This.RemoveNRightCharsQ(n)
	
			#>
		#>
	
	def NRightCharsRemoved(n)
		cResult = This.Copy().RemoveNRightCharsQ(n).Content()
		return cResult

		def RightNCharsRemoved(n)
			return This.NRightCharsRemoved(n)

	  #---------------------------------------------#
	 #    REMOVING A GIVEN CHAR FROM THE STRING    # 
	#---------------------------------------------#

	def RemoveCharCS(pcChar, pCaseSensitive)

		if CheckParams()

			if NOT StringIsChar(pcChar)
				stzRaise("Incorrect param type! You must provide a string containing char")
			ok
		ok

		This.RemoveCS(pcChar, pCaseSensitive)

		def RemoveCharCSQ(pcChar, pCaseSensitive)
			This.RemoveCharCS(pcChar, pCaseSensitive)
			return This

	def CharRemovedCS(pcChar, pCaseSensitive)
		cResult = This.Copy().RemoveCharCSQ(pcChar, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveChar(pcChar)
		This.RemoveCharCS(pcChar, TRUE)

		def RemoveCharQ(pcChar)
			This.RemoveChar(pcChar)
			return This

	def CharRemoved(pcChar)
		cResult = This.Copy().RemoveCharQ(pcChar).Content()
		return cResult

	  #----------------------------------#
	 #    REMOVING A SECTION OF CHARS   # 
	#----------------------------------#
	
	// Removes a portion of the string defined by its start and end positions
	def RemoveSection(n1, n2)
		#< @QtBased = TRUE #>

		if CheckParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isString(n1) and NOT Q(n1).IsOneOfThese([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ])

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and NOT Q(n2).IsOneOfThese([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ])

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok
	
			if n2 = :LastChar  or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

		ok

		# Doing the job

		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, "")
		This.Update(cResult)

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

	def SectionRemoved(n1, n2)
		cResult = This.Copy().RemoveSectionQ(n1, n2).Content()
		return cResult
	
	  #-------------------------------------------------------#
	 #    REMOVING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#-------------------------------------------------------#

	def RemoveManySections(paSections)
 		/* EXAMPLE
		
		o1 = new stzString("**Word1***Word2**Word3***")

		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.RemoveSections([
			[1,2], [8, 10], [16, 17], [23, 25]
		])
		
		? o1.Content()
		#--> "Word1Word2Word3"

		*/

		if isList(paSections)
			paSections = StzListQ(paSections).ItemRemoved([])
		ok

		if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		if nLen = 0
			return
		ok

		aSorted = @SortLists(paSections)
		nLen = len(aSorted)

		for i = nLen to 1 step -1
			This.RemoveSection(aSorted[i][1], aSorted[i][2])
		next

		#< @FunctionAlternativeForms

		def RemoveManySectionsQ(paListOfSections)
			This.RemoveManySections(paListOfSections)
			return This

		def RemoveSections(paListOfSections)
			This.RemoveManySections(paListOfSections)

			def RemoveSectionsQ(paListOfSections)
				This.RemoveSections(paListOfSections)
				return This

		#>

	def ManySectionsRemoved(paListOfSections)
		cResult = This.Copy().RemoveManySectionsQ(paListOfSections).Content()
		return This

		def SectionsRemoved(paListOfSections)
			return This.ManySectionsRemoved(paListOfSections)

	  #-------------------------------------#
	 #  REMOVING SPACES IN GIVEN SECTIONS  #
	#-------------------------------------#

	def RemoveSpacesInSections(paSections)

		# Getting the parts non concerned with the removal of spaces

		acAntiSections = This.AntiSections(paSections)
		nLenAntiSections = len(acAntiSections)

		# Getting the sections without spaces

		nLenSections = len(paSections)
		oaStzStr = This.SectionsQ(paSections).ToListOfStzStrings()

		acSections = []
		for i = 1 to nLenSections
			acSections + oaStzStr[i].WithoutSpaces()
		next

		# Constructing the string again

		cResult = ""

		if nLenAntiSections > nLenSections

			for i = 1 to nLenSections
				cResult += (acAntiSections[i] + acSections[i])
			next

			cResult += acAntiSections[nLenAntiSections]

		but nLenSections > nLenAntiSections

			for i = 1 to nLenAntiSections
				cResult += (acSections[i] + acAntiSections[i])
			next

			cResult += acSections[nLenSections]

		else // nLenSections = nLenAntiSections

			if paSections[1][1] = 1
	
				for i = 1 to nLenAntiSections
					cResult += (acSections[i] + acAntiSections[i])
				next

			else

				for i = 1 to nLenSections
					cResult += (acAntiSections[i] + acSections[i])
				next

			ok
		ok

		This.UpdateWith(cResult)


		def RemoveSpacesInSectionsQ(paSections)
			This.RemoveSpacesInSections()
			return This


	def SpacesInSectionsRemoved(paSections)
		cResult = This.Copy().RemoveSpacesInSectionsQ(paSections).Content()
		return cResult

	  #--------------------------------#
	 #    REMOVING A RANGE OF CHARS   # 
	#===============================#

	// Removes a portion of the string defined by a start position and
	// a range of n chars

	def RemoveRange(nStart, nRange)

		if CheckParams()
			if NOT @IsNumberOrString(nStart)
				StzRaise("Incorrect param type! nStart must be a number or string.")
			ok

			if isString(nStart) and NOT ( nStart = :FirstChar or nStart = :Start or nStart = :StartOfString )
				StzRaise("Incorrect value! nStart can only be one of these strings: :FirstChar, :Start, :StartOfString.")
			ok

			if nStart = :FirstChar or nStart = :Start or nStart = :StartOfString
				nStart = 1
			ok

		ok

		This.RemoveSection(nStart, nStart + nRange - 1)

		def RemoveRangeQ(nStart, nRange)
			This.RemoveRange(nStart, nNumberOfChars)
			return This

	def RangeRemoved(nStart, nRange)
		cResult = This.RemoveRangeQ(nStart, nRange).Content()
		return cResult

	  #-----------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#-----------------------------------------------------#

	def RemoveManyRanges(paRanges) #TODO: use for loop instead of for/in

		if NOT ( isList(paRanges) and Q(paRanges).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManyRanges(paRanges)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paRanges) is not a list of pairs of numbers."
			])

		ok

		if isList(paRanges)
			oSections = new stzList(paRanges)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paRanges = oSections.Content()
			
		ok

		# Tranform ranges to sections and then use RemoveManySections()

		nLen = len(paRanges)
		aSections = []

		for i = 1 to nLen
			n1 = paRanges[i][1]
			n2 = paRanges[i][1] + paRanges[i][2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.RemoveManySections(aSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManySections(paRanges)

		def RemoveRanges(paRanges)
			This.RemoveManyRanges(paRanges)

			def RemoveRangesQ(paRanges)
				This.RemoveRanges(paRanges)
				return This

	def ManyRangesRemoved(paRanges)
		cResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return This

		def RangedRemoved(paRanges)
			return This.ManyRangesRemoved(paRanges)

	  #-------------------------------------------------------------#
	 #    REMOVING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#=============================================================#

	def RemoveSectionsWCS(paSections, pcCondition, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Wehre = '{ Q(This[@i]).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindSubStringsWCS(acSubStr, pcCondition, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSectionsWCSQ(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCS(paSections, pcCondition, pCaseSensitive)
			return This

		def RemoveSectionsWhereCS(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCS(paSections, pcCondition, pCaseSensitive)

			def RemoveSectionsWhereCSQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveSectionsWhereCS(paSections, pcCondition, pCaseSensitive)
				return This

		def RemoveManySectionsWCS(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCS(paSections, pcCondition, pCaseSensitive)
	
			def RemoveManySectionsWCSQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveManySectionsWCS(paSections, pcCondition, pCaseSensitive)
				return This

		def RemoveManySectionsWhereCS(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCS(paSections, pcCondition, pCaseSensitive)

			def RemoveManySectionsWhereCSQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveManySectionsWhereCS(paSections, pcCondition, pCaseSensitive)
				return This

	def ManySectionsRemovedWCS(paSections, pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveManySectionsWCSQ(paSections, pcCondition, pCaseSensitive).Content()
		return cResult

		def ManySectionsRemovedWhereCS(paSections, pcCondition, pCaseSensitive)
			return This.ManySectionsRemovedWCS(paSections, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveSectionsW(paSections, pcCondition)
		This.RemoveSectionsWCS(paSections, pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveSectionsWQ(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
			return This

		def RemoveSectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveSectionsWhereQ(paSections, pcCondition)
				This.RemoveSectionsWhere(paSections, pcCondition)
				return This

		def RemoveManySectionsW(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
	
			def RemoveManySectionsWQ(paSections, pcCondition)
				This.RemoveManySectionsW(paSections, pcCondition)
				return This

		def RemoveManySectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveManySectionsWhereQ(paSections, pcCondition)
				This.RemoveManySectionsWhere(paSections, pcCondition)
				return This

	def ManySectionsRemovedW(paSections, pcCondition)
		cResult = This.Copy().RemoveManySectionsWQ(paSections, pcCondition).Content()
		return cResult

		def ManySectionsRemovedWhere(paSections, pcCondition)
			return This.ManySectionsRemovedW(paSections, pcCondition)

	  #-------------------------------------------------------------------#
	 #    REMOVING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#===================================================================#

	def RemoveSectionsWCSXT(paSections, pcCondition, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveSectionsWXT(
			[3, 4], [7,8], [11,12], [15,16],
			:Wehre = '{ Q(@section).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindSubStringsWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSectionsWCSXTQ(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCSXT(paSections, pcCondition, pCaseSensitive)
			return This

		def RemoveSectionsWhereCSXT(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCSXT(paSections, pcCondition, pCaseSensitive)

			def RemoveSectionsWhereCSXTQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveSectionsWhereCSXT(paSections, pcCondition, pCaseSensitive)
				return This

		def RemoveManySectionsWCSXT(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCSXT(paSections, pcCondition, pCaseSensitive)
	
			def RemoveManySectionsWCSXTQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveManySectionsWCSXT(paSections, pcCondition, pCaseSensitive)
				return This

		def RemoveManySectionsWhereCSXT(paSections, pcCondition, pCaseSensitive)
			This.RemoveSectionsWCSXT(paSections, pcCondition, pCaseSensitive)

			def RemoveManySectionsWhereCSXTQ(paSections, pcCondition, pCaseSensitive)
				This.RemoveManySectionsWhereCSXT(paSections, pcCondition, pCaseSensitive)
				return This

	def ManySectionsRemovedWCSXT(paSections, pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveManySectionsWCSXTQ(paSections, pcCondition, pCaseSensitive).Content()
		return cResult

		def ManySectionsRemovedWhereCSXT(paSections, pcCondition, pCaseSensitive)
			return This.ManySectionsRemovedWCSXT(paSections, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveSectionsWXT(paSections, pcCondition)
		This.RemoveSectionsWCSXT(paSections, pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveSectionsWXTQ(paSections, pcCondition)
			This.RemoveSectionsWXT(paSections, pcCondition)
			return This

		def RemoveSectionsWhereXT(paSections, pcCondition)
			This.RemoveSectionsWXT(paSections, pcCondition)

			def RemoveSectionsWhereXTQ(paSections, pcCondition)
				This.RemoveSectionsWhereXT(paSections, pcCondition)
				return This

		def RemoveManySectionsWXT(paSections, pcCondition)
			This.RemoveSectionsWXT(paSections, pcCondition)
	
			def RemoveManySectionsWXTQ(paSections, pcCondition)
				This.RemoveManySectionsWXT(paSections, pcCondition)
				return This

		def RemoveManySectionsWhereXT(paSections, pcCondition)
			This.RemoveSectionsWXT(paSections, pcCondition)

			def RemoveManySectionsWhereXTQ(paSections, pcCondition)
				This.RemoveManySectionsWhereXT(paSections, pcCondition)
				return This

	def ManySectionsRemovedWXT(paSections, pcCondition)
		cResult = This.Copy().RemoveManySectionsWXTQ(paSections, pcCondition).Content()
		return cResult

		def ManySectionsRemovedWhereXT(paSections, pcCondition)
			return This.ManySectionsRemovedWXT(paSections, pcCondition)

	  #-----------------------------------------------------------#
	 #    REMOVING RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#===========================================================#

	def RemoveRangesWCS(paRanges, pcCondition, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveRangesW(
			[3, 1], [7,1], [11,1], [15,1],
			:Wehre = '{ Q(This[@i]).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindSubStringsWCS(acSubStr, pcCondition, pCaseSensitive)
		This.RemoveRanges(aRanges)

		#< @FunctionFluentForm

		def RemoveRangesWCSQ(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCS(paRanges, pcCondition, pCaseSensitive)
			return This

		def RemoveRangesWhereCS(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCS(paRanges, pcCondition, pCaseSensitive)

			def RemoveRangesWhereCSQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveRangesWhereCS(paRanges, pcCondition, pCaseSensitive)
				return This

		def RemoveManyRangesWCS(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCS(paRanges, pcCondition, pCaseSensitive)
	
			def RemoveManyRangesWCSQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveManyRangesWCS(paRanges, pcCondition, pCaseSensitive)
				return This

		def RemoveManyRangesWhereCS(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCS(paRanges, pcCondition, pCaseSensitive)

			def RemoveManyRangesWhereCSQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveManyRangesWhereCS(paRanges, pcCondition, pCaseSensitive)
				return This

	def ManyRangesRemovedWCS(paRanges, pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveManyRangesWCSQ(paRanges, pcCondition, pCaseSensitive).Content()
		return cResult

		def ManyRangesRemovedWhereCS(paRanges, pcCondition, pCaseSensitive)
			return This.ManyRangesRemovedWCS(paRanges, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRangesW(paRanges, pcCondition)
		This.RemoveRangesWCS(paRanges, pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveRangesWQ(paRanges, pcCondition)
			This.RemoveRangesW(paRanges, pcCondition)
			return This

		def RemoveRangesWhere(paRanges, pcCondition)
			This.RemoveRangesW(paRanges, pcCondition)

			def RemoveRangesWhereQ(paRanges, pcCondition)
				This.RemoveRangesWhere(paRanges, pcCondition)
				return This

		def RemoveManyRangesW(paRanges, pcCondition)
			This.RemoveRangesW(paRanges, pcCondition)
	
			def RemoveManyRangesWQ(paRanges, pcCondition)
				This.RemoveManyRangesW(paRanges, pcCondition)
				return This

		def RemoveManyRangesWhere(paRanges, pcCondition)
			This.RemoveRangesW(paRanges, pcCondition)

			def RemoveManyRangesWhereQ(paRanges, pcCondition)
				This.RemoveManyRangesWhere(paRanges, pcCondition)
				return This

	def ManyRangesRemovedW(paRanges, pcCondition)
		cResult = This.Copy().RemoveManyRangesWQ(paRanges, pcCondition).Content()
		return cResult

		def ManyRangesRemovedWhere(paRanges, pcCondition)
			return This.ManyRangesRemovedW(paRanges, pcCondition)

	  #-----------------------------------------------------------------#
	 #    REMOVING RANGES OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#=================================================================#

	def RemoveRangesWCSXT(paRanges, pcCondition, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveRangesWXT(
			[3, 1], [7,1], [11,1], [15,1],
			:Wehre = '{ Q(@range).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindSubStringsWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.RemoveRanges(aRanges)

		#< @FunctionFluentForm

		def RemoveRangesWCSXTQ(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCSXT(paRanges, pcCondition, pCaseSensitive)
			return This

		def RemoveRangesWhereCSXT(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCSXT(paRanges, pcCondition, pCaseSensitive)

			def RemoveRangesWhereCSXTQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveRangesWhereCSXT(paRanges, pcCondition, pCaseSensitive)
				return This

		def RemoveManyRangesWCSXT(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCSXT(paRanges, pcCondition, pCaseSensitive)
	
			def RemoveManyRangesWCSXTQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveManyRangesWCSXT(paRanges, pcCondition, pCaseSensitive)
				return This

		def RemoveManyRangesWhereCSXT(paRanges, pcCondition, pCaseSensitive)
			This.RemoveRangesWCSXT(paRanges, pcCondition, pCaseSensitive)

			def RemoveManyRangesWhereCSXTQ(paRanges, pcCondition, pCaseSensitive)
				This.RemoveManyRangesWhereCSXT(paRanges, pcCondition, pCaseSensitive)
				return This

	def ManyRangesRemovedWCSXT(paRanges, pcCondition, pCaseSensitive)
		cResult = This.Copy().RemoveManyRangesWCSXTQ(paRanges, pcCondition, pCaseSensitive).Content()
		return cResult

		def ManyRangesRemovedWhereCSXT(paRanges, pcCondition, pCaseSensitive)
			return This.ManyRangesRemovedWCSXT(paRanges, pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRangesWXT(paRanges, pcCondition)
		This.RemoveRangesWCSXT(paRanges, pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveRangesWXTQ(paRanges, pcCondition)
			This.RemoveRangesWXT(paRanges, pcCondition)
			return This

		def RemoveRangesWhereXT(paRanges, pcCondition)
			This.RemoveRangesWXT(paRanges, pcCondition)

			def RemoveRangesWhereXTQ(paRanges, pcCondition)
				This.RemoveRangesWhereXT(paRanges, pcCondition)
				return This

		def RemoveManyRangesWXT(paRanges, pcCondition)
			This.RemoveRangesWXT(paRanges, pcCondition)
	
			def RemoveManyRangesWXTQ(paRanges, pcCondition)
				This.RemoveManyRangesWXT(paRanges, pcCondition)
				return This

		def RemoveManyRangesWhereXT(paRanges, pcCondition)
			This.RemoveRangesWXT(paRanges, pcCondition)

			def RemoveManyRangesWhereXTQ(paRanges, pcCondition)
				This.RemoveManyRangesWhereXT(paRanges, pcCondition)
				return This

	def ManyRangesRemovedWXT(paRanges, pcCondition)
		cResult = This.Copy().RemoveManyRangesWXTQ(paRanges, pcCondition).Content()
		return cResult

		def ManyRangesRemovedWhereXT(paRanges, pcCondition)
			return This.ManyRangesRemovedWXT(paRanges, pcCondition)

	  #-------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION   # 
	#=================================================#

	def RemoveCharsWhereCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveCharsWhereCSQ(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharsWCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveCharsWCSQ(pcCondition, pCaseSensitive)
				This.RemoveCharsWCS(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWhereCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveAllcharsWhereCSQ(pcCondition, pCaseSensitive)
				This.RemoveAllcharsWhereCS(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWCS(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCS(pcCondition, pCaseSensitive)

			def RemoveAllcharsWCSQ(pcCondition, pCaseSensitive)
				This.RemoveAllCharsWhereCS(pcCondition, pCaseSensitive)
				return This

		#>

	#-- @PassiveForm
	def CharsRemovedWCS(pcCondition, pCaseSensitive)
		aResult = This.Copy().RemoveCharsWCSQ(pcCondition, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveCharsWhere(pcCondition)
		This.RemoveCharsWhereCS(pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveCharsWhereQ(pcCondition)
			This.RemoveCharsWhere(pcCondition)
			return This

		#>

		def RemoveCharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveCharsWQ(pcCondition)
				This.RemoveCharsW(pcCondition)
				return This

		def RemoveAllcharsWhere(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWhereQ(pcCondition)
				This.RemoveAllcharsWhere(pcCondition)
				return This

		def RemoveAllcharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWQ(pcCondition)
				This.RemoveAllCharsWhere(pcCondition)
				return This

	#-- @PassiveForm
	def CharsRemovedW(pcCondition)
		aResult = This.Copy().RemoveCharsWQ(pcCondition).Content()
		return aResult

	  #----------------------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  # 
	#----------------------------------------------------------------#

	def RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveCharsWhereCSXTQ(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharsWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereWCSXT(pcCondition, pCaseSensitive)

			def RemoveCharsWCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveCharsWCSXT(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWhereWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)

			def RemoveAllcharsWhereCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveAllcharsWhereCSXT(pcCondition, pCaseSensitive)
				return This

		def RemoveAllcharsWCSXT(pcCondition, pCaseSensitive)
			This.RemoveCharsWhereCSXT(pcCondition, pCaseSensitive)

			def RemoveAllcharsWCSXTQ(pcCondition, pCaseSensitive)
				This.RemoveAllCharsWhereCSXT(pcCondition, pCaseSensitive)
				return This

		#>

	#-- @PassiveForm
	def CharsRemovedWCSXT(pcCondition, pCaseSensitive)
		aResult = This.Copy().RemoveCharsWCSXTQ(pcCondition, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveCharsWhereXT(pcCondition)
		This.RemoveCharsWhereCSXT(pcCondition, TRUE)

		#< @FunctionFluentForm

		def RemoveCharsWhereXTQ(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)
			return This

		#>

		def RemoveCharsWXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveCharsWXTQ(pcCondition)
				This.RemoveCharsWXT(pcCondition)
				return This

		def RemoveAllcharsWhereXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveAllcharsWhereXTQ(pcCondition)
				This.RemoveAllcharsWhereXT(pcCondition)
				return This

		def RemoveAllcharsWXT(pcCondition)
			This.RemoveCharsWhereXT(pcCondition)

			def RemoveAllcharsWXTQ(pcCondition)
				This.RemoveAllCharsWhereXT(pcCondition)
				return This

	#-- @PassiveForm
	def CharsRemovedWXT(pcCondition)
		aResult = This.Copy().RemoveCharsWXTQ(pcCondition).Content()
		return aResult

	  #-----------------------------------#
	 #    REPLACING A SECTION OF CHARS   # 
	#===================================#
	
	// Replaces a portion of the string defined by its start and end positions

	def ReplaceSection(n1, n2, pcNewSubStr)
		#< @MotherFunction = YES | @QtBased #>

		if CheckParams()

			if NOT ( @IsNumberOrString(n1) and @IsNumberOrString(n2) )
				StzRaise("Incorrect param type! n1 must be a number or string.")
			ok

			if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok

			if isString(n1) and NOT Q(n1).IsOneOfThese([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ])

				StzRaise("Incorrect value! n1 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			if isString(n2) and NOT Q(n2).IsOneOfThese([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ])

				StzRaise("Incorrect value! n2 can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			#--

			if n1 = :FirstChar or n1 = :StartOfString or n1 = :First
				n1 = 1
			ok
	
			if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
				n1 = This.NumberOfChars()
			ok
	
			if n2 = :LastChar  or n2 = :EndOfString or n2 = :Last
				n2 = This.NumberOfChars()
			ok
	
			if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
				n2 = 1
			ok

		ok

		# Doing the job

		nQtStart = n1 - 1
		nQtRange = n2 - n1 + 1

		cResult = QStringObject().replace(nQtStart, nQtRange, pcNewSubStr)
		This.Update(cResult)

		#< @FunctionFluentForm

		def ReplaceSectionQ(n1, n2, pcNewSubStr)
			This.ReplaceSection(n1, n2, pcNewSubStr)
			return This

		#>

	def SectionReplaced(n1, n2, pcNewSubStr)
		cResult = This.Copy().ReplaceSectionQ(n1, n2, pcNewSubStr).Content()
		return cResult
	
	  #--------------------------------------------------------#
	 #    REPLACING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#--------------------------------------------------------#

	def ReplaceManySections(paListOfSections, pcNewSubStr)

		/* EXAMLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.ReplaceManySections([ [1,2], [8, 10], [16, 17], [23, 25] ], "_" )
		
		? o1.Content() #--> "_word1_word2_word3_"
		*/

		if NOT( isList(paListOfSections) and Q(paListOfSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		aListOfSections = StzListOfPairsQ( paListOfSections ).SortedInAscending()

		n = 0
		nNumberOfSections = len(aListOfSections)
		
		for i = len(aListOfSections) to 1 step -1

			aSection = aListOfSections[i]

			n1 = aSection[1]
			n2 = aSection[2]

			This.ReplaceSection(n1, n2, pcNewSubStr)

		next

		def ReplaceManySectionsQ(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)
			return This


		def ReplaceSections(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)

			def ReplaceSectionsQ(paListOfSections, pcNewSubStr)
				This.ReplaceSections(paListOfSections, pcNewSubStr)
				return This

	def ManySectionsReplaced(paListOfSections, pcNewSubStr)
		cResult = This.Copy().ReplaceManySectionsQ(paListOfSections, pcNewSubStr).Content()
		return This

		def SectionsReplaced(paListOfSections, pcNewSubStr)
			return This.ManySectionsReplaced(paListOfSections, pcNewSubStr)

	  #----------------------------------------------#
	 #  REPLACING MANY SECTIONS BY MANY SUBSTRINGS  #
	#----------------------------------------------#

	def ReplaceSectionsByMany(paSections, pacSubStr)

		if CheckParams()

			if NOT isList(paSections)
				StzRaise("Incorrect param type! paSections must be a list.")
			ok
	
			if NOT isList(pacSubStr)
					StzRaise("Incorrect param type! pacSubStr must be a list.")
			ok

		ok

		# Justifying the contents of the two params

		nLenSections = len(paSections)
		nLenSubStr = len(pacSubStr)

		if nLenSections < nLenSubStr
			pacSubStr = StzListQ(pacSubStr).SectionRemoved(nLenSections+1, nLenSubStr)

		else
			nDiff = nLenSections - nLenSubStr
			for i = 1 to nDiff
				pacSubStr + ""
			next
		ok

		paSections = StzListOfPairsQ(paSections).Sorted()
		nLen = len(paSections)
#TODO: test case lists are not equal in size

		# Doing the job

		for i = nLen to 1 step -1
			This.ReplaceSection(paSections[i][1], paSections[i][2], pacSubStr[i])
		next
		

		def ReplaceSectionsByManyQ(paSections, pacSubStr)
			This. ReplaceSectionsByMany(paSections, pacSubStr)
			return This

	def SectionsRempalcedByMany(paSections, pacSubStr)
		cResult = This.RepalceSectionsByManyQ(paSections, pacSubStr).Content()
		return cResult

	  #----------------------------------------------------------#
	 #  REPLACING MANY SECTIONS BY MANY SUBSTRINGS -- eXTended  #
	#----------------------------------------------------------#

	  #---------------------------------#
	 #    REPLACING A RANGE OF CHARS   # 
	#---------------------------------#

	// Replaces a portion of the string defined by a start position and
	// a range of n chars
	def ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)

		if CheckParams()

			if NOT @IsNumberOrString(nStart)
				StzRaise("Incorrect param type! nStart must be a number or string.")
			ok

			if NOT isNumber(nNumberOfChars)
				StzRaise("Incorrect param type! nNumberOfChars must be a number.")
			ok

			if isString(nStart) and NOT Q(nStart).IsOneOfThese([
				:First, :FirstChar, :StartOfString,
				:Last,  :LastChar,  :EndOfString ])

				StzRaise("Incorrect value! nStart can be a string containing one of these values: " +
					":First, :FirstChar, :StartOfString, :Last,  :LastChar or :EndOfString.")

			ok

			#--

			if nStart = :FirstChar or nStart = :StartOfString or nStart = :First
				nStart = 1

			but nStart = :LastChar  or nStart = :EndOfString or nStart = :Last
				n1 = This.NumberOfChars()
			ok

		ok

		# Doing the job

		This.ReplaceSection(nStart, nStart + nNumberOfChars - 1, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr)
			This.ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)
			return This

		#>

	def RangeReplaced(nStart, nNumberOfChars, pcNewSubStr)
		cResult = This.ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#------------------------------------------------------#

	def ReplaceManyRanges(paListOfRanges, pcNewSubStr)

		# Tranform ranges to sections and then use ReplaceManySections()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySections(aSections, pcNewSubStr)

		def ReplaceManyRangesQ(paListOfRanges, pcNewSubStr)
			This.ReplaceManySections(paListOfRanges, pcNewSubStr)

		def ReplaceRanges(paListOfRanges, pcNewSubStr)
			This.ReplaceManyRanges(paListOfRanges, pcNewSubStr)

			def ReplaceRangesQ(paListOfRanges, pcNewSubStr)
				This.ReplaceRanges(paListOfRanges, pcNewSubStr)
				return This

	def ManyRangesReplaced(paListOfRanges, pcNewSubStr)
		cResult = This.Copy().ReplaceManyRangesQ(paListOfRanges, pcNewSubStr).Content()
		return This

		def RangedReplaced(paListOfRanges, pcNewSubStr)
			return This.ManyRangesReplaced(paListOfRanges, pcNewSubStr)

	  #--------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#==============================================================#

	def ReplaceSectionsWCS(paSections, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(This[@i]).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindAsSectionsWCS(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSectionsWQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedW(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhere(paSections, pcCondition)
			return This.ManySectionsReplacedW(paSections, pcCondition)

	  #--------------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#--------------------------------------------------------------------#

	def ReplaceSectionsWCSXT(paSections, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(@section).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Sections(paSections)
		aSections = This.FindAsSectionsWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSectionsWXTQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhereXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhereXT(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWXT(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhereXT(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsWXT(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereXTQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhereXT(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedWXT(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWXTQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhereXT(paSections, pcCondition)
			return This.ManySectionsReplacedWXT(paSections, pcCondition)

	  #------------------------------------------------------------#
	 #    REPLACING RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#============================================================#

	def ReplaceRangesWCS(paRanges, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceRangesW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(This[@i]).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindAsRangesWCS(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceRanges(aRanges, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRangesWQ(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)
			return This

		def ReplaceRangesWhere(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWhereQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesWhere(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesW(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)
	
			def ReplaceManyRangesWQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesW(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWhere(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesW(paRanges, pcNewSubStr, pcCondition)

			def ReplaceManyRangesWhereQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWhere(paRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedW(paRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWQ(paRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManyRangesReplacedWhere(paRanges, pcCondition)
			return This.ManyRangesReplacedW(paRanges, pcCondition)

	  #------------------------------------------------------------------#
	 #    REPLACING RANGES OF CHARS VERIFYING A GIVEN CONDITION -- WXT  # 
	#------------------------------------------------------------------#

	def ReplaceRangesWCSXT(paRanges, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceRangesW(
			[3, 4], [7,8], [11,12], [15,16],
			:Where = '{ Q(@section).IsLowercase() }',
			:With = "_"
		)

		#--> "..AA.._..BB.._"
		*/

		acSubStr = This.Ranges(paRanges)
		aRanges = This.FindAsRangesWCSXT(acSubStr, pcCondition, pCaseSensitive)
		This.ReplaceRanges(aRanges, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRangesWXTQ(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)
			return This

		def ReplaceRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWhereXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)
	
			def ReplaceManyRangesWXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWXT(paRanges, pcNewSubStr, pcCondition)
				return This

		def ReplaceManyRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
			This.ReplaceRangesWXT(paRanges, pcNewSubStr, pcCondition)

			def ReplaceManyRangesWhereXTQ(paRanges, pcNewSubStr, pcCondition)
				This.ReplaceManyRangesWhereXT(paRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedWXT(paRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWXTQ(paRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManyRangesReplacedWhereXT(paRanges, pcCondition)
			return This.ManyRangesReplacedWXT(paRanges, pcCondition)

	  #==========================================#
	 #    SWAPPING TWO SECTIONS OF THE STRING   # 
	#==========================================#

	def SwapSections( panSection1, panSection2 )

		if CheckParam() = TRUE
			if isList(panSection2) and Q(panSection2).IsWithOrAndNamedParams()
				panSection2 = panSection2[2]
			ok
	
			if NOT @BothArePairsOfNumbers(panSection1, panSection2)
				StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
			ok
		ok

		cSection1 = This.Section(panSection1[1], panSection1[2])
		cSection2 = This.Section(panSection2[1], panSection2[2])

		This.ReplaceSection(panSection1[1], panSection1[2], cSection2)
		This.ReplaceSection(panSection2[1], panSection2[2], cSection1)


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2)
		return cResult

	  #-----------------------------------#
	 #  SWAPPING MANY PAIRS OF SECTIONS  #
	#-----------------------------------#

	def SwapManyPairsOfSections(paPairsOfSections)
		if CheckParam() = TRUE
			if NOT ( isList(paPairsOfSections) and Q(paPairsOfSections).IsListOfPairsOfSections() )
				StzRaise("Incorrect param type! paPairsOfSections must be a list of pairs of sections, each section being a pair of numbers.")
			ok
		ok

		nLen = len(paPairsOfSections)

		for i = 1 to nLen
			This.SwapSections(paPairsOfSections[i][1], paPairsOfSections[i][2])
		next

		def SwapManyPairsOfSectionsQ(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)
			return This

		def SwapPairsOfSections(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)

			def SwapPairsOfSectionsQ(paPairsOfSections)
				This.SwapPairsOfSections(paPairsOfSections)
				return This

	def ManyPairsOfSectionsSwapped(paPairsOfSections)
		cResult = This.Copy().SwapManyPairsOfSectionsQ(paPairsOfSections).Content()
		return cResult

	  #========================================#
	 #    REMOVING NUMBERS FROM THE STRING    # 
	#========================================#

	def RemoveNumbers()
		cResult = ""
	
		aStzChars = This.ToListOfStzChars()

		#TODO: Replace for/in with for --> better performance
		for oChar in aStzChars
			if NOT oChar.IsANumber()
				cResult += oChar.Content()
			ok
		next
	
		This.Update( cResult )

	
		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

	def NumbersRemoved()
		cResult = This.Copy().RemoveNumbersQ().Content()
		return cResult

	  #====================================================#
	 #     REMOVING THE NTH OCCURRENCE OF A SUBSTRING     #
	#====================================================#

	def RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if isList(n)
			This.RemoveOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return
		ok

		This.ReplaceNthOccurrenceCS(n, pcSubStr, "", pCaseSensitive)

		#< @FunctionFluentForm
	
		def RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def RemoveNthCS(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

			def RemoveNthCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNthCS(n, pcSubStr, pCaseSensitive)
				return This

		#>

	def NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def NthRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def SubStringNthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pcSubStr)
		This.RemoveNthOccurrenceCS(n, pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveNth(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)

			def RemoveNthQ(n, pcSubStr)
				This.RemoveNth(n, pcSubStr)
				return This

		#>

	def NthOccurrenceOfSubStringRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveNthOccurrenceQ(n, pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def NthRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def SubStringNthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		#>

	  #------------------------------------------------#
	 #    REMOVING FIRST OCCURRENCE OF A SUBSTRING    #
	#------------------------------------------------#

	def RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveFirstCS(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveFirstCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def FirstRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pcSubStr)
		This.RemoveFirstOccurrenceCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.RemoveFirstOccurrence(pcSubStr)
			return This
	
		#>

		#< @functionAlternativeForm

		def RemoveFirst(pcSubStr)
			This.RemoveFirstOccurrence(pcSubStr)

			def RemoveFirstQ(pcSubStr)
				This.RemoveFirst(pcSubStr)
				return This

		#>

	def FirstOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveFirstOccurrenceQ(pcSubStr).Content()

		def FirstRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringFirstOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	  #--------------------------------------------------#
	 #     REMOVING LAST OCCURRENCE OF A SUBSTRING      #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveLastCS(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveLastCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def LastRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringLastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pcSubStr)
		This.RemoveLastOccurrenceCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)
			return This
	
		#>

		#< @FunctionLastOccurrence

		def RemoveLast(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)

			def RemoveLastQ(pcSubStr)
				This.RemoveLast(pcSubStr)
				return This

		#>

	def LastOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveLastOccurrenceQ(pcSubStr).Content()

		def LastRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringLastOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	   #----------------------------------------------------#
	  #    REMOVING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def RemoveNextNthOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNextNthOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		def RemoveNthNextOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def NextNthOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		def NthNextOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, TRUE)

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

		#--

		def RemoveNextNthOccurrenceST(n, pcSubStr, nStart)
			return This.RemoveNextNthOccurrence(n, pcSubStr, nStart)

			def RemoveNextNthOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemoveNextNthOccurrenceQ(n, pcSubStr, nStart)

		def RemoveNthNextOccurrenceST(n, pcSubStr, nStart)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart)

			def RemoveNthNextOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def NextNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthNextOccurrenceRemoved(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def NextNthOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart)

		def NthNextOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart)

		#>

	   #------------------------------------------------#
	  #    REMOVING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNextOccurrenceSTCS(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)

			def RemoveNextOccurrenceSTCSQ(pcSubStr, nStart, pCaseSensitive)
				return This.RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NextOccurrenceRemovedSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, TRUE)

		#< @FunctionFluentForm

		def RemoveNextOccurrenceQ(pcSubStr, nStart)
			This.RemoveNextOccurrence(pcSubStr, nStart)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNextOccurrenceST(pcSubStr, nStart)
			This.RemoveNextOccurrence(pcSubStr, nStart)

			def RemoveNextOccurrenceSTQ(pcSubStr, nStart)
				return This.RemoveNextOccurrenceQ(pcSubStr, nStart)

		#>

	#-- @FunctionAlternativeForm

	def NextOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemoveNextOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

		def NextOccurrenceRemovedST(pcSubStr, nStart)
			return This.NextOccurrenceRemoved(pcSubStr, nStart)

	   #-------------------------------------------------------#
	  #    REMOVING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                       #
	#-------------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

		if CheckParams()

			if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
				nStart = nStart[2]
			ok
	
			if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithNamedParam()
				pcNewSubStr = pcNewSubStr[2]
			ok

		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def RemovePreviousNthOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemovePreviousNthOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		def RemoveNthPreviousOccurrenceSTCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceSTCSQ(n, pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#--

		def PreviousNthOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		def NthPreviousOccurrenceRemovedSTCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, TRUE)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

		#--

		def RemovePreviousNthOccurrenceST(n, pcSubStr, nStart)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart)

			def RemovePreviousNthOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart)

		def RemoveNthPreviousOccurrenceST(n, pcSubStr, nStart)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart)

			def RemoveNthPreviousOccurrenceSTQ(n, pcSubStr, nStart)
				return This.RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthPreviousOccurrenceRemoved(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		#--

		def PreviousNthOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		def NthPreviousOccurrenceRemovedST(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

		#>

	   #----------------------------------------------------#
	  #    REMOVING PREVIOUS OCCURRENCE OF A SUBSTRING     # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		#< @FunctionFluentForm

		def RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrenceSTCS(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)

			def RemovePreviousOccurrenceSTCSQ(pcSubStr, nStart, pCaseSensitive)
				return This.RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def PreviousOccurrenceRemovedSTCS(pcSubStr, nStart, pCaseSensitive)
			return This.PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, TRUE)

		#< @FunctionFluentForm

		def RemovePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrenceST(pcSubStr, nStart)
			This.RemovePreviousOccurrence(pcSubStr, nStart)

			def RemovePreviousOccurrenceSTQ(pcSubStr, nStart)
				return This.RemovePreviousOccurrenceQ(pcSubStr, nStart)

		#>

	#-- @FunctionPassiveForm

	def PreviousOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

		def PreviousOccurrenceRemovedST(pcSubStr, nStart)
			return This.PreviousOccurrenceRemoved(pcSubStr, nStart)

	  #-----------------------------------------------#
	 #    REMOVING LEFT OCCURRENCE OF A SUBSTRING    # 
	#-----------------------------------------------#

	def RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsRightToLeft()
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def LeftOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLeftOccurrence(pcSubStr)
		This.RemoveLeftOccurrenceCS(pcSubStr, :CaseSensitive = FALSE)

		def RemoveLeftOccurrenceQ(pcSubStr)
			This.RemoveLeftOccurrence(pcSubStr)
			return This

	def LeftOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveLeftOccurrenceQ(pcSubStr).Content()
		return cResult

	  #---------------------------------------------#
	 #    REMOVING RIGHT OCCURRENCE OF SUBSTRING   # 
	#---------------------------------------------#

	def RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsRightToLeft()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsLeftToRight()

			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def RightOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveRightOccurrence(pcSubStr)
		This.RemoveRightOccurrenceCS(pcSubStr, TRUE)

		def RemoveRightOccurrenceQ(pcSubStr)
			This.RemoveRightOccurrence(pcSubStr)
			return This

	def RightOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveRightOccurrenceQ(pcSubStr).Content()
		return cResult

	  #===========================================================================#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE START OF THE STRING   #
	#===========================================================================#

	def NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)
		if This.IsLeftToRight()
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		else # IsRightToLeft()
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== TO THE START instead of ON THE START

		def CharOccurrenceToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== AT THE START instead of ON THE START

		def CharOccurrenceAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheStartCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#== STARTSIDE instead of ON THE START

		def CharOccurrenceStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def CharOccurrencesStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharStartSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheStart(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheStartCS(pcChar, TRUE)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== TO THE START instead of ON THE START

		def CharOccurrenceToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== AT THE START instead of ON THE START

		def CharOccurrenceAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheStart(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#== STARTSIDE instead of ON THE START

		def CharOccurrenceStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def CharOccurrencesStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrenceOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrenceStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def ThisCharOccurrencesStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def NumberOfOccurrencesOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#--

		def HowManyOccurrenceOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrencesOfCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrenceOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		def HowManyOccurrencesOfThisCharStartSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheStart(pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE END OF THE STRING    #
	#==========================================================================#

	def NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)
		if This.IsLeftToRight()
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		else # IsRightToLeft()
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== TO THE END instead of ON THE END

		def CharOccurrenceToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== AT THE END instead of ON THE END

		def CharOccurrenceAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheEndCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#== ENDSIDE instead of ON THE END

		def CharOccurrenceEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def CharOccurrencesEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharEndSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheEnd(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheEndCS(pcChar, TRUE)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== TO THE END instead of ON THE END

		def CharOccurrenceToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== AT THE END instead of ON THE END

		def CharOccurrenceAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheEnd(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#== ENDSIDE instead of ON THE END

		def CharOccurrenceEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def CharOccurrencesEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrenceOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrenceEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def ThisCharOccurrencesEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def NumberOfOccurrencesOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#--

		def HowManyOccurrenceOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrencesOfCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrenceOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		def HowManyOccurrencesOfThisCharEndSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheEnd(pcChar)

		#>

	  #---------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE LEFT OF THE STRING    #
	#===========================================================================#

	def NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)
		if CheckParams()
			if NOT ( isString(pcChar) and @IsChar(pcChar) )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		
		n = This.FindLastCS(pcChar, pCaseSensitive)

		if n = 0 or n = 1
			return n
		ok

		nResult = 0
		nTemp = n
		while TRUE
			nTemp--
			if nTemp = 0
				nResult = n
				exit
			ok

			if NOT This.CharQ(nTemp).IsEqualToCS(pcChar, pCaseSensitive)
				nResult = 0
				exit
			ok
		end
		
		return nResult

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheLeftCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def CharOccurrencesLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharLeftSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheLeft(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheLeftCS(pcChar, TRUE)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheLeft(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def CharOccurrencesLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrenceOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrenceLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def ThisCharOccurrencesLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def NumberOfOccurrencesOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#--

		def HowManyOccurrenceOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrencesOfCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrenceOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		def HowManyOccurrencesOfThisCharLeftSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheLeft(pcChar)

		#>

	  #---------------------------------------------------------------------------#
	 #   GETTING THE NUMBER OF OCCURRENCE OF A CHAR ON THE RIGHT OF THE STRING   #
	#---------------------------------------------------------------------------#

	def NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)
		if CheckParams()
			if NOT ( isString(pcChar) and @IsChar(pcChar) )
				StzRaise("Incorrect param type! pcChar must be a char.")
			ok
		ok

		nLen = This.NumberOfChars()
		n = This.FindFirstCS(pcChar, pCaseSensitive)

		if n = 0
			return 0

		but n = nLen
			return 1
		ok

		nResult = 1
		for i = n + 1 to nLen
			if This.CharQ(i).IsEqualToCS(pcChar, pCaseSensitive)
				nResult++
			else
				nResult = 0
				exit
			ok
		next

		return nResult

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharOnTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharToTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfThisCharAtTheRightCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def CharOccurrencesRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrenceOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def NumberOfOccurrenceOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrenceRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def ThisCharOccurrencesRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def NumberOfOccurrencesOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#--

		def HowManyOccurrenceOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrenceOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		def HowManyOccurrencesOfThisCharRightSideCS(pcChar, pCaseSensitive)
			return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def NumberOfOccurrenceOfCharOnTheRight(pcChar)
		return This.NumberOfOccurrenceOfCharOnTheRightCS(pcChar, TRUE)

		#< @FunctionAlternativeForms

		def CharOccurrenceOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharOnTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== TO THE LEFT instead of ON THE LEFT

		def CharOccurrenceToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharToTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== AT THE LEFT instead of ON THE LEFT

		def CharOccurrenceAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfThisCharAtTheRight(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#== LEFTSIDE instead of ON THE LEFT

		def CharOccurrenceRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def CharOccurrencesRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrenceOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def NumberOfOccurrenceOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrenceRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def ThisCharOccurrencesRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def NumberOfOccurrencesOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#--

		def HowManyOccurrenceOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrencesOfCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrenceOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		def HowManyOccurrencesOfThisCharRightSide(pcChar)
			return This.NumberOfOccurrenceOfCharOnTheRight(pcChar)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM START   #
	#================================#

	#TODO: Add "Strip" as alternative of "Trim" all over the library

	def RemoveThisCharFromStartCS(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
		else
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromStartCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def RemoveCharFromStartCSQ(c, pCaseSensitive)
				This.RemoveCharFromStartCS(c, pCaseSensitive)
				return This

		def TrimCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def TrimCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		def TrimThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def TrimThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		#--

		def StripCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def StripCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		def StripThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCS(c, pCaseSensitive)

			def StripThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromStartCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromStartCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		def ThisCharTrimmedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)


		def CharStrippedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		def ThisCharStrippedFromStartCS(c, pCaseSensitive)
			return This.CharRemovedFromStartCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromStart(c)
		This.RemoveAnyCharFromStartCS(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def RemoveCharFromStartQ(c)
				This.RemoveCharFromStartCS(c)
				return This

		def TrimCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def TrimCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def TrimThisCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def TrimThisCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		#--

		def StripCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def StripCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def StripThisCharFromStart(c)
			This.RemoveThisCharFromStart(c)

			def StripThisCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		#>

	def CharRemovedFromStart(c)
		return This.CharRemovedFromStartCS(c, TRUE)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStart(c)
			return This.CharRemovedFromStart(c)

		def CharTrimmedFromStart(c)
			return This.CharRemovedFromStart(c)

		def ThisCharTrimmedFromStart(c)
			return This.CharRemovedFromStart(c)

		#--

		def CharStrippedFromStart(c)
			return This.CharRemovedFromStart(c)

		def ThisCharStrippedFromStart(c)
			return This.CharRemovedFromStart(c)

		#>

	  #-------------------------------#
	 #   REMOVING A CHAR FROM END    #
	#===============================#

	def RemoveThisCharFromEndCS(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
		else
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromEndCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def RemoveCharFromEndCSQ(c, pCaseSensitive)
				This.RemoveCharFromEndCS(c, pCaseSensitive)
				return This

		def TrimCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def TrimCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def TrimThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def TrimThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def StripCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def StripCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		def StripThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCS(c, pCaseSensitive)

			def StripThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromEndCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromEndCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def ThisCharTrimmedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def CharStrippedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		def ThisCharStrippedFromEndCS(c, pCaseSensitive)
			return This.CharRemovedFromEndCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromEnd(c)
		This.RemoveThisCharFromEndCS(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def RemoveCharFromEndQ(c)
				This.RemoveCharFromEnd(c)
				return This

		def TrimCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def TrimCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def TrimThisCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def TrimThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def StripCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def StripCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def StripThisCharFromEnd(c)
			This.RemoveThisCharFromEnd(c)

			def StripThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#>

	def CharRemovedFromEnd(c)
		return This.CharRemovedFromEndCS(c, TRUE)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def CharTrimmedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def ThisCharTrimmedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def CharStrippedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		def ThisCharStrippedFromEnd(c)
			return This.CharRemovedFromEnd(c)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM LEFT    #
	#================================#

	def RemoveThisCharFromLeftCS(c, pCaseSensitive)
		if CheckParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		if This.LeftCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLeftChar()
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromLeftCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def RemoveCharFromLeftCSQ(c, pCaseSensitive)
				This.RemoveCharFromLeftCS(c, pCaseSensitive)
				return This

		def TrimCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def TrimCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def TrimThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def TrimThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def StripCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def StripCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		def StripThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCS(c, pCaseSensitive)

			def StripThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromLeftCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromLeftCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def ThisCharTrimmedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def CharStrippedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		def ThisCharStrippedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromLeft(c)
		This.RemoveThisCharFromLeftCS(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def RemoveCharFromLeftQ(c)
				This.RemoveCharFromLeft(c)
				return This

		def TrimCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def TrimCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def TrimThisCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def TrimThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def StripCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def StripCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		def StripThisCharFromLeft(c)
			This.RemoveThisCharFromLeft(c)

			def StripThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftQ(c)

		#>

	def CharRemovedFromLeft(c)
		return This.CharRemovedFromLeftCS(c, TRUE)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		#--

		def CharTrimmedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def ThisCharTrimmedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def CharStrippedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		def ThisCharStrippedFromLeft(c)
			return This.CharRemovedFromLeft(c)

		#>

	  #---------------------------------#
	 #   REMOVING A CHAR FROM RIGHT    #
	#---------------------------------#

	def RemoveThisCharFromRightCS(c, pCaseSensitive)
		if CheckParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		if This.RightCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRightChar()
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromRightCSQ(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def RemoveCharFromRightCSQ(c, pCaseSensitive)
				This.RemoveCharFromRightCS(c, pCaseSensitive)
				return This

		def TrimCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def TrimCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def TrimThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def TrimThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def StrimCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def StripCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		def StripThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCS(c, pCaseSensitive)

			def StripThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSQ(c, pCaseSensitive)

		#>

	def CharRemovedFromRightCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromRightCSQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		#--

		def CharTrimmedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def ThisCharTrimmedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def CharStrippedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		def ThisCharStrippedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCS(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromRight(c)
		This.RemoveAnyCharFromRightCS(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def RemoveCharFromRightQ(c)
				This.RemoveCharFromRight(c)
				return This

		def TrimCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def TrimCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def TrimThisCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def TrimThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def StripCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def StrimCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		def StrimThisCharFromRight(c)
			This.RemoveThisCharFromRight(c)

			def StripThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightQ(c)

		#>

	def CharRemovedFromRight(c)
		return This.CharRemovedFromRightCS(c, TRUE)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromRight(c)
			return This.CharRemovedFromRight(c)

		#--

		def CharTrimmedFromRight(c)
			return This.CharRemovedFromRight(c)

		def ThisCharTrimmedFromRight(c)
			return This.CharRemovedFromRight(c)

		def CharStrippedFromRight(c)
			return This.CharRemovedFromRight(c)

		def ThisCharStrippedFromRight(c)
			return This.CharRemovedFromRight(c)

		#>

	  #-----------------------------------------------------------------#
	 #   REMOVING ALL THE OCCURRENCES OF A CHAR FROM THE START -- XT   #
	#=================================================================#
	#TODO: Add Strip alternative

	def RemoveThisCharFromStartCSXT(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		else
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromStartCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromStartCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharstartSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharStartSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharStartSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharStartSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def RemoveCharFromStartCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromStartCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def TrimCharFromStartCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromStartCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromStartCSXT(c, pCaseSensitive)

			def TrimThisCharFromStartCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromStartCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromStartCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromStartCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromStartRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromStartRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedStartSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedStartSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromStartCSXT(c, pCaseSensitive)
			return This.CharRemovedFromStartCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromStartXT(c)
		This.RemoveThisCharFromStartCSXT(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromStart(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfCharFromStartQ(c)
				return This.RemoveThisCharFromStartQ(c)

		def RemoveAnyOccurrenceOfThisCharFromStart(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfThisCharFromStartQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveAnyOccurrenceOfCharstartSide(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfCharStartSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharStartSide(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveAnyOccurrenceOfThisCharStartSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def RemoveCharFromStartXTQ(c)
				This.RemoveCharFromStartCSXT(c)
				return This

		def TrimCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def TrimCharFromStartXTQ(c)
				return This.RemoveThisCharFromStartXTQ(c)

		def TrimThisCharFromStartXT(c)
			This.RemoveThisCharFromStartXT(c)

			def TrimThisCharFromStartXTQ(c)
				return This.RemoveThisCharFromStartXTQ(c)

		#>

	def CharRemovedFromStartXT(c)
		return This.CharRemovedFromStartCSXT(c, TRUE)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfCharRemovedFromStart(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharRemovedFromStart(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfCharFromStartRemoved(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharFromStartRemoved(c)
			return This.CharRemovedFromStartXT(c)

		#--

		def AnyOccurrenceOfCharRemovedStartSide(c)
			return This.CharRemovedFromStartXT(c)

		def AnyOccurrenceOfThisCharRemovedStartSide(c)
			return This.CharRemovedFromStartXT(c)

		#--

		def CharTrimmedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		def ThisCharTrimmedFromStartXT(c)
			return This.CharRemovedFromStartXT(c)

		#>

	  #-------------------------------#
	 #   REMOVING A CHAR FROM END    #
	#-------------------------------#
	#TODO: Add Strip alternative

	def RemoveThisCharFromEndCSXT(c, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		else
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromEndCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromEndCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharEndSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharEndSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharEndSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharEndSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def RemoveCharFromEndCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromEndCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def TrimCharFromEndCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromEndCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromEndCSXT(c, pCaseSensitive)

			def TrimThisCharFromEndCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromEndCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromEndCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisCharFromEndCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromEndRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromEndRemovedCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedEndSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedEndSideCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromEndCSXT(c, pCaseSensitive)
			return This.CharRemovedFromEndCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromEndXT(c)
		This.RemoveThisCharFromEndCSXT(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromEnd(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharFromEnd(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfThisCharFromEndQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveAnyOccurrenceOfCharEndSide(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfCharEndSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		def RemoveAnyOccurrenceOfThisCharEndSide(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveAnyOccurrenceOfThisCharEndSideQ(c)
				return This.RemoveThisCharFromEndQ(c)

		#--

		def RemoveCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def RemoveCharFromEndXTQ(c)
				This.RemoveCharFromEndCSXT(c)
				return This

		def TrimCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def TrimCharFromEndXTQ(c)
				return This.RemoveThisCharFromEndXTQ(c)

		def TrimThisCharFromEndXT(c)
			This.RemoveThisCharFromEndXT(c)

			def TrimThisCharFromEndXTQ(c)
				return This.RemoveThisCharFromEndXTQ(c)

		#>

	def CharRemovedFromEndXT(c)
		return This.CharRemovedFromEndCSXT(c, TRUE)

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfCharRemovedFromEnd(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharRemovedFromEnd(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfCharFromEndRemoved(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharFromEndRemoved(c)
			return This.CharRemovedFromEndXT(c)

		#--

		def AnyOccurrenceOfCharRemovedEndSide(c)
			return This.CharRemovedFromEndXT(c)

		def AnyOccurrenceOfThisCharRemovedEndSide(c)
			return This.CharRemovedFromEndXT(c)

		#--

		def CharTrimmedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		def ThisCharTrimmedFromEndXT(c)
			return This.CharRemovedFromEndXT(c)

		#>

	  #--------------------------------#
	 #   REMOVING A CHAR FROM LEFT    #
	#================================#
	#TODO: Add Strip alternative

	def RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
		if CheckParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		acChars = This.Chars()
		nLen = len(acChars)
		if nLen = 0
			return
		ok

		if IsCaseSensitive(pCaseSensitive) = FALSE
			c = ring_lower(c)
			for i = 1 to nLen
				acChars[i] = ring_lower(acChars[i])
			next
		ok

		n = 0

		if This.IsLeftToRight()
			for i = 1 to nLen
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( 1, n )
			ok

		else
			for i = nLen to 1 step -1
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( nLen - n + 1, nLen )
			ok

		ok

		#< @FunctionFluentFrom

		def RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromLeftCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromLeftCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharLeftSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharLeftSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharLeftSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharLeftSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def RemoveCharFromLeftCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromLeftCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def TrimCharFromLeftCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromLeftCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromLeftCSXT(c, pCaseSensitive)

			def TrimThisCharFromLeftCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromLeftCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromLeftCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromLeftCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromLeftCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromLeftRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromLeftRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedLeftSideCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedLeftSideCS(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromLeftCSXT(c, pCaseSensitive)
			return This.CharRemovedFromLeftCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromLeftXT(c)
		This.RemoveThisCharFromLeftCSXT(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromLeft(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		def RemoveAnyOccurrenceOfThisCharFromLeft(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfThisCharFromLeftQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#--

		def RemoveAnyOccurrenceOfCharLeftSide(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfCharLeftSideQ(c)
				return This.RemoveAnyCharFromLeftXTQ(c)

		def RemoveAnyOccurrenceOfThisCharLeftSide(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveAnyOccurrenceOfThisCharLeftSideQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#--

		def RemoveCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def RemoveCharFromLeftXTQ(c)
				This.RemoveCharFromLeftXT(c)
				return This

		def TrimCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def TrimCharFromLeftXTQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		def TrimThisCharFromLeftXT(c)
			This.RemoveThisCharFromLeftXT(c)

			def TrimThisCharFromLeftXTQ(c)
				return This.RemoveThisCharFromLeftXTQ(c)

		#>

	def CharRemovedFromLeftXT(c)
		return This.CharRemovedFromLeftCSXT(c, TRUE)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfCharRemovedFromLeft(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharRemovedFromLeft(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfCharFromLeftRemoved(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharFromLeftRemoved(c)
			return This.CharRemovedFromLeftXT(c)

		#--

		def AnyOccurrenceOfCharRemovedLeftSide(c)
			return This.CharRemovedFromLeftXT(c)

		def AnyOccurrenceOfThisCharRemovedLeftSide(c)
			return This.CharRemovedFromLeftXT(c)


		#--

		def CharTrimmedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		def ThisCharTrimmedFromLeftXT(c)
			return This.CharRemovedFromLeftXT(c)

		#>


	  #-------------------------------------#
	 #   REMOVING A CHAR FROM RIGHT -- XT  #
	#-------------------------------------#
	#TODO: Add Strip alternative

	def RemoveThisCharFromRightCSXT(c, pCaseSensitive)
		if CheckParams()
			if NOT (isString(c) and @IsChar(c))
				StzRaise("Incorrect param type! c must be a char.")
			ok
		ok

		acChars = This.Chars()
		nLen = len(acChars)
		if nLen = 0
			return
		ok

		if IsCaseSensitive(pCaseSensitive) = FALSE
			c = ring_lower(c)
			for i = 1 to nLen
				acChars[i] = ring_lower(acChars[i])
			next
		ok

		n = 0

		if This.IsLeftToRight()
			for i = nLen to 1 step -1
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( nLen - n + 1, nLen )
			ok

		else
			for i = 1 to nLen
				if acChars[i] = c
					n++
				else
					exit
				ok
			next i

			if n > 0
				This.RemoveSection( 1, n )
			ok

		ok


		#< @FunctionFluentFrom

		def RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharFromRightCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharFromRightCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#--

		def RemoveAnyOccurrenceOfCharRightSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfCharRightSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def RemoveAnyOccurrenceOfThisCharRightSideCS(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveAnyOccurrenceOfThisCharRightSideCSQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#--

		def RemoveCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def RemoveCharFromRightCSXTQ(c, pCaseSensitive)
				This.RemoveCharFromRightCSXT(c, pCaseSensitive)
				return This

		def TrimCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def TrimCharFromRightCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		def TrimThisCharFromRightCSXT(c, pCaseSensitive)
			This.RemoveThisCharFromRightCSXT(c, pCaseSensitive)

			def TrimThisCharFromRightCSXTQ(c, pCaseSensitive)
				return This.RemoveThisCharFromRightCSXTQ(c, pCaseSensitive)

		#>

	def CharRemovedFromRightCSXT(c, pCaseSensitive)
		cResult = This.Copy().RemoveCharFromRightCSXTQ(c, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisCharRemovedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedFromRightCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfCharFromRightRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharFromRightRemovedCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		#--

		def AnyOccurrenceOfCharRemovedRightSideCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def AnyOccurrenceOfThisCharRemovedRightSideCS(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)


		#--

		def CharTrimmedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		def ThisCharTrimmedFromRightCSXT(c, pCaseSensitive)
			return This.CharRemovedFromRightCSXT(c, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisCharFromRightXT(c)
		This.RemoveThisCharFromRightCSXT(c, TRUE)
		return This

		#< @FunctionAlternativeForms

		def RemoveAnyOccurrenceOfCharFromRight(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfCharFromRightQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		def RemoveAnyOccurrenceOfThisCharFromRight(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfThisCharFromRightQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#--

		def RemoveAnyOccurrenceOfCharRightSide(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfCharRightSideQ(c)
				return This.RemoveAnyCharFromRightXTQ(c)

		def RemoveAnyOccurrenceOfThisCharRightSide(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveAnyOccurrenceOfThisCharRightSideQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#--

		def RemoveCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def RemoveCharFromRightXTQ(c)
				This.RemoveCharFromRightXT(c)
				return This

		def TrimCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def TrimCharFromRightXTQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		def TrimThisCharFromRightXT(c)
			This.RemoveThisCharFromRightXT(c)

			def TrimThisCharFromRightXTQ(c)
				return This.RemoveThisCharFromRightXTQ(c)

		#>

	def CharRemovedFromRightXT(c)
		return This.CharRemovedFromRightCSXT(c, TRUE)

		#< @FunctionAlternativeForms


		def ThisCharRemovedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfCharRemovedFromRight(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharRemovedFromRight(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfCharFromRightRemoved(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharFromRightRemoved(c)
			return This.CharRemovedFromRightXT(c)

		#--

		def AnyOccurrenceOfCharRemovedRightSide(c)
			return This.CharRemovedFromRightXT(c)

		def AnyOccurrenceOfThisCharRemovedRightSide(c)
			return This.CharRemovedFromRightXT(c)


		#--

		def CharTrimmedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		def ThisCharTrimmedFromRightXT(c)
			return This.CharRemovedFromRightXT(c)

		#>

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM LEFT    #
	#=====================================#

	def RemoveFromLeftCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NLeftCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsLeftToRight()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr
			ok

			This.RemoveSection(n1, n2)
		ok

		#< @FunctionFluentForm

		def RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromLeftCS(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromLeftCSQ(pcSubStr, pCaseSensitive)
				return This.RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)

		#>

	def RemovedFromLeftCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromLeftCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringRemovedFromLeftCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromLeftCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromLeft(pcSubStr)
		This.RemoveFromLeftCS(pcSubStr, TRUE)

		def RemoveFromLeftQ(pcSubStr)
			This.RemoveFromLeft(pcSubStr)
			return This

		def RemoveSubStringFromLeft(pcSubStr)
			This.RemoveFromLeft(pcSubStr)

			def RemoveSubStringFromLeftQ(pcSubStr)
				This.RemoveSubStringFromLeft(pcSubStr)
				return This

	def RemovedFromLeft(pcSubStr)
		cResult = This.Copy().RemoveFromLeftQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromLeft(pcSubStr)
			return This.RemovedFromLeft(pcSubStr)

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM RIGHT   #
	#-------------------------------------#

	def RemoveFromRightCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NRightCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsRightToLeft()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr

			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromRightCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
			return This

		def RemoveRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringFromRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromRightCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromRightCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromRightCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromRightCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromRightCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromRight(pcSubStr)
		This.RemoveFromRightCS(pcSubStr, TRUE)

		def RemoveFromRightQ(pcSubStr)
			This.RemoveFromRight(pcSubStr)
			return This

		def RemoveRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveRightQ(pcSubStr)
				This.RemoveRight(pcSubStr)
				return This

		def RemoveSubStringFromRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveSubStringFromRightQ(pcSubStr)
				This.RemoveSubStringFromRight(pcSubStr)
				return This

	def RemovedFromRight(pcSubStr)
		cResult = This.Copy().RemoveFromRightQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromRight(pcSubStr)
			return This.RemovedFromRight(pcSubStr)	

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM START   #
	#-------------------------------------#

	def RemoveFromStartCS(pcSubStr, pCaseSensitive)

		if This.IsLeftToRight()
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromStartCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromStartCS(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromStartCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromStartCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveStartCS(pcSubStr, pCaseSensittive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveStartCSQ(pcSubStr, pCaseSensittive)
				This.RemoveStartCS(pcSubStr, pCaseSensittive)
				return This

		#>

	def RemovedFromStartCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromStartCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromStartCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

		def StartRemovedCS(pcSubStr, pCaseSensittive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromStart(pcSubStr)
		This.RemoveFromStartCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveFromStartQ(pcSubStr)
			This.RemoveFromStart(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveSubStringFromStartQ(pcSubStr)
				This.RemoveSubStringFromStart(pcSubStr)
				return This

		def RemoveStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveStartQ(pcSubStr)
				This.RemoveStart(pcSubStr)
				return This

		#>

	def RemovedFromStart(pcSubStr)
		cResult = This.Copy().RemoveFromStartQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromStart(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

		def StartRemoved(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

	  #-----------------------------------#
	 #   REMOVING A SUBSTRING FROM END   #
	#-----------------------------------#

	def RemoveFromEndCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromEndCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFromEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFromEndCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEndCS(pcSubStr, pCaseSensitive)
				return This
		#>

	def RemovedFromEndCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromEndCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromEndCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

		def EndRemovedCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromEnd(pcSubStr)
		This.RemoveFromEndCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def RemoveFromEndQ(pcSubStr)
			This.RemoveFromEnd(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveSubStringFromEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveSubStringFromEndQ(pcSubStr)
				This.RemoveSubStringFromEnd(pcSubStr)
				return This

		def RemoveEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveEndQ(pcSubStr)
				This.RemoveEnd(pcSubStr)
				return This

		#>

	def RemovedFromEnd(pcSubStr)
		cResult = This.Copy().RemoveFromEndQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromEnd(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

		def EndRemoved(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)


	  #=================================#
	 #   TRIMMING & REMOVING SPACES    # 
	#=================================#
	#TODO : Add Trim functions to stzList

	def Trim()
		This.Update( This.QStringObject().trimmed() )

		def TrimQ()
			This.Trim()
			return This

	def Trimmed()
		cResult = This.Copy().TrimQ().Content()
		return cResult

		def WithoutLeadingAndTrailingSpaces()
			return This.Trimmed()

	def TrimStart()
		if This.HasRepeatedLeadingChars()	
			This.RemoveThisRepeatedLeadingChar(" ")
		ok

		if This.FirstChar() = " "
			This.RemoveFirst(" ")
		ok

		def TrimStartQ()
			This.TrimStart()
			return This

		def RemoveLeadingSpaces()
			This.TrimStart()

			def RemoveLeadingSpacesQ()
				This.RemoveLeadingSpaces()
				return This

	def TrimmedFromStart()
		cResult = This.Copy().TrimStartQ().Content()
		return cResult

		def LeadingSpacesRemoved()
			return This.TrimmedFromStart()

		def WithoutLeadingSpaces()
			return This.TrimmedFromStart()

		def TrimmedStart()
			return This.TrimmedFromStart()

	def TrimEnd()

		This.RemoveThisRepeatedTrailingChar(" ")

		if This.LastChar() = " "
			This.RemoveLast(" ")
		ok

		def TrimEndQ()
			This.TrimEnd()
			return This

		def RemoveTrailingSpaces()
			This.TrimEnd()

			def RemoveTrailingSpacesQ()
				This.RemoveTrailingSpaces()
				return This
	
	def TrimmedFromEnd()
		cResult = This.Copy().TrimEndQ().Content()
		return cResult

		def TrailingSpacesRemoved()
			return This.TrimmedFromEnd()

		def WithoutTrailingSpaces()
			return This.TrimmedFromEnd()

		def TrimmedEnd()
			return This.TrimmedFromEnd()

	def TrimLeft()
		if This.IsLeftToRight()
			This.TrimStart()

		else # IsRightToLeft
			This.TrimEnd()
		ok

		def TrimLeftQ()
			This.TrimLeft()
			return This

		def RemoveLeftSpaces()
			This.TrimeLeft()

			def RemoveLeftSpacesQ()
				This.RemoveLeftSpaces()
				return This

	def TrimmedFromLeft()
		cResult = This.Copy().TrimLeftQ().Content()
		return cResult

		def LeftSpacesRemoved()
			return This.TrimmedFromLeft()

		def WithoutLeftSpaces()
			return This.TrimmedFromLeft()

		def TrimmedLeft()
			return This.TrimmedFromLeft()

	def TrimRight()
		if This.IsRightToLeft()
			This.TrimStart()

		else # IsLeftToRight
			This.TrimEnd()
		ok

		def TrimRightQ()
			This.TrimRight()
			return This

		def RemoveRightSpaces()
			This.TrimRight()

			def RemoveRightSpacesQ()
				This.RemoveRightSpaces()
				return This

	def TrimmedFromRight()
		cResult = This.Copy().TrimRightQ().Content()
		return cResult

		def RightSpacesRemoved()
			return This.TrimmedFromRight()

		def WithoutRightSpaces()
			return This.TrimmedFromRight()

		def TrimmedRight()
			return This.TrimmedFromRight()

	#--

	def TrimCharCS(c, pCaseSensitive) #TODO : Add TrimSubString()
		/* Example

		o1 = new stzString("123")
		o1.TrimChar("")
		? o1.Content()
		#--> "123"

		*/

		This.RemoveThisCharFromStartCS(c, pCaseSensitive)
		This.RemoveThisCharFromEndCS(c, pCaseSensitive)

		def TrimCharCSQ(c, pCaseSensitive)
			This.TrimCharCS(c, pCaseSensitive)
			return This

	def CharTrimmedCS(c, pCaseSensitive)
		cResult = This.Copy().TrimCharCSQ(c, pCaseSensitive).Content()
		return cResult

	def TrimChar(c)
		This.TrimCharCS(c, TRUE)

		def TrimCharQ(c)
			return This.TrimCharCSQ(c, TRUE)

	def CharTrimmed(c)
		return This.CharTrimmedCS(c, TRUE)

	#--

	def RemoveSpaces()
		This.RemoveAll(" ")

		def RemoveSpacesQ()
			This.RemoveSpaces()
			return This

		def RemoveAllSpaces()
			This.RemoveSpaces()

			def RemoveAllspacesQ()
				This.RemoveSpaces()
				return This

	def SpacesRemoved()
		cResult = This.Copy().RemoveSpacesQ().Content()
		return cResult

		def WithoutSpaces()
			return This.SpacesRemoved()

			#< @FunctionMisspelledForm

			def WithoutSapces()
				return This.WithoutSpaces()

			#>

	  #==========================================#
	 #  EXTRACTING A SUBSTRING FROM THE STRING  #
	#==========================================#

	def ExtractCS(pcSubStr, pCaseSensitive)
		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			StzRaise("Can't extract the substring It does not exist in the string.")
		ok

		This.RemoveCS(pcSubStr, pCaseSensitive)
		return pcSubStr

		def PopCS(pcSubStr, pCaseSensitive)
			return This.ExtractCS(pcSubStr, pCaseSensitive)

	def SubStringExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractCS(pcSubStr, pCaseSensitive)

		def SubStringPoppedCS(pcSubStr, pCaseSensitive)
			return This.SubStringExtractedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Extract(pcSubStr)
		return This.ExtractCS(pcSubStr, TRUE)

		def Pop(pcSubStr)
			return This.Extract(pcSubStr)

	def SubStringExtracted(pcSubStr)
		return This.Extract(pcSubStr)

		def SubStringPopped(pcSubStr)
			return This.SubStringExtracted(pcSubStr)

	  #----------------------------------------------#
	 #  EXTRACTING MANY SUBSTRINGS FROM THE STRING  #
	#----------------------------------------------#

	def ExtractManyCS(paSubStr, pCaseSensitive)
		if NOT This.ContainsManyCS(paSubStr, pCaseSensitive)
			StzRaise("Can't extract the substrings! SubStrings in paSubStr do not exist in the string.")
		ok

		This.RemoveManyCS(paSubStr, pCaseSensitive)
		return paSubStr

		#< @FunctionAlternativeForms

		def PopManyCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#--

		def ExtractTheseCS(aSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		def PopTheseCS(aSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#>

	def ManySubStringsExtractedCS(paSubStr, pCaseSensitive)
		return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ManySubStringsPoppedCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		def TheseSubStringsExtractedCS(paSubStr, pCaseSensitive)
			return This.ManySubStringsExtractedCS(paSubStr, pCaseSensitive)

		def TheseSubStringsPoppedCS(paSubStr, pCaseSensitive)
			return This.ExtractManyCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(paSubStr)
		return This.ExtractManyCS(paSubStr, :pCaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def PopMany(paSubStr)
			return This.ExtractMany(paSubStr)

		#--

		def ExtractThese(aSubStr)
			return This.ExtractMany(paSubStr)

		def PopThese(aSubStr)
			return This.ExtractMany(paSubStr)

		#>

	def ManySubStringsExtracted(paSubStr)
		return This.ExtractMany(paSubStr)

		#< @FunctionAlternativeForms

		def ManySubStringsPopped(paSubStr)
			return This.ExtractMany(paSubStr)

		def TheseSubStringsExtracted(paSubStr)
			return This.ManySubStringsExtracted(paSubStr)

		def TheseSubStringsPopped(paSubStr)
			return This.ExtractMany(paSubStr)

		#>

	  #-------------------------------------------------#
	 #  EXTRACTING ALL THE SUBSTRINGS FROM THE STRING  #
	#-------------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

		def PopAll()
			return This.ExtractAll()

	def AllStringExtracted()
		return This.ExtractAll()

		def AllStringPopped()
			return This.ExtractAll()

	  #---------------------------#
	 #  EXTRACTING THE NTH CHAR  #
	#---------------------------#

	def ExtractAt(n)
		if isString(n) and ( n = :Last or n = :LastSubString )
			n = This.NumberOfSubStrings()
		ok

		if NOT ( isNumber(n) and Q(n).IsBetween(1, This.NumberOfSubStrings()) )
			StzRaise("Can't extract! n outside of range.")
		ok

		TempcSubStr = This.SubStringAt(n)

		This.RemoveAt(n)

		return TempcSubStr

		#< @FunctionAlternativeForms

		def ExtractNthChar(n)
			return This.ExtractAt(n)

		def ExtractCharAtPosition(n)
			return This.ExtractAt(n)

		def ExtractCharAt(n)
			return This.ExtractAt(n)

		#--

		def PopAt(n)
			return This.ExtractAt(n)

		def PopNthChar(n)
			return This.ExtractAt(n)

		def PopCharAtPosition(n)
			return This.ExtractAt(n)

		def PopCharAt(n)
			return This.ExtractAt(n)

		#>

	def NthCharExtracted(n)
		return This.ExtractAt(n)

		def NthCharPopped(n)
			return This.ExtractAt(n)

		def ExtractedAt(n)
			return This.ExtractAt(n)

		def PoppedAt(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST CHAR  #
	#-----------------------------#

	def ExtractFirstChar()
		return This.ExtractAt(1)
 
		def PopFirstChar()
			return This.ExtractFirstChar()

	def FirstCharExtracted()
		return This.ExtractCharSubString()

		def FirstCharPopped()
			return This.ExtractFirstChar()

	  #----------------------------#
	 #  EXTRACTING THE LAST CHAR  #
	#----------------------------#

	def ExtractLastChar()
		return This.ExtractAt(This.NumberOfChars())

		def PopLastChar()
			return This.ExtractLastChar()

	def LastCharExtracted()
		return This.ExtractLastChar()

		def LastCharPopped()
			return This.ExtractLastChar()

	  #------------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF A SUBSTRING  #
	#------------------------------------------------#

	def ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive) > 0
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			StzRaise("Can't extract! The list does not contain n occurrences of pcSubStr.")
		ok

		#< @FunctionAlternativeFroms

		def ExtractNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		#>

	def NthOccurrenceExtractedCS(n, pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def NthOccurrencePoppedCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pcSubStr)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeFroms

		def ExtractNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNthOccurrence(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		#>

	def NthOccurrenceExtracted(n, pcSubStr)
		return This.ExtractNthOccurrence(n, pcSubStr)

		def NthOccurrencePopped(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

	  #--------------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF A SUBSTRING  #
	#--------------------------------------------------#

	def ExtractFirstCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopFirstCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def ExtractFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def PopFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		#>

	def FirstOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pcSubStr)
		return This.ExtractFirstCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def PopFirst(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def ExtractFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def PopFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		#>

	def FirstOccurrenceExtracted(pcSubStr)
		return This.ExtractFirst(pcSubStr)

		def FirstOccurrencePopped(pcSubStr)
			return This.ExtractFirst(pcSubStr)

	  #-------------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF A SUBSTRING  #
	#-------------------------------------------------#

	def ExtractLastCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(This.NumberOfChars(), pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopLastCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def ExtractLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def PopLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		#>

	def LastOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pcSubStr)
		return This.ExtractLastCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def PopLast(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def ExtractLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def PopLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		#>

	def LastOccurrenceExtracted(pcSubStr)
		return This.ExtractLast(pcSubStr)

		def LastOccurrencePopped(pcSubStr)
			return This.ExtractLast(pcSubStr)

	  #------------------------------------------------#
	 #  EXTRACTING CHARS VERIFYING A GIVEN CONDITION  #
	#================================================#

	# Removes the chars from the string and returns them

	def ExtractCharsWCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)
		acResult = This.CharsAtPositions(anPos)
		return acResult

		def PopCharsWCS(pcCondition, pCaseSensitive)
			return This.ExtractCharsWCS(pcCondition, pCaseSensitive)

	def CharsExtractedWCS(pcCondition, pCaseSensitive)
		return This.ExtractCharsWCS(pcCondition, pCaseSensitive)

		def CharsPoppedWCS(pcCondition, pCaseSensitive)
			return This.CharsExtractedWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractCharsW(pcCondition)
		This.ExtractCharsWCS(pcCondition, TRUE)

		def PopCharsW(pcCondition)
			return This.ExtractCharsW(pcCondition)

	def CharsExtractedW(pcCondition)
		return This.ExtractCharsW(pcCondition)

		def CharsPoppedW(pcCondition)
			return This.CharsExtractedW(pcCondition)

	  #-----------------------------------------------------#
	 #  EXTRACTING CHARS VERIFYING A GIVEN CONDITION -- XT #
	#-----------------------------------------------------#

	def ExtractCharsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		This.RemoveCharsAtPositions(anPos)
		acResult = This.CharsAtPositions(anPos)
		return acResult

		def PopCharsWCSXT(pcCondition, pCaseSensitive)
			return This.ExtractCharsWCSXT(pcCondition, pCaseSensitive)

	def CharsExtractedWCSXT(pcCondition, pCaseSensitive)
		return This.ExtractCharsWCSXT(pcCondition, pCaseSensitive)

		def CharsPoppedWCSXT(pcCondition, pCaseSensitive)
			return This.CharsExtractedWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractCharsWXT(pcCondition)
		This.ExtractCharsWCSXT(pcCondition, TRUE)

		def PopCharsWXT(pcCondition)
			return This.ExtractCharsWXT(pcCondition)

	def CharsExtractedWXT(pcCondition)
		return This.ExtractCharsWXT(pcCondition)

		def CharsPoppedWXT(pcCondition)
			return This.CharsExtractedWXT(pcCondition)

	  #-----------------------------------------------------#
	 #  EXTRACTING SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#=====================================================#

	# Removes the chars from the string and returns them

	def ExtractSubstringsWCS(pcCondition, pCaseSensitive)
		aSections = This.FindSubstringsWCSZZ(pcCondition, pCaseSensitive)
		This.RemoveSubstringsAtSections(aSections)
		acResult = This.Sections(aSections)
		return acResult

		def PopSubstringsWCS(pcCondition, pCaseSensitive)
			return This.ExtractSubstringsWCS(pcCondition, pCaseSensitive)

	def SubstringsExtractedWCS(pcCondition, pCaseSensitive)
		return This.ExtractSubstringsWCS(pcCondition, pCaseSensitive)

		def SubstringsPoppedWCS(pcCondition, pCaseSensitive)
			return This.SubstringsExtractedWCS(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractSubstringsW(pcCondition)
		This.ExtractSubstringsWCS(pcCondition, TRUE)

		def PopSubstringsW(pcCondition)
			return This.ExtractSubstringsW(pcCondition)

	def SubstringsExtractedW(pcCondition)
		return This.ExtractSubstringsW(pcCondition)

		def SubstringsPoppedW(pcCondition)
			return This.SubstringsExtractedW(pcCondition)

	  #----------------------------------------------------------#
	 #  EXTRACTING SUBSTRINGS VERIFYING A GIVEN CONDITION -- XT #
	#----------------------------------------------------------#

	def ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)
		aSections = This.FindSubstringsWCSXTZZ(pcCondition, pCaseSensitive)
		This.RemoveSubstringsAtSections(aSections)
		acResult = This.Sections(aSections)
		return acResult

		def PopSubstringsWCSXT(pcCondition, pCaseSensitive)
			return This.ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)

	def SubstringsExtractedWCSXT(pcCondition, pCaseSensitive)
		return This.ExtractSubstringsWCSXT(pcCondition, pCaseSensitive)

		def SubstringsPoppedWCSXT(pcCondition, pCaseSensitive)
			return This.SubstringsExtractedWCSXT(pcCondition, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractSubstringsWXT(pcCondition)
		This.ExtractSubstringsWCSXT(pcCondition, TRUE)

		def PopSubstringsWXT(pcCondition)
			return This.ExtractSubstringsWXT(pcCondition)

	def SubstringsExtractedWXT(pcCondition)
		return This.ExtractSubstringsWXT(pcCondition)

		def SubstringsPoppedWXT(pcCondition)
			return This.SubstringsExtractedWXT(pcCondition)

	  #----------------------------------------#
	 #  EXTRACTING A SECTION FROM THE STRING  #
	#========================================#

	def ExtractSection(n1, n2)

		if CheckParams()
			if NOT ( Q([n1, n2]).BothAreNumbers() and
		   	Q(n1).IsBetween(1, This.NumberOfSubStrings()) and
		   	Q(n2).IsBetween(1, This.NumberOfSubStrings()) )

				StzRaise("Can't extract! The section is outside the string.")
			ok
		ok

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def PopSection(n1, n2)
			return This.ExtractSection(n1, n2)

		#>

	def SectionExtracted(n1, n2)
		return This.ExtractSection(n1, n2)

		#< @FunctionAlternativeForm

		def SectionPopped(n1, n2)
			return This.SectionExtracted(n1, n2)

		#>

	  #--------------------------------------#
	 #  EXTRACTING A RANGE FROM THE STRING  #
	#--------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

		def PopRange(nStart, nRange)
			return This.ExtractRange(nStart, nRange)

	def RangeExtracted(nStart, nRange)
		return This.ExtractRange(nStart, nRange)

		def RangePopped(nStart, nRange)
			return This.RangeExtracted(nStart, nRange)

	  #----------------------------------------------------------#
	 #  EXTRACTING NEXT SUBSTRING STARTING AT A GIVEN POSITION  #
	#----------------------------------------------------------#

	def ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		if This.FindNext(pcSubStr, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemoveSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return pcSubStr

		#< @FunctionAlternativeForms

		def ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
			This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractNextOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def NextExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrenceExtractedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractNextST(pcSubStr, pnStartingAt)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def ExtractNext(pcSubStr, pnStartingAt)
			This.ExtractNextST(pcSubStr, pnStartingAt)

		def ExtractNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#--

		def ExtractNextOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		def PopNextOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#>

	def NextOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractNextSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def NextExtracted(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrenceExtractedST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)
	
		def NextOccurrencePoppedST(pcSubStr, pnStartingAt)
			return This.ExtractNextST(pcSubStr, pnStartingAt)

		#>

	  #--------------------------------------------------------------#
	 #  EXTRACTING PREVIOUS SUBSTRING STARTING AT A GIVEN POSITION  #
	#--------------------------------------------------------------#

	def ExtractPreviousSTCS(substring, pnStartingAt, pCaseSensitive)
		if This.FindPreviousCS(substring, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemovePreviousCS(substring, pnStartingAt, pCaseSensitive)
		return substring

		#< @FunctionAlternativeForms

		def ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
			This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractPreviousOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def PreviousOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PreviousExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrenceExtractedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedSTCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractPreviousST(pcSubStr, pnStartingAt)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def ExtractPrevious(pcSubStr, pnStartingAt)
			This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def ExtractPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#--

		def ExtractPreviousOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		def PopPreviousOccurrenceST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#>

	def PreviousOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractPreviousSTCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def PreviousExtracted(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrenceExtractedST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePoppedST(pcSubStr, pnStartingAt)
			return This.ExtractPreviousST(pcSubStr, pnStartingAt)

		#>

	  #====================================#
	 #  FINDING OVERSPACES IN THE STRING  #
	#====================================#
	
	def FindOverSpaces()
		acChars = This.Chars()
		nLen = len(acChars)
	
		anResult = []
	
		if nLen < 2
			return anResult
		ok
	
		for i = 2 to nLen-1
			if acChars[i] = " " and acChars[i-1] = " "
				anResult + i
			ok
		next
	
		if acChars[nLen] = " " and acChars[nLen-1] = " "
			anResult + nLen
		ok
	
		return anResult
	
		def FindOverSpacesZ()
			return This.FindOverSpaces()
	
	def FindOverSpacesAsSections()
		anPos = This.FindOverSpaces() + 0
		nLen = len(anPos)
	
		if nLen < 2
			return []
		ok
	
		aResult = []
		n1 = anPos[1]
		
		for i = 2 to nLen - 1
			nCurrentPos = anPos[i]
			nPrevPos = anPos[i-1]
			nNextPos = anPos[i+1]
	
			if nCurrentPos = nPrevPos + 1
				if nNextPos = nCurrentPos + 1
				// Continue
		
				else
					aResult + [ n1, anPos[i] ]
					n1 = anPos[i+1]
				ok
			ok		
		next
	
	
		return aResult
	
		def FindOverSpacesZZ()
			return This.FindOverSpacesAsSections()
	
	def Overspaces()
		acResult = This.Sections( This.FindOverSpacesZZ() )
		return acResult
	
	def OverSpacesAndTheirsPositions()
		acSpaces = This.OverSpaces()
		anPos = This.FindOverSpaces()
		aResult = Association([ acSpaces, anPos ])
	
		return aResult
	
		def OverSpacesZ()
			return This.OverSpacesAndTheirPositions()
	
	def OverSpacesAndTheirSections()
		acSpaces = This.OverSpaces()
		aSections = This.FindOverSpacesAsSections()
		aResult = Association([ acSpaces, aSections ])
	
		return aResult
	
		def OverSpacesZZ()
			return This.OverSpacesAndTheirSections()
	
	def RemoveOverSpaces()
		This.RemoveSections( This.FindOverSpacesAsSections() )
	
		def RemoveOverSpacesQ()
			This.RemoveOverSpaces()
			return This
	
	def OverSpacesRemoved()
		cResult = This.Copy().RemoveOverSpacesQ().Content()
		return cResult
	
	def ReplaceOverSpaces(c)
		if isList(c) and StzListQ(c).IsWithOrByNamedParams()
			c = c[2]
		ok
	
		# Composing the substrings to rpelace the overspaces with
	
		aSections = This.FindOverSpacesAsSections()
		nLen = len(aSections)
	
		acSpaceSubStr = []
	
		for i = 1 to nLen
			cSubStr = ""
			nLenSubStr = len(aSections[i])
	
			for j = 1 to nLenSubStr
				cSubStr += c
			next
	
			acSpaceSubStr + cSubStr
		next
	
		# Doing the job
	
		This.ReplaceSectionsByMany(aSections, acSpaceSubStr)
	
		def ReplaceOverSpacesQ(c)
			This.ReplaceOverSpaces()
			return This
	
	def OverSpacesReplaced(c)
		cResult = This.Copy().ReplaceOverSpacesQ(c).Content()
		return cResult

	  #==========================================================#
	 #   SIMPLIFYING THE STRING BY REMOVING DUPLICATED SPACES   #
	#==========================================================#

	def Simplify()

		# t0 = clock() // Veryf fast, takes almost 0.01s

		This.Update( @oQString.simplified() )

		# ? ( clock() - t0 ) / clockspersecond()

		def SimplifyQ()
			This.Simplify()
			return This

	def Simplified()
		cResult = This.Copy().SimplifyQ().Content()
		return cResult

	  #-------------------------------------------------#
	 #   SIMPLIFYING THE STRING EXCEPT SOME SECTIONS   #
	#-------------------------------------------------#

	def SimplifyExcept(paSections)
		/* EXAMPLE

		o1 = new stzString(' this code:   txt1  = "    withspaces    "   and txt2="nospaces"  ')
		o1.SimplifyExcept( [ [], [] ] )

		#--> 'var txt = "    nice    "'

		*/

		if isList(paSections) and Q(paSections).IsSectionsNamedParam()
			paSections = paSections[2]
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aAntiSections = This.AntiSectionsAsPairsOfNumbers(paSections)
		nLen = len(aAntiSections)

		for i = nLen to 1 step -1

			n1 = aAntiSections[i][1]
			n2 = aAntiSections[i][2]

			cSection = This.Section(n1, n2)

			cSectionSimplified = Q(cSection).Simplified()

			if (n2 - n1 + 1) > 2
				if Q(cSection).LastChar() = " " and
				   Q(cSectionSimplified).Last2CharsAsString() != "  "
	
					cSectionSimplified += " "
	
				but Q(cSection).FirstChar() = " " and
				    Q(cSectionSimplified).First2CharsAsString() != "  "
	
					cSectionSimplified = " " + cSectionSimplified
				ok
			ok

			This.ReplaceSection(n1, n2, cSectionSimplified)
		next

		This.Trim()

		def SimplifyExceptQ(paSections)
			This.SimplifyExcept(paSections)
			return This

	def SimplifiedExcept(paSections)
		cResult = This.Copy().SimplifyExceptQ().Content()
		return cResult

	  #==========================#
	 #  SPACIFYING THE STRING   #
	#==========================#

	def SpacifyXT(pcSeparator, pnStep, pcDirection)
		/* EXAMPLE

		Basic mode:

		o1 = new stzString("99999999999")
		? o1.SpacifiedXT(:Separator = "_", :Step = 3, :Direction = :Backward)
		#--> 99_999_999_999

		Advanced mode:
		
		o1 = new stzString("99999999999")
		o1.SpacifyXT(
			:Using    = [ ".", :AndThen = " " ],
			:Stepping = [ 2, :AndThen = 3],
			:Going    = :Backward
		)
		
		? o1.Content()
		#--> 99 999 999.99

		*/

		cMode = :Basic
		cSeparator2 = ""
		nStep2 = 0

		# Checking params correctness

		if isList(pcSeparator) and Q(pcSeparator).IsOneOfTheseNamedParams([ :Using, :Separator ])
			pcSeparator = pcSeparator[2]
		ok

		if isList(pnStep) and Q(pnStep).IsOneOfTheseNamedParams([ :Step, :Stepping, :EachNChars ])
			pnStep = pnStep[2]
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# checking :Using = [ ".", :AndThen = " " ]
		if isList(pcSeparator) and (isString(pcSeparator[2]))

			cMode = :Extended
			pcSeparator = pcSeparator[1]
			cSeparator2 = pcSeparator[2]

		but isList(pcSeparator) and isList(pcSeparator[2]) and
		    Q(pcSeparator[2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isString(pcSeparator[2][2])

			cMode = :Extended
			cSeparator2 = pcSeparator[2][2]
			pcSeparator = pcSeparator[1]
			
		ok

		# checking :Stepping = [ 2, :AndThen = 3]
		if isList(pnStep) and (isNumber(pnStep[2]))

			cMode = :Basic
			pnStep = pnStep[1]
			nStep2 = pnStep[2]

		but isList(pnStep) and isList(pnStep[2]) and
		    Q(pnStep[2][2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isNumber(pnStep[2][2][2])

			cMode = :Extended
			nStep2 = pnStep[2][2][2]
			pnstep = pnStep[2][1]
			
		ok

		if NOT (isString(pcSeparator) and pcSeparator != "")
			StzRaise("Incorrect param type! pcSeparator must be a non null string.")
		ok

		if NOT (isNumber(pnStep) and pnStep != 0)
			StzRaise("Incorrect param type! pnStep must be a non null number.")
		ok

		# Doing the job

		nLen = This.NumberOfChars()

		if cMode = :Basic

			anPos = []
			if pcDirection = :Forward
					
				for i = (pnStep + 1) to nLen step pnStep
					anPos + i
				next

				This.InsertBeforeThesePositions(anPos, pcSeparator)

			but pcDirection = :Backward
		
				for i = (nLen - pnStep) to 1 step -pnStep

					anPos + i
				next

				This.InsertAfterThesePositions(anPos, pcSeparator)
			ok

			

		but cMode = :Extended
			
			nStart = 0
			if pcDirection = :Forward
				This.InsertBefore( pnStep + 1, pcSeparator )
				nStart = pnStep + nStep2 + 1
			else
				This.InsertBefore( nLen - pnStep + 1, pcSeparator )
				nStart = nLen - pnStep - nStep2
			ok

			pnStep = nStep2
			pcSeparator = cSeparator2
			anPos = []

			if pcDirection = :Forward
				for i = nStart to nLen step pnStep
					anPos + i
				next
		
			but pcDirection = :Backward
		
				for i = nStart to 1 step -pnStep
					anPos + i
				next
			ok

			This.InsertAfterThesePositions(anPos, pcSeparator)

		ok

		def SpacifyXTQ(pcSeparator, pnStep, pcDirection)
			This.SpacifyXT(pcSeparator, pnStep, pcDirection)
			return This

	def SpacifiedXT(pcSeparator, pnStep, pcDirection)
		return This.Copy().SpacifyXTQ(pcSeparator, pnStep, pcDirection).Content()

	  #----------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING   #
	#----------------------------------------#

	def SpacifyEachNChars(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsQ(n)
			This.SpacifyEachNChars(n)
			return This

	def EachNCharsSpacified(n)
		return This.Copy().SpacifyEachNCharsQ(n).Content()

	#--

	def SpacifyEachNCharsForward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsForwardQ(n)
			This.SpacifyEachNCharsForward(n)
			return This

	def EachNCharsSpacifiedForward(n)
		return This.Copy().SpacifyEachNCharsForwardQ(n).Content()

	#--

	def SpacifyEachNCharsBackward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Backward)

		def SpacifyEachNCharsBackwardQ(n)
			This.SpacifyEachNCharsBackward(n)
			return This

	def EachNCharsSpacifiedBackward(n)
		return This.Copy().SpacifyEachNCharsBackwardQ(n).Content()

	#--

	def SpacifyChars()
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").Spacified()
		#--> R I N G O R I A L A N D

		*/
		This.SpacifyXT(:Using = " ", :EachNChars = 1, :Forward)

		def SpacifyCharsQ()
			This.SpacifyChars()
			return This

		def Spacify()
			This.SpacifyChars()

			def SpacifyQ()
				This.Spacify()
				return This

		def SpacifyIt()
			This.SpacifyChars()

			def SpacifyItQ()
				This.Spacify()
				return This

	#-- PASSIVE FORM : TODO - Add this title for each passive form in the library

	def CharsSpacified()
		cResult = This.Copy().SpacifyCharsQ().Content()
		return cResult

		def Spacified()
			return This.CharsSpacified()

		#--

		def CharsSpacifiedQ()
		#TODO
		# Add the fluent form of each passive form in the libraray

			oResult = This.Copy().SpacifyCharsQ()
			return oResult

			def SpacifiedQ()
				return This.CharsSpacifiedQ()

		#< @FunctionFutureForm

		def SpacifiedFQ()
			@AddFutureXT(:Spacify, _cFutureOrder)
			return This

		#>

	#--

	def IsSpacified()
		if This.IsEqualTo(This.Spacified())
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionFutureForm

		def IsSpacifiedF()
			@AddFutureXT(:Spacify, _cFutureOrder)

		def IsSpacifiedFQ()
			@AddFutureXT(:Spacify, _cFutureOrder)
			return This

		#>

	  #----------------------------------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------#

	def SpacifyCharsUsing(pcSep)
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").SpacifiedUsing("_")
		#--> R_I_N_G_O_R_I_A_L_A_N_D

		*/

		This.SpacifyXT(:Using = pcSep, :EachNChars = 1, :Forward)

		def SpacifyCharsUsingQ(pcSep)
			This.SpacifyCharsUsing(pcSep)
			return This

		def SpacifyUsing(pcSep)
			This.SpacifyCharsUsing(pcSep)

			def SpacifyUsingQ(pcSep)
				This.SpacifiyUsing(pcSep)
				return This

	def CharsSpacifiedUsing(pcSep)
		cResult = This.Copy().SpacifyCharsUsingQ(pcSep).Content()
		return cResult

		def SpacifiedUsing(pcSep)
			return CharsSpacifiedUsing(pcSep)

		#--

		def SpacifiedUsingQ(pcSep)
			oResult = This.Copy().SpacifyCharsUsingQ(pcSep)
			return oResult

	  #--------------------------------------------------------------------------#
	 #  SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING USING A GIVEN SEPARATOR  #
	#--------------------------------------------------------------------------#

	def SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
		This.AddBoundsToSubStringCS(pcSubStr, pcSep, pcSep, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
			return This

		#>

	def SubStringSpacifiedUsingCS(pcSubStr, pcSep, pCaseSensitive)
		cResult = This.Copy().SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubstringUsing(pcSubStr, pcSep)
		This.SpacifySubStringUsingCS(pcSubStr, pcSep, TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringUsingQ(pcSubStr, pcSep)
			This.SpacifySubstringUsing(pcSubStr, pcSep)
			return This

		#>

	def SubStringSpacifiedUsing(pcSubStr, pcSep)
		cResult = This.Copy().SpacifySubStringUsingQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	  #----------------------------------------------------#
	 #   SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#----------------------------------------------------#

	def SpacifySubstringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
		This.BoundSections(aSections, " ")


		def SpacifySubStringCSQ(pcSubStr, pCaseSensitive)
			This.SpacifySubStringCS(pcSubStr, pCaseSensitive)
			return This

		def SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
			This.SpacifySubstringCS(pcSubStr, pCaseSensitive)

			def SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

	def SubStringSpacifiedCS(pcSubStr, pCaseSensitive)
		return This.Copy().SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive).Content()

		def ThisSubStringSpacifiedCS(pcSubStr, pCaseSensitive)
			return This.SubStringSpacifiedCS(pcSubStr, pCaseSensitive)

	#-- CASE-SENSITIVE

	def SpacifySubstring(pcSubStr)
		This.SpacifySubstringCS(pcSubStr, TRUE)

		def SpacifySubstringQ(pcSubStr)
			This.SpacifySubstring(pcSubStr)
			return This

		def SpacifyThisSubString(pcSubStr)
			This.SpacifySubstring(pcSubStr)

			def SpacifyThisSubStringQ(pcSubStr)
				This.SpacifyThisSubString(pcSubStr)
				return This

	def SubStringSpacified(pcSubStr)
		return This.Copy().SpacifyThisSubStringQ(pcSubStr).Content()

		def ThisSubStringSpacified(pcSubStr)
			return This.SubStringSpacified(pcSubStr)

	  #----------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING   #
	#----------------------------------------------#

	def SpacifySubStringsCS(pacSubStr, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("IbelieveinRingfutureandengageforit!")

		o1.SpacifyTheseSubStrings([
			"believe", "in", "Ring", "future", "and", "engage", "for"
		])

		#--> I believe in Ring future and engage for it!

		*/

		This.SpacifySubStringsUsingCS(pacSubStr, " ", pCaseSensitive)

		#< @FuncionFluentForm

		def SpacifySubStringsCSQ(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def SpacifyTheseCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This


		#>

	def SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
		return This.Copy().SpacifySubStringsCSQ(pacSubStr, pCaseSensitive).Content()

		def TheseSubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

		def TheseSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStrings(pacSubStr)
		This.SpacifySubStringsCS(pacSubStr, TRUE)

		def SpacifySubStringsQ(pacSubStr)
			This.SpacifySubStrings(pacSubStr)
			return This

		def SpacifyTheseSubStrings(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseSubStringsQ(pacSubStr)
				This.SpacifyTheseSubStrings(pacSubStr)
				return This

		def SpacifyThese(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseQ(pacSubStr)
				This.SpacifyThese(pacSubStr)
				return This

	def SubStringsSpacified(pacSubStr)
		return This.Copy().SpacifySubStringsQ(pacSubStr).Content()

		def TheseSubStringsSpacified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

		def TheseSpaccified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

	  #----------------------------------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------------#

	def SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

		if CheckParams()

			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				stzRaise("Incorrect param! pacSubStr must be a list of strings.")
			ok
	
	
			if NOT ( isList(pacSubStr) and @IsListOfStrings(pacSubStr) )
				stzRaise("Incorrect param! pacSubStr must be a list of strings.")
			ok

		ok

		aSections = This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		nLen = len(aSections)

		if nLen = 0
			return

		but nLen = 1
			This.BoundSection(aSections[1][1], aSections[1][2], " ")
			return
		ok

		# If some sections are included in others then remove them

		#TODO
		# Turn this to a method RemoveIncluded() in stzListOfPairs

		aSectionsXT = [] + aSections[1]
		for i = 2 to nLen
			if ( aSections[i][1] > aSections[i-1][1] and aSections[i][1] < aSections[i-1][2] ) and
			   ( aSections[i][2] > aSections[i-1][1] and aSections[i][2] < aSections[i-1][2] )

				// do nothing
			else

				aSectionsXT + aSections[i]
			ok
		next

		# Inserting the bounds around the sections

		nLen = len(aSectionsXT)
		This.InsertAfterPosition(aSectionsXT[nLen][2], " ")

		for i = nLen to 1 step -1
			n1 = aSectionsXT[i][1]
			This.InsertBeforePosition(n1, " ")
		next

		

		#< @FunctionFluentForm

		def SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseSubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		def SpacifyTheseUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		#>

	def SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
		return This.Copy().SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def TheseSubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		def TheseSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStringsUsing(pacSubStr, pcSep)
		This.SpacifySubStringsUsingCS(pacSubStr, pcSep, TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringsUsingQ(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)
			return This

		def TheseSpacifiedUsingUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)

			def SpacifyTheseSubStringsUsingQ(pacSubStr, pcSep)
				This.SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
				return This

		#>

	def SubStringsSpacifiedUsing(pacSubStr, pcSep)
		return This.Copy().SpacifySubStringsUsingQ(pacSubStr, pcSep).Content()

		def TheseSubStringsSpacifiedUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

	  #------------------------------------------#
	 #   SPACIFITYING A SECTION OF THE STRING   #
	#------------------------------------------#

	def SpacifySection(n1, n2)

		cLeftSpace = ""
		if This.CharAt(n1) != " "
			cLeftSpace = " "
		ok

		cRightSpace = ""
		if This.CharAt(n2)
			cRightSpace = " "
		ok

		This.ReplaceSection(n1, n2, :By = (cLeftSpace + This.Section(n1, n2) + cRightSpace) )

		def SpacifySectionQ(n1, n2)
			This.SpacifySection(n1, n2)
			return This

	def SectionSpacified(n1, n2)
		cResult = This.Copy().SpacifySectionQ(n1, n2).Content()
		return cResult

	  #----------------------------------------------#
	 #   SPACIFITYING MANY SECTIONS OF THE STRING   #
	#----------------------------------------------#

	def SpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		anPos = []
		for i = 1 to nLen
			anPos + paSections[i][1]
			anPos + (paSections[i][2] + 1)
		next

		This.InsertBeforePositions(anPos, " ")

		def SpacifySectionsQ(paSections)
			This.SpacifySections(paSections)
			return This

	def SectionsSpacified(paSections)
		cResult = This.Copy().SpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #   UNSPACIFYING THE STRING --> REMOVING SPACES  #
	#================================================#

	def UnSpacify()
		if This.Content() = ""
			return

		but This.NumberOfChars() = 1 and This.Content() = " "
			This.Clear()

		but This.NumberOfChars() = 2
			if This.Content() = " " + " "
				This.Update(" ")

			but This.Contains(" ")
				This.Remove(" ")
			ok

		else

			This.Trim()
		ok


		def UnSpacifyQ()
			This.UnSpacify()
			return This

	def Unspacified()
		return This.Copy().UnSpacifyQ().Content()

	  #------------------------------------------------------#
	 #   UNSPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#------------------------------------------------------#

	def UnSpacifySubStringCS(pcSubStr, pCaseSensitive)

		if NOT ( isString(pcSubStr) and Q(pcSubStr).ContainsSpaces() )
			StzRaise("Incorrect param! pcSubStr must be a string containing spaces.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.ReplaceSections( aSections, Q(pcSubStr).Unspacified() )

	def UnSpacifySubString(pcSubStr)
		This.UnSpacifySubStringCS(pcSubStr, TRUE)

	  #--------------------------------------------#
	 #   UNSPACIFITYING A SECTION OF THE STRING   #
	#--------------------------------------------#

	def UnSpacifySection(n1, n2)
		This.ReplaceSection(n1, n2, :By = Q(This.SectionQ(n1, n2).Unspacified()) )

		def UnSpacifySectionQ(n1, n2)
			This.UnSpacifySection(n1, n2)
			return This

	def SectionUnSpacified(n1, n2)
		cResult = This.Copy().UnSpacifySectionQ(n1, n2).Content()
		return cResult

	  #------------------------------------------------#
	 #   UNSPACIFITYING MANY SECTIONS OF THE STRING   #
	#------------------------------------------------#

	def UnSpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		paSections = @SortLists(paSections)
		nLen = len(paSections)

		for i = nLen to 1 step -1
			n1 = paSections[i][1]
			n2 = paSections[i][2]

			cSectionWithoutSpaces = This.SectionQ(n1, n2).Unspacified()
			This.ReplaceSection( n1, n2, cSectionWithoutSpaces )

		next

		def UnSpacifySectionsQ(paSections)
			This.UnSpacifySections(paSections)
			return This

	def SectionsUnSpacified(paSections)
		cResult = This.Copy().UnSpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #    GETTING POSITION AFTER A GIVEN SUBSTRING    #
	#================================================#

	def PositionAfterCS(cSubStr, pCaseSensitive)
		return This.PositionAfterNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionAfterNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		n = This.FindNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		oStr = new stzString(cSubStr)
		return n + oStr.NumberOfChars()

	def PositionAfter(cSubStr)
		return This.PositionAfterCS(cSubStr, TRUE)

	def PositionAfterNthOccurrence(n, cSubStr)
		return This.PositionAfterNthOccurrenceCS(n, cSubStr, TRUE)

	  #--------------------------------------------------#
	 #    GETTING POSITION BEFORE A GIVEN SUBSTRING     #
	#--------------------------------------------------#

	def PositionBeforeCS(cSubStr, pCaseSensitive)
		return This.PositionBeforeNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		return This.FindNthOccurrenceCS(cSubStr, pCaseSensitive)
	
	def PositionBefore(cSubStr)
		return This.PositionBeforeCS(cSubStr, :CaseSensitive = FALSE)

	def PositionBeforeNthOccurrence(n, cSubStr)
		return This.PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)

	  #------------------------------#
	 #   FINDING THE CENTRAL CHAR   #
	#------------------------------#
	
	// Returns the position (if any) of the central Char in the string
	def FindCentralChar()
		nResult = 0

		oNumberOfChars = new stzNumber(This.NumberOfChars())
		if oNumberOfChars.IsOdd()
			nResult = ( This.NumberOfChars() + 1 ) / 2
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindMiddleChar()
			return This.FindCentralChar()

		def PositionOfCentralChar()
			return This.FindCentralChar()

		def CentralCharposition()
			return This.FindCentralChar()

		def PositionOfMiddleChar()
			return This.FindCentralChar()

		def MiddleCharposition()
			return This.FindCentralChar()


		#>

	  #------------------------------#
	 #   GETTING THE CENTRAL CHAR   #
	#------------------------------#

	def CentralChar()
		if This.CentralCharPosition() != NULL
			return This.NthChar( This.CentralCharPosition() )
		ok

		def CentralCharQ()
			return This.CentralCharQR(:stzChar)
	
		def CentralCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar( This.CentralChar() )
			on :stzString
				return new stzString( This.CentralChar() )
			on :stzListOfBytes
				return new stzListOfBytes( This.CentralChar() )
			off

		def MiddleChar()
			return This.CentralChar()

	  #-----------------------------------------------#
	 #   DOES THE STRING CONTAIN ANY CENTRAL CHAR?   #
	#-----------------------------------------------#

	def ContainsCentralChar()
		return This.NumberOfCharsQ().IsNotEven()

		def ContainsMiddleChar()
			return This.ContainsCentralChar()

		def HasCentralChar()
			return This.ContainsCentralChar()

		def HasMiddleChar()
			return This.ContainsCentralChar()

	  #---------------------------------------------------#
	 #   DOES THE STRING CONTAIN A GIVEN CENTRAL CHAR?   #
	#---------------------------------------------------#

	def ContainsCharInTheCenter(c)
		return This.CentralChar() = c

		def ContainsCharInTheMiddle(c)
			return This.ContainsCharInTheCenter()

		def HasCharInTheCenter(c)
			return This.ContainsCharInTheCenter(c)

		def HasCharInTheMiddle(c)
			return This.ContainsCharInTheMiddle(c)

	  #----------------------------------------------------#
	 #    DOES THE STRING CONTAIN ANY MIDDLE SUBSTRING?   #
	#----------------------------------------------------#

	def ContainsMiddleSubstring()
		if This.NumberOfCharsQ().IsOdd()
			return TRUE

		else
			return FALSE
		ok

		def HasMiddleSubstring()
			return This.ContainsMiddleSubstring()

		def ContainsCentralSubString()
			return This.ContainsMiddleSubstring()

		def HasCentralSubString()
			return This.ContainsMiddleSubstring()

	  #---------------------------------------------------------#
	 #    DOES THE STRING CONTAIN A GIVEN MIDDLE SUBSTRING?    #
	#---------------------------------------------------------#

	def ContainsSubstringInTheMiddle(pcSubStr)
		if ObjectIsStzString(pcSubStr)
			pcSubStr = pcSubStr.Content()
		ok

		if This.MiddleSubstring() = pcSubStr
			return TRUE
		else
			return FALSE
		ok

		def HasSubstringInTheCenter(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

		def ContainsSubstringInTheCenter(c)
			return This.ContainsSubstringInTheMiddle(c)

		def HasSubstringInTheMiddle(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

	  #---------------------------------------------------#
	 #    GETTING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def MiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		cResult = ""

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			n1 = nNumberOfCharsOfOnePart + 1
			n2 = nNumberOfChars - nNumberOfCharsOfOnePart

			cResult = This.Section( n1, n2 )
		ok

		return cResult

		#< @FunctionALternativeForms

		def CentralSubstringWithNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringN(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringN(n)
			return This.MiddleSubstringWithNChars(n)


		#>

	  #---------------------------------------------------#
	 #    FINDING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def FindMiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		nResult = 0

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			nResult = nNumberOfCharsOfOnePart + 1
		ok

		return nResult

		#< @FunctionALternativeForms

		def FindCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#--

		def PositionOfMiddleSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#>

	  #--------------------------------#
	 #   GETTING STRING ORIENTATION   #
	#--------------------------------#

	/*
	Note that we distinguish between string 'orientation', 
	char 'orientation', and char 'unicode direction'.

	The first says if a string is left-to-right or right-to-left oriented, and
	uses the Orientation() method, here, in stzString.

	The second says the same thing for the individual chars, and uses
	the Orientation() method on stzChar.

	While the third informs us about the technical direction of the char,
	in terms of UNICODE standard, and is returned using UnicodeDirection()
	method on stzChar.
	*/

	// Returns the orientation of the string (:RightToLeft OR :LeftToRight)
	def Orientation()
		if This.IsRightToLeft()
			return :RightToLeft
		else
			return :LeftToRight
		ok

	// Verifies if the string is right-to-left (like arabic) : SEE Orientation()
	def IsRightToleft()
		bResult = @oQString.isRightToleft()

		return bResult

	// Verifies if the string is left-to-right (like english)
	def IsLeftToRight()
		IF NOT This.IsRightToLeft()
			return TRUE
		else
			return FALSE

		ok

	// Checks if the text is hybrid (containing :RightToLeft AND :LeftToRight" texts)
	def ContainsHybridOrientation()
		aStzChars = This.ToListOfStzChars()

		bIsHybrid = FALSE
		cFlag = aStzChars[1].Orientation()

		for i=2 to len(aStzChars)
			if aStzChars[i].Orientation() != cFlag
				bIsHybrid = TRUE
				exit
			ok
		next

		return bIsHybrid

	// Transforms the string to a list of chars with indication of their orientation
	def CharsWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)
			aResult + [ This.Char(i) , oTempChar.Orientation() ]
		next

		return aResult

	def CharsWithOrientationQ()
		return new stzList( This.CharsWithOrientation() )

	// Transforms the string to a list of letters with indication of their orientation
	def LettersWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)

			if oTempChar.isLetter()
				aResult + [ This.Char(i) , oTempChar.Orientation() ]
			ok
		next

		return aResult

	def LettersWithOrientationQ()
		return new stzList( This.LettersWithOrientation() )

	  #----------------------#
	 #     ONLY NUMBERS     #
	#----------------------#
		
	/* Returns (as a string) only the numbers contained in the string

	   Note: if the string contains "", for example, then it is returned
	   as the number 36 contained in a string ("36")!

	   To return just numbers formed from decimal digits from 0 to 9,
	   use OnlyDecimalDigits()
	*/

	def OnlyNumbers()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsANumber()
				cResult += c
			ok
		next
		return cResult

		def OnlyNumbersQ()
			return new stzString( This.OnlyNumbers() )

	def OnlyDecimalDigits()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsDecimalDigit()
				cResult += c
			ok
		next
		return cResult

	def OnlyDecimalDigitsQ()
		return new stzList( This.OnlyDecimalDigits() )

	  #------------------------------------------#
	 #     ONLY LETTERS AND SPACES ANS CHARS    #
	#------------------------------------------#

	// Returns (as a string) only the letters contained in the string
	def OnlyLetters()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.isLetter()
				cResult += c
			ok
		next
		return cResult

	def OnlyLettersQ()
		return new stzList(This.OnlyLetters())

	#----

	def OnlyLettersAndSpaces()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			if StzCharQ(c).IsLetterOrSpace()

				cResult += c
			ok
		next

		return cResult

	def OnlyLettersAndSpacesQ()
		return new stzString( This.OnlyLettersAndSpaces() )

	#----

	def OnlyLettersAndSpacesAndChar(pcChar)

		# t0 = clock() # Takes almost 0.62s

		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsLetterOrSpaceOrChar(pcChar)
				cResult += c
			ok
		next

		# ? ( clock() - t0 ) / clockspersecond()

		return cResult

		def OnlyLettersAndSpacesAndThisChar(pcChar)
			return This.OnlyLettersAndSpacesAndChar(pcChar)

	def OnlyLettersAndSpacesAndCharQ(pcChar)
		return new stzString( This.OnlyLettersAndSpacesAndChar(pcChar) )

		def OnlyLettersAndSpacesAndThisCharQ(pcChar)
			return OnlyLettersAndSpacesAndCharQ(pcChar)

	#----

	def OnlyLettersAndSpacesAndChars(pacChars)
		return This.ItemsWhere('isLetter(@item) or isSpace(@item) or Q(@item).IsOneOfThese(pacChars)')

		def OnlyLettersAndSpacesAndCharsQ(paChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

		def OnlyLettersAndSpacesAndTheseChars(pacChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

	def IsLetterOrSpaceOrChar(pcChar)
		return This.IsLetterOrSpaceOrOneOfTheseChars([ pcChar ])

		def IsLetterOrSpaceOrThisChar(pcChar)
			return IsLetterOrSpaceOrChar(pcChar)

	def IsLetterOrSpaceOrChars(pacChar)
		bResult = FALSE

		if This.IsLetter() or This.IsSpace() or
		   This.IsOneOfThese(pacChars)

			return TRUE
		else
			return FALSE
		ok

		def IsLetterOrSpaceOrOneOfTheseChars(pacChar)
			return This.IsLetterOrSpaceOreChars(pacChar)

	  #==========================#
	 #    ALIGNING THE STRING   #
	#==========================#

	def Align(pcDirection)
		This.AlignXT( :Max, " ", pcDirection )

		#< @FunctionFluentForms

		def AlignQ(pcDirection)
			This.Align(pcDirection)
			return This

		def AlignQC(pcDirection)
			return This.Copy().Align(pcDirection)

		#>

		#< @FunctionAlternativeForms

		def AlignTo(pcDirection)
			This.Align(pcDirection)

			def AlignToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AlignToQC(cDirection)
				return This.AlignQC(cDirection)

		def Adjust(pcDirection)
			This.Align(pcDirection)

			def AdjustQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustQC(cDirection)
				return This.AlignQC(cDirection)

		def AdjustTo(pcDirection)
			This.Align(pcDirection)

			def AdjustToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustToQC(cDirection)
				return This.AlignQC(cDirection)
		#>
		
	def Aligned(cDirection)
		return This.Copy().AlignQ(cDirection).Content()

		#< @FunctionAlternativeForms

		def AlignedTo(cDirection)
			return This.Aligned(cDirection)

		def Adjusted(cDirection)
			return This.Aligned(cDirection)

		def AdjustedTo(cDirection)
			return This.Aligned(cDirection)

		#>
	  #-----------------------------------#
	 #  ALIGNING THE STRING -- EXTENDED  #
	#-----------------------------------#

	// Aligns the text in a container of width nWidth
	// Note: if the width is smaller then the string, nothing is done!

	def AlignXT(nWidth, cChar, cDirection)
		# cChar is the char to fill the 'blanks" with.

		if isList(nWidth) and Q(nWidth).IsWidthNamedParam()
			nWidth = nWidth[2]
		ok

		if isList(cChar) and ( Q(cChar).IsUsingNamedParam() or
			Q(cChar).IsCharNamedParam() )

			cChar = cChar[2]
		ok

		if isString(cChar) and cChar = ""
			cChar = " "
		ok

		if isList(cDirection) and ( Q(cDirection).IsOneOfTheseNamedParams([ :Direction, :Going ]) or
			Q(cDirection).IsToNamedParam() )

			cDirection = cDirection[2]
		ok

		switch cDirection

		on :Left
			return This.AlignLeftXT(nWidth, cChar)

		on :Right
			return This.AlignRightXT(nWidth, cChar)

		on :Center
			return This.AlignCenterXT(nWidth, cChar)

		on :Justified
			return This.JustifyXT(nWidth, cChar)

		other
			stzRaise(stzStringError(:UnsupportedStringJustificationDirection))
		end

		#< @FunctionFluentForm

		def AlignXTQ(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def AdjustXT(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)

			def AdjustXTQ(nWidth, cChar, cDirection)
				return This.AlignXTQ(nWidth, cChar, cDirection)

		#>

	def AlignedXT(nWidth, cChar, cDirection)
		cResult = This.Copy().AlignXTQ(nWidth, cChar, cDirection).Content()
		return cResult

		def AdjustedXT(nWidth, cChar, cDirection)
			return This.AlignedXT(nWidth, cChar, cDirection)

	  #-----------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT  #
	#-----------------------------------#

	def LeftAlign(nWidth)
		This.LeftAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def LeftAlignQ(nWidth)
			This.LeftAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AlignToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def LeftAdjust(nWidth)
			This.LeftAlign(nWidth)

			def LeftAdjustQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		#>

	def LeftAligned(nWidth)
		cResult = This.Copy().LeftAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		def LeftAdjusted(nWidth)
			return This.LeftAligned(nWidth)

		def AdjustedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		#>

	  #-----------------------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT -- EXTENDED  #
	#-----------------------------------------------#

	def LeftAlignXT(nWidth, cChar)

		/* NOTE

		Managing the special case of the arabic char (Shaddah)
		which can alter the justification of text, because Qt
		treats it as a spearate char with its own position in
		the resulting string, while it must set on top of chars!

		Note: The same case of arabic diacritics (7araket)
		is not managed in this version (In the future,
		an extended arabic library will manage those (and other)
		specificities of arabic language.

		WARNING: In this version, if your arabic text contains
		arabic diactritics (7arakets), then the alignment
		won't be correct!

		Also, for this alignement to work as expected, the font
		you use in to display the text on the console must be
		of "fixed size".

 		*/

		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the alignment using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			// Take in account a logical error of Qt in aligning non
			// left-to-right strings (like arabic and hebrew)

			if This.IsRightToLeft()
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def LeftAlignXTQ(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeftXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def AlignLeftXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		def LeftAdjustXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def LeftAdjustXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		#>

	def LeftAlignedXT(nWidth, cChar)
		cResult = This.Copy().LeftAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeftXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		def LeftAdjustedXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		#>

	  #------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT  #
	#------------------------------------#

	def RightAlign(nWidth)
		This.RightAlignXT(nWidth, " ")

		#< @FunctioFluentForm

		def RightAlignQ(nWidth)
			This.RightAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRight(nWidth)
			This.RightAlign(nWidth)

			def AlignRightQ(nWidth)
				return This.RightAlignQ(nWidth)

		def AlignToRight(nWidth)
			This.RightAlign(nWidth)

			def AlignToRightQ(nWidth)
				return This.RightAlignQ(nWidth)
	
		def RightAdjust(nWidth)
			This.RightAlign(nWidth)

			def RightAdjustQ(nWidth)
				return This.RightAlignQ(nWidth)

		#>

	def RightAligned(nWidth)
		cResult = This.Copy().RightAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRight(nWidth)
			return This.RightAligned(nWidth)

		def RightAdjusted(nWidth)
			return This.RightAligned(nWidth)

		def AdjustedtoRight(nWidth)
			return This.RightAligned(nWidth)

		#>

	  #------------------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT -- EXTENDED  #
	#------------------------------------------------#

	def RightAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			if This.IsRightToLeft()
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def RightAlignXTQ(nWidth, cChar)
			
			This.RightAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRightXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def AlignRightXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		def RightAdjustXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def RightAdjustXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		#>

	def RightAlignedXT(nWidth, cChar)
		cResult = This.Copy().RightAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def RightAdjustedXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def AdjustedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		#>

	  #------------------------#
	 #  CENTERING THE STRING  #
	#------------------------#

	def CenterAlign(nWidth)
		This.CenterAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def CenterAlignQ(nWidth)
			This.CenterAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AlignCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def CenterAdjust(nWidth)
			This.CenterAlign(nWidth)

			def CenterAdjustQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def Center(nWidth)
			This.CenterAlign(nWidth)

			def CenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		#>

	def CenterAligned(nWidth)
		cResult = This.Copy().CenterAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def AdjustedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def CenterAdjusted(nWidth)
			return This.CenterAligned(nWidth)

		def Centered(nWidth)
			This.CenterAligned(nWidth)

		#>

	  #------------------------------------#
	 #  CENTERING THE STRING -- EXTENDED  #
	#------------------------------------#

	def CenterAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth > This.NumberOfChars()

			n = nWidth - This.NumberOfChars()
			n1 = 0
			n2 = 0

			oNumber = new stzNumber(n)
			if oNumber.IsEven()
				n1 = n / 2
				n2 = n1
			else
				n1 = (n - 1) / 2
				n2 = n1 + 1
			ok

			cResult = StringRepeat(cChar, n1) +
				  This.String() +
				  StringRepeat(cChar, n2)

			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def CenterAlignXTQ(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AlignToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterAdjustXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterAdjustXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		#>

	def CenterAlignedXT(nWidth, cChar)
		cResult = This.Copy().CenterAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenterAdjustedXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def AdjustedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenteredXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		#>

	  #-------------------------#
	 #  JUSTIFYING THE STRING  #
	#-------------------------#

	def Justify(nWidth)
		This.JustifyXT(nWidth, " ")

		def JustifyQ(nWidth)
			This.Justify(nWidth)
			return This

		// NEW: returns a jystified copy of the string object
		// --> Useful in copy-on-right (functional) programming
		def JustifyQC(nWith)
			return This.Copy().Justify(nWidth)

	def Justified(nWidth)
		return This.Copy().JustifyQ(nWidth).Content()

	  #-------------------------------------#
	 #  JUSTIFYING THE STRING -- EXTENDED  #
	#-------------------------------------#

	def JustifyXT(nWidth, pcChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth <= This.NumberOfChars()
			return NULL
		ok

		nPoints = nWidth - This.NumberOfChars()
		aTemp = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen - 1

			cCurrentChar = This.Char(i)

			if NOT ( CharIsArabicShaddah(cCurrentChar) or CharIsArabic7arakah(cCurrentChar) )

				aTemp + cCurrentChar
			else
				if len(aTemp) != 0
					aTemp[ len(aTemp) ] = aTemp[ len(aTemp) ] + cCurrentChar
				ok
			ok
		next

		while nPoints > 0
			for i = 1 to len(aTemp)
				aTemp[i] = aTemp[i] + pcChar
				nPoints--
				if nPoints = 0 { exit }
			next
		end

		aTemp + This.LastChar()

		cResult = ""
		for str in aTemp
			cResult += str
		next

		cResult = Q(cResult).ReplaceQ(" ", pcChar).Content()
		This.Update( cResult )

		def JustifyXTQ(nWidth, pcChar)
			This.JustifyXT(nWidth, pcChar)
			return This

	def JustifiedXT(nWidth, pcChar)
		cResult = This.Copy().JustifyXTQ(nWidth, pcChar).Content()

	  #==================================#
	 #    TEXT ENCODING & CONVERTING    #
	#==================================#

	//Returns a UTF-8 representation of the string (using QByteArray)
	def ToUTF8()
		return QByteArrayToListOfUnicodes(@oQString.toUtf8())

	def ToUTF8Q()
		return new stzString( This.ToUTF8() )

	def FromUTF8(pcUTF8String)
		// TODO

	def ToLatin1()
		return @oQString.toLatin1()

	def FromLatin1(pcLatin1String)
		// TODO

	def ToLocal8Bit()
		return @oQString.toLocal8Bit()

	def ToBase64()
		return This.ToStzListOfBytes().ToBase64()

		def ToBase64Q()
			return new stzString( This.ToBase64() )

	// Transforms the content of the string to a url-like encoded string
	def ToPercentEncoding(pcExcludedFromEncoding, pcIncludedInEncoding, pcPercentAsciiChar)
		/* Example:
		o1 = new stzString("{a fishy string?}")
		? o1.ToPercentEncoding( "{}", "s" )

		--> {a%20fi%73hy%20%73tring%3F}
		*/

	// Updates the list of bytes with an url-like decoded copy of the provided string
	def FromPercentEncoding(pcPercentEncodedString, pcPercentAsciiChar) // TODO
		/* Example:
		o1 = new stzString("")
		o1.FromPercentEncoding( "{a%20fi%73hy%20%73tring%3F}", "%" )
		o1.Content()

		--> {a fishy string?}
		*/

		StzRaise("Feature not implemented yet!")

	  #-----------------------------#
	 #  WORKING WITH THE HEX FORM  #
	#=============================#

	def ToHex()

		cResult = HexPrefix() + str2hex( This.String() )
		return cResult

		def ToHexQ()
			return new stzString( This.ToHex() )

	def ToHexWithoutPrefix()
		cResult = str2hex( This.String() )
		return cResult

		def ToHexWithoutPrefixQ()
			return new stzString( This.ToHexWithoutPrefix() )

	def FromHex(cHex)
		@oQString = new QString2()
		@oQString.append(hex2str(cHex))

		def FromHexQ(cHex)
			This.FromHex(cHex)
			return This

	def Hexcodes()
		acResult = This.ToStzListOfBytes().HexCodes()
		return acResult

	def HexPerByte()
		aResult = This.ToStzListOfBytes().HexPerByte()

		def HexcodePerByte()
			return This.HexPerByte()

	def HexcodesWithoutPrefix()
		acResult = This.ToStzListOfBytes().HexCodesWithoutPrefix()
		return acResult

	def HexPerByteWithoutPrefix()
		aResult = This.ToStzListOfBytes().HexPerByteWithoutPrefix()

	def ToHexSeparated(pcSep)
		cResult = This.ToStzListOfBytes().ToHexSeparated(pcSep)

		#< @FunctionAlternativeForm

		def ToHexSeparatedBy(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		def ToHexSeparatedWith(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		def ToHexSeparatedUsing(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexSeparated(pcSep)

		#>

	def ToHexSpacified()
		return This.ToHexSeparatedBy(" ")

	#--

	def ToHexWithoutPrefixSeparated(pcSep)
		cResult = This.ToStzListOfBytes().ToHexWithoutPrefixSeparated(pcSep)

		#< @FunctionAlternativeForm

		def ToHexWithoutPrefixSeparatedBy(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		def ToHexWithoutPrefixSeparatedWith(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		def ToHexWithoutPrefixSeparatedUsing(pcSep)
			if CheckParams()
				if NOT isString(pcSep)
					StzRaise("Incorrect param type! pcSep must be a string.")
				ok
			ok

			return This.ToHexWithoutPrefixSeparated(pcSep)

		#>

	def ToHexWithoutPrefixSpacified()
		return This.ToHexWithoutPrefixSeparatedBy(" ")

	def ToHexUTF8()
		cResult = This.ToStzListOfBytes().ToHexUTF8()
		return cResult

	  #---------------------------------------------#
	 #  Escaping HTML special Chars in the string  #
	#=============================================#

	def EscapeHtml()
		cResult = @oQString.toHtmlEscaped()

		return cResult

		def EscapeHtmlQ()
			return new stzString( This.EscapeHtml() )

	def HtmlEscaped()
		return This.EscapeHtmlQ().Content()

	  #=======================================#
	 #  TRANSFORMING THE STRING TO A NUMBER  #
	#=======================================#

	def ToNumber()
		if This.IsNumberInString()
			cNumber = This.Copy().RemoveQ("_").Content()
			nResult = 0+ cNumber
			return nResult

		else
			StzRaise("Incorrect value! The string does not contain a well formed number.")
		ok

	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// Transforms the string to a number based on the defined format
	// --> TODO: Use the ApplyFormat() method in the stzNumber class...
	// Rething the naming!
	def ToNumberFormatted(cFormat) // TODO
		/*
		o1 = new stzString("+12500,14")
		? o1.ToNumberFormatted( :As = "+99 999.99") --> 12 500.14
		*/

		stzRaise("Function unavailable in this version!")

		def ToNumberFormattedQ(cFormat)
			return new stzNumber( This.ToNumberFormatted() )

	  #================================================#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#================================================#

	// Returns a list of unicodes of all the Chars in the string
	def Unicodes()
		aResult = []
		for i = 1 to This.NumberOfChars()
			aResult + This.UnicodeOfCharN(i)
		next

		return aResult

		#< @FunctionFluentForms

		def UnicodesQ()
			return This.UnicodesQR(:stzList)

		def UnicodesQR(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Unicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Unicodes() )

			other
				stzRaise("Unsupported return type!")
			off

		#>


	def Unicode()
		if This.NumberOfChars() = 1
			return This.UnicodeOfCharN(1)

		else
			return This.Unicodes()
		ok

	def CharsAndUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.UnicodeOfCharN(i) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def CharsAndTheirUnicodes()
			return This.CharsAndUnicodes()

		def UnicodesPerChar()
			return This.CharsAndUnicodes()

		def UnicodePerChar()
			return This.CharsAndUnicodes()

		#>

	def CharsAndUnicodesU()
		aResult = U( This.CharsAndUnicodes() )
		return aResult

		#< @FunctionAlternativeForms

		def CharsAndTheirUnicodesU()
			return This.CharsAndUnicodesU()

		def UnicodesPerCharU()
			return This.CharsAndUnicodesU()

		def UnicodePerCharU()
			return This.CharsAndUnicodesU()

		#>

	def UnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.UnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def UnicodesAndTheirChars()
			return This.UnicodesAndChars()

		def UnicodesXT()
			return This.UnicodesAndChars()

		def CharsPerUnicode()
			return This.UnicodesAndChars()

		def CharPerUnicode()
			return This.UnicodesAndChars()

		#>

	def UnicodesAndCharsU()
		aResult = U( This.UnicodesAndChars() )
		return aResult

		#< @FunctionAlternativeForms

		def UnicodesAndTheirCharsU()
			return This.UnicodesAndCharsU()

		def UnicodesXTU()
			return This.UnicodesAndCharsU()

		def CharsPerUnicodeU()
			return This.UnicodesAndCharsU()

		def CharPerUnicodeU()
			return This.UnicodesAndCharsU()

		#>

	// The following method is mainly used by stzChar class to
	// create a characrer object from text
	def UnicodeOfCharN(n)
		oTempQStr = new QString2()
		oTempQStr.append(This[n])
		return oTempQStr.unicode().unicode()
		/*
		The first unicode() on QString returns a QChar,
		while the seconde unicode() on this QChar returns
		the actual decimal unicode of the Char
		*/

		#< @FunctionAlternativeForms

		def UnicodeOfNthChar(n)
			return This.UnicodeOfCharN(n)

		def NthCharUnicode(n)
			return This.UnicodeOfCharN(n)

		#>

	  #-------------------------------------------------#
	 #   HEXUNICODE CODES OF THE CHARS OF THE STRING   #
	#-------------------------------------------------#

	// Returns a list of hexunicodes of all the Chars in the string
	def HexUnicodes()
		acResult = []
		for i = 1 to This.NumberOfChars()
			acResult + This.HexUnicodeOfCharN(i)
		next

		return acResult

		#< @FunctionFluentForms

		def HexUnicodesQ()
			return This.HexUnicodesQR(:stzList)

		def HexUnicodesQR(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.HexUnicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.HexUnicodes() )

			other
				stzRaise("Unsupported return type!")
			off

		#>


	def HexUnicode()
		if This.NumberOfChars() = 1
			return This.HexUnicodeOfCharN(1)

		else
			return This.HexUnicodes()
		ok

	def CharsAndHexUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.HexUnicodeOfCharN(i) ]
		next

		return aResult

		def CharsAndTheirHexUnicodes()
			return This.CharsAndHexUnicodes()

		def HexUnicodesPerChar()
			return This.CharsAndHexUnicodes()

	def HexUnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.HexUnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		def HexUnicodesAndTheirChars()
			return This.HexUnicodesAndChars()

		def HexUnicodesXT()
			return This.HexUnicodesAndChars()

	
		def CharsPerHexUnicode()
			return This.HexUnicodesAndChars()

	def HexUnicodeOfCharN(n)
		cResult = StzCharQ(This.Char(n)).HexUnicode()
		return cResult

		#< @FunctionAlternativeForms

		def HexUnicodeOfNthChar(n)
			return This.HexUnicodeOfCharN(n)

		def NthCharHexUnicode(n)
			return This.HexUnicodeOfCharN(n)

		#>

	  #-------------------------------------#
	 #   GETTING CHARS NAME (IN UNICODE)   #
	#-------------------------------------#

	def CharsNames()

		acChars = This.Chars()
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			acResult + StzCharQ(acChars[i]).Name()
		next

		return acResult

		#< @FunctionFleuntForms

		def CharNamesQ()
			return This.CharNamesQR(:stzList)

		def CharNamesQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.CharNames())

			on :stzListOfStrings
				return new stzListOfString(This.CharNames())

			else
				stzRaise("Unsupported return type!")
			off

		#>

	  #--------------------------------------------------#
	 #  GETTING THE NAME OF THE STRING IF IT IS A CHAR  #
	#--------------------------------------------------#
	# If the string contains more then 1 char, only the first is processed

	def CharName()
		if NOT This.IsEmpty()
			return This.CharsNames()[1]
		ok

		def CharNameQ()
			return new stzString(This.CharName())


	  #-----------------------------------#
	 #  REMOVING DOTS ON DOTTED LETTERS  #
	#-----------------------------------#

	def RemoveDots()
		#TODO: Needs a better data stracture to deal with some special cases

		acChars = This.Chars()
		anLettersPos = This.FindLetters()
		nLen = len(anLettersPos)

		for i = 1 to nLen
			n = anLettersPos[i]

			cDotless = DotlessLettersXT()[ acChars[n] ]

			if cDotless != ""
				This.ReplaceNthChar(n, cDotless)
			ok
		next

		#< @FunctionFluentForm

		def RemoveDotsQ()
			This.RemoveDots()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDotsOnLetters()
			This.RemoveDots()

			def RemoveDotsOnLettersQ()
				This.RemoveDotsQ()

		#>

	def DotsRemoved()
		cResult = This.Copy().RemoveDotsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def DotsOnLettersRemoved()
			return This.DotsRemoved()

		def WithoutDots()
			return This.DotsRemoved()

		def WithoutDotsOnLetters()
			return This.DotsRemoved()

		def Dotless()
			return This.DotsRemoved()

		#>

	  #===============================#
	 #    MULTINGUAL & LOCLAE INFO   #
	#===============================#

	/*
	In Softanza, a unicode code of a language, country or locale can be:
		* number : like "6" for arabic
		* name : like "arabic" for arabic
		* abbreviation : like "ar" (short form) and "ara" (long form) for arabic
	*/

	def IsLanguageIdentifier()
		return 	This.IsLanguageNumber() or
			This.IsLanguageAbbreviation() or
			This.IsLanguageName()

	def IsLanguageNumber()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if aLanguageInfo[1] = This.String()
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsLanguageCode()
			return This.IsLanguageNumber()

	def IsShortLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLongLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageAbbreviation()
		/* Could be written expressively like this:

		return This.IsLanguageShotAbbreviation() OR This.IsLanguageLongAbbreviation()

		but the following is mutch more efficient: */

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()

			if lower(aLanguageInfo[3]) = lower(This.String()) OR
			   lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageShortAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageLongAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def LanguageAbbreviationForm()

		if NOT This.IsLanguageAbbreviation()
			cForm = :NotLanguage
		
		else

			if This.IsLanguageShortAbbreviation()
				cForm = :Short

			but This.IsLanguageLongAbbreviation()
				cForm = :Long
			ok
		ok

		return cForm

	def IsLanguageName() # In english

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[2]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsNotLanguageName()
			return NOT This.IsLanguageName()

	def IsNativeLanguageName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzStringError(:UnsupportedFeatureInThisVersion)) #TODO

	def IsCountryIdentifier()
		return 	This.IsCountryNumber() or
			This.IsCountryAbbreviation() or
			This.IsCountryName() or
			This.IsCountryPhoneCode()

	def IsCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr) OR
			   UPPER(aCountryInfo[4]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsCountryName()
		if This.IsEmpty() { return FALSE }

		cName = This.String()
		bResult = FALSE
		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[2]) = lower(cName)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsNotCountryName()
			return NOT This.IsCountryName()

	def IsNativeCountryName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzString(:UnsupportedFeatureInThisVersion))

	def IsCountryPhoneCode()
		if This.IsEmpty() { return FALSE }

		cPhoneCode = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if aCountryInfo[5] = cPhoneCode
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def IsCountryNumber()
		if This.IsEmpty() { return FALSE }

		cNumber = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[1]) = lower(cNumber)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsCountryCode()
			return This.IsCountryNumber()

	def IsShortCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryShortAbbreviation()
			return This.IsShortCountryAbbreviation()

	def IsLongCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[4]) = UPPER(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryLongAbbreviation()
			return This.IsLongCouontryAbbreviation()

	def IsCountryAbbreviationXT()
		/*
		Returns :
		[ TRUE, :Short ] or [ :TRUE, :Long ] or [ FALSE, NULL ]
		*/

		if This.IsEmpty() { return FALSE }

		bAbbr = This.IsCountryAbbreviation()
		ctype = :Nothing

		if This.IsShortCountryAbbreviation()
			cType = :Short
		but This.IsLongCountryAbbreviation()
			cType = :Long
		ok

		return [ bAbbr, cType ]
	
	def IsScriptIdentifier()
		return 	This.IsScriptNumber() or
			This.IsScriptAbbreviation() or
			This.IsScriptName()

	# Script abbreviation can't be short or long, it is always 4 chars long!
	def IsScriptAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[3]) = lower(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsScriptName()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[2]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScript()
			return This.IsScriptName()

		def IsNotScriptName()
			return NOT This.IsScriptName()

	def IsScriptNumber()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[1]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScriptCode()
			return This.IsScriptNumber()

	def IsLocaleAbbreviation()
		cThisString = ", " + This.Copy().ReplaceQ("_", "-").Content() + ","
		oLocalesInString = StzStringQ( ", " + LocaleAbbreviationsHostedInString() + "," )
		bResult = oLocalesInString.ContainsCS( cThisString, :CaseSensitive = FALSE )

		return bResult
	
	def ContainsLocaleSeparator()
		return This.Contains("_") or This.Contains("-")

	def ExtractLocaleSeparator()

		if This.ContainsLocaleSeparator()
			if This.Contains("_")
				return "_"

			but This.Contains("-")
				return "-"
			ok
		ok

	def ContainsNoLocaleSeparator()
		return NOT This.ContainsLocaleSeparator()

	def ContainsOneLocaleSeparator()
		return This.ContainsNTimes(1, "_") or
			This.ContainsNTimes(1, "_")

	def IsLocaleSeparator()
		return This.Content() = "_" or This.Content() = "-"

	def IsCurrencyName()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE

		#TODO: Replace for/in with for --> better performance
		for aCurrencyInfo in CurrenciesXT()
			if lower(aCurrencyInfo[1]) = This.Lowercased()
				bResult = TRUE
				exit
			ok
		next

		return bResult	

	def IsCurrencySymbol()	#TODO
		if This.IsEmpty() { return FALSE }
		
	def IsBp64LocaleAbbreviation() # Like "ar-TN" for example
		if This.IsEmpty() { return FALSE }

		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsDayName() # In english

		return This.IsDayNameIn(:English)

	def IsDayNameIn(pcLanguageName)
		if This.IsEmpty() { return FALSE }

		return This.LowercaseQ().IsOnOfThese(NamesOfDaysIn(pcLanguageName))

	def IsNativeDayNameInLocale(pLocale) # Locale-specific
		if This.IsEmpty() { return FALSE }

		return This.IsEqualToCS(StzLocaleQ(pLocale).NativeDayName(), :CaseSensitive = FALSE)

	def IsMonthName() # In english
		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsNativeMonthName() # Locale-specific
		stzRaise(:UnsupportedFeatureInThisVersion)

	  #========================#
	 #    NUMBER IN STRING    #
	#========================#

	def NumberForm()
		if NOT This.RepresentsNumber()
			return :NotNumber

		else
 			if This.RepresentsNumberInDecimalForm()
				return :Decimal

		   	but This.RepresentsNumberInBinaryForm()
				return :Binary

		   	but This.RepresentsNumberInOctalForm()
				return :Octal

		   	but This.RepresentsNumberInHexForm()
				return :Hex

			but This.RepresentsNumberInScientificNotation()
				return :ScientificNotation
			ok
		ok

	def RepresentsDigit()
		bResult = FALSE

		if This.IsANumberInString()

			n = 0+ This.Content()
			if 0 <= n and n <= 9
				bResult = TRUE
			ok

		ok

		return bResult

		#< @FunctionAlternativeForms

		def RepresentsADigit()
			return This.RepresentsDigit()

		def IsDigit()
			return This.RepresentsDigit()

		def IsADigit()
			return This.RepresentsDigit()

		def IsDigitInString()
			return This.RepresentsDigit()

		def IsADigitInString()
			return This.RepresentsDigit()

		#>

	def RepresentsNumberOrListInString()
		if This.RepresentsNumberInString() or
		   This.RepresentsListInString()

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlaternativeForms

		def RepresentsListOrNumberInString()
			return This.RepresentsNumberOrListInString()

		def IsNumberOrListInString()
			return This.RepresentsNumberOrListInString()

		def IsStringOrNumberInString()
			return This.RepresentsNumberOrListInString()

		#>

	def RepresentsNumber()

		oCopy = This.Copy()
		oCopy.RemoveSpaces()

		if oCopy.RepresentsNumberInDecimalForm() or
		   oCopy.RepresentsNumberInBinaryForm() or
		   oCopy.RepresentsNumberInOctalForm() or
		   oCopy.RepresentsNumberInHexForm() //or
		   //oCopy.RepresentsNumberInScientificNotation()
			
			return TRUE

		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumber()
			return This.RepresentsNumber()

		def RepresentsNumberInString()
			return This.RepresentsNumber()

		def RepresentsANumberInString()
			return This.RepresentsNumber()

		def IsNumberInString()
			return This.RepresentsNumber()

		def IsANumberInString()
			return This.RepresentsNumber()

		#==

		def RepresentsReal()
			return This.RepresentsNumber()

		def RepresentsAReal()
			return This.RepresentsNumber()

		def RepresentsRealInString()
			return This.RepresentsNumber()

		def RepresentsARealInString()
			return This.RepresentsNumber()

		def IsRealInString()
			return This.RepresentsNumber()

		def IsARealInString()
			return This.RepresentsNumber()

		#--

		def RepresentsRealNumber()
			return This.RepresentsNumber()

		def RepresentsARealNumber()
			return This.RepresentsNumber()

		def RepresentsRealNumberInString()
			return This.RepresentsNumber()

		def RepresentsARealNumberInString()
			return This.RepresentsNumber()

		def IsRealNumberInString()
			return This.RepresentsNumber()

		def IsARealNumberInString()
			return This.RepresentsNumber()

		#>

	def RepresentsSignedNumber()
		if This.RepresentsNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedNumber()
			return This.RepresentsSignedNumber()

		def IsSignedNumber()
			return This.RepresentsSignedNumber()

		def IsASignedNumber()
			return This.RepresentsSignedNumber()

		def IsSignedNumberInString()
			return This.RepresentsSignedNumber()

		def IsASignedNumberInString()
			return This.RepresentsSignedNumber()

		#>

	def RepresentsUnsignedNumber()
		if This.RepresentsNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()	

		def IsUnsignedNumber()
			return This.RepresentsUnsignedNumber()

		def IsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()

		def IsUnsignedNumberInString()
			return This.RepresentsUnsignedNumber()

		def IsAnUnsignedNumberInString()
			return This.RepresentsUnsignedNumber()

		#>

	def RepresentsCalculableNumber() 

		if This.RepresentsCalculableInteger() or
		   This.RepresentsCalculableRealNumber()

			return TRUE

		else
			return FALSE
		ok
				 
		/* INFO
		Non calculable numbers are: 
		-  other numbers in Uniocde, like circled number icons,
		   roman and indian numbers and others

		- numbers in any form (decimal, binary, octal, hex, scientific)
		  that can not be calculated "precisily" with Ring, as defined by
		  MinCalculableNumber() and MaxCalculableNumber()
		*/

		#< @FunctionAlternativeForms

		def RepresentsACalculableNumber() 
			return This.RepresentsCalculableNumber()

		def IsCalculableNumber()
			return This.RepresentsCalculableNumber()

		def IsACalculableNumber()
			return This.RepresentsCalculableNumber()

		def IsCalculableNumberInString()
			return This.RepresentsCalculableNumber()

		def IsACalculableNumberInString()
			return This.RepresentsCalculableNumber()

		#>

	def RepresentsInteger()

		if This.RepresentsNumber() and This.ContainsNo(".")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnInteger()
			return This.RepresentsInteger()

		def IsInteger()
			return This.RepresentsInteger()

		def IsAnInteger()
			return This.RepresentsInteger()

		def IsIntegerInString()
			return This.RepresentsInteger()

		def IsAnIntegerInString()
			return This.RepresentsInteger()

		#>

	def RepresentsSignedInteger()
		if This.RepresentsInteger() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedInteger()
			return This.RepresentsSignedInteger()

		def IsSignedInteger()
			return This.RepresentsSignedInteger()

		def IsASignedInteger()
			return This.RepresentsSignedInteger()

		def IsSignedIntegerInString()
			return This.RepresentsSignedInteger()

		def IsASignedIntegerInString()
			return This.RepresentsSignedInteger()

		#>

	def RepresentsUnsignedInteger()
		if This.RepresentsInteger() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

		def IsUnsignedIntegerInString()
			return This.RepresentsUnsignedInteger()

		def IsAnUnsignedIntegerInString()
			return This.RepresentsUnsignedInteger()

		#>

	def RepresentsCalculableInteger()

		if This.representsInteger()

			# Step 1: we define the number of digits of
			# the integer and the maximum number of digits
			# allowed by Ring for integers
			
			if This.RepresentsSignedInteger()

				nNumberOfDigits = This.NumberOfChars() - 1
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedInteger()

			else

				nNumberOfDigits = This.NumberOfChars()
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedInteger()
			ok

			# Step 2: we compare between them to kwow if this
			# integer is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsACalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsCalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsACalculableInteger()
			return This.RepresentsCalculableInteger()

		def IsCalculableIntegerInString()
			return This.RepresentsCalculableInteger()

		def IsACalculableIntegerInString()
			return This.RepresentsCalculableInteger()

		#>

	def RepresentsSignedRealNumber()
		if This.RepresentsRealNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsSignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

		def IsSignedRealNumberInString()
			return This.RepresentsSignedRealNumber()		

		def IsASignedRealNumberInString()
			return This.RepresentsSignedRealNumber()		

		#>

	def RepresentsUnsignedRealNumber()
		if This.RepresentsRealNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

		def IsUnsignedRealNumberInString()
			return This.RepresentsUnsignedRealNumber()		

		def IsAnUnsignedRealNumberInString()
			return This.RepresentsUnsignedRealNumber()		

		#>

	def RepresentsCalculableRealNumber()
		
		if This.RepresentsRealNumber()

			# Step1: We split the string to get integer and
			# decimal parts and calculate the number of
			# digits in the real number

			cIntegerPart = This.Split(".")[1]
			nNumberOfDigitsIncIntegerPart = len(cIntegerPart)

		 	if ring_left(cIntegerPart, 1) = "+" or
			   ring_left(cIntegerPart, 1) = "-"
				nNumberOfDigitsIncIntegerPart--
			ok

			cFractionalPart = This.Split(".")[2]
			nNumberInDigitsInFractionalPart = len(cFractionalPart)

			nNumberOfDigits = nNumberOfDigitsIncIntegerPart +
					  nNumberInDigitsInFractionalPart

			# Step 2: We compute the maximum number of digits allowed
			# depending on the real number being singed or unsigned

			nMaxNumberOfDigits = 0
			if This.RepresentsSignedRealNumber()
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedRealNumber()
			else
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedRealNumber()
			ok

			# Step 3: we compare between them to kwow if this real
			# number is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsCalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

		def IsCalculableRealNumberInString()
			return This.RepresentsCalculableRealNumber()

		def IsACalculableRealNumberInString()
			return This.RepresentsCalculableRealNumber()

		#>

	def RepresentsNumberInDecimalForm()

		# Rule 1: String shouldn't be null

		if This.Content() = ""
			return FALSE
		ok

		# Rule 2: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" or
		    This.Content() = " ")

			return FALSE
		ok

		# Rule 3: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 4: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 5: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 6: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		acPossibleChars = "0":"9" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)
		
		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		#< @FunctionAlternativeForms

		def RepresentsANumberInDecimalForm()
			return This.RepresentsNumberInDecimalForm()

		def IsDecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def IsADecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def IsDecimalNumberInString()
			return This.RepresentsNumberInDecimalForm()

		def IsADecimalNumberInString()
			return This.RepresentsNumberInDecimalForm()

		#--

		def RepresentsDecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		def RepresentsADecimalNumber()
			return This.RepresentsNumberInDecimalForm()

		#>

	// Checks if the string corresponds to a binary number started by the
	// prefix defined in BinaryNumberPrefix() and composed of 0s and 1s

	def RepresentsNumberInBinaryForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must contains 0s or 1s

		if This.ContainsNo("0") and This.ContainsNo("1")
			return FALSE
		ok

		# Rule 3: String should be prefixed with a binary prefix

		bTemp = FALSE

		#TODO // Replace for/in with for --> better performance

		acBinPref = BinaryPrefixes()
		nLen = len(acBinPref)

		for i = 1 to nLen
			cBinPrefix = acBinPref[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cBinPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE
			return FALSE
		ok

		# Rule 4: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_")

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		acPossibleChars = "0":"1" + "b" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		#< @FunctionAlternativeForms

		def RepresentsANumberInBinaryForm()
			return This.RepresentsNumberInBinaryForm()

		def IsBinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		def IsABinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		def IsBinaryNumberInString()
			return This.RepresentsNumberInBinaryForm()

		def IsABinaryNumberInString()
			return This.RepresentsNumberInBinaryForm()

		#--

		def RepresentsBinayNumber()
			return This.RepresentsNumberInBinaryForm()

		def RepresentsABinaryNumber()
			return This.RepresentsNumberInBinaryForm()

		#>

	// Checks if the string corresponds to a hex number form
	def RepresentsNumberInHexForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain just a hex prefix

		if This.IsEqualToOneOfTheseCS(HexPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 3: String should be prefixed with a hex prefix

		bTemp = FALSE

		acHexPrefixes = HexPrefixes()
		nLen = len(acHexPrefixes)

		for i = 1 to nLen
			cHexPrefix = acHexPrefixes[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeft("-")
			oCopy.RemoveFromLeft("+")

			if oCopy.StartsWithCS(cHexPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE
			return FALSE
		ok

		# Rule 4: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that chars correspond to digits, signs or separators

		acPossibleChars = HexChars() + "x" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a hex number

		return TRUE

		#< @FunctionAlternativeForms

		def RepresentsANumberInHexForm()
			return This.RepresentsNumberInHexForm()

		def IsHexNumber()
			return This.RepresentsNumberInHexForm()

		def IsAHexNumber()
			return This.RepresentsNumberInHexForm()

		def IsHexNumberInString()
			return This.RepresentsNumberInHexForm()

		def IsAHexNumberInString()
			return This.RepresentsNumberInHexForm()

		#--

		def RepresentsHexNumber()
			return This.RepresentsNumberInHexForm()

		def RepresentsAHexNumber()
			return This.RepresentsNumberInHexForm()

		#>

	def RepresentsNumberInUnicodeHexForm()

		nLen = This.NumberOfChars()
		if NOT nLen > 2
			return FALSE
		ok

		if NOT This.SectionQ(1, 2).Uppercased() = "U+"
			return FALSE
		ok
	
		cNumber = This.Section(3, nLen)
	
		if StzStringQ( HexPrefix() + cNumber ).RepresentsNumberInHexForm()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumberInUnicodeHexForm()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsAHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsHexUnicodeInString()
			return This.RepresentsNumberInUnicodeHexForm()

		def IsAHexUnicodeInString()
			return This.RepresentsNumberInUnicodeHexForm()

		#--

		def RepresentsHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		def RepresentsAHexUnicode()
			return This.RepresentsNumberInUnicodeHexForm()

		#>

	// Checks if the string corresponds to an octal number
	def RepresentsNumberInOctalForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain only an octal prefix

		if This.IsEqualToOneOfTheseCS(OctalPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 4: String should be prefixed with an octal prefix

		bTemp = FALSE

		acOctalPrefixes = OctalPrefixes()
		nLen = len(acOctalPrefixes)

		for i = 1 to nLen
			cOctalPrefix = acOctalPrefixes[i]
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cOctalPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE
			return FALSE
		ok

		# Rule 5: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 6: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 7: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 8: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 9: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that the chars correspond to digits, signs or separators

		acPossibleChars = OctalChars() + "o" + "-" + "+" + "." + "_"
		acChars = This.Chars()
		nLen = len(acChars)

		for i = 1 to nLen
			c = acChars[i]

			if NOT ring_find(acPossibleChars, c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		#< @FunctionAlternativeForms

		def RepresentsANumberInUnicodeOctalForm()
			return This.RepresentsNumberInOctalForm()

		def IsOctalUnicode()
			return This.RepresentsNumberInOctalForm()

		def IsAnOctalUnicode()
			return This.RepresentsNumberInOctalForm()

		def IsOctalUnicodeInString()
			return This.RepresentsNumberInOctalForm()

		def IsAnOctalUnicodeInString()
			return This.RepresentsNumberInOctalForm()

		#--

		def RepresentsOctalNumber()
			return This.RepresentsNumberInOctalForm()

		def RepresentsAnOctalNumber()
			return This.RepresentsNumberInOctalForm()


		#>

	def RepresentsNumberInScientificNotation()
		// TODO
		StzRaise("Unsupported feature yet!")

		#< @FunctionAlternativeForms

		def RepresentsANumberInScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsAScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificNotationInString()
			return This.RepresentsNumberInScientificNotation()

		def IsAnScientificNotationInString()
			return This.RepresentsNumberInScientificNotation()

		#--

		def RepresentsScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsAScientificNotation()
			return This.RepresentsNumberInScientificNotation()

		#==

		def RepresentsNumberInScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsANumberInScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsAScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def IsScientificFormInString()
			return This.RepresentsNumberInScientificNotation()

		def IsAnScientificFormInString()
			return This.RepresentsNumberInScientificNotation()

		#--

		def RepresentsScientificForm()
			return This.RepresentsNumberInScientificNotation()

		def RepresentsAScientificForm()
			return This.RepresentsNumberInScientificNotation()

		#>

	  #==============#
	 #    CHARS     #
	#==============#

	def ToStzChar()
		c = This.FirstChar()
		return new stzChar(c)

	def CharsCS(pCaseSensitive)
		bCaseSensitive = CaseSensitive(pCaseSensitive)

		nLen = @oQString.count()
		acResult = []

		if bCaseSensitive = TRUE
			for i = 1 to nLen
				acResult + @oQString.mid(i-1, 1)
			next

		else
			for i = 1 to nLen
				c = lower( @oQString.mid(i-1, 1) )
				if ring_find(acResult, c) = 0
					acResult + c
				ok
			next

		ok

		return acResult

		#< @FunctionFluentForms

		def CharsCSQ(pCaseSensitive)
			return This.CharsCSQR(pCaseSensitive, :stzList)

		def CharsCSQR(pCaseSensitive, pcReturnType)
			if CheckParams()

				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

			ok

			switch pcReturnType

			on :stzList
				return new stzList( This.CharsCS(pCaseSensitive) )

			on :StzListOfChars
				return new stzListOfChars( This.CharsCS(pCaseSensitive) )

			on :StzListOfStrings
				return new stzListOfStrings( This.CharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def Chars()
		return This.CharsCS(TRUE)

		#< @FunctionFluentForm

		def CharsQ()
			return new stzList(This.Chars())

		def CharsQR(pcReturnType)
			return This.CharsCSQR(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def ToListOfChars()
			return This.Chars()

			def ToListOfCharsQ()
				return This.ToListOfCharsQR(:stzList)

			def ToListOfCharsQR(pcReturnType)
				return This.CharsQR(pcReturnType)
	
		#>

	  #------------------------------------------------#
	 #  GETTING THE LIST OF CHARS IN A GIVEN SECTION  #
	#------------------------------------------------#

	def CharsInSectionCS(n1, n2, pCaseSensitive)
		acResult = This.SectionCSQ(n1, n2, pCaseSensitive).Chars()
		return acResult

		#< @FunctionFluentForms

		def CharsInSectionCSQ(n1, n2, pCaseSensitive)
			return This.CharsInSectionCSQR(n1, n2, pCaseSensitive, :stzList)

		def CharsInSectionCSQR(n1, n2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsInSectionCS(n1, n2, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SectionCharsCS(n1, n2, pCaseSensitive)
			return this.CharsInSectionCS(n1, n2, pCaseSensitive)

			def SectionCharsCSQ(n1, n2, pCaseSensitive)
				return This.CharsInSectionCSQ(n1, n2, pCaseSensitive)

			def SectionCharsCSQR(n1, n2, pCaseSensitive, pcReturnType)
				return This.CharsInSectionCSQR(n1, n2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsInSection(n1, n2)
		return This.CharsInSectionCS(n1, n2, TRUE)

		#< @FunctionFluentForms

		def CharsInSectionQ(n1, n2)
			return This.CharsInSectionCSQR(n1, n2, :stzList)

		def CharsInSectionQR(n1, n2, pcReturnType)
			return This.CharsInSectionQR(n1, n2, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SectionChars(n1, n2)
			return this.CharsInSection(n1, n2)

			def SectionCharsQ(n1, n2)
				return This.CharsInSectionQ(n1, n2)

			def SectionCharsQR(n1, n2, pcReturnType)
				return This.CharsInSectionQR(n1, n2, pcReturnType)

		#>

	  #---------------------------------------------------------------------#
	 #  TRANSFORMING THE CHARS OF THE STRING TO A LIST OF stzChar OBJECTS  #
	#---------------------------------------------------------------------#

	def ToListOfStzChars()
		acChars = This.Chars()
		nLen = len(acChars)

		aResult = []

		for i = 1 to nLen
			#WARNing: Note that using 'for in' yields erronous
			# result for strings coded on more then 1 byte

			aResult + new stzChar(acChars[i])
		next

		return aResult

		#< @FunctionFluentForm

		def ToListOfStzCharsQ()
			return new stzList( This.ToListOfStzChars() )

		#>

	  #-------------------------------------------------------------------#
	 #  TRANSFORMING THE CHARS OF THE STRING TO A stzListOfChars OBJECT  #
	#-------------------------------------------------------------------#

	def ToStzListOfChars()
		return new stzListOfChars(This.Chars())

	  #=====================================================#
	 #  CHECKING IF THE STRING IS THE NAME OF A FUNCTION   #
	#=====================================================#
	/*
	TODO: Distinguish between Ring, Softanza, Qt, and other
	libraries functions, classes, and attributes.
	*/

	def IsAFunction()
		if ring_find( functions(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok
 
		def IsAFunctionName()
			return This.IsAFunction()

		def IsFunction()
			return This.IsAFunction()

		def IsFunctionName()
			return This.IsAFunction()

		#--

		def IsFunc()
			return This.IsAFunction()

		def IsFunctName()
			return This.IsAFunction()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A CLASS   #
	#--------------------------------------------------#

	def IsAClass()
		if ring_find( classes(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok

		def IsAClassName()
			return This.IsAClass()

		def IsClass()
			return This.IsAClass()

		def IsClassName()
			return This.IsAClass()

	  #------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF AN ATTRIBUTE  #
	#------------------------------------------------------#

	def IsAnAttributeOfClass(pcClass)
		acTheseAttributes = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Attributes )
		bResult = This.ExistsInCS( acTheseAttributes, :CS = FALSE )
		return bResult

		def IsAnAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOfClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A METHOD  #
	#--------------------------------------------------#

	def IsAMethodOfClass(pcClass)
		acTheseMethods = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Methods )
		bResult = This.ExistsInCS( acTheseMethods, :CS = FALSE )
		return bResult

		def IsAMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOfClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

	  #========================================#
	 #      CHECKING IF ALL CHARS ARE ...     #
	#========================================#

	def AllCharsAreNumbers()
		# EarlyCheck

		if This.IsEmpty() or NOT This.ContainsNumbers()
			return FALSE
		ok

		# Doing the job

		bResult = FALSE

		try
			if isNumber( 0+ This.Content() )
				bResult = TRUE
			ok
		catch
			// Do nothing
		done

		return bResult

		def IsMadeOfNumbers()
			return This.AllCharsAreNumbers()

	def AllCharsAre(pDescriptor)
		/* EXAMPLE

		? Q("248").AllCharsAre([ :Even, :Positive, :Numbers ])
		#--> TRUE

		? Q("248").AllCharsAre([ :Even, W('Q(@char).IsANumber()'), :Numbers ])
		#--> TRUE

		? Q(",:;").AllCharsAre(:Punctuations)

		*/

		if isString(pDescriptor)
			return This.AllCharsAreXT([ pDescriptor ], :EvalDirection = :Nothing)

		but isList(pDescriptor) and Q(pDescriptor).IsListOfStrings()
			return This.AllCharsAreXT(pDescriptor, :EvalDirection = :Nothing)

		ok	

	def AllCharsAreXT(pacDescriptors, paEvalDirection)

		if NOT ( isList(pacDescriptors) and Q(pacDescriptors).IsListOfStrings() )
			stzRaise("Incorrect param type! pacDescriptors must be a list of strings.")
		ok

		if isList(paEvalDirection) and
		   Q(paEvalDirection).IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if NOT Q(paEvalDirection).IsOneOfTheseCS([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], :CS = FALSE)

			stzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if Q(paEvalDirection).IsEither(:Default, :Or = :Nothing)
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		acDescriptors = pacDescriptors
		if Q(paEvalDirection).IsOneOfTheseCS([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			], :CS = FALSE)

			acDescriptors = Q(acDescriptors).Reversed()
		ok

		if len(acDescriptors) = 1

			if acDescriptors[1] = :Number or acDescriptors[1] = :Numbers
				cMethod = :IsANumber

			but acDescriptors[1] = :String or acDescriptors[1] = :Strings
				cMethod = :IsAString

			but acDescriptors[1] = :List or acDescriptors[1] = :Lists
				Method = :IsAList

			but acDescriptors[1] = :Object or acDescriptors[1] = :Objects
				cMethod = :IsAnObject

			but Q(acDescriptors[1]).FirstChar() = "{" and
			    Q(acDescriptors[1]).LastChar() = "}"

				bResult = This.Check( :That = acDescriptors[1] )
				return bResult
			
			else

				cMethod = Q(acDescriptors[1]).InfereMethod(:From = :stzChar)

			ok

			#TODO // Replace the fellowing with Check() when reincluded

			oaStzChars = This.ToListOfStzChars()
			nLen = len(oaStzChars)

			cCode = 'bOk = oaStzChars[i].' + cMethod + '()'

			bResult = TRUE

			for i = 1 to nLen
				eval(cCode)
				if NOT bOk
					bResult = FALSE
					exit
				ok
			next

			return bResult

		else

			cType = Q(acDescriptors[1]).InfereType()
			if Q(cType).StartsWithCS("stz", :CS = FALSE)
				cType = Q(cType).FirstNCharsRemoved(3)
			ok

			bResult = TRUE
	
			for i = 2 to len(acDescriptors)

 				if Q(acDescriptors[i]).FirstChar() = "{" and
			   	   Q(acDescriptors[i]).LastChar() = "}"

					bOk = This.Check( :That = acDescriptors[i] )
				
				else

					cMethod = Q(acDescriptors[i]).InfereMethod( :From = 'stz' + cType )
					bOk = This.Check( :That = 'Stz' + cType + 'Q(@item).' + cMethod + "()" )
				ok

				if bOk = FALSE
					bResult = FALSE
					exit
				ok
			next
		ok

		return bResult

	  #========================================#
	 #   CHARS VERIFYING A GIVEN CONDITION    #
	#========================================#
	
	def CharsWCS(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCS(pcCondition, pCaseSensitive)
		acResult = This.CharsAtPositions(anPos)

		return acResult

		#< @FunctionAlternativeForms

		def CharsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def AllCharsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def AllCharsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def OnlyWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		def ItemsWhereCS(pcCondition, pCaseSensitive)
			return This.CharsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsW(pcCondition)
		return This.CharsWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def CharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsW(pcCondition)
			return This.CharsW(pcCondition)

		def OnlyW(pcCondition)
			return This.CharsW(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsW(pcCondition)
			return This.CharsW(pcCondition)

		def ItemsWhere(pcCondition)
			return This.CharsW(pcCondition)

		#>

	  #---------------------------------------------#
	 #   CHARS VERIFYING A GIVEN CONDITION -- WXT  #
	#---------------------------------------------#
	
	def CharsWCSXT(pcCondition, pCaseSensitive)
		anPos = This.FindCharsWCSXT(pcCondition, pCaseSensitive)
		acResult = This.CharsAtPositions(anPos)

		return acResult

		#< @FunctionAlternativeForms

		def CharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def AllCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def AllCharsWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def OnlyWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		def ItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.CharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CharsWXT(pcCondition)
		return This.CharsWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def CharsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def AllCharsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def AllCharsWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def OnlyWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsWXT(pcCondition)
			return This.CharsWXT(pcCondition)

		def ItemsWhereXT(pcCondition)
			return This.CharsWXT(pcCondition)

		#>

	  #-------------------------------------------------#
	 #   NUMBER OF CHARS VERIFYING A GIVEN CONDITION   #
	#=================================================#

	def NumberOfCharsWCS(pcCondition, pCaseSensitive)
		return len( This.CharsWCS(pcCondition, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def CountCharsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def CountCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def NumberOfItemsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemWCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemWhereCS(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCharsW(pcCondition)
		return This.NumberOfCharsWCS(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def NumberOfItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		#>

	  #------------------------------------------------------#
	 #   NUMBER OF CHARS VERIFYING A GIVEN CONDITION -- XT  #
	#------------------------------------------------------#

	def NumberOfCharsWCSXT(pcCondition, pCaseSensitive)
		return len( This.CharsWCSXT(pcCondition, pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def CountCharsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def CountCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyCharsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyCharWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def NumberOfItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemsWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemWCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCS(pcCondition, pCaseSensitive)

		def HowManyItemsWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		def HowManyItemWhereCSXT(pcCondition, pCaseSensitive)
			return This.NumberOfCharsWCSXT(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCharsWXT(pcCondition)
		return This.NumberOfCharsWCSXT(pcCondition, TRUE)

		#< @FunctionAlternativeForms

		def NumberOfCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def CountCharsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def CountCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyCharWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def NumberOfItemsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemsWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemWXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemsWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		def HowManyItemWhereXT(pcCondition)
			return This.NumberOfCharsWXT(pcCondition)

		#>

	  #=======================#
	 #   STRING IS A CHAR?   #
	#=======================#

	def IsChar()
		if This.NumberOfChars() = 1
			return TRUE
		else
				
			return FALSE
		ok

		def IsAChar()
			return This.IsChar()

	def IsNullOrChar()
		return isNull(This.Content()) or This.IsChar()

		def IsCharOrNull()
			return This.IsNullOrChar()

		def IsEmptyOrChar()
			return This.IsNullOrChar()

		def IsCharOrEmpty()
			return This.IsNullOrChar()

	def IsAsciiChar()
		if This.Unicode() <= 255
			return TRUE
		else
			return FALSE
		ok

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		def IsAnAsciiChar()
			return This.IsAsciiChar()

	def IsCharName()
		return StzUnicodeDataQ().ContainsCharName( This.Uppercased() )

		def IsACharName()
			return This.IsCharName()

	  #---------------------------#
	 #   STRING MADE OF CHARS?   #
	#---------------------------#

	def IsMadeOfCharCS(c, pCaseSensitive)
		if ( NOT This.IsEmpty() ) and  StringIsChar(c)
			return This.IsMadeOfCS([ c ], pCaseSensitive)
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfChar(c)
		return This.IsMadeOfCharCS(c, TRUE)

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF SOME OF THE GIVEN SUBSTRINGS  #
	#------------------------------------------------------------------#

	def IsMadeOfSomeCS(acSubStr, pCaseSensitive)
		if CheckParams()
			if NOT (isList(acSubStr) and @IsListOfStrings(acSubStr))
				StzRaise("Incorrect param type! acSubStr must be a list of strings.")
			ok
		ok

		oCopy = This.Copy()
		nLen = len(acSubStr)


		for i = 1 to nLen
			if This.ContainsCS(acSubStr[i], pCaseSensitive)
				oCopy.RemoveAll(acSubStr[i])
			ok
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		return FALSE

		#< @FunctionAlternativeForms

		def IsMadeOfSomeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfSomeCS(acSubStr, pCaseSensitive)

		def IsMadeOfSomeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfSomeCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfSome(acSubStr)
		return This.IsMadeOfSomeCS(acSubStr, TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfSomeOfThese(acSubStr)
			return This.IsMadeOfSome(acSubStr)

		def IsMadeOfSomeOfTheseSubstrings(acSubStr)
			return This.IsMadeOfSome(acSubStr)

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF SOME OF THE GIVEN CHARS  #
	#-------------------------------------------------------------#

	def IsMadeOfSomeOfTheseCharsCS(acChars, pCaseSensitive)
		if CheckParams()
			if NOT (isList(acChars) and @IsListOfChars(acChars))
				StzRaise("Incorrect param type! acChars must be a list of chars.")
			ok
		ok

		return This.IsMadeOfSomeCS(acChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def IsMadeOfSomeOfTheseChars(acChars)
		return This.IsMadeOfSomeOfTheseCharsCS(acChars, TRUE)

	  #-------------------------------------------------#
	 #   STRING IS A CHAR IN A COMPUTABLE FORM ("c")   #
	#-------------------------------------------------#

	def IsCharInComputableForm()
		if This.IsChar() and This.IsInComputableForm()
			return TRUE
		else
			return FALSE
		ok

	def IsAsciiCharInString()
		if This.NumberOfChars() = 3 and
		   (This.IsBoundedBy("'", "'") or
		   This.IsBoundedBy('"', '"'))
			return StzStringQ(This.Char(2)).IsAsciiChar()
		else
			return FALSE
		ok

	  #----------------------------#
	 #   NUMBER OF UNIQUE CHARS   #
	#----------------------------#

	def NumberOfCharsCSU(pCaseSensitive)
		nResult = len( This.CharsCSU(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfUniqueCharsCS(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		def HowManyCharsCSU(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		def HowManyUniqueCharsCS(pCaseSensitive)
			return This.NumberOfCharsCSU(pCaseSensitive)

		#>

	#--

	def NumberOfCharsU()
		return This.NumberOfCharsCSU(TRUE)

		#< @FunctionAlternativeForms

		def NumberOfUniqueChars()
			return This.NumberOfCharsU()

		def HowManyCharsU()
			return This.NumberOfCharsU()

		def HowManyUniqueChars()
			return This.NumberOfCharsU()

		#>

	  #------------------------------#
	 #   UNIQUE CHARS IN THE LIST   #
	#------------------------------#

	def UniqueCharsCS(pCaseSensitive)

		acChars = This.CharsCS(pCaseSensitive)
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			c = acChars[i]
			if ring_find(acResult, c) = 0
				acrEsult + c
			ok
		next

		return acResult

		#< @FunctionFluentForms

		def UniqueCharsCSQ(pCaseSensitive)
			return This.UniqueCharsCSQR(pCaseSensitive, :stzList)

		def UniqueCharsCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueCharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionALternativeForm

		def ToSetOfCharsCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)
	
			def ToSetOfCharsCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)
	
			def ToSetOfCharsCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQR(pCaseSensitive, pcReturnType)
	
		def CharsCSU(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsCSUQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsCSUQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQR(pCaseSensitive, pcReturnType)

		def CharsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicationCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicationCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQR(pCaseSensitive, pcReturnType)

		def CharsWithoutDuplicatesCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicatesCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicatesCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsCSQR(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def UniqueChars()
		return This.UniqueCharsCS(TRUE)

		#< @FunctionFluentForms

		def UniqueCharsQ()
			return This.UniqueCharsCSQR(TRUE, :stzList)

		def UniqueCharsQR(pcReturnTyp)
			return This.UniqueCharsCSQR(TRUE, pcReturnType)

		#>

		#< @FunctionALternativeForm

		def ToSetOfChars()
			return This.UniqueChars()
	
			def ToSetOfCharsQ()
				return This.UniqueCharsQ()
	
			def ToSetOfCharsQR(pcReturnType)
				return This.UniqueCharsQR(pcReturnType)
	
		def CharsU()
			return This.UniqueChars()

			def CharsUQ()
				return This.UniqueCharsQ()

			def CharsUQR(pcReturnType)
				return This.UniqueCharsQR(pcReturnType)

		def CharsWithoutDuplication()
			return This.UniqueChars()

			def CharsWithoutDuplicationQ()
				return This.UniqueCharsQ()

			def CharsWithoutDuplicationQR(pcReturnType)
				return This.UniqueCharsQR(pcReturnType)

		def CharsWithoutDuplicates()
			return This.UniqueChars()

			def CharsWithoutDuplicatesQ()
				return This.UniqueCharsQ()

			def CharsWithoutDuplicatesQR(pcReturnType)
				return This.UniqueCharsQR(pcReturnType)

		#>

	  #-----------------------------#
	 #  REMOVING DUPLICATED CHARS  #
	#-----------------------------#

	def RemoveDuplicatedCharsCS(pCaseSensitive)
		cNewString = This.UniqueCharsCSQR(pCaseSensitive, :stzListOfStrings).Concatenated()
		This.Update(cNewString)

		def RemoveDuplicatedCharsCSQ(pCaseSensitive)
			This.RemoveDuplicatedCharsCS(pCaseSensitive)
			return This
	
	def DuplicatedCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatedCharsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatedChars()
		This.RemoveDuplicatedCharsCS(TRUE)

		def RemoveDuplicatedCharsQ()
			This.RemoveDuplicatedChars()
			return This
	
	def DuplicatedCharsRemoved()
		cResult = This.Copy().RemoveDuplicatedCharsQ().Content()
		return cResult

	  #---------------------------------------#
	 #   GETTING CHAR AT A GIVEN POSITION    #
	#---------------------------------------#
	
	def NthChar(n)
		#< QtBased | Uses QString.mid() >

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		nLen = @oQString.count()
		cResult = @oQString.mid(n-1, 1)
		return cResult

		#< @FunctionFluentForm
		
		def NthCharQ(n)
			return This.NthCharQR(n, :stzString)

		def NthCharQR(n, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NthChar(n) )
			on :stzChar
				return new stzChar( This.NthChar(n) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
		#< @FunctionAlternativeForms

		def CharAt(n)
			return This.NthChar(n)

			def CharAtQR(n, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.NthCharQR(n, pcReturnType)
	
			def CharAtQ(n)
				return This.CharAtQR(n, :stzString)

		def CharAtPosition(n)
			return This.NthChar(n)

			def CharAtPositionQR(n, pcReturnType)
				return This.CharAtQR(n, pcReturnType)

			def CharAtPositionQ(n)
				return This.CharAtPositionQR(n, :stzString)

		def CharN(n)
			return This.NthChar(n)

			def CharNQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharNQ(n)
				return This.CharAtQR(n, :stzString)

		def Char(n)
			return This.NthChar(n)

			def CharQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharQ(n)
				return This.CharAtQR(n, :stzString)

		#>

	  #-------------------------------------------------#
	 #   NTH CHAR TO THE LAST (OR TO THE FIRST) CHAR   #
	#-------------------------------------------------#

	def NthToLast(n)
		return This.CharAtPosition( This.NumberOfChars() - n )

	def NthToFirst(n)
		return This.CharAtPosition(n + 1)

	  #--------------------------------#
	 #   CHARS AT A GIVEN POSITIONS   #
	#--------------------------------#
	
	def CharsAtPositions(panPos)
		if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
			stzRaise("Incorrect param! panPos must be a list of numbers.")
		ok

		acResult = []

		#TODO: Replace for/in with for --> better performance
		for n in panPos
			acResult + This.CharAt(n)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsAtPositionsQ(panPosirtions)
			return This.CharsAtPositionsQR(panPos, :stzList)

		def CharsAtPositionsQR(panPos, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.CharsAtPositionsQR(panPos, pcReturnType) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsAtPositionsQR(panPos, pcReturnType) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsAtPositionsQR(panPos, pcReturnType) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def CharsAtThesePositions(panPos)
			return This.CharsAtPositions(panPos)

			def CharsAtThesePositionsQ(panPos)
				return This.CharsAtQR(panPos, :stzList)

			def CharsAtThesePositionsQR(panPos, pcReturnType)
				return This.CharsAtPositionsQR(panPos, pcReturnType)

		def CharsAt(panPos)
			return This.CharsAtPositions(panPos)

			def CharsAtQ(panPos)
				return This.CharsAtQR(panPos, :stzList)

			def CharsAtQR(panPos, pcReturnType)
				return This.CharsAtPositionsQR(panPos, pcReturnType)

		#>

	  #---------------------------#
	 #   FIRST AND LAST CHARS    #
	#---------------------------#

	def FirstChar()
 		return This.QStringObject().mid(0, 1)

		#< @FunctionFluentForm

		def FirstCharQ()
			return This.FirstCharQR(:stzString)

		def FirstCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.FirstChar() )
			on :stzChar
				return new stzChar( This.FirstChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def SecondChar()
		return This.Char(2)

		def SecondCharQ()
			return This.SecondCharQR(:stzString)

		def SecondCharQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNameSpace()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsAStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcreturnType
			on :stzString
				return new stzString( This.SecondChar() )

			on :stzChar
				return new stzChar( This.SecondChar() )

			other
				StzRaise("Unsupported return type!")
			off

	def LastChar()
		nLen = This.NumberOfChars()
		cResult = This.QStringObject().mid(nLen - 1, 1)
		return cResult

		#< @FunctionFluentForm

		def LastCharQ()
			return This.LastCharQR(:stzString)

		def LastCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LastChar() )
			on :stzChar
				return new stzChar( This.LastChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForms

		def _()
			return This.LastChar()

			def o_()
				return This.LastChar()
	
		def DernierCaractre()
			return This.LastChar()


		def ()
			return This.LastChar()

		#>

	  #---------------------------#
	 #   LEFT AND RIGHT CHARS    #
	#---------------------------#
		
	def LeftChar()
		if This.IsLeftToRight()
			return This.FirstChar()
		else
			return This.LastChar()
		ok

		#< @FunctionFluentForm

		def LeftCharQ()
			return This.LeftCharQR(:stzString)

		def LeftCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LeftChar() )
			on :stzChar
				return new stzChar( This.LeftChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def RightChar()
		if This.IsLeftToRight()
			return This.LastChar()
		else
			return This.FirstChar()
		ok

		#< @FunctionFluentForm

		def RightCharQ()
			return This.RightCharQR(:stzString)

		def RightCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.RightChar() )
			on :stzChar
				return new stzChar( This.RightChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

	  #-----------------------#
	 #   NUMBER OF CHARS     #
	#-----------------------#

	/* TODO
	Reimplement these functions using QTextBoundaryFinder
	https://doc.qt.io/qt-5/qtextboundaryfinder.html#details
	*/

	def NumberOfCharsCS(pCaseSensitive)
		#< QtBased | Uses QString.count() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		if pCaseSensitive = TRUE

			return @oQString.count()

			#TODO // we should use @oQString.size() instead
			# ~> because count() returns the number of unicode
			# codepoints and not the number of chars

			# ~> Ask Mahmoud to add it to RingQt

		else
			return len( This.UniqueChars() )
		ok

		#< @FunctionFluentForm

		def NumberOfCharsCSQ(pCaseSensitive)
			return new stzNumber(This.NumberOfCharsCS(pCaseSensitive))

		#>

		#< @FunctionBooleanForm

		def NumberOfcharsCSB(pCaseSensitive)
			if This.NumberOfCharsCS(pCaseSensitive) = LastValue()
				return TRUE
			else
				return FALSE
			ok

			def NumberOfCharCSBQ(pCaseSensitive)
				if This.NumberOfcharsCSB(pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def SizeCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def SizeCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def SizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def SizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def SizeInCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def SizeInCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def SizeInCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def NumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def NumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def NumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def NumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def LengthCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def LengthCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def LengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#-- Used in natural-coding

		def ANumberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ANumberOfCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ANumberOfCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ANumberOfCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ASizeCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ASizeCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ASizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ASizeInCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ASizeInCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ASizeInCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ANumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ANumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ANumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ANumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ALengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def ALengthCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def ALengthCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def ALengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#--

		def CountCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def CountCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def CountCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def CountCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def HowManyCharsCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def HowManyCharsCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def HowManyCharsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyCharCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

			def HowManyCharCSQ(pCaseSensitive)
				return This.NumberOfCharsCSQ(pCaseSensitive)

			def HowManyCharCSB(pCaseSensitive)
				return This.NumberOfCharsCSB(pCaseSensitive)

			def HowManyCharCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NuberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#--

		def LenghtCS(pCaseSensitive)
			return This.Length(pCaseSensitive)

		def LenghtCSQ(pCaseSensitive)
			return This.NumberOfItemsCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfChars()
		return This.NumberOfCharsCS(TRUE)

		#< @FunctionFluentForm

		def NumberOfCharsQ()
			return new stzNumber(This.NumberOfChars())

		#>

		#< @FunctionBooleanForm

		def NumberOfcharsB()
			if This.NumberOfChars() = LastValue()
				return TRUE
			else
				return FALSE
			ok

			def NumberOfCharBQ()
				if This.NumberOfcharsB()
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfChars()

			def SizeQ()
				return This.NumberOfCharsQ()

			def SizeB()
				return This.NumberOfCharsB()

			def SizeBQ()
				return This.NumberOfCharBQ()

		def SizeInChars()
			return This.NumberOfChars()

			def SizeInCharsQ()
				return This.NumberOfCharsQ()

			def SizeInCharsB()
				return This.NumberOfCharsB()

			def SizeInCharsBQ()
				return This.NumberOfCharBQ()

		def NumberOfItems()
			return This.NumberOfChars()

			def NumberOfItemsQ()
				return This.NumberOfCharsQ()

			def NumberOfItemsB()
				return This.NumberOfCharsB()

			def NumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def Length()
			return This.NumberOfChars()

			def LengthQ()
				return This.NumberOfCharsQ()

				def LengthQV()
					SetLastValue(This.Length())
					return This.LengthQ()

			def LengthB()
				return This.NumberOfCharsB()

			def LengthBQ()
				return This.NumberOfCharBQ()

				def LengthBQV()
					SetLastValue(This.Lenght())
					return This.LengthBQ()

		#-- Used in natural-coding

		def ANumberOfChars()
			return This.NumberOfChars()

			def ANumberOfCharsQ()
				return This.NumberOfCharsQ()

			def ANumberOfCharsB()
				return This.NumberOfCharsB()

			def ANumberOfCharsBQ()
				return This.NumberOfCharBQ()

		def ASize()
			return This.NumberOfChars()

			def ASizeQ()
				return This.NumberOfCharsQ()

			def ASizeB()
				return This.NumberOfCharsB()

			def ASizeBQ()
				return This.NumberOfCharBQ()

		def ASizeInChars()
			return This.NumberOfChars()

			def ASizeInCharsQ()
				return This.NumberOfCharsQ()

			def ASizeInCharsB()
				return This.NumberOfCharsB()

			def ASizeInCharsBQ()
				return This.NumberOfCharBQ()

		def ANumberOfItems()
			return This.NumberOfChars()

			def ANumberOfItemsQ()
				return This.NumberOfCharsQ()

			def ANumberOfItemsB()
				return This.NumberOfCharsB()

			def ANumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def ALength()
			return This.NumberOfChars()

			def ALengthQ()
				return This.NumberOfCharsQ()

			def ALengthB()
				return This.NumberOfCharsB()

			def ALengthBQ()
				return This.NumberOfCharBQ()

		#--

		def CountChars()
			return This.NumberOfChars()

			def CountCharsQ()
				return This.NumberOfCharsQ()

			def CountCharsB()
				return This.NumberOfCharsB()

			def CountCharsBQ()
				return This.NumberOfCharBQ()

		def HowManyChars()
			return This.NumberOfChars()

			def HowManyCharsQ()
				return This.NumberOfCharsQ()

			def HowManyCharsB()
				return This.NumberOfCharsB()

			def HowManyCharsBQ()
				return This.NumberOfCharBQ()

		def HowManyChar()
			return This.NumberOfChars()

			def HowManyCharQ()
				return This.NumberOfCharsQ()

			def HowManyCharB()
				return This.NumberOfCharsB()

			def HowManyCharBQ()
				return This.NumberOfCharBQ()

		#>

		#< @FunctionMisspelledForm

		def NuberOfChars()
			return This.NumberOfChars()

		#--

		def Lenght()
			return This.Length()

		def LenghtQ()
			return This.NumberOfItemsQ()

		#>

	  #-----------------------#
	 #   NUMBER OF LETTERS   #
	#-----------------------#

	def NumberOfLetters()
		return len(This.OnlyLetters())
	
		#< @FunctionFluentForm

		def NumberOfLettersQ()
			return new stzNumber(This.NumberOfLetters())

		#>

		#< @FunctionBooleanForm

		def NumberOfLettersB()
			if This.NumberOfLetters() = LastValue()
				return TRUE
			else
				return FALSE
			ok

		def NumberOfLettersBQ()
			if This.NumberOfLettersB() = TRUE
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def CountLetters()
			return This.NumberOfLetters()

			def CountLettersQ()
				This.NumberOfLettersQ()

			def CountLettersB()
				return This.NumberOfLettersB()

			def CountLettersBQ()
				return This.NumberOfLettersBQ()

		def HowManyLetters()
			return This.NumberOfLetters()

			def HowManyLettersQ()
				This.NumberOfLettersQ()

			def HowManyLettersB()
				return This.NumberOfLettersB()

			def HowManyLettersBQ()
				return This.NumberOfLettersBQ()

		def HowManyLetter()
			return This.NumberOfLetters()

			def HowManyLetterQ()
				This.NumberOfLettersQ()

			def HowManyLetterB()
				return This.NumberOfLettersB()

			def HowManyLetterBQ()
				return This.NumberOfLettersBQ()

		#>

	  #-----------------------#
	 #   NUMBER OF SPACES    #
	#-----------------------#

	def NumberOfSpaces()
		return len(This.FindAll(" "))

		#< @FunctionAlternativeForms

		def CountSpaces()
			return This.NumberOfSpaces()

		def HowManySpaces()
			return This.NumberOfSpaces()

		def HowManySpace()
			return This.NumberOfSpaces()

		#>

	  #---------------------------------------#
	 #   CHEKING IF THE STRING IS A LETTER   #
	#---------------------------------------#

	def IsLetter()
		if This.IsChar() and StzCharQ(This.Content()).IsLetter()
			return TRUE
		else
			return FALSE
		ok
		
		#< @FunctionAlternativeForms

		def IsALetter()
			return This.IsLetter()

		def ContainsJustALetter()
			return This.IsLetter()

		def ContainsOnlyALetter()
			return This.IsLetter()

		#>

		#< @FunctionPassiveForm

		def IsNotLetter()
			return NOT This.IsLetter()

		def IsNotALetter()
			return NOT This.IsLetter()

		#>

	  #----------------------------------------------------------#
	 #   CHEKING IF THE STRING IS A LETTER OF AN OTHER STRING   #
	#----------------------------------------------------------#

	def IsLetterOf(pcOtherStr)
		if This.IsLetter() and Q(pcOtherStr).ContainsLetter(This.Content())
			return TRUE
		else
			return FALSE
		ok

		def IsALetterOf(pcOtherStr)
			return This.IsLetterOf(pcOtherStr)

	  #-----------------------------------------------#
	 #   GETTING THE LIST OF LETTERS IN THE STRING   #
	#-----------------------------------------------#

	def FindLetters()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)
		anResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				anResult + i
			ok
		next

		return anResult

		def FindLettersZ()
			return This.FindLetters()

	def Letters()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)
		aResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				aResult + aoChars[i].Content()
			ok
		next

		return aResult

		def LettersQ()
			return This.LettersQR(:stzList)

		def LettersQR(pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.Letters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Letters() )

			on :stzListOfChars
				return new stzListOfChars( This.Letters() )
			off

		def LettersN()
			nResult = This.NumberOfLetters()
			return nResult

			def LettersNQ()
				return new stzNumber(This.LettersN())

		def LettersNB() # Used for natural-coding and chains of truth
			if This.NumberOfLetters() = LastValue()
				return TRUE
			else
				return FALSE
			ok

			def LettersNBQ()
				if This.LettersNB() = TRUE
					return This
				else
					return AFalseObject()
				ok

	def LettersZ()
		aResult = []
		aoChars = This.CharsQ().ToListOfStzStrings()
		nLen = len(acChars)
		anResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				anResult + [ aoChars[i].Content(), i ]
			ok
		next

		return aResult

		def LettersAndTheirPositions()

	  #----------------------------------------------------------------------#
	 #   GETTING THE LIST OF LETTERS IN THE STRING  -- WITHOUT DUPLICATION  #
	#----------------------------------------------------------------------#

	def UniqueLetters()
		acResult = This.LettersQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForms

		def UniqueLettersQ()
			return This.UniqueLettersQR(:stzList)

		def UniqueLettersQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueLetters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueLetters() )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueLetters() )
			off

		#>

		#< @FunctionAlternativeForms

		def LettersU()
			return This.UniqueLetters()

			def LettersUQ()
				return This.LettersUQR(:stzList)

			def LettersUQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
	
		def LettersWithoutDuplication()
			return This.UniqueLetters()

			def LettersWithoutDuplicationQ()
				return This.LettersWithoutDuplicationQR(:stzList)

			def LettersWithoutDuplicationQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
		#

	  #----------------------------------------------------------------------#
	 #    CHECKING IF THE STRING IS IN A COMPUTABLE FORM ("str" or 'str')   #
	#----------------------------------------------------------------------#

	def IsInComputableForm()
		if This.NumberOfChars() > 2 and
		   (This.IsBoundedBy("'", "'") or
		    This.IsBoundedBy('"', '"'))

			return TRUE
		else
			return FALSE
		ok
	
		def IsWellFormed()
			return This.IsInComputableForm()

	  #------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN SUBSTRINGS   #
	#------------------------------------------------------------#

	def IsMadeOfCS(acSubStr, pCaseSensitive)
		if CheckParams()

			IF NOT ( isList(acSubStr) and Q(acSubStr).IsListOfStrings() )
				StzRaise("Incorrect param type! acSubStr must be a list of strings.")
			ok

		ok

		oCopy = This.Copy()
		
		nLen = len(acSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(acSubStr[i], pCaseSensitive)
				return FALSE
			ok

			oCopy.RemoveAllCS(acSubStr[i], pCaseSensitive)
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		def IsMadeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			This.IsMadeOfCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOf(acSubStr)
		return This.IsMadeOfCS(acSubStr, TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfThese(acSubStr)
			return This.IsMadeOf(acSubStr)

		def IsMadeOfTheseSubstrings(acSubStr)
			This.IsMadeOf(acSubStr)

		#>

	  #-------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN CHARS   #
	#-------------------------------------------------------#

	def IsMadeOfTheseCharsCS(acChars, pCaseSensitive)
		if @IsListOfChars(acChars)
			return This.IsMadeOfCS(acChars, pCaseSensitive)
		else
			stzRaise("You must provide a list of chars!")
		ok

		def ContainsOnlyTheseCharsCS(acChars, pCaseSensitive)
			return This.IsMadeOfTheseCharsCS(acChars, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfTheseChars(acChars)
		return This.IsMadeOfTheseCharsCS(acChars, TRUE)

		def ContainsOnlyTheseChars(acChars, pCaseSensitive)
			return This.IsMadeOfTheseChars(acChars)

	#TODO
	# Add ContainsOnly...() alternative to all IsMadeOf...() functions and vice versa

	  #-----------------#
	 #   MULTIPLY BY   #	TODO: reclassify it with other calculations
	#-----------------#

	def Multiply(pValue)
		if isList(pValue) and Q(pValue).IsByNamedParam()
			pValue = pValue[2]
		ok

		This.MultiplyBy(pValue)

		def MultiplyQ(pValue)
			This.Multiply(pValue)
			return This

	def Multiplied(pValue)
		cResult = This.Copy().MultiplyQ(pValue).Content()
		return cResult

	#--

	def MultiplyBy(pValue)
		cResult = NULL

		if ring_type(pValue) = "NUMBER"
			cResult = This.RepeatedNTimes(pValue)
		
		but ring_type(pValue) = "STRING"

			if pValue = NULL { return NULL }

			cResult = NULL
			cTemp = NULL

			for i = 1 to This.NumberOfChars()
				cTemp = @oQString.mid(i-1,1) + pValue
				cResult += cTemp
			next
		
		but ring_type(pValue) = "LIST"
			aValue = pValue // just for expressivity
			nLenValue = len(aValue)
			nLen = This.NumberOfChars()

			cResult = ""
			cTemp = ""
				
			for i = 1 to nLen
				
				for v = 1 to nLenValue
					cTemp = @oQString.mid(i-1,1) + aValue[v]
					cResult += cTemp 
				next
										
				cResult += " "

			next

			cResult = StzStringQ(cResult).RemovedFromEnd(" ")
		ok

		This.Update( cResult )

		#< @FunctionFluentForm

		def MultiplyByQ(pValue)
			This.MultiplyBy(pValue)
			return This

		#>

	def MultipliedBy(pValue)
		cResult = This.Copy().MultiplyByQ(pValue).Content()
		return cResult
	
	  #========================================#
	 #     BOXING THE STRING AND ITS CHARS    #
	#========================================#
	
	def Box() # Undersatnd it as a verb action on the string (boxing the string)

		This.BoxXT([])

		#< @FunctionFluentForm

		def BoxQ()
			This.Box()
			return This
		#>

		#< @FunctionAlternativeForm

		def Boxify()
			This.Box()

			def BoxifyQ()
				return This.BoxQ()

		#>

	def Boxed()
		return This.Copy().BoxQ().Content()

		def Boxified()
			return This.Boxed()

	#--

	def BoxDashed()
		This.BoxXT([ :Line = :Dashed, :AllCorners = :Rectangular ])

		#< @FunctionFluentForm

		def BoxDashedQ()
			This.BoxDashed()
			return This
		#>

		#< @FunctionFluentForm

		def BoxifyDashed()
			This.BoxDashed()

			def BoxifyDashedQ()
				return This.BoxDashedQ()

		#>

	def BoxedDashed()
		return This.Copy().BoxDashedQ().Content()

		def BoxifiedDashed()
			return This.BoxedDashed()

	#--

	def BoxRound()
		This.BoxXT([ :Line = :Thin, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundQ()
			This.BoxRound()
			return This
		#>

		def BoxifyRound()
			This.BoxRound()

			def BoxifyRoundQ()
				return This.BoxRoundQ()

	def BoxedRound()
		return This.Copy().BoxRoundQ().Content()

		def BoxifiedRound()
			return This.BoxedRound()

	#--

	def BoxRoundDashed()
		This.BoxXT([ :Line = :Dashed, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundDashedQ()
			This.BoxRoundDashed()
			return This

		#>

		#< @FunctionAlternativeForms

		def BoxDashedRound()
			This.BoxRoundDashed()

			def BoxDashedRoundQ()
				return This.BoxRoundDashedQ()

		#--

		def BoxifyRoundDashed()
			This.BoxRoundDashed()

			def BoxifyRoundDashedQ()
				return This.return This.BoxRoundDashedQ()

		#>

	def BoxedRoundDashed()
		return This.Copy().BoxRoundDashedQ().Content()

		def BoxedDashedRound()
			return This.BoxDashedRound()

		def BoxifiedDashedRound()
			return This.BoxDashedRound()

	#--

	def BoxEachChar()

		This.BoxXT([ :Line = :Thin, :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharQ()
			This.BoxEachChar()
			return This

		#>

		#< @FunctionAlternativeForm

		def BoxChars()
			This.BoxEachChar()

			def BoxCharQ()
				return This.BoxEachCharQ()

		#--

		def BoxifyEachChar()
			This.BoxEachChar()

			def BoxifyEachCharQ()
				return This.BoxEachCharQ()

		def BoxifyChars()
			This.BoxEachChar()

			def BoxifyCharQ()
				return This.BoxEachCharQ()

		#>

	def EachCharBoxed()
		return This.Copy().BoxEachCharQ().Content()

		def CharsBoxed()
			return This.EachCharBoxed()

		def EachCharBoxified()
			return This.EachCharBoxed()

		def CharsBoxified()
			return This.EachCharBoxed()

	#--

	def BoxEachCharRound()
		This.BoxXT( [ :AllCorners = :Round, :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharRoundQ()
			This.BoxEachCharRound()
			return This

		#>

		def BoxifyEachCharRound()
			This.BoxEachCharRound()

			def BoxifyEachCharRoundQ()
				return This.BoxEachCharRoundQ()

	def EachCharBoxedRound()
		return This.Copy().BoxEachCharRoundQ().Content()

		def EachCharBoxifiedRound()
			return This.EachCharBoxedRound()

	#--

	def BoxEachCharXT(paBoxOptions)
		cResult = This.ToStzListOfChars().BoxedXT(paBoxOptions)
		This.Update(cResult)

/*
		# Checking the paBoxOptions param

		if isString(paBoxOptions)
			paTemp = []
			paTemp + [ paBoxOptions, TRUE ]
			paBoxOptions = paTemp
		ok

		if NOT isList(paBoxOptions)
			StzRaise("Incorrect param type! paBoxOptions must be a list.")
		ok

		if len(paBoxOptions) = 0
			This.BoxEachChar()
			return
		ok

? "emm"
		bEachCharFound = FALSE
		nLen = len(paBoxOptions)
		for i = 1 to nLen

			item = paBoxOptions[i]

			if (isString(item) and item = :EachChar) or

			   (isList(item) and len(item) = 2 and
			    isString(item[1]) and
			    item[1] = :EachChar)

				bEachCharFound = TRUE
				exit
			ok
		next

		if NOT bEachCharFound
			paBoxOptions + [ :EachChar, TRUE ]
		ok

		# Doing the job

		This.BoxedXT(paBoxOptions)
*/
		#< @FunctionFluentForm

		def BoxEachCharXTQ(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)
			return This

		#>

		#< @FunctionAlternativeForms

		def BoxCharsXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxCharsXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)

		#--

		def BoxifyEachCharXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxifyEachCharXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)

		def BoxifyCharsXT(paBoxOptions)
			This.BoxEachCharXT(paBoxOptions)

			def BoxifyCharsXTQ(paBoxOptions)
				return This.BoxEachCharXTQ(paBoxOptions)
	
		#>

	def EachCharBoxedXT(paBoxOptions)
		return This.Copy().BoxEachCharXTQ(paBoxOptions).Content()

		def CharsBoxedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

		def EachCharBoxifiedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

		def CharsBoxifiedXT(paBoxOptions)
			return This.EachCharBoxedXT(paBoxOptions)

	#--

	def BoxXT(paBoxOptions)

		/*
		Example:

		? StzStringQ("TEXT1").BoxXT([

			:Line = :Thin,	# or :Dashed
		
			:AllCorners = :Round, # can also be :Rectangualr
			# :Corners = [ :Round, :Rectangular, :Round, :Rectangular ],
		
			:TextAdjustedTo = :Center # or :Left or :Right or :Justified

		]).Content()

		--> Gives:
		
		     TEXT1      
		

		The list of possible options, as you find inforced in
		stzList.IsTextBoxedOptionsNamedParam(), are:

			aListOfBoxOptions = [
				# General options
				:Line,
				:AllCorners,
				:Corners,
				:Width,
				:TextAdjustedTo,

				# Options speciefic to list of chars and words
				:EachChar,
				:EachWord,
				:Hilighted,
				:Numbered
			]

		*/

		if StzListQ(paBoxOptions).IsTextBoxedOptionsNamedParam()

			# Reading the type of line (thin or dashed)

			cLine = :Thin # By default

			if paBoxOptions[ :Line ] = :Dashed
				cLine = :Dashed
			ok

			# Reading the type of corners (rectangualr or round)

			cAllCorners = :Rectangular # By default

			if paBoxOptions[ :AllCorners ] = :Round
				cAllCorners = :Round
			ok

			aCorners = []
			if cAllCorners = :Rectangular
				 # By default
				aCorners = [ :Rectangular, :Rectangular, :Rectangular, :Rectangular ]

			but cAllCorners = :Round
				aCorners = [ :Round, :Round, :Round, :Round ]

			ok

			if len(paBoxOptions[:Corners]) = 4 and
			   StzListQ( paBoxOptions[:Corners] ).IsMadeOfSome([ :Rectangular, :Round ])
	
				aCorners = paBoxOptions[:Corners]

			ok

			# If the boxing happens at the char level, delegate it
			# to the stzListOfChars class

			if paBoxOptions[ :EachChar ] = TRUE

				cResult = This.ToStzListOfChars().BoxedXT(paBoxOptions)
				This.UpdateWith(cResult)
				return
			ok

			# If the boxing happens at the word level, delegate it
			# to the stzListOfStrings class

			if paBoxOptions[ :EachWord ] = TRUE
				return This.ToListOfStringsQ().Boxed(paBoxOptions)
			ok

			# Reading the width of the box in number of chars

			nWidth = This.NumberOfChars() + 2 # By default

			if isNumber(paBoxOptions[:Width]) and
			   paBoxOptions[:Width] > This.NumberOfChars() + 2

				nWidth = paBoxOptions[:Width]
			ok

			# Reading the text adjustment option

			cTextAdjustedTo = :Center # By default

			oString = new stzString( paBoxOptions[ :TextAdjustedTo ] )
			if oString.IsOneOfThese([ :Left, :Center, :Right, :Justified ])

				cTextAdjustedTo = paBoxOptions[ :TextAdjustedTo ]
			ok
 
			# Composing the box

			cVTrait  = ""

			cHTrait  = ""

			if cLine = :Dashed
				cHTrait = ""
				cVTrait = ""
			ok
			
			
			cCorner1 = ""
			cCorner2 = ""
			cCorner3 = ""
			cCorner4 = ""

			if  aCorners[1] = :Round
				cCorner1 = ""
			ok

			if aCorners[2] = :Round
				cCorner2 = ""
			ok

			if aCorners[3] = :Round
				cCorner3 = ""
			ok

			if aCorners[4] = :Round
				cCorner4 = ""
			ok

			cUpLine = cCorner1 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner2 

			
			cMidLine = cVTrait + " " +
				   This.AlignXTQ(nWidth - 2, " ", cTextAdjustedTo).Content() +
				   " " +
				   cVTrait

			cDownLine = cCorner4 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner3 

			This.UpdateWith( cUpLine + NL + cMidLine + NL + cDownLine )

		but isList(paBoxOptions) and len(paBoxOptions) = 0
			# Do nothing, takes default options for boxing

		else
			stzRaise(stzStringError(:CanNotBoxTheString))
		ok

		#< @FunctionFluentForm

		def BoxXTQ(paBoxOptions)
			This.BoxXT(paBoxOptions)
			return This

		#>

		def BoxifyXT(paBoxOptions)
			This.BoxXT(paBoxOptions)

			def BoxifyXTQ(paBoxOptions)
				return This.BoxXTQ(paBoxOptions)

	def BoxedXT(paBoxOptions)
		cResult = This.Copy().BoxXTQ(paBoxOptions).Content()
		return cResult

		def BoxifiedXT(paBoxOptions)
			return This.BoxedXT(paBoxOptions)

	  #=================================================#
	 #   STRING EXISTENCE AS AN ITEM IN A GIVEN LIST   #
	#=================================================#

	def ExistsInListCS(paList, pCaseSensitive)

		if NOT isList(paList)
			stzRaise("Incorrect param! paList must be a list.")
		ok

		bResult = FALSE
		nLen = len(paList)

		for i = 1 to nLen
			item = paList[i]
			if isString(item) and Q(item).IsEqualToCS( This.String(), pCaseSensitive )
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ExistsAsItemInListCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheseCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

	#--

	def ExistsInList(paList)
		return This.ExistsInListCS(paList, TRUE)

		def ExistsAsItemInList(paList)
			return This.ExistsInList(paList)

		def IsOneOfThese(paList)
			return This.ExistsInList(paList)

		def IsOneOf(paList)
			return This.ExistsInList(paList)

		def IsOneOfThe(paList)
			return This.ExistsInList(paList)

	  #====================================================#
	 #  CHECHKING IF THE STRING IS EQUAL TO VAL1 OR VAL2  #
	#====================================================#
	// TODO: Add same function to other classes

	def IsEitherCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and Q(pcStr2).IsOrNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.IsOneOfTheseCS([ pcStr1, pcStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsEither(pcStr1, pcStr2)
		return This.IsEitherCS(pcStr1, pcStr2, TRUE)

	  #=============================================#
	 #  MOVING CHAR AT POSITION N1 TO POSITION N2  #
	#=============================================#
	#TODO: Should be generalized to move hole substrings not only chars

	def Move(n1, n2)

		# Checking params correctness

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedParams([
			:From, :FromPosition,
			:At, :AtPosition,
			:Char, :CharAt, :CharAtPosition,
			:FromCharAt, :FromCharAtPosition,
			:CharFrom, :CharFromPosition
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToChar, :ToPosition, :ToPositionOfChar,
				:ToCharAt, :ToCharAtPosition ])

			n2 = n2[2]
		ok

		if isString(n1) and
		   Q(n1).IsOneOfThese([ :First, :FirstPosition, :FirstChar ])
				    
			n1 = 1
		ok

		if isString(n2) and
		   Q(n1).IsOneOfThese([ :Last, :LastPosition, :LastChar ])

			n2 = This.NumberOfItems()
		ok

		if NOT @BothAreNumbers(n1, n2)
			stzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		# Doing the job
		
		if n1 > n2
		# . . . 2 . . 1 . .
		#       ^     |
		#       |_____|

			cTempChar = This[n1]
			This.RemoveCharAtPosition(n1)
			This.InsertBefore(n2, cTempChar)

		but n1 < n2
		# . . . 1 . . 2 . .
		#       |     ^
		#       |_____|

			cTempChar = This[n1]

			if n2 = This.NumberOfItems()
				This.AddChar(cTempChar)
			else
				This.InSertAfter(n2, cTempChar)
			ok

			This.RemoveCharAt(n1)
		ok

		#< @FunctionAlternativeForm

		def MoveChar(n1, n2)
			This.Move(n1, n2)

		#>

	  #=========================================#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if BothAreStrings(n1, n2)
			This.SwapSubStrings(n1, n2)
			return
		ok

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedPArams([
			:Between, :BetweenPosition, :BetweenPositions,
			:BetweenChar, :BetweenChars,
			:BetweenCharAt, :BetweenCharAtPosition, :BetweenCharAtPositions,
			:Position, :Positions, :CharAt, :CharAtPosition, :CharAtPositions,
			:CharsAt, :CharsAtPosition, :CharAtPositions
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedPArams([
			:And, :AndPosition, :AndCharAt, :AndCharAtPosition, :AndChar ])

			n2 = n2[2]
		ok

		copy = This[n2]
		This.ReplaceCharAtPosition(n2, :By = This[n1])
		This.ReplaceCharAtPosition(n1, :By = copy)

		#< @FunctionFluentForm

		def SwapQ(n1, n2)
			This.Swap(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenQ(n1, n2)
				This.SwapBetween(n1, n2)
				return This

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenPositionsQ(n1, n2)
				This.SwapBetweenPositions(n1, n2)
				return This

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapItemsQ(n1, n2)
				This.SwapItems(n1, n2)
				return This

		def SwapChar(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndCharAt, :AndCharAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapCharQ(n1, n2)
				This.SwapChar(n1, n2)
				return This

		def SwapChars(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsQ(n1, n2)
				This.SwapChars(n1, n2)
				return This

		def SwapCharsAtPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsAtPositionsQ(n1, n2)
				This.SwapCharsAtPositions(n1, n2)
				return This

		#>

	  #-----------------------------------------#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TWO, ONE, THREE!")
		o1.SwapSubStrings("TWO", "ONE")

		? o1.Content()
		#--> ONE, TWO, THREE!

		*/

		if isList(pcSubStr2) and Q(pcSubStr2).IsOneOfThese([ :And, :With, :By ])
			pcSubStr2 = pcSubStr2[2]
		ok

		if NOT This.ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			StzRaise("Incorrect param types! Both pcSubStr1 and pcSubStr2 must be strings.")
		ok

		#NOTE: if the string contains more then one occurrence form a substring,
		# then only the first Occurrence is considered

		aSectionSubStr1 = This.FindAsSectionsCS(pcSubStr1, pCaseSensitive)[1]
		aSectionSubStr2 = This.FindAsSectionsCS(pcSubStr2, pCaseSensitive)[1]

		This.ReplaceSection(aSectionSubStr1[1], aSectionSubStr1[2], pcSubStr2)
		This.ReplaceSection(aSectionSubStr2[1], aSectionSubStr2[2], pcSubStr1)

		def SwapSubStringsCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			This.SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStrings(pcSubStr1, pcSubStr2)
		This.SwapSubStringsCS(pcSubStr1, pcSubStr2, TRUE)

		def SwapSubStringsQ(pcSubStr1, pcSubStr2)
			This.SwapSubStrings(pcSubStr1, pcSubStr2)
			return This

	  #==================================#
	 #   REVERSING THE ORDER OF CHARS   #
	#==================================#

	def ReverseCharsOrder()

		cInversed = ""
		nLen = This.NumberOfChars()
		acReversed = []

		for i = nLen to 1 step -1
			cInversed += This.@oQString.mid(i-1, 1)
		next

		This.Update( cInversed )

		#< @FunctionFluentForm

		def ReverseCharsOrderQ()
			This.ReverseCharsOrder()
			return This
	
		#>

		#< @FunctionAlternativeForm

		def Reverse() # To stay consistent with Ring that has reverse() function
			This.ReversecharsOrder()

			def ReverseQ()
				This.Reverse()
				return This

		def ReverseOrder()
			This.ReversecharsOrder()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		#--

		def InverseCharsOrder()
			return This.ReverseCharsOrder()

		def Inverse()
			This.InversecharsOrder()

			def InverseQ()
				This.Inverse()
				return This

		def InverseOrder()
			This.InversecharsOrder()

			def InverseOrderQ()
				This.InverseOrder()
				return This

		#--

		def InvertCharsOrder()
			return This.ReverseCharsOrder()

		def Invert()
			This.InversecharsOrder()

			def InvertQ()
				This.Invert()
				return This

		def InvertOrder()
			This.InversecharsOrder()

			def InvertOrderQ()
				This.InvertOrder()
				return This

		#>

	def CharsOrderReversed()
		cResult = This.Copy().ReverseCharsOrderQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def Reversed()
			return This.CharsOrderReversed()

		def OrderReversed()
			return This.CharsOrderReversed()

		#--

		def CharsOrderInversed()
			return This.CharsOrderReversed()

		def Inversed()
			return This.CharsOrderReversed()

		def OrderInversed()
			return This.CharsOrderReversed()

		#--

		def CharsOrderInverted()
			return This.CharsOrderReversed()

		def Inverted()
			return This.CharsOrderReversed()

		def OrderInverted()
			return This.CharsOrderReversed()

		#>

	  #---------------------------------------------------------#
	 #   TUENING CHARS OF THE STRING (IF POSSIBLE IN UNICODE)  #
	#=========================================================#

	def Turnchars()
		/*
		Example:
		? StzStringQ("LIFE").CharsTurned()
		#--> I
		*/

		#NOTE: Applies to latin script only

		cResult = ""

		aoStzChars = This.ToListOfStzChars()
		nLen = len(aoStzChars)

		for i = 1 to nLen
			cResult += aoStzChars[i].Turned()
		next

		This.UpdateWith(cResult)

		#< @FunctionFluentForm

		def TurnCharsQ()
			This.TurnChars()
			return This
		#>

		#< @FunctionAlternativeForms

		def ReverseChars()
			This.Turnchars()

			def ReverseCharsQ()
				return This.TurnCharsQ()

		def InverseChars()
			This.Turnchars()

			def InverseCharsQ()
				return This.TurnCharsQ()

		def InvertChars()
			This.Turnchars()

			def InvertCharsQ()
				return This.TurnCharsQ()

		#>

	def CharsTurned()
		return This.Copy().TurnCharsQ().Content()

		#< @FunctionAlternativeForms

		def CharsReversed()
			return This.CharsTurned()

		def CharsInversed()
			return This.CharsTurned()

		def CharsInverted()
			return This.CharsTurned()

		#>

	  #----------------------#
	 #  TURNING THE STRING  #
	#----------------------#

	def Turn()
		cResult = This.TurnCharsQ().Reversed()
		This.UpdateWith(cResult)

		def TurnQ()
			This.Turn()
			return This

	def Turned()
		cResult = This.Copy().TurnQ().Content()
		return cResult

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS A REVERSED COPY OF AN OTHER STRING  #
	#----------------------------------------------------------------#

	def IsReverseOf(pcOtherStr)

		if This.Reversed() = pcOtherStr
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsInverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)
		
		def IsInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAnInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsAnInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#==

		def IsTheReverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		def IsTheReversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsTheInverseOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)
		
		def IsTheInversedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def IsTheInvertedCopyOf(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#--

		def ReverseOfB(pcOtherStr)
			return This.IsReverseOf(pcOtherStr)

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF INVERTED (TURNED) CHARS  #
	#-------------------------------------------------------------#

	def IsTurned()

		aoChars = This.ToListOfStzChars()
		nLen = len(aoChars)

		bResult = TRUE


		for i = 1 to nLen
			if NOT aoChars[i].IsTurned()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def CharsAreTurned()
			return This.IsTurned()

		def AllCharsAreTurned()
			return This.IsTurned()

		#>

	  #========================#
	 #   HASHING THE STRING   #
	#========================#
	
	# Currently we use the native hashing functions of Ring StdLib
	#TODO: other algortithms can be added through RingQt

	def Hash(pcHashingAlgo)
		if isList(pcHashingAlgo) and Q(pcHashingAlgo).IsWithOrUsingOrByNamedParam()
			pcHashingAlgo = pcHashingAlgo[2]
		ok

		if NOT isString(pcHashingAlgo)
			StzRaise("Incorrect param type! pcHashingAlgo must be a string.")
		ok

		if NOT Q(pcHashingAlgo).IsOneOfThese([ :MD5, :SHA1, :SHA256, :SHA512, :SHA384, :SHA224 ])
			StzRaise("Unsupported hashing algorithm! Allowed values are :MD5, :SHA1, :SHA256, :SHA512, :SHA384 and :SHA224.")
		ok

		cHashed = ""

		switch pcHashingAlgo

		on :MD5
			cHashed = md5( This.String() )

		on :SHA1
			cHashed = sha1( This.String() )

		on :SHA256
			cHashed = sha256( This.String() )

		on :SHA512
			cHashed = sha512( This.String() )

		on :SHA384
			cHashed = sha384( This.String() )

		on :SHA224
			cHashed = sha224( This.String() )

		other
			stzRaise("syntax error or unsupported hashing algorithm!")
		off

		This.Update( cHashed )

		#< @FunctionFluentVersion

		def HashQ(pcHashingAlgo)
			return new stzString( This.Hash(pcHashingAlgo) )

		#>

		#< @FunctionAlternativeForms

		def HashWithAlgo(pcHashingAlgo)
			return This.Hash(pcHashingAlgo)

			def HashWithAlgoQ(pcHashingAlgo)
				return new stzString( This.HashWithAlgo(pcHashingAlgo) )
		#>

	def HashWithMD5()
		This.Hash(:MD5)

		def HashWithMD5Q()
			This.HashWithMD5()
			return This

	def HashWithSHA1()
		This.Hash(:SHA1)

		def HashWithSHA1Q()
			This.HashWithSHA1()
			return This

	def HashWithSHA256()
		This.Hash(:SHA256)

		def HashWithSHA256Q()
			This.HashWithSHA256()
			return This

	def HashWithSHA384()
		This.Hash(:SHA384)

		def HashWithSHA384Q()
			This.HashWithSHA384()
			return This

	def HashWithSHA224()
		This.Hash(:SHA224)

		def HashWithSHA224Q()
			This.HashWithSHA224()
			return This

	  #------------------------------------------#
	 #   ENCRYPTING AND DECRYPTING THE STRING   #
	#------------------------------------------#
	
	# Encrypts the string using the blowfish algorithm:
	#--> returns what's called a cipher in a binary string

	#--> TODO: - what the cIV param means?
	# 	    - check: key must be between 4 and 56 bytes long 

	def EncryptWithBlowfish(cSecretKey, cIV)
		cEncrypted = encrypt( This.String(), cSecretKey, cIV)
		This.Update( cEncrypted )

		#< @FunctionAlternativeForms

		def EncryptWithBlowfishQ(cSecretKey, cIV)
			return new stzListOfBytes( This.EncryptWithBlowfish(cSecretKey, cIV) )

		#>

	# Updates the string from a cipher encrypted with the blowfish algorithm
	#--> cCypher should be in binary form (list of bytes)
	def FromDecryptedWithBlowfish(cCypher, cSecret, cIV)
		This.Update( decrypt(cCypher, cSecret, cIV) )

		#< @FunctionAlternativeForms

		def FromBlowfishCipher(cCypher, cSecret, cIV)
			This.FromDecryptedWithBlowfish(cCypher, cSecret, cIV)

		#>

	  #==============================#
	 #   GETTING TEXT FROM A URL    #
	#==============================#

	def UpdateFromURL(cURL)
		This.Update( download(cURL) )

		def UpdateFromURLQ(cURL)
			This.UpdateFromURLL(cURL)
			return This

		def FromURL(cURL)
			This.UpdateFromURL(cURL)

			def FromURLQ(cURL)
				This.FromURL(cURL)
				return This

	def UpdatedFromURL(cURL)
		cResult = This.Copy().UpdateFromURLQ(cURL).Content()
		return cResult

	  #====================================================#
	 #     WALKING THE STRING AND RETURNING SOMETHING     #
	#====================================================#

	def AddWalker(pcWalkerName, nStart, nEnd, nStep)
		@aWalkers + new stzWalker(nStart, nEnd, nStep)

		def AddWalkerST(pcWalkerName, nStart, nEnd, nStep)
			This.AddWalker(pcWalkerName, nStart, nEnd, nStep)

	def Walker(pcWalkerName)
		oResult = @aWalkers[pcWalkerName]
		if oResult = NULL
			StzRaise("Incorrect param value! pcWalkerName must be a valid walker name.")
		else
			return @aWalkers[pcWalkerName].Walkables()
		ok

		def WalkerPositions(pcWalkerName)
			return new stzList(This.Walker(pcWalkerName))

		def WalkedPositionsBy(pcWalkerName)
			return new stzList(This.Walker(pcWalkerName))

	def WalkerQ(pcwalkerName)
		oResult = @aWalkers[pcWalkerName]
		if oResult = NULL
			StzRaise("Incorrect param value! pcWalkerName must be a valid walker name.")
		else
			return @aWalkers[pcWalkerName]
		ok

	def Walkers()
		return @aWalkers

	def RemoveWalker(pcWalkerName)
		nLen = len(@aWalkers)
		nPos = 0
		for i = 1 to nLen
			if @aWalkers[i][1] = pcWalkerName
				nPos = i
				exit
			ok
		next

		if nPos > 0
			ring_remove(@aWalkers, nPos)
		ok

	def RemoveWalkers(pcWalkerName)
		@aWalkers = []


	  #=================================#
	 #  REPEATING THE STRING N TIMES   #
	#=================================#

	def RepeatNTimes(n)
		/* NOTE

		This method exists already in the parent stzObject.
		Here we make it specific to strings.

		In fact, Q("Hi!").RepeatNTimes(3) when applied to
		the string "Hi!" will update it to become "Hi!Hi!Hi!".

		In all other types (stzList, stzNumber, and stzObject)
		Q(5).RepeatNTimes(3) will produce the list [5, 5, 5],
		and Q(1:3).RepeatNTimes(3) will produce the list
		[ 1:3, 1:3, 1:3 ].

		You may ask why we opted for a different behavior for
		strings compared to other types?

		Well, because I think it's more obvious to update the
		string when we ask to repeat it, and have a string as a
		result not a list!

		If you want to avoid any confusion due to this choice,
		use RproduceIn() instead, and specify explicitly what
		you hant to have, like this:

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InString)
		#--> "Hi!Hi:Hi!

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InList)
		"--> [ "Hi!", "Hi!", "Hi!" ]

		*/

		cResult = ""
		for i = 1 to n
			cResult += This.Content()
		next
		This.Update( cResult )

		#< @FunctionFluentForms

		def RepeatNTimesQ(n)
			This.RepeatNTimes(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def Repeat(n)
			This.RepeatNTimes(n)

			def RepeatQ(n)
				This.Repeat(n)
				return This

		def Reproduce(n)
			This.RepeatNTimes(n)

			def ReproduceQ(n)
				This.Reproduce(n)
				return This

		def ReproduceNTimes(n)
			This.RepeatNTimes(n)

			def ReproduceNTimesQ(n)
				This.ReproduceNTimes(n)
				return This

		def CopyNTimes(n)
			This.RepeatNTimes(n)

			def copyNTimesQ(n)
				This.copyNTimes(n)
				return This
		#>


	# RETURNING THE OUTPUT DATA

	def RepeatedNTimes(n)
		return This.Copy().RepeatNTimesQ(n).Content()

		#< @FunctionAlternativeForms

		def Repeated(n)
			return This.RepeatedNTimes(n)

		def ReproducedNTimes(n)
			return This.RepeatedNTimes(n)

		def Reproduced(n)
			return This.RepeatedNTimes(n)

		def CopiedNTimes(n)
			return This.RepeatedNTimes(n)

		def Copied(n)
			return This.RepeatedNTimes(n)

		#>

	  #---------------------------------#
	 #  REPEATING THE STRING N TIMES   #
	#---------------------------------#

	def Repeat3Times()
		This.RepeatNTimes(3)

		#< @FunctionFluentForms

		def Repeat3TimesQ()
			This.Repeat3Times()
			return This

		#>

		#< @FunctionAlternativeForms

		def Reproduce3Times()
			This.Repeat3Times()

			def Reproduce3TimesQ()
				This.Reproduce3Times()
				return This

		def Copy3Times()
			This.Repeat3Times()

			def Copy3TimesQ()
				This.Copy3Times()
				return This

		#>

	# RETURNING THE OUTPUT DATA

	def Repeated3Times()
		return This.Copy().Repeat3TimesQ().Content()

		#< @FunctionAlternativeForms

		def Reproduced3Times()
			return This.Repeated3Times()

		def Copied3Times()
			return This.Repeated3Times()

		#>

	  #====================================================#
	 #     COMPRESSING THE STRING WITH A BINARY SCHEMA    #
	#====================================================#

	// Example : ABCDEFGH > 10011011 => ADEGH
	def CompressUsingBinary(cBinary)

		oBinary = new stzString(cBinary)
		if NOT oBinary.IsMadeOf(["0", "1"])
			stzRaise(stzStringError(:CanNotCompressStringUsingBinary))
		ok

		cCompressed = ""
		nLenBinary = len(cBinary)
		nLen = This.NumberOfChars()

		for i = 1 to nLenBinary
			if cBinary[i] = "1" and i <= nLen					
				cCompressed += This.Char(i)
			ok
		next
			
		if nLen > nLenBinary
			for i = NLenBinary + 1 to nLen
				cCompressed += This.CHar(i) 
			next
		ok

		This.Update( cCompressed )

		#< @FunctionFluentForm

		def CompressUsingBinaryQ(cBinary)
			This.CompressUsingBinary(cBinary)
			return This

		#>

	  #=================================#
	 #    CHECKING A LIST IN STRING    #
	#=================================#

	def IsListInString()
		/* EXAMPLES
	
		o1 = new stzString('[ "A","B", "C", "D" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "A":"D" ')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString('[ "", "", "" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "":"": ')
		? o1.IsListInString() #--> TRUE

		o1 = new stzString("10 : 15")
		? o1.IsListInString() #--> TRUE

		*/

		oCopy = This.RemoveSpacesQ().RemoveTheseBoundsQ( "{", "}" ).

		# A list can not be written with less then 2 chars

		if oCopy.NumberOfChars() < 2
			return FALSE
		ok

		bResult = FALSE

		# Case 1 : The list is in normal [_,_,_] form

		if oCopy.IsBoundedBy([ "[","]" ]) and
			oCopy.Contains(",")

			cCode = "aTempList = " + oCopy.Content()
			eval(cCode)

			bResult = isList(aTempList)

		else

		# Case 2 : The list is in short _:_ form

			if oCopy.ContainsOneOccurrence(":")

				# the : separator in _:_ can not be at the
				# beginning or the end of the list in string

				n = oCopy.FindFirst(":")
				if NOT ( n > 1 and n < oCopy.NumberOfChars() )

					bResult = FALSE

				ok

				# The list is in short form, let's analyze it
				# and tranform it to a normal syntax
	
				aListMembers = QStringListToList( oCopy.QStringObject().split( ":", 0, 0 ) )
				#NOTE: could be written { aListMembers = oCopy.Split( :Using = ":" ) } after
				# terminating Split() funtion in Softanza.

				cMember1 = aListMembers[1]
				cMember2 = aListMembers[2]

				cCode = "pMember1 = " + cMember1
				eval(cCode)
	
				cCode = "pMember2 = " + cMember2
				eval(cCode)
	
				cNormalSyntax = "[ "
	
				if ( isString(pMember1) and @IsChar(pMember1) ) and
				   ( isString(pMember2) and @IsChar(pMember2) )
					
					n1 = CharUnicode(pMember1)
					n2 = CharUnicode(pMember2)
		
					if n1 <= n2
						for n = n1 to n2
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2
						for n = n1 to n2 step -1
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n > n2
								cNormalSyntax += ", "
							ok
						next
					ok
		
					cNormalSyntax += " ]"
	
				but isNumber(pMember1) and isNumber(pMember2)

					n1 = pMember1
					n2 = pMember2
		
					if n1 <= n2

						for n = n1 to n2
							cNormalSyntax += (""+ n)
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2

						for n = n1 to n2 step -1
							cNormalSyntax += (""+ n)
							if n > n2
								cNormalSyntax += ", "
							ok
						next
		
					ok
		
				ok

				cNormalSyntax = StzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()

				if Q(cNormalSyntax).LastChar() != "]"
					cNormalSyntax += " ]"
				ok

				cCode = "aTempList = " + cNormalSyntax
				eval(cCode)

				bResult = isList(aTempList)

			ok  
		ok

		return bResult

		def RepresentsListInString()
			return This.IsListInString()

	def IsListInNormalForm()
		if NOT This.IsListInString()
			return FALSE
		ok

		if This.TrimQ().IsBoundedBy([ "[","]" ])
			return TRUE
		else
			return FALSE
		ok

		def RepresentsListInNormalForm()
			return This.IsListInNormalForm()

	def IsListInShortForm()
		if This.IsListInString() and
		  ( NOT This.IsListInNormalForm() )

			return TRUE
		else
			return FALSE
		ok

		def RepresentsListInShortForm()
			return This.IsListInShortForm()

	  #--------------------------------------------#
	 #    CHECKING A CONTIGUOUS LIST IN STRING    #
	#--------------------------------------------#

	def IsContiguousListInString()

		cCode = "aTempList = " + This.ToListInNormalForm()
		eval(cCode)
		bResult = StzListQ(aTempList).IsContiguous()

		return bResult

		def IsContinuousListInString()
			return This.IsContiguousListInString()

	def IsContiguousListInNormalForm()
	
		if This.IsContiguousListInString() and
		   This.IsListInNormalForm()
		  
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInNormalForm()
			return This.IsContiguousListInNormalForm()

	def IsContiguousListInShortForm()

		if This.IsContiguousListInString() and
		   This.IsListInShortForm()
		   
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInShortForm()
			return This.IsContiguousListInShortForm()

	  #------------------------------------------------------------#
	 #  TRANSFORMING THE LIST INTO RING CODE IN SHORT FORM (_:_)  #
	#------------------------------------------------------------#

	def ToListInShortForm()
	
		if NOT This.IsContiguousListInString()
			stzRaise([
				:Where = "stzString > ToListInShortForm()",
				:What  = "Can't convert the list in string to short form!",
				:Why   = "The list in string is not contiguous list."
			])
		ok

		cResult = ""

		if This.IsListInShortForm()
			cResult  =  This.Copy().
					RemoveSpacesQ().
					ReplaceQ(":", " : ").
					Content()

		but This.IsListInNormalForm()

			cCode = "aTempList = " + This.String()
			eval(cCode)

			if StzListQ(aTempList).IsContiguous()

				oCopy = This.Copy()
				oCopy.Trim()
				oCopy.RemoveFirstAndLastChars()

				acMembers = oCopy.QStringObject().split(",", 0, 0)
				acMembers = QStringListToList(acMembers)
				acMembers = StzListQ(acMembers).FirstAndLastItems()

				/*
				TODO : replace with this when Split() is finished.

				acMembers = This.TrimQ().
						RemoveTheeBoundsQ("[","]").
						SplitQ(",").
						FirstAndLastItems()
				*/

						
				cMember1 = StzStringQ(acMembers[1]).Simplified()
				cMember2 = StzStringQ(acMembers[len(acMembers)]).Simplified()

				cResult = cMember1 + ":" + cMember2

			else
				cResult = This.Simplified()
			ok
		ok

		return cResult

		def ToListInShortFormQ()
			return new stzString( This.ToListInShortForm() )

		def ToListInStringInShortForm()
			return This.ToListInShortForm()

			def ToListInStringInShortFormQ()
				return new stzString( This.ToListInStringInShortForm() )

	  #-----------------------------------------------------------------#
	 #  TRANSFORMING THE LIST INTO RING CODE IN NORMAL FORM ([_,_,_])  #
	#-----------------------------------------------------------------#

	def ToListInNormalForm()

		If NOT This.IsListInString()
			stzRaise([
				:Where = "stzString > ToListInNormalForm()",
				:What  = "Can't convert the string to short form list!",
				:Why   = "The string is not a list in string."
			])
		ok

		if This.IsListInNormalForm()
			cResult = This.Simplified()

		but This.IsListInShortForm()

			# The list is in short form, let's analyze it
			# and tranform it to a normal syntax

			aListMembers = QStringListToList( This.QStringObject().split( ":", 0, 0 ) )
			#NOTE: could be written { aListMembers = This.Split( :Using = ":" ) } after
			# terminating Split() funtion in Softanza.
					
			cMember1 = aListMembers[1]
			cMember2 = aListMembers[2]

			cCode = "pMember1 = " + cMember1
			eval(cCode)
		
			cCode = "pMember2 = " + cMember2
			eval(cCode)
	
			cNormalSyntax = "[ "
	
			if ( isString(pMember1) and @IsChar(pMember1) ) and
			   ( isString(pMember2) and @IsChar(pMember2) )
						
				n1 = CharUnicode(pMember1)
				n2 = CharUnicode(pMember2)
		
				if n1 <= n2
					for n = n1 to n2
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2
					for n = n1 to n2 step -1
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n > n2
							cNormalSyntax += ", "
						ok
					next
				ok
		
				cNormalSystax = stzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()
				cNormalSyntax += " ]"
		
			but isNumber(pMember1) and isNumber(pMember2)

				n1 = pMember1
				n2 = pMember2
		
				if n1 <= n2

					for n = n1 to n2
						cNormalSyntax += (""+ n)
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2

					for n = n1 to n2 step -1
						cNormalSyntax += (""+ n)
						if n > n2
							cNormalSyntax += ", "
						ok
					next
		
				ok
		
				cNormalSystax = StzStringQ(cNormalSyntax).RemoveFromEndQ(", ").Content()
				cNormalSyntax += " ]"
			ok

			cResult = StzStringQ(cNormalSyntax).ReplaceLastQ(",  ]", " ]").Content()

		ok  

		return cResult

		def ToListInNormalFormQ()
			return new stzString( This.ToListInNormalForm() )

		def ToListInStringInNormalForm()
			return This.ToListInNormalForm()

			def ToListInStringInNormalFormQ()
				return new stzString( This.ToListInStringInNormalForm() )

	def ToListInString()
		return This.ToListInNormalForm()

		def ToListInStringQ()
			return new stzString( This.ToListInString() )

	def ToListInStringSF()
		return This.ToListInShortForm()

		def ToListInStringSFQ()
			return new stzString( This.ToListInStringSF() )


	def ToList()
		/* EXAMPLES

		? Q("[1, 2, 3 ]")	#--> [ 1, 2, 3 ]
		? Q("1:3")		#--> [ 1, 2, 3 ]
		? Q("A:C")		#--> [ "A", "B", "C"]

		? Q("#1 : #3")		#--> [ "#1", "#2", "#3" ]
		? Q("day1 : day3")	#--> [ "day1", "day2", "day3" ]

		*/

		aResult = []

		oCopy = This.Copy()
		nLenCopy = oCopy.NumberOfChars()

		oCopy.Trim()


		# Case where we have a normal list syntax

		if oCopy.IsBoundedBy([ "[", "]" ])
			cCode = "aResult = " + This.Content()
			eval(cCode)
			return aResult
		ok

		# Case where we have a continuous list syntax

		nPos = oCopy.FindFirst(":")
		nLen = oCopy.NumberOfChars()

		if nLen >= 3 and oCopy.NumberOfOccurrence(":") = 1 and
		   nPos != 1 and nPos != nLen

			acParts = oCopy.Split(":")
			cPart1 = Q(acParts[1]).Trimmed()
			cPart2 = Q(acParts[2]).Trimmed()
			oPart1 = new stzString(cPart1)
			oPart2 = new stzString(cPart2)
			nLenPart1 = oPart1.NumberOfChars()
			nLenPart2 = oPart2.NumberOfChars()

			if BothAreIntegersInStrings(cPart1, cPart2)

				n1 = 0+ ring_trim(cPart1)
				n2 = 0+ ring_trim(cPart2)

				anResult = n1 : n2
				return anResult

			# Case Q(' 1 : 3 ') ~> [ 1, 2, 3 ]

			but BothAreRealsInStrings(cPart1, cPart2)

				cPart1 = ring_trim(cPart1)
				cPart2 = ring_trim(cPart2)

				nLenPart1 = len(cPart1)
				nLenPart2 = len(cPart2)

				nDec1 = 0
				nDec2 = 0

				#TODO # Check if substr() upports all unicode chars!

				nPos1 = substr(cPart1, ".")
				if nPos1 > 0
					nDec1 = nLenPart1 - nPos1
				ok

				nPos2 = substr(cPart2, ".")
				if nPos2 > 0
					nDec2 = nLenPart2 - nPos2
				ok

				nDec = Max([ nDec1, nDec2 ])

				nTempDec = CurrentRound()
				decimals(nDec)

				n1 = 0+ cPart1
				n2 = 0+ cPart2 + (1 / pow(10, nDec+1))
				nStep = 1 / pow(10, nDec)

				anResult = []

				for n = n1 to n2 step nStep
					anResult + n
				next

				decimals(nTempDec)

				return anResult

			# Case Q(' "A" : "C" ') ~> [ "A", "B", "C" ]

			but ( (oPart1.IsBoundedBy('"') or oPart1.IsBoundedBy("'") ) and
			      (oPart2.IsBoundedBy('"') or oPart2.IsBoundedBy("'") ) )

				# Case of "A" : "E"

				if  nLenPart1 = 3 and nLenPart2 = 3

					anUnicodes = ring_sort([
						@Unicode(oPart1.CharAt(2)),
						@Unicode(oPart2.CharAt(2))
					])
	
					anUnicodes = anUnicodes[1] : anUnicodes[2]
					aResult = @UnicodesToChars(anUnicodes)

					return aResult
				ok

			# Case "day1 : day3" ~> [ "day1", "day2", "day3" ]

			but BothEndWithANumber(cPart1, cPart2)

				# Extracting the first substring and number

				acChars1 = @Chars(cPart1)

				nLen1 = len(acChars1)

				cSubStr1 = ""
				cNumber1 = ""

				for j = nLen1 to 1 step -1
					if @IsNumberInString(acChars1[j])
						cNumber1 += acChars1[j]
					else
						cSubStr1 += acChars1[j]
					ok

				next

				n1 = 0+ (ring_reverse(cNumber1))
				cSubStr1 = ring_reverse(cSubStr1)

				# Extracting the second substring and number

				acChars2 = @Chars(cPart2)
				nLen2 = len(acChars2)

				cSubStr2 = ""
				cNumber2 = ""

				for j = nLen2 to 1 step -1

					if @IsNumberInString(acChars2[j])
						cNumber2 += acChars2[j]
					else
						cSubStr2 += acChars2[j]
					ok
				next

				n2 = 0+ (ring_reverse(cNumber2))
				cSubStr2 = ring_reverse(cSubStr2)

				# Composing the list

				if cSubStr1 = cSubStr2
					acResult = []

					for j = n1 to n2
						acResult + (cSubStr1 + j)
					next

					return acResult
				ok

			ok

		ok

		# Case where this syntax is provided :
		# Q("#1 : #3").ToList() and gives [ "#1", "#2", "#3" ]

		if oCopy.NumberOfOccurrence(":") = 1 and
		   oCopy.FirstChar() = "#"

			oCopy2 = oCopy
			oCopy2.RemoveSpaces()
			n = oCopy2.FindFirst(":")

			if n < oCopy2.NumberOfChars() and
			   oCopy2.NthChar(n+1) = "#"

				aoSplits = oCopy2.SplitQ(":").ToListOfStzStrings()
				oStzStrOne = aoSplits[1].RemoveFirstCharQ()
				oStzStrTwo = aoSplits[2].RemoveFirstCharQ()

				if oStzStrOne.IsNumberInString() and
				   oStzStrTwo.IsNumberInString()

					n1 = 0+ oStzStrOne.Content()
					n2 = 0+ oStzStrTwo.Content()

					acResult = []

					for i = n1 to n2
						acResult + ("#" + i)
					next

					return acResult

				ok

			ok

		ok

		# Last case : returning the string in a list

		return [ This.Content() ]

		def ToListQ()
			return new stzList( This.ToList() )

	  #==================================================#
	 #  CHECKING IF THE STRING IS MADE OF PUNCTUATIONS  #
	#==================================================#

	def IsPunctuation()
		aoChars = U( This.ToListOfStzChars() )
		nLen = len(aoChars)

		bResult = TRUE

		for i = 1 to nLen
			if NOT aoChars[i].IsPunct()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfPunctuations()
			return This.IsPunctuation()

		def CharsArePunctuations()
			return This.IsPunctuation()

		def ArePunctuations()
			return This.IsPunctuation()

		#--

		def IsPunct()
			return This.IsPunctuation()

		def IsMadeOfPunct()
			return This.IsPunctuation()

		def CharsArePunct()
			return This.IsPunctuation()

		def ArePunct()
			return This.IsPunctuation()

		#>

	  #===============================#
	 #  FINDING PUNCTUATIONS CHARS   #
	#===============================#

	def FindPunctuations()
		aoChars = This.CharsQ().ToListOfStzChars()
		nLen = len(aoChars)

		anResult = []

		for i = 1 to nLen
			if aoChars[i].IsPunctuation()
				anResult + i
			ok
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindPunctionChars()
			return This.FindPunctuations()

		def FindPunct()
			return This.FindPunctuations()

		def FindPunctChars()
			return This.FindPunctuations()

		#--

		def FindPunctuationsZ()
			return This.FindPunctuations()

		def FindPunctionCharsZ()
			return This.FindPunctuations()

		def FindPunctZ()
			return This.FindPunctuations()

		def FindPunctCharsZ()
			return This.FindPunctuations()

		#>

	  #------------------------------#
	 #  REMOVING PUNCTUATION CHARS  #
	#------------------------------#

	def RemovePunctuations()
		anPos = This.FindPunctuations()
		This.RemoveCharsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemovePunctuationsQ()
			This.RemovePunctuations()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePunctuation()
			This.RemovePunctuations()
	
			def RemovePunctuationQ()
				return This.RemovePunctuationsQ()

		#>

	#-- @PassiveForm
	def PunctuationsRemoved()
		cResult = This.Copy().RemovePunctuationsQ().Content()
		return cResult

		def PunctuationRemoved()
			return This.PunctuationsRemoved()

	  #============================#
	 #  OPERATORS OVERLOADING     #
	#============================#

	#TODO: Operators should carry same semantics in all classes...

	def operator(pOp,pValue)

		// string access : str[n]
		// string search : str[substr]

		if pOp = "[]"
			
			if isString(pValue)
				if pValue = :First or pValue = :FirsChar
					pValue = 1

				but pValue = :Last or pValue = :LastChar
					pValue = This.NumberOfChars()
				ok
			ok

			if isNumber(pValue)

				return This.NthChar(pValue)
							
			but isString(pValue)
				if StzStringQ(pValue).TrimQ().IsBoundedBy(["{","}"])
					pcCondition = StzStringQ(pValue).TrimQ().TheseBoundsRemoved("{","}")
					anResult = []

					@char = ""
					nLen = This.NumberOfChars()

					for @i = 1 to nLen
						@char = This.Char(@i)
						cCode = 'bOk = ( ' + pcCondition + ' )'

						eval(cCode)
						if bOk
							anResult + @i
						ok
					next

					return anResult
				else
					return This.FindAll(pValue)
				ok	
			ok
				// Add an item at the beginning of the list
		but pOp = "<<"
			This.Prepend(1)

		// Add an item at the end of the list
		but pOp = ">>"
			This.Append(value)

		// compare equality : oString = str

		but pOp = "="
			return This.IsEqualTo(pValue)

		// oString < str

		but pOp = "<"
			return This.IsSmallerThan(pValue)
		
		// compare : oString > str

		but pOp = ">"
			return This.IsLargerThan(pValue)
	
		// add : string + string | string + ListOfStrings

		but pOp = "+"
			if ring_type(pValue) = "STRING"
				return This.AppendedWith(pValue)

			but @IsStzString(pValue)
				This.AppendWith(pValue.Content())
				return This
		
			but isList(pValue) and Q(pValue).IsListOfStrings()
				cExtension = QR(pValue, :stzListOfStrings).Concatenated()
				cResult = This.Content() + cExtension
				return cResult

			but @IsStzListOfStrings(pValue)
				cResult = This.Content() + pValue.Concatenated()
				retur new stzString(cResult)
			ok

		// Multiply: string * n | string * string | string * list
	
		but pOp = "*"
			if @IsStzString(pValue)
				This.MultiplyBy(pValue.Content())
				return This

			but @IsStzNumber(pValue)
				This.MultiplyBy(pValue.NumericValue())
				return This

			but isList(pValue) and Q(pValue).IsListOfStrings()
				nLen = len(pValue)
				cResult = ""

				for i = 1 to nLen
					cResult += (This.Content() + pValue[i])
				next

				return cResult

			but @IsStzListOfStrings(pValue)
				nLen = len(pValue)
				cResult = ""

				for i = 1 to nLen
					cResult += (This.Content() + pValue[i])
				next

				return new stzString(cResult)

			else
				return This.MultipliedBy(pValue)
			ok

		// Split: String / n  | String / str	| String / list

		but pOp = "/"

			if isString(pValue)
				if Q(pValue).IsBoundedBy([ "{", "}" ])

					acSplitted = This.SplitW(pValue)

				else
					acSplitted = This.Split(pValue)
				ok

				return acSplitted

			but @IsStzString(pValue)
				if pValue.IsBoundedBy([ "{", "}" ])
					acSplitted = This.SplitW(pValue.Content())

				else
					acSplitted = This.Split(pValue.Content())
				ok

				return Q(acSplitted)

			but isNumber(pValue)
				return This.SplitToNParts(pValue)

			but @IsStzNumber(pValue)
				return Q(This.SplitToNParts(pValue.NumericValue()))

			but isList(pValue) and Q(pValue).IsListOfNumbers()
				acSplitted = This.SplitAtPositions(pValue)
				return acSplitted

			but @IsStzList(pValue) and pValue.IsListOfNumbers()
				acSplitted = This.SplitAtPositions(pValue.Content())
				return Q(acSplitted)

			but isList(pValue) and Q(pValue).IsPairOfStrings() and
			    pValue[1] = :where and Q(pValue[2]).IsBoundedBy([ "{" , "}" ])

				acSplitted = This.SplitW(pValue[2])
				return acSplitted
			
			but @IsStzList(pValue) and pValue.IsPairOfStrings() and
			    pValue.Content()[1] = :where and Q(pValue.Content())[2].IsBoundedBy([ "{", "}" ])

				acSplitted = This.SplitW(pValue.Content()[2])
				return Q(acSplitted)

			but isList(pValue) and Q(pValue).IsListOfStrings()
				/* EXAMPLE
				? @@( Q("RingRubyJava") / [ "Qute", "Nice", "Good" ] )
				#--> [ [ "Qute", "Ring" ], [ "Nice", "Ruby" ], [ "Good", "Java" ] ]	
				*/

				nLen = len(pValue)
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue, acSplitted ])
				return aResult

			but @IsStzList(pValue) and pValue.IsListOfStrings()
				nLen = len(pValue.Content())
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue.Content(), acSplitted ])
				return Q(aResult)

			but isList(pValue) and Q(pValue).IsHashList()
				oHashList = new stzHashList(pValue)

				# All the values except the last one must be numbers

				aValuesExceptLast = oHashList.ValuesQ().LastItemRemoved()

				if NOT Q(aValuesExceptLast).IsListOfNumbers()
					stzRaise("Incorrect values! All the values except the last, must be numbers.")
				ok

				# The last value can be a number or a string equal to :Remaining or :RemainingChars

				if NOT 	( isNumber(oHashList.LastValue()) or

					  ( isString(oHashList.LastValue()) and
					    Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ]) ) )

					stzRaise("Incorrect value! The last value mus tbe a number or a string (:Remaining or :RemainingChars).")
				ok

				# If the last value is :Remaining or :RemainingChars, the its replace by the n remaining chars

				if isString(oHashList.LastValue()) and
				   Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ])

					
					n = 0
					nLenTemp = len(aValuesExceptLast)
					for i = 1 to nLenTemp
						n += aValuesExceptLast[i]
					next

					nRemainingChars = This.NumberOfChars() - n

					pValue[ len(pValue) ][2] = nRemainingChars
				ok

				# The sum of shares must be equal to the number of chars

				if NOT StzHashListQ(pValue).ValuesQR(:stzListOfNumbers).Sum() = This.NumberOfChars()
					stzRaise("Incorrect values! The sum of numbers must be equal to the number of chars!")
				ok

				# Making the share of the string based on the values provided

				nLenValue = len(pValue)
				aResult = []
				n = 1
				for i = 1 to nLenValue
					aPair = pValue[i]
					cShare = This.Range(n, aPair[2])
					n += aPair[2]

					aResult + [ aPair[1], cShare  ]
				next

				return aResult

			but @IsStzList(pValue) and pValue.IsHashList()
				acResult = This / pValue.Content()
				return Q(acResult)
			ok
		
		// string - string | string - .25 | string - 3
		but pOp = "-"
			cResult = NULL
						
			if isString(pValue)

				cResult = This.Copy().Removed(pValue)
				return cResult

			but @IsStzString(pValue)

				oResult = This.Copy().RemoveQ(pValue.Content())
				return oResult

			but isList(pValue)

				cResult = This.RemoveManyQ(pValue).Content()
				return cResult

			but @IsStzList(pValue)

				cResult = This.RemoveManyQ(pValue.Content()).Content()
				return new stzString(cResult)

			ok

		// String % n : returns the rest of letters after dividing String / n

		but pOp = "%"

			if ring_type(pValue) = "NUMBER"

				cResult = ""
				aParts = []
		
				nParts = ceil( This.NumberOfChars() / pValue )
				for i=1 to This.NumberOfChars() step nParts
					cTemp = @oQString.mid(i-1, nParts)
					aParts + cTemp	
				next
		
				if len(aParts) < pValue
					for i = len(aParts) to pValue-1
						aParts + "_"
					next
				ok
		
				if aParts[ len(aParts) ] != "_"
					return aParts[ len(aParts) ]
				ok

				return cResult

			but @IsStzNumber(pValue)
				cResult = This % pValue.NumericValue()
				return new stzString(cResult)

			ok

		ok // --- End of operator overloading section

	  #=====================================================#
	 #  METHODS USED FOR CAMPATIBILITY WITH EXTERNAL CODE  #
	#=====================================================#

	def join(pacItems) # Python
		/* EXAMPLE

		In Python: ' + '.join([ "a", "b", "c" ])
		#--> a + b + c

		# In Ring, with Softanza:

		? Q(' + ').join([ "a", "b", "c" ])
		#--> a + b + c

		*/

		if NOT ( isList(pacItems) and Q(pacItems).IsListOfStrings() )
			StzRaise("Incorrect param type! pacItems must be a list of strings.")
		ok

		cResult = QR(pacItems, :stzListOfStrings).ConcatenatedUsing(This.String())
		return cResult

	  #==========================================#
	 #   METHODS USED FOR NEAR-NATURAL-CODING   #
	#==========================================#

	def IsAlmostAFunctionCall()
		# Why almost? Because it doesn't analyse the correctness of the params
		# which we should do in the future, but this is sufficient for our
		# actual needs in stzChainOfTruth and other classes of natural-coding

		# PS: if you you don't like sutch a precison, use the alternative name
		# IsFunctionCall() instead.

		if This.NumberOfOccurrence("(") = 1 and
		   This.NumberOfOccurrence(")") = 1 and
		   This.FindFirst("(") > 1 and
		   This.FindFirst("(") < This.FindFirst(")") and
		   This.LastChar() = ")" // and #TODO: complete this and remove "Almost" from the function name!
		   //This.SectionQ(1,  This.FindFirst("(") - 1).ContainsOnly(:CompterCodeChars)
		
			return TRUE
		else
			return FALSE
		ok

		#< FunctionAlternativeForms >

		def IsFunctionCall()
			return This.IsAlmostAFunctionCall()
		#>

	def IsAMethodOfThisObject(pObject)
		return This.String().ExistsIn( classes(pObject) )

		def IsMethodOfObject(pObject)
			return IsAMethodOfThisObject(pObject)

	def IsAnAttributeOfThisObject(pObject)
		return This.String().ExistsIn( attributes(pObject) )

		def IsAttributeOfObject(pObject)
			return IsAnAttributeOfThisObject(pObject)		 

	#-----------------

	def IsStzString()
		return TRUE

	def StzType()
		return :stzString

	def IsANumber()
		return FALSE

		def IsNotANumber()
			return TRUE

	def IsAString()
		return TRUE

		def IsNotAString()
			return FALSE

	def IsAList()
		return FALSE

		def IsNotAList()
			return TRUE

	def IsAnObject()
		return TRUE

		def IsAObject()
			return TRUE

		def IsNotAnObject()
			return FALSE

	  #=====================================================#
	 #  CHECKING IF THE STRING STARTS WITH A GIVEN NUMBER  #
	#=====================================================#

	def StartsWithThisNumber(n)
		
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).RemoveSpacesQ().
					 RemoveQ("_").
					 ThisFirstCharRemoved("+")
			ok
		ok

		oStrCopyWS = This.Copy().RemoveSpacesQ()
		cLeadingNumber = Q(oStrCopyWS.LeadingNumber()).ThisFirstCharRemoved("+")

		if  cLeadingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def ContainsThisStartingNumber(n)
			return This.StartsWithThisNumber(n)

		def ContainsThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def HasThisLeadingNumber(n)
			return This.StartsWithThisNumber(n)

		def HasThisStartingNumber(n)
			return This.StartsWithThisNumber(n)

		#--

		def StartsWithNumberN(n)
			return This.StartsWithThisNumber(n)

		def StartsWithLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def ContainsStartingNumberN(n)
			return This.StartsWithThisNumber(n)

		def ContainsLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def HasLeadingNumberN(n)
			return This.StartsWithThisNumber(n)

		def HasStartingNumberN(n)
			return This.StartsWithThisNumber(n)

		#>
		
	  #-----------------------------------------------#
	 #  CHECKING IF THE STRING STARTS WITH A NUMBER  #
	#-----------------------------------------------#

	def StartsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.StartsWithANumber()
		#--> TRUE
		*/

		oStrCopyWS = This.Copy().RemoveSpacesQ()

		if  oStrCopyWS.FirstCharQ().IsANumberInString() or

		    ( oStrCopyWS.NumberOfChars() > 1 and
		      oStrCopyWS.FirstCharQ().IsEither("+", :Or = "-") and
		      oStrCopyWS.SecondCharQ().IsANumberInString() )

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingNumber()
			return This.StartsWithANumber()

		def ContainsAStartingNumber()
			return This.StartsWithANumber()

		def ContainsALeadingNumber()
			return This.StartsWithANumber()

		def HasALeadingNumber()
			return This.StartsWithANumber()

		def HasAStartingNumber()
			return This.StartsWithANumber()

		#--

		def StartsWithNumber()
			return This.StartsWithANumber()

		def BeginsWithNumber()
			return This.StartsWithANumber()

		def BeginsWithANumber()
			return This.StartsWithANumber()

		#>

	  #-----------------------------------------------------#
	 #  GETTING THE LEADING NUMBER (IF ANY) IN THE STRING  #
	#-----------------------------------------------------#

	def StartingNumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		o1.StartingNumber()
		#--> 23
		*/

		if NOT This.HasALeadingNumber()
			return ""
		ok

		cResult = ""
		bContinue = TRUE
		i = 0
		nLen = This.NumberOfChars()

		while bContinue
			i++
			if i > nLen
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "_", "." ]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).
			  RemoveSpacesQ().
			  RemoveThisFirstCharQ("+").
			  ThisLastCharRemoved(".")

		return cResult

		#< @FunctionAlternativeForm

		def LeadingNumber()
			return This.StartingNumber()

		def BeginningNumber()
			return This.StartingNumber()

		#>
	
  	  #===================================================#
	 #  CHECKING IF THE STRING ENDS WITH A GIVEN NUMBER  #
	#===================================================#

	def EndsWithThisNumber(n)
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).ThisFirstCharRemoved("+")
			ok
		ok

		cTrailingNumber = Q(This.TrailingNumber()).ThisFirstCharRemoved("+")

		if  cTrailingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithThisTrailingNumber(n)
			return This.EndsWithThisNumber(n)

		def EndsWithThisFinalNumber(n)
			return This.EndsWithThisNumber(n)

		def ContainsThisTrailingNumber(n)
			return This.EndsWiththisNumber(n)

		def ContainsThisFinalNumber(n)
			return This.EndsWithThisNumber(n)

		def ContainsThisEndingNumber(n)
			return This.EndsWithThisNumber(n)

		#--

		def EndsWithNumberN(n)
			return This.EndsWithThisNumber(n)

		def EndsWithTrailingNumberN(n)
			return This.EndsWithThisNumber(n)

		def EndsWithFinalNumberN(n)
			return This.EndsWithThisNumber(n)

		def ContainsTrailingNumberN(n)
			return This.EndsWiththisNumber(n)

		def ContainsFinalNumberN(n)
			return This.EndsWithThisNumber(n)

		def ContainsEndingNumberN(n)
			return This.EndsWithThisNumber(n)

		#>
		
	  #---------------------------------------------#
	 #  CHECKING IF THE STRING ENDS WITH A NUMBER  #
	#---------------------------------------------#

	def EndsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.EndsWithNumber()
		#--> TRUE
		*/

		nResult = This.LastCharQ().IsANumberInString()
		return nResult

		#< @FunctionAlternativeForms

		def EndsWithATrailingNumber()
			return This.EndsWithNumber()

		def EndsWithAFinalNumber()
			return This.EndsWithNumber()

		def ContainsATrailingNumber()
			return This.EndsWithNumber()

		def ContainsAFinalNumber()
			return This.EndsWithNumber()

		def ContainsAnEndingNumber()
			return This.EndsWithNumber()

		#--

		def EndsWithNumber()
			return This.EndsWithNumber()

		#>

	  #------------------------------------------------------#
	 #  GETTING THE TRAILING NUMBER (IF ANY) IN THE STRING  #
	#------------------------------------------------------#

	def TrailingNumber()
		/* EXAMPLE
		o1 = new stzString("Age: 48")
		o1.TrailingNumber()
		#--> 48
		*/

		cResult = ""
		bContinue = TRUE
		i = This.NumberOfChars() + 1

		while bContinue
			i--
			if i = 0
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "."]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).ReverseCharsQ().ThisLastCharRemoved(".")
		return cResult

		#< @FunctionAlternativeForm

		def FinalNumber()
			return This.StartingNumber()

		def EndingNumber()
			return This.StartingNumber()

		#>

	  #==============================================================#
	 #  GETTING ALL THE (DECIMAL) NUMBERS THAT EXIST IN THE STRING  #
	#==============================================================#
 
	def Numbers()
		/* EXAMPLE

		o1 = new stzString("book: 12.34, watch: -56.30, glasses: 77.")
		? o1.Numbers()
		#--> [ "13.34", "-56.30",  "77" ]

		*/

		cTempStr = This.Content() + " "
		nLen = This.NumberOfChars() + 1

		cNumber = ""
		acResult = []
		bThereWasASign = FALSE

		for i = 1 to nLen
			c = Q(cTempStr).CharAt(i)

			if c = " " and bThereWasASign
				loop
			ok

			if StzCharQ(c).IsANumber() or
			   (c = "+" or c = "-" and cNumber = "") or
			   ((c = "." or c = "_") and cNumber != "" and StzCharQ(Q(cNumber).LastChar()).IsANumber())
		
				cNumber += c

			but (NOT StzCharQ(c).IsANumber()) or i = nLen
		
				if cNumber != ""
		
					cNumber = Q(cNumber).
						  RemoveThisLastCharQ(".").
						  RemoveThisLastCharQ("_").
						  Content()
		
					cSign = ""
					if len(acResult) > 0
						if acResult[len(acResult)] = "+"
							cSign = "+"

						but acResult[len(acResult)] = "-"
							cSign = "-"
						ok
					ok

					if cSign != ""
						del(acResult, len(acResult))
						cNumber = cSign + cNumber
					ok

					if cNumber != "+" and cNumber != "-"
						acResult + cNumber
						cNumber = ""
					ok
				ok
			ok
		
		next
		
		return acResult

		def NumbersQ()
			return This.NumbersQR(:stzList)

		def NumbersQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfStrings
				return new stzList( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

	  #--------------------------------------#
	 #  EXTRACTING NUMBERS FROM THE STRING  #
	#--------------------------------------#

	def ExtractNumbers()
		acNumbers = This.Numbers()
		This.RemoveMany(acNumbers)
		return acNumbers

	  #------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF (DECIMAL) NUMBERS INCLUDED IN THE STRING  #
	#------------------------------------------------------------------#

	def NumberOfNumbers()
		return len( This.Numbers() )

		#< @FunctionAlternativeForms

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumbers()
			return This.NumberOfNumbers()

		def HowManyNumber()
			return This.NumberOfNumbers()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------#

	def NumbersAndTheirPositions() #TODO: Check performance!
		aResult = Q(This.UniqueNumbers()).AssociatedWith( This.FindNumbers() )
		return aResult

		def NumbersZ()
			return This.NumbersAndTheirPositions()

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR SECTIONS  #
	#------------------------------------------------------------------------#

	def NumbersAndTheirSections() #TODO: chek performance!
		aResult = []
		acNumbersU = This.UniqueNumbers()
		nLen = len(acNumbersU)

		for i = 1 to nLen
			aResult + [ acNumbersU[i], This.FindAsSections(acNumbersU[i]) ]
		next

		return aResult


		def NumbersZZ()
			return This.NumbersAndTheirSections()

	  #----------------------------------------------------#
	 #  GETTING THE LIST OF UNIQUE NUMBERS IN THE STRING  #
	#----------------------------------------------------#

	def UniqueNumbers()
		return This.NumbersQ().DuplicatesRemoved()

		#< @FunctionAlternativeForms

		def NumbersU()
			return This.UniqueNumbers()

		def NumbersWithoutDuplication()
			return This.UniqueNumbers()

		#>

	  #-------------------------------------------------------#
	 #  GETTTING THE NUMBER OF UNIQUE NUMBERS IN THE STRING  #
	#-------------------------------------------------------#

	def NumberOfUniqueNumbers()
		return len( This.UniqueNumbers() )

		#< @FunctionAlternativeForms

		def CountUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def NumberOfNumbersU()
			return This.NumberOfUniqueNumbers()

		def CountNumbersU()
			return This.NumberOfUniqueNumbers()

		#--

		def HowManyUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersU()
			return This.NumberOfUniqueNumbers()

		def HowManyUniqueNumber()
			return This.NumberOfUniqueNumbers()

		def HowManyNumberU()
			return This.NumberOfUniqueNumbers()

		#--

		def NumberOfNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (POSITIONS RETURNED)  #
	#----------------------------------------------------------------#

	def FindNumbers()
		anResult = This.FindManyQ( This.UniqueNumbers() ).FlattenQ().Sorted()
		return anResult

	  #---------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (SECTIONS RETURNED)  #
	#---------------------------------------------------------------#

	def FindNumbersAsSections()
		return This.FindManyAsSections( This.UniqueNumbers() )

		def FindNumbersSections()
			return This.FindNumbersAsSection()

		def FindAsSectionsOfNumbers()
			return This.FindNumbersAsSection()

	  #--------------------------------------------------------------#
	 #  GETTING THE NTH (DECIMAL) NUMBER THAT EXISTS IN THE DTRING  #
	#--------------------------------------------------------------#

	def NthNumber(n)
		if isString(n)
			if n = :First or n = :FirstNumber
				n = 1

			but n = :Last or n = :LastNumber
				n = len( This.Numbers() )
			ok
		ok

		return This.Numbers()[n]

	  #------------------------------------------------------#
	 #  GETTING THE FIRST NUMBER THAT EXISTS IN THE DTRING  #
	#------------------------------------------------------#

	def FirstNumber(n)
		return This.NthNumber(1)

	  #-----------------------------------------------------#
	 #  GETTING THE LAST NUMBER THAT EXISTS IN THE DTRING  #
	#-----------------------------------------------------#

	def LastNumber(n)
		return This.NthNumber(This.NumberOfNumbers())

	  #==========================================#
	 #  NUMBERS COMING AFTER A GIVEN SUBSTRING  #
	#==========================================#

	def NumbersComingAfterCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("This[@i-1] = This[@i+3]")
		? o1.NumbersComingAfter("@i")
		#--> [ "-1", "3" ]

		? o1.NumberComingAfter("@i+")
		#--> 3
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		acSubStr = This.SplitQ("@i").FirstItemRemoved()
		# Splitting takes as little as 0.01s

		nLen = len(acSubStr)
	
		acResult = []
		for i = 1 to nLen
			acNumbers = Q(acSubStr[i]).Numbers()
			nLen2 = len(acNumbers)

			for j = 1 to nLen2
				acResult + acNumbers[j]
			next j
		next i

		return acResult


		#< @FunctionFluentForm

		def NumbersComingAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, :stzList)

		def NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				stzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NumbersAfterCS(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCS(pcSubStr, pCaseSensivitive)

		def NumbersAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbesrAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def NumbersAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumbersComingAfter(pcSubStr)
		return This.NumbersComingAfterCS(pcSubStr, TRUE)

		#< @FunctionFluentForm

		def NumbersComingAfterQ(pcSubStr)
			return This.NumbersComingAfterQR(pcSubStr, :stzList)

		def NumbersComingAfterQR(pcSubStr, pcReturnType)
			return This.NumbersComingAfterCSQR(pcSubStr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NumbersAfter(pcSubStr)
			return This.NumbersComingAfter(pcSubStr)

		def NumbersAfterQ(pcSubStr)
			return This.NumbesrAfterQR(pcSubStr, pcReturnType)

		def NumbersAfterQR(pcSubStr, pcReturnType)
			return NumbersComingAfterQR(pcSubStr, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  NTH NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#---------------------------------------------#

	def NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)
		#TODO: Re-implement it for better performance
		# No need to parse all the numbers and then get the nth

		return This.NumbersComingAfterCS(pcSubStr, pCaseSensitive)[n]

		#< @FunctionAlternativeForm

		def NthNumberAfterCS(n, pcSubStr, pCaseSensitive)
			return This.NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthNumberComingAfter(n, pcSubStr)
		return This.NthNumberComingAfterCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def NthNumberAfter(n, pcSubStr)
			return This.NthNumberComingAfter(n, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #  FIRST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(1, pcSubStr, pCaseSensitive)

		def NumbeComingAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FirstNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FirstNumberComingAfter(pcSubStr)
		return This.FirstNumberComingAfterCS(pcSubStr, TRUE)

		def NumberComingAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#< @FunctionAlternativeForm

		def FirstNumberAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#>

	  #----------------------------------------------#
	 #  LAST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def LastNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(:Last, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.LastNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def LastNumberComingAfter(pcSubStr)
		return This.LastNumberComingAfterCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForm

		def LastNumberAfter(pcSubStr)
			return This.LastNumberComingAfter(pcSubStr)

		#>

	  #====================================#
	 #  BISECTING THE STRING INTO HALVES  #
	#====================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()
		
	def FirstHalfXT()

		nPos = ceil(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult
		
	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
				return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

	  #==========================================#
	 #   STRINGIFY(), TOSTRING(), AND TOCODE()  #
	#==========================================#

	def Stringify()
		# Do nothing, the object is naturally stringified
		# becauses it is already a string

		def StringifyQ()
			return This

	def Stringified()
		return This.Content()

	def ToString()
		return This.Content()

		def ToStringQ()
			return new stzString( This.Content() )
	
	def ToCode()
		cResult = ""

		cQuote = "'"
		cDoubleQuote = '"'

		if This.IsBoundedBy(cDoubleQuote)
			cResult = cQuote + This.String() + cQuote

		but This.IsBoundedBy(cQuote)
			cResult = cDoubleQuote + This.String() + cDoubleQuote

		else
			cResult = This.String()
		ok

		return cResult

		def ToCodeQ()
			return new stzString( This.ToCode() )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE COMMON SUBSTRINGS BETWEEN THIS STRING AND AN OTHER STRING  #
	#-------------------------------------------------------------------------#

	def CommonSubStringsCS(pcOtherStr, pCaseSensitive)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		aTempList = [
			This.SubStringsCS(pCaseSensitive),
			Q(pcOtherStr).SubStringsCS(pCaseSensitive)
		]

		acResult = StzListOfListsQ(aTempList).CommonItemsCS(pCaseSensitive)
		
		return acResult

		def IntersectionCS(pcOtherStr, pCaseSensitive)
			return This.CommonSubStringsCS(pcOtherStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CommonSubStrings(pcOtherStr)
		return This.CommonSubStringsCS(pcOtherStr, TRUE)

		def Intersection(pcOtherStr)
			return This.CommonSubStrings(pcOtherStr)

	  #======================#
	 #  SHOWING THE STRING  #
	#======================#

	def Show()
		? @@( This.Content() )

		#< @FuntionMisspelledForm

		def Shwo()
			This.Show()

		#>

	def ShowShort()
		? @@( This.Shortened() )

		def ShowShortCopy()
			This.ShowShort()

		#< @FuntionMisspelledForm

		def ShwoShort()
			This.ShowShort()

		def ShwoShortCopy()
			This.ShowShort()

		#>

	def ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		? @@( This.ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart) )

		def ShowShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		#< @FuntionMisspelledForm

		def ShwoShortXT(nMinStrSize, oNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		def ShwoShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

		#>

	def ShowShortN(n)
		? @@( This.ShortenedN(n) )

		#< @FuntionMisspelledForm

		def ShwoShortN(n)
			This.ShowShortN(n)

		#>

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortUsing(pcMiddlePart)
			This.ShowShortUsing(pcMiddlePart)

		#>

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortNUsing(n, pcMiddlePart)
			This.ShowShortNUsing(n, pcMiddlePart)

		#>

	  #-------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING  #
	#===========================================#

	def ToShort()
		return This.ToShortXT(10, 3, " (...) ")

	  #-----------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING WITH N ITEMS FROM EACH SIDE  #
	#-----------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, " (...) ")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USiNG A GIVEN MIDDLE PART  #
	#---------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #--------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#--------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #------------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE STRING -- EXTENDED  #
	#------------------------------------------------------#

	def ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		# nMinStrSize : the minimum size to start shprtening
		# --> if the size of the string is less than this value,
		#     the string will not be shortened (returned as is)

		# pNumberOfCharsToShow: the number of chars to show from
		# both the beginning and end of the string
		# --> the other part of the string (coming in the middle)
		#     will be hide and replaced by pcMiddlePart

		/* EXAMPLES

		? Q("1234567890987654321").Shortened()
		#--> 123 ... 321
		
		? Q("1234567890987654321").ShortenedN(5)
		#--> 12345 ... 54321
		
		? Q("1234567890987654321").ShortenedXT(0, 3, " ... ")
		#--> 123 ... 321

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinStrSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfCharsToShow)
			n1 = pNumberOfCharsToShow
			n2 = pNumberOfCharsToShow

		but isList(p) and Q(pNumberOfCharsToShow).IsPairOfNumbers()
			n1 = pNumberOfCharsToShow[1]
			n2 = pNumberOfCharsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfCharsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of chars to show must be different of zero.")
		ok

		# Doing the job

		cPart1 = This.Section(1, n1)
		cPart2 = This.Section(nLen - n2 + 1, nLen)

		cResult = cPart1 + pcMiddlePart + cPart2

		return cResult

	  #-------------------------#
	 #  SHORTENING THE STRING  #
	#=========================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #---------------------------------------------------#
	 #  SHORTENING THE STRING TO N CHARS FROM EACH SIDE  #
	#---------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNChars(n)
			This.ShortenN(n)

			def ShortenToNICharsQ(n)
				This.ShortenToNChars(n)
				return This

		def ShortenToNCharsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsInEachSideQ(n)
				This.ShortenToNCharsInEachSide(n)
				return This

		def ShortenToNCharsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsFromEachSideQ(n)
				This.ShortenToNCharsFromEachSide(n)
				return This

		def ShortenToNCharsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsAtEachSideQ(n)
				This.ShortenToNCharsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNChars(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNICharsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #-----------------------------------------------------------------#
	 #  SHORTENING THE STRING USING THE GIVEN STRING AS A MIDDLE PART  #
	#-----------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE STRING -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart).Content()
		return cResult

	  #===========================================#
	 #  GETTING THE LIST OF WORDS IN THE STRING  #
	#===========================================#

	#NOTE: stzString has a limited understanding of what a word is.
	# In fact, i't just a substring bounded by two spaces (or one space
	# if it is at the start or the end of the substring.

	# To get a more appealling meaning of Word(), use stzText instead.

	def WordsCS(pCaseSensitive)
		acResult = This.RemovePunctuationsQ().SplitQ(" ").ToSetCS(pCaseSensitive)
		return acResult

		def WordsCSQ(pCaseSensitive)
			return WordsCSQR(pCaseSensitive, :stzList)

		def WordsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.WordsCS(pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.WordsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

	#-- WITHOUT CASESENSITIVITY

	def Words()
		return This.WordsCS(TRUE)

		def WordsQ()
			return This.WordsQR(:stzList)

		def WordsQR(pcReturnType)
			return This.WordsCSQR(TRUE, pcReturnType)

	  #---------------------------------------------------#
	 #   GETTING THE LIST OF WORDS WITHOUT DUPPLICATION  #
	#---------------------------------------------------#

	def WordsCSU(pCaseSensitive)
		acResult = This.WordsCSQ(pCaseSensitive).ToSet()
		return acResult

		#< @FunctionFulentForms

		def WordsCSUQ(pCaseSensitive)
			return WordsCSUQR(pCaseSensitive, :stzList)

		def WordsCSUQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.WordsCSu(pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.WordsCSU(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def UniqueWordsCS(pCaseSensitive)
			return This.WordsCSU(pCaseSensitive)

		def UniqueWordsCSQ(pCaseSensitive)
			return This.WordsCSUQ(pCaseSensitive)

		def UniqueWordsCSQR(pCaseSensitive, pcReturnType)
			return ThisWordsCSUQR(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def WordsU()
		return This.WordsCSU(TRUE)

		#< @FunctionAlternativeForms

		def WordsUQ()
			return This.WordsUQR(:stzList)

		def WordsUQR(pcReturnType)
			return This.WordsCSUQR(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def UniqueWords()
			return This.WordsU()

		def UniqueWordsQ()
			return This.WordsUQ()

		def UniqueWordsQR(pcReturnType)
			return ThisWordsUQR(pcReturnType)

		#>
		
	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRING CORRESPONDS TO A WORD OF THE STRING  #
	#========================================================================#

	def SubStringIsWordCS(pcSubStr, pCaseSensitive) #TODO: Check for performance!
		bResult = This.WordsCSQ(pCaseSensitive).ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForm

		def SubStringIsAWordCS(pcSubStr, pCaseSensitive)
			return This.SubStringIsWordCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsWord(pcSubStr)
		return This.SubStringIsWordCS(pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def SubStringIsAWord(pcSubStr)
			return SubStringIsWord(pcSubStr)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRINGS CORRESPOND TO A WORDS OF THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringsAreWordsCS(acSubStr, pCaseSensitive) #TODO: check for performance!

		if CheckParams() = TRUE
			if NOT (isList(acSubStr) and Q(acSubStr).IsLIstOfStrings())
				StzRaise("Incorrect param type! acSubStr must be a list pf strings.")
			ok
		ok

		bResult = TRUE

		nLen = len(acSubStr)
		for i = 1 to nLen
			if NOT This.SubStringIsWordCS(acSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok

		next

		return bResult
		
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringsAreWords(acSubStr)
		return This.SubStringsAreWordsCS(acSubStr, TRUE)

	  #-----------------------------------#
	 #  FINDING THE WORDS IN THE STRING  #
	#===================================#

	def FindWordsCS(pCaseSensitive)

		acSplittedZ = This.SplitCSZ(" ", pCaseSensitive)
		anResult = U( QR(acSplittedZ, :stzListOfPairs).SecondItems() )

		return anResult

		def PositionsOfWordsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

		def WordsPositionsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWords()
		return This.FindWordsCS(TRUE)

		def PositionsOfWords()
			return This.FindWords()

		def WordsPositions()
			return This.FindWords()

	  #-----------------------------------------------------------------------------#
	 #  FINDING THE WORDS IN THE STRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-----------------------------------------------------------------------------#

	def FindWordsAsSectionsCS(pCaseSensitive)

		acSplittedZZ = This.SplitCSZZ(" ", pCaseSensitive)
		aResult = QR(acSplittedZZ, :stzListOfPairs).SecondItems()

		return aResult

		def SectionsOfWordsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

		def WordsSectionsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWordsAsSections()
		return This.FindWordsAsSectionsCS(TRUE)

		def SectionsOfWords()
			return This.FindWordsAsSections()

		def WordsSections()
			return This.FindWordsAsSections()

	  #--------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def WordsCSZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirPositionsCS(pCaseSensitive)
			return This.WordsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZ()
		return This.WordsCSZ(TRUE)

		def WordsAndTheirPositions()
			return This.WordsZ()

	  #-------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------#

	def WordsCSZZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirSectionsCS(pCaseSensitive)
			return This.WordsCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZZ()
		return This.WordsCSZZ(TRUE)

		def WordsAndTheirSections()
			return This.WordsZZ()

	   #=====================================================#
	  #   CHECKING IF STRING OCCURES BEFORE/AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST              #
	#=====================================================#

	#NOTE
	# These functions have been abstracted in stzObject so
	# we can use them with any type not only a string

	# Here is the list of those functions:
	# 	Occurs(pValue, pIn)
	# 	OccursBefore(pValue, pIn)
	# 	OccursAfter(pValue, pIn)
	# 	OccursBetween(pValue1, pValue2, pIn)
	# 	OccursNTimes( n, pIn )
	# 	OccursForTheNthTimeAt(n, pIn, pnAt)

	  #===========#
	 #   MISC.   #
	#===========#
		
	def HasSameTypeAs(p)
		return isString(p)

	def IsAnagramOfCS(pcOtherStr, pCaseSensitive)

		oTheseChars = This.CharsQR(:stzListOfStrings).RemoveduplicatesQ().SortInAscendingQ()

		cOtherChars = StzStringQ( pcOtherStr ).
				CharsQ().RemoveDuplicatesQ().
				SortInAscendingQ().Content()
	
		bResult = oTheseChars.IsEqualToCS( cOtherChars, pCaseSensitive )

		return bResult

	def IsAnagramOf(pcOtherStr)
		return This.IsAnagramOfCS(pcOtherStr, TRUE)

	def UpTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() < CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar)
				acResult + StzCharQ(n).Content()
			next
			return acResult
		ok

	def DownTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() > CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar) step -1 
				acResult + StzCharQ(n).Content()
			next

			return acResult
		ok

	def FirstAndLastChars()
		aResult = [ This.FirstChar(), This.LastChar() ]
		return aResult

	def LastAndFirstChars()
		aResult = [ This.LastChar(), FirstChar() ]
		return aResult
		
	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzstring"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	def IsLatinScript()
		return This.ToStzText().IsLatinScript()

		def IsLatin()
			return This.IsLatinScript()

	def IsArabicScript()
		return This.ToStzText().IsArabicScript()

		def IsArabic()
			return This.IsArabicScript()

	def IsText()
		return TRUE

	def ToStzCCode()
		return new stzCCode(This.String())

		def ToStzCCodeObject()
			return This.ToStzCCode()

		def ToStzCCodeQ()
			return This.ToStzCCode()
  
	#==
               
	def SubStringCS(pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsInOrInStringNamedParam()
			return This.SubStringInCS(pcSubStr[2], pCaseSensitive)
		ok

		if This.ContainsCS(pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			return NULL
		ok

		def SubStringCSQ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsInOrInStringNamedParam()
				return This.SubStringInCSQ(pcSubStr[2], pCaseSensitive)
			ok
	
			return new stzSubStringCS(pcSubStr, This.String(), pCaseSensitive)

	def SubString(pcSubStr)
		return This.SubStringCS(pcSubStr, TRUE)

		def SubStringQ(pcSubStr)
			return This.SubStringCSQ(pcSubStr, TRUE)

	#--

	def InCS(p, pCaseSensitive)
		if NOT (isString(p) or isList(p))
			StzRaise("Incorrect param type! p must be string or list.")
		ok

		if isString(p)
			return SubStringInCS(p, pCaseSensitive)

		but isList(p)
			return ItemInCS(p, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def InCSQ(p, pCaseSensitive)
			if NOT (isString(p) or isList(p))
				StzRaise("Incorrect param type! p must be string or list.")
			ok
	
			if isString(p)
				return SubStringInCSQ(p, pCaseSensitive)
	
			but isList(p)
				return ItemInCSQ(p, pCaseSensitive)
			ok

		#>

		#< @FunctionAlternativeForm

		def _In(p)
			return InCS(p, TRUE)

			def InQ(p)
				return InCSQ(p, TRUE)

		#>

	#--

	def SubStringInCS(pcStr, pCaseSensitive)
		if THis.ExistsInCS(pcStr, pCaseSensitive)
			return This.Content()
		else
			return NULL
		ok

		def SubStringInCSQ(pcStr, pCaseSensitive)
			return new stzSubStringCS(This.Content(), pcStr, pCaseSensitive)


	def SubStringIn(pcStr)
		return This.SubStringInCS(pcStr, TRUE)

		def SubStringInQ(pcStr)
			return new stzSubString(This.Content(), pcStr)

	#--

	def ItemInCS(paList, pCaseSensitive)
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if This.ExistsInCS(paList, pCaseSensitive)
			return This.Content()
		else
			return NULL
		ok

		def ItemInCSQ(paList, pCaseSensitive)
			return new stzItemCS(This.Content(), paList, pCaseSensitive)

	def ItemIn(paList)	
		return This.ItemInCS(paList, TRUE)

	# Swapping the content of the stzString with an other stzString

	def SwapWith(pOtherStzString)

		if CheckParams()

			if NOT @IsStzString(pOtherStzString)
				StzRaise("Incorrect param type! pOtherStzString must be a stzString object.")
			ok
	
		ok

		cThis = This.Content()
		cOther = pOtherStzString.Content()

		This.UpdateWith(cOther)
		pOtherStzString.UpdateWith(cThis)

		def SwapWithQ(pOtherStzString)
			This.SwapWith(pOtherStzString)
			return This

		def SwapContentWith(pOtherStzString)
			This.SwapWith(pOtherStzString)

			def SwapContentWithQ(pOtherStzString)
				return This.SwapWithQ(pOtherStzString)


                 ///////////////////////////////////////////////
                //                              ///////////////
      ///////////      ALTERNATIVE FORMS       /////////////
 ///////////////                              //
///////////////////////////////////////////////

	  #--------------------------#
	 #  ALTERNATIVES OF Find()  #
	#--------------------------#

	def FindAllOccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllOccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
						
		def FFindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
	
	def FindAllCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindAllCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindSubstringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindSubstringCSQ(pcSubStr, pCaseSensitive)
			return This.FindSubstringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindSubstringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def OccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def OccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.OccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def OccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsOfSubStringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsOfSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindPositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindPositionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindPositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindPositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)


	#-- WITHOUT CASESENSITIVITY

	def FindAll(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindAllQ(pcSubStr)
			return This.FindAllQR(pcSubStr, :stzList)
				
		def FindAllQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindSubStringQ(pcSubStr)
			return This.FindSubStringQR(pcSubStr, :stzList)
				
		def FindSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Occurrences(pcSubStr)
		return This.Find(pcSubStr)
	
		def OccurrencesQ(pcSubStr)
			return This.OccurrencesQR(pcSubStr, :stzList)
				
		def OccurrencesQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Positions(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsQ(pcSubStr)
			return This.PositionsQR(pcSubStr, :stzList)
				
		def PositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)
	
	def PositionsOfSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsOfSubStringQ(pcSubStr)
			return This.PositionsOfSubStringQR(pcSubStr, :stzList)
				
		def PositionsOfSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindPositions(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindPositionsQ(pcSubStr)
			return This.FindPositionsQR(pcSubStr, :stzList)
				
		def FindPositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	  #-------------------------------------------#
	 #  FINDING A SUBSTRING AT A GIVEN POSITION  #
	#-------------------------------------------#

	def FindAtCS(n, pcSubStr, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		if ring_find(anPos, n)
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionFluentForm

		def FindAtCSQ(n, pcSubStr, pCaseSensitive)
			This.FindAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def FindSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindASubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindASubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#==

		def FindSubStringAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		def FindAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindASubStringAtPositionNCS(n, pcSubStr, pCaseSensitive)
			return This.FindAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAt(n, pcSubStr)
		return This.FindAtCS(n, pcSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringAt(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindSubStringAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#--

		def FindASubStringAt(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindASubStringAtPosition(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#==

		def FindSubStringAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		def FindAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#--

		def FindASubStringAtPositionN(n, pcSubStr)
			return This.FindAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A CHAR INSIDE THE STING  #
	#======================================================#

	def FindCharCS(c, pCaseSensitive)
		anResult = This.FindCS(c, pCaseSensitive)
		return anResult

		def FindCharCSZ(c, pCaseSensitive)
			return This.FindCharCS(c, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def FindChar(c)
		return This.FindCharCS(c, TRUE)

		def FindCharZ(c)
			return This.FindChar(c)

	  #---------------------------------------------------------#
	 #  FINDING THE NTH OCCURRENCE OF A CHAR INSIDE THE STING  #
	#---------------------------------------------------------#

	def FindNthCharCS(n, cChar, pCaseSensitive)
		nResult = This.FindNthCS(n, cChar, pCaseSensitive)
		return nResult

		#< @FunctiionAlternativeForms

		def FindNthCharCSZ(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		#--

		def FindNthOccurrenceOfCharCS(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		def FindNthOccurrenceOfCharCSZ(n, cChar, pCaseSensitive)
			return This.FindNthCharCS(n, cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindNthChar(n, cChar)
		return This.FindNthCharCS(n, cChar, TRUE)

		#< @FunctionAlternativeForms

		def FindNthCharZ(n, cChar)
			return This.FindNthChar(n, cChar)

		#--

		def FindNthOccurrenceOfChar(n, cChar)
			return This.FindNthChar(n, cChar)

		def FindNthOccurrenceOfCharZ(n, cChar)
			return This.FindNthChar(n, cChar)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING THE FIRST OCCURRENCE OF A CHAR INSIDE THE STING  #
	#-----------------------------------------------------------#

	def FindFirstCharCS(cChar, pCaseSensitive)

		nResult = This.FindNthOccurrenceOfCharCS(1, cChar, pCaseSensitive)
		return nResult

		#< @FunctiionAlternativeForms

		def FindFirstCharCSZ(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		#--

		def FindFirstOccurrenceOfCharCS(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		def FindFirstOccurrenceOfCharCSZ(cChar, pCaseSensitive)
			return This.FindFirstCharCS(cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindFirstChar(cChar)
		return This.FindFirstCharCS(cChar, TRUE)

		#< @FunctiionAlternativeForms

		def FindFirstCharZ(cChar)
			return This.FindFirstChar(cChar)

		#--

		def FindFirstOccurrenceOfChar(cChar)
			return This.FindFirstChar(cChar)

		def FindFirstOccurrenceOfCharZ(cChar)
			return This.FindFirstChar(cChar)

		#>

	  #----------------------------------------------------------#
	 #  FINDING THE LAST OCCURRENCE OF A CHAR INSIDE THE STING  #
	#----------------------------------------------------------#

	def FindLastCharCS(cChar, pCaseSensitive)

		n = This.NumberOfOccurrenceCS(c, pCaseSensitive)
		nResult = This.FindNthOccurrenceOfCharCS(n, cChar, pCaseSensitive)

		return nResult

		#< @FunctiionAlternativeForms

		def FindLastCharCSZ(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		#--

		def FindLastOccurrenceOfCharCS(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		def FindLastOccurrenceOfCharCSZ(cChar, pCaseSensitive)
			return This.FindLastCharCS(cChar, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindLastChar(cChar)
		return This.FindLastCharCS(cChar, TRUE)

		#< @FunctiionAlternativeForms

		def FindLastCharZ(cChar)
			return This.FindLastChar(cChar)

		#--

		def FindLastOccurrenceOfChar(cChar)
			return This.FindLastChar(cChar)

		def FindLastOccurrenceOfCharZ(cChar)
			return This.FindLastChar(cChar)

		#>

	  #============================================#
	 #  GETTING THE LIST OF VOWELS IN THE STRING  #
	#============================================#

	#TODO
	# Add case sensitivity

	def Vowels()
		nLen = This.NumberOfChars()
		aoChars = This.ToListOfStzChars()
		
		acResult = []

		for i = 1 to nLen
			if aoChars[i].IsVowel()
				acResult + aoChars[i].Content()
			ok
		next

		return acResult

		def VowelsQ()
			return new stzList(This.Vowels())

		def VowelsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.Vowels())

			on :stzListOfChars
				return new stzList(This.Vowels())

			on :stzListOfStrings
				return new stzListOfStrings(This.Vowels())

			other
				StzRaise("Unsupported return type!")
			off

		#-- @MisspelledForm

		def Vowyels()
			return This.Vowels()

		def VowyelsQ()
			return This.VowelsQ()

		def VowyelsQR(pcReturnType)
			return This.VowelsQ(pcReturnType)

		#-- @BooleanForm

		def VowelsB()
			if This.VowelsQ().IsEqualTo(LastValue())
				return TRUE
			else
				return FALSE
			ok

		def VowelsBQ()
			if This.VowelsB()
				return This
			else
				return AFalseObject()
			ok

	def NumberOfVowels()
		nResult = len( This.Vowels() )
		return nResult

		#-- @Misspelled

		def NumberOfVowyels()
			return This.NumberOfVowels()

	def Vowel() # a random vowel from the string
		cResult = ARandomItemIn( This.Vowels() )
		return cResult

		def VowelQ()
			return new stzString(This.Vowel())

		def VowelQR(pcReturnType)
			switch pcReturnType
			on :stzString
				return new stzString(This.Vowel())

			on :stzChar
				return new stzChar(This.Vowel())

			other
				StzRaise("Unsuppprted return type!")
			off

		#-- @Misspelled

		def Vowyel()
			return This.Vowel()

			def VowyelQ()
				return This.VowelQ()

			def VowyelQR(pcReturnType)
				return This.VowelQR(pcReturnType)

	def VowelN()
		return This.NumberOfVowels()

		def VowelNQ()
			return new stzNumber(This.vowelN())

		#-- @Misspelled

		def VowyelN()
			return This.VowelN()

			def VowyelNQ()
				return This.VowelNQ()

	def VowelNB()
		if This.NumberOfVowels() = LastValue()
			return TRUE
		else
			return FALSE
		ok

		def VowelNBQ()
			if This.NumberOfVowels() = LastValue()
				return This
			else
				return AFalseObject()
			ok

		#-- @Misspelled

		def VowyelNB()
			return This.VowelNB()

			def VowyelNBQ()
				return This.VowelNBQ()



	  ///////////////////////////////////
	 //  ALTERNATIVES OF SubStrings() //
	///////////////////////////////////

	def AllSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def AllPossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllPossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllPossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def PossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def PossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def PossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	#-- WITHOUT CASESENSITIVE

	def AllSubStrings()
		return This.SubStrings()

		def AllSubStringsQ()
			return This.SubStringsQ()

		def AllSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def AllPossibleSubStrings()
		return This.SubStrings()

		def AllPossibleSubStringsQ()
			return This.SubStringsQ()

		def AllPossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def PossibleSubStrings()
		return This.SubStrings()

		def PossibleSubStringsQ()
			return This.SubStringsQ()

		def PossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	  #----------------------------#
	 #  ALTERNATIVES OF Append()  #
	#----------------------------#

	def Add(pcOtherStr)
		This.Append(pcOtherStr)

		def AddQ(pcOtherStr)
			This.Add(pcOtherStr)
			return This

	def AddToEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddToEndQ(pcOtherStr)
			This.AddToEnd(pcOtherStr)
			return This

	def AddEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddEndQ(pcOtherStr)
			This.AddEnd(pcOtherStr)
			return This

	#--

	def AppendEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendEndQ(pcOtherStr)
			This.AppendEnd(pcOtherStr)
			return This

	def AppendFromEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendFromEndQ(pcOtherStr)
			This.AppendFromEnd(pcOtherStr)
			return This

	def AppendAtEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendAtEndQ(pcOtherStr)
			This.AppendAtEnd(pcOtherStr)
			return This

	  #-------------------------------#
	 #   ALTERNATIVES OF Appended()  #
	#-------------------------------#

	def Added(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AddedToEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedFromEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedAtEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Prepend()  #
	#----------------------------#

	def AddStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddStartQ(pcOtherStr)
			This.AddStart(pcOtherStr)
			return This

	def AddToStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddToStartQ(pcOtherStr)
			This.AddToStart(pcOtherStr)
			return This

	def AddAtStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddAtStartQ(pcOtherStr)
			This.AddAtStart(pcOtherStr)
			return This

	def AddFromStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddFromStartQ(pcOtherStr)
			This.AddFromStart(pcOtherStr)
			return This

	  #--------------------------------#
	 #   ALTERNATIVES OF Prepended()  #
	#--------------------------------#

	def AddedToStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedFromStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedAtStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	  #----------------------------------------#
	 #  ALTERNATIVES OF FindManyAsSections()  #
	#----------------------------------------#

	def FindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringsAsSections(pacSubStr)
		return This.FindManyAsSections(pacSubStr)

	  #---------------------------------------#
	 #  ALTERNATIVES OF FindAnySplittedBy()  #
	#---------------------------------------#

	def FindAnySeparatedByCS(pcSeparator, pCaseSensitive)
		return This.FindAnySplittedByCS(pcSeparator, pCaseSensitive)

		#< @FunctionFluentForms

		def FindAnySeparatedByCSQ(pcSeparator, pCaseSensitive)
			return This.FindAnySplittedByCSQR(pcSeparator, pCaseSensitive, :stzList)

		def FindAnySeparatedByCSQR(pcSeparator, pCaseSensitive, pcReturnType)
			return This.FindanySplittedByCSQR(pcSeparator, TRUE, pcReturnType)				
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySeparatedBy(pcSeparator)
		return This.FindAnySplittedBy(pcSeparator)			

		#< @FunctionFluentForms

		def FindAnySeparatedByQ(pcSeparator)
			return This.FindAnySeparatedByQR(pcSeparator, :stzList)

		def FindAnySeparatedByQR(pcSeparator, pcReturnType)
			return This.FindAnySplittedByCSQR(pcSeparator, TRUE, pcReturnType)				

		#>

	  #------------------------------#
	 #  ALTERNATIVES OF FindNext()  #
	#------------------------------#
#nasrallah
	def FindNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	def NextFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)

	def FirstNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNextSCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfFirstNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextFirstOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FirstNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	  #----------------------------------#
	 #  ALTERNATIVES OF FindPrevious()  #
	#----------------------------------#

	def FindPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FirstPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousFirstOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FirstPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	  #-----------------------------#
	 #  ALTERNATIVES OF FindNth()  #
	#-----------------------------#

	def FindNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def PositionOfNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrencePositionCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def SubStringPositionByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def FindSubStringByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def PositionOfNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrencePosition(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def SubStringPositionByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def FindSubStringByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def Nth(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrence(n, pcSubStr)
		return This.FindNthC(n, pcSubstr)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindNthNext()  #
	#---------------------------------#

	def FindNthNextOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
		
	def PositionOfNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNext(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pcSubStr, nStart )
		return This.FindNthNext( n, pcSubStr, nStart )

	def FindNthNextOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def FindNthNextS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def PositionOfNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
		
	def NthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def NextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	  #------------------------------------------#
	 #  ALTERNATIVES OF FindNthNextAsSection()  #
	#------------------------------------------#

	def FindNthNextOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthNextAsSection( n, pcSubStr, nStart )

	def FindNthNextOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNthNextAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def PositionOfNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def NthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def NextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindNthPrevious()  #
	#-------------------------------------#

	def FindNthPreviousOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence( n, pcSubStr, nStart )
		return This.FindNthPrevious( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindPreviousNthS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindNthPreviousS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PositionOfPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def NthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindNthPreviousAsSection()  #
	#----------------------------------------------#

	def FindNthPreviousOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthPreviousAsSection( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindPreviousNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindNthPreviousAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PositionOfPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def NthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindAllNext()  #
	#---------------------------------#

	def FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def NextPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindNextOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllNextS(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def FindNextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def NextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def FindNextOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindAllPrevious()  #
	#-------------------------------------#

	def FindAllPreviousSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def PreviousPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindPreviousOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllPreviousS(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def PreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def FindPreviousOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	  #------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceXT()  #
	#------------------------------------------#

	def NumberOfOccurrencesCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrenceOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrencesOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def CountCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def HowManyCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrenceOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrencesOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def CountXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def HowManyXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	  #-----------------------------#
	 #  ALTERNATIVES OF Replace()  #
	#-----------------------------#

	def ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllOccurrencesCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAllOccurrencesOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This		

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceAll(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllQ(pcSubStr, pcNewSubStr)
			This.ReplaceAll(pcSubStr, pcNewSubStr)
			return This

	def ReplaceSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceSubstring(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrencesOfSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesOfSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr)
			return This		

	  #----------------------------#
	 #  ALTERNATIVES OF Remove()  #
	#----------------------------#

	def RemoveAllCS(pSubStr, pCaseSensitive)
		This.RemoveCS(pSubStr, pCaseSensitive)

		def RemoveAllCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllCS(pSubStr, pCaseSensitive)
			return This

	def RemoveSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveSubstringCS(pSubStr, pCaseSensitive)
			return This

	def RemoveAllOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveAllOccurrencesOfSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllOccurrencesOfSubstringCS(pSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAll(pSubStr)
		This.Remove(pSubStr)

		def RemoveAllQ(pSubStr)
			This.RemoveAll(pSubStr)
			return This

	def RemoveSubstring(pcSubStr, pCaseSensitive)
		This.Remove(pcSubStr)

		def RemoveSubstringQ(pSubStr)
			This.RemoveSubstring(pSubStr)
			return This

	def RemoveAllOccurrencesOfSubstring(pcSubStr)
		This.Remove(pcSubStr)

		def RemoveAllOccurrencesOfSubstringQ(pSubStr)
			This.RemoveAllOccurrencesOfSubstring(pSubStr)
			return This
