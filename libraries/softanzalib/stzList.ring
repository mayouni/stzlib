#---------------------------------------------------------------------------#
# 		   SOFTANZA LIBRARY (V1.0) - STZLIST			    #
#	An accelerative library for Ring applications, and more!	    #
#---------------------------------------------------------------------------#
#									    #
# 	Description	: The core class for managing lists in Softanza     #
#	Version		: V1.0 (2020-2024)				    #
#	Author		: Mansour Ayouni (kalidianow@gmail.com)		    #
#									    #
#---------------------------------------------------------------------------#

  /////////////////////
 ///   FUNCTIONS   ///
/////////////////////

func StzListQ(paList)
	return new stzList(paList)

#===

func Types(paList)
	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	acResult = []
	nLen = len(paList)

	for i = 1 to nLen
		acResult + type(paList[i])
	next

	return acResult

	func @Types(paList)
		return Types(paList)

func SortListsBySize(paLists)
	if CheckParam()
		if NOT ( isList(paLists) and @IsListOfLists(paLists) )
			StzRaise("Incorrect param type! paLists must be a list of lists.")
		ok
	ok

	nLen = len(paLists)

	for i = 1 to nLen
		ring_insert(paLists[i], len(paLists[i]), 1)
	next

	SortListsOn(paLists, 1)

	for i = 1 to nLen
		ring_remove(paLists[i], 1)
	next

	return paLists

	func @SortListsBySize(paLists)
		return nSortListsBySize(paLists)

func SortLists(paLists)
	return SortListsOn(palists, 1)

	func @SortLists(paList)
		return SortLists(paList)

func ListsStringifyXT(paListOfLists)
	if CheckParams()
		if NOT ( isList(paListOfLists) and @IsListOfLists(paListOfLists) )
			StzRaise("Incorrect param type! paListOfLists must be a list of Lists.")
		ok
	ok

	if len(paListOfLists) = 0
		return [ "" ]
	ok

	aCols = StzListOfListsQ(paListOfLists).Cols()
	nLen = len(aCols)

	acColsStringified = []
	for i = 1 to nLen
		acColsStringified + ListStringifyXT(aCols[i])
	next

	oLoL = StzListOfListsQ([])

	for i = 1 to nLen
		oLoL.AddCol(acColsStringified[i])
	next

	aResult = oLoL.Content()

	return aResult


	func @ListsStringifyXT(paListOfLists)
		return ListsStringifyXT(paListOfLists)

func ListStringifyXT(paList)
	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	# If list contains numbers then we adjust
	# them before we stringify them

	# We start by getting the max left and right
	# number of digits (integer and decimal parts)

	nLen = len(paList)

	nMaxSize = 0
	nMaxLeft = 0
	nMaxRight = 0

	anNumbersPos = []

	for i = 1 to nLen
		if isNumber(paList[i])

			anNumbersPos + i

			cNumber = ""+ paList[i]

			nSize = len(cNumber)
			if nSize > nMaxSize
				nMaxSize = nSize
			ok

			nDotPos = substr( cNumber, "." )

			if nDotPos = 0
				nLenLeft = nSize
				nLenRight = 0

			else
				nLenLeft = nDotPos - 1
				nLenRight = nSize - nDotPos

			ok

			if nLenLeft > nMaxLeft
				nMaxLeft = nLenLeft
			ok

			if nLenRight > nMaxRight
				nMaxRight = nLenRight
			ok
		ok
	next

	nHowManyNumbers = len(anNumbersPos)

	# The numbers without decimal part are adjusted
	# first, by adding a dot and some 0s to them,
	# and then the numbers with dots are adjusted

	for i = 1 to nHowManyNumbers
		nPos = anNumbersPos[i]

		# Early check

		if paList[nPos] = 0
			paList[nPos] = "0."
			loop
		ok

		# In case where the number is not a zero

		cNumber = ""+ paList[nPos]
		nLenNumber = len(cNumber)
		nPosDot = substr(cNumber, ".")
			
		if nPosDot = 0
				
			nAddLeft = nMaxLeft - nLenNumber
			nAddRight = nMaxRight

			cExtLeft = ""
			cExtRight = ""

			for j = 1 to nAddLeft
				cExtLeft += "0"
			next

			for j = 1 to nAddRight
				cExtRight += "0"
			next

			cNumber = cExtLeft + cNumber + "." + cExtRight

		else
			nAddLeft = nMaxLeft - (nPosDot - 1)
			nAddRight = nMaxRight - (nLenNumber - nPosDot)

			cExtLeft = ""
			cExtRight = ""

			for j = 1 to nAddLeft
				cExtLeft += "0"
			next

			for j = 1 to nAddRight
				cExtRight += "0"
			next

			cNumber = cExtLeft + cNumber + cExtRight

		ok

		paList[nPos] = cNumber

	next

	# Now we stringify the items of the column that
	# are not numbers (usning @@() ~> ComputableForm())

	for i = 1 to nLen
		if NOT isNumber(paList[i])
			paList[i] = @@(paList[i])
			loop
		ok

	next

	return paList

	func @ListStringifyXT(paList)
		return ListStringifyXT(paList)

func SortListsOn(paLists, n)

	if CheckParam()
		if isNumber(paLists) and isList(n)
			temp = paLists
			paLists = n
			n = temp
		ok

		if NOT ( isList(paLists) and @IsListOfLists(paLists) )
			StzRaise("Incorrect param type! paList must be a list of lists.")
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok
	ok

	nLen = len(paLists)
	if nLen = 0
		return []

	but nLen < 2
		return paLists
	ok

	# Early check1 : If One of the lists is empty

	for i = 1 to nLen
		if len(paLists[i]) = 0
			return @SortList(paLists)
		ok
	next

	# Early check2 : Using Ring sort() in priority

	if IsRingSortableOn(paLists, n)
		return ring_sort2(paLists, n)
	ok

	# Special case: when the nth column contains empty lists
	# ~> we replace them by [0] so they are sorted first
	# ~> we keep their number so they are restored at the end

	nLenEmptyLists = 0
	for i = 1 to nLen
		nLenList = len(paLists[i])
		if n <= nLenList
			if isList(paLists[i][n]) and len(paLists[i][n]) = 0
				paLists[i][n] + 0
				nLenEmptyLists++
			ok
		ok
	next

	# Special case: the nth column contains the same items
	# ~> sort the column after, or if n is the last column,
	# sort the column just before

	oLoL = new stzListOfLists(paLists)

	if oLol.ColQ(n).IsMadeOfSameItem()

		nCols = oLol.NumberOfCols()

		# Walking the columns backward and find the first
		# one containing distinc items ~> sort on it

		for i = nCols - 1 to 1 step -1
			if NOT oLoL.ColQ(i).IsMadeOfSameItem()
				return @SortListsOn(paLists, i)
			ok
		next

		# ~> All the columns for n back to the first
		# one are made of the same items!

		# Walking the columns forward and find the first
		# one containing distinc items ~> sort on it

		if n < nCols
			for i =  n + 1 to nCols
				if NOT oLoL.ColQ(i).IsMadeOfSameItem()
					return @SortListsOn(paLists, i)
				ok
			next
		ok

		# ~> All the columns are made of same items, there
		# is no need to make any sort!

		return

	ok

	# Adjusting the lists up to the nth column
	# (we do this to make it possible using Ring sort() function)

	for i = 1 to nLen
		nLenList = len(paLists)
		if nLenList < n
			nDif = n - nLenList
			for j = 1 to nDiff
				paLists[i] + NULL
			next
		ok

	next

	if n = 1
		# We stringify only the first column and then
		# sort the list on it using ring_sort2(list, n)

		aFirstCol = []
		for i = 1 to nLen
			aFirstCol + paLists[i][1]
		next

		aFirstColXT = ListStringifyXT(aFirstCol)

		# Adding this stringified colum as the very first
		# column of the list, sorting it using ring_sort2()
		# and then removing this stringified column

		for i = 1 to nLen
			ring_insert(paLists[i], 1, aFirstColXT[i])
		next

		# Now we sort the list of lists using ring_sort2()

		paLists = ring_sort2(paLists, 1)

		# finally we compose the result by excluding
		# the very first coumumn 

		for i = 1 to nLen
			ring_remove(paLists[i], 1)
		next

		# Restoring the [] lists from their [0] temporal form

		for i = 1 to nLen
			nLenList = len(paLists[i])
			if nLenList > n # Note n = 1 but we leave it for expressiveness
				if isList(paLists[i][n]) and len(paLists[i][n]) = 1 and paLists[i][n][1] = 0
					if nLenEmptyLists > 0
						ring_remove(paLists[i][n], 1)
						nLenEmptyLists--
					ok
				ok
			ok
		next


		# Returning the result

		return paLists
	ok

	# In this case, the nth column is not the first column.
	# We need to sort not only the nth column, but:

	# 	1. sort the first column
	# 	2. sort the items of the first column that have same value

	# We fellow the same logic of the previous case, but for
	# two columns and not only one column

		# We stringify the nth and first columns

		aNthAndFirstCols = []
		for i = 1 to nLen
			aNthAndFirstCols + [ paLists[i][n], paLists[i][1] ]
		next

		aNthAndFirstColsXT = ListsStringifyXT(aNthAndFirstCols)

		# Adding the stringifief nth and first columns (concatenated)
		# at the begining of the list (as the first column)

		for i = 1 to nLen
			ring_insert(paLists[i], 1, aNthAndFirstColsXT[i][1] + aNthAndFirstColsXT[i][2])
		next

		# Now we sort the list of lists using ring_sort2(), first on
		# the nth column (which is the first column now in the list)

		paLists = ring_sort2(paLists, 1)

		# finally we compose the result by excluding
		# the very first coumumn 

		for i = 1 to nLen
			ring_remove(paLists[i], 1)
		next

		# Restoring the [] lists from their [0] temporal form

		for i = 1 to nLen
			nLenList = len(paLists[i])
			if n <= nLenList
				if isList(paLists[i][n]) and len(paLists[i][n]) = 1 and paLists[i][n][1] = 0
					if nLenEmptyLists > 0
						ring_remove(paLists[i][n], 1)
						nLenEmptyLists--
					ok
				ok
			ok
		next

		# Returning the result

		return paLists


	#< @FunctionAlternativeForms

	func @SortListsOn(paLists, n)
		return SortListsOn(paLists, n)

	func SortOn(paLists, n)
		return SortListsOn(paLists, n)

	func @SortOn(paLists, n)
		return SortListsOn(paLists, n)

	#>

func @SortList(paList)

	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	# The idea is to separate the items by type
	# and then sort them

	nLen = len(paList)

	if nLen = 0
		return []
	ok
	
	anNumbers = []

	acStrings = []
	nLenNull = 0
	# Null strings are counted and will be put first in the sort

	aaLists   = []
	nLenEmptyLists = 0
	# Empty lists are counted and will be added at the top
	# of sorted lists (there is no need to sort them)

	aoObjects = []

	for i = 1 to nLen
		if isNumber(paList[i])
			anNumbers + paList[i]

		but isString(paList[i])
			if paList[i] = ""
				nLenNull++
			else
				acStrings + paList[i]
			ok

		but isList(paList[i])
			if len(paList[i]) = 0
				nLenEmptyLists++
			else
				aaLists + paList[i]
			ok

		else // isObject()
			aoObjects + paList[i]
		ok
	next

	aResult = []

	nLenNumbers = len(anNumbers)
	nLenStrings = len(acStrings)
	nLenLists = len(aaLists)
	nLenObjects = len(aoObjects)

	# Adding the null values on the top of the result

	for i = 1 to nLenNull
		aResult + ""
	next

	# Sorting the numbers and adding them to the result

	anNumbersSorted = ring_sort(anNumbers)
	for i = 1 to nLenNumbers
		aResult + anNumbersSorted[i]
	next

	# Sorting the (non-null) strings and adding them to the result

	acStringsSorted = ring_sort(acStrings)
	for i = 1 to nLenStrings
		aResult + acStringsSorted[i]
	next

	# Adding the empty lists to the result

	for i = 1 to nLenEmptyLists
		aResult + []
	next

	# Sorting the (other non-empty) lists and adding them to the result

	aaListsSorted = @SortListsOn(aaLists, 1)
	for i = 1 to nLenLists
		aResult + aaListsSorted[i]
	next

	# Sorting the objects and adding them to the result

	for i = 1 to nLenObjects
		aResult + aoObjects[i]
	next

	return aResult


	func SortList(paList)
		return @SortList(paList)

func @Sort(p)
	if NOT (isString(p) or isList(p))
		StzRaise("Incorrect param type! p must be a string or list.")
	ok

	if isString(p)
		return ring_sort(p)

	else // isList()

		if @IsListOfNumbers(p) or @IsListOfStrings(p)
			return ring_sort(p)
		ok

		if @IsListOfLists(p)
			
			# Case where one list is empty

			nLen = len(p)
			for i = 1 to nLen
				if len(p[i]) = 0
					return @SortList(p)
				ok

			next

			# Other cases

			return @SortListsOn(p, 1)

		else
			return @SortList(p)
		ok
	ok

func SortListBy(paList, pcExpr)
	return StzListQ(paList).SortedBy(pcExpr)

	func @SortListBy(paList, pcExpr)
		return SortListBy(paList, pcExpr)

func SortBy(paList, pcExpr)
	if CheckParams()
		if NOT isList(paList)
			Stzraise("Incorrect param type! paList must be a list.")
		ok
	ok

	return StzListQ(paList).SortedBy(pcExpr)


	func @SortBy(paList, pcExpr)
		return SortBy(paList, pcExpr)

#==========

func IsListOfNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfNumbers(paList)
		return IsListOfNumbers(paList)

	func IsAListOfNumbers(paList)
		return IsListOfNumbers(paList)

	func @IsAListOfNumbers(paList)
		return IsListOfNumbers(paList)

	#>

func IsListOfListsOfNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	func IsAListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	func @IsAListOfListsOfNumbers(paList)
		return IsListOfListsOfNumbers(paList)

	#>

func IsListOfDecimalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	func IsAListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	func @IsAListOfDecimalNumbers(paList)
		return IsListOfDecimalNumbers(paList)

	#>

func IsListOfListsOfDecimalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	func IsAListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	func @IsAListOfListsOfDecimalNumbers(paList)
		return IsListOfListsOfDecimalNumbers(paList)

	#>

func IsListOfBinaryNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	func IsAListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	func @IsAListOfBinaryNumbers(paList)
		return IsListOfBinaryNumbers(paList)

	#>

func IsListOfListsOfBinaryNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	func IsAListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	func @IsAListOfListsOfBinaryNumbers(paList)
		return IsListOfListsOfBinaryNumbers(paList)

	#>

func IsListOfOctalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	func IsAListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	func @IsAListOfOctalNumbers(paList)
		return IsListOfOctalNumbers(paList)

	#>

func IsListOfListsOfOctalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	func IsAListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	func @IsAListOfListsOfOctalNumbers(paList)
		return IsListOfListsOfOctalNumbers(paList)

	#>

func IsListOfHexNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	func IsAListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	func @IsAListOfHexNumbers(paList)
		return IsListOfHexNumbers(paList)

	#>

func IsListOfListsOfHexNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	func IsAListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	func @IsAListOfListsOfHexNumbers(paList)
		return IsListOfListsOfHexNumbers(paList)

	#>

func IsListOfStrings(paList)
	#TODO
	# Use this implementation of all IsListOf...() functions
	# ~> More performant then usign stzObjects
	
	if NOT isList(paList)
		return FALSE
	ok

	bResult = TRUE
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isString(paList[i])
			bResult = FALSE
			exit
		ok
	next

	return bResult

	#< @FunctionAlternativeForms

	func @IsListOfStrings(paList)
		return IsListOfStrings(paList)

	func IsAListOfStrings(paList)
		return IsListOfStrings(paList)

	func @IsAListOfStrings(paList)
		return IsListOfStrings(paList)

	#>

func IsListOfListsOfStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	func IsAListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	func @IsAListOfListsOfStrings(paList)
		return IsListOfListsOfStrings(paList)

	#>

func IsListOfLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	bResult = TRUE
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isList(paList[i])
			bResult = FALSE
			exit
		ok
	next

	return bResult

	#< @FunctionAlternativeForms

	func @IsListOfLists(paList)
		return IsListOfLists(paList)

	func IsAListOfLists(paList)
		return IsListOfLists(paList)

	func @IsAListOfLists(paList)
		return IsListOfLists(paList)

	#>

func IsListOfHybridLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfHybridLists()

	#< @FunctionAlternativeForms

	func @IsListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	func IsAListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	func @IsAListOfHybridLists(paList)
		return IsListOfHybridLists(paList)

	#>

func IsListOfListsOfHybridLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfHybridLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	func IsAListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	func @IsAListOfListsOfHybridLists(paList)
		return IsListOfListsOfHybridLists(paList)

	#>

func IsListOfListsOfLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	func IsAListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	func @IsAListOfListsOfLists(paList)
		return IsListOfListsOfLists(paList)

	#>

func IsListOfObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	bResult = TRUE
	nLen = len(paList)

	for i = 1 to nLen
		if NOT isObject(paList[i])
			bResult = FALSE
			exit
		ok
	next

	return bResult

	return StzListQ(paList).IsListOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfObjects(paList)
		return IsListOfObjects(paList)

	func IsAListOfObjects(paList)
		return IsListOfObjects(paList)

	func @IsAListOfObjects(paList)
		return IsListOfObjects(paList)

	#>

func IsListOfListsOfObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	func IsAListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	func @IsAListOfListsOfObjects(paList)
		return IsListOfListsOfObjects(paList)

	#>

func IsListOfChars(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfChars(paList)
		return IsListOfChars(paList)

	func IsAListOfChars(paList)
		return IsListOfChars(paList)

	func @IsAListOfChars(paList)
		return IsListOfChars(paList)

	#>

func IsListOfListsOfChars(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	func IsAListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	func @IsAListOfListsOfChars(paList)
		return IsListOfListsOfChars(paList)

	#>

func IsListOfPairs(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairs()

	#< @FunctionAlternativeForms

	func @IsListOfPairs(paList)
		return IsListOfPairs(paList)

	func IsAListOfPairs(paList)
		return IsListOfPairs(paList)

	func @IsAListOfPairs(paList)
		return IsListOfPairs(paList)

	#>

func IsListOfListsOfPairs(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfPairs()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	func IsAListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	func @IsAListOfListsOfPairs(paList)
		return IsListOfListsOfPairs(paList)

	#>

func IsListOfSets(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfSets()

	#< @FunctionAlternativeForms

	func @IsListOfSets(paList)
		return IsListOfSets(paList)

	func IsAListOfSets(paList)
		return IsListOfSets(paList)

	func @IsAListOfSets(paList)
		return IsListOfSets(paList)

	#>

func IsListOfListsOfSets(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfSets()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	func IsAListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	func @IsAListOfListsOfSets(paList)
		return IsListOfListsOfSets(paList)

	#>

func IsListOfHashLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfHashLists(paList)
		return IsListOfHashLists(paList)

	func IsAListOfHashLists(paList)
		return IsListOfHashLists(paList)

	func @IsAListOfHashLists(paList)
		return IsListOfHashLists(paList)

	#>

func IsListOfListsOfHashLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	func IsAListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	func @IsAListOfListsOfHashLists(paList)
		return IsListOfListsOfHashLists(paList)

	#>

func IsListOfGrids(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfGrids()

	#< @FunctionAlternativeForms

	func @IsListOfGrids(paList)
		return IsListOfGrids(paList)

	func IsAListOfGrids(paList)
		return IsListOfGrids(paList)

	func @IsAListOfGrids(paList)
		return IsListOfGrids(paList)

	#>

func IsListOfListsOfGrids(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfGrids()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	func IsAListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	func @IsAListOfListsOfGrids(paList)
		return IsListOfListsOfGrids(paList)

	#>

func IsListOfTables(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfTables()

	#< @FunctionAlternativeForms

	func @IsListOfTables(paList)
		return IsListOfTables(paList)

	func IsAListOfTables(paList)
		return IsListOfTables(paList)

	func @IsAListOfTables(paList)
		return IsListOfTables(paList)

	#>

func IsListOfListsOfTables(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfTables()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	func IsAListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	func @IsAListOfListsOfTables(paList)
		return IsListOfListsOfTables(paList)

	#>

func IsListOfTrees(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfTrees()

	#< @FunctionAlternativeForms

	func @IsListOfTrees(paList)
		return IsListOfTrees(paList)

	func IsAListOfTrees(paList)
		return IsListOfTrees(paList)

	func @IsAListOfTrees(paList)
		return IsListOfTrees(paList)

	#>

func IsListOfListsOfTrees(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfTrees()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	func IsAListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	func @IsAListOfListsOfTrees(paList)
		return IsListOfListsOfTrees(paList)

	#>

func IsListOfStzNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	func IsAListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	func @IsAListOfStzNumbers(paList)
		return IsListOfStzNumbers(paList)

	#>

func IsListOfListsOfStzNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	func IsAListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	func @IsAListOfListsOfStzNumbers(paList)
		return IsListOfListsOfStzNumbers(paList)

	#>

func IsListOfStzDecimalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	func IsAListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	func @IsAListOfStzDecimalNumbers(paList)
		return IsListOfStzDecimalNumbers(paList)

	#>

func IsListOfListsOfStzDecimalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzDecimalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	func IsAListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	func @IsAListOfListsOfStzDecimalNumbers(paList)
		return IsListOfListsOfStzDecimalNumbers(paList)

	#>

func IsListOfStzBinaryNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	func IsAListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	func @IsAListOfStzBinaryNumbers(paList)
		return IsListOfStzBinaryNumbers(paList)

	#>

func IsListOfListsOfStzBinaryNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzBinaryNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	func IsAListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	func @IsAListOfListsOfStzBinaryNumbers(paList)
		return IsListOfListsOfStzBinaryNumbers(paList)

	#>

func IsListOfStzOctalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	func IsAListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	func @IsAListOfStzOctalNumbers(paList)
		return IsListOfStzOctalNumbers(paList)

	#>

func IsListOfListsOfStzOctalNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzOctalNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	func IsAListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	func @IsAListOfListsOfStzOctalNumbers(paList)
		return IsListOfListsOfStzOctalNumbers(paList)

	#>

func IsListOfStzHexNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	func IsAListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	func @IsAListOfStzHexNumbers(paList)
		return IsListOfStzHexNumbers(paList)

	#>

func IsListOfListsOfStzHexNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzHexNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	func IsAListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	func @IsAListOfListsOfStzHexNumbers(paList)
		return IsListOfListsOfStzHexNumbers(paList)

	#>

func IsListOfStzStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	func IsAListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	func @IsAListOfStzStrings(paList)
		return IsListOfStzStrings(paList)

	#>

func IsListOfListsOfStzStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	func IsAListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	func @IsAListOfListsOfStzStrings(paList)
		return IsListOfListsOfStzStrings(paList)

	#>

func IsListOfStzLists(paList)
	if NOT isList(paList)
		return FALSE
	ok
	return StzListQ(paList).IsListOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfStzLists(paList)
		return IsListOfStzLists(paList)

	func IsAListOfStzLists(paList)
		return IsListOfStzLists(paList)

	func @IsAListOfStzLists(paList)
		return IsListOfStzLists(paList)

	#>

func IsListOfListsOfStzLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	func IsAListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	func @IsAListOfListsOfStzLists(paList)
		return IsListOfListsOfStzLists(paList)

	#>

func IsListOfStzObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	func IsAListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	func @IsAListOfStzObjects(paList)
		return IsListOfStzObjects(paList)

	#>

func IsListOfListsOfStzObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	func IsAListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	func @IsAListOfListsOfStzObjects(paList)
		return IsListOfListsOfStzObjects(paList)

	#>

func IsListOfStzChars(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzChars()

	#< @FunctionAlternativeForms

	func @IsListOfStzChars(paList)
		return IsListOfStzChars(paList)

	func IsAListOfStzChars(paList)
		return IsListOfStzChars(paList)

	func @IsAListOfStzChars(paList)
		return IsListOfStzChars(paList)

	#>

func IsListOfListsOfStzChars(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzChars()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	func IsAListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	func @IsAListOfListsOfStzChars(paList)
		return IsListOfListsOfStzChars(paList)

	#>

func IsListOfStzPairs(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzPairs()

	#< @FunctionAlternativeForms

	func @IsListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	func IsAListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	func @IsAListOfStzPairs(paList)
		return IsListOfStzPairs(paList)

	#>

func IsListOfListsOfStzPairs(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzPairs()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	func IsAListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	func @IsAListOfListsOfStzPairs(paList)
		return IsListOfListsOfStzPairs(paList)

	#>

func IsListOfStzSets(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzSets()

	#< @FunctionAlternativeForms

	func @IsListOfStzSets(paList)
		return IsListOfStzSets(paList)

	func IsAListOfStzSets(paList)
		return IsListOfStzSets(paList)

	func @IsAListOfStzSets(paList)
		return IsListOfStzSets(paList)

	#>

func IsListOfListsOfStzSets(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzSets()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	func IsAListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	func @IsAListOfListsOfStzSets(paList)
		return IsListOfListsOfStzSets(paList)

	#>

func IsListOfStzHashLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	func IsAListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	func @IsAListOfStzHashLists(paList)
		return IsListOfStzHashLists(paList)

	#>

func IsListOfListsOfStzHashLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzHashLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	func IsAListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	func @IsAListOfListsOfStzHashLists(paList)
		return IsListOfListsOfStzHashLists(paList)

	#>

func IsListOfStzGrids(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzGrids()

	#< @FunctionAlternativeForms

	func @IsListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	func IsAListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	func @IsAListOfStzGrids(paList)
		return IsListOfStzGrids(paList)

	#>

func IsListOfListsOfStzGrids(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzGrids()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	func IsAListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	func @IsAListOfListsOfStzGrids(paList)
		return IsListOfListsOfStzGrids(paList)

	#>

func IsListOfStzTables(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzTables()

	#< @FunctionAlternativeForms

	func @IsListOfStzTables(paList)
		return IsListOfStzTables(paList)

	func IsAListOfStzTables(paList)
		return IsListOfStzTables(paList)

	func @IsAListOfStzTables(paList)
		return IsListOfStzTables(paList)

	#>

func IsListOfListsOfStzTables(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzTables()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	func IsAListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	func @IsAListOfListsOfStzTables(paList)
		return IsListOfListsOfStzTables(paList)

	#>

func IsListOfStzTrees(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzTrees()

	#< @FunctionAlternativeForms

	func @IsListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	func IsAListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	func @IsAListOfStzTrees(paList)
		return IsListOfStzTrees(paList)

	#>

func IsListOfListsOfStzTrees(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfStzTrees()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	func IsAListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	func @IsAListOfListsOfStzTrees(paList)
		return IsListOfListsOfStzTrees(paList)

	#>

#===

func IsUniformList(paList) # Is made of the same item
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsUniform()

func IsDeepList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsDeep()

	#< @FunctionAlternativeForms

	func @IsDeepList(paList)
		return IsDeepList(paList)

	func IsADeepList(paList)
		return IsDeepList(paList)

	func @IsADeepList(paList)
		return IsDeepList(paList)

	#>

func IsHybridList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsHybridList()

	#< @FunctionAlternativeForms

	func @IsHybridList(paList)
		return IsHybridList(paList)

	func IsAHybridList(paList)
		return IsHybridList(paList)

	func @IsAHybridList(paList)
		return IsHybridList(paList)

	#>

func IsPureList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsPureList()

	#< @FunctionAlternativeForms

	func @IsPureList(paList)
		return IsPureList(paList)

	func IsAPureList(paList)
		return IsPureList(paList)

	func @IsAPureList(paList)
		return IsPureList(paList)

	#>

func IsOddList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsOdd()

	#< @FunctionAlternativeForms

	func @IsOddList(paList)
		return IsOddList(paList)

	func IsAOddList(paList)
		return IsOddList(paList)

	func @IsAOddList(paList)
		return IsOddList(paList)

	#--

	func IsFardiList(paList)
		return IsOddList(paList)

	func IsAFardiList(paList)
		return IsOddList(paList)

	func @IsFardiList(paList)
		return IsOddList(paList)

	func @IsAFardiList(paList)
		return IsOddList(paList)

	#>

func IsEvenList()
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsEven()

	#< @FunctionAlternativeForms

	func @IsEvenList(paList)
		return IsEvenList(paList)

	func IsAEvenList(paList)
		return IsEvenList(paList)

	func @IsAEvenList(paList)
		return IsEvenList(paList)

	#--

	func IsZawjiList(paList)
		return IsOddList(paList)

	func IsAZawjiList(paList)
		return IsOddList(paList)

	func @IsZawjiList(paList)
		return IsOddList(paList)

	func @IsAZawjiList(paList)
		return IsOddList(paList)

	#>

func IsListOfBits(paLists)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfBits()

	#< @FunctionAlternativeForms

	func @IsListOfBits(paList)
		return IsListOfBits(paList)

	func IsAListOfBits(paList)
		return IsListOfBits(paList)

	func @IsAListOfBits(paList)
		return IsListOfBits(paList)

	#>

func IsListOfZerosAndOnes(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfZerosAndOnes()

	#< @FunctionAlternativeForms

	func @IsListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	func IsAListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	func @IsAListOfZerosAndOnes(paList)
		return IsListOfZerosAndOnes(paList)

	#>


#===

func IsListOfLetters(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfLetters()

	#< @FunctionAlternativeForms

	func @IsListOfLetters(paList)
		return IsListOfLetters(paList)

	func IsAListOfLetters(paList)
		return IsListOfLetters(paList)

	func @IsAListOfLetters(paList)
		return IsListOfLetters(paList)

	#>

func IsListOfQBytesLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfQBytesLists()

	#< @FunctionAlternativeForms

	func @IsListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	func IsAListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	func @IsAListOfQBytesLists(paList)
		return IsListOfQBytesLists(paList)

	#>

func IsListOfStzListOfBytes(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStzListOfBytes()

	#< @FunctionAlternativeForms

	func @IsListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	func IsAListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	func @IsAListOfStzListOfBytes(paList)
		return IsListOfStzListOfBytes(paList)

	#>

func IsListOfNumbersInStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbersInStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	func IsAListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	func @IsAListOfNumbersInStrings(paList)
		return IsListOfNumbersInStrings(paList)

	#>

func IsListOfNumbersOrStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbersOrStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	func IsAListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	func @IsAListOfNumbersOrStrings(paList)
		return IsListOfNumbersOrStrings(paList)

	#>

func IsListOfNumbersAndStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbersAndStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	func IsAListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	func @IsAListOfNumbersAndStrings(paList)
		return IsListOfNumbersAndStrings(paList)

	#>

func IsListOfNumbersOrListOfStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbersOrListOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	func IsAListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	func @IsAListOfNumbersOrListOfStrings(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	#--

	func IsListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func @IsListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func IsAListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)
	
	func @IsAListOfStringsOrListOfNumbers(paList)
		return IsListOfNumbersOrListOfStrings(paList)

	#>

func IsListOfStringsAndPairsOfStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfStringsAndPairsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	func IsAListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	func @IsAListOfStringsAndPairsOfStrings(paList)
		return IsListOfStringsAndPairsOfStrings(paList)

	#>

func IsListOfNumbersAndPairsOfNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNumbersAndPairsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	func IsAListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	func @IsAListOfNumbersAndPairsOfNumbers(paList)
		return IsListOfNumbersAndPairsOfNumbers(paList)

	#>

func IsListOfListsAndPairsOfLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsAndPairsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	func IsAListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	func @IsAListOfListsAndPairsOfLists(paList)
		return IsListOfListsAndPairsOfLists(paList)

	#>

func IsListOfObjectsAndPairsOfObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfObjectsAndPairsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	func IsAListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	func @IsAListOfObjectsAndPairsOfObjects(paList)
		return IsListOfObjectsAndPairsOfObjects(paList)

	#>

func IsPairOfStrings(paPair)
	if isList(paPair) and len(paPair) = 2 and
	   isString(paPair[1]) and isString(paPair[2])

		return TRUE
	else
		return FALSE
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	func IsAPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	func @IsAPairOfStrings(paPair)
		return IsPairOfStrings(paPair)

	#>

func IsListOfPairsOfStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStrings()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	func IsAListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	func @IsAListOfPairsOfStrings(paList)
		return IsListOfPairsOfStrings(paList)

	#>

func IsPairOfNumbers(paPair)
	if isList(paPair) and len(paPair) = 2 and
	   isNumber(paPair[1]) and isNumber(paPair[2])

		return TRUE
	else

		return FALSE
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	func IsAPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	func @IsAPairOfNumbers(paPair)
		return IsPairOfNumbers(paPair)

	#>

func IsListOfPairsOfNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	func IsAListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsAListOfPairsOfNumbers(paList)
		return IsListOfPairsOfNumbers(paList)

	#--

	func IsListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func IsAListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	func @IsAListOfSections(paList)
		return IsListOfPairsOfNumbers(paList)

	#>

func IsPairOfSections(paPair)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzPairQ(paPair).IsPairOfSections()

	#< @FunctionAlternativeForms

	func @IsPairOfSections(paPair)
		return IsPairOfSections(paPair)

	func IsAPairOfSections(paPair)
		return IsPairOfSections(paPair)

	func @IsAPairOfSections(paPair)
		return IsPairOfSections(paPair)

	#>

func IsListOfPairsOfSections(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfSections()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	func IsAListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	func @IsAListOfPairsOfSections(paList)
		return IsListOfPairsOfSections(paList)

	#>

func IsPairOfLists(paPair)
	if isList(paList) and len(paList) = 2 and
	   isList(paList[1]) and isList(paList[2])

		return TRUE
	else

		return FALSE
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfLists(paPair)
		return IsPairOfLists(paPair)

	func IsAPairOfLists(paPair)
		return IsPairOfLists(paPair)

	func @IsAPairOfLists(paPair)
		return IsPairOfLists(paPair)

	#>

func IsListOfPairsOfLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfLists()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	func IsAListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	func @IsAListOfPairsOfLists(paList)
		return IsListOfPairsOfLists(paList)

	#>

func IsPairOfObjects(paPair)
	if isList(paList) and len(paList) = 2 and
	   isObject(paList[1]) and isObject(paList[2])

		return TRUE
	else

		return FALSE
	ok

	#< @FunctionAlternativeForms

	func @IsPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	func IsAPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	func @IsAPairOfObjects(paPair)
		return IsPairOfObjects(paPair)

	#>

func IsListOfPairsOfObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfObjects()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	func IsAListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	func @IsAListOfPairsOfObjects(paList)
		return IsListOfPairsOfObjects(paList)

	#>

func IsPairAndKeyIsString(paList)
	if isList(paList) and len(paList) = 2 and
	   isString(paList[1])

		return TRUE
	else

		return FALSE
	ok

	#< @FunctionAlternativeForms

	func @IsPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	func IsAPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	func @IsAPairAndKeyIsString(paList)
		return IsPairAndKeyIsString(paList)

	#>

func IsPairOfStzObjects(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	func IsAPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	func @IsAPairOfStzObjects(paList)
		return IsPairOfStzObjects(paList)

	#>

func IsListOfPairsOfStzObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStzObjects()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	func IsAListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	func @IsAListOfPairsOfStzObjects(paList)
		return IsListOfPairsOfStzObjects(paList)

	#>

func IsPairOfStzNumbers(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	func IsAPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	func @IsAPairOfStzNumbers(paList)
		return IsPairOfStzNumbers(paList)

	#>

func IsListOfPairsOfStzNumbers(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStzNumbers()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	func IsAListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	func @IsAListOfPairsOfStzNumbers(paList)
		return IsListOfPairsOfStzNumbers(paList)

	#>

func IsPairOfStzStrings(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	func IsAPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	func @IsAPairOfStzStrings(paList)
		return IsPairOfStzStrings(paList)

	#>

func IsListOfPairsOfStzStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStzStrings()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	func IsAListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	func @IsAListOfPairsOfStzStrings(paList)
		return IsListOfPairsOfStzStrings(paList)

	#>

func IsPairOfStzLists(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStzLists()

	#< @FunctionAlternativeForms

	func @IsPairOfStzLists(paList)
		return IsPairOfStzLists(paList)

	func IsAPairOfStzLists(paList)
		return IsPairOfStzLists(paPair)

	func @IsAPairOfStzLists(paPair)
		return IsPairOfStzLists(paList)

	#>

func IsListOfPairsOfStzLists(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStzLists()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	func IsAListOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	func @IsALitsOfPairsOfStzLists(paList)
		return IsListOfPairsOfStzLists(paList)

	#>

func IsPairOfNumberAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfNumberAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	func IsAPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	func @IsAPairOfNumberAndString(paList)
		return IsPairOfNumberAndString(paList)

	#>

func IsListOfPairsOfNumberAndString(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	func IsAListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	func @IsAListOfPairsOfNumberAndString(paList)
		return IsListOfPairsOfNumberAndString(paList)

	#>

func IsPairOfStringAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStringAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	func IsAPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	func @IsAPairOfStringAndNumber(paList)
		return IsPairOfStringAndNumber(paList)

	#>

func IsListOfPairsOfStringAndNumber(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	func IsAListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	func @IsAListOfPairsOfStringAndNumber(paList)
		return IsListOfPairsOfStringAndNumber(paList)

	#>

func IsPairOfNumberAndList(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfNumberAndList()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	func IsAPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	func @IsAPairOfNumberAndList(paList)
		return IsPairOfNumberAndList(paList)

	#>

func IsListOfPairsOfNumberAndList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndList()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	func IsAListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	func @IsAListOfPairsOfNumberAndList(paList)
		return IsListOfPairsOfNumberAndList(paList)

	#>

func IsPairOfListAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfListAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	func IsAPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	func @IsAPairOfListAndNumber(paList)
		return IsPairOfListAndNumber(paList)

	#>

func IsListOfPairsOfListAndNumber(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfListAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	func IsAListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	func @IsAListOfPairsOfListAndNumber(paList)
		return IsListOfPairsOfListAndNumber(paList)

	#>

func IsPairOfNumberAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfNumberAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	func IsAPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	func @IsAPairOfNumberAndObject(paList)
		return IsPairOfNumberAndObject(paList)

	#>

func IsListOfPairsOfNumberAndObject(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfNumberAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	func IsAListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	func @IsAListOfPairsOfNumberAndObject(paList)
		return IsListOfPairsOfNumberAndObject(paList)

	#>

func IsPairOfObjectAndNumber(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfObjectAndNumber()

	#< @FunctionAlternativeForms

	func @IsPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	func IsAPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	func @IsAPairOfObjectAndNumber(paList)
		return IsPairOfObjectAndNumber(paList)

	#>

func IsListOfPairsOfObjectAndNumber(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfObjectAndNumber()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	func IsAListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	func @IsAListOfPairsOfObjectAndNumber(paList)
		return IsListOfPairsOfObjectAndNumber(paList)

	#>

func IsPairOfStringAndList(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStringAndList()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndList(paList)
		return IsPairOfStringAndList(paList)

	func IsAPairOfStringAndList(paList)
		return IsPairOfStringAndList(paList)

	func @IsAPairOfStringAndList(paPair)
		return IsPairOfStringAndList(paPair)

	#>

func IsListOfPairsOfStringAndList(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndList()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	func IsAListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	func @IsAListOfPairsOfStringAndList(paList)
		return IsListOfPairsOfStringAndList(paList)

	#>

func IsPairOfListAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfListAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	func IsAPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	func @IsAPairOfListAndString(paList)
		return IsPairOfListAndString(paList)

	#>

func IsListOfPairsOfListAndString(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfListAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	func IsAListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	func @IsAListOfPairsOfListAndString(paList)
		return IsListOfPairsOfListAndString(paList)

	#>

func IsPairOfStringAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfStringAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	func IsAPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	func @IsAPairOfStringAndObject(paList)
		return IsPairOfStringAndObject(paList)

	#>

func IsListOfPairsOfStringAndObject(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfStringAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	func IsAListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	func @IsAListOfPairsOfStringAndObject(paList)
		return IsListOfPairsOfStringAndObject(paList)

	#>

func IsPairOfObjectAndString(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfObjectAndString()

	#< @FunctionAlternativeForms

	func @IsPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	func IsAPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	func @IsAPairOfObjectAndString(paList)
		return IsPairOfObjectAndString(paList)

	#>

func IsListOfPairsOfObjectAndString(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfObjectAndString()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	func IsAListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	func @IsAListOfPairsOfObjectAndString(paList)
		return IsListOfPairsOfObjectAndString(paList)

	#>

func IsPairOfListAndObject(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzListQ(paList).IsPairOfListAndObject()

	#< @FunctionAlternativeForms

	func @IsPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	func IsAPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	func @IsAPairOfListAndObject(paList)
		return IsPairOfListAndObject(paList)

	#>

func IsListOfPairsOfListAndObject(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfPairsOfListAndObject()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfListAndObject(paList)
		return IsListOfPairsOfListAndObject(paList)

	func IsAListOfPairsOfListAndObject(paList)
		return IsListOfPairsOfListAndObject(paList)

	func @IsAListOfPairsOfListAndObject(paPair)
		return IsListOfPairsOfListAndObject(paList)

	#>

func IsPairOfChars(paList)
	if NOT ( isList(paList) and len(paList) = 2 )
		return FALSE
	ok

	return StzPairQ(paList).IsPairOfChars()

	#< @FunctionAlternativeForms

	func @IsPairOfChars(paList)
		return IsPairOfChars(paList)

	func IsAPairOfChars(paList)
		return IsPairOfChars(paList)

	func @IsAPairOfChars(paList)
		return IsPairOfChars(paList)

	#>

func IsListOfPairsOfChars(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzPairQ(paList).IsListOfPairsOfChars()

	#< @FunctionAlternativeForms

	func @IsListOfPairsOfChars(paList)
		return IsListOfPairsOfChars(paList)

	func IsAListOfPairsOfChars(paList)
		return IsListOfPairsOfChars(paList)

	func @IsAListOfPaisrOfChars(paList)
		return IsListOfPairsOfChars(paList)

	#>

func IsPairOfEmptyLists(paList)
	if isList(paList) and len(paList) = 2 and
	   isList(paList[1]) and len(paList[1]) = 0 and
	   isList(paList[2]) and len(paList[2]) = 0

		return TRUE
	else
		return FALSE
	ok

	func IsAPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

	func @IsPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

	func @IsAPairOfEmptyLists(paList)
		return IsPairOfEmptyLists(paList)

func IsPairOf(pcType, paPair)
	if NOT ( isList(paPair) and len(paPair) = 2 )
		return FALSE
	ok

	return StzPairQ(paPair).IsPairOf(pcType)

	#< @FunctionAlternativeForms

	func @IsPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	func IsAPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	func @IsAPairOf(pcType, paPair)
		return IsPairOf(pcType, paPair)

	#>

func IsListOf(pcType, paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOf(pcType)

	#< @FunctionAlternativeForms

	func @IsListOf(pcType, paList)
		return IsListOf(pcType, paList)

	func IsAListOf(pcType, paList)
		return IsListOf(pcType, paList)

	func @IsAListOf(pcType, paList)
		return IsListOf(pcType, paList)

	#>

func IsListOfNamedObjects(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfNamedObjects()

	#< @FunctionAlternativeForms

	func @IsListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	func IsAListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	func @IsAListOfNamedObjects(paList)
		return IsListOfNamedObjects(paList)

	#>

func IsHashListOrListOfStrings(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsHashListOrListOfStrings()

	#< @FunctionAlternativeForms

	func @IsHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	func IsAHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	func @IsAHashListOrListOfStrings(paList)
		return IsHashListOrListOfStrings(paList)

	#>

func IsListOfListsOfSameSize(paList)
	if NOT isList(paList)
		return FALSE
	ok

	return StzListQ(paList).IsListOfListsOfSameSize()

	#< @FunctionAlternativeForms

	func @IsListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	func IsAListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	func @IsAListOfListsOfSameSize(paList)
		return IsListOfListsOfSameSize(paList)

	#>

func IsListInString(cStr)
	bResult = StzStringQ(cStr).IsListInString()
	return bResult

	func IsAListInString(cStr)
		return IsListInString(cStr)

	func @IsListInString(cStr)
		return IsListInString(cStr)

	func @IsAListInString(cStr)
		return IsListInString(cStr)


#===

func StzNamedList(paNamed)
	if CheckParams()
		if NOT (isList(paNamed) and Q(paNamed).IsPairOfStringAndList())
			StzRaise("Incorrect param type! paNamed must be a pair of string and list.")
		ok
	ok

	oList = new stzList(paNamed[2])
	oList.SetName(paNamed[1])
	return oList

	func StzNamedListQ(paNamed)
		return StzNamedList(paNamed)

	func StzNamedListXTQ(paNamed)
		return StzNamedList(paNamed)

func StzListMethods()
	return Stz(:List, :Methods)

func StzListAttributes()
	return Stz(:List, :Attributes)

func StzListClassName()
	return "stzlist"

	func StzListClass()
		return "stzlist"

func OnlyNumbers(paList)
	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	anResult = []

	for i = 1 to nLen
		if isNumber(paList[i])
			anResult + paList[i]
		ok
	next

	return anResult


	func @OnlyNumbers(paList)
		return OnlyNumbers(paList)

	func OnlyNumbersIn(paList)
		return OnlyNumbers(paList)

	func @OnlyNumbersIn(paList)
		return OnlyNumbers(paList)

#TODO: Add OnlyStrings() and cie...

def Flatten(paList)
	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []
	aTemp = []

	for i = 1 to nLen
		if isList(paList[i])
			aTemp = Flatten(paList[i]) # A recursive call
			nLenTemp = len(aTemp)

			for j = 1 to nLenTemp
				aResult + aTemp[j]
			next
		else
			aResult + paList[i]
		ok
	next

	return aResult

	func ListFlatten(paList)
		return Flatten(paList)

	func @Flatten(paList)
		return Flatten(paList)

func U(p)
	/* EXAMPLE

	? U([ "", 1, 2, 2, "", "", 3 ]) # Or Unique() or WithoutDuplicates()
	#--> [ "", 1, 2, 3 ]
	
	*/

	if CheckParams()
		if NOT isList(p)
			StzRaise("Incorrect param type!")
		ok
	ok

	result = StzListQ(p).WithoutDuplicates()
	return result

	func WithoutDuplicates(p)
		return U(p)

	func WithoutDupplicates(p)
		return U(p)

	func Unique(p)
		return U(p)

	func @U(p)
		return U(p)

	func @WithoutDuplicates(p)
		return U(p)

	func @WithoutDupplicates(p)
		return U(p)

	func @Unique(p)
		return U(p)

	func UniqueItems(p)
		return U(p)

	func @UniqueItems(p)
		return U(p)

	func UniqueItemsIn(p)
		return U(p)

	func @UniqueItemsIn(p)
		return U(p)

	func ToSet(p)
		return U(p)

	func @ToSet(p)
		return U(p)

func L(p)

	if isList(p)
		return p

	but isString(p)

		return StzStringQ(p).ToList()

	but isObject(p)
		return StzObject(p).ObjectAttributesAndValues()

	but isNumber(p)
		aResult = []
		for i = 1 to p
			aResult + NULL
		next

		return aResult

	else
		StzRaise("Incorrect param! Can't tranform param to list.")
	ok

	func LQ(p)
		return new stzList(L(p))

func ListReverse(paList)
	return reverse(paList) # Here we rely on the native Ring reverse() function

	func @Reverse(paList)
		return reverse(paList)

	func Inverse(paList)
		return reverse(paList)

	func @Inverse(paList)
		return reverse(paList)

func ListFirstItem(paList)
	return paList[1]

	#< @AlternativeFunctionNames

	func FirstItem(paList)
		return ListFirstItem(paList)

	func FirstItemIn(paList)
		return ListFirstItem(paList)

	func FirstItemInList(paList)
		return ListFirstItem(paList)

	#---

	func @FirstItem(paList)
		return ListFirstItem(paList)

	func @FirstItemIn(paList)
		return ListFirstItem(paList)

	func @FirstItemInList(paList)
		return ListFirstItem(paList)

	#>

func ListLastItem(paList)
	return paList[ len(paList) ]

	#< @AlternativeFunctionNames

	func LastItem(paList)
		return ListLastItem(paList)

	func LastItemIn(paList)
		return ListLastItem(paList)

	func LastItemInList(paList)
		return ListLastItem(paList)

	#---

	func @LastItem(paList)
		return ListLastItem(paList)

	func @LastItemIn(paList)
		return ListLastItem(paList)

	func @LastItemInList(paList)
		return ListLastItem(paList)

	#>

func UpdateLastItem(paList, pValue)
	oTempList = new stzList(paList)
	return oTempList.UpdateLastItem(pValue)

func FirstListIn(paList)
	oTempList = new stzList(paList)
	return LastItemIn( oTempList.WalkUntilItemIsList() )

func GenerateListAccessCode_FromNameAndPath(pcListName, paPath)
	// Warining: aPath must contain only numbers!!!
	cCode = pcListName
	for n in paPath
		cCode += ("["+ n + ']')
	next

	return cCode

func ListItemsAreAllStrings(paList)
	oTempList = new stzList(paList)
	return oTempList.ItemsAreAllStrings()

	func ItemsAreAllStrings(paList)
		return ListItemsAreAllStrings()

	func @ItemsAreAllStrings(paList)
		return ListItemsAreAllStrings()

	func AllItemsAreStrings(paList)
		return ListItemsAreAllStrings(paList)

	func @AllItemsAreStrings(paList)
		return ListItemsAreAllStrings(paList)

func IsLocaleList(paList)
	return StzListQ(paList).IsLocaleList()

	def @IsLocaleList(paList)
		return This.StzListQ(paList).IsLocaleList()

#===

func CallMethod( pcMethod, paOnObjects )

	if NOT ( paOnObjects[1] = "on" and StzListQ(paOnObjects[2]).IsListOfStrings() )
		StzRaise(stzObjectError(:CanNotProcessMethodCall))
	ok

	aResult = []
	for cObjName in paOnObjects[2]
		cCode = "aResult + " + cObjName + "." + pcMethod
		eval(cCode)
	next
	return aResult

#====

func AreBothEqualCS(p1, p2, pCaseSensitive)

	if NOT type(p1) = type(p2)
		return FALSE
	ok

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
		StzRaise("Incorrect param! pCaseSensitive must be TRUE or FALSE.")
	ok

	if isNumber(p1)
		return p1 = p2

	but isString(p1)

		if pCaseSensitive = FALSE
			p1 = lower(p1)
			p2 = lower(p2)
		ok

		return p1 = p2

	else
		return Q(p1).IsEqualToCS(p2, pCaseSensitive)
	ok

	#< @FunctionAlternativeForms

	func BothAreEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	func @AreBothEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	func @BothAreEqualCS(p1, p2, pCaseSensitive)
		return AreBothEqualCS(p1, p2, pCaseSensitive)

	#>

	#< @FunctionNegativeForms

	func BothAreNotEqualCS(p1, p2, pCaseSensitive)
		return NOT AreBothEqualCS(p1, p2, pCaseSensitive)

	func @AreNotBothEqualCS(p1, p2, pCaseSensitive)
		return BothAreNotEqualCS(p1, p2, pCaseSensitive)

	func @BothAreNotEqualCS(p1, p2, pCaseSensitive)
		return BothAreNotEqualCS(p1, p2, pCaseSensitive)

	#>

#-- WITHOUT CASESENSITIVITY

func AreBothEqual(p1, p2)
	return AreBothEqualCS(p1, p2, TRUE)

	#< @FunctionAlternativeForms

	func BothAreEqual(p1, p2)
		return AreBothEqual(p1, p2)

	func @AreBothEqual(p1, p2)
		return AreBothEqual(p1, p2)

	func @BothAreEqual(p1, p2)
		return AreBothEqual(p1, p2)

	#>

	#< @FunctionNegativeForms

	func BothAreNotEqual(p1, p2)
		return NOT AreBothEqual(p1, p2)

	func @AreNotBothEqual(p1, p2)
		return BothAreNotEqual(p1, p2)

	func @BothAreNotEqual(p1, p2)
		return BothAreNotEqual(p1, p2)

	#>


#===

func AreEqualCS(paValues, pCaseSensitive)
	if NOT isList(paValues)
		return FALSE
	ok

	if NOT AllHaveSameType(paValues)
		return FALSE
	ok

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
		StzRaise("Incorrect param! pCaseSensitive must be TRUE or FALSE.")
	ok

	# Early checks

	nLen = len(paValues)
	if nLen = 0
		return FALSE
	but nLen = 1
		return TRUE
	ok

	# Doing the job

	bResult = TRUE

	if IsNumber(paValues[1])

		for i = 2 to nLen
			if paValues[i] != paValues[1]
				bResult = FALSE
				exit
			ok
		next

		return bResult

	but isString(paValues[1])
		if pCaseSensitive = FALSE
			for i = 1 to nLen
				paValues[i] = lower(paValues[i])
			next
		ok

		for i = 2 to nLen
			if paValues[i] != paValues[1]
				bResult = FALSE
				exit
			ok
		next

		return bResult

	else

		for i = 2 to nLen
			if NOT Q(paValues[i]).IsEqualCS(paValues[1], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

	ok

	#< @FunctionAlternativeForms

	func @AreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func AreAllEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func @AreAllEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func AllAreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	func @AllAreEqualCS(paValues, pCaseSensitive)
		return AreEqualCS(paValues, pCaseSensitive)

	#>

	#< @FunctionNegativeForms

	func AreNotEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AreNotEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	func AreNotAllEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AreNotAllEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	func AllAreNotEqualCS(paValues, pCaseSensitive)
		return NOT AreEqualCS(paValues, pCaseSensitive)

	func @AllAreNotEqualCS(paValues, pCaseSensitive)
		return AreNotEqualCS(paValues, pCaseSensitive)

	#>

#-- WITHOUT CASESENSITIVITY

func AreEqual(paValues)
	return AreEqualCS(paValues, TRUE)

	#< @FunctionAlternativeForm

	func @AreEqual(paValues)
		return AreEqual(paValues)

	func AreAllEqual(paValues)
		return AreEqual(paValues)

	func @AreAllEqual(paValues)
		return AreEqual(paValues)

	func AllAreEqual(paValues)
		return AreEqual(paValues)

	func @AllAreEqual(paValues)
		return AreEqualCS(paValues)

	#>

	#< @FunctionNegativeForms

	func AreNotEqual(paValues)
		return NOT AreEqual(paValues)

	func @AreNotEqual(paValues)
		return AreNotEqual(paValues)

	func AreNotAllEqual(paValues)
		return AreNotEqual(paValues)

	func @AreNotAllEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	func AllAreNotEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	func @AllAreNotEqual(paValues, pCaseSensitive)
		return AreNotEqual(paValues)

	#>

#===

func HaveSameType(paItems)
	if NOT isList(paItems)
		StzRaise("Incorrect param type! paItems must be a list.")
	ok

	nLen = len(paItems)
	if nLen = 0
		return FALSE
	but nLen = 1
		return TRUE
	ok

	# Case nLen >= 2

	bResult = TRUE
	for i = 2 to nLen
		if ring_type( paItems[1] ) != ring_type( paItems[i] )
			bResult = FALSE
			exit
		ok
	next
	return bResult

	func @HaveSameType(paItems)
		return HaveSameType(paItems)

	func AllHaveSameType(paItems)
		return HaveSameType(paItems)

	func @AllHaveSameType(paItems)
		return HaveSameType(paItems)

func BothHaveSameType(p1, p2)
	return ring_type(p1) = ring_type(p2)

func HaveSameContent(paItems)
	/* Two items have same content when:
	 if they are stringified they are equal strings.

	Stringifying number 12 generate string "12"
	*/
	if NOT isList(paItems)
		StzRaise("Incorrect param type! paItems must be a list.")
	ok

	if len(paItems) = 1
		return TRUE
	ok

	bResult = TRUE
	for i = 2 to len(paItems)
		bOk = Q( @@( paItems[i] ) ).IsEqualTo( @@( paItems[1] ) )
		if NOT bOk
			bResult = FALSE
			exit
		ok
	next
	return bResult

	func @HaveSameContent(paItems)
		return HaveSameContent(paItems)

func HaveBothSameType(p1, p2)
	return ring_type(p1) = ring_type(p2)

	func @HaveBothSameType(p1, p2)
		return HaveBothSameType(p1, p2)

func IsEmptyList(paList)
	return StzListQ(paList).IsEmpty()
		
	func IsAnEmptyList(paList)
		return IsEmptyList(paList)

	func @IsEmptyList(paList)
		return IsEmptyList(paList)

	func @IsAnEmptyList(paList)
		return IsEmptyList(paList)

#===

func ListShow(paList)
	StzListQ(paList).Show()

func AreNumbers(paList)
	return StzListQ(paList).ContainsOnlyNumbers()

	#< @FunctionAlternativeForms

	func AllAreNumbers(paList)
		return AreNumbers(paList)

	func AreAllNumbers(paList)
		return AreNumbers(paList)

	func TheseAreNumbers(paList)
		return AreNumbers(paList)

	func AllTheseAreNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfOnlyNumbers(paList)
		return AreNumbers(paList)

	func IsMadeOfJustNumbers(paList)
		return AreNumbers(paList)

	func ContainsOnlyNumbers(paList)
		return AreNumbers(paList)

	func ContainsJustNumbers(paList)
		return AreNumbers(paList)

	#--

	func @AreNumbers(paList)
		return AreNumbers(paList)

	func @AllAreNumbers(paList)
		return AreNumbers(paList)

	func @AreAllNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfOnlyNumbers(paList)
		return AreNumbers(paList)

	func @IsMadeOfJustNumbers(paList)
		return AreNumbers(paList)

	func @ContainsOnlyNumbers(paList)
		return AreNumbers(paList)

	func @ContainsJustNumbers(paList)
		return AreNumbers(paList)

	#TODO : Add these alternatives to other similar functions
	#>

func AreStrings(paList)
	return StzListQ(paList).ContainsOnlyStrings()

	#< @FuncctionAlternativeForms

	func AllAreStrings(paList)
		return AreStrings(paList)

	func AreAllStrings(paList)
		return AreStrings(paList)

	func TheseAreStrings(paList)
		return AreStrings(paList)

	func AllTheseAreStrings(paList)
		return AreStrings(paList)

	#--

	func @AreStrings(paList)
		return AreStrings(paList)

	func @AllAreStrings(paList)
		return AreStrings(paList)

	func @AreAllStrings(paList)
		return AreStrings(paList)

	#>

func AreLists(paList)
	return StzListQ(paList).ContainsOnlyLists()

	#< @FunctionAlternativeForms

	func AllAreLists(paList)
		return AreLists(paList)

	func AreAllLists(paList)
		return AreLists(paList)

	func TheseAreLists(paList)
		return AreLists(paList)

	#--

	func @AreLists(paList)
		return AreLists(paList)

	func @AllAreLists(paList)
		return AreLists(paList)

	func @AreAllLists(paList)
		return AreLists(paList)

	#>

func AreObjects(paList)
	return StzListQ(paList).ContainsOnlyObjects()

	#< @FunctionAlternativeForms

	func AllAreObjects(paList)
		return AreObjects(paList)

	func AreAllObjects(paList)
		return AreObjects(paList)

	func TheseAreObjects(paList)
		return AreObjects(paList)

	#--

	func @AreObjects(paList)
		return AreObjects(paList)

	func @AllAreObjects(paList)
		return AreObjects(paList)

	func @AreAllObjects(paList)
		return AreObjects(paList)

	#>

func IsRangeNamedParamList(paList)
	return StzListQ(paList).IsRangeNamedParam()

	func @IsRangeNamedParamList(paList)
		return IsRangeNamedParamList(paList)

func ListToCode(paList)
	return StzListQ(paList).ToCode()


func AllTheseAreNull(paList)
	return StzListQ(paList).AllItemsAreNull()

	func AllOfTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func TheseAreNull(paList)
		return AllTheseAreNull(paList)

	#--

	func @AllTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func @AllOfTheseAreNull(paList)
		return AllTheseAreNull(paList)

	func @TheseAreNull(paList)
		return AllTheseAreNull(paList)

func AllOfTheseAreNotNull(paList)
	bResult = TRUE
	for item in paList
		if isString(item) and isNull(item)
			bResult = FALSE
			exit
		ok
	next

	return bResult

	func NoOneOfTheseIsNull(paList)
		return AllOfTheseAreNotNull(paList)

	func TheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

	#--

	func @AllOfTheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

	func @NoOneOfTheseIsNull(paList)
		return AllOfTheseAreNotNull(paList)

	func @TheseAreNotNull(paList)
		return AllOfTheseAreNotNull(paList)

func BothAreNull(p1, p2)
	return TheseAreNull([ p1, p2 ])

	func @BothAreNull(p1, p2)
		return BothAreNull(p1, p2)

func BothAreNotNull(p1, p2)
	return TheseAreNotNull([ p1, p2 ])

	func @BothAreNotNull(p1, p2)
		return BothAreNotNull(p1, p2)

func NoOneOfTheseIsAString(paList)
	bResult = TRUE
	for item in paList
		if isString(item)
			bResult = FALSE
			exit
		ok
	next
	
	return bResult

	func @NoOneOfTheseIsAString(paList)
		return NoOneOfTheseIsAString(paList)

func List@(paList)
	if isList(paList)
		return ComputableForm(paList)
	ok

func ListFindAll(paList, p)
	return StzListQ(paList).FindAll(p)

func ListOfNTimes(n, pItem)
	aResult = []
	for i = 1 to n
		aResult + pItem
	next
	return aResult

#--

func WithoutDuplication(paList)
	return StzListQ(paList).WithoutDuplication()

	func @WithoutDuplication(paList)
		return WithoutDuplication(paList)

	#-- @Misspelled (two p instead of one)

	func WithoutDupplication(paList)
		return WithoutDuplication(paList)

	func @WithoutDupplication(paList)
		return WithoutDuplication(paList)

func StringsIn(paList)
	if CheckParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isString(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForm

	func @StringsIn(paList)
		return Strings(paList)

	#>

func ListsIn(paList)
	if CheckParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isList(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForm

	func @ListsIn(paList)
		return Lists(paList)

	#>

func ObjectsIn(paList)
	if CheckParams()
		if NOT IsList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok
	ok

	nLen = len(paList)
	aResult = []

	for i = 1 to nLen
		if isObject(paList[i])
			aResult + palist[i]
		ok
	next

	return aResult

	#< @FunctionAlternativeForms

	func @ObjectsIn(paList)
		return Objects(paList)

	#>

#===

# A softanza function that uses the native Find() function in Ring
# to find the nth occurrence of an item in a list
#-> Used by stzList when possible (for better performance)

func @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	if CheckParams()
		if NOT isList(aList)
			StzRaise("Incorrect param type! aList must be a list.")
		ok

		if NOT isNumber(nth)
			StzRaise("Incorrect param type! nth must be a number.")
		ok

		if NOT (isString(pItem) or isNumber(pItem))
			return -1
		ok

		if NOT isNumber(nStart)
			StzRaise("Incorrect param type! nStart must be a number.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok
	ok

	if pCaseSensitive = FALSE 
		if isString(pItem)
			pItem = lower(pItem)
		ok

		aList = StzListQ(aList).Lowercased()
	ok

	nLen = len(aList)
	aContent = []

	for i = nStart to nLen
		aContent + aList[i]
	next

	nPos = -1
	n = 0

	while TRUE
		try
			nPos = find(aContent, pItem)
		catch
			return -1
		done

		if nPos = 0
			exit
		ok

		n++
		if n = nth
			exit
		ok

		aContent[nPos] += (""+ aContent[nPos]+1)
		
	end

	nResult = nPos + nStart - 1
	return nResult

	func FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	#--

	func @FindNthNextSCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNextNthSCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNextNthSCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNthNextSCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)


	func FindNthNextStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func FindNextNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)


	func @FindNextNthStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	func @FindNthNextStartingAtCS(aList, nth, pItem, nStart, pCaseSensitive)
		return @FindNthSCS(aList, nth, pItem, nStart, pCaseSensitive)

	#>

func @FindNthS(aList, nth, pItem, nStart)
	return @FindNthSCS(aList, nth, pItem, nStart, TRUE)

	#< @FunctionAlternativeForms

	func @FindNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func FindNthS(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func FindNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	#--

	func @FindNthNextS(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func @FindNextNthS(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func FindNextNthS(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func FindNthNextS(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)


	func FindNthNextStartingAt(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func FindNextNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)


	func @FindNextNthStartingAt(aList, nth, pItem, nStart)
		return @FindNthS(aList, nth, pItem, nStart)

	func @FindNthNextStartingAt(aList, nth, pItem, nStart)
		return @FindNthSCS(aList, nth, pItem, nStart)

	#>

#==

func @FindNextCS(aList, pItem, nStart, pCaseSensitive)
	return @FindNthNextSCS(aList, 1, pItem, nStart, pCaseSensitive)

	func FindNextCS(aList, pItem, nStart, pCaseSensitive)
		return @FindNextCS(aList, pItem, nStart, pCaseSensitive)

func @FindNext(aList, pItem, nStart)
	return @FindNextCS(aList, pItem, nStart, TRUE)

	func FindNext(aList, pItem, nStart)
		return @FindNext(aList, pItem, nStart)

#===

# A softanza function that uses the native Find() function in Ring
# to find the occurrences of an item in a given list
#-> Used by stzList when possible (for better performance)

func @FindAllCS(aList, pItem, pCaseSensitive)

	if CheckParams()
		if NOT isList(aList)
			StzRaise("Incorrect param type! aList must be a list.")
		ok

		if NOT (isString(pItem) or isNumber(pItem))
			return -1
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( isNumber(pCaseSensitive) and (pCaseSensitive = 0 or pCaseSensitive = 1) )
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok
	ok

	nLen = len(aList)

	if EarlyCheck()
		if nLen = 0
			return []
		ok
	ok

	if pCaseSensitive = FALSE 
		if isString(pItem)
			pItem = lower(pItem)
		ok

		aList = StzListQ(aList).Lowercased()
	ok

	aContent = aList

	anResult = []
	nPos = -1
	n = 0

	while TRUE
		try
			nPos = find(aContent, pItem)
		catch
			return -1
		done

		if nPos = 0
			exit
		ok

		anResult + nPos
		aContent[nPos] += (""+ aContent[nPos]+1)
		
	end

	
	return anResult

	func FindAllCS(aList, pItem, pCaseSensitive)
		return @FindAllCS(aList, pItem, pCaseSensitive)


func @FindAll(aList, pItem)
	return @FindAllCS(aList, pItem, TRUE)

	func FindAll(aList, pItem)
		return @FindAll(aList, pItem)

func IsRingSortable(pListOrString)

	# Ring can sort string ans lists.

	# In the case of lists, only lists made of numbers and strings
	# can be sorted. There is a special case though...

	# If the list is a list of lists, then Ring can sort it on
	# a given column, using ring(aList, nCol), but under a condition:

	# the column must be made of numbers and/or strings and must not
	# contain dupplicated items (because in this case, the output
	# is not accurate, at a hiher level, and should be managed by Softanza)

	if CheckParams()
		if NOT ( isString(pListOrString) or isList(pListOrString) )
			StzRaise("Incorrect param type! pListOrString must be a list or string.")
		ok
	ok

	if isString(pListOrString)
		return TRUE
	ok

	# Case of a list

	if IsListOfNumbers(pListOrString) or
	   IsListOfStrings(pListOrString) or
	   IsListOfNumbersAndStrings(pListOrString)

		return TRUE

	but IsListOfLists(pListOrString)

		# Early check: case where one of the lists is empty

		nLen = len(pListOrString)

		for i = 1 to nLen
			if len(pListOrString[i]) = 0
				return FALSE
			ok
		next

		# Checking the columns one by one, and when we
		# find a column that is made of numbers and/or
		# strings and containing no dupplications, then
		# that column make the list of lists sortable

		oLoL = new stzListOfLists(pListOrString)
		nCols = oLoL.NumberOfCols()

		# Parsing all the columns one by one

		for i = 1 to nCols

			# Assuming the current column is Ring sortable

			bColSortable = TRUE

			# the column must contain only numbers and strings
			# and should not contain dupplicated items

			aCol = oLoL.Col(i)

			nLenCol = len(aCol)
			aSeen = []

			for j = 1 to nLenCol

				if NOT ( isString(aCol[j]) or isNumber(aCol[j]) )
					bColSortable = FALSE
					exit
				else
					if ring_find(aSeen, aCol[j]) = 0
						aSeen + aCol[j]
					else
						bColSortable = FALSE
						exit
					ok
				ok
			next

			if bColSortable # We've got a ring-sortable column!
				return TRUE
			ok

		next

		# We parsed all the list of lists, column by column, and
		# we did not find any ring-sortable column, so:

		return FALSE

	ok

	# In any other case

	return FALSE

	func @IsRingSortable(pListOrString)
		return IsRingSortable(pListOrString)

func IsRingSortableOn(paListOfLists, n)

	# In Ring, with the standard ring() function, to sort a list of
	# lists on a given column, that column must:

	# 1. the column of sort should have size as the first column
	# 2. be made of numbers or strings only (no lists or objects),
	# 3. must not contain dupllicated items (because in this case,
	#    the sorting result is not accurate - from Softanza point of view)

	if NOT ( isList(paListOfLists) and IsListOfLists(paListOfLists) )
		return FALSE
	ok

	if NOT isNumber(n)
		StzRaise("Incorrect param type! n must be a number.")
	ok

	# Early check : case where at least one list is empty

	nLen = len(paListOfLists)

	for i = 1 to nLen
		if len(paListOfLists[i]) = 0
			return FALSE
		ok
	next

	# getting the items in the column n

	oLoL = StzListOfListsQ(paListOfLists)
	aCol = oLoL.Col(n)
	nLen = len(aCol)

	# Early check: the column of sort should have
	# the same number of items as the first column

	if n > 1
		aCol1 = oLoL.Col(1)
		nLen1 = len(aCol1)

		if nLen != nLen1
			return FALSE
		ok
	ok

	aSeen = []

	for i = 1 to nLen
		if NOT ( isNumber(aCol[i]) or isString(aCol[i]) )
			return FALSE
		ok

		if ring_find(aSeen, aCol[i]) = 0
			aSeen + aCol[i]
		else
			return FALSE
		ok
	next

	return TRUE

	func @IsRingSortableOn(paListOfLists, n)
		return IsRingSortableOn(paListOfLists, n)
	
func Move(paList, n1, n2)

	if CheckParams()
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if NOT isNumber(n1)
			StzRaise("Incorrect param type! n1 must be a number.")
		ok

		if NOT isNumber(n2)
			StzRaise("Incorrect param type! n2 must be a number.")
		ok
	ok

	item = paList[n1]
	ring_remove(paList, n1)
	n = n2
	if n1 > n2
		n++
	ok
	ring_insert(paList, n2, item)
	return paList


	#< @FunctionAlternativeForms

	func @Move(paList, n1, n2)
		return Move(paList, n1, n2)

	func MoveItems(paList, n1, n2)
		return Move(paList, n1, n2)

	func @MoveItems(paList, n1, n2)
		return Move(paList, n1, n2)

	#>

  /////////////////
 ///   CLASS   ///
/////////////////

class stzList from stzObject
	@aContent = []

	@aWalkers = []

	  #--------------#
	 #     INIT     #
	#--------------#

	def init(paList)
		if CheckParams()

			if NOT isList(paList)
				StzRaise("Can't create the stzList object! paList must be a list.")
			ok
		ok

		@aContent = paList

	  #---------------------#
	 #     CONSTRAINTS     #
	#---------------------#
	// TODO: Finish stzConstraint --> Finsh Constraints section here and
	// in other classes (StzString...)

	//def MustBe(pcIsMethod)


	//def CanNotBe(pcIsMethod)


	  #-----------------------------------#
	 #  GETTING THE CONTENT OF THE LIST  #
	#-----------------------------------#

	def ContentCS(pCaseSensitive)
		
		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok
	
		if NOT (pCaseSensitive = 0 or pCaseSensitive = 1)
			StzRaise("Incorrect param type! pCaseSensitive must be 1 (TRUE) or 0 (FALSE).")
		ok

		aResult = []

		if pCaseSensitive = TRUE
			aResult = @aContent

		else
			aResult = This.WithoutDuplicationCS(FALSE)
		
		ok

		return aResult

		#< @FunctionAlternativeForm

		def ContentCSQ(pCaseSensitive)
			return new stzList(This.Content())

		#>

		#< @FunctionAlternativeForms

		def ValueCS(pCaseSensitive)
			return This.ContentCS(pCaseSensitive)

			def ValueCSQ(pCaseSensitive)
				return This.ContentCSQ(pCaseSensitive)

		def ListCS(pCaseSensitive)
			return This.ContentCS(pCaseSensitive)

			def ListCSQ(pCaseSensitive)
				return This.ContentCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Content()
		return @aContent

		#< @FunctionAlternativeForm

		def ContentQ()
			return new stzList(This.Content())

		#>

		#< @FunctionAlternativeForms

		def Value()
			return This.Content()

			def ValueQ()
				return This.ContentQ()

		def List()
			return This.Content()

			def ListQ()
				return This.ContentQ()

		#>

	  #--------------------------------------------------------#
	 #  GETTING THE CONTENT OF THE LIST WITHOUT DUPPLICATION  #
	#--------------------------------------------------------#

	def ContentCSU(pCaseSensitive)
		return This.WithoutDuplicationCS(FALSE)


		#< @FunctionAlternativeForm

		def ContentCSUQ(pCaseSensitive)
			return new stzList(This.ContentU())

		#>

		#< @FunctionAlternativeForms

		def ValueCSU(pCaseSensitive)
			return This.ContentCSU(pCaseSensitive)

			def ValueCSUQ(pCaseSensitive)
				return This.ContentCSUQ(pCaseSensitive)

		def ListCSU(pCaseSensitive)
			return This.ContentCSU(pCaseSensitive)

			def ListCSUQ(pCaseSensitive)
				return This.ContentCSUQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContentU()
		return This.WithoutDuplication()

		#< @FunctionAlternativeForm

		def ContentUQ()
			return new stzList(This.ContentU())

		#>

		#< @FunctionAlternativeForms

		def ValueU()
			return This.ContentU()

			def ValueUQ()
				return This.ContentUQ()

		def ListU()
			return This.ContentU()

			def ListUQ()
				return This.ContentUQ()

		#>

	  #------------------------------#
	 #  GETTING A COPY OF THE LIST  #
	#------------------------------#

	def Copy()
		return new stzList( This.List() )

	def ReversedCopy()
		return This.ReverseQ()

	  #-------------------------------------------#
	 #  GETTING THE NUMBER OF ITEMS OF THE LIST  #
	#-------------------------------------------#

	def NumberOfItemsCS(pCaseSensitive)
		nResult = len( This.ContentCS(pCaseSensitive) )
		return nResult

		#< @FuntionFluentForm

		def NumberOfItemsCSQ(pCaseSensitive)
			return new stzNumber( This.NumberOfItemsCS(pCaseSensitive) )

		#>

		#< @FunctionBooleanForm

		def NumberOfItemsCSB(pCaseSensitive)
			if This.NumberOfItemsCS(pCaseSensitive) = LastValue()
				return TRUE
			else
				return FALSE
			ok

			def NumberOfItemsCSBQ(pCaseSensitive)
				if This.NumberOfItemsCSB(pCaseSensitive)
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def SizeCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def SizeCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def SizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def LengthCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def LengthCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def LengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#-- Used in natural-coding

		def ANumberOfItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ANumberOfItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ANumberOfItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ANumberOfItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ASizeCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ASizeCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ASizeCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ASizeCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def ALengthCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def ALengthCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def ALengthCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def ALengthCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#--

		def CountItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def CountItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def CountItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def CountItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		def HowManyItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

			def HowManyItemsCSQ(pCaseSensitive)
				return This.NumberOfItemsCSQ(pCaseSensitive)

			def HowManyItemsCSB(pCaseSensitive)
				return This.NumberOfItemsCSB(pCaseSensitive)

			def HowManyItemsCSBQ(pCaseSensitive)
				return This.NumberOfCharCSBQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def NuberOfItemsCS(pCaseSensitive)
			return This.NumberOfItemsCS(pCaseSensitive)

		#--

		def LenghtCS(pCaseSensitive)
			return This.LengthCS(pCaseSensitive)

		def LenghtCSQ(pCaseSensitive)
			return This.NumberOfItemsCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfItems()
		nResult = len(@aContent)
		return nResult

		#< @FuntionFluentForm

		def NumberOfItemsQ()
			return new stzNumber( This.NumberOfItems() )

		#>

		#< @FunctionBooleanForm

		def NumberOfItemsB()
			if This.NumberOfItems() = LastValue()
				return TRUE
			else
				return FALSE
			ok

			def NumberOfItemsBQ()
				if This.NumberOfItemsB()
					return This
				else
					return AFalseObject()
				ok

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfItems()

			def SizeQ()
				return This.NumberOfItemsQ()

			def SizeB()
				return This.NumberOfItemsB()

			def SizeBQ()
				return This.NumberOfCharBQ()

		def Length()
			return This.NumberOfItems()

			def LengthQ()
				return This.NumberOfItemsQ()

			def LengthB()
				return This.NumberOfItemsB()

			def LengthBQ()
				return This.NumberOfCharBQ()

		#-- Used in natural-coding

		def ANumberOfItems()
			return This.NumberOfItems()

			def ANumberOfItemsQ()
				return This.NumberOfItemsQ()

			def ANumberOfItemsB()
				return This.NumberOfItemsB()

			def ANumberOfItemsBQ()
				return This.NumberOfCharBQ()

		def ASize()
			return This.NumberOfItems()

			def ASizeQ()
				return This.NumberOfItemsQ()

			def ASizeB()
				return This.NumberOfItemsB()

			def ASizeBQ()
				return This.NumberOfCharBQ()

		def ALength()
			return This.NumberOfItems()

			def ALengthQ()
				return This.NumberOfItemsQ()

			def ALengthB()
				return This.NumberOfItemsB()

			def ALengthBQ()
				return This.NumberOfCharBQ()

		#--

		def CountItems()
			return This.NumberOfItems()

			def CountItemsQ()
				return This.NumberOfItemsQ()

			def CountItemsB()
				return This.NumberOfItemsB()

			def CountItemsBQ()
				return This.NumberOfCharBQ()

		def HowManyItems()
			return This.NumberOfItems()

			def HowManyItemsQ()
				return This.NumberOfItemsQ()

			def HowManyItemsB()
				return This.NumberOfItemsB()

			def HowManyItemsBQ()
				return This.NumberOfCharBQ()

		#>

		#< @FunctionMisspelledForms

		def NuberOfItems()
			return This.NumberOfItems()

		#--

		def Lenght()
			return This.Length()

		def LenghtQ()
			return This.NumberOfItemsQ()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF ITEMS OF THE LIST -- U/Extended FORM  #
	#--------------------------------------------------------------#

	def NumberOfItemsU()
		return len( Q(This.Content()).WithoutDuplicates() )

		def NumberOfItemsUQ()
			return new stzNumber(This.NumberOfItemsU())

		def SizeU()
			return This.NumberOfItemsU()

		def LengthU()
			return This.NumberOfItemsU()

			#-- @Misspelled

			def LenghtU()
				return This.NumberOfItemsU()

		def CountItemsU()
			return This.NumberOfItemsU()

		def HowManyItemsU()
			return This.NumberOfItemsU()
	
		def HowManyItemU()
			return This.NumberOfItemsU()

	  #-----------------------------------------#
	 #  GETTING THE SIZE OF THE LIST IN BYTES  #
	#-----------------------------------------#
	#TODO

	def SizeInBytes()
		StzRaise("Unavailable feature in this version!")

		def HownManyBytes()
			return This.SizeInBytes()

	  #-----------------------------#
	 #  GETTING THE LIST OF ITEMS  #
	#-----------------------------#

	def Items()
		return This.Content()

		#< @FunctionFluentForm

		def ItemsQ()
			return This

		#>

	  #------------------------------------#
	 #  GETTING THE NTH ITEM IN THE LIST  #
	#------------------------------------#

	def Item(n)
		if CheckParams()

			if isString(n)
				if n = "first"
					n = 1
	
				but n = "last"
					n = This.NumberOfItems()
	
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n should be a number.")
			ok
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if n < 0
			n = nLen + n + 1
		ok

		return This.Content()[n]

		def ItemQ(n)
			return Q(This.Item(n))

		#< @AlternativeFunctionNames

		def NthItem(n)
			return This.Item(n)

			def NthItemQ(n)
				return Q(This.NthItem(n))

		def ItemAtPosition(n)
			return This.Item(n)

		def ItemAt(n)
			return This.Item(n)

		#>

	  #--------------------------------------#
	 #  GETTING THE FIRST ITEM IN THE LIST  #
	#--------------------------------------#

	def FirstItem()
		return This.NthItem(1)

		def FirstItemQ()
			return Q(This.FirstItem())

		#-- MISSPELLED

		def FristItem()
			return This.FirstItem()

			def FristItemQ()
				return This.FirstItemQ()

	  #-------------------------------------#
	 #  GETTING THE LAST ITEM IN THE LIST  #
	#-------------------------------------#

	def LastItem()
		return This.NthItem( This.NumberOfItems() )

		def LastItemQ()
			return Q(This.LastItem())

	  #------------------------------------------------#
	 #  GETTING THE FIRST AND LAST ITEMS IN THE LIST  #
	#------------------------------------------------#

	def FirstAndLastItems()
		aResult = [ This.FirstItem(), This.LastItem() ]
		return aResult

		#-- MISSPELLED

		def FristAndLastItems()
			return This.FirstAndLastItems()

	def LastAndFirstItems()
		aResult = [ This.LastItem(), FirstItem() ]
		return aResult

		#-- MISSPELLED

		def LastAndFristItems()
			return This.LastAndFirstItems()

	  #--------------------------------------------#
	 #  GETTING THE CENTRAL POSITION IN THE LIST  #
	#--------------------------------------------#

	def CentralPosition()
		oTemp = new stzNumber( (This.NumberOfItems()/2) )
		n = oTemp.IntegerPartValue()
		return n

		def CentralItemPosition()
			return This.CentralPosition()

	  #----------------------------------------#
	 #  GETTING THE CENTRAL ITEM IN THE LIST  #
	#----------------------------------------#

	def CentralItem()
		return This[CentralPosition()]

		def CentralItemQ()
			return Q(This.CentralItem())

	  #---------------------------------------------#
	 #  CHECKING IF THE STRING HAS A CENTRAL ITEM  #
	#---------------------------------------------#

	def HasCentralItem()
		return This.NumberOfItemsQ().IsNotEven()

		def ContainsCentralItem()
			return This.HasCentralItem()

	  #-------------------------------------#
	 #  GETTING THE LIST OF N FIRST ITEMS  #
	#-------------------------------------#

	def NFirstItems(n)
		aContent = This.Content()
		aResult = []

		for i = 1 to n
			aResult + aContent[i]
		next

		return aResult
		
		#< @FunctionFluentForms

		def NFirstItemsQ(n)
			return NFirstItemsQR(n, :stzList)

		def NFirstItemsQR(n, pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstItems(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstItems(n) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NFirstItems(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def FirstNItems(n)
			return This.NFirstItems(n)

			def FirstNItemsQ(n)
				return This.NFirstItemsQ(n)

			def FirstNItemsQR(n, pcReturnType)
				return This.NFirstItemsQR(n, pcReturnType)

		#>

		#< @FunctionSpecieficForms

		def First2Items()
			return This.FirstNItems(2)
	
			def 2FirstItems()
				return This.First2Items()
	
			def FirstTwoItems()
				return This.First2Items()
	
			def TwoFirstItems()
				return This.First2Items()
	
		def First3Items()
			return This.FirstNItems(3)
	
			def 3FirstItems()
				return This.First3Items()
	
			def FirstThreeItems()
				return This.First2Items()
	
			def ThreeFirstItems()
				return This.First3Items()
	
		def First4Items()
			return This.FirstNItems(4)
	
			def 4FirstItems()
				return This.First4Items()
	
			def FirstFourItems()
				return This.First4Items()
	
			def FourFirstItems()
				return This.First4Items()
	
		def First5Items()
			return This.FirstNItems(5)
	
			def 5FirstItems()
				return This.First5Items()
	
			def FirstFiveItems()
				return This.First5Items()
	
			def FiveFirstItems()
				return This.First5Items()
	
		def First6Items()
			return This.FirstNItems(6)
	
			def 6FirstItems()
				return This.First6Items()
	
			def FirstSixItems()
				return This.First6Items()
	
			def SixFirstItems()
				return This.First6Items()
	
		def First7Items()
			return This.FirstNItems(7)
	
			def 7FirstItems()
				return This.First7Items()
	
			def FirstSevenItems()
				return This.First7Items()
	
			def SevenFirstItems()
				return This.First7Items()
	
		def First8Items()
			return This.FirstNItems(8)
	
			def 8FirstItems()
				return This.First8Items()
	
			def FirstEightItems()
				return This.First8Items()
	
			def EightFirstItems()
				return This.First8Items()
	
		def First9Items()
			return This.FirstNItems(9)
	
			def 9FirstItems()
				return This.First9Items()
	
			def FirstNineItems()
				return This.First9Items()
	
			def NineFirstItems()
				return This.First9Items()
	
		def First10Items()
			return This.FirstNItems(10)
	
			def 10FirstItems()
				return This.First10Items()
	
			def FirstTenItems()
				return This.First10Items()
	
			def TenFirstItems()
			return This.First10Items()

		#>

		#< @FunctionAMisspelledForms

		def NFristItems(n)
			return This.NFirstItems(n)

			def NFristItemsQ(n)
				return This.NFirstItemsQ(n)

			def NFristItemsQR(n, pcReturnType)
				return This.NFirstItemsQR(n, pcReturnType)

		def FristNItems(n)
			return This.NFirstItems(n)

			def FristNItemsQ(n)
				return This.NFirstItemsQ(n)

			def FristNItemsQR(n, pcReturnType)
				return This.NFirstItemsQR(n, pcReturnType)

		#--

		def Frist2Items()
			return This.FirstNItems(2)
	
			def 2FristItems()
				return This.First2Items()
	
			def FristTwoItems()
				return This.First2Items()
	
			def TwoFristItems()
				return This.First2Items()
	
		def Frist3Items()
			return This.FirstNItems(3)
	
			def 3FristItems()
				return This.First3Items()
	
			def FristThreeItems()
				return This.First2Items()
	
			def ThreeFristItems()
				return This.First3Items()
	
		def Frist4Items()
			return This.FirstNItems(4)
	
			def 4FristItems()
				return This.First4Items()
	
			def FristFourItems()
				return This.First4Items()
	
			def FourFristItems()
				return This.First4Items()
	
		def Frist5Items()
			return This.FirstNItems(5)
	
			def 5FristItems()
				return This.First5Items()
	
			def FristFiveItems()
				return This.First5Items()
	
			def FrieFirstItems()
				return This.First5Items()
	
		def Frist6Items()
			return This.FirstNItems(6)
	
			def 6FristItems()
				return This.First6Items()
	
			def FristSixItems()
				return This.First6Items()
	
			def SixFristItems()
				return This.First6Items()
	
		def Frist7Items()
			return This.FirstNItems(7)
	
			def 7FristItems()
				return This.First7Items()
	
			def FristSevenItems()
				return This.First7Items()
	
			def SevenFristItems()
				return This.First7Items()
	
		def Frist8Items()
			return This.FirstNItems(8)
	
			def 8FristItems()
				return This.First8Items()
	
			def FristEightItems()
				return This.First8Items()
	
			def EightFristItems()
				return This.First8Items()
	
		def Frist9Items()
			return This.FirstNItems(9)
	
			def 9FristItems()
				return This.First9Items()
	
			def FristNineItems()
				return This.First9Items()
	
			def NineFristItems()
				return This.First9Items()
	
		def Frist10Items()
			return This.FirstNItems(10)
	
			def 10FristItems()
				return This.First10Items()
	
			def FristTenItems()
				return This.First10Items()
	
			def TenFristItems()
			return This.First10Items()

		#>

	  #------------------------------------#
	 #  GETTING THE LIST OF N LAST ITEMS  #
	#------------------------------------#

	def NLastItems(n)
		aContent = This.Content()
		nLen = len(aContent)
		n1 = nLen - n + 1
		n2 = nLen

		aResult = []

		for i = n1 to n2
			aResult + aContent[i]
		next

		return aResult

		#< @FunctionFluentForms

		def NLastItemsQ(n)
			return NLastItemsQR(n, :stzList)

		def NLastItemsQR(n, pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NLastItems(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastItems(n) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NLastItems(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNItems(n)
			return This.NLastItems(n)

			def LastNItemsQ(n)
				return This.NLastItemsQ(n)

			def LastNItemsQR(n, pcReturnType)
				return This.NLastItemsQR(n, pcReturnType)

		#>

		#< @FunctionSpecieficForms

		def Last2Items()
			return This.LastNItems(2)
	
			def 2LastItems()
				return This.Last2Items()
	
			def LastTwoItems()
				return This.Last2Items()
	
			def TwoLastItems()
				return This.Last2Items()
	
		def Last3Items()
			return This.LastNItems(3)
	
			def 3LastItems()
				return This.Last3Items()
	
			def LastThreeItems()
				return This.Last2Items()
	
			def ThreeLastItems()
				return This.Last3Items()
	
		def Last4Items()
			return This.LastNItems(4)
	
			def 4LastItems()
				return This.Last4Items()
	
			def LastFourItems()
				return This.Last4Items()
	
			def FourLastItems()
				return This.Last4Items()
	
		def Last5Items()
			return This.LastNItems(5)
	
			def 5LastItems()
				return This.Last5Items()
	
			def LastFiveItems()
				return This.Last5Items()
	
			def FiveLastItems()
				return This.Last5Items()
	
		def Last6Items()
			return This.LastNItems(6)
	
			def 6LastItems()
				return This.Last6Items()
	
			def LastSixItems()
				return This.Last6Items()
	
			def SixLastItems()
				return This.Last6Items()
	
		def Last7Items()
			return This.LastNItems(7)
	
			def 7LastItems()
				return This.Last7Items()
	
			def LastSevenItems()
				return This.Last7Items()
	
			def SevenLastItems()
				return This.Last7Items()
	
		def Last8Items()
			return This.LastNItems(8)
	
			def 8LastItems()
				return This.Last8Items()
	
			def LastEightItems()
				return This.Last8Items()
	
			def EightLastItems()
				return This.Last8Items()
	
		def Last9Items()
			return This.LastNItems(9)
	
			def 9LastItems()
				return This.Last9Items()
	
			def LastNineItems()
				return This.Last9Items()
	
			def NineLastItems()
				return This.Last9Items()
	
		def Last10Items()
			return This.LastNItems(10)
	
			def 10LastItems()
				return This.Last10Items()
	
			def LastTenItems()
				return This.Last10Items()
	
			def TenLastItems()
				return This.Last10Items()
	
		#>

	  #---------------------------------------------#
	 #  NEXT N ITEMS STARTING AT A GIVEN POSITION  #
	#=============================================#

	def NextNItems(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstItem
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastItem
				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfItems() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt, pnStarting + n - 1).Items()

		return acResult

		#< @FunctionFluentForm

		def NextNItemsQ(n, pnStartingAt)
			return This.NextNItemsQR(n, pnStartingAt, :stzList)

		def NextNItemsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNItems(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNItems(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNItems(n, pnStartingAt) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NextNItems(n, pnStartingAt) )

			on :stzListOfLists
				return new stzListOfLists( This.NextNItems(n, pnStartingAt) )

			on :stzListOfPairs
				return new stzListOfPairs( This.NextNItems(n, pnStartingAt) )

			on :stzListOfObjects
				return new stzListOfObjects( This.NextNItems(n, pnStartingAt) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------#

	def PreviousNItems(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstItem
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastItem
				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfItems() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt - n + 1, pnStartingAt).Items()

		return acResult


		#< @FunctionFluentForm

		def PreviousNItemsQ(n, pnStartingAt)
			return This.PreviousNItemsQR(n, pnStartingAt, :stzList)

		def PreviousNItemsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfLists
				return new stzListOfLists( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfPairs
				return new stzListOfPairs( This.PreviousNItems(n, pnStartingAt) )

			on :stzListOfObjects
				return new stzListOfObjects( This.PreviousNItems(n, pnStartingAt) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #--------------------#
	 #      UPDATING      #
	#--------------------#

	/*
	Semantic Note:
		Update	-> Assigning a hole new list to the list
		Replace	-> Replacing items or sections of items
	*/

	def Update(paNewList)
		if isList(paNewList) and Q(paNewList).IsWithOrByOrUsingNamedParam()
			paNewList = paNewList[2]
		ok

		@aContent = paNewList

		#< @FunctionFluentForm

		def UpdateQ(paNewList)
			This.Update(paNewList)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(paNewList)
			This.Update(paNewList)

			def UpdateWithQ(paNewList)
				return This.UpdateQ(paNewList)
	
		def UpdateBy(paNewList)
			This.Update(paNewList)

			def UpdateByQ(paNewList)
				return This.UpdateQ(paNewList)

		def UpdateUsing(paNewList)
			This.Update(paNewList)

			def UpdateUsingQ(paNewList)
				return This.UpdateQ(paNewList)

		#--

		def Fill(paNewList)
			This.Update(paNewList)

			def FillQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillWith(paNewList)
			This.Update(paNewList)

			def FillWithQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillBy(paNewList)
			This.Update(paNewList)

			def FillByQ(paNewList)
				return This.UpdateQ(paNewList)

		def FillUsing(paNewList)
			This.Update(paNewList)

			def FillUsingQ(paNewList)
				return This.UpdateQ(paNewList)

		#>

	def Updated(paNewList)
		return paNewList

		#< @FunctionAlternativeForms

		def UpdatedWith(paNewList)
			return This.Updated(paNewList)

		def UpdatedBy(paNewList)
			return This.Updated(paNewList)

		def UpdatedUsing(paNewList)
			return This.Updated(paNewList)

		#--

		def Filled(paNewList)
			return paNewList

		def FilledWith(paNewList)
			return paNewList
	
		def FilledBy(paNewList)
			return paNewList

		def FilledUsing(paNewList)
			return paNewList

		#>

	  #----------------------#
	 #     ADDING ITEMS     #
	#----------------------#

	def AddItem(pItem)
		@aContent + pItem

		#< @FunctionFluentForm

		def AddItemQ(pItem)
			This.AddItem(pItem)
			return This
		
		#

		#< @FunctionAlternativeForm

		def Add(pItem)
			This.AddItem(pItem)

			def AddQ(pItem)
				This.Add(pItem)
				return This

		def AppendWith(pItem)
			This.AddItem(pItem)

			def AppendWithQ(pItem)
				This.AppendWithQ(pItem)
				return This

		def Append(pItem)
			if isList(pItem) and Q(pItem).IsWithOrUsingOrByNamedParam()
				pItem = pItem[2]
			ok

			This.AddItem(pItem)

			def AppendQ(pItem)
				This.Append(pItem)
				return This

		#>

	def ItemAdded(pItem)
		aResult = This.Copy().AddItemQ(pItem).Content()
		return aResult

		def Added(pItem)
			return This.ItemAdded(pItem)

		def AppendedWith(pItem)
			return This.ItemAdded(pItem)

		def Appended(pItem)
			return This.ItemAdded(pItem)

	  #-----------------------------------------------------------#
	 #  ADDING AN ITEM AT A GIVEN POSITION --> INSERT OR EXTEND  #
	#-----------------------------------------------------------#

	def AddItemAt(n, pItem) #TODO: Test it!

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n <= This.NumberOfItems()
			This.InsertAt(n, pItem)

		else
			This.ExtendToPosition(n - 1, :With = NULL)
			This.Add(pItem)
		ok

		#< @FunctionFluentForm

		def AddItemAtQ(n, pItem)
			This.AddItem(n, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddItemAtPosition(n, pItem)
			This.AddItemAt(n, pItem)

			def AddItemAtPositionQ(n, pItem)
				This.AddItemAtPosition(n, pItem)
				return This

		def AddAt(n, pItem)
			This.AddItem(n, pItem)

			def AddAtQ(n, pItem)
				This.AddAt(n, pItem)
				return This
	
		def AddAnNthItem(n, pItem)
			This.AddItem(n, pItem)

			def AddAnNthItemQ(n, pItem)
				This.AddAnNthItem(n, pItem)
				return This

		#>

	  #---------------------------------#
	 #  ADDING MANY ITEMS TO THE LIST  #
	#---------------------------------#

	def AddMany(paItems)
		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)

		for i = 1 to nLen
			@aContent + paItems[i]
		next
	
		#< @FunctionFluentForm

		def AddManyQ(paItems)
			This.AddMany(paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def AddManyItems(paItems)
			This.AddMany(paItems)

			def AddManyItemsQ(paItems)
				This.AddManyItems(paItems)

		def AddEach(paItems)
			This.AddMany(paItems)

			def AddEachQ(paItems)
				This.AddEach(paItems)
				return This

		def AddTheseItems(paItems)
			This.AddMany(paItems)

			def AddTheseItemsQ(paItems)
				This.AddTheseItems(paItems)
				return This

		def AddThese(paItems)
			This.AddMany(paItems)

			def AddTheseQ(paItems)
				This.AddThese(paItems)
				return This
		#>

	def ManyAdded(paItems)
		aResult = This.Copy().AddManyQ(paItems).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ManyItemsAdded(paItems)
			return This.ManyAdded(paItems)

		def EachAdded(paItems)
			return This.ManyAdded(paItems)

		def EachItemAdded(paItems)
			return This.ManyAdded(paItems)

		def TheseItemsAdded(paItems)
			return This.ManyAdded(paItems)

		def TheseAdded(paItems)
			return This.ManyAdded(paItems)

		#>

	  #===================================================#
	 #     INSERTING AN ITEM BEFORE A GIVEN POSITION     #
	#===================================================#

	def Insert(pItem, pWhere)

		if isList(pItem) and Q(pItem).IsItemNamedParam()
			pItem = pItem[2]
		ok

		if isList(pWhere)
			if Q(pWhere).IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pWhere[2], pItem)
				return

			but Q(pWhere).IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pWhere[2], pItem)
				return
			ok
		else
			This.InsertBefore(pWhere, pItem)
		ok

		#< @FunctionFluentForm

		def InsertQ(pItem, pWhere)
			This.Insert( pItem, pWhere )
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertItem(pItem, pWhere)
			This.Insert(pItem, pWhere)

			def InsertItemQ(pItem, pWhere)
				This.InsertItem(pItem, pWhere)
				return This
		#>

	def InsertBeforePosition(n, pItem)
		if isList(n) and Q(n).IsPositionNamedParam()
			n = n[2]
		ok

		if isList(n) and Q(n).IsListOfNumbers()
			This.InsertBeforePositions(n, pItem)
			return
		ok

		if isList(pItem) and Q(pItem).IsItemNamedParam()
			pItem = pItem[2]
		ok

		if n >= 1 and n <= This.NumberOfItems()
			ring_insert(This.List(), n-1, pItem)

		but n > This.NumberofItems()
			This.ExtendToN(n)
			ring_insert(This.List(), n-1, pItem)
			# Using Ring native insert function here
		ok

		#< @FunctionFluentForm

		def InsertBeforePositionQ(n, pItem)
			This.InsertBeforePosition(n, pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertBefore(n, pItem)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :ItemAt, :ItemAtPosition ])
				n = n[2]
			ok

			This.InsertBeforePosition(n, pItem)

			def InsertBeforeQ(n, pItem)
				This.InsertBefore(n, pItem)
				return This

		def InsertAt(n, pItem)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :ItemAt, :ItemAtPosition ])
				n = n[2]
			ok

			This.InsertBeforePosition(n, pItem)

			def InsertAtQ(n, pItem)
				This.InsertAt(n, pItem)
				return This

		#>
		
	  #----------------------------------------------------#
	 #     INSERTING AN ITEM AFTER A GIVEN POSITION      #
	#----------------------------------------------------#

	def InsertAfterPosition(n, pItem)

		if isList(n) and Q(n).IsListOfNumbers()
			This.InsertAfterPositions(n, pItem)
			return
		ok

		if n > 0 and n < This.NumberOfItems()
			ring_insert(This.List(), n, pItem)

		ok

		#< @FunctionFluentForm

		def InserAfterPositionQ(n, pItem)
			This.InsertAfterPosition(n, pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAfter(n, pItem)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :ItemAt, :ItemAtPosition ])
				n = n[2]
			ok

			This.InsertAfterPosition(n, pItem)

			def InsertAfterQ(n, pItem)
				This.InsertAfter(n, pItem)
				return This

		#>

	#---------------------------------------#
	#TODO: Add same functions as stzString #
	#---------------------------------------#
	
	/*
	INSERTING BEFORE/AFTER THE NTH OCCURRENCE OF AN ITEM
		INSERTING BEFORE/AFTER THE FIRST OCCURRENCE OF AN ITEM
		INSERTING BEFORE/AFTER THE LAST OCCURRENCE OF AN ITEM
	
	INSERTING BEFORE THE NEXT NTH OCCURRENCE OF AN ITEM STARTING AT
		INSERTING BEFORE/AFTER THE NEXT OCCURRENCE OF AN ITEM STARTING AT
	
	INSERTING BEFORE THE PREVIOUS NTH OCCURRENCE OF AN ITEM STARTING AT
		INSERTING BEFORE/AFTER THE PREVIOUS OCCURRENCE OF AN ITEM STARTING AT
	*/

	  #--------------------------------#
	 #     OTHER INSERTING FORMS      #TODO
	#--------------------------------#

	def InsertAfterEachNumberOfSteps(n, pItem) // TODO
		/* Example : InsertAfterEachNumberOfSteps(2, "*")
		a = [ "A" , "B" , "C"  , "D" , "E" , "F" , "G" ]
		-->
		a = [ "A" , "B" , "*" , "D" , "E" , "*" , "F" , "G" ]
		*/

	def InsertAfterEachSequenceOfSteps(paSteps, pItem) // TODO
		/* Example : InsertAfterEachSequenceOfSteps([2,1], pcStr)
		a = [ "A" , "B" , "C"  , "D" , "E" , "F" , "G" ]
		-->
		a = [ "A" , "B" , "*" , "D" , "*" "E" , "F" , "*" , "G" , "*" ]
		*/

	def InsertRandomlyBefore(pItem)
		n = random( This.NumberOfItems() )
		This.InsertBefore(n, pItem)

		#< @FunctionFluentForm

		def InsertRandomlyBeforeQ(pItem)
			This.InsertRandomlyBefore(pItem)
			return This

		#>

	def InsertRandomlyAfter(pItem)
		n = random( This.NumberOfItems() )
		This.InsertAfter(n, pItem)

		#< @FunctionFluentForm

		def InsertRandomlyAfterQ(pItem)
			This.InsertRandomlyAfter(pItem)
			return This

		#>

	  #=============================================#
	 #  MOVING ITEM AT POSITION N1 TO POSITION N2  #
	#=============================================#

	def Move(n1, n2)

		# Checking params correctness

		if CheckParams()

			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([
				:From, :FromPosition,
				:At, :AtPosition,
				:Item, :ItemAt, :ItemAtPosition,
				:FromItemAt, :FromItemAtPosition,
				:ItemFrom, :ItemFromPosition
			   ])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToPosition, :ToItem, :ToItemAt,
				:ToItemAtPosition, :ToPositionOfItem ])
	
				n2 = n2[2]
			ok
	
			if isString(n1) and
			   Q(n1).IsOneOfThese([ :First, :FirstPosition, :FirstItem ])
					    
				n1 = 1
			ok
	
			if isString(n2) and
			   Q(n1).IsOneOfThese([ :Last, :LastPosition, :LastItem ])
	
				n2 = This.NumberOfItems()
			ok
	
			if NOT Q([n1, n2]).BothAreNumbers()
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

		ok

		# Doing the job

		item = @aContent[n1]
		ring_remove(@aContent, n1)
		n = n2
		if n1 > n2
			n++
		ok
		ring_insert(@aContent, n2, item)

		#< @FunctionFluentForm

		def MoveQ(n1, n2)
			This.Move(n1, n2)
			return This

		#>

	  #-------------------------------------------#
	 #  MOVING A GIVEN ITEM TO A GIVEN POSITION  #
	#-------------------------------------------#
	#NOTE
	# Only the first position of pItem in the list is moved

	def MoveItemCS(pItem, n, pCaseSensitive)
		if CheckParams()
			if isList(n) and Q(n).IsToOrToPositionNamedParam()
				n = n[2]
			ok

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		if n < 1 or n > len(@aContent)
			return
		ok

		n1 = This.FindFirstCS(pItem, pCaseSensitive)
		if n1 = 0
			return
		ok

		This.Move(n1, n)


		def MoveItemCSQ(pItem, n, pCaseSensitive)
			This.MoveItemCS(pItem, n, pCaseSensitive)
			return This

	def ItemMovedCS(pItem, n, pCaseSensitive)
		aResult = This.Copy().MoveItemCSQ(pItem, n, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def MoveItem(pItem, n)
		return This.MoveItemCS(pItem, n, TRUE)

		def MoveItemQ(pItem, n)
			This.MoveItem(pItem, n)
			return This

	  #=========================================#
	 #  SWAPPING ITEMS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedPArams([
			:Between, :BetweenPosition, :BetweenPositions,
			:BetweenItem, :BetweenItems,
			:BetweenItemAt, :BetweenItemAtPosition, :BetweenItemAtPositions,
			:Position, :Positions, :ItemAt, :ItemAtPosition, :ItemAtPositions,
			:Items, :ItemsAt, :ItemsAtPosition, :ItemsAtPositions
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedPArams([
			:And, :AndPosition, :AndItemAt, :AndItemAtPosition, :AndItem ])

			n2 = n2[2]
		ok

		copy = This[n2]
		This.ReplaceNth(n2, :By = This[n1])
		This.ReplaceNth(n1, :By = copy)

		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

		def SwapItem(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndItemAt, :AndItemAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)
		#>

	  #=========================================#
	 #   REPLACING ALL ITEMS WITH A NEW ITEM   #
	#=========================================#

	def ReplaceAllItems(pNewItem)

		for i = 1 to This.NumberOfItems()
			This.ReplaceAt(i, pNewItem)
		next

		#< @FunctionFluentForm

		def ReplaceAllItemsQ(pNewItem)
			This.ReplaceAllItems(pNewItem)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceEachItem(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachOccurrenceOfItem(pNewItem)
			This.ReplaceAllItems(pNewItem)

		#--

		def ReplaceAllItemsWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachItemWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		def ReplaceEachOccurrenceOfItemWith(pNewItem)
			This.ReplaceAllItems(pNewItem)

		#>

	  #-------------------------------------------#
	 #   REPLACING ALL OCCURRENCES OF AN ITEM    #
	#-------------------------------------------#

	def ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

		if CheckParams()

			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		for i = 1 to nLen
			This.ReplaceAnyItemAtPositionCS(anPos[i], pNewItem, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAllOccurrencesCSQ(pItem, pNewIteme, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceItemCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceItemCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceItemCS(pItem, pNewItem, pCaseSensitive)
				return This

		def ReplaceAllCS(pItem, pNewItem, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceAllCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceAllCS(pItem, pNewItem, pCaseSensitive)
				return This

		def ReplaceCS(pItem, pNewItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.ReplaceAllOccurrencesCS(pItem, pNewItem, pCaseSensitive)

			def ReplaceCSQ(pItem, pNewItem, pCaseSensitive)
				This.ReplaceCS(pItem, pNewItem, pCaseSensitive)
				return This

		#>

	def ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceItemCSQ(pItem, pNewItem, pCaseSensitive).
				Content()

		return aResult

		def AllOccurrencesOfItemReplacedByCS(pItem, pNewItem, pCaseSensitive)
			return ItemReplacedByCS(pItem, pNewItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAllOccurrences(pItem, pNewItem)
		This.ReplaceAllOccurrencesCS(pItem, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceAllOccurrencesQ(pItem, pNewIteme)
			This.ReplaceAllOccurrences(pItem, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceItem(pItem, pNewItem)
			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceItemQ(pItem, pNewItem)
				This.ReplaceItem(pItem, pNewItem)
				return This

		def ReplaceAll(pItem, pNewItem)
			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceAllQ(pItem, pNewItem)
				This.ReplaceAll(pItem, pNewItem)
				return This

		def Replace(pItem, pNewItem)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.ReplaceAllOccurrences(pItem, pNewItem)

			def ReplaceQ(pItem, pNewItem)
				This.Replace(pItem, pNewItem)
				return This

		#>

	def ItemReplacedBy(pItem, pNewItem)

		aResult =  This.Copy().
				ReplaceItemQ(pItem, pNewItem).
				Content()

		return aResult

		def AllOccurrencesOfItemReplacedBy(pItem, pNewItem)
			return ItemReplacedBy(pItem, pNewItem)


	  #----------------------------------------------#
	 #   REPLACING FIRST N OCCURRENCES OF AN ITEM   #
	#==============================================#

	def ReplaceFirstNOccurrences(n, pItem, pNewItem)
		This.ReplaceTheseOccurrences( 1 : n, pItem, pNewItem )

		def ReplaceFirstNOccurrencesQ(n, pItem, pNewItem)
			This.ReplaceFirstNOccurrences(n, pItem, pNewItem)
			return This

		def ReplaceNFirstOccurrences(n, pItem, pNewItem)
			This.ReplaceFirstNOccurrences(n, pItem, pNewItem)

			def ReplaceNFirstOccurrencesQ(n, pItem, pNewItem)
				This.ReplaceNFirstOccurrences(n, pItem, pNewItem)

	def FirstNOccurrencesReplaced(n, pItem, pNewItem)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pItem, pNewItem).Content()

		def NFirstOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

		#-- MISSPELLED

		def FristNOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

		def NFristOccurrencesReplaced(n, pItem, pNewItem)
			return This.FirstNOccurrencesReplaced(n, pItem, pNewItem)

	  #---------------------------------------------#
	 #   REPLACING LAST N OCCURRENCES OF AN ITEM   #
	#---------------------------------------------#

	def ReplaceLastNOccurrences(n, pItem, pNewItem)
		nNumberOfOccurr = This.NumberOfOccurrences(pItem)
		n1 = nNumberOfOccurr - n + 1
		This.ReplaceTheseOccurrences( n1 : nNumberOfOccurr, pItem, pNewItem )

		def ReplaceLastNOccurrencesQ(n, pItem, pNewItem)
			This.ReplaceLastNOccurrences(n, pItem, pNewItem)
			return This

		def ReplaceNLastOccurrences(n, pItem, pNewItem)
			This.ReplaceLastNOccurrences(n, pItem, pNewItem)

			def ReplaceNLastOccurrencesQ(n, pItem, pNewItem)
				This.ReplaceNLastOccurrences(n, pItem, pNewItem)

	def LastNOccurrencesReplaced(n, pItem, pNewItem)
		return This.Copy().ReplaceLastNOccurrencesQ(n, pItem, pNewItem).Content()

		def NLastOccurrencesReplaced(n, pItem, pNewItem)
			return This.LastNOccurrencesReplaced(n, pItem, pNewItem)


	  #--------------------------------------#
	 #     REPLACING MANY ITEMS AT ONCE     #
	#======================================#

	def ReplaceManyCS(paItems, pNewItem, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzList([ "a", "+", "b", "-", "c", "/", "d", "=", "0" ])
		o1.ReplaceMany( ["+", "-", "/" ], :By = "*" )
		? o1.Content()
	
		#--> [ "a", "*", "b", "*", "c", "*", "d", "=", "0" ]
	
		*/

		if CheckParams()

			if NOT isList(paItems)
				stzRaise("Incorrect param type! paItems must be a list.")
			ok
	
			if isList(pNewItem) and Q(pNewItem).IsWithOrByNamedParam()
				pNewItem = pNewItem[2]
			ok

		ok

		# Doing the job

		paItems = Q(paItems).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(paItems)
		
		for i = 1 to nLen
			This.ReplaceCS( paItems[i], pNewItem, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceAllOfTheseCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceManyItemsCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceManyItemsCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceItemsCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceItemsCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseItemsCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyCSQ(paItems, pNewItem, pCaseSensitive)

		#>

	def ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
		acResult = This.Copy().ReplaceManyItemsCSQ(paItems, pNewItem, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def ItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def TheseReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedCS(paItems, pNewItem, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(paItems, pNewItem)
		This.ReplaceManyCS( paItems, pNewItem, TRUE )

		#< @FunctionFluentFormn

		def ReplaceManyQ(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)
			return This
		#>

		#< @FunctionAlternativeForm

		def ReplaceThese(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceTheseQ(paItems, pItem)
				This.ReplaceThese(paItems, pItem)
				return This

		def ReplaceTheseItems(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceTheseItemsQ(paItems, pItem)
				This.ReplaceTheseItems(paItems, pItem)
				return This

		def ReplaceAllOfThese(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceAllOfTheseQ(paItems, pItem)
				This.ReplaceAllOfThese(paItems, pItem)
				return This

		def ReplaceManyItems(paItems, pNewItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceManyItemsQ(paItems, pNewItem)
				This.ReplaceManyItems(paItems, pNewItem)
				return This

		def ReplaceItems(paItems, pItem)
			This.ReplaceMany(paItems, pNewItem)

			def ReplaceItemsQ(paItems, pItem)
				return This.ReplaceManyQ(paItems, pNewItem)

		#>

	def ManyItemsReplaced(paItems, pNewItem)
		acResult = This.Copy().ReplaceManyItemsQ(paItems, pNewItem).Content()
		return acResult

		#< @FunctionAlternativeForms

		def TheseReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def TheseItemsReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def ManyReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		def ItemsReplaced(paItems, pNewItem)
			return This.ManyItemsReplaced(paItems, pNewItem)

		#>

	  #---------------------------------------------------#
	 #     REPLACING MANY ITEMS BY THE ITEM PRIVIDED     #
	#---------------------------------------------------#

	def ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

		if CheckParams()

			if NOT isList(paItems)
				stzRaise("Incorrect param type! paItems must be a list.")
			ok

		ok

		# Doing the job

		paItems = Q(paItems).DuplicatesRemovedCS(pCaseSensitive)
		nLen = len(paItems)
		
		for i = 1 to nLen
			This.ReplaceCS( paItems[i], pNewItem, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)
			return This
		
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceTheseItemsByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceAllOfTheseByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceAllOfTheseByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceManyItemsByCS(paItems, pNewItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceManyItemsByCSQ(paItems, pNewItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		def ReplaceItemsByCS(paItems, pItem, pCaseSensitive)
			This.ReplaceManyByCS(paItems, pNewItem, pCaseSensitive)

			def ReplaceItemsByCSQ(paItems, pItem, pCaseSensitive)
				return This.ReplaceManyByCSQ(paItems, pNewItem, pCaseSensitive)

		#>

	def ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
		acResult = This.Copy().ReplaceManyItemsByCSQ(paItems, pNewItem, pCaseSensitive).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		def ItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)
			return This.ManyItemsReplacedByCS(paItems, pNewItem, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceManyBy(paItems, pNewItem)
		This.ReplaceManyByCS( paItems, pNewItem, TRUE )

		#< @FunctionFluentFormn

		def ReplaceManyByQ(paItems, pItem)
			This.ReplaceManyBy(paItems, pNewItem)
			return This
		#>

		#< @FunctionALternativeForms

		def ReplaceTheseBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceTheseByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceTheseItemsBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceTheseItemsByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceAllOfTheseBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceAllOfTheseByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceManyItemsBy(paItems, pNewItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceManyItemsByQ(paItems, pNewItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		def ReplaceItemsBy(paItems, pItem)
			This.ReplaceManyBy(paItems, pNewItem)

			def ReplaceItemsByQ(paItems, pItem)
				return This.ReplaceManyByQ(paItems, pNewItem)

		#>

	def ManyItemsReplacedBy(paItems, pNewItem)
		acResult = This.Copy().ReplaceManyItemsByQ(paItems, pNewItem).Content()
		return acResult

		#< @FunctionAlternativeForms

		def ManyReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		def ItemsReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		def TheseItemsReplacedBy(paItems, pNewItem)
			return This.ManyItemsReplacedBy(paItems, pNewItem)

		#>

	  #---------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY ITEMS  #
	#---------------------------------------#

	def ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ruby", "ring", "python", "ring" ])
		o1.ReplaceByMany("ring", [ "", "", "" ])
	
		? o1.Content() #--> [ "", "php", "ruby", "", "python", "" ]

		*/

		anPos = This.FindCS(pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemByManyCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByManyCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByManyCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByManyCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseCS(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCS(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseCSQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSQ(pItem, paNewItems, pCaseSensitive).Conten()
		return cResult

		#< @FunctionAlternativeForms

		def ItemReplacedByManyCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ReplacedByTheseItemsCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplaceByManyCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplaceByTheseCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByTheseItemsCS(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCS(pItem, paNewItems, pCaseSensitive)

		#>

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pItem, paNewItems)
		This.ReplaceByManyCS(pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceByManyQ(pItem, paNewItems)
			return This.ReplaceByManyCSQ(pItem, paNewItems, TRUE)

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByMany(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceItemByManyQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceItemByThese(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceItemByTheseQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceThisItemByMany(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceThisItemByManyQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		def ReplaceThisItemByThese(pItem, paNewItems)
			This.ReplaceByMany(pItem, paNewItems)

			def ReplaceThisItemByTheseQ(pItem, paNewItems)
				return This.ReplaceByManyQ(pItem, paNewItems)

		#>

	#< @FunctionPassiveForms

	def ReplacedByMany(pItem, paNewItems)
		return This.ReplacedByManyCS(pItem, paNewItems, TRUE)

		#< @FunctionAlternativeForms

		def ItemReplacedByMany(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ReplacedByTheseItems(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplaceByMany(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ItemReplacedByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplaceByThese(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		def ThisItemReplacedByTheseItems(pItem, paNewItems)
			return This.ReplacedByMany(pItem, paNewItems)

		#>

	#>

	  #---------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY ITEMS -- EXTENDED (RETURN TO FIRST)  #
	#---------------------------------------------------------------------#

	def ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "ring" ])
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> [ "#1", "php", "#2", "ruby", "#1", "python", "#2" ]

		*/

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCSXT(anPos, pItem, paNewItems, pCaseSensitive)


		#< @FunctionFluentForm

		def ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByManyCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByManyCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByTheseCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceItemByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceItemByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		def ReplaceThisByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			This.ReplaceByManyCSXT(pItem, paNewItems, pCaseSensitive)

			def ReplaceThisByTheseItemsCSXTQ(pItem, paNewItems, pCaseSensitive)
				return This.ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceByManyCSXTQ(pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ThisItemReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ItemReplacedByTheseItemsCSXT(pItem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ReplacedByThesesCSXT(pITem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

		def ReplacedByThesesItemsCSXT(pITem, paNewItems, pCaseSensitive)
			return This.ReplacedByManyCSXT(pItem, paNewItems, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pItem, paNewItems)
		This.ReplaceByManyCSXT(pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceByManyXTQ(pItem, paNewItems)
			return This.ReplaceByManyCSXTQ(pItem, paNewItems, TRUE)

		#>

		#< @FunctionAlternativeForm

		def ReplaceItemByManyXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByManyXT(pItem, paNewItems)
			This.ReplaceByManyCXT(pItem, paNewItems)

			def ReplaceThisItemByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByManyXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByManyXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceItemByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisItemByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByTheseXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByTheseXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceItemByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceItemByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisItemByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisItemByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		def ReplaceThisByTheseItemsXT(pItem, paNewItems)
			This.ReplaceByManyXT(pItem, paNewItems)

			def ReplaceThisByTheseItemsXTQ(pItem, paNewItems)
				return This.ReplaceByManyXTQ(pItem, paNewItems)

		#>

	#< @FunctionPassiveForms

	def ReplacedByManyXT(pItem, paNewItems)
		cResult = This.Copy().ReplaceByManyXTQ(pItem, paNewItems).Content()
		return cResult

		def ItemReplacedByManyXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ThisItemReplacedByManyXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ItemReplacedByTheseXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ItemReplacedByTheseItemsXT(pItem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ReplacedByThesesXT(pITem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

		def ReplacedByThesesItemsXT(pITem, paNewItems)
			return This.ReplacedByManyXT(pItem, paNewItems)

	#>

	  #--------------------------------------------#
	 #  REPLACING MANY ITEMS BY MANY OTHER ITEMS  #
	#--------------------------------------------#

	def ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "ring" ])
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "", "", "" ])

		? o1.Content() #--> [ "", "qt", "", "pyhton", "", "csharp", "" ]
		*/

		if CheckParams()
	
			if isList(paNewItems) and Q(paNewItems).IsWithOrByNamedParam()
				paNewItems = paNewItems[2]
			ok

		ok

		# Doing the job

		paItems = StzListQ(paItems).WithoutDuplication()	
		nLenItems = len(paItems)
		nLenNewItems = len(paNewItems)

		if NOT ( nLenItems = nLenNewItems )
			StzRaise("Incorrect values! nLenItems and nLenNewItems must have the same size.")
		ok

		for i = 1 to nLenItems
			This.ReplaceCS(paItems[i], paNewItems[i], pCaseSensitive)
		next


		#< @FunctionFluentForm

		def ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByManyCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseItemsCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		#--

		def ReplaceTheseByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceTheseItemsByTheseCS(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCS(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsByTheseCSQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive)

		#>

	#< @FunctionPassiveForm

	def ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSQ(paItems, paNewItems, pCaseSensitive).Content()
		return cResult

		def ItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseItemsCS(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(paItems, paNewItems)
		This.ReplaceManyByManyCS(paItems, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceManyByManyQ(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByMany(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByManyQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		def ReplaceManyItemsByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByTheseQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseItems(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceManyItemsByTheseItemsQ(paItems, paNewItems)
				return This.ReplaceManyByManyQ(paItems, paNewItems)

		#--

		def ReplaceTheseByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceTheseByTheseQ(paItems, paNewItems)
				This.ReplaceTheseByThese(paItems, paNewItems)
				return This

		def ReplaceTheseItemsByThese(paItems, paNewItems)
			This.ReplaceManyByMany(paItems, paNewItems)

			def ReplaceTheseItemsByTheseQ(paItems, paNewItems)
				This.ReplaceTheseByThese(paItems, paNewItems)
				return This

		#>

	#< @FunctionPassiveForm

	def ManyItemsReplacedByMany(paItems, paNewItems)
		cResult = This.Copy().ReplaceManyByManyQ(paItems, paNewItems).Content()
		return cResult

		def ItemsReplacedByMany(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def TheseItemsReplacedByThese(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def ItemsReplacedByThese(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def TheseItemsReplacedByTheseItems(paItems, paNewItems)
			return This.ManyItemsReplacedByMany(paItems, paNewItems)

		def ItemsReplacedByTheseItems(paItems, paNewItems)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems)

	#>

	  #--------------------------------------------------#
	 #  REPLACING MANY ITEMS BY MANY OTHER ITEMS -- XT  #
	#--------------------------------------------------#
	# XT ~> Return to beginning if all the other items are replaced

	def ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)
		#TODO: Add "These" as alternatibe of "Many"

		/* EXAMPLE

		o1 = new stzList(["ring", "qt", "softanza", "pyhton", "kandaji", "csharp", "zai" ])
		o1.ReplaceManyByManyXT([ "ring", "softanza", "kandaji", "zai" ], :By = [ "", "" ])
		
		? o1.Content()
		#--> [ "", "qt", "", "pyhton", "", "csharp", "" ]

		*/

		if CheckParams()
	
			if isList(paNewItems) and Q(paNewItems).IsWithOrByNamedParam()
				paNewItems = paNewItems[2]
			ok

		ok

		# Doing the job

		aItems = StzListQ(paItems).WithoutDupplication()
		nLenItems = len(paItems)
		nLenNewItems = len(paNewItems)

		# Extending or shrinking aNewItems, if necessary, so it has
		# the same size as aItems

		if nLenNewItems < nLenItems
			aNewItems = paNewItems
			n = 0
			for i = nLenNewItems + 1 to nLenItems # ~> for i = 2 to 4
				n++
				if n > nLenNewItems
					n = 1
				else
					aNewItems + paNewItems[n]
				ok
			next
		else
			aNewItems = []
			for i = 1 to nLenItems
				aItems + paNewItems[i]
			next
		ok

		# Calling the normal function

		This.ReplaceManyByManyCS(aItems, aNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByManyCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceManyItemsByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceManyItemsByTheseItemsCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		#--

		def ReplaceTheseByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		def ReplaceTheseItemsByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			This.ReplaceManyByManyCSXT(paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsByTheseCSXTQ(paItems, paNewItems, pCaseSensitive)
				return This.ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive)

		#>

	#< @FunctionPassiveForm

	def ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceManyByManyCSXTQ(paItems, paNewItems, pCaseSensitive).Content()
		return cResult

		def ItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

		def TheseItemsReplacedByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCS(paItems, paNewItems, pCaseSensitive)

		def ItemsReplacedByTheseItemsCSXT(paItems, paNewItems, pCaseSensitive)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems, pCaseSensitive)

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByManyXT(paItems, paNewItems)
		This.ReplaceManyByManyCSXT(paItems, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceManyByManyXTQ(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceManyItemsByManyXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByManyXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByTheseXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		def ReplaceManyItemsByTheseItemsXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceManyItemsByTheseItemsXTQ(paItems, paNewItems)
				return This.ReplaceManyByManyXTQ(paItems, paNewItems)

		#--

		def ReplaceTheseByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceTheseByTheseXTQ(paItems, paNewItems)
				This.ReplaceTheseByTheseXT(paItems, paNewItems)
				return This

		def ReplaceTheseItemsByTheseXT(paItems, paNewItems)
			This.ReplaceManyByManyXT(paItems, paNewItems)

			def ReplaceTheseItemsByTheseXTQ(paItems, paNewItems)
				This.ReplaceTheseByTheseXT(paItems, paNewItems)
				return This

		#>

	#< @FunctionPassiveForm

	def ManyItemsReplacedByManyXT(paItems, paNewItems)
		cResult = This.Copy().ReplaceManyByManyXTQ(paItems, paNewItems).Content()
		return cResult

		def ItemsReplacedByManyXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def TheseItemsReplacedByTheseXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def ItemsReplacedByTheseXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def TheseItemsReplacedByTheseItemsXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyXT(paItems, paNewItems)

		def ItemsReplacedByTheseItemsXT(paItems, paNewItems)
			return This.ManyItemsReplacedByManyCSXT(paItems, paNewItems)

	#>

	  #---------------------------------------------------------------#
	 #  REPLACING ANY ITEM AT POSITION N WITH THE NEW ITEM PROVIDED  #
	#===============================================================#

	def ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)
		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		@aContent[n] = pNewItem

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAtCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceItemAtCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceItemAtCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceItemAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceItemAtPositionCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceAnyItemAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyItemAtPositionCSQ(n, pNewItem, pCaseSensitive)
				This.ReplaceAnyItemAtPositionCS(n, pNewItem, pCaseSensitive)
				return This

		def ReplaceAnyAtPositionCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionCSQ(n, pNewItem, pCaseSensitive)

		#--

		def ReplaceAnyAtCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyAtCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)

		def ReplaceAnyAtPositionNCS(n, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionNCS(n, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionNCSQ(n, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemAtPositionNCSXTQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	def AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionNCSQ(n, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemAtPositionReplacedCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		def AnyReplacedAtPositionCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		def AnyItemReplacedAtPositionCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		#--

		def AnyItemAtReplacedCS(n, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionNReplacedCS(n, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionN(n, pNewItem)
		return This.ReplaceAnyItemAtPositionNCS(n, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionNQ(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAt(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAtQ(n, pNewItem)
				This.ReplaceAt(n, pNewItem)
				return This

		def ReplaceItemAt(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceItemAtQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceItemAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceItemAtPositionQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceAnyItemAt(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyItemAtQ(n, pNewItem)
				This.ReplaceAnyItemAt(n, pNewItem)
				return This

		def ReplaceAnyItemAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyItemAtPositionQ(n, pNewItem)
				This.ReplaceAnyItemAtPosition(n, pNewItem)
				return This

		def ReplaceAnyAtPosition(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyAtPositionQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionQ(n, pNewItem)

		#--

		def ReplaceAnyAt(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyAtQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNQ(n, pNewItem)

		def ReplaceAnyAtPositionN(n, pNewItem)
			This.ReplaceAnyItemAtPositionN(n, pNewItem)

			def ReplaceAnyAtPositionNQ(n, pNewItem)
				return This.ReplaceAnyItemAtPositionNXTQ(n, pItem, pNewItem)

		#>

	#< @FunctionPassiveForms

	def AnyItemAtPositionNReplaced(n, pNewItem)
		cResult = This.Copy().ReplaceAnyItemAtPositionNQ(n, pNewItem)
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemAtPositionReplaced(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		def AnyReplacedAtPosition(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		def AnyItemReplacedAtPosition(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		#--

		def AnyItemAtReplaced(n, pNewItem)
			return This.AnyItemAtPositionNReplaced(n, pNewItem)

		#>

	#>

	  #-----------------------------------------------------------------------#
	 #  REPLACING ANY ITEMS AT THE GIVEN POSITIONS BY THE NEW ITEM PROVIDED  #
	#-----------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)
		if CheckParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		nLen = len(panPos)

		for i = 1 to nLen
			@aContent[ panPos[i] ] = pNewItem
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
				return This

		def ReplaceAnyAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAnyAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		def ReplaceAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				This.ReplaceAtPositionsCS(panPos, pNewItem, pCaseSensitive)
				return This

		def ReplaceItemsAtCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceItemsAtCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		def ReplaceItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsCS(panPos, pNewItem, pCaseSensitive)

			def ReplaceItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
				return This.ReplaceAnyItemsAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)

		#>

	#< @FunctionPassiveForm

	def AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsCSQ(panPos, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		def ReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		def ItemsReplacedAtPositionsCS(panPos, pNewItem, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedCS(panPos, pNewItem, pCaseSensitive)

		#>
	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositions(panPos, pNewItem)
		return This.ReplaceAnyItemAtPositionsCS(panPos, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsQ(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAnyItemsAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)
				This.ReplaceAnyItemsAtPositions(panPos, pNewItem)
				return This

		def ReplaceAnyAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAnyAtPositionsQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		def ReplaceAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemAtPositions(panPos, pNewItem)

			def ReplaceAtPositionsQ(panPos, pNewItem)
				This.ReplaceAtPositions(panPos, pNewItem)
				return This

		def ReplaceItemsAt(panPos, pNewItem)
			This.ReplaceAnyItemsAtPositions(panPos, pNewItem)

			def ReplaceItemsAtQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		def ReplaceItemsAtPositions(panPos, pNewItem)
			This.ReplaceAnyItemsAtPositions(panPos, pNewItem)

			def ReplaceItemsAtPositionsQ(panPos, pNewItem)
				return This.ReplaceAnyItemsAtPositionsQ(panPos, pNewItem)

		#>

	#< @FunctionPassiveForm

	def AnyItemAtPositionsReplaced(panPos, pNewItem)
		cResult = This.Copy().ReplaceAnyItemAtPositionsQ(panPos, pNewItem)
		return cResult

		#< @FunctionAlternativeform

		def AnyItemReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		def ReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		def ItemsReplacedAtPositions(panPos, pNewItem)
			return This.AnyItemAtPositionsReplaced(panPos, pNewItem)

		#>
	#>

	  #------------------------------------------------------------------#
	 #  REPLACING A GIVEN ITEM (IF IT EXISTS) AT THE GIVEN POSITION(S)  #
	#==================================================================#

	def ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)

		if isNumber(n)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

		but isList(n) and @IsListOfNumbers(n)
			This.ReplaceThisItemAtPositionsCS(n, pItem, pNewItem, pCaseSensitive)

		else
			StzRaise("Incorrect param type! n must be a number or list of numbers.")
		ok

		#< @FunctionFluentForm

		def ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisAtCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisNthItemCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceItemAtCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisNthItemCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceThisItemAtCSQ(n, pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ThisReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisNthItemReplacedCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemReplacedAtCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAt(n, pItem, pNewItem)
		This.ReplaceThisItemAtCS(n, pItem, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceThisItemAtQ(n, pItem, pNewItem)
			This.ReplaceThisItemAt(n, pItem, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisAt(n, pItem, pNewItem)
			This.ReplaceThisItemAt(n, pItem, pNewItem)

			def ReplaceThisAtQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtQ(n, pItem, pNewItem)

		def ReplaceThisNthItem(n, pItem, pNewItem)
			This.ReplaceItemAt(n, pItem, pNewItem)

			def ReplaceThisNthItemQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtQ(n, pItem, pNewItem)

		#>

	#-- @FunctionPassiveForm

	def ThisItemReplacedAt(n, pItem, pNewItem)
		return This.ThisItemReplacedAtCS(n, pItem, pNewItem, TRUE)

		#< @FunctionAlternativeForms

		def ThisReplacedAt(n, pItem, pNewItem)
			return This.ThisItemReplacedAt(n, pItem, pNewItem)

		def ThisNthItemReplaced(n, pItem, pNewItem)
			return This.ThisItemReplacedAt(n, pItem, pNewItem)

		#>

	  #--------------------------------------------------------#
	 #  REPLACING AN ITEM IF IT EXISTS AT THE GIVEN POSITION  #
	#========================================================#

	def ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			if isList(pNewItem) and Q(pNewItem).IsByOrWithOrUsingNamedParam()
				pNewItem = pNewItem[2]
			ok
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		if len(anPos) > 0 and ring_find(anPos, n) > 0
			@aContent[n] = pNewItem
		ok

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisItemAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisItemAtPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		#--

		def ReplaceThisItemAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisItemAtThisPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtThisPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		def ReplaceThisAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, pCaseSensitive)

			def ReplaceThisAtThisPositionNCSQ(n, pItem, pNewItem, pCaseSensitive)
				return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)

		#>

	#< @FunctionPassiveForms

	def ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeForms

		def ThisItemReplacedAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#--

		def ThisItemAtThisPositionReplacedCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtThisPositionCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisItemReplacedAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		def ThisReplacedAtThisPositionNCS(n, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionNReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAtPosition(n, pItem, pNewItem)
		This.ReplaceThisItemAtPositionCS(n, pItem, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionQ(n, pItem, pNewItem)
			return This.ReplaceThisItemAtPositionCSQ(n, pItem, pNewItem, TRUE)

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisItemAtPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisItemAtPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtPosition(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtPositionQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		#--

		def ReplaceThisItemAtThisPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisItemAtThisPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtThisPosition(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtThisPositionQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		def ReplaceThisAtThisPositionN(n, pItem, pNewItem)
			This.ReplaceThisItemAtPosition(n, pItem, pNewItem)

			def ReplaceThisAtThisPositionNQ(n, pItem, pNewItem)
				return This.ReplaceThisItemAtPositionQ(n, pItem, pNewItem)

		#>

	#< @FunctionPassiveForms

	def ThisItemAtPositionNReplaced(n, pItem, pNewItem)
		cResult = This.Copy().ReplaceThisItemAtPositionNCSQ(n, pItem, pNewItem, TRUE).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ThisItemReplacedAtPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		#--

		def ThisItemAtThisPositionReplaced(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtThisPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtThisPosition(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisItemReplacedAtThisPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		def ThisReplacedAtThisPositionN(n, pItem, pNewItem)
			return This.ThisItemAtPositionNReplaced(n, pItem, pNewItem)

		#>

	#>
			
	  #-----------------------------------------------------------------------------------------#
	 #   REPLACING A GIVEN ITEM AT THE GIVEN POSITIONS (IF THE ITEM EXIST) BY AN OTHER ITEM    #
	#-----------------------------------------------------------------------------------------#

	def ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzList([ "ring", "ruby", "ring", "php", "ring" ])
		o1.ReplaceThisItemAtPositions([ 1, 5 ], "ring", :By = "")

		? o1.Content()
		#--> [ "", "ruby", "ring", "php", "" ]
		*/

		if CheckParams()
			if NOT (isList(panPos) and Q(panPos).IsListOfNumbers())
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			
			if isList(pNewItem)

				oNewItem = StzListQ(pNewItem)

				if oNewItem.IsOneOfTheseNamedParams([ :ByMany, :WithMany, :UsingMany ])
					This.ReplaceThisItemAtPositionsByManyCS(panPos, pItem, pNewItem[2], pCaseSensitive)
					return

				but oNewItem.IsOneOfTheseNamedParams([ :ByManyXT, :WithManyXT, :UsingManyXT ])
					This.ReplaceThisItemAtPositionsByManyCSXT(panPos, pItem, pNewItem[2], pCaseSensitive)
					return

				but oNewItem.IsByOrWithOrUsingNamedParam()
					pNewItem = pNewItem[2]
				ok
			ok

		ok

		nLen = len(panPos)
		anPosAll = This.FindAllCS(pItem, pCaseSensitive)
		
		anPos = []

		for i = 1 to nLen
			if ring_find(anPosAll, panPos[i])
				@aContent[ panPos[i] ] = pNewItem
			ok
		next

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive)
			This.ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)
			return This

		#>

	def ThisItemAtPositionsReplacedCS(panPos, pItem, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceThisItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositionsCS(panPos, pItem, pNewItem, pCaseSensitive)
			return This.ThisItemAtPositionsReplacedCS(n, pItem, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisItemAtPositions(panPos, pItem, pNewItem)
		This.ReplaceThisItemAtPositionsCS(panPos, pItem, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceThisItemAtPositionsQ(panPos, pItem, pNewItem)
			This.ReplaceThisItemAtPositions(panPos, pItem, pNewItem)
			return This

		#>

	def ThisItemAtPositionsReplaced(panPos, pItem, pNewItem)
		cResult = This.Copy().ReplaceThisItemAtPositionsQ(panPos, pItem, pNewItem)
		return cResult

		#< @FunctionAlternativeform

		def ThisItemReplacedAtPositions(panPos, pItem, pNewItem)
			return This.ThisItemAtPositionsReplaced(n, pItem, pNewItem)

		#>

	  #--------------------------------------------------------------------------------------#
	 #   REPLACING THE GIVEN ITEMS AT THE GIVEN POSITIONS (IF THEY EXIST) BY AN OTHER ITEM  #
	#--------------------------------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "ruby", "softanza", "ring", "php", "softanza" ])
		o1.ReplaceTheseItemsAtPositions([ 1, 3, 4, 5 ], [ "ring", "softanza" ] , :By = "")
		
		? o1.Content()
		#--> [ "", "ruby", "", "", "php", "softanza" ]

		*/

		if CheckParams()
			if NOT (isList(panPos) and Q(panPos).IsListOfNumbers())
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(pNewItem)
				oNewItem = StzListQ(pNewItem)

				if oNewItem.IsOneOfTheseNamedParams([ :ByMany, :WithMany, :UsingMany ])
					This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
					return

				but oNewItem.IsOneOfTheseNamedParams([ :ByManyXT, :WithManyXT, :UsingManyXT ])
					This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
					return

				but oNewItem.IsByOrWithOrUsingNamedParam()
					pNewItem = pNewItem[2]
				ok
			ok

		ok

		nLen = len(panPos)
		anPosAll = This.FindManyCS(paItems, pCaseSensitive)
		
		anPos = []

		for i = 1 to nLen
			if ring_find(anPosAll, panPos[i])
				@aContent[ panPos[i] ] = pNewItem
			ok
		next

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsCSQ(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This

		#>

	def TheseItemsAtPositionsReplacedCS(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsCSQ(panPos, paItems, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeform

		def TheseItemsReplacedAtPositionsCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedCS(n, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositions(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsCS(panPos, paItems, pNewItem, TRUE)

	def TheseItemsAtPositionsReplaced(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsQ(panPos, paItems, pNewItem)
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositions(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplaced(n, paItems, pNewItem)

		#>

	  #---------------------------------------------------------------#
	 #   REPLACING ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS  #
	#---------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ "ring", "ruby", "softanza", "ring", "php", "softanza" ])
		o1.ReplaceTheseItemsAtPositionsByMany([ 1, 3, 4, 6 ], [ "ring", "softanza" ] , [ "", "" ])
				
		? @@( o1.Content() )
		#--> [ "", "ruby", "", "", "php", "" ]

		*/

		if CheckParams()
			if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(paNewItems) and Q(paNewItems).IsRespectivelyNamedParam()
				This.ReplaceTheseItemsAtPositionsByManyRespectivelyCS(panPos, paItems, paNewItems[2], pCaseSensitive)
				return
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return
		ok

		# Doing the job

		nLenItems = len(paItems)

		for i = 1 to nLenItems
			This.ReplaceTheseItemAtPositionsByManyCS(panPos, paItems[i], paNewItems, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseCS(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)

			def ReplaceTheseItemsAtPositionsByTheseCSQ(panPos, paItems, paNewItems, pCaseSensitive)
				This.ReplaceTheseItemsAtPositionsByTheseCS(panPos, paItems, paNewItems, pCaseSensitive)
				return This

		#>

	def TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyCSQ(panPos, paItems, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeform

		def TheseItemsReplacedAtPositionsByManyCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#--

		def TheseItemsAtPositionsReplacedByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedAtPositionsByTheseCS(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCS(n, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositionsByMany(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, pNewItem, TRUE)

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByThese(panPos, paItems, paNewItems)
			This.ReplaceTheseItemsAtPositionsByMany(panPos, paItems, paNewItems)

			def ReplaceTheseItemsAtPositionsByTheseQ(panPos, paItems, paNewItems)
				This.ReplaceTheseItemsAtPositionsByThese(panPos, paItems, paNewItems)
				return This

		#>

	def TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyQ(panPos, paItems, pNewItem)
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByMany(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(n, paItems, pNewItem)

		#--

		def TheseItemsAtPositionsReplacedByThese(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(panPos, paItems, pNewItem)

		def TheseItemsReplacedAtPositionsByThese(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByMany(n, paItems, pNewItem)

		#>
/*
def replaceany()

ReplaceThisItem() VS ReplaceItem()
Item and then position
*/
	  #----------------------------------------------------------------------------------------#
	 #   REPLACING ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- XT (RESTART AT FIRST)  #
	#----------------------------------------------------------------------------------------#

	def ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([
			"ring", "ruby", "softanza",
			"ring", "ring", "php",
			"softanza", "ring", "softanza"
		])
		
		o1.ReplaceTheseItemsAtPositionsByManyXT( [ 1, 4, 5, 8, 9 ],
			[ "ring", "softanza" ], [ "", "" ] )
						
		? @@( o1.Content() )
		#       1    2       3     4    5     6      7    8     9
		#--> [ "", "ruby", "", "", "", "php", "", "", "" ]
		#	^                  ^    ^                 ^
		#                    ^                       ^          ^

		*/

		if CheckParams()
			if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok

			if isList(paNewItems) and Q(paNewItems).IsRespectivelyNamedParam()
				This.ReplaceTheseItemsAtPositionsByManyRespectivelyCS(panPos, paItems, paNewItems[2], pCaseSensitive)
				return
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceTheseItemsAtPositionsByManyCS(panPos, paItems, paNewItems, pCaseSensitive)
			return
		ok

		# Doing the job

		nLenItems = len(paItems)

		for i = 1 to nLenItems
			This.ReplaceThisItemAtPositionsByManyCSXT(panPos, paItems[i], paNewItems, pCaseSensitive)
		next


		#< @FunctionFluentForm

		def ReplaceThisItemsAtPositionsByManyCSXTQ(panPos, paItems, paNewItems, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)

			def ReplaceTheseItemsAtPositionsByTheseCSXTQ(panPos, paItems, pNewItem, pCaseSensitive)
				This.ReplaceTheseItemsAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
				return This
		#>


	def TheseItemsAtPositionsReplacedByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyCSXTQ(panPos, paItems, pNewItem, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(n, paItems, pNewItem, pCaseSensitive)

		#--

		def TheseItemsAtPositionsReplacedByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(panPos, paItems, pNewItem, pCaseSensitive)

		def TheseItemsReplacedAtPositionsByTheseCSXT(panPos, paItems, pNewItem, pCaseSensitive)
			return This.TheseItemsAtPositionsReplacedByManyCSXT(n, paItems, pNewItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)
		This.ReplaceTheseItemsAtPositionsByManyCSXT(panPos, paItems, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceTheseItemsAtPositionsByManyXTQ(panPos, paItems, pNewItem)
			This.ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseItemsAtPositionsByTheseXT(panPos, paItems, pNewItem)
			This.ReplaceTheseItemsAtPositionsByManyXT(panPos, paItems, pNewItem)

			def ReplaceTheseItemsAtPositionsByTheseXTQ(panPos, paItems, pNewItem)
				This.ReplaceTheseItemsAtPositionsByTheseXT(panPos, paItems, pNewItem)
				return This
		#>

	def TheseItemsAtPositionsReplacedByManyXT(panPos, paItems, pNewItem)
		cResult = This.Copy().ReplaceTheseItemsAtPositionsByManyXTQ(panPos, paItems, pNewItem)
		return cResult

		#< @FunctionAlternativeforms

		def TheseItemsReplacedAtPositionsByManyXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(n, paItems, pNewItem)

		#--

		def TheseItemsAtPositionsReplacedByTheseXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(panPos, paItems, pNewItem)

		def TheseItemsReplacedAtPositionsByTheseXT(panPos, paItems, pNewItem)
			return This.TheseItemsAtPositionsReplacedByManyXT(n, paItems, pNewItem)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #   REPLACING ANY ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- XT (RESTART AT FIRST)  #
	#--------------------------------------------------------------------------------------------#

	def ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([
			"ring", "ruby", "softanza",
			"ring", "ring", "php",
			"softanza", "ring", "softanza"
		])
		
		o1.ReplaceAnyItemsAtPositionsByManyXT( [ 1, 4, 5, 8, 9 ], [ "", "" ] )
						
		? @@( o1.Content() )
		#       1    2       3     4    5     6      7          8     9
		#--> [ "", "ruby", "", "", "", "php", "softanza", "", "" ]
		#	^                  ^    ^                        ^    ^

		*/

		if CheckParams()
			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early check

		nLenNewItems = len(paNewItems)

		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			return
		ok

		# Computing nPos and aNewItems

		anPos = @WithoutDuplicates(panPos)
		nLenPos = len(anPos)

		aNewItems = []

		if nLenNewItems >= nLenPos
 			anNewItems = Q(paNewItems).Section(1, nLenPos)
		else
			aNewItems = paNewItems
			n = 0
			for j = 1 to nLenPos - nLenNewItems
				n++
				if n > nLenNewItems
					n = 1
				ok

				aNewItems + paNewItems[n]
			next
		ok

		# Doing the replacement

		for i = 1 to nLenPos
			This.ReplaceAnyItemAtPositionCS(anPos[i], aNewItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceanyItemsAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceanyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceanyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAtByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		#--

		def ReplaceItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceItemsAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		#>

	def AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemsAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemsReplacedAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemsAtPositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemsReplacedAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemsAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemsAtPositionsByManyXT(panPos, paNewItems)
		This.ReplaceAnyItemsAtPositionsByManyCSXT(panPos, paNewItems, TRUE)

		#< @FunctionAlternativeForm

		def ReplaceAnyItemsAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceanyItemsAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceanyItemsAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByManyXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtPositionsByManyXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByManyXT(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAtByManyXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtByManyXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByManyXT(panPos, paNewItems)
				return This

		def ReplaceAtByTheseXT(panPos, paNewItems)
			This.ReplaceanyItemsAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAtByTheseXTQ(panPos, paNewItems)
				This.ReplaceAtPositionsByTheseXT(panPos, paNewItems)
				return This

		#>

	def AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)
		cResult = This.Copy().ReplaceAnyItemsAtPositionsByManyXTQ(panPos, paNewItems)
		return cResult

		#< @FunctionAlternativeforms

		def AnyItemsReplacedAtPositionsByManyXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(n, paNewItems)

		#--

		def AnyItemsAtPositionsReplacedByTheseXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemsReplacedAtPositionsByTheseXT(panPos, paNewItems)
			return This.AnyItemsAtPositionsReplacedByManyXT(panPos, paNewItems)

		#>

	  #---------------------------------------------------------------#
	 #   REPLACING AN ITEM AT GIVEN POSITIONS BY MANY OTHER ITEMS    #
	#===============================================================#

	def ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceItemAtPositionsByMany([ 3, 5, 7], "ring", :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! panNewItems must be a list.")
			ok

		ok

		# Early check

		nLenItems = len(paNewItems)

		if nLenItems = 0
			return
		ok

		# Managing the positions

		anPosItem = This.FindAllCS(pItem, pCaseSensitive)
		anPos = @Intersection([ panPos, anPosItem ])
		nLen = len(anPos)

		# Doing the job

		for i = 1 to nLen
			@aContent[ anPos[i] ] = paNewItems[i]
		next

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtThesePositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#--

		def ReplaceItemAtPositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtPositionsByTheseCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtPositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		def ReplaceItemAtThesePositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByTheseCSQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceItemAtThesePositionsByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceItemAtPositionsByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ItemAtPositionsReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtThesePositionsReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)
		This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyQ(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByMany(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByManyQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtThesePositionsByMany(panPos, pItem, paNewItems)
				return This

		#--

		def ReplaceItemAtPositionsByThese(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtPositionsByTheseQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtPositionsByThese(panPos, pItem, paNewItems)
				return This

		def ReplaceItemAtThesePositionsByThese(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByMany(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByTheseQ(panPos, pItem, paNewItems)
				This.ReplaceItemAtThesePositionsByThese(panPos, pItem, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceItemAtPositionsByManyQ(panPos, pItem, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByMany(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		#--

		def ItemAtPositionsReplacedByThese(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		def ItemAtThesePositionsReplacedByThese(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByMany(panPos, pItem, paNewItems)

		#>

	  #------------------------------------------------------------------#
	 #  REPLACING THE ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS  #
	#------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceAnyItemsAtPositionsByMany([ 3, 5, 7], :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Keeping only the adequate number of positions and new items
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new items

		nMin = Min([ len(panPos), len(paNewItems) ])

		anPos = Q(panPos).SectionQ(1, nMin).SortedInDescending()
		aNewItems   = Q(paNewItems).SectionQ(1, nMin).SortedInDescending()

		# Doing the job

		for i = 1 to nMin
			This.ReplaceAnyItemAtPositionNCS(anPos[i], aNewItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAtByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByManyCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByManyCS(panPos, paNewItems, pCaseSensitive)
				return This

		#--	

		def ReplaceAnyItemsAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtPositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByTheseCSQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByTheseCS(panPos, paNewItems, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyCSQ(panPos, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemsAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemAtThesePositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtPositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByTheseCS(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtThesePositionsReplacedByManyCS(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
		This.ReplaceAnyItemAtPositionsByManyCS(panPos, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyQ(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAtByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAtByManyQ(panPos, paNewItems)
				This.ReplaceAtByManyCS(panPos, paNewItems)
				return This

		def ReplaceAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAtPositionsByManyQ(panPos, paNewItems)
				This.ReplaceAtPositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtPositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtPositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByMany(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByMany(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByManyQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByMany(panPos, paNewItems)
				return This

		#--	

		def ReplaceAnyItemsAtPositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByMany(panPos, paNewItems)
			
			def ReplaceAnyItemsAtPositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByThese(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByThese(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByThese(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByThese(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByThese(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByTheseQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByThese(panPos, paNewItems)
				return This

		#>


	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByMany(panPos, paNewItems)
		return This.AnyItemAtPositionsReplacedByManyCS(panPos, paNewItems, TRUE)

		#< @FunctionAlternativeForms

		def AnyItemsAtPositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtPositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByMany(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		#--

		def AnyItemAtThesePositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtPositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByThese(panPos, paNewItems)
			return This.AnyItemAtThesePositionsReplacedByMany(panPos, paNewItems)

		#>

	  #--------------------------------------------------------------------------#
	 #   REPLACING AN ITEM AT GIVEN POSITIONS BY MANY OTHER ITEMS -- EXTENDED   #
	#==========================================================================#

	def ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceItemAtPositionsByManyXT([ 3, 5, 7, 9], "ring", :By = [ "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "" ]

		*/

		if CheckParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		# Early Checkbox()

		nLenNewItems = len(paNewItems)
		if nLenNewItems = 0
			return

		but nLenNewItems = len(panPos)
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		paNewItems = @WithoutDuplicates(paNewItems)
		nLenNewItems = len(paNewItems)

		# Cleaning the positons by leaving only those related to pItem

		anPosItem = This.FindAllCS(pItem, pCaseSensitive)

		nLenPos   = len(panPos)
		anPos = []

		for i = 1 to nLenPos
			if ring_find(anPosItem, panPos[i]) > 0 and
			   ring_find(anPos, panPos[i]) = 0

				anPos + panPos[i]
			ok
		next

		nLenPos = len(anPos)

		# Doing the job

		if nLenNewItems >= nLenPos
			This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		# Case :  nLenItems < nLenPos

		aItems = paNewItems
		j = 0
		for i = 1 to nLenPos - nLenNewItems
			j++
			if j > nLenNewItems
				j = 1
			ok
			aItems + paNewItems[j]
		next

		for i = 1 to nLenPos
			This.ReplaceItemAtPositionNCS(anPos[i], pItem, aItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceItemAtPositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtPositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceItemAtThesePositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceItemAtThesePositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ReplaceThisItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtPositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtPositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		def ReplaceThisItemAtThesePositionsByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceThisItemAtThesePositionsByTheseCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForms

	def ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceItemAtPositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtPositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ItemAtThesePositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		#--

		def ThisItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtThesePositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtPositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		def ThisItemAtThesePositionsReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)
		This.ReplaceItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceItemAtThesePositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceItemAtPositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtPositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceItemAtThesePositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceItemAtThesePositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		#--

		def ReplaceThisItemAtPositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtThesePositionsByManyXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtThesePositionsByManyXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtPositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtPositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		def ReplaceThisItemAtThesePositionsByTheseXT(panPos, pItem, paNewItems)
			This.ReplaceItemAtPositionsByManyXT(panPos, pItem, paNewItems)

			def ReplaceThisItemAtThesePositionsByTheseXTQ(panPos, pItem, paNewItems)
				return This.ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems)

		#>

	#-- @FunctionPassiveForm

	def ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceItemAtPositionsByManyXTQ(panPos, pItem, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ItemAtThesePositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ItemAtPositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ItemAtThesePositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		#--

		def ThisItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtThesePositionsReplacedByManyXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtPositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		def ThisItemAtThesePositionsReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, pItem, paNewItems)

		#>

	  #------------------------------------------------------------------------------#
	 #  REPLACING THE ITEMS AT THE GIVEN POSITIONS BY MANY OTHER ITEMS -- EXTENDED  #
	#------------------------------------------------------------------------------#

	def ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)

		/* EXAMPLE 1

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "python", "ring", "csharp", "ring" ])
		o1.ReplaceAnyItemsAtPositionsByManyXT([ 3, 5, 7], :By = [ "", "", "" ])

		? o1.Content()
		#--> [ "ring", "php", "", "ruby", "", "python", "", "csharp", "ring" ]

		*/

		if CheckParams()

			if NOT ( isList(panPos) and @IsListOfNumbers(panPos) )
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

			if NOT isList(paNewItems)
				StzRaise("Incorrect param type! paNewItems must be a list.")
			ok

		ok

		nLenPos   = len(panPos)
		nLenItems = len(paNewItems)

		if nLenItems >= nLenPos
			This.ReplaceItemAtPositionsByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return
		ok

		# Case :  nLenItems < nLenPos

		aItems = paNewItems
		j = 0
		for i = 1 to nLenPos - nLenItems
			j++
			if j > nLenItems
				j = 1
			ok
			aItems + paNewItems[j]
		next

		for i = 1 to nLenPos
			This.ReplaceAnyItemAtPositionNCS(panPos[i], aItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnyItemAtThesePositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
				return This

		#--	

		def ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemAtPositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)

			def ReplaceAnyItemAtThesePositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			This.ReplaceAnyItemAtPositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			
			def ReplaceAnyItemsAtThesePositionsByTheseCSXTQ(panPos, paNewItems, pCaseSensitive)
				This.ReplaceAnyItemsAtThesePositionsByTheseCSXT(panPos, paNewItems, pCaseSensitive)
				return This

		#>

	#-- @FunctionPassiveForms

	def AnyItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyCSXTQ(panPos, paNewItems, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemAtThesePositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#--

		def AnyItemAtPositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.AnyItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemAtThesePositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		def AnyItemsAtThesePositionsReplacedByTheseCSXT(panPos, paNewItems, pCaseSensitive)
			return This.ItemAtPositionsReplacedByManyCSXT(panPos, paNewItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
		This.ReplaceAnyItemAtPositionsByManyCSXT(panPos, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceAnyItemAtPositionsByManyXTQ(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceAnyItemAtThesePositionsByManyXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByManyXTQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByManyXT(panPos, paNewItems)
				return This

		#--	

		def ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByManyXT(panPos, paNewItems)
			
			def ReplaceAnyItemAtPositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtPositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAnyItemAtThesePositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)

			def ReplaceAnyItemAtThesePositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemAtThesePositionsByTheseXT(panPos, paNewItems)
				return This

		def ReplaceAnyItemsAtThesePositionsByTheseXT(panPos, paNewItems)
			This.ReplaceAnyItemAtPositionsByTheseXT(panPos, paNewItems)
			
			def ReplaceAnyItemsAtThesePositionsByTheseXTQ(panPos, paNewItems)
				This.ReplaceAnyItemsAtThesePositionsByTheseXT(panPos, paNewItems)
				return This

		#>

	#-- @FunctionPassiveForm

	def AnyItemAtPositionsReplacedByManyXT(panPos, paNewItems)
		cResult = This.Copy().ReplaceAnyItemAtPositionsByManyXTQ(panPos, paNewItems).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AnyItemAtThesePositionsReplacedByManyXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		#--

		def AnyItemAtPositionsReplacedByTheseXT(panPos, paNewItems)
			return This.AnyItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemAtThesePositionsReplacedByTheseXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		def AnyItemsAtThesePositionsReplacedByTheseXT(panPos, paNewItems)
			return This.ItemAtPositionsReplacedByManyXT(panPos, paNewItems)

		#>

 	  #-------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF AN ITEM BY MANY OTHER SUBSTRINGS  #
	#===================================================================#

	def ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsCS(anPos, pItem, pNewItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesCSQ(panPos, pItem, pNewItem, pCaseSensitive)
			This.ReplaceItemAtPositionsCSQ(panPos, pItem, pNewItem, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)

			def ReplaceTheseOccurrencesCSQ(panOccurr, pItem, pNewItem, pCaseSensitive)
				This.ReplaceTheseOccurrencesCS(panOccurr, pItem, pNewItem, pCaseSensitive)
				return This

		#>

	def OccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)
		aResult = This.Copy().ReplaceOccurrencesCSQ(panPos, pItem, pNewItem, pCaseSensitive).Content()
		return aResult

		def TheseOccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)
			return This.OccurrencesReplacedCS(panOccurr, pItem, pNewItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurr, pItem, pNewItem)
		This.ReplaceOccurrencesCS(panOccurr, pItem, pNewItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesQ(panPos, pItem, pNewItem)
			This.ReplaceSubStringAtPositionsQ(panPos, pItem, pNewItem)

		#>

		#< @FunctionAlternativeForm

		def ReplaceTheseOccurrences(panOccurr, pItem, pNewItem)
			This.ReplaceOccurrences(panOccurr, pItem, pNewItem)

			def ReplaceTheseOccurrencesQ(panOccurr, pItem, pNewItem)
				This.ReplaceTheseOccurrences(panOccurr, pItem, pNewItem)
				return This

		#>

	def OccurrencesReplaced(panOccurr, pItem, pNewItem)
		aResult = This.Copy().ReplaceOccurrencesQ(panPos, pItem, pNewItem).Content()
		return aResult

		def TheseOccurrencesReplaced(panOccurr, pItem, pNewItem)
			return This.OccurrencesReplaced(panOccurr, pItem, pNewItem)

	  #------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER ITEMS  #
	#------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, pCaseSensitive)
		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCS(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseCS(panOccurr, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, pCaseSensitive)

			def ReplaceOccurrencesByTheseCSQ(panOccurr, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	#-- @FunctionPassiveForm

	def OccurrencesReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		def OccurrencesReplacedByTheseCS(panPos, pItem, paNewItems, pCaseSensitive)
			return This.OccurrencesReplacedByManyCS(panPos, pItem, paNewItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByMany(panOccurr, pItem, paNewItems)
		this.ReplaceOccurrencesByManyCS(panOccurr, pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems)
			This.ReplaceOccurrencesByMany(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByThese(panOccurr, pItem, paNewItems)
			This.ReplaceOccurrencesByMany(panOccurr, pItem, paNewItems)

			def ReplaceOccurrencesByTheseQ(panOccurr, pItem, paNewItems)
				return This.ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems)

		#>

	#-- @FunctionPassiveForm

	def OccurrencesReplacedByMany(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceOccurrencesByManyQ(panPos, pItem, paNewItems).Content()
		return cResult 

		def OccurrencesReplacedByThese(panPos, pItem, paNewItems)
			return This.OccurrencesReplacedByMany(panPos, pItem, paNewItems)

	  #-------------------------------------------------------------------------#
	 #  REPLACING GIVEN OCCURRENCES OF A SUBSTRING BY MANY OTHER ITEMS -- XT  #
	#------------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "*", "*", "*", "*",  "*" ])
		o1.ReplaceOccurrencesByManyXT([ 3, 4, 5, 6, 7 ], [ "#1", "#2" ])
		? @@( o1.Content() )
		#--> [ "A", "B", "#1", "#2", "#1", "#2", "#1" ]
		*/

		anPos = This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		This.ReplaceItemAtPositionsByManyCSXT(anPos, pItem, paNewItems, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)
			This.ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, pCaseSensitive)

			def ReplaceOccurrencesByTheseCSXTQ(panOccurr, pItem, paNewItems, pCaseSensitive)
				return This.ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive)

		#>

	def OccurrencesReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)
		cResult = This.Copy().ReplaceOccurrencesByManyCSXTQ(panPos, pItem, paNewItems, pCaseSensitive).Content()
		return cResult

		def OccurrencesReplacedByTheseCSXT(panPos, pItem, paNewItems, pCaseSensitive)
			return This.OccurrencesReplacedByManyCSXT(panPos, pItem, paNewItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrencesByManyXT(panOccurr, pItem, paNewItems)
		this.ReplaceOccurrencesByManyCSXT(panOccurr, pItem, paNewItems, TRUE)

		#< @FunctionFluentForm

		def ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems)
			This.ReplaceOccurrencesByManyXT(panPos, pItem, paNewItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceOccurrencesByTheseXT(panOccurr, pItem, paNewItems)
			This.ReplaceOccurrencesByManyXT(panOccurr, pItem, paNewItems)

			def ReplaceOccurrencesByTheseXTQ(panOccurr, pItem, paNewItems)
				return This.ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems)

		#>

	def OccurrencesReplacedByManyXT(panPos, pItem, paNewItems)
		cResult = This.Copy().ReplaceOccurrencesByManyXTQ(panPos, pItem, paNewItems).Content()
		return cResult 

		def OccurrencesReplacedByTheseXT(panPos, pItem, paNewItems)
			return This.OccurrencesReplacedByManyXT(panPos, pItem, paNewItems)

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ring", "ruby", "ring", "pyhton", "ring" ])
		o1.ReplaceItem@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content()
		#--> [ "#1", "php", "#2", "ruby", "#3", "pyhton", "#4" ]

		*/

		if isList(pDynamicItem) and Q(pDynamicItem).IsWithOrByNamedParam()
			pDynamicItem = pDynamicItem[2]
		ok

		anPos = This.FindAllCSQ(pItem, pCaseSensitive).SortedInDescending()


		@Item = pItem

		@NumberOfOccurrences = len(anPos)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfItems  = @NumberOfOccurrences
		@NumberOfItems  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		aitem = []

		for @Position in anPos

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPos[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPos[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicItem = @@Q(pDynamicItem).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempItem = ( ' + cDynamicItem + ' )'
			eval(cCode)

			aitem + cTempStr

		next

		aItems = StzListQ(aItems).SortedInDescending()
	
		i = 0
		for @Position in anPos
			i++
			item = aItems[i]
			This.ReplaceItemAtPositionNCS(@Position, pItem, item, pCaseSensitive)
		next

		def ReplaceItemCS@Q(pItem, pDynamicItem, pCaseSensitive)
			This.ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)
			return This

		def ReplaceCS@(pItem, pDynamicItem, pCaseSensitive)
			This.ReplaceItemCS@(pItem, pDynamicItem, pCaseSensitive)

			def ReplaceCS@Q(pItem, pDynamicItem, pCaseSensitive)
				This.ReplaceCS@(pItem, pDynamicItem, pCaseSensitive)
				return This

	def ItemReplacedCS@(pItem, pDynamicItem, pCaseSensitive)
		aResult = This.Copy().ReplaceItemCS@Q(pItem, pDynamicItem, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceItem@(pItem, pDynamicItem)
		This.ReplaceItemCS@(pItem, pDynamicItem, TRUE)

		def ReplaceItem@Q(pItem, pDynamicItem)
			This.ReplaceItem@(pItem, pDynamicItem)
			return This

		def Replace@(pItem, pDynamicItem)
			This.ReplaceItem@(pItem, pDynamicItem)

			def Replace@Q(pItem, pDynamicItem)
				This.Replace@(pItem, pDynamicItem)
				return This

	def ItemReplaced@(pItem, pcDynamicStr)
		aResult = This.Copy().ReplaceItem@Q(pItem, pcDynamicStr).Content()
		return aResult

	   #------------------------------------------------#
	  #   REPLACING THE NEXT OCCURRENCES OF AN ITEM    #
         #   STARTING AT A GIVEN POSITION                 #
	#================================================#

	def ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		anPos = This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAllNextCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceAllNextCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def ReplaceAllNextSCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceAllNextSCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def ReplaceNextOccurrencesSCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplaceNextOccurrencesSCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This.ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		acResult = This.Copy().
				ReplaceNextOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive).
				Content()
		return acResult

		#< @FunctionAlternativeForms

		def AllNextReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def AllNextReplacedSCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		def NextOccurrencesReplacedSCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrencesReplacedCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)
		This.ReplaceNextOccurrencesCS(pItem, pOtherItem, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceAllNext(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplaceAllNextQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		def ReplaceAllNextS(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplaceAllNextSQ(pItem, pOtherItem, pnStartingAt)
				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		def ReplaceNextOccurrencesS(pItem, pOtherItem, pnStartingAt)
			This.ReplaceNextOccurrences(pItem, pOtherItem, pnStartingAt)

				return This.ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt)

		#>

	def NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		acResult = This.Copy().
				ReplaceNextOccurrencesQ(pItem, pOtherItem, pnStartingAt).
				Content()

		return acResult

		#< @FunctionAlternativeForms

		def AllNextReplaced(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		def AllNextReplacedS(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplaced(pItem, pOtherItem, pnStartingAt)

		def NextOccurrencesReplacedS(pItem, pOtherItem, pnStartingAt)
			return This.NextOccurrencesReplacedQ(pItem, pOtherItem, pnStartingAt)

		#>

	   #--------------------------------------------------#
	  #   REPLACING THE PREVIOUS OCCURRENCES OF AN ITEM  #
         #   STARTING AT A GIVEN POSITION                   #
	#--------------------------------------------------#

	def ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		anPos = This.FindPreviousOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		def ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			return This

		def ReplacePreviousCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

			def ReplacePreviousCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				This.ReplacePreviousCS(pItem, pOtherItem, pnStartingAt, pCaseSensitive)
				return This

	def PreviousOccurrencesReplacedCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive)

		acResult = This.Copy().
				ReplacePreviousOccurrencesCSQ(pItem, pOtherItem, pnStartingAt, pCaseSensitive).
				Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)
		This.ReplacePreviousOccurrencesCS(pItem, pOtherItem, pnStartingAt, TRUE)

		def ReplacePreviousOccurrencesQ(pItem, pOtherItem, pStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)
			return This

		def ReplacePrevious(pItem, pOtherItem, pnStartingAt)
			This.ReplacePreviousOccurrences(pItem, pOtherItem, pnStartingAt)

			def ReplacePreviousQ(pItem, pOtherItem, pnStartingAt)
				This.ReplacePrevious(pItem, pOtherItem, pnStartingAt)
				return This

	def PreviousOccurrencesReplacedQ(pItem, pOtherItem, pnStartingAt)

		acResult = This.Copy().
				ReplacePreviousOccurrencesQ(pItem, pOtherItem, pnStartingAt).
				Content()
		return acResult

	  #-----------------------------------------#
	 #   REPLACING NTH OCCURRENCE OF AN ITEM   #
	#-----------------------------------------#

	def ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pOtherItem) and
		   StzListQ(pOtherItem).IsWithOrByNamedParam()
		
			pOtherItem = pOtherItem[2]
		ok

		nItemPosition = This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		This.ReplaceAtCS(nItemPosition, pOtherItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceCSQ(n, pItem, pOtherItem, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthCS(n, pItem, pOtherItem, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, pCaseSensitive)

			def ReplaceNthCSQ(n, pItem, pOtherItem, pCaseSensitive)
				This.ReplaceNthCS(n, pItem, pOtherItem, pCaseSensitive)
				return This
			
		#>

	def NthOccurrenceReplacedCS(n, pItem, pOtherItem, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceNthOccurrenceCSQ(n, pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def NthReplacedCS(n, pItem, pOtherItem, pCaseSensitive)
			return This.NthOccurrenceReplacedCS(n, pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pItem, pOtherItem)
		This.ReplaceNthOccurrenceCS(n, pItem, pOtherItem, TRUE)

		#< @FunctionAlternativeForms

		def ReplaceNth(n, pItem, pOtherItem)
			This.ReplaceNthOccurrence(n, pItem, pOtherItem)

			def ReplaceNthQ(n, pItem, pOtherItem)
				This.ReplaceNth(n, pItem, pOtherItem)
				return This
			
		#>

	def NthOccurrenceReplaced(n, pItem, pOtherItem)

		aResult  = This.Copy().
				ReplaceNthOccurrenceQ(n, pItem, pOtherItem).
				Content()

		return aResult

		def NthReplaced(n, pItem, pOtherItem)
			return This.NthOccurrenceReplaced(n, pItem, pOtherItem, pCaseSensitive)

	  #--------------------------------------------#
	 #   REPLACING FIRST OCCURRENCE OF AN ITEM    #
	#--------------------------------------------#

	def ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pItem, pOtherItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFirstCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
				return This
		#>

		#< @FunctionMisspelledForms

		def ReplaceFristOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFristOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
				return This.ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)

		#--

		def ReplaceFristCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceFristCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceFirstCS(pItem, pOtherItem, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)
		aResult  = This.Copy().
				ReplaceFirstOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def FirstReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		def FristReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pItem, pOtherItem)
		This.ReplaceFirstOccurrenceCS(pItem, pOtherItem, TRUE)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceFirst(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFirstQ(pItem, pOtherItem)
				This.ReplaceFirst(pItem, pOtherItem)
				return This
		#>

		#< @FunctionMisspelledForms

		def ReplaceFristOccurrence(pItem, pOtherItem)
			return This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFristOccurrenceQ(pItem, pOtherItem)
				return This.ReplaceFirstOccurrenceQ(pItem, pOtherItem)

		#--

		def ReplaceFrist(pItem, pOtherItem)
			This.ReplaceFirstOccurrence(pItem, pOtherItem)

			def ReplaceFristQ(pItem, pOtherItem)
				This.ReplaceFirst(pItem, pOtherItem)
				return This

		#>

	def FirstOccurrenceReplaced(pItem, pOtherItem)
		aResult  = This.Copy().
				ReplaceFirstOccurrenceQ(pItem, pOtherItem).
				Content()

		return aResult

		def FirstReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplaced(pItem, pOtherItem)

		#-- MISSPELLED

		def FristOccurrenceReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplacedCS(pItem, pOtherItem)

		def FristReplaced(pItem, pOtherItem)
			return This.FirstOccurrenceReplaced(pItem, pOtherItem)

	  #-----------------------------------------#
	 #   REPLACING LAST OCCURRENCE OF AN ITEM  #
	#-----------------------------------------#

	def ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
		n = This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		This.ReplaceAt(n, pOtherItem)

		def ReplaceLastOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)
			return This

		#< @FunctionAlternativeForms

		def ReplaceLastCS(pItem, pOtherItem, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pItem, pOtherItem, pCaseSensitive)

			def ReplaceLastCSQ(pItem, pOtherItem, pCaseSensitive)
				This.ReplaceLastCS(pItem, pOtherItem, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceLastOccurrenceCSQ(pItem, pOtherItem, pCaseSensitive).
				Content()

		return aResult

		def LastReplacedCS(pItem, pOtherItem, pCaseSensitive)
			return This.LastOccurrenceReplacedCS(pItem, pOtherItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pItem, pOtherItem)
		n = This.FindLastOccurrence(pItem)

		This.ReplaceAt(n, pOtherItem)

		def ReplaceLastOccurrenceQ(pItem, pOtherItem)
			This.ReplaceLastOccurrence(pItem, pOtherItem)
			return This

		#< @FunctionAlternativeForms

		def ReplaceLast(pItem, pOtherItem)
			This.ReplaceLastOccurrence(pItem, pOtherItem)

			def ReplaceLastQ(pItem, pOtherItem)
				This.ReplaceLast(pItem, pOtherItem)
				return This

		#>

	def LastOccurrenceReplaced(pItem, pOtherItem)

		aResult  = This.Copy().
				ReplaceLastOccurrenceQ(pItem, pOtherItem).
				Content()

		return aResult

		def LastReplaced(pItem, pOtherItem)
			return This.LastOccurrenceReplaced(pItem, pOtherItem)

	   #-----------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST   #
	#-----------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		# Checking params correctness

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   StzListQ(pNewItem).IsWithOrByNamedParam()

			if Q(pNewItem[1]).LastChar() = "@"
				
				cCode = 'pNewtItem = ' +
					Q(pNewItem[2]).
					RemoveSpacesQ().
					RemoveTheseBoundsQ("{","}").
					Content()

				eval(cCode)
			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfThese([
				:First, :FirstPosition, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfThese([
				:Last, :LastPosition, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		# Doing the job

		oSection   = This.SectionQR(pnStartingAt, This.NumberOfItems(), :stzList)
		anPos = oSection.FindAllCS(pItem, pCaseSensitive)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt - 1).Content()
			nPos = anPos[n]
	
			This.ReplaceAt(nPos, pNewItem)
		ok
	
		#< @FunctionFluentForm

		def ReplaceNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthNextOccurrenceCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
				return This

		#>

	def NextNthOccurrenceReplacedCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)

		aResult  = This.Copy().
				ReplaceNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pNewItem, pCaseSensitive).
				Content()
		return aResult

		def NthNextOccurrenceReplacedCS(n, pItem, pnStartingAt, pNewItem, pCaseSensitive)
			return This.NextNthOccurrenceReplaced(n, pItem, pnStartingAt, pNewItem)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		return This.ReplaceNextNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def ReplaceNextNthOccurrenceQ(n, pItem, pnStartingAt, pNewItem)
			This.ReplaceNextNthOccurrence(n, pItem, pnStartingAt, pNewItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceNthNextOccurrence(n, pItem, pnStartingAt, pNewItem)
			This.ReplaceNextNthOccurrence(n, pItem, pnStartingAt, pNewItem)

			def ReplaceNthNextOccurrenceQ(n, pItem, pnStartingAt, pNewItem)
				This.ReplaceNthNextOccurrence(n, pItem, pnStartingAt, pNewItem)
				return This

		#>

	def NextNthOccurrenceReplaced(n, pItem, pnStartingAt, pNewItem)

		aResult  = This.Copy().
				ReplaceNthNextOccurrenceQ(n, pItem, pnStartingAt, pNewItem).
				Content()

		return aResult

		def NthNextOccurrenceReplaced(n, pItem, pnStartingAt, pNewItem)
			return This.NextNthOccurrenceReplaced(n, pItem, pnStartingAt, pNewItem)

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF AN ITEM        #
	 #    STARTING AT A GIVEN POSITION IN THE LIST    #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

	def NextOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceNextOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pItem, pNewItem, pnStartingAt)
		This.ReplaceNextNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplaceNextOccurrenceQ(pItem, pNewItem, pnStartingAt)
			This.ReplaceNextOccurrence(pItem, pNewItem, pnStartingAt)
			return This

	def NextOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

		aResult  = This.Copy().
				ReplaceNextOccurrenceQ(pItem, pNewItem, pnStartingAt).
				Content()

		return aResult

	   #-----------------------------------------------------#
	  #    REPLACING MANY NEXT NTH OCCURRENCES OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST         #
	#-----------------------------------------------------#

	def ReplaceNextNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListOfQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			ReplaceNextNthOccurrences([2, 3], :of = "A", :with = "*",  :StartingAt = 3)
			? Content() # !--> [ "A" , "B", "A", "C", "*", "D", "*" ]
		}		

		*/

		if NOT (isList(panList) and StzListQ(panList).IsListOfNumbers() and
		        StzListQ(panList).NumberOfItemsW("StzNumberQ(@item).IsBetween(1, " + This.NumberOfItems() + ")") = len(panList) )

			StzRaise("Incorrect param! panList must be a list of numbers between 1 and This.NumberOfItems().")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   StzListQ(pNewItem).IsWithOrByNamedParam()
			if Q(pNewItem[1]).LastChar() = "@"
				cCode = 'pNewtItem = ' + pNewItem[2]
				eval(cCode)
			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfThese([
				:First, :FirstPosition, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfThese([
				:Last, :LastPosition, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok
			
		oSection = This.SectionQ(pnStartingAt, :LastItem)

		anPos = oSection.
			      FindAllCSQR(pItem, pCaseSensitive, :stzListOfNumbers).
			      AddToEachQ(pnStartingAt-1).
			      Content()

		anPosToBeReplaced = []

		nLen = len(panList)
		nLenPos = len(anPos)

		for i = 1 to nLen
			if i <= nLenPos
				anPosToBeReplaced +  anPos[panList[i]]
			ok
		next

		This.ReplaceAllItemsAtThesePositions(anPosToBeReplaced, pNewItem)

		#< @FunctionFluentForm

		def ReplaceNextNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNthNextOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplaceNextNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				This.ReplaceNthNextOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This
		#>

	def NextNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult = This.
			  ReplaceNextNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive).
			  Content()

		return aResult

		def NthNextOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
		return This.ReplaceNextNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def ReplaceNextNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNthNextOccurrences(panList, pItem, pNewItem, pnStartingAt)
			This.ReplaceNextNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthNextOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthNextOccurrences(panList, pItem, pNewItem, pnStartingAt)
				return This
		#>

	def NextNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

		aResult = This.
			  ReplaceNextNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt).
			  Content()

		return aResult

		def NthNextOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)
			return This.NextNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

	   #---------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST       #
	#---------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   StzListQ(pNewItem).IsWithOrByNamedParam()

			if Q(pNewItem[1]).LastChar() = "@"
				cCode = 'pNewtItem = ' + pNewItem[2]
				eval(cCode)

			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfThese([
				:First, :FirstPosition, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfThese([
				:Last, :LastPosition, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection   = This.SectionQR(1, pnStartingAt, :stzList)
		aPositions = oSection.FindAllCS(pItem, pCaseSensitive)

		nPosition = aPositions[ len(aPositions) - n + 1 ]

		This.ReplaceAtCS(nPosition, pNewItem, pCaseSensitive)

		def ReplacePreviousNthOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		def ReplaceNthPreviousOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This

	def NthPreviousOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplaceNthPreviousOccurrenceCSQ(n, pItem, pNewItem, pnStartingAt, pCaseSensitive).
				Content()

		return aResult

		def PreviousNthOccurrenceReplacedCS(n, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceReplacedCS(n, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

		def ReplacePreviousNthOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)
			return This

		def ReplaceNthPreviousOccurrence(n, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrence(n, pItem, pNewItem, pnStartingAt)

			def ReplaceNthPreviousOccurrenceQ(n, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthPreviousOccurrence(n, pItem, pNewItem, pnStartingAt)
				return This

	def NthPreviousOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)

		aResult =  This.Copy().
				ReplaceNthPreviousOccurrenceQ(n, pItem, pNewItem, pnStartingAt).
				Content()

		return aResult

		def PreviousNthOccurrenceReplaced(n, pItem, pNewItem, pnStartingAt)
			return This.NthPreviousOccurrenceReplaced(n, pItem, pnStartingAt)

	   #-----------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF AN ITEM   #
	 #    STARTING AT A GIVEN POSITION IN THE LIST   #
	#-----------------------------------------------#

	def ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

	def PreviousOccurrenceReplacedCS(pItem, pNewItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				ReplacePreviousOccurrenceCSQ(pItem, pNewItem, pnStartingAt, pCaseSensitive).
				Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pItem, pNewItem, pnStartingAt)
		This.ReplacePreviousOccurrenceCS(pItem, pNewItem, pnStartingAt, TRUE)

		def ReplacePreviousOccurrenceQ(pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousOccurrence(pItem, pNewItem, pnStartingAt)
			return This

	def PreviousOccurrenceReplaced(pItem, pNewItem, pnStartingAt)

		aResult =  This.Copy().
				ReplacePreviousOccurrenceQ(pItem, pNewItem, pnStartingAt).
				Content()
		return aResult

	   #---------------------------------------------------------#
	  #     REPLACING MANY PREVIOUS NTH OCCURRENCES OF AN ITEM  #
	 #    STARTING AT A GIVEN POSITION IN THE LIST             #
	#---------------------------------------------------------#

	def ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			ReplacePreviousNthOccurrences([2, 3], :of = "A", :with = "*",  :StartingAt = 5)
			? Content() # !--> [ "*" , "B", "*", "C", "A", "D", "A" ]
		}		

		*/

		if NOT ( isList(panList) and StzListQ(panList).IsListOfNumbers() and

		         StzListQ(panList).NumberOfItemsW("StzNumberQ(@item).IsBetween(1, " + This.NumberOfItems() + ")") = len(panList) )

			StzRaise("Incorrect param! panList must be a list of numbers between 1 and This.NumberOfItems().")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pNewItem) and
		   ( StzListQ(pNewItem).IsWithNamedParam() or StzListQ(pNewItem).IsByNamedParam() )

			if Q(pNewItem[1]).LastChar() = "@"
				cCode = 'pNewtItem = ' + pNewItem[2]
				eval(cCode)

			else
				pNewItem = pNewItem[2]
			ok
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfThese([
				:First, :FirstPosition, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfThese([
				:Last, :LastPosition, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok
			
		oSection = This.SectionQ(1, pnStartingAt)

		anPos = oSection.FindAllCSQ(pItem, pCaseSensitive).ItemsReversed()

		anPosToBeReplaced = []
		nLen = len(panList)
		nLenPos = len(anPos)

		for i = 1 to nLen
			if i <= nLenPos
				anPosToBeReplaced +  anPos[panList[i]]
			ok
		next

		This.ReplaceAllItemsAtThesePositionsCS(anPosToBeReplaced, pNewItem, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNthPreviousOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

			def ReplaceNthPreviousOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				This.ReplaceNthPreviousOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
				return This
		#>

	def PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
		aResult =  This.
			   ReplacePreviousNthOccurrencesCSQ(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive).
			   Content()

		return aResult

		def NthPreviousOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesReplacedCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
		This.ReplacePreviousNthOccurrencesCS(panList, pItem, pNewItem, pnStartingAt, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceNthPreviousOccurrences(panList, pItem, pNewItem, pnStartingAt)
			This.ReplacePreviousNthOccurrences(panList, pItem, pNewItem, pnStartingAt)

			def ReplaceNthPreviousOccurrencesQ(panList, pItem, pNewItem, pnStartingAt)
				This.ReplaceNthPreviousOccurrences(panList, pItem, pNewItem, pnStartingAt)
				return This
		#>

	def PreviousNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

		aResult =  This.
			   ReplacePreviousNthOccurrencesQ(panList, pItem, pNewItem, pnStartingAt).
			   Content()

		return aResult

		def NthPreviousOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)
			return This.PreviousNthOccurrencesReplaced(panList, pItem, pNewItem, pnStartingAt)

	  #------------------------------#
	 #   REPLACING THE FIRST ITEM   #
	#------------------------------#

	def ReplaceFirstItem(pOtherItem)
		@aContent[1] = pOtherItem

		def ReplaceFirstItemQ(pOtherItem)
			This.ReplaceFirstItem(pOtherItem)
			return This

	def FirstItemReplaced(pOtherItem)
		aResult = This.Copy().ReplaceFirstItemQ(pOtherItem).Content()
		return aResult

		def FirstItemReplacedWith(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

		#-- MISSPELLED

		def FristItemReplaced(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

		def FristItemReplacedWith(pOtherItem)
			return This.FirstItemReplaced(pOtherItem)

	  #-----------------------------#
	 #   REPLACING THE LAST ITEM   #
	#-----------------------------#

	def ReplaceLastItem(pOtherItem)
		@aContent[ len(@aContent) ] = pOtherItem

		def ReplaceLastItemQ(pOtherItem)
			This.ReplaceLastItem(pOtherItem)
			return This

	def LastItemReplaced(pOtherItem)
		aResult = This.Copy().ReplaceLastItemQ(pOtherItem).Content()
		return aResult

		def LastItemReplacedWith(pOtherItem)
			return This.LastItemReplaced(pOtherItem)

	  #---------------------------------------------------#
	 #    REPLACING A SECTION OF ITEMS BY A GIVEN ITEM   #
	#===================================================#

	def ReplaceSection(n1, n2, pNewItem)
		/* EXAMPLE 1

		o1 = new stzList([ "A", "B", "_", "_", "_", "D" ])
		o1.ReplaceSection(3, 5, "C")
		? o1.Content() #--> [ "A", "B", "C", "D" ]

		EXAMPLE 2 (Using :By@)

		o1 = new stzList([ "A", "B", "c", "d", "e", "F" , "G" ])
		
		o1.ReplaceSection(3, 5, :By@ = '{ @EachItemQ.Uppercased() }')
		? o1.Content()
		#--> [ "A", "B", "C", "D", "E", "F", "G" ]

		*/

		This.RemoveSectionQ(n1, n2)
		This.InsertBefore(n1, pNewItem)

		def ReplaceSectionQ(n1, n2, pNewItem)
			This.ReplaceSection(n1, n2, pNewItem)
			return This

	def SectionReplaced(n1, n2, pNewItem)
		aResult = This.Copy().ReplaceSectionQ(n1, n2, pNewItem).Content()
		return aResult

		def SectionReplacedWith(n1, n2, pNewItem)
			return This.SectionReplaced(n1, n2, pNewItem)
	
	  #----------------------------------------------#
	 #    REPLACING MANY SECTIONS BY A GIVEN ITEM   #
	#----------------------------------------------#

	def ReplaceManySections(paSections, pNewItem)
		for anSection in paSections
			This.ReplaceSection(anSection, pNewItem)
		next

		def ReplaceManySectionsQ(paSections, pNewItem)
			This.ReplaceManySections(paSections, pNewItem)
			return This
		
		def ReplaceTheseSections(paSections, pNewItem)
			This.ReplaceManySections(paSections, pNewItem)

			def ReplaceTheseSectionsQ(paSections, pNewItem)
				return This.ReplaceManySectionsQ(paSections, pNewItem)
				
	def ManySectionsReplaced(paSections, pNewItem)
		aResult = This.Copy().ReplaceManySectionsQ(paSections, pNewItem).Content()
		return aResult

		def ManySectionsReplacedWith(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

		def TheseSectionsReplaced(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

		def TheseSectionsReplacedWith(paSections, pNewItem)
			return This.ManySectionsReplaced(paSections, pNewItem)

	  #------------------------------------------------------#
	 #   REPLACING EACH ITEM IN SECTION BY ONE GIVEN ITEM   #
	#------------------------------------------------------#

	def ReplaceEachItemInSection(n1, n2, pNewItem)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "_", "_", "_", "D" ])
		o1.ReplaceEachItemInSection(3, 5, "C")
		? o1.Content() #--> [ "A", "B", "C", "C", "C", "D" ]

		*/

		This.ReplaceItemsAtThesePositions(n1 : n2, pNewItem)

		def ReplaceEachItemInSectionQ(n1, n2, pNewItem)
			This.ReplaceEachItemInSection(n1, n2, pNewItem)
			return This

	def EachItemInSectionReplaced(n1, n2, pNewItem)
		acResult = This.Copy().ReplaceEachItemInSectionQ(n1, n2, pNewItem).Content()
		return acResult

		def EachItemInSectionReplacedWith(n1, n2, pNewItem)
			return This.EachItemInSectionReplaced(n1, n2, pNewItem)

		def EachItemReplacedInSection(n1, n2, pNewItem)
			return This.EachItemInSectionReplaced(n1, n2, pNewItem)

		def EachItemReplacedInSectionWith(n1, n2, pNewItem)
			return This.EachItemReplacedInSection(n1, n2, pNewItem)
	
	  #----------------------------------------------------------#
	 #   REPLACING EACH ITEM IN MANY SECTIONS BY A GIVEN ITEM   #
	#----------------------------------------------------------#

	def ReplaceEachItemInManySections(paSections, pNewItem)
		for anSection in paSections
			n1 = anSection[1]
			n2 = anSection[2]
			This.ReplaceEachItemInSection(n1, n2, pNewItem)
		next

		def ReplaceEachItemInManySectionsQ(paSections, pNewItem)
			This.ReplaceEachItemInManySections(paSections, pNewItem)
			return This

		def ReplaceEachItemInTheseSections(paSections, pNewItem)
			This.ReplaceEachItemInManySections(paSections, pNewItem)

			def ReplaceEachItemInTheseSectionsQ(paSections, pNewItem)
				return This.ReplaceEachItemInManySectionsQ(paSections, pNewItem)

	def EachItemInManySectionsReplaced(paSections, pNewItem)

		acResult = This.Copy().
				ReplaceEachItemInManySectionsQ(paSections, pNewItem).
				Content()

		return acResult

		def EachItemInTheseSectionsReplaced(paSections, pNewItem)
			return This.EachItemInManySectionsReplaced(paSections, pNewItem)

	   #-----------------------------------------------#
	  #   REPLACING A SECTION OF ITEMS IN THE LIST    #
	 #   BY MANY ITEMS ONE BY ONE    	         #
	#-----------------------------------------------#

	def ReplaceSectionByMany(n1, n2, paOtherListOfItems)
		/* EXAMPLE

		o1 = new stzList([ "A", "B", "_", "_", "_", "F" ])
		o1.ReplaceSectionByMany(3, 5, [ "C", "D", "F" ])
		? o1.Content() #--> [ "A", "B", "C", "D", "E", "F" ]

		*/
		i = 0

		for n = n1 to n2
			i++
			if i <= len(paOtherListOfItems)
				item = paOtherListOfItems[i]
			else
				item = NULL
			ok

			This.ReplaceAt(n, item)
		next

		def ReplaceSectionByManyQ(n1, n2, paOtherListOfItems)
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)
			return This

		def ReplaceSectionByThese(n1, n2, pOtherListOfItems)
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)

			def ReplaceSectionByTheseQ(n1, n2, pOtherListOfItems)
				return This.ReplaceSectionByManyQ(n1, n2, paOtherListOfItems)

	def SectionReplacedByMany(n1, n2, paOtherListOfItems)
		aResult = This.ReplaceSectionByManyQ(n1, n2, paOtherListOfItems).Content()
		return aResult

		def SectionReplacedByThese(n1, n2, paOtherListOfItems)
			return This.SectionReplacedByMany(n1, n2, paOtherListOfItems)

	   #---------------------------------------------------#
	  #   REPLACING MANY SECTIONS OF ITEMS IN THE LIST    #
	 #   BY MANY ITEMS ONE BY ONE                        #
	#---------------------------------------------------#

	def ReplaceManySectionsByMany(paSections, paOtherListOfItems)
		for anSection in paSections
			n1 = paSections[1]
			n2 = paSections[2]
			This.ReplaceSectionByMany(n1, n2, paOtherListOfItems)
		next

		def ReplaceManySectionsByManyQ(paSections, paOtherListOfItems)
			This.ReplaceManySectionsByMany(paSections, paOtherListOfItems)
			return This

		def ReplaceTheseSectionsByThese(paSections, paOtherListOfItems)
			This.ReplaceManySectionsByMany(paSections, paOtherListOfItems)

			def ReplaceTheseSectionsByTheseQ(paSections, paOtherListOfItems)
				This.ReplaceTheseSectionsByThese(paSections, paOtherListOfItems)

	def ManySectionsReplacedByMany(paSections, paOtherListOfStr)
		acResult = This.Copy().
				ReplaceManySectionsByManyQ(paSections, paOtherListOfItems).
				Content()

		return acResult

		def TheseSectionsReplacedByThese(paSections, paOtherListOfStr)
			return This.ManySectionsReplacedByMany(paSections, paOtherListOfStr)

	  #--------------------------------------------#
	 #   REPLACING A RANGE OF ITEMS IN THE LIST   #
	#--------------------------------------------#

	def ReplaceRange(n, nRange, pNewItem)

		anSection = RangeToSection([ n, nRange ])
		n1 = anSection[1]
		n2 = anSection[2]

		This.ReplaceSection(n1, n2, pNewItem)

		def ReplaceRangeQ(n, nRange, pNewItem)
			This.ReplaceRange(n, nRange, pNewItem)
			return This

	def RangeReplaced(n, nRange, pNewItem)
		acResult = This.Copy().ReplaceRangeQ(n, nRange, pNewItem).Content()
		return acResult

	  #------------------------------------------------#
	 #   REPLACING MANY RANGES OF ITEMS IN THE LIST   #
	#------------------------------------------------#

	def ReplaceRanges(panRanges, pNewItem)
		#TODO: Add params check
		#TODO: Change for/in loop by for loop

		for anRange in panRanges
			n = anRange[1]
			nRange = anRange[2]
			This.ReplaceRange(n, nRange, pNewItem)
		next

		def ReplaceRangesQ(panRanges, pNewItem)
			This.ReplaceManyRanges(panRanges, pNewItem)
			return This

		def ReplaceManyRanges(panRanges, pNewItem)
			This.ReplaceRanges(panRanges, pNewItem)

			def ReplaceManyRangesQ(panRanges, pNewItem)
				return This.ReplaceRangesQ(panRanges, pNewItem)

		def ReplaceTheseRanges(panRanges, pNewItem)
			This.ReplaceRanges(panRanges, pNewItem)

			def ReplaceTheseRangesQ(panRanges, pNewItem)
				return This.ReplaceRangesQ(panRanges, pNewItem)

	def RangesReplaced(panRanges, pNewItem)
		acResult = This.Copy().ReplaceManyRangesQ(panRanges, pNewItem).Content()
		return acResult

		def ManyRangesReplaced(panRanges, pNewItem)
			return This.RangesReplaced(panRanges, pNewItem)

		def TheseRangesReplaced(panRanges, pNewItem)
			return This.RangesReplaced(panRanges, pNewItem)

	  #-----------------------------------------------------------#		
	 #   REPLACING EACH ITEM IN A RANGE BY THE SAME GIVEN ITEM   #
	#-----------------------------------------------------------#

	def ReplaceEachItemInRange(n, nRange, pNewItem)

		anSection = RangeToSection([ n, nRange ])
		anPos = ring_sort( StzListOfPairsQ(anSection).ExpandedIfPairsOfNumbers() )

		This.ReplaceItemsAtThesePositions(anPos, pNewItem)

		def ReplaceEachItemInRangeQ(n, nRange, pNewItem)
			This.ReplaceEachItemInRange(n, nRange, pNewItem)
			return This

	def EachItemInRangeReplaced(n, nRange, pNewItem)

		acResult = This.Copy().ReplaceEachItemInRangeQ(n, nRange, pNewItem).Content()
		return acResult

		def EachItemReplacedInRange(n, nRange, pNewItem)
			return This.EachItemInRangeReplaced(n, nRange, pNewItem)
		
	  #---------------------------------------------------------------#		
	 #   REPLACING EACH ITEM IN MANY RANGES BY THE SAME GIVEN ITEM   #
	#---------------------------------------------------------------#

	def ReplaceEachItemInManyRanges(panRanges, pNewItem)
		#TODO: Add params check
		#TODO: Change for/in loop by for loop

		for anRange in panRanges
			anSection = RangeToSection(anRange)
			n1 = anSection[1]
			n2 = anSection[2]
			This.ReplaceEachItemInSection(n1, n2, pNewItem)
		next

		def ReplaceEachItemInManyRangesQ(panRanges, pNewItem)
			This.ReplaceEachItemInManyRanges(panRanges, pNewItem)
			return This

		def ReplaceEachItemInTheseRanges(panRanges, pNewItem)
			This.ReplaceEachItemInManyRanges(panRanges, pNewItem)

			def ReplaceEachItemInTheseRangesQ(panRanges, pNewItem)
				return This.ReplaceEachItemInManyRangesQ(panRanges, pNewItem)

	def EachItemInManyRangesReplaced(panRanges, pNewItem)

		acResult =  This.Copy().
				ReplaceEachItemInManyRangesQ(panRanges, pNewItem).
				Content()

		return acResult

		def EachItemReplacedInManyRanges(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)
	
		def EachItemInTheseRangesReplaced(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)

		def EachItemReplacedInTheseRanges(panRanges, pNewItem)
			return This.EachItemInManyRangesReplaced(panRanges, pNewItem)

	   #--------------------------------------------#
	  #   REPLACING A RANGE OF ITEMS IN THE LIST   #
	 #   WITH MANY ITEMS ONE BY ONE               #
	#--------------------------------------------#

	def ReplaceRangeByMany(n, nRange, paOtherListOfItems)
		#TODO: Add params check

		anSection = RangeToSection([ n, nRange ])
		n1 = anSection[1]
		n2 = anSection[2]

		i = 0
		for n = n1 to n2
			i++
			if i <= len(paOtherListOfItems)
				item = paOtherListOfItems[i]
			else
				item = NULL
			ok

			This.ReplaceAt(n, item)
		next

		def ReplaceRangeByManyQ(n, nRange, paOtherListOfItems)
			This.ReplaceRangeByMany(n, nRange, paOtherListOfItems)
			return This

		def ReplaceRangeByThese(n, nRange, paOtherListOfItems)
			This.ReplaceRangeByMany(n, nRange, paOtherListOfItems)

			def ReplaceRangeByTheseQ(n, nRange, paOtherListOfItems)
				return This.ReplaceRangeByManyQ(n, nRange, paOtherListOfItems)

	def RangeReplacedByMany(n, nRange, paOtherListOfItems)
		aResult = This.ReplaceRangeByManyQ(n, nRange, paOtherListOfItems).Content()
		return aResult

		def RangeReplacedByThese(n, nRange, paOtherListOfItems)
			return This.RangeReplacedByMany(n, nRange, paOtherListOfItems)

	   #------------------------------------------------#
	  #   REPLACING MANY RANGES OF ITEMS IN THE LIST   #
	 #   WITH MANY ITEMS ONE BY ONE                   #
	#------------------------------------------------#

	def ReplaceManyRangesByMany(panRanges, paOtherListOfItems)
		for anRange in panRanges
			anSection = RangeToSection(anRange)
			n1 = anSections[1]
			n2 = anSections[2]
			This.ReplaceRangeByMany(n, nRange, paOtherListOfItems)
		next

		def ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems)
			This.ReplaceManyRangesByMany(panRanges, paOtherListOfItems)
			return This

		def ReplaceTheseRangesByThese(panRanges, paOtherListOfItems)
			This.ReplaceManyRangesByMany(panRanges, paOtherListOfItems)

			def ReplaceTheseRangesByTheseQ(panRanges, paOtherListOfItems)
				return This.ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems)

	def RangesReplacedByMany(panRanges, paOtherListOfItems)
		
		acResult = This.Copy().
				ReplaceManyRangesByManyQ(panRanges, paOtherListOfItems).
				Content()

		return acResult

		def RangesReplacedByThese(panRanges, paOtherListOfItems)
			return This.RangesReplacedByMany(panRanges, paOtherListOfItems)

	  #----------------------------------------------#
	 #   REPLACING ITEMS UNDER A GIVEN CONDITION    #
	#----------------------------------------------#

	def ReplaceItemsW(pCondition, pOtherItem)

		anPos = This.FindItemsW(pCondition)
		This.ReplaceItemsAtPositions(anPos, pOtherItem)

		#< @FunctionFluentForm

		def ReplaceItemsWQ(pCondition, pOtherItem)
			This.ReplaceItemsW(pCondition, pOtherItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def ReplaceW(pCondition, pOtherItem)
			This.ReplaceItemsW(pCondition, pOtherItem)

			def ReplaceWQ(pCondition, pOtherItem)
				This.ReplaceW(pCondition, pOtherItem)
				return This

		#>

	def ItemsReplacedW(pCondition, pOtherItem)
		aResult = This.Copy().ReplaceItemsW(pCondition, pOtherItem)
		return aResult

	  #----------------------------------#
	 #  REPLACING AN ITEM AT ANY LEVEL  #
	#----------------------------------#

	// Replaces an item at any nested level of the list by a new value
	def DeepReplaceCS(pItem, pByValue, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([
			"me",
			"other",
			[ "other", "me", [ "me" ], "other" ],
			"other"
		])
		
		o1.DeepReplace("me", :By = "you")
		? o1.Content()
		#--> [
		#	"you",
		#	"other",
		#	[ "other", "me", [ "you" ], "other" ],
		#	"other"
		#    ]
		
		*/

		if isList(pByValue) and Q(pByValue).IsByOrWithNamedParam()
			pByValue = pByValue[2]
		ok

		cValue = @@(pItem)
		cByValue = @@(pByValue)

		cCode = This.ToCodeQ().ReplaceCSQ( cValue, cByValue, pCaseSensitive ).Content()
		cCode = ' aResult = ' + cCode

		eval(cCode)
		This.Update( aResult )

		def DeepReplaceCSQ(pItem, pByValue, pCaseSensitive)
			This.DeepReplaceCS(pItem, pByValue, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def DeepReplace(pItem, pByValue)
		This.DeepReplaceCS(pItem, pByValue, TRUE)

		def DeepReplaceQ(pItem, pByValue)
			This.DeepReplace(pItem, pByValue)
			return This

	  #=========================================================#
	 #   REMOVING ALL OCCURRENCE OF A GIVEN ITEM IN THE LIST   #
	#=========================================================#

	def RemoveAllCS(pItem, pCaseSensitive)
		if CheckParams()
			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLenPos = len(anPos)

		for i = nLenPos to 1 step -1
			This.RemoveItemAtPosition(anPos[i])
		next

		#< @FunctionFluentForm

		def RemoveAllCSQ(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveAllOccurrencesCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveAllOccurrencesCSQ(pItem, pCaseSensitive)
				This.RemoveAllOccurrencesCS(pItem, pCaseSensitive)
				return This

		def RemoveCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveCSQ(pItem, pCaseSensitive)
				This.RemoveCS(pItem, pCaseSensitive)
				return This

		def RemoveItemCS(pItem, pCaseSensitive)
			This.RemoveAllCS(pItem, pCaseSensitive)

			def RemoveItemCSQ(pItem, pCaseSensitive)
				This.RemoveItemCS(pItem, pCaseSensitive)
				return This

		#>

	def AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveAllOccurrencesCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def AllOccurrencesRemovedCS(pItem, pCaseSensitive)
			return This.AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)

		def ItemRemovedCS(pItem, pCaseSensitive)
			return This.AllOccurrencesOfThisItemRemovedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveAll(pItem)
		This.RemoveAllCS(pItem, TRUE)

		#< @FunctionFluentForm

		def RemoveAllQ(pItem)
			This.RemoveAll(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveAllOccurrences(pItem)
			This.RemoveAll(pItem)

			def RemoveAllOccurrencesQ(pItem)
				This.RemoveAllOccurrences(pItem)
				return This

		def Remove(pItem)
			if isList(pItem) and Q(pItem).IsEachNamedParam()
				pItem = pItem[2]
			ok

			This.RemoveAll(pItem)

			def RemoveQ(pItem)
				This.Remove(pItem)
				return This

		def RemoveItem(pItem)
			This.RemoveAll(pItem)

			def RemoveItemQ(pItem)
				This.RemoveItem(pItem)
				return This

	def AllOccurrencesOfThisItemRemoved(pItem)
		aResult = This.Copy().RemoveAllOccurrencesQ(pItem).Content()
		return aResult

		def AllOccurrencesRemoved(pItem)
			return This.AllOccurrencesOfThisItemRemoved(pItem)

		def ItemRemoved(pItem)
			return This.AllOccurrencesOfThisItemRemoved(pItem)

	  #-------------------------------------------------------#
	 #   REMOVING GIVEN OCCURRENCES OF AN ITEM IN THE LIST   #TODO: Add CASESENSITIVITY
	#-------------------------------------------------------#

	def RemoveOccurrences(panOccurr, pItem)
		if CheckParams()
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and
			   Q(panOccurr[i]).IsAndNamedParam()

				panOccurr[i] = panOccurr[i][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrences(pItem)
					ok
				ok
			next
		ok

		if NOT ( isList(panOccurr) and @IsListOfNumbers(panOccurr) )
			StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
		ok

		anPos = This.FindTheseOccurrences(panOccurr, pItem)
		This.RemoveItemsAtPositions(anPos)

		#TODO
		# See why this alternative implementations leads an error
		/*
		for i = 1 to nLen
			This.RemoveNthOccurrence(panOccurr[i], pItem)
		next
		*/

		#< @FunctionFluentForm

		def RemoveOccurrencesQ(panOccurr, pItem)
			This.RemoveOccurrences(panOccurr, pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveManyOccurrences(paOccurrences, pItem)
			This.RemoveOccurrences(panOccurr, pItem)

			def RemoveManyOccurrencesQ(paOccurrences, pItem)
				This.RemoveManyOccurrences(paOccurrences, pItem)
				return This

		def RemoveTheseOccurrences(panOccurr, pItem)
			This.RemoveOccurrences(panOccurr, pItem)

			def RemoveTheseOccurrencesQ(panOccurr, pItem)
				This.RemoveTheseOccurrences(panOccurr, pItem)
				return This

		#>

	def OccurrencesRemoved(panOccurr, pItem)
		aResult = This.Copy.RemoveOccurrencesQ(panOccurr, pItem).Content()
		return aResult

		def TheseOccurrencesRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def TheseOccurrencesOfThisItemRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def ManyOccurrencesOfThisItemRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

		def ManyOccurrencesRemoved(panOccurr, pItem)
			return This.OccurrencesRemoved(panOccurr, pItem)

	  #------------------------------------------#
	 #   REMOVING MANY ITEMS AT THE SAME TIME   #
	#------------------------------------------#

	def RemoveManyCS(paItems, pCaseSensitive)
		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)

		for i = 1 to nLen
			This.RemoveAllCS(paItems[i], pCaseSensitive)
		next

		#< @FunctionFluentForm

		def RemoveManyCSQ(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAllOfTheseCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveAllOfTheseCSQ(paItems, pCaseSensitive)
				This.RemoveAllOfTheseCS(paItems, pCaseSensitive)
				return This

		def RemoveTheseCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveTheseCSQ(paItems, pCaseSensitive)
				This.RemoveTheseCS(paItems, pCaseSensitive)
				return This

		def RemoveTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveManyCS(paItems, pCaseSensitive)

			def RemoveTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveTheseItemsCS(paItems, pCaseSensitive)
				return This

		#>

	def TheseItemsRemovedCS(paItems, pCaseSensitive)

		aResult =  This.Copy().
				RemoveTheseItemsCSQ(paItems, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		def ManyItemsRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		def ManyRemovedCS(paItems, pCaseSensitive)
			return This.TheseItemsRemovedCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveMany(paItems)
		This.RemoveManyCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def RemoveAllOfThese(paItems)
			This.RemoveMany(paItems)

			def RemoveAllOfTheseQ(paItems)
				This.RemoveAllOfThese(paItems)
				return This

		def RemoveThese(paItems)
			This.RemoveMany(paItems)

			def RemoveTheseQ(paItems)
				This.RemoveThese(paItems)
				return This

		def RemoveTheseItems(paItems)
			This.RemoveMany(paItems)

			def RemoveTheseItemsQ(paItems)
				This.RemoveTheseItems(paItems)
				return This

		#>

	def TheseItemsRemoved(paItems)

		aResult =  This.Copy().
				RemoveTheseItemsQ(paItems).
				Content()

		return aResult

		#< @FunctionAlternativeForms

		def AllOfTheseItemsRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		def ManyItemsRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		def ManyRemoved(paItems)
			return This.TheseItemsRemoved(paItems)

		#>

	  #--------------------------------------------#
	 #  REMOVING ITEMS OTHER THAN THOSE PROVIDED  #
	#--------------------------------------------#

	def RemoveItemsOtherThanCS(paItems, pCaseSensitive)
		anPos = This.FindItemsOtherThanCS(paItems, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveItemsOtherThanCSQ(paItems, pCaseSensitive)
			This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsOtherThanTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def RemoveItemsExceptCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def RemoveAllExceptCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveAllExceptTheseCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		def RemoveAllButCS(paItems, pCaseSensitive)
			return This.RemoveItemsOtherThanCS(paItems, pCaseSensitive)

		#>

	def ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)
		aResult = This.Copy().RemoveItemsOtherThanCSQ(paItems, pCaseSensitive).Content()
		return aResult

		def ItemsRemovedExceptCS(paItems, pCaseSensitive)
			return This.ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)

		def AllRemovedButCS(paItems, pCaseSensitive)
			return This.ItemsOtherThanTheseRemovedCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveItemsOtherThan(paItems)
		return This.RemoveItemsOtherThanCS(paItems, TRUE)

		#< @FunctionFluentForm

		def RemoveItemsOtherThanQ(paItems)
			This.RemoveItemsOtherThan(paItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsOtherThanThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#--

		def RemoveItemsExcept(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveItemsExceptThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#--

		def RemoveAllExcept(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveAllExceptThese(paItems)
			return This.RemoveItemsOtherThan(paItems)

		def RemoveAllBut(paItems)
			return This.RemoveItemsOtherThan(paItems)

		#>

	def ItemsOtherThanTheseRemoved(paItems)
		aResult = This.Copy().RemoveItemsOtherThanQ(paItems).Content()
		return aResult

		def ItemsRemovedExcept(paItems)
			return This.ItemsOtherThanTheseRemoved(paItems)

		def AllRemovedBut(paItems)
			return This.ItemsOtherThanTheseRemoved(paItems)

	  #-------------------------------------------------#
	 #   REMOVING THE NTH OCCURRENCE OF A GIVEN ITEM   #
	#-------------------------------------------------#

	def RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)
		nPos = This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		This.RemoveItemAtPosition( nPos )

		#< @FunctionFluentForm

		def RemoveNthOccurrenceCSQ(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveNthCS(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)

			def RemoveNthCSQ(n, pItem, pCaseSensitive)
				This.RemoveNthCS(n, pItem, pCaseSensitive)
				return This

		def RemoveOccurrenceCS(n, pItem, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)

			def RemoveOccurrenceCSQ(n, pItem, pCaseSensitive)
				This.RemoveOccurrenceCS(n, pItem, pCaseSensitive)
				return This

		#>

	def NthOccurrenceRemovedCS(n, pItem, pCaseSensitive)
		aResult = This.Copy().RemoveNthOccurrencesCSQ(n, pItem, pCaseSensitive).Content()
		return aResult

		def NthRemovedCS(n, pItem, pCaseSensitive)
			return This.NthOccurrenceRemovedCS(n, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pItem)
		This.RemoveNthOccurrenceCS(n, pItem, TRUE)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pItem)
			This.RemoveNthOccurrence(n, pItem)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveNth(n, pItem)
			This.RemoveNthOccurrence(n, pItem)

			def RemoveNthQ(n, pItem)
				This.RemoveNth(n, pItem)
				return This

		def RemoveOccurrence(n, pItem)
			This.RemoveNth(n, pItem)

			def RemoveOccurrenceQ(n, pItem)
				This.RemoveOccurrence(n, pItem)
				return This
		#>

	def NthOccurrenceRemoved(n, pItem)
		aResult = This.Copy().RemoveNthOccurrencesQ(n, pItem).Content()
		return aResult

		def NthRemoved(n, pItem)
			return This.NthOccurrenceRemoved(n, pItem)

	  #----------------------------------------------#
	 #   REMOVING THE FIRST OCCURRENCE OF AN ITEM   #
	#----------------------------------------------#

	def RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

		This.RemoveItemAtPosition( This.FindFirstOccurrenceCS(pItem, pCaseSensitive) )


		#< @FunctionFluentForm

		def RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFirstCSQ(pItem, pCaseSensitive)
				This.RemoveFirstCS(pItem, pCaseSensitive)
				return This

		#>

		#< @FunctionMisspelledForms

		def RemoveFristOccurrenceCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFristOccurrenceCSQ(pItem, pCaseSensitive)
				return RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive)

		#--

		def RemoveFristCS(pItem, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pItem, pCaseSensitive)

			def RemoveFristCSQ(pItem, pCaseSensitive)
				return This.RemoveFirstCSQ(pItem, pCaseSensitive)

		#>

	def FirstOccurrenceRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveFirstOccurrenceCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def FirstRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)

		def FristRemovedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pItem, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pItem)
		This.RemoveFirstOccurrenceCS(pItem, TRUE)


		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pItem)
			This.RemoveFirstOccurrence(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirst(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFirstQ(pItem)
				This.RemoveFirst(pItem)
				return This

		#>

		#< @FunctionMisspelledForms

		def RemoveFristOccurrence(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFristOccurrenceQ(pItem)
				return RemoveFirstOccurrenceQ(pItem)

		#--

		def RemoveFrist(pItem)
			This.RemoveFirstOccurrence(pItem)

			def RemoveFristQ(pItem)
				return This.RemoveFirstQ(pItem)

		#>

	def FirstOccurrenceRemoved(pItem)
		aResult = This.Copy().RemoveFirstOccurrenceQ(pItem).Content()
		return aResult

		def FirstRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

		#-- MISSPELLED

		def FristOccurrenceRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

		def FristRemoved(pItem)
			return This.FirstOccurrenceRemoved(pItem)

	  #--------------------------------------------------#
	 #   REMOVING THE LAST OCCURRENCE OF A GIVEN ITEM   #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pItem, pCaseSensitive)
		n = This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		if n <= This.NumberOfItems()
			This.RemoveItemAtPosition( n )
		ok

		#< @FunctionFluentForm

		def RemoveLastOccurrenceCSQ(pItem, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pItem, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastCS(pItem, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pItem, pCaseSensitive)

			def RemoveLastCSQ(pItem, pCaseSensitive)
				This.RemoveLastCS(pItem, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pItem, pCaseSensitive)
		aResult = This.Copy().RemoveLastOccurrenceCSQ(pItem, pCaseSensitive).Content()
		return aResult

		def LastRemovedCS(pItem, pCaseSensitive)
			return This.LastOccurrenceRemovedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pItem)
		n = This.FindLastOccurrence(pItem)

		if n <= This.NumberOfItems()
			This.RemoveItemAtPosition( n )
		ok

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pItem)
			This.RemoveLastOccurrence(pItem)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLast(pItem)
			This.RemoveLastOccurrence(pItem)

			def RemoveLastQ(pItem)
				This.RemoveLast(pItem)
				return This

		#>

	def LastOccurrenceRemoved(pItem)
		aResult = This.Copy().RemoveLastOccurrenceQ(pItem).Content()
		return aResult

		def LastRemoved(pItem)
			return This.LastOccurrenceRemoved(pItem)

	   #----------------------------------------------#
	  #   REMOVING NEXT NTH OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST   #
	#----------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstItem, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastItem, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection   = This.SectionQ(pnStartingAt, :LastItem)
		anPos = oSection.FindAllCS(pItem, pCaseSensitive)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt - 1).Content()
			nPos = anPos[n]
	
			This.RemoveItemAtPosition(nPos)
		ok

		#< @FuntionFluentForm

		def RemoveNextNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This

		#<

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthNextOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
				return This

		#>

	def NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		aResult  = This.Copy().
				RemoveNthNextOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive).
				Content()

		return aResult

		def NextNthOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthNextOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pItem, pnStartingAt)
		This.RemoveNextNthOccurrenceCS(n, pItem, pnStartingAt, TRUE)

		#< @FuntionFluentForm

		def RemoveNextNthOccurrenceQ(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)
			return This

		#<

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrence(n, pItem, pnStartingAt)
			This.RemoveNextNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNthNextOccurrenceQ(n, pItem, pnStartingAt)
				This.RemoveNthNextOccurrence(n, pItem, pnStartingAt)
				return This

		#>

	def NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

		aResult  = This.Copy().
				RemoveNthNextOccurrenceQ(n, pItem, pnStartingAt).
				Content()

		return aResult

		def NextNthOccurrenceRemoved(n, pItem, pnStartingAt)
			return This.NthNextOccurrenceRemoved(n, pItem, pnStartingAt)

	   #-----------------------------------------------#
	  #   REMOVING NEXT OCCURRENCE OF AN ITEM         #
	 #   STARTING AT A GIVEN POSITION IN THE LIST    #
	#-----------------------------------------------#

	def RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pItem, pnStartingAt, pCaseSensitive)

		def RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitiy)
			return This

		def RemoveSCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextCSQ(pItem, pnStartingAt, pCaseSensitive)
				This.RemoveSCS(pItem, pnStartingAt, pCaseSensitive)
				return This

	def NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)
		aResult =  This.Copy().
				RemoveNextOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive).
				Content()
		return aResult

		def NextRemovedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.NextOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pItem, pnStartingAt)
		This.RemoveNextNthOccurrence(1, pItem, pnStartingAt)

		def RemoveNextOccurrenceQ(pItem, pnStartingAt)
			This.RemoveNextOccurrence(pItem, pnStartingAt)
			return This

		def RemoveNext(pItem, pnStartingAt)
			This.RemoveNextOccurrence(pItem, pnStartingAt)

			def RemoveNextQ(pItem, pnStartingAt)
				This.RemoveNext(pItem, pnStartingAt)
				return This

	def NextOccurrenceRemoved(pItem, pnStartingAt)
		aRersult =  This.Copy().
				RemoveNextOccurrenceQ(pItem, pnStartingAt).
				Content()
		return aRersult

		def NextRemoved(pItem, pnStartingAt)
			return This.NextOccurrenceRemoved(pItem, pnStartingAt)

	   #----------------------------------------------------#
	  #   REMOVING MANY NEXT NTH OCCURRENCES OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST         #
	#----------------------------------------------------#

	def RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			RemoveNexNthOccurrences([2, 3], :of = "A", :StartingAt = 3)
			? Content() # !--> [ "A" , "B", "A", "C", "D" ]
		}		

		*/

		if NOT (isList(panList) and StzListQ(panList).IsListOfNumbers() and
		        StzListQ(panList).NumberOfItemsW("StzNumberQ(@item).IsBetween(1, " + This.NumberOfItems() + ")") = len(panList) )

			StzRaise("Incorrect param! panList must be a list of numbers between 1 and This.NumberOfItems().")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstItem, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastItem, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok
			
		oSection = This.SectionQ(pnStartingAt, :LastItem)

		anPos  = 	oSection.
				FindAllCSQR(pItem, pCaseSensitive, :stzListOfNumbers).
				AddToEachQ(pnStartingAt-1).
				Content()

		anPosToBeRemoved = []
		nLen = len(panList)
		nLenPos = len(anPos)

		for i = 1 to nLen
			if i <= nLenPos
				anPosToBeRemoved +  anPos[panList[i]]
			ok
		next

		This.RemoveItemsAtThesePositionsCS(anPosToBeRemoved, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthNextOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
				return This

		def RemoveNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNextOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthNextOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
				return This
		#>

	def NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		aResult =  This.
			   RemoveNextNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive).
			   Content()

		return aResult

		def NthNextOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.NextNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextNthOccurrences(panList, pItem, pnStartingAt)
		This.RemoveNextNthOccurrencesCS(panList, pItem, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthNextOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
				return This

		def RemoveNextOccurrences(panList, pItem, pnStartingAt)
			This.RemoveNextNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNextOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemoveNthNextOccurrences(panList, pItem, pnStartingAt)
				return This
		#>

	def NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		aResult =  This.
			   RemoveNextNthOccurrencesQ(panList, pItem, pnStartingAt).
			   Content()

		return aResult

		def NthNextOccurrencesRemoved(panList, pItem, pnStartingAt)
			return This.NextNthOccurrencesRemoved(panList, pItem, pnStartingAt)

	   #--------------------------------------------------#
	  #   REMOVING PREVIOUS NTH OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST       #
	#--------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstItem, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastItem, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection   = This.SectionQ(1, pnStartingAt)
		aPositions = oSection.FindAllCS(pItem, pCaseSensitive)

		nPosition = aPositions[ len(aPositions) - n + 1 ]

		This.RemoveItemAtPosition(nPosition)

		def RemovePreviousNthOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This

		def RemoveNthPreviousOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthPreviousOccurrenceCS(n, pItem, pnStartingAt, pCaseSensitive)
				return This

	def NthPreviousOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

		aResult =  This.Copy().
				RemoveNthPreviousOccurrenceCSQ(n, pItem, pnStartingAt, pCaseSensitive).
				Content()

		return This

		def PreviousNthOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)
			return This.NthPreviousOccurrenceRemovedCS(n, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pItem, pnStartingAt)
		This.RemovePreviousNthOccurrenceCS(n, pItem, pnStartingAt, TRUE)

		def RemovePreviousNthOccurrenceQ(n, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrence(n, pItem, pnStartingAt)
			return This

		def RemoveNthPreviousOccurrence(n, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrence(n, pItem, pnStartingAt)

			def RemoveNthPreviousOccurrenceQ(n, pItem, pnStartingAt)
				This.RemoveNthPreviousOccurrence(n, pItem, pnStartingAt)
				return This

	def NthPreviousOccurrenceRemoved(n, pItem, pnStartingAt)

		aResult =  This.Copy().
				RemoveNthPreviousOccurrenceQ(n, pItem, pnStartingAt).
				Content()

		return This

		def PreviousNthOccurrenceRemoved(n, pItem, pnStartingAt)
			return This.NthPreviousOccurrenceRemoved(n, pItem, pnStartingAt)

	   #----------------------------------------------#
	  #   REMOVING PREVIOUS OCCURRENCE OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST   #
	#----------------------------------------------#

	def RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pItem, pnStartingAt, pCaseSensitive)

		def RemovePreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This

		def RemovePreviousCS(pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

	def PreviousOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)
		aResult =  This.Copy().
				RemovePreviousOccurrenceCSQ(pItem, pnStartingAt, pCaseSensitive).
				Content()
		return This

		def PreviousRemovedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousOccurrenceRemovedCS(pItem, pnStartingAt, pCaseSensitive)

	# WITHOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pItem, pnStartingAt)
		This.RemovePreviousOccurrenceCS(pItem, pnStartingAt, TRUE)

		def RemovePreviousOccurrenceQ(pItem, pnStartingAt)
			This.RemovePreviousOccurrence(pItem, pnStartingAt)
			return This

		def RemovePrevious(pItem, pnStartingAt)
			This.RemovePreviousOccurrence(pItem, pnStartingAt)

	def PreviousOccurrenceRemoved(pItem, pnStartingAt)
		aResult =  This.Copy().
				RemovePreviousOccurrenceQ(pItem, pnStartingAt).
				Content()
		return This

		def PreviousRemoved(pItem, pnStartingAt)
			return This.PreviousOccurrenceRemoved(pItem, pnStartingAt)

	   #--------------------------------------------------------#
	  #   REMOVING MANY PREVIOUS NTH OCCURRENCES OF AN ITEM    #
	 #   STARTING AT A GIVEN POSITION IN THE LIST             #
	#--------------------------------------------------------#

	def RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
		/* Example

		StzListQ([ "A" , "B", "A", "C", "A", "D", "A" ]) {
			RemovePreviousNthOccurrences([2, 3], :of = "A", :StartingAt = 5)
			? Content() #--> [ "A" , "B", "C", "D", "A" ]
		}		

		*/

		if NOT (isList(panList) and StzListQ(panList).IsListOfNumbers() and
		        StzListQ(panList).NumberOfItemsW("StzNumberQ(@item).IsBetween(1, " + This.NumberOfItems() + ")") = len(panList) )

			StzRaise("Incorrect param! panList must be a list of numbers between 1 and This.NumberOfItems().")
		ok

		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstItem, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastItem, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok
			
		oSection = This.SectionQ(1, pnStartingAt)

		anPos = oSection.FindAllCSQ(pItem, pCaseSensitive).ItemsReversed()

		anPosToBeRemoved = []
		nLen = len(panList)
		nLenPositions = len(anPos)

		for i = 1 to nLen
			if i <= nLenPso
				anPosToBeRemoved + anPos[panList[i]]
			ok
		next

		This.RemoveItemsAtThesePositionsCS(anPosToBeRemoved, pCaseSensitive)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemovePreviousOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				This.RemovePreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
				return This

		def RemoveNthPreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
			This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)

			def RemoveNthPreviousOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive)
				This.RemoveNthPreviousOccurrencesCS(panList, pItem, pnStartingAt, pCaseSensitive)
				return This
		#>

	def PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

		aResult = This.
			  RemovePreviousNthOccurrencesCSQ(panList, pItem, pnStartingAt, pCaseSensitive).
			  Content()

		return aResult

		def NthPreviousOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)
			return This.PreviousNthOccurrencesRemovedCS(panList, pItem, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)
		This.RemovePreviousNthOccurrencesCS(panList, pItem, pnStartingAt, TRUE)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemovePreviousOccurrences(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemovePreviousOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemovePreviousOccurrences(panList, pItem, pnStartingAt)
				return This

		#--

		def RemoveNthPreviousOccurrences(panList, pItem, pnStartingAt)
			This.RemovePreviousNthOccurrences(panList, pItem, pnStartingAt)

			def RemoveNthPreviousOccurrencesQ(panList, pItem, pnStartingAt)
				This.RemoveNthPreviousOccurrences(panList, pItem, pnStartingAt)
				return This
		#>

	def PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

		aResult = This.
			  RemovePreviousNthOccurrencesQ(panList, pItem, pnStartingAt).
			  Content()

		return aResult

		def NthPreviousOccurrencesRemoved(panList, pItem, pnStartingAt)
			return This.PreviousNthOccurrencesRemoved(panList, pItem, pnStartingAt)

	  #---------------------------------------------------#
	 #   REMOVING AN ITEM BY SPECIFYING ITS POSITION    #
	#---------------------------------------------------#

	def RemoveItemAtPosition(n)

		# Checking param correctness

		if isString(n)
			if Q(n).IsOneOfThese([
				:First, :FirstPosition,
			      	:FirstItem, :FirstItem ])
				  
				n = 1

			but Q(n).IsOneOfThese([
				:Last, :LastPosition,
			     	:LastItem, :LastItem ])

				n = This.NumberOfItems()
			ok
		ok

		if NOT (isNumber(n) and n != 0 )
			StzRaise("Incorrect param! n must be a number different from zero.")
		ok

		# Doing the job

		if n <= This.NumberOfItems()
			ring_del( @aContent, n )

		ok

		#< @FunctionFluentForm

		def RemoveItemAtPositionQ(n)
			This.RemoveItemAtPosition(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveAt(n)
			This.RemoveItemAtPosition(n)

			def RemoveAtQ(n)
				This.RemoveAt(n)
				return This

		def RemoveAtPosition(n)
			This.RemoveItemAtPosition(n)

			def RemoveAtPositionQ(n)
				This.RemoveAtPosition(n)
				return This

		def RemoveItemAt(n)
			This.RemoveItemAtPosition(n)

			def RemoveItemAtQ(n)
				This.RemoveItemAt(n)
				return This

		#--

		def RemoveNthItem(n)
			This.RemoveItemAtPosition(n)

			def RemoveNthItemQ(n)
				This.RemoveNthItem(n)
				return This

		#>

	def ItemAtPositionNRemoved(n)
		aResult = This.Copy().RemoveItemAtPositionQ(n).Content()
		return This

		def NthItemRemoved(n)
			return This.ItemAtPositionNRemoved(n)

	  #--------------------------------------#
	 #    REMOVING FIRST ITEM IN THE LIST   #
	#--------------------------------------#

	def RemoveFirstItem()
		This.RemoveItemAtPosition(1)

		#< @FunctionFluentForm

		def RemoveFirstItemQ()
			This.RemoveFirstItem()
			return This

		#>

		#< @FunctionMisspelledForm

		def RemoveFristItem()
			This.RemoveFirstItem()

			def RemoveFristItemQ()
				return This.RemoveFirstItemQ()

		#>

	def FirstItemRemoved()
		aResult = This.Copy().RemoveFirstItemQ().Content()
		return aResult

		#-- MISSPELLED

		def FristItemRemoved()
			return This.FirstItemRemoved()

	  #-------------------------------------#
	 #    REMOVING LAST ITEM IN THE LIST   #
	#-------------------------------------#

	def RemoveLastItem()
		This.RemoveItemAtPosition( This.NumberOfItems() )

		#< @FunctionFluentForm

		def RemoveLastItemQ()
			This.RemoveLastItem()
			return This

		#>

	def LastItemRemoved()
		aResult = This.Copy().RemoveLastItemQ().Content()
		return aResult

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST ITEMS  #
	#----------------------------------#

	def RemoveFirstAndLastItems()
		This.RemoveFirstItem()
		This.RemoveLastItem()

		#< @FunctionFluentForm

		def RemoveFirstAndLastItemsQ()
			This.RemoveFirstAndLastItems()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstItems()
			This.RemoveFirstAndLastItems()

			def RemoveLastAndFirstItemsQ()
				This.RemoveLastAndFirstItems()
				return This

		def RemoveFirstAndLast()
			This.RemoveFirstAndLastItems()

			def RemoveFirstAndLastQ()
				This.RemoveFirstAndLast()

		def RemoveLastAndFirst()
			This.RemoveFirstAndLastItems()

			def RemoveLastAndFirstQ()
				This.RemoveFirstAndLast()

		#--

		def RemoveFirstItemAndLastItem()
			This.RemoveFirstAndLastItems()

			def RemoveFirstItemAndLastItemQ()
				This.RemoveFirstItemAndLastItem()
				return This

		def RemoveLastItemAndFirstItem()
			This.RemoveFirstAndLastItems()

			def RemoveLastItemAndFirstItemQ()
				This.RemoveLastItemAndFirstItem()
				return This

		#>

	def FirstAndLastItemsRemoved()
		aResult = This.Copy().RemoveFirstAndLastItemsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def LastAndFirstItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def FirstAndLastRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFirstRemoved()
			return This.FirstAndLastItemsRemoved()

		#--

		def FirstItemAndLastItemRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastItemAndFirstItemRemoved()
			return This.FirstAndLastItemsRemoved()

		#>

		#< @FunctionMisspelledForms

		def FristAndLastItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFristItemsRemoved()
			return This.FirstAndLastItemsRemoved()

		def FristAndLastRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastAndFristRemoved()
			return This.FirstAndLastItemsRemoved()

		#--

		def FristItemAndLastItemRemoved()
			return This.FirstAndLastItemsRemoved()

		def LastItemAndFristItemRemoved()
			return This.FirstAndLastItemsRemoved()

		#>

	  #--------------------------------------#
	 #  REMOVING A GIVEN NTH ITEM (IF ANY)  #
	#--------------------------------------#

	def RemoveThisNthItemCS(n, pItem, pCaseSensitive)
		NthItem = This.NthItem(n)
		bItemExists = FALSE

		if isString( pItem )
			if Q(NthItem).IsEqualToCS(pItem, pCaseSensitive)
				bItemExists = TRUE
			ok

		else
			if Q(NthItem).IsEqualTo(pItem)
				bItemExists = TRUE
			ok
		ok

		if bItemExists
			This.RemoveNthItem(n)
		ok

		def RemoveThisNthItemCSQ(n, pItem, pCaseSensitive)
			This.RemoveThisNthItemCS(n, pItem, pCaseSensitive)
			return This

	def ThisNthItemRemovedCS(n, pItem, pCaseSensitive)
		return This.RemoveThisNthItemCSQ(n, pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthItem(n, pItem)
		This.RemoveThisNthItemCS(n, pItem, TRUE)
			
		def RemoveThisNthItemQ(n, pItem)
			This.RemoveThisNthItemCS(n, pItem)
			return This

	def ThisNthItemRemoved(n, pItem)
		return This.RemoveThisNthItemQ(n, pItem).Content()

	  #------------------------------------------------------#
	 #  REMOVING THE GIVEN FIRST ITEM (IA ANY) IN THE LIST  #
	#------------------------------------------------------#

	def RemoveThisFirstItemCS(pItem, pCaseSensitive)
		This.RemoveThisNthItemCS(1, pItem, pCaseSensitive)

		def RemoveThisFirstItemCSQ(pItem, pCaseSensitive)
			This.RemoveThisFirstItemCS(pItem, pCaseSensitive)
			return This

	def ThisFirstItemRemovedCS(pItem, pCaseSensitive)
		return This.Copy().RemoveThisFirstItemCSQ(pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstItem(pItem)
		This.RemoveThisNthItemCS(1, pItem, TRUE)

		def RemoveThisFirstItemQ(pItem)
			This.RemoveThisFirstItem(pItem)
			return This

	def ThisFirstItemRemoved(pItem)
		return This.Copy().RemoveThisFirstItemQ(pItem, pCaseSensitive).Content()

	  #-----------------------------------------------------#
	 #  REMOVING THE GIVEN LAST ITEM (IA ANY) IN THE LIST  #
	#-----------------------------------------------------#

	def RemoveThisLastItemCS(pItem, pCaseSensitive)
		This.RemoveThisNthItemCS(This.NumberOfItems(), pItem, pCaseSensitive)

		def RemoveThisLastItemCSQ(pItem, pCaseSensitive)
			This.RemoveThisLastItemCS(pItem, pCaseSensitive)
			return This

	def ThisLastItemRemovedCS(pItem, pCaseSensitive)
		return This.Copy().RemoveThisLastItemCSQ(pItem, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastItem(pItem)
		This.RemoveThisNthItemCS(1, pItem, TRUE)

		def RemoveThisLastItemQ(pItem)
			This.RemoveThisLastItem(pItem)
			return This

	def ThisLastItemRemoved(pItem)
		return This.Copy().RemoveThisLastItemQ(pItem, pCaseSensitive).Content()

	  #=====================================================#
	 #  REMOVING MANY ITEMS BY SPECIFYING THEIR POSITIONS  #
	#=====================================================#

	def RemoveItemsAtPositions(panPos)

		if CheckParams()

			if NOT isList(panPos)
				StzRaise("Incorrect pram! panPos must be a list.")
			ok
			nLen = len(panPos)
			if nLen = 0
				return
			ok
	
			for i = 1 to nLen
				if isString(panpos[i])
					if panPos[i] = :First or panPos[i] = :FirstPosition
						paPos[i] = 1
	
					but panPos[i] = :Last or panPos[i] = :LastPosition
						paPos[i] = This.NumberOfItems()
					ok
				ok
			next

		ok

		anPosSorted = ring_sort(panPos)
		
		for i = nLen to 1 step -1
			ring_remove(@aContent, anPosSorted[i])
		next

		#< @FunctionFluentForm

		def RemoveItemsAtPositionsQ(panPos)
			This.RemoveItemsAtPositions(panPos)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveItemsAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveItemsAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAt(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveManyItemsAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveManyItemsAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		#--

		def RemoveItemsAtThesePositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveItemsAtThesePositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		def RemoveAtPositions(panPos)
			This.RemoveItemsAtPositions(panPos)

			def RemoveAtPositionsQ(panPos)
				return This.RemoveItemsAtPositionsQ(panPos)

		#>
		
	def ItemsAtThesePositionsRemoved(panPos)
		aResult = This.Copy().RemoveItemsAtThesePositionsQ(panPos).Content()
		return aResult

	  #-------------------------------#
	 #   REMOVING A RANGE OF ITEMS   #
	#-------------------------------#

	def RemoveRange(pnStart, pnRange)
	
		# Checking the correctness of the pnStart param

		if isList(pnStart) and Q(pnStart).IsFromNamedParam()
			pnStart = pnStart[2]
		ok

		if isString(pnStart)
			if Q(pnStart).IsOneOfThese([
					:First, :FirstPosition,
				      	:FirstItem, :FirstItem ])
				  
				pnStart = 1

			but Q(pnStart).IsOneOfThese([
					:Last, :LastPosition,
				      	:LastItem, :LastItem ])

				n = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStart)
			StzRaise("Incorrect param! n must be a number.")
		ok

		# Checking the correctness of the pnRange param

		if isList(pnRange) and
		   isItem(pnRange[1]) and

		   ( Q(pnRange[1]).IsOneOfTheseCS([ :UpToN, :UpToNItems, :UpToNItems ]) )

		   	pnRange = pnRange[2]
		ok
	
		if NOT isNumber(pnRange)
			StzRaise("Incorrect param type! pnRange must be a number.")
		ok

		# Doing the job

		This.RemoveSection( pnStart, (pnStart + pnRange - 1) )

		#< @FunctionFluentForm

		def RemoveRangeQ(pnStart, pnRange)
			This.RemoveRange(pnStart, pnRange)
			return This
		#>

	def RangeRemoved(pnStart, pnRange)
		aResult = This.Copy().RemoveRangeQ(pnStart, pnRange)
		return aResult

	  #-----------------------------------#
	 #   REMOVING MANY RANGES OF ITEMS   #
	#-----------------------------------#

	def RemoveManyRanges(panRanges)

		anSections = []
		for anRange in panRanges
			anSections + RangeToSection(anRange)
		next

		This.RemoveManySections(anSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManyRanges(paRanges)
			return This

	def ManyRangesRemoved(paRanges)
		aResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return aResult

	  #---------------------------------#
	 #   REMOVING A SECTION OF ITEMS   #
	#---------------------------------#

	def RemoveSection(n1, n2)

		nLen = len(@aContent)

		# Checking params correctness

		if CheckParams() = TRUE
			if isList(n1) and
				( Q(n1).IsFromNamedParam() or Q(n1).IsFromNamedParam()  or
				  Q(n1).IsFromPositionNamedParam() )
	
				n1 = n1[2]
			ok
	
			if isList(n2) and ( Q(n2).IsToNamedParam() or Q(n2).IsToPositionNamedParam() )
				n2 = n2[2]
			ok
	
			if isString(n1) and
				( Q(n1).IsOneOfThese([
					:First, :FirstPosition,
					:FirstItem, :FirstItem ]) )
	
				n1 = 1
			ok
	
			if isString(n2) and
				( Q(n2).IsOneOfThese([
					:Last, :LastPosition,
					:LastItem, :LastItem ]) )
	 
				n2 = This.NumberOfItems()
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok

			if (n1 < 1 or n1 > nLen)
				StzRaise("Incorrect param value! n1 is out of range.")
			ok

			if (n2 < 1 or n2 > nLen)
				StzRaise("Incorrect param value! n2 is out of range.")
			ok

			if n2 < n1
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

		ok

		# Doing the job

		if EarlyCheck()
			if nLen = 0
				return
			ok
		
			if (n1 = 1 and n2 = nLen) or (n1 = nLen and n2 = 1)
				@aContent = []
				return
			ok
	
			if n1 = n2
				This.removeItemAtPosition(n1)
				return
			ok
		ok

		aResult = []

		for i = 1 to n1 - 1
			aResult + @aContent[i]
		next

		for i = n2 + 1 to nLen
			aResult + @aContent[i]
		next

		@aContent = aResult

		#< @FunctionFluentForm

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

		#>

	def SectionRemoved(n1, n2)
		aResult = This.Copy().RemoveSectionQ(n1, n2)
		return aResult

	  #-------------------------------------#
	 #   REMOVING MANY SECTIONS OF ITEMS   #
	#-------------------------------------#

	def RemoveManySections(paSections)

		if isList(paSections)
			oSections = new stzList(paSections)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paSections = oSections.Content()
			
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzList > RemoveManySections(paSections)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paSections) is not a list of pairs of numbers."
			])

		ok

		nLen = len(paSections)
		if nLen = 0
			return
		ok

		aSorted = QR(paSections, :stzListOfPairs).Sorted()

		for i = nLen to 1 step -1
			This.RemoveSection(aSorted[i][1], aSorted[i][2])
		next

		def RemoveManySectionsQ(paSections)
			This.RemoveManySections(paSections)
			return This

		def RemoveSections(paSections)
			This.RemoveManySections(paSections)

	def ManySectionsRemoved(paSections)
		aResult = This.Copy().RemoveManySectionsQ(paSections).Content()
		return aResult

		def SectionsRemoved(paSections)

	  #----------------------------------#
	 #   REMOVING ANY ITEM FROM START   #
	#==================================#

	def RemoveAnyItemFromStartCS(pItem, pCaseSensitive)

		aItems = This.Items()
		nLen = len(aItems)
		if nLen = 0
			return
		ok

		n = 0

		for i = 1 to nLen
			if Q(aItems[i]).IsEqualToCS(pItem, pCaseSensitive)
				n++
			else
				exit
			ok
		next i

		if n > 0
			This.RemoveSection( 1, n )
		ok


		def RemoveAnyItemFromStartCSQ(c, pCaseSensitive)
			This.RemoveAnyItemFromStartCS(c, pCaseSensitive)
			return This

	def AnyItemFromStartRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveAnyItemFromStartCSQ(c, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyItemFromStart(c)
		This.RemoveAnyItemFromStartCS(c, TRUE)
		return This

		def RemoveAnyItemFromStartQ(c)
			This.RemoveAnyItemFromStart(c)
			return This

	def AnyItemFromStartRemoved(c)
		return This.AnyItemFromStartRemovedCS(c, TRUE)

	  #---------------------------------#
	 #   REMOVING ANY ITEM FROM END    #
	#---------------------------------#

	def RemoveAnyItemFromEndCS(c, pCaseSensitive)

		aItems = This.Items()
		nLen = len(aItems)
		if nLen = 0
			return
		ok

		n = 0

		for i = nLen to 1 step -1
			if Q(aItems[i]).IsEqualToCS(c, pCaseSensitive)
				n++
			else
				exit
			ok
		next i

		if n > 0
			This.RemoveSection( nLen - n + 1, nLen )
		ok


		def RemoveAnyItemFromEndCSQ(c, pCaseSensitive)
			This.RemoveAnyItemFromEndCS(c, pCaseSensitive)
			return This

	def AnyItemFromEndRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveAnyItemFromEndCSQ(c, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyItemFromEnd(c)
		This.RemoveAnyItemFromEndCS(c, TRUE)
		return This

		def RemoveAnyItemFromEndQ(c)
			This.RemoveAnyItemFromEnd(c)
			return This

	def AnyItemFromEndRemoved(c)
		return This.AnyItemFromEndRemovedCS(c, TRUE)

	  #========================================#
	 #    SWAPPING TWO SECTIONS OF THE LIST   # 
	#========================================#

	def SwapSections( panSection1, panSection2 )
		if isList(panSection2) and Q(panSection2).IsWithOrAndNamedParams()
			panSection2 = panSection2[2]
		ok

		if NOT @BothArePairsOfNumbers(panSection1, panSection2)
			StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
		ok

		aSorted = QR([ panSection1, panSection2 ], :stzListOfPairs).Sorted()

		anFirstSection = []
		anLastSection  = []

		if Q(aSorted[1]).IsEqualTo(panSection1)
			anFirstSection = panSection1
			anLastSection  = panSection2

		else
			anFirstSection = panSection2
			anLastSection  = panSection1
		ok

		aResult = ListsMerge([
			This.Section(anLastSection[1], anLastSection[2]),
			This.Section(anFirstSection[2] + 1, anLastSection[1] - 1),
			This.Section(anFirstSection[1], anFirstSection[2])
		])

		This.UpdateWith(aResult)


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2)
		return cResult

	  #------------------------------------#
	 #   REMOVING ALL ITEMS IN THE LIST   #
	#------------------------------------#
	
	def RemoveAllItems()
		@aContent = []

		#< @FunctionFluentForm

		def RemoveAllItemsQ()
			This.RemoveAllItems()
			return This

		#>

		#< @FunctionAlternativeForm

		def Clear()
			This.RemoveAllItems()

			def ClearQ()
				This.Clear()
				return This

		#>

	def AllItemsRemoved()
		return []

	  #--------------------------------------------#
	 #   REMOVING ITEMS UNDER A GIVEN CONDITION   #
	#============================================#

	def RemoveW(pCondition)
		/*
		Example:

		o1 = new stzList([ "1", "a", "2", "b", "3", "c" ])
		o1.RemoveAllItemsW(:Where = '{ StzCharQ(This[@i]).IsANumber() }')
		? o1.Content()

		#--> Gives: [ "a", "b", "c" ]
		*/

		# Checking the provided param for the pCondition

		anPos = This.FindW(pCondition)
		This.RemoveItemsAtThesePositions(anPos)

		#< @FunctionFluentForm

		def RemoveWQ(pCondition)
			This.RemoveW(pCondition)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsW(pCondition)
			This.RemoveW(pCondition)

			def RemoveItemsWQ(pCondition)
				This.RemoveItemsW(pCondition)
				return This

		#>

	def ItemsRemovedW(pCondition)
		aResult = This.Copy().RemoveItemsWQ(pCondition).Content()
		return aResult

	  #------------------------------------------------------------#
	 #   REMOVING ITEMS UNDER A GIVEN CONDITION -- WXT/EXTENDED   #
	#------------------------------------------------------------#

	def RemoveWXT(pCondition)
		/*
		Example:

		o1 = new stzList([ "1", "a", "2", "b", "3", "c" ])
		o1.RemoveAllItemsWXT(:Where = '{ StzCharQ(@item).IsANumber() }')
		? o1.Content()

		#--> Gives: [ "a", "b", "c" ]
		*/

		# Checking the provided param for the pCondition

		anPos = This.FindWXT(pCondition)
		This.RemoveItemsAtThesePositions(anPos)

		#< @FunctionFluentForm

		def RemoveWXTQ(pCondition)
			This.RemoveWXT(pCondition)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveItemsWXT(pCondition)
			This.RemoveWXT(pCondition)

			def RemoveItemsWXTQ(pCondition)
				This.RemoveItemsWXT(pCondition)
				return This

		#>

	def ItemsRemovedWXT(pCondition)
		aResult = This.Copy().RemoveItemsWXTQ(pCondition).Content()
		return aResult

	  #====================================#
	 #  EXTRACTING AN ITEM FROM THE LIST  #
	#====================================#

	def ExtractCS(pItem, pCaseSensitive)
		if NOT This.ContainsCS(pItem, pCaseSensitive)
			StzRaise("Can't extract the item! It does not exist in the list.")
		ok

		This.RemoveCS(pItem, pCaseSensitive)
		return pItem

		def PopCS(pItem, pCaseSensitive)
			return This.ExtractCS(pItem, pCaseSensitive)

	def ItemExtractedCS(pItem, pCaseSensitive)
		return This.ExtractCS(pItem, pCaseSensitive)

		def ItemPoppedCS(pItem, pCaseSensitive)
			return This.ItemExtractedCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Extract(pItem)
		return This.ExtractCS(pItem, TRUE)

		def Pop(pItem)
			return This.Extract(pItem)

	def ItemExtracted(pItem)
		return This.Extract(pItem)

		def ItemPopped(pItem)
			return This.ItemExtracted(pItem)

	  #---------------------------------------#
	 #  EXTRACTING MANY ITEMS FROM THE LIST  #
	#---------------------------------------#

	def ExtractManyCS(paItems, pCaseSensitive)
		if NOT This.ContainsManyCS(paItems, pCaseSensitive)
			StzRaise("Can't extract the items! Items in paItems do not exist in the list.")
		ok

		This.RemoveManyCS(paItems, pCaseSensitive)
		return paItems

		#< @FunctionAlternativeForms

		def PopManyCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#--

		def ExtractTheseCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		def PopTheseCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#>

	def ManyItemsExtractedCS(paItems, pCaseSensitive)
		return This.ExtractManyCS(paItems, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ManySubStringsPoppedCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		def TheseSubStringsExtractedCS(paItems, pCaseSensitive)
			return This.ManySubStringsExtractedCS(paItems, pCaseSensitive)

		def TheseSubStringsPoppedCS(paItems, pCaseSensitive)
			return This.ExtractManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(paItems)
		return This.ExtractManyCS(paItems, :pCaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def PopMany(paItems)
			return This.ExtractMany(paItems)

		#--

		def ExtractThese(paItems)
			return This.ExtractMany(paItems)

		def PopThese(paItems)
			return This.ExtractMany(paItems)

		#>

	def ManyItemsExtracted(paItems)
		return This.ExtractMany(paItems)

		#< @FunctionAlternativeForms

		def ManySubStringsPopped(paItems)
			return This.ExtractMany(paItems)

		def TheseSubStringsExtracted(paItems)
			return This.ManySubStringsExtracted(paItems)

		def TheseSubStringsPopped(paItems)
			return This.ExtractMany(paItems)

		#>

	  #------------------------------------------#
	 #  EXTRACTING ALL THE ITEMS FROM THE LIST  #
	#------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

		#< @FunctionAlternativeForms

		def ExtractList()
			return This.ExtractAll()

		def ExtractAllList()
			return This.ExtractAll()

		#--

		def PopAll()
			return This.ExtractAll()

		def PopList()
			return This.ExtractAll()

		def PopAllList()
			return This.ExtractAll()

		#>

	def AllItemsExtracted()
		return This.ExtractAll()

		#< @FunctionAlternativeForms

		def ListExtracted()
			return This.ExtractAll()

		def AllListExtracted()
			return This.ExtractAll()

		#--

		def AllItemsPopped()
			return This.ExtractAll()

		def ListPopped()
			return This.ExtractAll()

		def AllListPopped()
			return This.ExtractAll()
		#>

	  #---------------------------#
	 #  EXTRACTING THE NTH ITEM  #
	#---------------------------#

	def ExtractAt(n)
		if isString(n) and ( n = :Last or n = :LastItem )
			n = This.NumberOfItems()
		ok

		if NOT ( isNumber(n) and Q(n).IsBetween(1, This.NumberOfItems()) )
			StzRaise("Can't extract! n outside of range.")
		ok

		TempItem = This.ItemAt(n)

		This.RemoveAt(n)

		return TempItem

		#< @FunctionAlternativeForms

		def ExtractNthItem(n)
			return This.ExtractAt(n)

		def ExtractItemAtPosition(n)
			return This.ExtractAt(n)

		def ExtractItemAt(n)
			return This.ExtractAt(n)

		#--

		def PopAt(n)
			return This.ExtractAt(n)

		def PopNthItem(n)
			return This.ExtractAt(n)

		def PopItemAtPosition(n)
			return This.ExtractAt(n)

		def PopItemAt(n)
			return This.ExtractAt(n)

		#>

	def NthItemExtracted(n)
		return This.ExtractAt(n)

		def NthItemPopped(n)
			return This.ExtractAt(n)

		def ExtractedAt(n)
			return This.ExtractAt(n)

		def PoppedAt(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST ITEM  #
	#-----------------------------#

	def ExtractFirstItem()
		return This.ExtractAt(1)
 
		def PopFirstItem()
			return This.ExtractFirstItem()

	def FirstItemExtracted()
		return This.ExtractFirstItem()

		def FirstItemPopped()
			return This.ExtractFirstItem()

		#-- MISSPELLED

		def FristItemExtracted()
			return This.FirstItemExtracted()

		def FristItemPopped()
			return This.ExtractFirstItem()

	  #----------------------------#
	 #  EXTRACTING THE LAST ITEM  #
	#----------------------------#

	def ExtractLastItem()
		return This.ExtractAt(This.NumberOfItems())
		#TODO: the line above was:
		# return This.ExtractAt(:Last)
		# but since CheckParams() is used in ExtractAt(),
		# the special value :Last will not be recognosed.
		# That's why I changed it to its actual value NumberOfItems()
		#--> Do the same all over the library!

		def PopLastItem()
			return This.ExtractLastItem()

	def LastItemExtracted()
		return This.ExtractLastItem()

		def LastItemPopped()
			return This.ExtractLastItem()

	  #--------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF AN ITEM  #
	#--------------------------------------------#

	def ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)
		if This.FindNthOccurrenceCS(n, pItem, pCaseSensitive) > 0
			This.RemoveNthOccurrenceCS(n, pItem, pCaseSensitive)
			return pItem
		else
			StzRaise("Can't extract! The list does not contain n occurrences of pItem.")
		ok

		#< @FunctionAlternativeFroms

		def ExtractNthCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def PopNthCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def PopNthOccurrenceCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		#>

	def NthOccurrenceExtractedCS(n, pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthOccurrencePoppedCS(n, pItem, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pItem)
		return This.ExtractNthOccurrenceCS(n, pItem, TRUE)

		#< @FunctionAlternativeFroms

		def ExtractNth(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		def PopNth(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		def PopNthOccurrence(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

		#>

	def NthOccurrenceExtracted(n, pItem)
		return This.ExtractNthOccurrence(n, pItem)

		def NthOccurrencePopped(n, pItem)
			return This.ExtractNthOccurrence(n, pItem)

	  #----------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF AN ITEM  #
	#----------------------------------------------#

	def ExtractFirstCS(pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pItem, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopFirstCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def ExtractFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ExtractFristCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFristCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def ExtractFristOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		def PopFristOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#>

	def FirstOccurrenceExtractedCS(pItem, pCaseSensitive)
		return This.ExtractFirstCS(pItem, pCaseSensitive)

		def FirstOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)

		#-- MISSPELLED

		def FristOccurrenceExtractedCS(pItem, pCaseSensitive)
			return This.FirstOccurrenceExtractedCS(pItem, pCaseSensitive)

		def FristOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractFirstCS(pItem, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pItem)
		return This.ExtractFirstCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def PopFirst(pItem)
			return This.ExtractFirst(pItem)

		def ExtractFirstOccurrence(pItem)
			return This.ExtractFirst(pItem)

		def PopFirstOccurrence(pItem)
			return This.ExtractFirst(pItem)

		#>

		#< @FunctionMisspelledForms

		def ExtractFrist(pItem)
			return This.ExtractFirst(pItem)

		def PopFrist(pItem)
			return This.ExtractFirst(pItem)

		def ExtractFristOccurrence(pItem)
			return This.ExtractFirst(pItem)

		def PopFristOccurrence(pItem)
			return This.ExtractFirst(pItem)

		#>

	def FirstOccurrenceExtracted(pItem)
		return This.ExtractFirst(pItem)

		def FirstOccurrencePopped(pItem)
			return This.ExtractFirst(pItem)

		#-- MISSPELLED

		def FristOccurrenceExtracted(pItem)
			return This.FirstOccurrenceExtracted(pItem)

		def FristOccurrencePopped(pItem)
			return This.ExtractFirst(pItem)

	  #---------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF AN ITEM  #
	#---------------------------------------------#

	def ExtractLastCS(pItem, pCaseSensitive)
		nLast = This.NumberOfOcurrencesCS(pItem, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(nLast, pItem, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopLastCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		def ExtractLastOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		def PopLastOccurrenceCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

		#>

	def LastOccurrenceExtractedCS(pItem, pCaseSensitive)
		return This.ExtractLastCS(pItem, pCaseSensitive)

		def LastOccurrencePoppedCS(pItem, pCaseSensitive)
			return This.ExtractLastCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pItem)
		return This.ExtractLastCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def PopLast(pItem)
			return This.ExtractLast(pItem)

		def ExtractLastOccurrence(pItem)
			return This.ExtractLast(pItem)

		def PopLastOccurrence(pItem)
			return This.ExtractLast(pItem)

		#>

	def LastOccurrenceExtracted(pItem)
		return This.ExtractLast(pItem)

		def LastOccurrencePopped(pItem)
			return This.ExtractLast(pItem)

	  #------------------------------------------------#
	 #  EXTRACTING ITEMS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------#

	def ExtractW(pcCondition)
		aResult = This.ItemsW(pcCondition)
		if len(aResult) = 0
			StzRaise("Can't extract! The condition returns no values at all.")
		ok

		This.RemoveW(pcCondition)
		return aResult

		def PopW(pcCondition)
			return This.ExtractW(pcCondition)

	def ItemsExtractedW(pcCondition)
		return This.ExtractW(pcCondition)

		def ItemsPoppedW(pcCondition)
			return This.ItemsExtractedW(pcCondition)

	  #--------------------------------------#
	 #  EXTRACTING A SECTION FROM THE LIST  #
	#--------------------------------------#

	def ExtractSection(n1, n2)
		if NOT ( Q([n1, n2]).BothAreNumbers() and
		   Q(n1).IsBetween(1, This.NumberOfItems()) and
		   Q(n2).IsBetween(1, This.NumberOfItems()) )

			StzRaise("Can't extract! The section is outside the list.")
		ok

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def PopSection(n1, n2)
			return This.ExtractSection(n1, n2)

		#>

	def SectionExtracted(n1, n2)
		return This.ExtractSection(n1, n2)

		#< @FunctionAlternativeForm

		def SectionPopped(n1, n2)
			return This.SectionExtracted(n1, n2)

		#>

	  #------------------------------------#
	 #  EXTRACTING A RANGE FROM THE LIST  #
	#------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

		def PopRange(nStart, nRange)
			return This.ExtractRange(nStart, nRange)

	def RangeExtracted(nStart, nRange)
		return This.ExtractRange(nStart, nRange)

		def RangePopped(nStart, nRange)
			return This.RangeExtracted(nStart, nRange)

	  #-----------------------------------------------------#
	 #  EXTRACTING NEXT ITEM STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------#

	def ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)
		if This.FindNext(pItem, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pItem does not exist at the specified position.")
		ok

		This.RemoveSCS(pItem, pnStartingAt, pCaseSensitive)
		return pItem

		#< @FunctionAlternativeForms

		def ExtractNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		def PopNextSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def ExtractNextOccurrenceSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)
		return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def NextOccurrenceExtractedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractNextSCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractNext(item, pnStartingAt)
		return This.ExtractNext(item, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def ExtractNextOccurrence(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		def PopNext(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		def PopNextOccurrence(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		#--

		def ExtractNextS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		def ExtractNextOccurrenceS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		def PopNextS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		def PopNextOccurrenceS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		#>

	def NextOccurrenceExtracted(pItem, pnStartingAt)
		return This.ExtractNext(pItem, pnStartingAt)

		#< @FunctionAlternativeForms

		def NextOccurrenceExtractedS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)
	
		def NextOccurrencePopped(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)
	
		def NextOccurrencePoppedS(pItem, pnStartingAt)
			return This.ExtractNext(pItem, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #  EXTRACTING PREVIOUS ITEM STARTING AT A GIVEN POSITION  #
	#---------------------------------------------------------#

	def ExtractPreviousCS(item, pnStartingAt, pCaseSensitive)
		if This.FindPreviousCS(item, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pItem does not exist at the specified position.")
		ok

		This.RemovePreviousCS(item, pnStartingAt, pCaseSensitive)
		return item

		#< @FunctionAlternativeForms

		def ExtractPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def ExtractPreviousSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		def ExtractPreviousOccurrenceSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	def PreviousOccurrenceExtractedCS(pItem, pnStartingAt, pCaseSensitive)
		return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PreviousOccurrenceExtractedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pItem, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractPrevious(item, pnStartingAt)
		return This.ExtractPreviousCS(item, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def ExtractPreviousOccurrence(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		def PopPrevious(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		def PopPreviousOccurrence(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		#--

		def ExtractPreviousS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		def ExtractPreviousOccurrenceS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		def PopPreviousS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		def PopPreviousOccurrenceS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		#>

	def PreviousOccurrenceExtracted(pItem, pnStartingAt)
		return This.ExtractPrevious(pItem, pnStartingAt)

		#< @FunctionAlternativeForms

		def PreviousOccurrenceExtractedS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)
	
		def PreviousOccurrencePopped(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)
	
		def PreviousOccurrencePoppedS(pItem, pnStartingAt)
			return This.ExtractPrevious(pItem, pnStartingAt)

		#>

	  #===================================================================================#
	 #  CHECKING IF THE 2 ITEMS OF THE LIST ARE BOUNDS OF A SUBSTRING IN A GIVEN STRING  #
	#===================================================================================#

	#TODO: Unify the bounds fucntions in stzString and stzList

	def AreBoundsOfCS(pcSubStr, pIn, pCaseSensitive)
		# Supports only strings in pIn
		#TODO: lists will be also supported

		/* EXAMPLE 1

		o1 = new stzList([ "<<", ">>" ])
		? o1.AreBoundsOf("word", :In = "<<word>> and __word__")
		#--> TRUE

		EXAMPLE 2

		o1 = new stzList([ [ "<<", ">>" ], [ "__", "__" ] ])
		? o1.AreBoundsOf("word", :In = "<<word>> and __word__")
		#--> TRUE

		*/

		# Checking the params

		if CheckParams() = TRUE

			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
	
			if NOT ( This.IsPair() or This.IsListOfPairs() )
				StzRaise("Can't check bounds! List must be a pair or a list of pairs.")
			ok
	
			if isList(pIn) and Q(pIn).IsInNamedParam()
				pIn = pIn[2]
			ok
	
			if NOT isString(pIn)
				StzRaise("Incorrect param type! pIn must be a string.")
			ok

		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		oSubStr = new stzString(pcSubStr)
		bResult = FALSE

		if This.IsListOfPairs()
			bResult = TRUE

			for i = 1 to nLen
				bResult = oSubStr.IsBoundedByIn(aContent[i], pIn)
				if bResult = FALSE
					exit
				ok
			next
		else
			bResult = oSubStr.IsBoundedByIn(aContent, pIn)
		ok

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def AreBoundsOf(pItem, pIn)
		return This.AreBoundsOfCS(pItem, pIn, TRUE)

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST IS BOUNDED BY THE GIVEN TWO ITEMS  #
	#----------------------------------------------------------#

	def IsBoundedByCS(paBounds, pCaseSensitive)
		if isList(paBounds) and Q(paBounds).IsPair()
			pItem1 = paBounds[1]
			pItem2 = paBounds[2]

		else
			pItem1 = paBounds
			pItem2 = paBounds
		ok
	
		if This.FirstItemQ().IsEqualToCS(pItem1, pCaseSensitive) and
		   This.LastItemQ().IsEqualToCS(pItem2, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

	def IsBoundedBy(pacBounds)
		return This.IsBoundedByCS(paBounds, TRUE)

	  #--------------------------------------------#
	 #  GETTING BOUNDS OF THE LIST UP TO N ITEMS  #
	#--------------------------------------------#

	def BoundsUpToNItems(n)
		aResult = [ This.NFirstItems(n), This.NLastItems(n) ]
		return aResult

		#< @FunctionFluentForm
	
		def BoundsUpToNItemsQ(n)
			return new stzList( This.BoundsUpToNItems(n) )

		#>

	  #-------------------------#
	 #     REMOVING BOUNDS     #
	#-------------------------#

	def RemoveTheseBoundsCS(pBound1, pBound2, pCaseSensitive)
		if This.IsBoundedByCS([ pBound1, pBound2], pCaseSensitive)
			This.RemoveFirstItem()
			This.RemoveLastItem()
		ok

		def RemoveTheseBoundsCSQ(pBound1, pBound2, pCaseSensitive)
			This.RemoveTheseBoundsCS(pBound1, pBound2, pCaseSensitive)
			return This

	def TheseBoundsRemovedCS(pBound1, pBound2, pCaseSensitive)

		aResult = This.Copy().RemoveTheseBoundsCSQ(pBound1, pBound2, pCaseSensitive).Content()
		return aResult

		/* WARNING: Subtle bug in Ring (Show to Mahmoud)

		In the function above, if we write the expression that returns
		the result directly after the keyword 'return', like this:

		return This.Copy().RemoveTheseBoundsQ(pItem1, pItem2).Content()

		Then nothing is returned, altough the result should be a list!

		I don't know why this happens. But I found that the solution is
		to avoid writing any expression after return. Instead, let's always
		compute the result in a variable, and then return it (see code above).

		--> TODO: Check the occurrence this pattern all over the library!
		*/
		
	#-- WIHTOUT CASESENSITIVITY

	def RemoveTheseBounds(pBound1, pBound2)
		This.RemoveTheseBoundsCS(pBound1, pBound2, TRUE)

		def RemoveTheseBoundsQ(pBound1, pBound2)
			This.RemoveTheseBounds(pBound1, pBound2)
			return This

	def TheseBoundsRemoved(pBound1, pBound2)

		aResult = This.Copy().RemoveTheseBoundsQ(pBound1, pBound2).Content()
		return aResult

	  #------------------------------#
	 #     REMOVING MANY BOUNDS     #
	#------------------------------#

	def RemoveManyBoundsCS(paPairsOfBounds, pCaseSensitive)
		nLen = len(paPairsOfBounds)
		for i = 1 to nLen
			This.RemoveTheseBoundsCS(paPairsOfBounds[i][1], paPairsOfBounds[i][2], pCaseSensitive)
		next

		def RemoveManyBoundsCSQ(paPairsOfBounds, pCaseSensitive)
			This.RemoveManyBoundsCS(paPairsOfBounds, pCaseSensitive)
			return This

	def ManyBoundsRemovedCS(paPairsOfBounds, pCaseSensitive)
		aResult = This.Copy().RemoveManyBoundsCSQ(paPairsOfBounds, pCaseSensitive).Content()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveManyBounds(paPairsOfBounds)
		This.RemoveManyBoundsCS(paPairsOfBounds, TRUE)

		def RemoveManyBoundsQ(paPairsOfBounds)
			This.RemoveManyBounds(paPairsOfBounds)
			return This

	def ManyBoundsRemoved(paPairsOfBounds)
		aResult = This.Copy().RemoveManyBoundsQ(paPairsOfBounds).Content()
		return aResult

	  #----------------------------------#
	 #   REMOVING ZEROS FROM THE LIST   #
	#----------------------------------#

	def RemoveZeros()
		This.RemoveItem(0)

		def RemoveZerosQ()
			This.RemoveZeros()
			return This

	def ZerosRemoved()
		aResult = This.Copy().RemoveZerosQ().Content()
		return aResult

	  #--------------------------------------#
	 #  CHECKING IF ALL THE ITEMS ARE NULL  #
	#--------------------------------------#

	def AllItemsAreNull()

		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT isString(@aContent[i])
				return FALSE
			ok
			if @aContent[i] != NULL
				return FALSE
			ok
		next

		return TRUE

	  #-------------------------------------#
	 #    CHECKINK LIST CHARACTERISTICS    #
	#-------------------------------------#

	def IsUniformCS(pCaseSensitive)
		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 2
			return TRUE
		ok

		if This.NumberOfOccurrenceCS(aContent[1], pCaseSensitive) = nLen
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfSameItemCS(pCaseSensitive)
			return This.IsUniformCS(pCaseSensitive)

		def ItemsAreSameCS(pCaseSensitive)
			return This.IsUniformCS(pCaseSensitive)

		#>

	def IsUniform()
		return This.IsUniformCS(TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfSameItem()
			return This.IsUniform()

		def ItemsAreSame()
			return This.IsUniform()

		#>

	#--

	def IsUnary()
		if This.NumberOfItems() = 1
			return TRUE
		else
			return FALSE
		ok

		def IsUnaryList()
			return This.IsUnary()

		def IsAUnaryList()
			return This.IsUnary()

	def IsEmpty()
		if This.NumberOfItems() = 0
			return TRUE
		else
			return FALSE
		ok

		def IsEmptyList()
			return This.IsEmpty()

		def IsAnEmptyList()
			return This.IsEmpty()

	def IsDeepList()	// Contains at least an inner list
		If This.Depth() > 1
			return TRUE
		else
			return FALSE
		ok

		def IsADeepList()
			return This.ISDeepList()

		def IsDeep()
			return This.ISDeepList()

	def IsHybridList()	// Contains items of different types
		if This.ContainsOnlyNumbers() or
		   This.ContainsOnlyStrings() or
		   This.ContainsOnlyLists() or
		   This.ContainsOnlyObjects()

			return FALSE
		else
			return TRUE
		ok

		def IsAHybridList()
			return This.IsHybridList()

	def IsPureList()	// Contains items of the same type
		if This.ContainsOnlyNumbers() or
		   This.ContainsOnlyStrings() or
		   This.ContainsOnlyLists() or
		   This.ContainsOnlyObjects()

			return TRUE
		else
			return FALSE
		ok

		def IsAPureList()
			return This.IsPureList()

	def IsOddList()
		oTempNumber = new stzNumber( This.NumberOfItems() )
		if oTempNumber.IsOdd()
			return TRUE
		else
			return FALSE
		ok

		def IsAnOddList()
			return This.IsOddList()

	def IsEvenList()
		if NOT This.IsOddList()
			return TRUE
		else
			return FALSE
		ok

		def IsAnEvenList()
			return This.IsEvenList()

	// TODO: Maybe we should design a stzListOfBits class...
	def IsListOfBits()
		if This.NumberOfItems() = 0
			return FALSE
		ok

		if This.IsListOfNumbers()
			for n in This.List()
				if NOT IsBit(n)
					return FALSE
				ok
			end
		ok

		return TRUE

		def IsAListOfBits()
			return This.IsListOfBits()

	def IsListOfZerosAndOnes()
		if This.NumberOfItems() = 0
			return FALSE
		ok

		return This.IsListOfBits()

		def IsAListOfZerosAndOnes()
			return This.IsListOfZerosAndOnes()

	def IsGrid()
		aContent = This.Content()
		nLen = len(aContent)

		if nLen < 2
			return FALSE
		ok

		if NOT This.AllItemsAreLists()
			return FALSE
		ok

		nLen1 = len(aContent[1])
		bResult = TRUE

		for i = 2 to nLen
			if len(aContent[i]) != nLen1
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def IsAGrid()
			return This.IsGrid

	def IsHashList()
		/*
		A hash list is a grid of 2 vlines.

		The items of the 1st vline are all strings.
		And they are all unique (form a Set).

		When stzGrid class is fully tested we can use this code:	
		
		oTempGrid = new stzGrid( This.List() )
		bResult = FALSE

		if oTempGrid.NumberOfVLines() = 2

			aFirstVLine = oTempGrid.VLine(1)

			if @IsSet(aFirstVLine) and ListItemsAreAllStrings(aFirstVLine)
				bResult = TRUE
			ok
		ok
		return bResult
		*/

		# All items are list of 2 items, where the 1st beeing string
		#TODO: The strings in the 1st column (keys of the hashlist) must be unique

		bResult = TRUE
		aTempKeys = []

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isString(aContent[i][1]) )

				bResult = FALSE
				exit
			else
				if ring_find(aTempKeys, aContent[i][1]) > 0
					bResult = FALSE
					exit
				ok

				aTempKeys + aContent[i][1]
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAHashList()
			return This.IsHashList()

		def IsNotHashList()
			return NOT This.IsHashList()

		def IsNotAHashList()
			return This.IsHashList()
	
		#>


	def IsHashListOrListOfStrings()
		if This.IsListOfStrings() or This.IsHashList()
			return TRUE
		else
			return FALSE
		ok

		def IsListOfStringsOrHashList()
			return This.IsHashListOrListOfStrings()

	def IsListOfListsOfSameSize()
		if This.NumberOfItems() = 0
			return FALSE
		ok

		bResult = FALSE

		if This.AllItemsAreLists()
			bSame = TRUE
			for i = 2 to This.NumberOfItems()
				if len(Item(i)) != len(Item(i-1))
					bSame = FALSE
				ok
			next
			if bSame
				bResult = TRUE
			ok
		ok

		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def ItemsAreAllListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def ContainsListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsOfSameSize()
			return This.IsListOfListsOfSameSize()

		#--

		def IsListOfListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def ItemsAreListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def ContainsListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsHavingSameSize()
			return This.IsListOfListsOfSameSize()

		#=

		def ItemsAreListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ContainsListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsOfSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		#--

		def IsListOfListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ItemsAreListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def AllItemsAreListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def ContainsListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		def IsMadeOfListsHavingSameNumberOfItems()
			return This.IsListOfListsOfSameSize()

		#>

	  #----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HYBRID LISTS  #
	#====================================================#

	def IsListOfHybridLists()
		if NOT This.IsListOfLists()
			return FALSE
		ok

		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsHybridList(aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHybridLists()
			return This.IsListOfHybridLists()

		def ItemsAreHybridLists()
			return This.IsListOfHybridLists()

		def ItemsAreAllHybridLists()
			return This.IsListOfHybridLists()

		def AllItemsAreHybridLists()
			return This.IsListOfHybridLists()

		def ContainsOnlyHybridLists()
			return This.IsListOfHybridLists()

		def ContainsHybridListsOnly()
			return This.IsListOfHybridLists()

		def IsMadeOfHybridLists()
			return This.IsListOfHybridLists()

		def IsMadeOfOnlyHybridLists()
			return This.IsListOfHybridLists()

		def IsMadeOfHybridListsOnly()
			return This.IsListOfHybridLists()

		def IsMadeOnlyOfHybridLists()
			return This.IsListOfHybridLists()

		def IsOnlyMadeOfHybridLists()
			return This.IsListOfHybridLists()

		#--

		def AreHybridLists()
			return This.IsListOfHybridLists()

		def AreAllHybridLists()
			return This.IsListOfHybridLists()

		def AllAreHybridLists()
			return This.IsListOfHybridLists()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS MADE OF LISTS OF HYBRID LISTS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfHybridLists(paList)
		aContent = This.Content()
		nLen = len(aContent)

		aoStzLists = This.ToStzlists()

		bResult = TRUE

		for i = 1 to nLen
			if NOT aoStzLists.IsHybridList()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ItemsAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ItemsAreAllListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AllItemsAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ContainsOnlyListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def ContainsListsOfHybridListsOnly()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfOnlyListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOfListsOfHybridListsOnly()
			return This.IsListOfListsOfHybridLists()

		def IsMadeOnlyOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def IsOnlyMadeOfListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		#--

		def AreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AreAllListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		def AllAreListsOfHybridLists()
			return This.IsListOfListsOfHybridLists()

		#>


	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF NUMBERS  #
	#===============================================#

	def IsListOfNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbers()
			return This.IsListOfNumbers()

		def ItemsAreNumbers()
			return This.IsListOfNumbers()

		def ItemsAreAllNumbers()
			return This.IsListOfNumbers()

		def AllItemsAreNumbers()
			return This.IsListOfNumbers()

		def ContainsOnlyNumbers()
			return This.IsListOfNumbers()

		def ContainsNumbersOnly()
			return This.IsListOfNumbers()

		def IsMadeOfNumbers()
			return This.IsListOfNumbers()

		def IsMadeOfOnlyNumbers()
			return This.IsListOfNumbers()

		def IsMadeOfNumbersOnly()
			return This.IsListOfNumbers()

		def IsMadeOnlyOfNumbers()
			return This.IsListOfNumbers()

		def IsOnlyMadeOfNumbers()
			return This.IsListOfNumbers()

		#--

		def AreNumbers()
			return This.IsListOfNumbers()

		def AreAllNumbers()
			return This.IsListOfNumbers()

		def AllAreNumbers()
			return This.IsListOfNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF NUMBERS  #
	#--------------------------------------------------------#

	def IsListOfListsOfNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ItemsAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ItemsAreAllListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AllItemsAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ContainsOnlyListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def ContainsListsOfNumbersOnly()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfOnlyListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsMadeOfListsOfNumbersOnly()
			return This.IsListOfListsOfNumbers()

		def IsMadeOnlyOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def IsOnlyMadeOfListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		#--

		def AreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AreAllListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		def AllAreListsOfNumbers()
			return This.IsListOfListsOfNumbers()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF DECIMAL NUMBERS  #
	#=======================================================#

	def IsListOfDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsDecimalNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ItemsAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ItemsAreAllDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AllItemsAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ContainsOnlyDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def ContainsDecimalNumbersOnly()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfOnlyDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsMadeOfDecimalNumbersOnly()
			return This.IsListOfDecimalNumbers()

		def IsMadeOnlyOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def IsOnlyMadeOfDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		#--

		def AreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AreAllDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		def AllAreDecimalNumbers()
			return This.IsListOfDecimalNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF DECIMAL NUMBERS  #
	#----------------------------------------------------------------#

	def IsListOfListsOfDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfDecimalNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ItemsAreListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ItemsAreAllListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AllItemsAreListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ContainsOnlyListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def ContainsListsOfDecimalNumbersOnly()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfOnlyListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOfListsOfDecimalNumbersOnly()
			return This.IsListOfListsOfDecimalNumbers()

		def IsMadeOnlyOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def IsOnlyMadeOfListsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		#--

		def ArelistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AreAlllistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		def AllArelistsOfDecimalNumbers()
			return This.IsListOfListsOfDecimalNumbers()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF BINARY NUMBERS  #
	#======================================================#

	def IsListOfBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsBinaryNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ItemsAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ItemsAreAllBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AllItemsAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ContainsOnlyBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def ContainsBinaryNumbersOnly()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfOnlyBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsMadeOfBinaryNumbersOnly()
			return This.IsListOfBinaryNumbers()

		def IsMadeOnlyOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def IsOnlyMadeOfBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		#--

		def AreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AreAllBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		def AllAreBinaryNumbers()
			return This.IsListOfBinaryNumbers()

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF BINARY NUMBERS  #
	#---------------------------------------------------------------#

	def IsListOfListsOfBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfBinaryNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ItemsAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ItemsAreAllListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AllItemsAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ContainsOnlyListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def ContainsListsOfBinaryNumbersOnly()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfOnlyListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOfListsOfBinaryNumbersOnly()
			return This.IsListOfListsOfBinaryNumbers()

		def IsMadeOnlyOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def IsOnlyMadeOfListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		#--

		def AreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AreAllListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		def AllAreListsOfBinaryNumbers()
			return This.IsListOfListsOfBinaryNumbers()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF OCTAL NUMBERS  #
	#=====================================================#

	def IsListOfOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsOctalNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ItemsAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ItemsAreAllOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AllItemsAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ContainsOnlyOctalNumbers()
			return This.IsListOfOctalNumbers()

		def ContainsOctalNumbersOnly()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOnlyOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsMadeOfOctalNumbersOnly()
			return This.IsListOfOctalNumbers()

		def IsMadeOnlyOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		def IsOnlyMadeOfOctalNumbers()
			return This.IsListOfOctalNumbers()

		#--

		def AreOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AreAllOctalNumbers()
			return This.IsListOfOctalNumbers()

		def AllAreOctalNumbers()
			return This.IsListOfOctalNumbers()

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF OCTAL NUMBERS  #
	#--------------------------------------------------------------#

	def IsListOfListsOfOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfOctalNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ItemsAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ItemsAreAllListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AllItemsAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ContainsOnlyListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def ContainsListsOfOctalNumbersOnly()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfOnlyListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOfListsOfOctalNumbersOnly()
			return This.IsListOfListsOfOctalNumbers()

		def IsMadeOnlyOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def IsOnlyMadeOfListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		#--

		def AreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AreAllListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		def AllAreListsOfOctalNumbers()
			return This.IsListOfListsOfOctalNumbers()

		#>

	  #---------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HEX NUMBERS  #
	#===================================================#

	def IsListOfHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsHexNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHexNumbers()
			return This.IsListOfHexNumbers()

		def ItemsAreHexNumbers()
			return This.IsListOfHexNumbers()

		def ItemsAreAllHexNumbers()
			return This.IsListOfHexNumbers()

		def AllItemsAreHexNumbers()
			return This.IsListOfHexNumbers()

		def ContainsOnlyHexNumbers()
			return This.IsListOfHexNumbers()

		def ContainsHexNumbersOnly()
			return This.IsListOfHexNumbers()

		def IsMadeOfHexNumbers()
			return This.IsListOfHexNumbers()

		def IsMadeOfOnlyHexNumbers()
			return This.IsListOfHexNumbers()

		def IsMadeOfHexNumbersOnly()
			return This.IsListOfHexNumbers()

		def IsMadeOnlyOfHexNumbers()
			return This.IsListOfHexNumbers()

		def IsOnlyMadeOfHexNumbers()
			return This.IsListOfHexNumbers()

		#--

		def AreHexNumbers()
			return This.IsListOfHexNumbers()

		def AreAllHexNumbers()
			return This.IsListOfHexNumbers()

		def AllAreHexNumbers()
			return This.IsListOfHexNumbers()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF HEX NUMBERS  #
	#------------------------------------------------------------#

	def IsListOfListsOfHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfHexNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ItemsAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ItemsAreAllListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AllItemsAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ContainsOnlyListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def ContainsListsOfHexNumbersOnly()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfOnlyListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOfListsOfHexNumbersOnly()
			return This.IsListOfListsOfHexNumbers()

		def IsMadeOnlyOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def IsOnlyMadeOfListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		#--

		def AreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AreAllListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		def AllAreListsOfHexNumbers()
			return This.IsListOfListsOfHexNumbers()

		#>
	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF QBYTESLIST OBJECTS  #
	#==========================================================#

	def IsListOfQBytesLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsQBytesListObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfQBytesLists()
			return This.IsListOfQBytesLists()

		def ItemsAreQBytesLists()
			return This.IsListOfQBytesLists()

		def ItemsAreAllQBytesLists()
			return This.IsListOfQBytesLists()

		def AllItemsAreQBytesLists()
			return This.IsListOfQBytesLists()

		def ContainsOnlyQBytesLists()
			return This.IsListOfQBytesLists()

		def ContainsQBytesListsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesLists()
			return This.IsListOfQBytesLists()

		def IsMadeOfOnlyQBytesLists()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOnlyOfQBytesLists()
			return This.IsListOfQBytesLists()

		def IsOnlyMadeOfQBytesLists()
			return This.IsListOfQBytesLists()

		#--

		def IsListOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsAListOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ItemsAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ItemsAreAllQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AllItemsAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ContainsOnlyQBytesListObjects()
			return This.IsListOfQBytesLists()

		def ContainsQBytesListObjectsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsMadeOfOnlyQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsMadeOfQBytesListObjectsOnly()
			return This.IsListOfQBytesLists()

		def IsMadeOnlyOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		def IsOnlyMadeOfQBytesListObjects()
			return This.IsListOfQBytesLists()

		#--

		def AreQBytesList()
			return This.IsListOfQBytesLists()

		def AreAllQBytesList()
			return This.IsListOfQBytesLists()

		def AllAreQBytesList()
			return This.IsListOfQBytesLists()

		def AreQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AreAllQBytesListObjects()
			return This.IsListOfQBytesLists()

		def AllAreQBytesListObjects()
			return This.IsListOfQBytesLists()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STRINGS  #
	#===============================================#

	def IsListOfStrings()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStrings()
			return This.IsListOfStrings()

		def ItemsAreStrings()
			return This.IsListOfStrings()

		def ItemsAreAllStrings()
			return This.IsListOfStrings()

		def AllItemsAreStrings()
			return This.IsListOfStrings()

		def ContainsOnlyStrings()
			return This.IsListOfStrings()

		def ContainsStringsOnly()
			return This.IsListOfStrings()

		def IsMadeOfStrings()
			return This.IsListOfStrings()

		def IsMadeOfOnlyStrings()
			return This.IsListOfStrings()

		def IsMadeOfStringsOnly()
			return This.IsListOfStrings()

		def IsMadeOnlyOfStrings()
			return This.IsListOfStrings()

		def IsOnlyMadeOfStrings()
			return This.IsListOfStrings()

		#--

		def AreStrings()
			return This.IsListOfStrings()

		def AreAllStrings()
			return This.IsListOfStrings()

		def AllAreStrings()
			return This.IsListOfStrings()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STRINGS  #
	#--------------------------------------------------------#

	def IsListOfListsOfStrings()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStrings(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ItemsAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ItemsAreAllListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AllItemsAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ContainsOnlyListsOfStrings()
			return This.IsListOfListsOfStrings()

		def ContainsListsOfStringsOnly()
			return This.IsListOfListsOfStrings()

		def IsMadeOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsMadeOfOnlyListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsMadeOfListsOfStringsOnly()
			return This.IsListOfListsOfStrings()

		def IsMadeOnlyOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		def IsOnlyMadeOfListsOfStrings()
			return This.IsListOfListsOfStrings()

		#--

		def AreListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AreAllListsOfStrings()
			return This.IsListOfListsOfStrings()

		def AllAreListsOfStrings()
			return This.IsListOfListsOfStrings()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS  #
	#=============================================#

	def IsListOfLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT isList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfLists()
			return This.IsListOfLists()

		def ItemsAreLists()
			return This.IsListOfLists()

		def ItemsAreAllLists()
			return This.IsListOfLists()

		def AllItemsAreLists()
			return This.IsListOfLists()

		def ContainsOnlyLists()
			return This.IsListOfLists()

		def ContainsListsOnly()
			return This.IsListOfLists()

		def IsMadeOfLists()
			return This.IsListOfLists()

		def IsMadeOfOnlyLists()
			return This.IsListOfLists()

		def IsMadeOfListsOnly()
			return This.IsListOfLists()

		def IsMadeOnlyOfLists()
			return This.IsListOfLists()

		def IsOnlyMadeOfLists()
			return This.IsListOfLists()

		#--

		def AreLists()
			return This.IsListOfLists()

		def AreAllLists()
			return This.IsListOfLists()

		def AllAreLists()
			return This.IsListOfLists()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF LISTS  #
	#------------------------------------------------------#

	def IsListOfListsOfLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfLists(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfLists()
			return This.IsListOfListsOfLists()

		def ItemsAreListsOfLists()
			return This.IsListOfListsOfLists()

		def ItemsAreAllListsOfLists()
			return This.IsListOfListsOfLists()

		def AllItemsAreListsOfLists()
			return This.IsListOfListsOfLists()

		def ContainsOnlyListsOfLists()
			return This.IsListOfListsOfLists()

		def ContainsListsOfListsOnly()
			return This.IsListOfListsOfLists()

		def IsMadeOfListsOfLists()
			return This.IsListOfListsOfLists()

		def IsMadeOfOnlyListsOfLists()
			return This.IsListOfListsOfLists()

		def IsMadeOfListsOfListsOnly()
			return This.IsListOfListsOfLists()

		def IsMadeOnlyOfListsOfLists()
			return This.IsListOfListsOfLists()

		def IsOnlyMadeOfListsOfLists()
			return This.IsListOfListsOfLists()

		#--

		def AreListsOfLists()
			return This.IsListOfListsOfLists()

		def AreAllListsOfLists()
			return This.IsListOfListsOfLists()

		def AllAreListsOfLists()
			return This.IsListOfListsOfLists()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF OBJECTS  #
	#===============================================#

	def IsListOfObjects()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfObjects()
			return This.IsListOfObjects()

		def ItemsAreObjects()
			return This.IsListOfObjects()

		def ItemsAreAllObjects()
			return This.IsListOfObjects()

		def AllItemsAreObjects()
			return This.IsListOfObjects()

		def ContainsOnlyObjects()
			return This.IsListOfObjects()

		def ContainsObjectsOnly()
			return This.IsListOfObjects()

		def IsMadeOfObjects()
			return This.IsListOfObjects()

		def IsMadeOfOnlyObjects()
			return This.IsListOfObjects()

		def IsMadeOfObjectsOnly()
			return This.IsListOfObjects()

		def IsMadeOnlyOfObjects()
			return This.IsListOfObjects()

		def IsOnlyMadeOfObjects()
			return This.IsListOfObjects()

		#--

		def AreObjects()
			return This.IsListOfObjects()

		def AreAllObjects()
			return This.IsListOfObjects()

		def AllAreObjects()
			return This.IsListOfObjects()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF OBJECTS  #
	#--------------------------------------------------------#

	def IsListOfListsOfObjects()

		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfObjects(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ItemsAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ItemsAreAllListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AllItemsAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ContainsOnlyListsOfObjects()
			return This.IsListOfListsOfObjects()

		def ContainsListsOfObjectsOnly()
			return This.IsListOfListsOfObjects()

		def IsMadeOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsMadeOfOnlyListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsMadeOfListsOfObjectsOnly()
			return This.IsListOfListsOfObjects()

		def IsMadeOnlyOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		def IsOnlyMadeOfListsOfObjects()
			return This.IsListOfListsOfObjects()

		#--

		def AreListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AreAllListsOfObjects()
			return This.IsListOfListsOfObjects()

		def AllAreListsOfObjects()
			return This.IsListOfListsOfObjects()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF CHARS  #
	#=============================================#

	def IsListOfChars()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsChar(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfChars()
			return This.IsListOfChars()

		def ItemsAreChars()
			return This.IsListOfChars()

		def ItemsAreAllChars()
			return This.IsListOfChars()

		def AllItemsAreChars()
			return This.IsListOfChars()

		def ContainsOnlyChars()
			return This.IsListOfChars()

		def ContainsCharsOnly()
			return This.IsListOfChars()

		def IsMadeOfChars()
			return This.IsListOfChars()

		def IsMadeOfOnlyChars()
			return This.IsListOfChars()

		def IsMadeOfCharsOnly()
			return This.IsListOfChars()

		def IsMadeOnlyOfChars()
			return This.IsListOfChars()

		def IsOnlyMadeOfChars()
			return This.IsListOfChars()

		#--

		def AreChars()
			return This.IsListOfChars()

		def AreAllChars()
			return This.IsListOfChars()

		def AllAreChars()
			return This.IsListOfChars()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF CHARS  #
	#------------------------------------------------------#

	def IsListOfListsOfChars()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfChars(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfChars()
			return This.IsListOfListsOfChars()

		def ItemsAreListsOfChars()
			return This.IsListOfListsOfChars()

		def ItemsAreAllListsOfChars()
			return This.IsListOfListsOfChars()

		def AllItemsAreListsOfChars()
			return This.IsListOfListsOfChars()

		def ContainsOnlyListsOfChars()
			return This.IsListOfListsOfChars()

		def ContainsListsOfCharsOnly()
			return This.IsListOfListsOfChars()

		def IsMadeOfListsOfChars()
			return This.IsListOfListsOfChars()

		def IsMadeOfOnlyListsOfChars()
			return This.IsListOfListsOfChars()

		def IsMadeOfListsOfCharsOnly()
			return This.IsListOfListsOfChars()

		def IsMadeOnlyOfListsOfChars()
			return This.IsListOfListsOfChars()

		def IsOnlyMadeOfListsOfChars()
			return This.IsListOfListsOfChars()

		#--

		def AreListsOfChars()
			return This.IsListOfListsOfChars()

		def AreAllListsOfChars()
			return This.IsListOfListsOfChars()

		def AllAreListsOfChars()
			return This.IsListOfListsOfChars()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF PAIRS  #
	#=============================================#

	def IsListOfPairs()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsPair(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfPairs()
			return This.IsListOfPairs()

		def ItemsArePairs()
			return This.IsListOfPairs()

		def ItemsAreAllPairs()
			return This.IsListOfPairs()

		def AllItemsArePairs()
			return This.IsListOfPairs()

		def ContainsOnlyPairs()
			return This.IsListOfPairs()

		def ContainsPairsOnly()
			return This.IsListOfPairs()

		def IsMadeOfPairs()
			return This.IsListOfPairs()

		def IsMadeOfOnlyPairs()
			return This.IsListOfPairs()

		def IsMadeOfPairsOnly()
			return This.IsListOfPairs()

		def IsMadeOnlyOfPairs()
			return This.IsListOfPairs()

		def IsOnlyMadeOfPairs()
			return This.IsListOfPairs()

		#--

		def ArePairs()
			return This.IsListOfPairs()

		def AreAllPairs()
			return This.IsListOfPairs()

		def AllArePairs()
			return This.IsListOfPairs()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF PAIRS  #
	#------------------------------------------------------#

	def IsListOfListsOfPairs()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfPairs(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ItemsAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ItemsAreAllListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AllItemsAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ContainsOnlyListsOfPairs()
			return This.IsListOfListsOfPairs()

		def ContainsListsOfPairsOnly()
			return This.IsListOfListsOfPairs()

		def IsMadeOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsMadeOfOnlyListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsMadeOfListsOfPairsOnly()
			return This.IsListOfListsOfPairs()

		def IsMadeOnlyOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		def IsOnlyMadeOfListsOfPairs()
			return This.IsListOfListsOfPairs()

		#--

		def AreListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AreAllListsOfPairs()
			return This.IsListOfListsOfPairs()

		def AllAreListsOfPairs()
			return This.IsListOfListsOfPairs()

		#>

	  #--------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF SETS  #
	#============================================#

	def IsListOfSets()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsSet(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfSets()
			return This.IsListOfSets()

		def ItemsAreSets()
			return This.IsListOfSets()

		def ItemsAreAllSets()
			return This.IsListOfSets()

		def AllItemsAreSets()
			return This.IsListOfSets()

		def ContainsOnlySets()
			return This.IsListOfSets()

		def ContainsSetsOnly()
			return This.IsListOfSets()

		def IsMadeOfSets()
			return This.IsListOfSets()

		def IsMadeOfOnlySets()
			return This.IsListOfSets()

		def IsMadeOfSetsOnly()
			return This.IsListOfSets()

		def IsMadeOnlyOfSets()
			return This.IsListOfSets()

		def IsOnlyMadeOfSets()
			return This.IsListOfSets()

		#--

		def AreSets()
			return This.IsListOfSets()

		def AreAllSets()
			return This.IsListOfSets()

		def AllAreSets()
			return This.IsListOfSets()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF SETS  #
	#-----------------------------------------------------#

	def IsListOfListsOfSets()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfSets(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfSets()
			return This.IsListOfListsOfSets()

		def ItemsAreListsOfSets()
			return This.IsListOfListsOfSets()

		def ItemsAreAllListsOfSets()
			return This.IsListOfListsOfSets()

		def AllItemsAreListsOfSets()
			return This.IsListOfListsOfSets()

		def ContainsOnlyListsOfSets()
			return This.IsListOfListsOfSets()

		def ContainsListsOfSetsOnly()
			return This.IsListOfListsOfSets()

		def IsMadeOfListsOfSets()
			return This.IsListOfListsOfSets()

		def IsMadeOfOnlyListsOfSets()
			return This.IsListOfListsOfSets()

		def IsMadeOfListsOfSetsOnly()
			return This.IsListOfListsOfSets()

		def IsMadeOnlyOfListsOfSets()
			return This.IsListOfListsOfSets()

		def IsOnlyMadeOfListsOfSets()
			return This.IsListOfListsOfSets()

		#--

		def AreListsOfSets()
			return This.IsListOfListsOfSets()

		def AreAllListsOfSets()
			return This.IsListOfListsOfSets()

		def AllAreListsOfSets()
			return This.IsListOfListsOfSets()

		#>

	  #-------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF HASHLISTS  #
	#=================================================#

	def IsListOfHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsHashList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfHashLists()
			return This.IsListOfHashLists()

		def ItemsAreHashLists()
			return This.IsListOfHashLists()

		def ItemsAreAllHashLists()
			return This.IsListOfHashLists()

		def AllItemsAreHashLists()
			return This.IsListOfHashLists()

		def ContainsOnlyHashLists()
			return This.IsListOfHashLists()

		def ContainsHashListsOnly()
			return This.IsListOfHashLists()

		def IsMadeOfHashLists()
			return This.IsListOfHashLists()

		def IsMadeOfOnlyHashLists()
			return This.IsListOfHashLists()

		def IsMadeOfHashListsOnly()
			return This.IsListOfHashLists()

		def IsMadeOnlyOfHashLists()
			return This.IsListOfHashLists()

		def IsOnlyMadeOfHashLists()
			return This.IsListOfHashLists()

		#--

		def AreHashLists()
			return This.IsListOfHashLists()

		def AreAllHashLists()
			return This.IsListOfHashLists()

		def AllAreHashLists()
			return This.IsListOfHashLists()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF HASHLISTS  #
	#----------------------------------------------------------#

	def IsListOfListsOfHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfHashLists(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ItemsAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ItemsAreAllListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AllItemsAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ContainsOnlyListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def ContainsListsOfHashListsOnly()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfOnlyListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsMadeOfListsOfHashListsOnly()
			return This.IsListOfListsOfHashLists()

		def IsMadeOnlyOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def IsOnlyMadeOfListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		#--

		def AreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AreAllListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		def AllAreListsOfHashLists()
			return This.IsListOfListsOfHashLists()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF GRIDS  #
	#=============================================#

	def IsListOfGrids()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsGrid(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfGrids()
			return This.IsListOfGrids()

		def ItemsAreGrids()
			return This.IsListOfGrids()

		def ItemsAreAllGrids()
			return This.IsListOfGrids()

		def AllItemsAreGrids()
			return This.IsListOfGrids()

		def ContainsOnlyGrids()
			return This.IsListOfGrids()

		def ContainsGridsOnly()
			return This.IsListOfGrids()

		def IsMadeOfGrids()
			return This.IsListOfGrids()

		def IsMadeOfOnlyGrids()
			return This.IsListOfGrids()

		def IsMadeOfGridsOnly()
			return This.IsListOfGrids()

		def IsMadeOnlyOfGrids()
			return This.IsListOfGrids()

		def IsOnlyMadeOfGrids()
			return This.IsListOfGrids()

		#--

		def AreGrids()
			return This.IsListOfGrids()

		def AreAllGrids()
			return This.IsListOfGrids()

		def AllAreGrids()
			return This.IsListOfGrids()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF GRIDS  #
	#------------------------------------------------------#

	def IsListOfListsOfGrids()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfGrids(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ItemsAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ItemsAreAllListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AllItemsAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ContainsOnlyListsOfGrids()
			return This.IsListOfListsOfGrids()

		def ContainsListsOfGridsOnly()
			return This.IsListOfListsOfGrids()

		def IsMadeOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsMadeOfOnlyListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsMadeOfListsOfGridsOnly()
			return This.IsListOfListsOfGrids()

		def IsMadeOnlyOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		def IsOnlyMadeOfListsOfGrids()
			return This.IsListOfListsOfGrids()

		#--

		def AreListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AreAllListsOfGrids()
			return This.IsListOfListsOfGrids()

		def AllAreListsOfGrids()
			return This.IsListOfListsOfGrids()

		#>

	  #----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF TABLES  #
	#==============================================#

	def IsListOfTables()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsTable(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfTables()
			return This.IsListOfTables()

		def ItemsAreTables()
			return This.IsListOfTables()

		def ItemsAreAllTables()
			return This.IsListOfTables()

		def AllItemsAreTables()
			return This.IsListOfTables()

		def ContainsOnlyTables()
			return This.IsListOfTables()

		def ContainsTablesOnly()
			return This.IsListOfTables()

		def IsMadeOfTables()
			return This.IsListOfTables()

		def IsMadeOfOnlyTables()
			return This.IsListOfTables()

		def IsMadeOfTablesOnly()
			return This.IsListOfTables()

		def IsMadeOnlyOfTables()
			return This.IsListOfTables()

		def IsOnlyMadeOfTables()
			return This.IsListOfTables()

		#--

		def AreTables()
			return This.IsListOfTables()

		def AreAllTables()
			return This.IsListOfTables()

		def AllAreTables()
			return This.IsListOfTables()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF TABLES  #
	#-------------------------------------------------------#

	def IsListOfListsOfTables()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfTables(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfTables()
			return This.IsListOfListsOfTables()

		def ItemsAreListsOfTables()
			return This.IsListOfListsOfTables()

		def ItemsAreAllListsOfTables()
			return This.IsListOfListsOfTables()

		def AllItemsAreListsOfTables()
			return This.IsListOfListsOfTables()

		def ContainsOnlyListsOfTables()
			return This.IsListOfListsOfTables()

		def ContainsListsOfTablesOnly()
			return This.IsListOfListsOfTables()

		def IsMadeOfListsOfTables()
			return This.IsListOfListsOfTables()

		def IsMadeOfOnlyListsOfTables()
			return This.IsListOfListsOfTables()

		def IsMadeOfListsOfTablesOnly()
			return This.IsListOfListsOfTables()

		def IsMadeOnlyOfListsOfTables()
			return This.IsListOfListsOfTables()

		def IsOnlyMadeOfListsOfTables()
			return This.IsListOfListsOfTables()

		#--

		def AreListsOfTables()
			return This.IsListOfListsOfTables()

		def AreAllListsOfTables()
			return This.IsListOfListsOfTables()

		def AllAreListsOfTables()
			return This.IsListOfListsOfTables()

		#>

	  #---------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF TREES  #
	#=============================================#

	def IsListOfTrees()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsTree(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfTrees()
			return This.IsListOfTrees()

		def ItemsAreTrees()
			return This.IsListOfTrees()

		def ItemsAreAllTrees()
			return This.IsListOfTrees()

		def AllItemsAreTrees()
			return This.IsListOfTrees()

		def ContainsOnlyTrees()
			return This.IsListOfTrees()

		def ContainsTreesOnly()
			return This.IsListOfTrees()

		def IsMadeOfTrees()
			return This.IsListOfTrees()

		def IsMadeOfOnlyTrees()
			return This.IsListOfTrees()

		def IsMadeOfTreesOnly()
			return This.IsListOfTrees()

		def IsMadeOnlyOfTrees()
			return This.IsListOfTrees()

		def IsOnlyMadeOfTrees()
			return This.IsListOfTrees()

		#--

		def AreTrees()
			return This.IsListOfTrees()

		def AreAllTrees()
			return This.IsListOfTrees()

		def AllAreTrees()
			return This.IsListOfTrees()

		#>

	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF TREES  #
	#------------------------------------------------------#

	def IsListOfListsOfTrees()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfTrees(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ItemsAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ItemsAreAllListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AllItemsAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ContainsOnlyListsOfTrees()
			return This.IsListOfListsOfTrees()

		def ContainsListsOfTreesOnly()
			return This.IsListOfListsOfTrees()

		def IsMadeOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsMadeOfOnlyListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsMadeOfListsOfTreesOnly()
			return This.IsListOfListsOfTrees()

		def IsMadeOnlyOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		def IsOnlyMadeOfListsOfTrees()
			return This.IsListOfListsOfTrees()

		#--

		def AreListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AreAllListsOfTrees()
			return This.IsListOfListsOfTrees()

		def AllAreListsOfTrees()
			return This.IsListOfListsOfTrees()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZNUMBERS  #
	#==================================================#

	def IsListOfStzNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzNumbers()
			return This.IsListOfStzNumbers()

		def ItemsAreStzNumbers()
			return This.IsListOfStzNumbers()

		def ItemsAreAllStzNumbers()
			return This.IsListOfStzNumbers()

		def AllItemsAreStzNumbers()
			return This.IsListOfStzNumbers()

		def ContainsOnlyStzNumbers()
			return This.IsListOfStzNumbers()

		def ContainsStzNumbersOnly()
			return This.IsListOfStzNumbers()

		def IsMadeOfStzNumbers()
			return This.IsListOfStzNumbers()

		def IsMadeOfOnlyStzNumbers()
			return This.IsListOfStzNumbers()

		def IsMadeOfStzNumbersOnly()
			return This.IsListOfStzNumbers()

		def IsMadeOnlyOfStzNumbers()
			return This.IsListOfStzNumbers()

		def IsOnlyMadeOfStzNumbers()
			return This.IsListOfStzNumbers()

		#--

		def AreStzNumbers()
			return This.IsListOfStzNumbers()

		def AreAllStzNumbers()
			return This.IsListOfStzNumbers()

		def AllAreStzNumbers()
			return This.IsListOfStzNumbers()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZNUMBERS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ItemsAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ItemsAreAllListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AllItemsAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ContainsOnlyListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def ContainsListsOfStzNumbersOnly()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfOnlyListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOfListsOfStzNumbersOnly()
			return This.IsListOfListsOfStzNumbers()

		def IsMadeOnlyOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def IsOnlyMadeOfListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		#--

		def AreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AreAllListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		def AllAreListsOfStzNumbers()
			return This.IsListOfListsOfStzNumbers()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZDECIMALNUMBERS  #
	#=========================================================#

	def IsListOfStzDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzDecimalNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ItemsAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ItemsAreAllStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AllItemsAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ContainsOnlyStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def ContainsStzDecimalNumbersOnly()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfOnlyStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOfStzDecimalNumbersOnly()
			return This.IsListOfStzDecimalNumbers()

		def IsMadeOnlyOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def IsOnlyMadeOfStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		#--

		def AreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AreAllStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		def AllAreStzDecimalNumbers()
			return This.IsListOfStzDecimalNumbers()

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZDECIMALNUMBERS  #
	#------------------------------------------------------------------#

	def IsListOfListsOfStzDecimalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzDecimalNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ItemsAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ItemsAreAllListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AllItemsAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ContainsOnlyListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def ContainsListsOfStzDecimalNumbersOnly()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfOnlyListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOfListsOfStzDecimalNumbersOnly()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsMadeOnlyOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def IsOnlyMadeOfListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		#--

		def AreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AreAllListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		def AllAreListsOfStzDecimalNumbers()
			return This.IsListOfListsOfStzDecimalNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZBINARYNUMBERS  #
	#========================================================#

	def IsListOfStzBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzBinaryNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ItemsAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ItemsAreAllStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllItemsAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ContainsOnlyStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def ContainsStzBinaryNumbersOnly()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfOnlyStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOfStzBinaryNumbersOnly()
			return This.IsListOfStzBinaryNumbers()

		def IsMadeOnlyOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def IsOnlyMadeOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#--

		def AreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AreAllStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllAreStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZBINARYNUMBERS  #
	#-----------------------------------------------------------------#

	def IsListOfListsOfStzBinaryNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzBinaryNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ItemsAreListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ItemsAreAllListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def AllItemsAreListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ContainsOnlyListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def ContainsListsOfStzBinaryNumbersOnly()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfOnlyListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOfListsOfStzBinaryNumbersOnly()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsMadeOnlyOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		def IsOnlyMadeOfListsOfStzBinaryNumbers()
			return This.IsListOfListsOfStzBinaryNumbers()

		#--

		def AreListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AreAllListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		def AllAreListsOfStzBinaryNumbers()
			return This.IsListOfStzBinaryNumbers()

		#>

	  #-------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZOCTALNUMBERS  #
	#=======================================================#

	def IsListOfStzOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzOctalNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ItemsAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ItemsAreAllStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AllItemsAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ContainsOnlyStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def ContainsStzOctalNumbersOnly()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfOnlyStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOfStzOctalNumbersOnly()
			return This.IsListOfStzOctalNumbers()

		def IsMadeOnlyOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def IsOnlyMadeOfStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		#--

		def AreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AreAllStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		def AllAreStzOctalNumbers()
			return This.IsListOfStzOctalNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZOCTALNUMBERS  #
	#----------------------------------------------------------------#

	def IsListOfListsOfStzOctalNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzOctalNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ItemsAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ItemsAreAllListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AllItemsAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ContainsOnlyListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def ContainsListsOfStzOctalNumbersOnly()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfOnlyListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOfListsOfStzOctalNumbersOnly()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsMadeOnlyOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def IsOnlyMadeOfListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		#--

		def AreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AreAllListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		def AllAreListsOfStzOctalNumbers()
			return This.IsListOfListsOfStzOctalNumbers()

		#>

	  #-----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZHEXNUMBERS  #
	#=====================================================#

	def IsListOfStzHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzHexNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ItemsAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ItemsAreAllStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AllItemsAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ContainsOnlyStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def ContainsStzHexNumbersOnly()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfOnlyStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsMadeOfStzHexNumbersOnly()
			return This.IsListOfStzHexNumbers()

		def IsMadeOnlyOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def IsOnlyMadeOfStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		#--

		def AreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AreAllStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		def AllAreStzHexNumbers()
			return This.IsListOfStzHexNumbers()

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZHEXNUMBERS  #
	#--------------------------------------------------------------#

	def IsListOfListsOfStzHexNumbers()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzHexNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ItemsAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ItemsAreAllListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AllItemsAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ContainsOnlyListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def ContainsListsOfStzHexNumbersOnly()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfOnlyListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOfListsOfStzHexNumbersOnly()
			return This.IsListOfListsOfStzHexNumbers()

		def IsMadeOnlyOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def IsOnlyMadeOfListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		#--

		def AreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AreAllListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		def AllAreListsOfStzHexNumbers()
			return This.IsListOfListsOfStzHexNumbers()

		#>
	  #------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZLISTOFBYTES  #
	#======================================================#

	def IsListOfStzListsOfBytes()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzListOfBytes(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzListOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ItemsAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ItemsAreAllStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def AllItemsAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ContainsOnlyStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def ContainsStzListsOfBytesOnly()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfOnlyStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOfStzListsOfBytesOnly()
			return This.IsListOfStzListsOfBytes()

		def IsMadeOnlyOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def IsOnlyMadeOfStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		#--

		def AreStzListsOfBytes()
			return This.IsListOfStzNumbers()

		def AreAllStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		def AllAreStzListsOfBytes()
			return This.IsListOfStzListsOfBytes()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZSTRINGS  #
	#==================================================#

	def IsListOfStzStrings()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzStrings()
			return This.IsListOfStzStrings()

		def ItemsAreStzStrings()
			return This.IsListOfStzStrings()

		def ItemsAreAllStzStrings()
			return This.IsListOfStzStrings()

		def AllItemsAreStzStrings()
			return This.IsListOfStzStrings()

		def ContainsOnlyStzStrings()
			return This.IsListOfStzStrings()

		def ContainsStzStringsOnly()
			return This.IsListOfStzStrings()

		def IsMadeOfStzStrings()
			return This.IsListOfStzStrings()

		def IsMadeOfOnlyStzStrings()
			return This.IsListOfStzStrings()

		def IsMadeOfStzStringsOnly()
			return This.IsListOfStzStrings()

		def IsMadeOnlyOfStzStrings()
			return This.IsListOfStzStrings()

		def IsOnlyMadeOfStzStrings()
			return This.IsListOfStzStrings()

		#--

		def AreStzStrings()
			return This.IsListOfStzStrings()

		def AreAllStzStrings()
			return This.IsListOfStzStrings()

		def AllAreStzStrings()
			return This.IsListOfStzStrings()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZSTRINGS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzStrings()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzStrings(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ItemsAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ItemsAreAllListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AllItemsAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ContainsOnlyListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def ContainsListsOfStzStringsOnly()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfOnlyListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOfListsOfStzStringsOnly()
			return This.IsListOfListsOfStzStrings()

		def IsMadeOnlyOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def IsOnlyMadeOfListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		#--

		def AreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AreAllListsofStzStrings()
			return This.IsListOfListsOfStzStrings()

		def AllAreListsOfStzStrings()
			return This.IsListOfListsOfStzStrings()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZLISTS  #
	#================================================#

	def IsListOfStzLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzLists()
			return This.IsListOfStzLists()

		def ItemsAreStzLists()
			return This.IsListOfStzLists()

		def ItemsAreAllStzLists()
			return This.IsListOfStzLists()

		def AllItemsAreStzLists()
			return This.IsListOfStzLists()

		def ContainsOnlyStzLists()
			return This.IsListOfStzLists()

		def ContainsStzListsOnly()
			return This.IsListOfStzLists()

		def IsMadeOfStzLists()
			return This.IsListOfStzLists()

		def IsMadeOfOnlyStzLists()
			return This.IsListOfStzLists()

		def IsMadeOfStzListsOnly()
			return This.IsListOfStzLists()

		def IsMadeOnlyOfStzLists()
			return This.IsListOfStzLists()

		def IsOnlyMadeOfStzLists()
			return This.IsListOfStzLists()

		#--

		def AreStzLists()
			return This.IsListOfStzLists()

		def AreAllStzLists()
			return This.IsListOfStzLists()

		def AllAreStzLists()
			return This.IsListOfStzLists()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZLISTS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzLists(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ItemsAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ItemsAreAllListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AllItemsAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ContainsOnlyListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def ContainsListsOfStzListsOnly()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfOnlyListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsMadeOfListsOfStzListsOnly()
			return This.IsListOfListsOfStzLists()

		def IsMadeOnlyOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def IsOnlyMadeOfListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		#--

		def AreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AreAllListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		def AllAreListsOfStzLists()
			return This.IsListOfListsOfStzLists()

		#>

	  #--------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZOBJECTS  #
	#==================================================#

	def IsListOfStzObjects()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzObjects()
			return This.IsListOfStzObjects()

		def ItemsAreStzObjects()
			return This.IsListOfStzObjects()

		def ItemsAreAllStzObjects()
			return This.IsListOfStzObjects()

		def AllItemsAreStzObjects()
			return This.IsListOfStzObjects()

		def ContainsOnlyStzObjects()
			return This.IsListOfStzObjects()

		def ContainsStzObjectsOnly()
			return This.IsListOfStzObjects()

		def IsMadeOfStzObjects()
			return This.IsListOfStzObjects()

		def IsMadeOfOnlyStzObjects()
			return This.IsListOfStzObjects()

		def IsMadeOfStzObjectsOnly()
			return This.IsListOfStzObjects()

		def IsMadeOnlyOfStzObjects()
			return This.IsListOfStzObjects()

		def IsOnlyMadeOfStzObjects()
			return This.IsListOfStzObjects()

		#--

		def AreStzObjects()
			return This.IsListOfStzObjects()

		def AreAllStzObjects()
			return This.IsListOfStzObjects()

		def AllAreStzObjects()
			return This.IsListOfStzObjects()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZOBJECTS  #
	#-----------------------------------------------------------#

	def IsListOfListsOfStzObjects()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzObjects(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ItemsAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ItemsAreAllListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AllItemsAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ContainsOnlyListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def ContainsListsOfStzObjectsOnly()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfOnlyListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOfListsOfStzObjectsOnly()
			return This.IsListOfListsOfStzObjects()

		def IsMadeOnlyOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def IsOnlyMadeOfListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		#--

		def AreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AreAllListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		def AllAreListsOfStzObjects()
			return This.IsListOfListsOfStzObjects()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZCHARS  #
	#================================================#

	def IsListOfStzChars()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzChar(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzChars()
			return This.IsListOfStzChars()

		def ItemsAreStzChars()
			return This.IsListOfStzChars()

		def ItemsAreAllStzChars()
			return This.IsListOfStzChars()

		def AllItemsAreStzChars()
			return This.IsListOfStzChars()

		def ContainsOnlyStzChars()
			return This.IsListOfStzChars()

		def ContainsStzCharsOnly()
			return This.IsListOfStzChars()

		def IsMadeOfStzChars()
			return This.IsListOfStzChars()

		def IsMadeOfOnlyStzChars()
			return This.IsListOfStzChars()

		def IsMadeOfStzCharsOnly()
			return This.IsListOfStzChars()

		def IsMadeOnlyOfStzChars()
			return This.IsListOfStzChars()

		def IsOnlyMadeOfStzChars()
			return This.IsListOfStzChars()

		#--

		def AreStzChars()
			return This.IsListOfStzChars()

		def AreAllStzChars()
			return This.IsListOfStzChars()

		def AllAreStzChars()
			return This.IsListOfStzChars()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZCHARS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzChars()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzChars(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ItemsAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ItemsAreAllListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AllItemsAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ContainsOnlyListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def ContainsListsOfStzCharsOnly()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfOnlyListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsMadeOfListsOfStzCharsOnly()
			return This.IsListOfListsOfStzChars()

		def IsMadeOnlyOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def IsOnlyMadeOfListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		#--

		def AreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AreAllListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		def AllAreListsOfStzChars()
			return This.IsListOfListsOfStzChars()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZPAIRS  #
	#================================================#

	def IsListOfStzPairs()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzPair(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzPairs()
			return This.IsListOfStzPairs()

		def ItemsAreStzPairs()
			return This.IsListOfStzPairs()

		def ItemsAreAllStzPairs()
			return This.IsListOfStzPairs()

		def AllItemsAreStzPairs()
			return This.IsListOfStzPairs()

		def ContainsOnlyStzPairs()
			return This.IsListOfStzPairs()

		def ContainsStzPairsOnly()
			return This.IsListOfStzPairs()

		def IsMadeOfStzPairs()
			return This.IsListOfStzPairs()

		def IsMadeOfOnlyStzPairs()
			return This.IsListOfStzPairs()

		def IsMadeOfStzPairsOnly()
			return This.IsListOfStzPairs()

		def IsMadeOnlyOfStzPairs()
			return This.IsListOfStzPairs()

		def IsOnlyMadeOfStzPairs()
			return This.IsListOfStzPairs()

		#--

		def AreStzPairs()
			return This.IsListOfStzPairs()

		def AreAllStzPairs()
			return This.IsListOfStzPairs()

		def AllAreStzPairs()
			return This.IsListOfStzPairs()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZPAIRS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzPairs()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzPairs(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ItemsAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ItemsAreAllListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AllItemsAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ContainsOnlyListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def ContainsListsOfStzPairsOnly()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfOnlyListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOfListsOfStzPairsOnly()
			return This.IsListOfListsOfStzPairs()

		def IsMadeOnlyOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def IsOnlyMadeOfListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		#--

		def AreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AreAllListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		def AllAreListsOfStzPairs()
			return This.IsListOfListsOfStzPairs()

		#>

	  #-----------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZSETS  #
	#===============================================#

	def IsListOfStzSets()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzSet(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzSets()
			return This.IsListOfStzSets()

		def ItemsAreStzSets()
			return This.IsListOfStzSets()

		def ItemsAreAllStzSets()
			return This.IsListOfStzSets()

		def AllItemsAreStzSets()
			return This.IsListOfStzSets()

		def ContainsOnlyStzSets()
			return This.IsListOfStzSets()

		def ContainsStzSetsOnly()
			return This.IsListOfStzSets()

		def IsMadeOfStzSets()
			return This.IsListOfStzSets()

		def IsMadeOfOnlyStzSets()
			return This.IsListOfStzSets()

		def IsMadeOfStzSetsOnly()
			return This.IsListOfStzSets()

		def IsMadeOnlyOfStzSets()
			return This.IsListOfStzSets()

		def IsOnlyMadeOfStzSets()
			return This.IsListOfStzSets()

		#--

		def AreStzSets()
			return This.IsListOfStzNumbers()

		def AreAllStzSets()
			return This.IsListOfStzNumbers()

		def AllAreStzSets()
			return This.IsListOfStzNumbers()

		#>

	  #--------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZSETS  #
	#--------------------------------------------------------#

	def IsListOfListsOfStzSets()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzSets(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ItemsAreListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ItemsAreAllListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def AllItemsAreListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ContainsOnlyListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def ContainsListsOfStzSetsOnly()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfOnlyListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsMadeOfListsOfStzSetsOnly()
			return This.IsListOfListsOfStzSets()

		def IsMadeOnlyOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		def IsOnlyMadeOfListsOfStzSets()
			return This.IsListOfListsOfStzSets()

		#--

		def AreListsOfStzSets()
			return This.IsListOfStzNumbers()

		def AreAllListsOfStzSets()
			return This.IsListOfStzNumbers()

		def AllAreListsOfStzSets()
			return This.IsListOfStzNumbers()

		#>

	  #----------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZHASHLISTS  #
	#====================================================#

	def IsListOfStzHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzHashList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzHashLists()
			return This.IsListOfStzHashLists()

		def ItemsAreStzHashLists()
			return This.IsListOfStzHashLists()

		def ItemsAreAllStzHashLists()
			return This.IsListOfStzHashLists()

		def AllItemsAreStzHashLists()
			return This.IsListOfStzHashLists()

		def ContainsOnlyStzHashLists()
			return This.IsListOfStzHashLists()

		def ContainsStzHashListsOnly()
			return This.IsListOfStzHashLists()

		def IsMadeOfStzHashLists()
			return This.IsListOfStzHashLists()

		def IsMadeOfOnlyStzHashLists()
			return This.IsListOfStzHashLists()

		def IsMadeOfStzHashListsOnly()
			return This.IsListOfStzHashLists()

		def IsMadeOnlyOfStzHashLists()
			return This.IsListOfStzHashLists()

		def IsOnlyMadeOfStzHashLists()
			return This.IsListOfStzHashLists()

		#--

		def AreStzHashLists()
			return This.IsListOfStzHashLists()

		def AreAllStzHashLists()
			return This.IsListOfStzHashLists()

		def AllAreStzHashLists()
			return This.IsListOfStzHashLists()

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZHASHLISTS  #
	#-------------------------------------------------------------#

	def IsListOfListsOfStzHashLists()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzHashLists(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ItemsAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ItemsAreAllListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AllItemsAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ContainsOnlyListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def ContainsListsOfStzHashListsOnly()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfOnlyListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOfListsOfStzHashListsOnly()
			return This.IsListOfListsOfStzHashLists()

		def IsMadeOnlyOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def IsOnlyMadeOfListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		#--

		def AreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AreAllListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		def AllAreListsOfStzHashLists()
			return This.IsListOfListsOfStzHashLists()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZGRIDS  #
	#================================================#

	def IsListOfStzGrids()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzGrid(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzGrids()
			return This.IsListOfStzGrids()

		def ItemsAreStzGrids()
			return This.IsListOfStzGrids()

		def ItemsAreAllStzGrids()
			return This.IsListOfStzGrids()

		def AllItemsAreStzGrids()
			return This.IsListOfStzGrids()

		def ContainsOnlyStzGrids()
			return This.IsListOfStzGrids()

		def ContainsStzGridsOnly()
			return This.IsListOfStzGrids()

		def IsMadeOfStzGrids()
			return This.IsListOfStzGrids()

		def IsMadeOfOnlyStzGrids()
			return This.IsListOfStzGrids()

		def IsMadeOfStzGridsOnly()
			return This.IsListOfStzGrids()

		def IsMadeOnlyOfStzGrids()
			return This.IsListOfStzGrids()

		def IsOnlyMadeOfStzGrids()
			return This.IsListOfStzGrids()

		#--

		def AreStzGrids()
			return This.IsListOfStzGrids()

		def AreAllStzGrids()
			return This.IsListOfStzGrids()

		def AllAreStzGrids()
			return This.IsListOfStzGrids()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZGRIDS  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzGrids()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzGrids(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ItemsAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ItemsAreAllListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AllItemsAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ContainsOnlyListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def ContainsListsOfStzGridsOnly()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfOnlyListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOfListsOfStzGridsOnly()
			return This.IsListOfListsOfStzGrids()

		def IsMadeOnlyOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def IsOnlyMadeOfListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		#--

		def AreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AreAllListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		def AllAreListsOfStzGrids()
			return This.IsListOfListsOfStzGrids()

		#>

	  #-------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZTABLES  #
	#=================================================#

	def IsListOfStzTables()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzTable(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzTables()
			return This.IsListOfStzTables()

		def ItemsAreStzTables()
			return This.IsListOfStzTables()

		def ItemsAreAllStzTables()
			return This.IsListOfStzTables()

		def AllItemsAreStzTables()
			return This.IsListOfStzTables()

		def ContainsOnlyStzTables()
			return This.IsListOfStzTables()

		def ContainsStzTablesOnly()
			return This.IsListOfStzTables()

		def IsMadeOfStzTables()
			return This.IsListOfStzTables()

		def IsMadeOfOnlyStzTables()
			return This.IsListOfStzTables()

		def IsMadeOfStzTablesOnly()
			return This.IsListOfStzTables()

		def IsMadeOnlyOfStzTables()
			return This.IsListOfStzTables()

		def IsOnlyMadeOfStzTables()
			return This.IsListOfStzTables()

		#--

		def AreStzTables()
			return This.IsListOfStzTables()

		def AreAllStzTables()
			return This.IsListOfStzTables()

		def AllAreStzTables()
			return This.IsListOfStzTables()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZTABLES  #
	#----------------------------------------------------------#

	def IsListOfListsOfStzTables()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzTables(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ItemsAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ItemsAreAllListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AllItemsAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ContainsOnlyListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def ContainsListsOfStzTablesOnly()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfOnlyListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsMadeOfListsOfStzTablesOnly()
			return This.IsListOfListsOfStzTables()

		def IsMadeOnlyOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def IsOnlyMadeOfListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		#--

		def AreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AreAllListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		def AllAreListsOfStzTables()
			return This.IsListOfListsOfStzTables()

		#>

	  #------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF STZTREES  #
	#================================================#

	def IsListOfStzTrees()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsStzTree(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStzTrees()
			return This.IsListOfStzTrees()

		def ItemsAreStzTrees()
			return This.IsListOfStzTrees()

		def ItemsAreAllStzTrees()
			return This.IsListOfStzTrees()

		def AllItemsAreStzTrees()
			return This.IsListOfStzTrees()

		def ContainsOnlyStzTrees()
			return This.IsListOfStzTrees()

		def ContainsStzTreesOnly()
			return This.IsListOfStzTrees()

		def IsMadeOfStzTrees()
			return This.IsListOfStzTrees()

		def IsMadeOfOnlyStzTrees()
			return This.IsListOfStzTrees()

		def IsMadeOfStzTreesOnly()
			return This.IsListOfStzTrees()

		def IsMadeOnlyOfStzTrees()
			return This.IsListOfStzTrees()

		def IsOnlyMadeOfStzTrees()
			return This.IsListOfStzTrees()

		#--

		def AreStzTrees()
			return This.IsListOfStzTrees()

		def AreAllStzTrees()
			return This.IsListOfStzTrees()

		def AllAreStzTrees()
			return This.IsListOfStzTrees()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING THAT THE LIST IS A LIST OF LISTS OF STZTREES  #
	#---------------------------------------------------------#

	def IsListOfListsOfStzTrees()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsListOfStzTrees(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ItemsAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ItemsAreAllListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AllItemsAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ContainsOnlyListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def ContainsListsOfStzTreesOnly()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfOnlyListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOfListsOfStzTreesOnly()
			return This.IsListOfListsOfStzTrees()

		def IsMadeOnlyOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def IsOnlyMadeOfListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		#--

		def AreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AreAllListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		def AllAreListsOfStzTrees()
			return This.IsListOfListsOfStzTrees()

		#>

	#==

	def IsListOfNumbersInStrings()
		nLen = len(@aContent)
		if nLen = 0
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to nLen
			if NOT @IsNumberInString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ItemsAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ItemsAreAllNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AllItemsAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ContainsOnlyNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def ContainsNumbersInStringsOnly()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfOnlyNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def IsMadeOfNumbersInStringsOnly()
			return This.IsListOfNumbersInStrings()

		#--

		def AreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AreAllNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		def AllAreNumbersInStrings()
			return This.IsListOfNumbersInStrings()

		#>

	def IsListOfNumbersOrStrings()
		if This.IsListOfNumbers() or
		   This.IsListOfStrings() or
		   This.ISListOfNumbersAndStrings()

			return TRUE
		else
			return FALSE
		ok
		#< @FunctionAlternativeForms

		def IsAListOfNumberOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreAllListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def AllItemsAreListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ContainsOnlyListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def ContainsListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfOnlyListsOfNumbersOrStrings()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfNumbersOrStringsOnly()
			return This.IsListOfNumbersOrStrings()

		#--

		def IsListOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsAListOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ItemsAreAllListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def AllItemsAreListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ContainsOnlyListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def ContainsListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfOnlyListsOfStringsOrNumbers()
			return This.IsListOfNumbersOrStrings()

		def IsMadeOfListsOfStringsOrNumbersOnly()
			return This.IsListOfNumbersOrStrings()

		#>

	def IsListOfNumbersAndStrings()
		bResult = TRUE
		for item in This.List()
			if NOT (isString(item) or isNumber(item))
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumberAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreAllListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AllItemsAreListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ContainsOnlyListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def ContainsListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfOnlyListsOfNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfNumbersAndStringsOnly()
			return This.IsListOfNumbersAndStrings()

		#--

		def IsListOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsAListOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ItemsAreAllListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def AllItemsAreListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ContainsOnlyListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def ContainsListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfOnlyListsOfStringsAndNumbers()
			return This.IsListOfNumbersAndStrings()

		def IsMadeOfListsOfStringsAndNumbersOnly()
			return This.IsListOfNumbersAndStrings()

		#--

		def AreNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AreAllNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		def AllAreNumbersAndStrings()
			return This.IsListOfNumbersAndStrings()

		#>

	def IsListOfNumbersOrListOfStrings()
		if This.IsListOfNumbers() or This.IsListOfStrings()
			return TRUE
		else
			return FALSE
		ok

		def IsListOfStringsOrListOfNumbers()
			return This.IsListOfNumbersOrListOfStrings()

		def AreOnlyNumbersOrOnlyStrings()
			return This.IsListOfNumbersOrListOfStrings()

		def AreOnlyStringsOrOnlyNumbers()
			return This.IsListOfNumbersOrListOfStrings()

	def IsListOfStringsAndPairsOfStrings()
		bResult = TRUE

		for item in This.List()
			if NOT 	( isString(item) or
					( isList(item) and Q(item).IsPairOfStrings() ) )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfStringsAndPairsOfStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def IsListOfPairsOfstringsAndStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def IsAListOfPairsOfStringsAndstrings()
			return This.IsListOfStringsAndPairsOfStrings()

		#--

		def AreStringsAndPairsOfStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		def ArePairsOfStringsAndStrings()
			return This.IsListOfStringsAndPairsOfStrings()

		#>

	def IsListOfNumbersAndPairsOfNumbers()
		bResult = TRUE

		for item in This.List()
			if NOT 	( isNumber(item) or
					( isList(item) and Q(item).IsPairOfNumbers() ) )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfNumbersAndPairsOfNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def IsListOfPairsOfNumbersAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def IsAListOfPairsOfNumbersAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		#--

		def AreNumbersAndPairsOfStrings()
			return This.IsListOfNumbersAndPairsOfNumbers()

		def ArePairsOfStringsAndNumbers()
			return This.IsListOfNumbersAndPairsOfNumbers()

		#>

	def IsListOfListsAndPairsOfLists()
		bResult = TRUE

		for item in This.List()
			if NOT 	( isList(item) or
					( isList(item) and Q(item).IsPairOfLists() ) )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfListsAndPairsOfLists()
			return This.IsListOfListsAndPairsOfLists()

		def IsListOfPairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		def IsAListOfPairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		#--

		def AreListsAndPairsOfLists()
			return This.IsListOfListsAndPairsOfLists()

		def ArePairsOfListsAndLists()
			return This.IsListOfListsAndPairsOfLists()

		#>

	def IsListOfObjectsAndPairsOfObjects()
		bResult = TRUE

		for item in This.List()
			if NOT 	( isNumber(item) or
					( isObject(item) and Q(item).IsPairOfObjects() ) )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfObjectsAndPairsOfObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def IsListOfPairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def IsAListOfPairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		#--

		def AreObjectsAndPairsOfObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		def ArePairsOfObjectsAndObjects()
			return This.IsListOfObjectsAndPairsOfObjects()

		#>

	def IsPair()
		return This.NumberOfItems() = 2

		def IsPairQ()
			if This.IsPair()
				return This
			else
				return StzFalseObjectQ()
			ok

		def IsAPair()
			return This.IsPair()

			def IsAPairQ()
				return This.IsPairQ()

	def IsPairOfStrings()
		return This.IsPair() and This.IsListOfStrings()

		def IsAPairOfStrings()
			return This.IsPairOfStrings()

	def IsListOfPairsOfStrings()
		/*
		Coud be solved nicely like this:

			if This.IsListOfPairs() and
			   Check('Q(@EachItem).IsPairOfStrings()' ) = TRUE
	
				return TRUE
			else
				return FALSE
			ok

		But the following solution is more performant...
		*/

		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isString(aContent[i][1]) and isString(aContent[i][2]) )

					bResult = FALSE
					exit
			ok
		next

		return bResult


		def IsAListOfPairsOfStrings()
			return This.IsListOfPairsOfStrings()

		def ArePairsOfStrings()
			return This.IsListOfPairsOfStrings()

	def IsPairOfNumbers()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isNumber(aContent[1]) and isNumber(aContent[2])
			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsOnlyPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsOnlyAPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsPairOfNumbers()
			return This.IsPairOfNumbers()

		def ContainsAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfOnlyPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfOnlyAPairOfNumbers()
			return This.IsPairOfNumbers()

		def IsMadeOfPairOfNumbersOnly()
			return This.IsPairOfNumbers()

		def IsMadeOfAPairOfNumbersOnly()
			return This.IsPairOfNumbers()

		#--

		def IsSection()
			return This.IsPairOfNumbers()

		def IsASection()
			return This.IsPairOfNumbers()

		def ContainsSection()
			return This.IsPairOfNumbers()

		def ContainsASection()
			return This.IsPairOfNumbers()

		def ContainsOnlySection()
			return This.IsPairOfNumbers()

		def ContainsOnlyASection()
			return This.IsPairOfNumbers()

		def ContainsSectionOnly()
			return This.IsPairOfNumbers()

		def ContainsASectionOnly()
			return This.IsPairOfNumbers()

		#>

	def IsListOfPairsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isNumber(aContent[i][1]) and isNumber(aContent[i][2]) )

					bResult = FALSE
					exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsAListOfPairsOfNumbers()
			return This.IsListOfPairsOfNumbers()

		def IsListOfSections()
			return This.IsListOfPairsOfNumbers()

		def IsAListOfSections()
			return This.IsListOfPairsOfNumbers()

		#--

		def ArePairsOfNumbers()
			return This.IsListOfPairsOfNumbers()

		def AreSections()
			IsListOfPairsOfNumbers

		#>

	def IsPairOfSections()
		aContent = This.Content()
		nLen = len(aContent)

		if isList(aContent[1]) and
		   isList(aContent[2]) and
		   Q(aContent[1]).IsPairOfNumbers() and
		   Q(aContent[2]).IsPairOfNumbers()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfSections()
			return This.IsPairOfSections()

		def ContainsOnlyPairOfSections()
			return This.IsPairOfSections()

		def ContainsOnlyAPairOfSections()
			return This.IsPairOfSections()

		def ContainsPairOfSections()
			return This.IsPairOfSections()

		def ContainsAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfOnlyPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfOnlyAPairOfSections()
			return This.IsPairOfSections()

		def IsMadeOfPairOfSectionsOnly()
			return This.IsPairOfSections()

		def IsMadeOfAPairOfSectionsOnly()
			return This.IsPairOfSections()

		#>

	def IsListOfPairsOfSections()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen
			if NOT (isList(aContent[i]) and Q(aContent[i]).IsPairOfSections())
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def IsAListOfPairsOfSections()
			return This.IsListOfPairsOfSections

		def ArePairsOfSections()
			return This.IsListOfPairsOfSections()

	def IsPairOfLists()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isList(aContent[1]) and isList(aContent[2])
			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfLists()
			return This.IsPairOfLists()

		def ContainsOnlyPairOfLists()
			return This.IsPairOfLists()

		def ContainsOnlyAPairOfLists()
			return This.IsPairOfLists()

		def ContainsPairOfLists()
			return This.IsPairOfLists()

		def ContainsAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfOnlyPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfOnlyAPairOfLists()
			return This.IsPairOfLists()

		def IsMadeOfPairOfListsOnly()
			return This.IsPairOfLists()

		def IsMadeOfAPairOfListsOnly()
			return This.IsPairOfLists()

		#>

	def IsPairOfEmptyLists()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and
		   isList(aContent[1]) and len(aContent[1]) = 0 and
		   isList(aContent[2]) and len(aContent[2]) = 0

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsOnlyPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsOnlyAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def ContainsAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfOnlyPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfOnlyAPairOfEmptyLists()
			return This.IsPairOfEmptyLists()

		def IsMadeOfPairOfEmptyListsOnly()
			return This.IsPairOfEmptyLists()

		def IsMadeOfAPairOfEmptyListsOnly()
			return This.IsPairOfEmptyLists()

		#>

	def IsListOfPairsOfLists()

		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isList(aContent[i][1]) and isList(aContent[i][2]) )

					bResult = FALSE
					exit
			ok
		next

		return bResult

		def IsAListOfPairsOfLists()
			return This.IsListOfPairsOfLists()

		def ArePairsOfLists()
			return This.IsListOfPairsOfLists()

	def IsPairOfObjects()
		aContent = This.Content()
		nlen = len(aContent)

		if nLen = 2 and isObject(aContent[1]) and isObject(aContent[2])
			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsOnlyPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsOnlyAPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsPairOfObjects()
			return This.IsPairOfObjects()

		def ContainsAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfOnlyPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfOnlyAPairOfObjects()
			return This.IsPairOfObjects()

		def IsMadeOfPairOfObjectsOnly()
			return This.IsPairOfObjects()

		def IsMadeOfAPairOfObjectsOnly()
			return This.IsPairOfObjects()

		#>

	def IsListOfPairsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = 2 and
				 isObject(aContent[i][1]) and isObject(aContent[i][2]) )

					bResult = FALSE
					exit
			ok
		next

		return bResult

		def IsAListOfPairsOfObjects()
			return This.IsListOfPairsOfObjects()

		def ArePairsOfObjects()
			return This.IsListOfPairsOfObjects()

	def IsPairAndKeyIsString()
		return This.IsPair() and isString(This.Item(1))

		#< @FunctionAlternativeForms

		def IsAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def IsPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def IsAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#--

		def IsMadeOfAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def IsMadeOfPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def IsMAdeOfAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#--

		def ContainsAPairAndKeyIsString()
			return IsPairAndKeyIsString()

		def ContainsPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		def containsAPairAndKeyIsAString()
			return This.IsPairAndKeyIsString()

		#>

	def IsPairOfStzObjects()
		return This.IsPair() and This.IsListOfStzObjects()

		#< @FunctionAlternativeForms

		def IsAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsOnlyPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsOnlyAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def ContainsAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfOnlyPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfOnlyAPairOfStzObjects()
			return This.IsPairOfStzObjects()

		def IsMadeOfPairOfStzObjectsOnly()
			return This.IsPairOfStzObjects()

		def IsMadeOfAPairOfStzObjectsOnly()
			return This.IsPairOfStzObjects()

		#>

	def IsPairOfStzNumbers()
		return This.IsPair() and This.IsListOfStzNumbers()

		#< @FunctionAlternativeForms

		def IsAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsOnlyPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsOnlyAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def ContainsAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfOnlyPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfOnlyAPairOfStzNumbers()
			return This.IsPairOfStzNumbers()

		def IsMadeOfPairOfStzNumbersOnly()
			return This.IsPairOfStzNumbers()

		def IsMadeOfAPairOfStzNumbersOnly()
			return This.IsPairOfStzNumbers()

		#>

	def IsPairOfStzStrings()
		return This.IsPair() and This.IsListOfStzStrings()

		#< @FunctionAlternativeForms

		def IsAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsOnlyPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsOnlyAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def ContainsAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfOnlyPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfOnlyAPairOfStzStrings()
			return This.IsPairOfStzStrings()

		def IsMadeOfPairOfStzStringsOnly()
			return This.IsPairOfStzStrings()

		def IsMadeOfAPairOfStzStringsOnly()
			return This.IsPairOfStzStrings()

		#>

	def IsPairOfStzLists()
		return This.IsPair() and This.IsListOfStzLists()

		#< @FunctionAlternativeForms

		def IsAPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsOnlyPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsOnlyAPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsPairOfStzLists()
			return This.IsPairOfStzLists()

		def ContainsAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfOnlyPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfOnlyAPairOfStzLists()
			return This.IsPairOfStzLists()

		def IsMadeOfPairOfStzListsOnly()
			return This.IsPairOfStzLists()

		def IsMadeOfAPairOfStzListsOnly()
			return This.IsPairOfStzLists()

		#>

	#--

	def IsNamedObject()
		return FALSE

	def IsListOfNamedObjects()
		bResult = TRUE

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if NOT ( isList(aContent[i]) and Q(aContent[i]).IsNamedObject() )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def AreNamedObjects()
			return This.IsListOfNamedObjects()

	#--

	def IsPairOfNumberAndString()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isString(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def IsAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		#--

		def IsMadeOfPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def IsMAdeOfAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		#--

		def ContainsOnlyPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def ContainsPairOfNumberAndStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyAPairOfNumberAndString()
			return This.IsPairOfNumberAndString()

		def ContainsAPairOfNumberAndStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def ContainsPairOfANumberAndAStringOnly()
			return This.IsPairOfNumberAndString()

		def ContainsOnlyAPairOfANumberAndAString()
			return This.IsPairOfNumberAndString()

		def ContainsAPairOfANumberAndAStringOnly()
			return This.IsPairOfNumberAndString()

		#>

	def IsPairOfStringAndNumber()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isNumber(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def IsAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		#--

		def IsMadeOfPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def IsMadeOfAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		#--

		def ContainsOnlyPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def ContainsPairOfStringAndNumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyAPairOfStringAndNumber()
			return This.IsPairOfStringAndNumber()

		def ContainsAPairOfStringAndNumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def ContainsPairOfAStringAndANumberOnly()
			return This.IsPairOfStringAndNumber()

		def ContainsOnlyAPairOfAStringAndANumber()
			return This.IsPairOfStringAndNumber()

		def ContainsAPairOfAStringAndANumberOnly()
			return This.IsPairOfStringAndNumber()

		#>

	def IsPairOfNumberAndList()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isList(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def IsAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		#--

		def IsMadeOfPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def IsMadeOfAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		#--

		def ContainsOnlyPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def ContainsPairOfNumberAndListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyAPairOfNumberAndList()
			return This.IsPairOfNumberAndList()

		def ContainsAPairOfNumberAndListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def ContainsPairOfANumberAndAListOnly()
			return This.IsPairOfNumberAndList()

		def ContainsOnlyAPairOfANumberAndAList()
			return This.IsPairOfNumberAndList()

		def ContainsAPairOfANumberAndAListOnly()
			return This.IsPairOfNumberAndList()

		#>

	def IsPairOfListAndNumber()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isNumber(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def IsAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		#--

		def IsMadeOfPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def IsMadeOfAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		#--

		def ContainsOnlyPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def ContainsPairOfListAndNumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyAPairOfListAndNumber()
			return This.IsPairOfListAndNumber()

		def ContainsAPairOfListAndNumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def ContainsPairOfAListAndANumberOnly()
			return This.IsPairOfListAndNumber()

		def ContainsOnlyAPairOfAListAndANumber()
			return This.IsPairOfListAndNumber()

		def ContainsAPairOfAListAndANumberOnly()
			return This.IsPairOfListAndNumber()

		#>

	def IsPairOfNumberAndObject()
		if This.NumberOfItems() = 2 and isNumber(This.Item(1)) and isObject(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def IsAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		#--

		def IsMadeOfPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsMadeOfAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def IsMAdeOfPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def IsMAdeOfAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		#--

		def ContainsOnlyPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def ContainsPairOfNumberAndObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyAPairOfNumberAndObject()
			return This.IsPairOfNumberAndObject()

		def ContainsAPairOfNumberAndObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def ContainsPairOfANumberAndAnObjectOnly()
			return This.IsPairOfNumberAndObject()

		def ContainsOnlyAPairOfANumberAndAnObject()
			return This.IsPairOfNumberAndObject()

		def ContainsAPairOfANumberAndAnObjectOnly()
			return This.IsPairOfNumberAndObject()

		#>

	def IsPairOfObjectAndNumber()
		if This.NumberOfItems() = 2 and isObject(This.Item(1)) and isNumber(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def IsAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		#--

		def IsMAdeOfPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsMAdeOfAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def IsMadeOfPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def IsMadeOfAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		#--

		def ContainsOnlyPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsPairOfObjectAndNumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyAPairOfObjectAndNumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsAPairOfObjectAndNumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsPairOfAnObjectAndANumberOnly()
			return This.IsPairOfObjectAndNumber()

		def ContainsOnlyAPairOfAnObjectAndANumber()
			return This.IsPairOfObjectAndNumber()

		def ContainsAPairOfAnObjectAndANumberOnly()
			return This.IsPairOfObjectAndNumber()

		#>

	def IsPairOfStringAndList()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isList(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def IsAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		#--

		def IsMadeOfPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def IsMAdeOfAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		#--

		def ContainsOnlyPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def ContainsPairOfStringAndListOnly()
			return This.IsPairOfStringAndList()

		def ContainsOnlyAPairOfStringAndList()
			return This.IsPairOfStringAndList()

		def ContainsAPairOfStringAndList()
			return This.IsPairOfStringAndListOnly()

		def ContainsOnlyPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def ContainsPairOfAStringAndAListOnly()
			return This.IsPairOfStringAndList()

		def ContainsOnlyAPairOfAStringAndAList()
			return This.IsPairOfStringAndList()

		def ContainsAPairOfAStringAndAListOnly()
			return This.IsPairOfStringAndList()

		#>

	def IsPairOfListAndString()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isString(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def IsAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		#--

		def IsMadeOfPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsMadeOfAPairOfListAndString()
			return This.IsPairOfListAndString()

		def IsMadeOfPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def IsMadeOfAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		#--

		def ContainsOnlyPairOfListAndString()
			return This.IsPairOfListAndString()

		def ContainsPairOfListAndStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyAPairOfListAndString()
			return This.IsPairOfListAndString()

		def ContainsAPairOfListAndStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def ContainsPairOfAListAndAStringOnly()
			return This.IsPairOfListAndString()

		def ContainsOnlyAPairOfAListAndAString()
			return This.IsPairOfListAndString()

		def ContainsAPairOfAListAndAStringOnly()
			return This.IsPairOfListAndString()

		#>

	def IsPairOfStringAndObject()
		if This.NumberOfItems() = 2 and isString(This.Item(1)) and isObject(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def IsAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		#--

		def IsMadeOfPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def IsMadeOfAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		#--

		def ContainsOnlyPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def ContainsPairOfStringAndObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyAPairOfStringAndObject()
			return This.IsPairOfStringAndObject()

		def ContainsAPairOfStringAndObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def ContainsPairOfAStringAndAnObjectOnly()
			return This.IsPairOfStringAndObject()

		def ContainsOnlyAPairOfAStringAndAnObject()
			return This.IsPairOfStringAndObject()

		def ContainsAPairOfAStringAndAnObjectOnly()
			return This.IsPairOfStringAndObject()

		#>

	def IsPairOfObjectAndString()
		if This.NumberOfItems() = 2 and isObject(This.Item(1)) and isString(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def IsAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		#--

		def IsMadeOfPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsMadeOfAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def IsMadeeOfPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def IsMAdeOfAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		#--

		def ContainsOnlyPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def ContainsPairOfObjectAndStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyAPairOfObjectAndString()
			return This.IsPairOfObjectAndString()

		def ContainsAPairOfObjectAndStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def ContainsPairOfAnObjectAndAStringOnly()
			return This.IsPairOfObjectAndString()

		def ContainsOnlyAPairOfAnObjectAndAString()
			return This.IsPairOfObjectAndString()

		def ContainsAPairOfAnObjectAndAStringOnly()
			return This.IsPairOfObjectAndString()

		#>

	def IsPairOfListAndObject()
		if This.NumberOfItems() = 2 and isList(This.Item(1)) and isObject(This.Item(2))
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		def IsAPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		#--

		def IsMadeOfPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		def IsMadeOfAPairOfAListAndAnObject()
			return This.IsPairOfListAndObject()

		#--

		def ContainsOnlyPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def ContainsPairOfListAndObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsOnlyAPairOfListAndObject()
			return This.IsPairOfListAndObject()

		def ContainsAPairOfListAndObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsPairOfAListAndAnObjectOnly()
			return This.IsPairOfListAndObject()

		def ContainsAPairOfAListAndAnObjectOnly()
			return This.IsPairOfListAndObject()

		#>

	#--

	def IsPairOfChars()
		return This.IsPair() and This.IsListOf(:Chars)

		def IsAPairOfChars()
			return This.IsPairOfChars()

	def IsPairOf(pcType)
		return This.IsPair() and This.IsListOf(pcType)

		def IsAPairOf(pcType)
			return This.IsPairOf(pcType)

	def IsListOf(pcType)
		/* EXAMPLES

			Q([ 1, 2, 3 ]).IsListOf(:Number)	#--> TRUE

			pcType should be a string containing the name of:
				- a string containing one of the 4 Ring types (given by RingTypes() )
				- a Softanza type ( given by StzTypes() )

			For the sake of expressiveness, pcType can be in plural form:

			Q([ 1, 2, 3 ]).IsListOf(:Numbers)

		*/

		if CheckParams()
			if NOT isString(pcType)
				StzRaise("Incorrect param type! pcType must be a string.")
			ok
		ok

		pcType = Q(pcType).InfereType()

		if pcType = "number" or pcType = "string" or pcType = "list"
			pcType = "A" + pcType
		but pcType = "object"
			pcType = "An" + pcType
		ok

		cCode1 = 'bOk = item.Is' + pcType + '()'
		cCode2 = 'bOk = ( ring_type(item) = "' + upper(pcType) + '" )'

		bResult = TRUE
		aList = This.List()
		nLen = len(aList)

		for i = 1 to nLen
			item = aList[i]

			if isObject(item) and Q( ring_classname(item) ).IsStzClassName()
				eval(cCode1)

			else
				eval(cCode2)
			ok

			if NOT bOk
				bResult = FALSE
				exit
			ok
		next

		return bResult


		def IsAListOf(pcType)
			return This.IsListOf(pcType)

	def IsTree()
		if NOT This.IsEmpty()
			return TRUE

		else
			return FALSE
		ok

		def IsATree()
			return This.IsTree()

	def IsStzTree()
		if This.StzClassName() = "stztree"
			return TRUE
		else
			return FALSE
		ok

		def IsAStzTree()
			return This.IsStzTree()

	def IsTable() #TODO: Review this solution
		try
			new stzTable(This.List())
			return TRUE
		catch
			return FALSE
		done

	def IsPivotTable() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def IsAPivotTable()
			return This.IsPivotTable()

	def IsGraph() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	#=====

	def IsListOfPairsOfStzObjects()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzObjects(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfStzObjects()
			return This.IsListOfPairsOfStzObjects()

	def IsListOfPairsOfStzNumbers()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzNumbers(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult
	
		def ArePairsOfStzNumbers()
			return This.IsListOfPairsOfStzNumbers()

	def IsListOfPairsOfStzStrings()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzStrings(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult
	
		def ArePairsOfStzStrings()
			return This.IsListOfPairsOfStzStrings()

	def IsListOfPairsOfStzLists()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStzLists(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfStzlists()
			return This.IsListOfPairsOfStzLists()

	def IsListOfPairsOfNumberAndString()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndString()
			return This.IsListOfPairsOfNumberAndString()

	def IsListOfPairsOfStringAndNumber()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndNumber()
			return This.IsListOfPairsOfStringAndNumber()

	def IsListOfPairsOfNumberAndList()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndlist(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndList()
			return This.IsListOfPairsOfNumberAndList()

	def IsListOfPairsOfListAndNumber()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfListAndNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndNumber()
			return This.IsListOfPairsOfListAndNumber()

	def IsListOfPairsOfNumberAndObject()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfNumberAndObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfNumberAndObject()
			return This.IsListOfPairsOfNumberAndObject()

	def IsListOfPairsOfObjectAndNumber()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfObjectAndNumber(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfObjectAndNumber()
			return This.IsListOfPairsOfObjectAndNumber()

	def IsListOfPairsOfStringAndList()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndList()
			return This.IsListOfPairsOfStringAndList()

	def IsListOfPairsOfListAndString()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfListAndString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndString()
			return This.IsListOfPairsOfListAndString()

	def IsListOfPairsOfStringAndObject()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOfStringAndObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfStringAndObject()
			return This.IsListOfPairsOfStringAndObject()

	def IsListOfPairsOfObjectAndString()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPairOdObjectAndString(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def AreairsOfObjectAndString()
			return This.IsListOfPairsOfObjectAndString()

	def IsListOfPairsOfListAndObject()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfListAndObject(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfListAndObject()
			return This.IsListOfPairsOfListAndObject()

	def IsListOfPairsOfObjectAndList()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfObjectAndList(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ArePairsOfObjectAndList()
			return This.IsListOfPairsOfObjectAndList()

	def IsListOfPairsOfChars()
		bResult = TRUE
		nLen = len(@aContent)

		for i = 1 to nLen
			if NOT @IsPAirOfChars(@aContent[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult	

		def ArePairsOfChars()
			return This.IsListOfPairsOfChars()

	  #----------------------------#
	 #   SAME TYPE & SAME VALUE   #
	#----------------------------#

	def ItemsHaveSameType()
		return This.IsPureList()

		def AllItemsHaveSameType()
			return This.ItemsHaveSameType()

		def AreOfSametype()
			return This.ItemsHaveSameType()

		def IsMadeOfItemsOfSameType()
			return This.ItemsHaveSameType()

	def ItemsHaveSameValue()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE
		if This.ItemsHaveSameType()
			if This.ItemsAreAllNumbers() or This.ItemsAreAllStrings()
				for i = 2 to nLen		
					if aContent[i] != aContent[i-1]
						bResult = FALSE
						exit
					ok
				next

			but This.ItemsAreAllLists()
				for i = 2 to nLen
					oTempList = new stzList(aContent[i])
					if oTempList.IsEqualTo(aContent[i-1])
						bResult = FALSE
						exit
					ok
				next

			but ItemsAreAllObjects()
				StzRaise("Can't compare between objects!")
			
			else
				StzRaise("Unsupported type!")
			ok
		else
			bResult = FALSE
		ok

		return bResult

		def AllItemsHaveSameValue()
			return This.ItemsHaveSameValue()

		def AreOfSameValue()
			return This.ItemsHaveSameValue()

		def IsMadeOfItemsOfSameValue()
			return This.ItemsHaveSameValue()

	  #-----------------------------------#
	 #  CHECKING IF ALL ITEMS ARE EQUAL  #
	#-----------------------------------#

	def ItemsAreAllEqualCS(pCaseSensitive)

		nLen = This.NumberOfItems()
		if nLen = 0
			return FALSE
		but nLen = 1
			return TRUE
		ok

		aContent = This.Content()

		oFirstItem = Q(aContent[1])


		bResult = TRUE
		for i = 2 to nLen

			if isNumber(aContent[i])
				if NOT aContent[i] = aContent[1]
					bResult = FALSE
					exit
				ok

			but isString(aContent[i]) or isList(aContent[i])
				if NOT oFirstItem.IsEqualToCS(aContent[i], pCaseSensitive)
					bResult = FALSE
					exit
				ok

			else // isObject(aContent[i])
				if NOT oFirstItem.IsEqualTo(aContent[i])
					bResult = FALSE
					exit
				ok
			ok
		next

		return bResult
		
		#< @FunctionAlternativeForms

		def ItemsAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AllItemsAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def AreAllEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def IsMadeOfEqualItemsCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		def IsMadeOfItemsThatAreEqualCS(pCaseSensitive)
			return This.ItemsAreAllEqualCS(pCaseSensitive)

		#>

	#-- CASESENSITIVITY

	def ItemsAreAllEqual()
		return This.ItemsAreAllEqualCS(TRUE)

		#< @FunctionAlternativeForms

		def ItemsAreEqual()
			return This.ItemsAreAllEqual()

		def AllItemsAreEqual()
			return This.ItemsAreAllEqual()

		def AreEqual(pCaseSensitive)
			return This.ItemsAreAllEqual()

		def AreAllEqual(pCaseSensitive)
			return This.ItemsAreAllEqual()

		def IsMadeOfEqualItems()
			return This.ItemsAreAllEqual()

		def IsMadeOfItemsThatAreEqual()
			return This.ItemsAreAllEqual()

		#>

	  #----------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE EQUAL TO A GIVEN VALUE  #
	#----------------------------------------------------#

	def ItemsAreAllEqualTo(pValue)
		bResult = TRUE
		nLen = This.NumberOfItems()

		aContent = This.Content()

		for i = 1 to nLen
			
			if NOT Q(aContent[i]).IsEqualTo(pValue)
				bResult = FALSE
				exit
			ok

		next
		return bResult

		def AllItemsAreEqualTo(pValue)
			return This.AllItemsAreEqualTo(pValue)

		def IsMadeOfItemsEqualTo(pValue)
			return This.AllItemsAreEqualTo(pValue)

		def AreAllEqualTo(pValue)
			return This.AllItemsAreEqualTo(pValue)

	  #---------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE LISTS HAVING SAME NUMBER OF ITEMS  #
	#---------------------------------------------------------------#

	def ContainsOnlyListsWithSameNumberOfItems()
		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok

		if NOT isList(aContent[1])
			return FALSE
		ok

		nLenFirst = len(aContent[1])
		if nLenFirst = 1
			return TRUE
		ok

		bResult = TRUE

		for i = 2 to nLen

			if NOT ( isList(aContent[i]) and len(aContent[i]) = nLen )
				bResult = FALSE
				exit
			ok

		next
		return bResult

		def ItemsAreAllListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def AllItemsAreListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

		def IsMadeOfListsWithSameNumberOfItems()
			return This.ContainsOnlyListsWithSameNumberOfItems()

	  #-----------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE STRINGS CONTAINING VALID RING CODES  #
	#-----------------------------------------------------------------#

	def ContainsOnlyValidRingCodes()
		bResult = TRUE

		if NOT This.IsListOfStrings()
			return FALSE
		ok

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT Q(aContent[i]).IsValidRingCode()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def AllItemsAreValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

		def ItemsAreAllValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

		def IsMadeOfValidRingCodes()
			return This.ContainsOnlyValidRingCodes()

	  #---------------------------------------------------------------------#
	 #  CHECKING IF ALL ITEMS ARE STRINGS CONTAINING SOFTANZA CLASS NAMES  #
	#---------------------------------------------------------------------#

	def ContainsOnlyStzClassNames()
		bResult = TRUE

		if NOT This.IsListOfStrings()
			return FALSE
		ok

		nLen = This.NumberOfItems()
		aContent = This.Content()

		for i = 1 to nLen

			if NOT Q(aContent[i]).IsStzClassName()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def AllItemsAreStzClassNames()
			return This.ContainsOnlyStzClassNames()

		def ItemsAreAllStzClassNames()
			return This.ContainsOnlyStzClassNames()

		def IsMadeOfStzClassNames()
			return This.ContainsOnlyStzClassNames()

	  #======================#
	 #   MANAGING WALKERS   #TODO
	#======================#

	def AddWalker(pcName, pnStart, pnEnd, panStepping)

		if NOT ( StzNumberQ(pnStart).IsBetween(1, This.NumberOfItems()) and
		         StzNumberQ(pnEnd).IsBetween(1, This.NumberOfItems()) )

			StzRaise("Start or end of walker outside list range!")
		ok

		bNewName = TRUE
		for aWalk in This.Walkers()
			if aWalk[1] = pcName
				bNewName = FALSE
				exit
			ok
		next

		if NOT bNewName
			StzRaise(stzListError(:CanNotAddWalkerAlreadyExistant))
		else
			oWalk = new stzWalker(pnStart, pnEnd, panStepping)
			@aWalkers + [ pcName, oWalk.Content() ]
		ok

	def Walkers()
		return @aWalkers

	def Walker(pcWalker)
		return This.Walkers()[pcWalker]

	def FindWalker(pcWalker) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	def RemoveWalker(pcWalker)
		del( @aWalkers, This.FindWalker(pcWalker) )

	def RemoveTheseWalkers(pacNames) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

	def RemoveWalkers()
		@aWalkers = []

		def RemoveAllWalkers()
			This.RemoveWalkers()

	def CombineTheseWalkers(pacNames) #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def ComposeTheseWalkers(pacNames)
			return This.CombineTheseWalkers(pacNames)

	def CombineWalkers()
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def CombineAllWalkers()
			This.CombineWalkers()

		def ComposeWalkers()
			This.CombineWalkers()

		def ComposeAllWalkers()
			This.CombineWalkers()

	def CombinedWalkers() #TODO
		/* ... */
		StzRaise("Inexistant feature in this release!")

		def ComposedWalkers()
			return This.CombinedWalkers()

	  #=================#
	 #  WALKING WHERE  #
	#=================#

	def WalkWhere(pcCondition)
		return This.WalkWhereXT(pcCondition, :Forward, :Return = :WalkedPositions)

		def WalkW(pcCondition)
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			return This.WalkWhere(pcCondition)

	def WalkWhereXT(pcCondition, pcDirection, pReturn)
		/*
		o1 = new stzList([ 1, "A", 3, "B", "_", 6 ])

		? WalkWhere("isNumber(@item)")
		#--> [1, 3, 6]
		*/

		# Checking params

		if CheckParams()
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
	
			if isList(pReturn) and
			   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])
	
				pReturn = pReturn[2]
			ok
	
			if NOT ( isString(pReturn) and
	
				 Q(pReturn).IsOneOfThese([
					:WalkedPositions, :WalkedItems,
					:LastPosition, :LastWalkedPosition,
					:LastItem, :LastWalkedItem,
					:Default
				]) )
	
				StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
					 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
			ok
	
			if pReturn = :Default
				pReturn = :WalkedPositions
			ok
	
			if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
				pcDirection = pcDirection[2]
			ok
	
			if NOT ( isString(pcDirection) and
				 Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )
	
				StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
			ok
	
			if pcDirection = :Default
				pcDirection = :Forward
			ok
		ok

		# Doing the job

		anPos = []

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				anPos + @i
			ok
	
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		def WalkWXT(pcCondition, pReturn)
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			return This.WalkWhereXT(pcCondition, pReturn)

	  #============================================#
	 #  WALKING UNTIL (AND WALKING UNTIL BEFORE)  #
	#============================================#

	def WalkUntil(pcCondition)
		return This.WalkUntilXT(pcCondition, :Forward, :WalkedPositions)

	def WalkUntilBefore(pcCondition)
		return This.WalkUntil( :Before = pcCondition )

	def WalkUntilXT(pcCondition, pcDirection, pReturn)
		/*
		[ "A", "B", 12, "C", "D", "E", 4, "F", 25, "G", "H" ]

		WalkUntil("@item = 'D'", :Return = :WalkedPositions  )  #--> 1:5
		WalkUntil("@item = 'D'", :Return = :LastPosition )  #--> 5

		WalkUntil("@item = 'D'", :Return = :WalkedItems )
		#--> [ "A", "B", 12, "C", "D" ]

		WalkUntil("@item = 'D'", :Return = :LastItem ) #--> "D"


		WalkUntil("isNumber(@item)") #--> 1:3
		WalkUntil("isNumber(@item) and @item > 20") #--> 1:9
		*/

		bWalkBefore = FALSE

		# Checking the params

		if isList(pcCondition) and Q(pcCondition).IsBeforeNamedParam()
			bWalkBefore = TRUE
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok
		# Doing the job

		cCode = 'bOk = ( ' +  StzCCodeQ(pcCondition).Transpiled() + ' )'

		bFound = FALSE
		aList = This.Content()
		nLen = This.NumberOfItems()

		anPos = []

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				if bWalkBefore = FALSE
					anPos + @i
				ok

				exit
			ok

			anPos + @i
			
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	def WalkUntilBeforeXT(pcCondition, pReturn)
		return This.WalkUntilXT( :Before = pcCondition, pReturn)

	  #=================#
	 #  WALKING WHILE  #
	#=================#

	def WalkWhile(pcCondition)
		return This.WalkWhileXT(pcCondition, :Forward, :WalkedPositions)

	def WalkWhileXT(pcCondition, pcDirection, pReturn)
		/*
		o1 = new stzList([ "A", "B", "_", "*", 12, "C", "D", 4 ])

		? WalkWhile("Q(@item).IsNotNumber()")
		#--> 1:4
		*/

		# Checking params

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if NOT bOk
				exit
			ok

			anPos + @i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #================#
	 #  WALKING WHEN  #
	#================#

	def WalkWhen(pcCondition)
		return This.WalkWhenXT(pcCondition, :Forward, :WalkedPositions)

	def WalkWhenXT(pcCondition, pcDirection, pReturn)

		# Checking params

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )

			StzRaise("Incorrect param type! pcDirection must be one of these strings [ :Forward, :Backward, :Default ].")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'

		anPos = []
		nLen = This.NumberOfItems()

		nStart = 1
		nEnd   = nLen
		nStep  = 1

		if pcDirection = :Backward
			nStart = nLen
			nEnd   = 1
			nStep  = -1
		ok

		for @i = nStart to nEnd step nStep
			@item = @aContent[@i]
			eval(cCode)

			if bOk
				anPos = @i : nEnd
				exit
			ok

			
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #===================#
	 #  WALKING BETWEEN  #
	#===================#

	def WalkBetween(n1, n2)
		return This.WalkBetweenIB(n1, n2, :WalkedPositions)

	def WalkBetweenIB(n1, n2, pReturn)

		# Checking params

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :Position, :Positions ])
			n1 = n1[2]
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :Position, :AndPosition, :And ])
			n2 = n2[2]
		ok

		if NOT Q([ n1, n2 ]).BothAreNumbers()
			StzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		anPos = []
		nLen = This.NumberOfItems()

		anPos = n1 : n2

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #===================================#
	 #  WALKING THE LIST FORTH AND BACK  #
	#===================================#

	def WalkForthAndBack()
		return This.WalkForthAndBackXT(:Return = :WalkedPositions)

	def WalkForthAndBackXT(pReturn)

		# Checking pReturn param

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = 1 : This.NumberOfItems()

		for i = This.NumberOfItems()-1 to 1 step -1
			anPos + i
		next
		
		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #-----------------------------------#
	 #  WALKING THE LIST BACK AND FORTH  #
	#-----------------------------------#

	def WalkBackAndForth()
		return This.WalkBackAndForthXT(:Return = :WalkedPositions)

	def WalkBackAndForthXT(pReturn)

		# Checking pReturn param

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = This.NumberOfItems() : 1

		for i = 2 to This.NumberOfItems()
			anPos + i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

	  #===============================================#
	 #  WALKING THE LIST EACH TIME N ITEMS FORWARD   #
	#===============================================#

	def WalkNItemsForward(n)
		return This.WalkNItemsForwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkNStepsForward(n)
			return This.WalkNItemsForward(n)

		def WalkForward(n)
			return This.WalkNItemsForward(n)

		def WalkNForward(n)
			return This.WalkNItemsForward(n)

		#--

		def WalkEachTimeNSItemsForward(n)
			return This.WalkNItemsForward(n)

		def WalkEachTimeNStepsForward(n)
			return This.WalkNItemsForward(n)

		#>

	def WalkNItemsForwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = []

		for i = 1 to This.NumberOfItems() step n
			anPos + i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlterntives

		def WalkNStepsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkNForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		#--

		def WalkEachTimeNSItemsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		def WalkEachTimeNStepsForwardXT(n, pReturn)
			return This.WalkNItemsForwardXT(n, pReturn)

		#>

	  #-----------------------------------------------#
	 #  WALKING THE LIST EACH TIME N ITEMS BACKWARD  #
	#-----------------------------------------------#

	def WalkNItemsBackward(n)
		return This.WalkNItemsBackwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkNStepsBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkNBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkBackward(n)
			return This.WalkNItemsBackward(n)

		#--

		def WalkEachTimeNItemsBackward(n)
			return This.WalkNItemsBackward(n)

		def WalkEachTimeNStepsBackward(n)
			return This.WalkNItemsBackward(n)

		#>

	def WalkNItemsBackwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = []

		for i = This.NumberOfItems() to 1 step -n
			anPos + i
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkNStepsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkNBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		#--

		def WalkEachTimeNItemsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		def WalkEachTimeNStepsBackwardXT(n, pReturn)
			return This.WalkNItemsBackwardXT(n, pReturn)

		#>

	  #===========================================================#
	 #  WALKING THE LIST EACH TIME N MORE ITEMS FORWARD   #
	#===========================================================#

	def WalkNProgressiveItemsForward(n)
		return This.WalkNProgressiveItemsForwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkProgressiveNItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkNProgressiveStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNProgressiveStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkProgressiveNStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkNMoreItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNMoreItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkNMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkMoreNItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeMoreStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkNMoreForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#--

		def WalkMoreForward(n)
			return This.WalkNProgressiveItemsForward(n)

		#==

		def WalkNCumulativeItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)

		def WalkEachTimeNCumulativeItemsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkCumulativeNItemsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		#--

		def WalkNCumulativeStepsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		def WalkEachTimeNCumulativeStepsForward(n)
			return This.WalkNProgressiveItemsForward(n)


		def WalkCumulativeNStepsForward(n)
			return This.WalkNCumulativeItemsForward(n)

		#>

	def WalkNProgressiveItemsForwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = []

		if n < 0

			StzRaise("Can't proceed. n must be positive!")
		but n = 0
			anPos = [1]

		else
			anPos = [1]
			nstep = 1
			i = 0
			
			while nStep <= This.NumberOfItems()
				i++
				nStep += (n * i)
				if nStep <= This.NumberOfItems()
					anPos + nStep
				ok
			end

		ok

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkProgressiveNItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkNProgressiveStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNProgressiveStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkProgressiveNStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkNMoreItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNMoreItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkNMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkMoreNItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeMoreStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkNMoreForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#--

		def WalkMoreForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		#==

		def WalkNCumulativeItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)

		def WalkEachTimeNCumulativeItemsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkCumulativeNItemsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		#--

		def WalkNCumulativeStepsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		def WalkEachTimeNCumulativeStepsForwardXT(n, pReturn)
			return This.WalkNProgressiveItemsForwardXT(n, pReturn)


		def WalkCumulativeNStepsForwardXT(n, pReturn)
			return This.WalkNCumulativeItemsForwardXT(n, pReturn)

		#>

	  #------------------------------------------------------------#
	 #  WALKING THE LIST EATCH TIME N PROGRESSIVE ITEMS BACKWARD  #
	#------------------------------------------------------------#

	def WalkNProgressiveItemsBackward(n)
		return This.WalkNProgressiveItemsBackwardXT(n, :Return = :WalkedPositions)

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkProgressiveNItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkNProgressiveStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNProgressiveStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkProgressiveNStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkNMoreItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNMoreItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkNMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkMoreNItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkMoreStepsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkNMoreBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#--

		def WalkMoreBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		#==

		def WalkNCumulativeItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)

		def WalkEachTimeNCumulativeItemsBackward(n)
			return This.WalkNProgressiveItemsBackward(n)


		def WalkCumulativeNItemsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		#--

		def WalkNCumulativeStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		def WalkEachTimeNCumulativeStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)


		def WalkCumulativeNStepsBackward(n)
			return This.WalkNCumulativeItemsBackward(n)

		#>

	def WalkNProgressiveItemsBackwardXT(n, pReturn)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param! n must be a number.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		# Doing the job

		anPos = []

		if n < 0
			StzRaise("Can't proceed. n must be positive!")

		but n = 0
			anPos = [ This.NumberOfItems() ]

		else
			anPos = [ This.NumberOfItems() ]
			nStep = This.NumberOfItems()
			i = 0
			
			while nStep > 0
				i++
				nStep -= (n * i)
				if nStep > 0
					anPos + nStep
				ok
			end
	
		ok

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForms

		def WalkEachTimeNProgressiveItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkProgressiveNItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkNProgressiveStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNProgressiveStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkProgressiveNStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkNMoreItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNMoreItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkNMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkMoreNItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkMoreStepsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkNMoreBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#--

		def WalkMoreBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		#==

		def WalkNCumulativeItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)

		def WalkEachTimeNCumulativeItemsBackwardXT(n, pReturn)
			return This.WalkNProgressiveItemsBackwardXT(n, pReturn)


		def WalkCumulativeNItemsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		#--

		def WalkNCumulativeStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		def WalkEachTimeNCumulativeStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)


		def WalkCumulativeNStepsBackwardXT(n, pReturn)
			return This.WalkNCumulativeItemsBackwardXT(n, pReturn)

		#>

	  #================================================#
	 #  WALKING N ITEMS FORWARD AND N ITEMS BACKWARD  #
	#================================================#

	def WalkNItemsForwardNItemsBackward(pnForward, pnBackward)
		return This.WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsForwardNItemsBackward(pnForward, pnBackward)
			return This.WalkNItemsForwardNItemsBackward(pnForward, pnBackward)


		def WalkNStepsForwardNStepsBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		def WalkEachTimeNStepsForwardNStepsBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)


		def WalkNForwardNBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		def WalkForwardBackward(pnForward, pnBackward)
			return This.WalkNITemsForwardNItemsBackward(pnForward, pnBackward)

		#>

	def WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		# Checking params

		if NOT Q([pnForward, pnBackward]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnForward and pnBackward must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		if pnForward = pnBackward
			return []
		ok

		if pnBackward > pnForward
			nStart = pnBackward - pnForward + 1
		else
			nStart = 1
		ok

		i = nStart
		anPos = [ i ]

		while Q(i + pnForward).IsBetween(1, nLen) and
		      Q(i + pnForward - pnBackward).IsBetween(1, nLen)

			i = i + pnForward
			anPos + i

			i = i - pnBackward
			anPos + i

		end

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end
	
		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNItemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)


		def WalkNStepsForwardNStepsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkEachTimeNStepsForwardNStepsBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkNForwardNBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		def WalkForwardBackwardXT(pnForward, pnBackward, pReturn)
			return This.WalkNITemsForwardNItemsBackwardXT(pnForward, pnBackward, pReturn)

		#>

	  #------------------------------------------------#
	 #  WALKING N ITEMS FORWARD AND N ITEMS BACKWARD  #
	#------------------------------------------------#

	def WalkNItemsBackwardNItemsForward(pnBackward, pnForward)
		return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsBackwardNItemsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)


		def WalkNStepsBackwardNStepsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)

		def WalkEachTimeNStepsBackwardNStepsForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)


		def WalkNBackwardNForward(pnForward, pnBackward)
			return This.WalkNITemsBackwardNItemsForward(pnForward, pnBackward)

		def WalkBackwardForward(pnForward, pnBackward)
			return This.WalkNItemsBackwardNItemsForward(pnForward, pnBackward)

		#>

	def WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		# Checking params

		if NOT Q([pnBackward, pnForward]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnForward and pnBackward must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		if pnForward = pnBackward
			return []
		ok

		if pnForward > pnBackward
			nStart = nLen - pnBackward
		else
			nStart = nLen
		ok

		i = nStart
		anPos = [ nStart ]

		while Q(i - pnBackward).IsBetween(1, nLen) and
		      Q(i - pnBackward + pnForward ).IsBetween(1, nLen)

			i = i - pnBackward
			anPos + i

			i = i + pnForward
			anPos + i

		end

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)


		def WalkNStepsBackwardNStepsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		def WalkEachTimeNStepsBackwardNStepsForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)


		def WalkNBackwardNForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNITemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		def WalkBackwardForwardXT(pnBackward, pnForward, pReturn)
			return This.WalkNItemsBackwardNItemsForwardXT(pnBackward, pnForward, pReturn)

		#>

	  #===================================================#
	 #  WALKING N STEPS FROM START AND N STEPS FROM END  #
	#===================================================#

	def WalkNItemsFromStartNItemsFromEnd(nFromStart, nFromEnd)
		return This.WalkNItemsFromStartNItemsFromEndXT(nFromStart, nFromEnd, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)


		def WalkNStepsFromStartNStepsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkEachTimeNStepsFromStartNStepsFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)


		def WalkNFromStartNFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkFromStartFromEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkNStartNEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		def WalkStartEnd(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromStartNItemsFromEnd(pnFromStart, pnFromEnd)

		#>

	def WalkNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		# Checking params

		if NOT Q([pnFromStart, pnFromEnd]).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnFromStart and pnFromEnd must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		anPos = [ 1 ]

		for i = 1 to nLen
			nPosFromStart = i + pnFromStart
			nPosFromEnd   = nLen - i - pnFromEnd + 1

			if nPosFromEnd >= nPosFromStart
				anPos + nPosFromStart
				if nPosFromEnd != nPosFromStart
					anPos + nPosFromEnd
				ok
			ok
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end
	
		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNItemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)


		def WalkNStepsFromStartNStepsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkEachTimeNStepsFromStartNStepsFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkNFromStartNFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkFromStartFromEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkNStartNEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		def WalkStartEndXT(pnFromStart, pnFromEnd, pReturn)
			return This.WalkNITemsFromStartNItemsFromEndXT(pnFromStart, pnFromEnd, pReturn)

		#>

	  #---------------------------------------------------#
	 #  WALKING N ITEMS FROM END AND N ITEMS FROM START  #
	#---------------------------------------------------#

	def WalkNItemsFromEndNItemsFromStart(pnFromEnd, pnFromStart)
		return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, :Return = :WalkedPositions)

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)


		def WalkNStepsFromEndNStepsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkEachTimeNStepsFromEndNStepsFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)


		def WalkNFromEndNFromStart(pnFromStart, pnFromEnd)
			return This.WalkNITemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkFromEndFromStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkNEndNStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		def WalkEndStart(pnFromStart, pnFromEnd)
			return This.WalkNItemsFromEndNItemsFromStart(pnFromStart, pnFromEnd)

		#>

	def WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		# Checking params

		if NOT Q(pnFromEnd, pnFromStart).BothAreNumbers()
			StzRaise("Incorrect param type! Both pnFromStart and pnFromEnd must be numbers.")
		ok

		if isList(pReturn) and
		   Q(pReturn).IsOneOfTheseNamedParams([ :Return, :AndReturn ])

			pReturn = pReturn[2]
		ok

		if NOT ( isString(pReturn) and

			 Q(pReturn).IsOneOfThese([
				:WalkedPositions, :WalkedItems,
				:LastPosition, :LastWalkedPosition,
				:LastItem, :LastWalkedItem,
				:Default
			]) )

			StzRaise("Incorrect param! pReturn must be a string. Allowed values are " +
				 ":WalkedPositions, :WalkedItems, :LastWalkedPosition, :LastWalkedItem, and :Default." )
		ok

		if pReturn = :Default
			pReturn = :WalkedPositions
		ok

		# Doing the job

		aList = This.List()
		nLen = len(aList)

		anPos = [ 7 ]

		for i = nLen to 1 step -1

			nPosFromEnd   = i - pnFromEnd
			nPosFromStart = nLen - i + 1

			if nPosFromEnd >= nPosFromStart
				anPos + nPosFromEnd
				
				if nPosFromStart != nPosFromEnd
					anPos + nPosFromStart
				ok
			ok
		next

		if pReturn = :WalkedItems
			return This.ItemsAt(anPos)

		but pReturn = :WalkedPositions
			return anPos

		but pReturn = :LastItem or pReturn = :LastWalkedItem
			return This.ItemAt(len(anPos))

		but pReturn = :LastPosition or pReturn = :LastWalkedPosition
			return anPos[len(anPos)]

		else
			return anPos
		end

		#< @FunctionAlternativeForm

		def WalkEachTimeNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)


		def WalkNStepsFromEndNStepsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkEachTimeNStepsFromEndNStepsFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)


		def WalkNFromEndNFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNITemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkFromEndFromStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkNEndNStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		def WalkEndStartXT(pnFromEnd, pnFromStart, pReturn)
			return This.WalkNItemsFromEndNItemsFromStartXT(pnFromEnd, pnFromStart, pReturn)

		#>

	  #===========================================#
	 #   EXPANDING THE LIST OF PAIR OF NUMBERS   #
	#===========================================#

	/* Example
		o1 = new stzList([ 12, 7 ])
		? o1.ExpandedIfPairOfNumbers() #--> [ 12, 11, 10, 9, 8, 7 ]
	*/

	def ExpandIfPairOfNumbers() #TODO: Should be delegated to stzPairOfNumbers
		if This.IsPairOfNumbers()
			n1 = This.Item(1)
			n2 = This.Item(2)

			anResult = n1 : n2

			This.UpdateWith( anResult )
		ok

		def ExpandIfPairOfNumbersQ()
			This.ExpandIfPairOfNumbers()
			return This

	def ExpandedIfPairOfNumbers()
		bResult = This.Copy().ExpandIfPairOfNumbersQ().Content()
		return bResult

	  #========================================================#
	 #   CHECKING IF ALL THE ITEMS VERIFY A GIVEN CONDITION   #
	#========================================================#

	def CheckW(pcCondition)
		#< @MotherFunction = CheckOnPositionsW > @RingBased #>

		/* EXAMPLE

		o1 = new stzList([ "BING", "BINGO", "BINGOO", "BINGOOO", "BINGOOOO" ])
		? o1.CheckW( :That = '{ @NextItem = @item + "O" }' )	#--> TRUE

		*/

		bResult = This.CheckOnPositionsW(1:This.NumberOfItems(), pcCondition)
		return bResult

		#< @FunctionAlternativeForms

		def Check(pcCondition)
			return This.CheckW(pcCondition)

		def Verify(pcCondition)
			return This.CheckW(pcCondition)

		def EachItemVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def EachItemVerify(pcCondition)
			return This.CheckW(pcCondition)

		def AllItemsVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def AllItemsVerify(pcCondition)
			return This.CheckW(pcCondition)

		def ItemsVerify(pcCondition)
			return This.CheckW(pcCondition)

		def ItemsVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		#>

	  #-------------------------------------------------------------------#
	 #   CHECKING IF ITEMS AT GIVEN POSITIONS VERIFY A GIVEN CONDITION   #
	#-------------------------------------------------------------------#

	def CheckOnW(panPos, pcCondition)
		#< @MotherFunction = YES | @RingBased #>

		/* EXAMPLE

		o1 = new stzList([ "Word1", " 2", "Word3", " 4", "Word5", " 6" ])
		? o1.CheckOnW([1, 3, 5], :That = 'Q(@item).IsLeftToRight()' ) #--> TRUE

		*/
		if This.IsEmpty()
			return FALSE
		ok

		if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
			StzRaise("Invalid param type! panPos must be a list of numbers.")
		ok

		if len(panPos) = 0
			return FALSE
		ok

		if isList(pcCondition) and Q(pcCondition).IsThatOrWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pccondition)
			StzRaise("Incorrect param! pcCondition must be a string.")
		ok

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ' )'
		oCode = StzStringQ(cCode)
		
		nLenPositions = len(panPos)
		bResult = TRUE

		for n = 1 to nLenPositions
			@i = panPos[n]
			@item = @aContent[@i]
			bEval = TRUE

			if @i = This.NumberOfItems() and
			   oCode.Copy().RemoveSpacesQ().ContainsCS("This[@i+1]", :CS=FALSE)

				bEval = FALSE

			but @i = 1 and
			    oCode.Copy().RemoveSpacesQ().ContainsCS("This[@i-1]", :CS=FALSE)

				bEval = FALSE
			ok

			if bEval

				eval(cCode)

				if bOk = FALSE
					bResult = FALSE
					exit
				ok
			ok

		next

		return bResult

		#< @FunctionAlternativeForms

		def CheckOn(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def CheckOnPositionsW(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def CheckOnThesePositionsW(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def CheckOnPositions(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)


		def VerifyOn(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def VerifyOnPositionsW(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def VerifyOnThesePositionsW(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def VerifyOnPositions(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		#>

	  #------------------------------------------------------------------------------#
	 #   CHECKING IF ITEMS AT GIVEN POSITIONS VERIFY A GIVEN CONDITION -- EXTENDED  #
	#------------------------------------------------------------------------------#

	def CheckOnWXT(panPos, pcCondition)
		#< @MotherFunction = YES | @RingBased #>

		if This.IsEmpty()
			return FALSE
		ok

		if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
			StzRaise("Invalid param type! panPos must be a list of numbers.")
		ok

		if len(panPos) = 0
			return FALSE
		ok

		if isList(pcCondition) and Q(pcCondition).IsThatOrWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pccondition)
			StzRaise("Incorrect param! pcCondition must be a string.")
		ok

		oCCode = StzCCodeQ(pcCondition)
		cCode = 'bOk = ( ' + oCCode.Transpiled() + ' )'
		oCode = StzStringQ(cCode)
		
		nLenPositions = len(panPos)
		bResult = TRUE

		for n = 1 to nLenPositions
			@i = panPos[n]
			@item = @aContent[@i]
			bEval = TRUE

			if @i = This.NumberOfItems() and
			   oCode.Copy().RemoveSpacesQ().ContainsCS("This[@i+1]", :CS=FALSE)

				bEval = FALSE

			but @i = 1 and
			    oCode.Copy().RemoveSpacesQ().ContainsCS("This[@i-1]", :CS=FALSE)

				bEval = FALSE
			ok

			if bEval

				eval(cCode)

				if bOk = FALSE
					bResult = FALSE
					exit
				ok
			ok

		next

		return bResult

		#< @FunctionAlternativeForms

		def CheckOnXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		def CheckOnPositionsWXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		def CheckOnThesePositionsWXT(panPos, pcCondition)
			return This.CheckOnW(panPos, pcCondition)

		def CheckOnPositionsXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)


		def VerifyOnXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		def VerifyOnPositionsWXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		def VerifyOnThesePositionsWXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		def VerifyOnPositionsXT(panPos, pcCondition)
			return This.CheckOnWXT(panPos, pcCondition)

		#>

	  #------------------------------------------------------------------#
	 #   CHECKING IF ITEMS AT GIVEN SECTIONS VERIFY A GIVEN CONDITION   #
	#------------------------------------------------------------------#

	def CheckOnSectionsW(paSections, pcCondition)
		#< @MotherFunction = CheckOnPositionsW > @RingBased #>


		# Checking correctness of paSections param

		if NOT ( isList(paSections) and
			 Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		if len(paSections) = 0
			return FALSE
		ok

		# Getting all the positions from the provided sections
		# Example: [ [2,5], [7,9 ] --> [ 2, 3, 4, 5, 7, 8, 9 ]

		aSectionsExpanded = []
		for aPair in paSections
			aSectionsExpanded + StzListQ(aPair).ExpandedIfPairOfNumbers()
		next

		anPosMerged = ListsMerge( aSectionsExpanded )

		anPos = StzListQ(anPosMerged).ToSet()

		bResult = This.CheckOnW(anPos, pcCondition)
		return bResult

		#< @FunctionAlternativeForm

		def CheckOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		#>

	  #----------------------------------------------------------------------------#
	 #  CHECKING IF ITEMS AT GIVEN SECTIONS VERIFY A GIVEN CONDITION -- EXTENDED  #
	#----------------------------------------------------------------------------#

	def CheckOnSectionsWXT(paSections, pcCondition)
		#< @MotherFunction = CheckOnPositionsW > @RingBased #>


		# Checking correctness of paSections param

		if NOT ( isList(paSections) and
			 Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		if len(paSections) = 0
			return FALSE
		ok

		# Getting all the positions from the provided sections
		# Example: [ [2,5], [7,9 ] --> [ 2, 3, 4, 5, 7, 8, 9 ]

		aSectionsExpanded = []
		for aPair in paSections
			aSectionsExpanded + StzListQ(aPair).ExpandedIfPairOfNumbers()
		next

		anPosMerged = ListsMerge( aSectionsExpanded )

		anPos = StzListQ(anPosMerged).ToSet()

		bResult = This.CheckOnWXT(anPos, pcCondition)
		return bResult

		#< @FunctionAlternativeForm

		def CheckOnSectionsXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		def CheckOnTheseSectionsWXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		def CheckOnTheseSectionsXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		def VerifyOnSectionsXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		def VerifyOnTheseSectionsWXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		def VerifyOnTheseSectionsXT(paSections, pcCondition)
			return This.CheckOnSectionsWXT(paSections, pcCondition)

		#>

	  #=========================================#
	 #   YIELDING INFORMATION FROM EACH ITEM   #
	#=========================================#

	/* NOTE:

	This function is more performant then its extended version
	YieldXT(), that it relies on the user to provide it
	with a correct formed condition containing only @i, @item,
	and @list keywords.

	All other keywords should be expressed using the @i keyword.

	For example, @CurrentItem should be expressed using simply This[@i],
	@PreviousItem should be expressed using This[@-1] and so on...

	*/

	def Yield(pcCode)
		nLen = This.NumberOfItems()

		aSection = StzCCodeQ(pcCode).ExecutableSection()
		n1 = aSection[1]
		n2 = aSection[2]
		
		if isString(n2) and n2 = :Last
			n2 = nLen
		ok

		if n2 < 0
			n2 += nLen
		ok

		return This.YieldFrom( n1 : n2, pcCode )

		#< @FunctionFluentForm

		def YieldQ(pcCode)
			return This.YieldQR(pcCode, :stzList)
	
		def YieldQR(pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Yield(pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.Yield(pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.Yield(pcCode) )

			on :stzHashList
				return new stzHashList( This.Yield(pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.Yield(pcCode) )
		
		other
				StzRaise("Unsupported return type!")
		off

		#>

		#< @FunctionAlternativeForms

		def YieldFromEachItem(pcCode)
			return This.Yield(pcCode)

			def YieldFromEachItemQ(pcCode)
				return This.YieldFromEachItemQR(pcCode, :stzList)
		
			def YieldFromEachItemQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromEachItem(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromEachItem(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromEachItem(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromEachItem(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def Harvest(pcCode)
			return This.Yield(pcCode)

			def HervestQ(pcCode)
				return This.YieldFromEachItemQR(pcCode, :stzList)
		
			def HarvestQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.Harvest(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.Harvest(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.Harvest(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.Harvest(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def HarvestFromEachItem(pcCode)
			return This.Yield(pcCode)

			def HarvestFromEachItemQ(pcCode)
				return This.HarvestFromEachItemQR(pcCode, :stzList)
		
			def HarvestFromEachItemQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromEachItem(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromEachItem(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromEachItem(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.HarvestFromEachItem(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionMisspelledForm

		def Yiled(pcCode)
			return This.Yield(pcCode)

		#>

	  #----------------------------------------------------#
 	 #   YIELDING INFORMATION FROM EACH ITEM -- EXTENDED  #
	#----------------------------------------------------#

	/* NOTE

	This function is less performan then it's simplest form Yield(),
	because it takes time to analyze the conditional code provided,
	spacify it, and transpile it, so a keyword like @PrecedentItem
	for example, can be used (in the keyword, the function is transpiled
	to "This[@i-1]" automatically).

	If performance is critical to you, don't use it, but use the simple
	form Yield() instead (supporting only the This[@i...]-like keywords).

	*/

	def YieldXT(pcCode)

		return This.YieldFromXT( 1:This.NumberOfItems(), pcCode )

		#< @FunctionFluentForm

		def YieldXTQ(pcCode)
			return This.YieldXTQR(pcCode, :stzList)
	
		def YieldXTQR(pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldXT(pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldXT(pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldXT(pcCode) )

			on :stzHashList
				return new stzHashList( This.YieldXT(pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldXT(pcCode) )
		
		other
				StzRaise("Unsupported return type!")
		off

		#>

		#< @FunctionAlternativeForms

		def YieldFromEachItemXT(pcCode)
			return This.YieldXT(pcCode)

			def YieldFromEachItemXTQ(pcCode)
				return This.YieldFromEachItemXTQR(pcCode, :stzList)
		
			def YieldFromEachItemXTQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromEachItemXT(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromEachItemXT(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromEachItemXT(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromEachItemXT(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def HarvestXT(pcCode)
			return This.YieldXT(pcCode)

			def HervestXTQ(pcCode)
				return This.YieldFromEachItemXTQR(pcCode, :stzList)
		
			def HarvestXTQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestXT(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestXT(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestXT(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.HarvestXT(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def HarvestFromEachItemXT(pcCode)
			return This.YieldXT(pcCode)

			def HarvestFromEachItemXTQ(pcCode)
				return This.HarvestFromEachItemXTQR(pcCode, :stzList)
		
			def HarvestFromEachItemXTQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromEachItemXT(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromEachItemXT(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromEachItemXT(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.HarvestFromEachItemXT(pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionMisspelledForm

		def YiledXT(pcCode)
			return This.YieldXT(pcCode)

		#>

	  #========================================================#
	 #   YIELDING INFORMATION FROM ITEMS AT GIVEN POSITIONS   #
	#========================================================#

	/* NOTE:
		This function is more performant then its extended version
		YieldFromXT(), that it relies on the user to provide it
		with a correct formed condition containing only @i, @item,
		and @list keywords.

		All other keywords should be expressed using the @i keyword.

		For example, @CurrentItem should be expressed using simply This[@i],
		@PreviousItem should be expressed using This[@-1] and so on...
	*/

	def YieldFrom(panPos, pcCode)

		#< @MotherFunction #>

		if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
			StzRaise("Incorrect param! paPositions must be a list of numbers.")
		ok

		if len(panPos) = 0
			return []
		ok

		panPos = ring_sort(panPos)
		nLenPositions = len(panPos)

		if NOT isString(pcCode)
			StzRaise("Invalid param type! Condition must be a string.")
		ok

		if StzStringQ(pcCode).WithoutSpaces() = 0
			aTemp = []
			
			for i = 1 to nLenPositions
				aTemp + NULL
			next

			return aTemp
		ok

		cCode = "aResult + ( " + StzCCodeQ(pcCode).Transpiled() + " )"
		oCode = StzStringQ(cCode)
		
		aResult = []
		nLenList = This.NumberOfItems()

		for i = 1 to nLenPositions
			@i = panPos[i]
			@item = @aContent[@i]

			bEval = TRUE

			oCodeWS = Q( oCode.WithoutSpaces() )
			bContainsIPlus1  = oCodeWS.ContainsCS( "This[@i+1]", :CS=FALSE )
			bContainsIMinus1 = oCodeWS.ContainsCS( "This[@i-1]", :CS=FALSE )

			if @i = nLenList and bContainsIPlus1
				bEval = FALSE

			but @i = 1 and bContainsIMinus1
				bEval = FALSE
			
			ok

			if bEval

				eval(cCode) # Populates aResult with the yielded information

			ok

		next

		return aResult


		#< @FunctionFluentForm

		def YieldFromQ(paPositions, pcCode)
			return This.YieldFromQR(paPositions, pcCode, :stzList)
	
		def YieldFromQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFrom(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFrom(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFrom(paPositions, pcCode) )
		
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def YieldFromPositions(panPos, pcCode)
			return This.YieldFrom(panPos, pcCode)

			def YieldFromPositionsQ(paPositions, pcCode)
				return This.YieldFromPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromPositions(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def YieldFromItemsAt(panPos, pcCode)
			return This.YieldFrom(panPos, pcCode)

			def YieldFromItemsAtQ(paPositions, pcCode)
				return This.YieldFromItemsAtQR(paPositions, pcCode, :stzList)
		
			def YieldFromItemsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromItemsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromItemsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromItemsAt(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def YieldFromItemsAtPositions(panPos, pcCode)
			return This.YieldOn(panPos, pcCode)

			def YieldFromItemsAtPositionsQ(paPositions, pcCode)
				return This.YieldFromItemsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromItemsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromItemsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromItemsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromItemsAtPositions(paPositions, pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromItemsAtPositions(paPositions, pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def HarvestFrom(panPos, pcCode)
			return This.HarvestFrom(panPos, pcCode)

			def HarvestFromQ(paPositions, pcCode)
				return This.HarvestFromQR(paPositions, pcCode, :stzList)
		
			def HarvestFromQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFrom(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFrom(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFrom(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromPositions(panPos, pcCode)
			return This.HarvestFrom(panPos, pcCode)

			def HarvestFromPositionsQ(paPositions, pcCode)
				return This.HarvestFromPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromPositions(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromItemsAt(panPos, pcCode)
			return This.HarvestFrom(panPos, pcCode)

			def HarvestFromItemsAtQ(paPositions, pcCode)
				return This.HarvestFromItemsAtQR(paPositions, pcCode, :stzList)
		
			def HarvestFromItemsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromItemsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromItemsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromItemsAt(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromItemsAtPositions(panPos, pcCode)
			return This.HarvestOn(panPos, pcCode)

			def HarvestFromItemsAtPositionsQ(paPositions, pcCode)
				return This.HarvestFromItemsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromItemsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromItemsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromItemsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromItemsAtPositions(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off
		#>

		#< @FunctionMisspelledForm

		def YiledFrom(paPostions, pcCode)
			return This.YieldFrom(paPositons, pcCode)

		#>

	  #---------------------------------------------------------#
	 #  YIELDING INFORMATION FROM GIVEN POSITIONS -- EXTENDED  #
	#---------------------------------------------------------#

	/* NOTE

	This function is less performan then it's simplest form YieldFrom(),
	because it takes time to analyze the conditional code provided, spacify it,
	transile it for :stzList, so a keyword like @PrecedentItem for example, can
	be used, and the function will transpile it to "This[@i-1]" automatically.

	If performance is critical, don't use it.

	*/

	def YieldFromXT(panPos, pcCode)
		if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
			StzRaise("Incorrect param! paPositions must be a list of numbers.")
		ok

		if len(panPos) = 0
			return []
		ok

		panPos = ring_sort(panPos)
		nLenPositions = len(panPos)

		if NOT isString(pcCode)
			StzRaise("Invalid param type! Condition must be a string.")
		ok

		if StzStringQ(pcCode).WithoutSpaces() = 0
			aTemp = []
			
			for i = 1 to nLenPositions
				aTemp + NULL
			next

			return aTemp
		ok

		pcCode = StzCCodeQ(pcCode).Transpiled()

		cCode = "aResult + ( " + pcCode + " )"
		oCode = StzStringQ(cCode)
		
		aResult = []
		nLenList = This.NumberOfItems()

		for i = 1 to nLenPositions
			@i = panPos[i]
			@item = @aContent[@i]

			bEval = TRUE

			oCodeWS = Q( oCode.WithoutSpaces() )
			bContainsIPlus1  = oCodeWS.ContainsCS( "This[@i+1]", :CS=FALSE )
			bContainsIMinus1 = oCodeWS.ContainsCS( "This[@i-1]", :CS=FALSE )

			if @i = nLenList and bContainsIPlus1
				bEval = FALSE

			but @i = 1 and bContainsIMinus1
				bEval = FALSE
			
			ok

			if bEval

				eval(cCode) # Populates aResult with the yielded information

			ok

		next

		return aResult

		#< @FunctionFluentForm

		def YieldFromXTQ(paPositions, pcCode)
			return This.YieldFromXTQR(paPositions, pcCode, :stzList)
	
		def YieldFromXTQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromXT(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFromXT(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFromXT(paPositions, pcCode) )
		
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def YieldFromPositionsXT(panPos, pcCode)
			return This.YieldFromXT(panPos, pcCode)

			def YieldFromPositionsXTQ(paPositions, pcCode)
				return This.YieldFromPositionsXTQR(paPositions, pcCode, :stzList)
		
			def YieldFromPositionsXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromPositionsXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromPositionsXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromPositionsXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def YieldFromItemsAtXT(panPos, pcCode)
			return This.YieldFromXT(panPos, pcCode)

			def YieldFromItemsAtXTQ(paPositions, pcCode)
				return This.YieldFromItemsAtXTQR(paPositions, pcCode, :stzList)
		
			def YieldFromItemsAtXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromItemsAtXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromItemsAtXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromItemsAtXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def YieldFromItemsAtPositionsXT(panPos, pcCode)
			return This.YieldOnXT(panPos, pcCode)

			def YieldFromItemsAtPositionsXTQ(paPositions, pcCode)
				return This.YieldFromItemsAtPositionsXTQR(paPositions, pcCode, :stzList)
		
			def YieldFromItemsAtPositionsXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromItemsAtPositionsXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromItemsAtPositionsXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromItemsAtPositionsXT(paPositions, pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromItemsAtPositionsXT(paPositions, pcCode) )
			
			other
					StzRaise("Unsupported return type!")
			off

		def HarvestFromXT(panPos, pcCode)
			return This.HarvestFromXT(panPos, pcCode)

			def HarvestFromXTQ(paPositions, pcCode)
				return This.HarvestFromXTQR(paPositions, pcCode, :stzList)
		
			def HarvestFromXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromPositionsXT(panPos, pcCode)
			return This.HarvestFromXT(panPos, pcCode)

			def HarvestFromPositionsXTQ(paPositions, pcCode)
				return This.HarvestFromPositionsXTQR(paPositions, pcCode, :stzList)
		
			def HarvestFromPositionsXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromPositionsXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromPositionsXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromPositionsXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromItemsAtXT(panPos, pcCode)
			return This.HarvestFromXT(panPos, pcCode)

			def HarvestFromItemsAtXTQ(paPositions, pcCode)
				return This.HarvestFromItemsAtXTQR(paPositions, pcCode, :stzList)
		
			def HarvestFromItemsAtXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromItemsAtXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromItemsAtXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromItemsAtXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		def HarvestFromItemsAtPositionsXT(panPos, pcCode)
			return This.HarvestOnXT(panPos, pcCode)

			def HarvestFromItemsAtPositionsXTQ(paPositions, pcCode)
				return This.HarvestFromItemsAtPositionsXTQR(paPositions, pcCode, :stzList)
		
			def HarvestFromItemsAtPositionsXTQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromItemsAtPositionsXT(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromItemsAtPositionsXT(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromItemsAtPositionsXT(paPositions, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off
		#>

		#< @FunctionMisspelledForm

		def YiledFromXT(paPostions, pcCode)
			return This.YieldFromXT(paPositons, pcCode)

		#>

	  #======================================================#
	 #   YIELDING INFORMATION ON ITEMS IN GIVEN SECTIONS    #
	#======================================================#

	def YieldFromSections(paSections, pcCode)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		# Getting all the positions from the provided sections
		# Example: [ [2,5], [7,9 ] ] --> [ 2, 3, 4, 5, 7, 8, 9 ]

		anSectionsExpanded = StzListQ(paSections).PerformQ('{
			@item = Q(@item).ExpandedIfPairOfNumbers()
		}').Content()
	
		anPos = ListsMergeQ( anSectionsExpanded ).DuplicatesRemoved()

		return This.YieldFrom(anPos, pcCode)

		#< @FunctionFluentForm

		def YieldFromSectionsQ(paSections, pcCode)
			return This.YieldFromSectionsQR(paPositions, pcCode, :stzList)
	
		def YieldFromSectionsQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSections(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFromSections(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFromSections(paPositions, pcCode) )
		
			other
				StzRaise("Unsupported return type!")
			off			

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsQ(paSections, pcCode)
				return This.HarvestFromSectionsQR(paSections, pcCode, :stzList)

			def HarvestFromSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSections(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
	
		def YieldSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def YieldSectionsQ(paSections, pcCode)
				return This.YieldSectionsQR(paSections, pcCode, :stzList)

			def YieldSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSections(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		def HarvestSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsQ(paSections, pcCode)
				return This.HarvestSectionsQR(paSections, pcCode, :stzList)

			def HarvestSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSections(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
		#>

	def YieldFromSectionsOneByOne(paSections, pcCode)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		anSectionsExpanded = []
		for aSection in paSections
			anSectionsExpanded + Q(aSection).ExpandedIfPairOfNumbers()
		next

		for anPos in anSectionsExpanded
			aResult + This.YieldFromPositions(anPos, pcCode)
		next

		return aResult

		#< @FunctionFluentForm

		def YieldFromSectionsOneByOneQ(paSections, pcCode)
			return This.YieldFromSectionsOneByOneQR(paSections, pcCode, :stzList)

		def YieldFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestFromSectionsOneByOneQR(paSections, pcCode, :stzList)

			def HarvestFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSectionsOneByOne(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
				
		def HarvestSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestSectionsOneByOneQR(paSections, pcCode, :stzList)

			def HarvestSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSectionsOneByOne(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		def YieldSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def YieldSectionsOneByOneQ(paSections, pcCode)
				return This.YieldSectionsOneByOneQR(paSections, pcCode, :stzList)

			def YieldSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSectionsOneByOne(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

	  #================================================================#
	 #   YIELDING INFORMATION ON ITEMS IN GIVEN SECTIONS -- EXTENDED  #
	#================================================================#

	def YieldFromSectionsXT(paSections, pcCode)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		# Getting all the positions from the provided sections
		# Example: [ [2,5], [7,9 ] ] --> [ 2, 3, 4, 5, 7, 8, 9 ]

		anSectionsExpanded = StzListQ(paSections).PerformQ('{
			@item = Q(@item).ExpandedIfPairOfNumbers()
		}').Content()
	
		anPos = ListsMergeQ( anSectionsExpanded ).DuplicatesRemoved()

		return This.YieldFromXT(anPos, pcCode)

		#< @FunctionFluentForm

		def YieldFromSectionsXTQ(paSections, pcCode)
			return This.YieldFromSectionsXTQR(paPositions, pcCode, :stzList)
	
		def YieldFromSectionsXTQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSectionsXT(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFromSectionsXT(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFromSectionsXT(paPositions, pcCode) )
		
			other
				StzRaise("Unsupported return type!")
			off			

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSectionsXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def HarvestFromSectionsXTQ(paSections, pcCode)
				return This.HarvestFromSectionsXTQR(paSections, pcCode, :stzList)

			def HarvestFromSectionsXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSectionsXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSectionsXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
	
		def YieldSectionsXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def YieldSectionsXTQ(paSections, pcCode)
				return This.YieldSectionsXTQR(paSections, pcCode, :stzList)

			def YieldSectionsXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSectionsXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSectionsXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		def HarvestSectionsXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def HarvestSectionsXTQ(paSections, pcCode)
				return This.HarvestSectionsXTQR(paSections, pcCode, :stzList)

			def HarvestSectionsXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSectionsXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSectionsXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
		#>

	def YieldFromSectionsOneByOneXT(paSections, pcCode)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		anSectionsExpanded = []
		for aSection in paSections
			anSectionsExpanded + Q(aSection).ExpandedIfPairOfNumbers()
		next

		for anPos in anSectionsExpanded
			aResult + This.YieldFromPositionsXT(anPos, pcCode)
		next

		return aResult

		#< @FunctionFluentForm

		def YieldFromSectionsOneByOneXTQ(paSections, pcCode)
			return This.YieldFromSectionsOneByOneXTQR(paSections, pcCode, :stzList)

		def YieldFromSectionsOneByOneXTQR(paSections, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSectionsOneByOneXTQ(paSections, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldFromSectionsOneByOneXTQ(paSections, pcCode) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSectionsOneByOneXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def HarvestFromSectionsOneByOneXTQ(paSections, pcCode)
				return This.HarvestFromSectionsOneByOneXTQR(paSections, pcCode, :stzList)

			def HarvestFromSectionsOneByOneXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSectionsOneByOneXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSectionsOneByOneXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off
				
		def HarvestSectionsOneByOneXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def HarvestSectionsOneByOneXTQ(paSections, pcCode)
				return This.HarvestSectionsOneByOneXTQR(paSections, pcCode, :stzList)

			def HarvestSectionsOneByOneXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSectionsOneByOneXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSectionsOneByOneXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		def YieldSectionsOneByOneXT(paSections, pcCode)
			return This.YieldFromSectionsXT(paSections, pcCode)

			def YieldSectionsOneByOneXTQ(paSections, pcCode)
				return This.YieldSectionsOneByOneXTQR(paSections, pcCode, :stzList)

			def YieldSectionsOneByOneXTQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSectionsOneByOneXT(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSectionsOneByOneXT(paSections, pcCode) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

	  #================================================================#
	 #   YIELDING INFORMATION ON ITEMS VERIFYiNG A GIVEN CONDITION    #
	#================================================================#

	def YieldW(pcCode, pcCondition)
		/*
		o1 = new stzList([ 1, 2, 3, 4, 5, 6, 7 ])
		? o1.YieldW('@NextItem', :if = 'StzNumberQ(@item).IsMultipleOf(2)')
		*/
		if NOT isString(pcCode)
			StzRaise("Incorrect param! pcCode must be a string.")
		ok

		if isList(pcCondition) and Q(pcCondition).IsWhereOrIfNamedParam()
			pcCondition = pccondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param! pcCondition must be astring.")
		ok

		anPos = This.FindW(pcCondition)
		aResult = This.YieldFrom(anPos, pcCode)

		return aResult

		#< @FunctionFluentForm

		def YieldWQ(pcCode, pcCondition)
				return This.YieldWQR(paPositions, pcCode, :stzList)
		
			def YieldWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldW(pcCode, pcCondition) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldW(pcCode, pcCondition) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldW(pcCode, pcCondition) )
	
				on :stzHashList
					return new stzHashList( This.YieldW(pcCode, pcCondition) )
			
			other
					StzRaise("Unsupported return type!")
			off

		#>

		#> @FunctionAlternativeForm

		def HarvestW(pcCode, pcCondition)
			return This.YieldW(pcCode, pcCondition)

			def HervestWQ(pcCode, pcCondition)
				return This.HarvestWQR(pcCode, pcCondition, :stzList)

			def HervestWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				if NOT isString(pcReturnType)
					StzRaise("IncorrectType! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestW(pcCode, pcCondition) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestW(pcCode, pcCondition) )

				other
					StzRaise("Unsupported return type!")
				off
		#>

		#< @FunctionMisspelledForm

		def YiledW(pcCode, pcCondition)
			return This.YieldW(pcCode, pcCondition)

		#>

	  #---------------------------------------------------------------------------#
	 #   YIELDING INFORMATION ON ITEMS VERIFYiNG A GIVEN CONDITION -- EXTENDED   #
	#---------------------------------------------------------------------------#

	def YieldWXT(pcCode, pcCondition)

		if NOT isString(pcCode)
			StzRaise("Incorrect param! pcCode must be a string.")
		ok

		if isList(pcCondition) and Q(pcCondition).IsWhereOrIfNamedParam()
			pcCondition = pccondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param! pcCondition must be astring.")
		ok

		anPos = This.FindWXT(pcCondition)
		aResult = This.YieldFromXT(anPos, pcCode)

		return aResult

		#< @FunctionFluentForm

		def YieldWXTQ(pcCode, pcCondition)
				return This.YieldWXTQR(paPositions, pcCode, :stzList)
		
			def YieldWXTQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldWXT(pcCode, pcCondition) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldWXT(pcCode, pcCondition) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldWXT(pcCode, pcCondition) )
	
				on :stzHashList
					return new stzHashList( This.YieldWXT(pcCode, pcCondition) )
			
			other
					StzRaise("Unsupported return type!")
			off

		#>

		#> @FunctionAlternativeForm

		def HarvestWXT(pcCode, pcCondition)
			return This.YieldWXT(pcCode, pcCondition)

			def HervestWXTQ(pcCode, pcCondition)
				return This.HarvestWXTQR(pcCode, pcCondition, :stzList)

			def HervestWXTQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				if NOT isString(pcReturnType)
					StzRaise("IncorrectType! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestWXT(pcCode, pcCondition) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestWXT(pcCode, pcCondition) )

				other
					StzRaise("Unsupported return type!")
				off
		#>

	  #===============================================#
	 #  YIELDING AND CUMULATING VALUES ON EACH ITEM  #
	#===============================================#

	def YieldAndCumulate(pcCode, paReturnEachOrLast)
		/* EXAMPLE
			o1 = new stzList([ 1, 2, 3 ])
			? o1.YieldAndCumulate("@item", :ReturnEach)
			#--> [ 1, 3, 6 ]

			? o1.YieldAndCumulate("@item", :ReturnLast)
			#--> 6
		*/

		bReturnLast = FALSE

		if isList(paReturnEachOrLast)
			if len(paReturnEachOrLast) = 2 and
			   isString(paReturnEachOrLast[1]) and
			   paReturnEachOrLast[1] = :ReturnLast and
			   isNumber(paReturnEachOrLast[2]) and
			   Q(paReturnEachOrLast[2]).IsEither(TRUE, :Or = FALSE)
				bReturnLast = paReturnEachOrLast[2]
			ok

		but isString(paReturnEachOrLast)
			if paReturnEachOrLast = :ReturnLast
				bReturnLast = TRUE
			ok	
		ok

		if NOT (This.IsListOfNumbers() or This.IsListOfStrings())
			StzRaise("Can't cumulate! The list must b a list of numbers or a list of strings.")
		ok

		if NOT isString(pcCode)
			StzRaise("Incorrect param type! pcCode must be a string.")
		ok

		aYielded = This.Yield(pcCode)
		nLenYielded = len(aYielded)

		if nLenYielded > 0
			aCumulated = [ aYielded[1] ]

			if nLenYielded > 1
				for i = 2 to nLenYielded
					aCumulated + ( aCumulated[i-1] + aYielded[i] )
				next
			ok
		ok

		nLenCumulated = len(aCumulated)

		if bReturnLast
			return aCumulated[ nLenCumulated ]
		else
			return aCumulated
		ok

		#< @FunctionFluentForm

		def YieldAndCumulateQ(pcCode, paReturnEachOrLast)
			return Q(This.YieldAndCumulate(pcCode, paReturnEachOrLast))

		#>

		#< @FunctionAlternativeForm

		def HarvestAndCumulate(pcCode, paReturnEachOrLast)
			return This.YieldAndCumulate(pcCode, paReturnEachOrLast)

			def HarvestAndCumulateQ(pcCode, paReturnEachOrLast)
				This.YieldAndCumulateQ(pcCode, paReturnEachOrLast)

		#>

	  #-----------------------------------------------------------#
	 #  YIELDING AND CUMULATING VALUES ON EACH ITEM -- EXTENDED  #
	#-----------------------------------------------------------#

	def YieldAndCumulateXT(pcCode, paReturnEachOrLast)

		bReturnLast = FALSE

		if isList(paReturnEachOrLast)
			if len(paReturnEachOrLast) = 2 and
			   isString(paReturnEachOrLast[1]) and
			   paReturnEachOrLast[1] = :ReturnLast and
			   isNumber(paReturnEachOrLast[2]) and
			   Q(paReturnEachOrLast[2]).IsEither(TRUE, :Or = FALSE)
				bReturnLast = paReturnEachOrLast[2]
			ok

		but isString(paReturnEachOrLast)
			if paReturnEachOrLast = :ReturnLast
				bReturnLast = TRUE
			ok	
		ok

		if NOT ( This.IsListOfNumbers() or This.IsListOfStrings() )
			StzRaise("Can't cumulate! The list must b a list of numbers or a list of strings.")
		ok

		if NOT isString(pcCode)
			StzRaise("Incorrect param type! pcCode must be a string.")
		ok

		aYielded = This.YieldXT(pcCode)
		nLenYielded = len(aYielded)

		if nLenYielded > 0
			aCumulated = [ aYielded[1] ]

			if nLenYielded > 1
				for i = 2 to nLenYielded
					aCumulated + ( aCumulated[i-1] + aYielded[i] )
				next
			ok
		ok

		nLenCumulated = len(aCumulated)

		if bReturnLast
			return aCumulated[ nLenCumulated ]
		else
			return aCumulated
		ok

		#< @FunctionFluentForm

		def YieldAndCumulateXTQ(pcCode, paReturnEachOrLast)
			return Q(This.YieldAndCumulateXT(pcCode, paReturnEachOrLast))

		#>

		#< @FunctionAlternativeForm

		def HarvestAndCumulateXT(pcCode, paReturnEachOrLast)
			return This.YieldAndCumulateXT(pcCode, paReturnEachOrLast)

			def HarvestAndCumulateXTQ(pcCode, paReturnEachOrLast)
				This.YieldAndCumulateXTQ(pcCode, paReturnEachOrLast)

		#>

	  #--------------------------------------------------------#
	 #  APPLYING A REDUCE OPERATION ON THE ITEMS OF THE LIST  #
	#--------------------------------------------------------#

	def Reduce(pcCode)
		return This.YieldAndCumulate(pcCode, :ReturnLast)

		def ReduceQ(pcCode, paReturnEachOrLast)
			return This.Reduce(pcCode, paReturnEachOrLast)

	  #--------------------------------------------------------------------#
	 #  APPLYING A REDUCE OPERATION ON THE ITEMS OF THE LIST -- EXTENDED  #
	#--------------------------------------------------------------------#

	def ReduceXT(pcCode)
		return This.YieldAndCumulateXT(pcCode, :ReturnLast)

		def ReduceXTQ(pcCode, paReturnEachOrLast)
			return This.ReduceXT(pcCode, paReturnEachOrLast)

	  #=======================================#
	 #   PERFORMING AN ACTION ON EACH ITEM   #
	#=======================================#

	def Perform(pcAction)
		# Must begin with '@item ='

		/* Example

		aWhatIs = [ :Ring = "programming language", :Softanza = "Ring library", :Qt = "C++ framework" ]
		
		o1 = new stzList([ "Ring", "Softanza", "Qt" ])
		o1.Perform('{ @item += " is a " + aWhatIs[@item] }')
		
		? o1.Content()
		#--> [ "Ring is a programming language", "Softanza is a Ring library", "Qt is a C++ framework" ]

		*/

		if isList(pcAction) and Q(pcAction).IsDoNamedParam()
			pcAction = pcAction[2]
		ok

		This.PerformOnThesePositions(1:This.NumberOfItems(), pcAction)

		#< @FunctionfluentForm

		def PerformQ(pcAction)
			This.Perform(pcAction)
			return This

		def PerformQR(pcAction, pcReturnType)
			if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return This

			on :stzListOfStrings
				return new stzListOfStrings( This.Perform(pcAction) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Perform(pcAction) )

			on :stzListOfLists
				return new stzListOfLists( This.Perform(pcAction) )

			on :stzListOfPairs
				return new stzListOfPairs( This.Perform(pcAction) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def Doo(pcAction) # We can't use do() because it is reserved keyword by Ring
			This.Perform(pcAction)

			def DooQ(pcAction)
				return This.PerformQ(pcAction)

			def DooQR(pcAction, pcReturnType)
				return This.PerformQR(pcAction, pcReturnType)

			def DoQ(pcAction)
				return This.PerformQ(pcAction)

			def DoQR(pcAction, pcReturnType)
				return This.PerformQR(pcAction, pcReturnType)

		def Do_(pcAction) # We can't use do() because it is reserved keyword by Ring
			This.Perform(pcAction)

			def Do_Q(pcAction)
				return This.PerformQ(pcAction)

			def Do_QR(pcAction, pcReturnType)
				return This.PerformQR(pcAction, pcReturnType)

		#>

	  #---------------------------------------------------#
	 #   PERFORMIN ACTIONS ON CHARS IN GIVEN POSITIONS   #
	#---------------------------------------------------#

	def PerformOn(panPos, pcCode)
		#< @MotherFunction > ReplaceAt() | @RingBased #>

		if NOT ( isList(panPos) and (Q(panPos).IsListOfNumbers() or len(panPos) = 0) )
			StzRaise("Invalid param type! panPos must be a list of numbers.")
		ok

		if len(panPos) = 0
			return
		ok

		if NOT isString(pcCode)
			StzRaise("Invalid param type! pcCode must be a string.")
		ok

		oCode = new stzString( StzCCodeQ(pcCode).Transpiled() )
		
		if oCode.WithoutSpaces() = ''
			return
		ok

		if NOT oCode.BeginsWithOneOfTheseCS(
			[ "@item =", "@item=",
			  "@item +=", "@item+=",
			  "@item -=", "@item-=",
			  "@item *=", "@item*=",
			  "@item /=", "@item/="
			],

			:CaseSensitive = FALSE )

			StzRaise("Syntax error! pcCode must begin with '@item ='.")
		ok

		cCode = oCode.Content()
		oCode = StzStringQ(cCode)

		nLen = This.NumberOfItems()

		@i = 0
		
		for @i in panPos

			bEval = TRUE

			if @i = nLen and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i+1]", :CS=FALSE )

				bEval = FALSE

			but @i = 1 and
			    oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i-1]", :CS=FALSE )

				bEval = FALSE
			
			ok

			if bEval
				@item = @aContent[@i]
				eval(cCode)
				This.ReplaceAt(@i, @item)
			ok

		next

		#--

		def PerformOnQ(panPos, pcCode)
			This.PerformOn(panPos, pcCode)
			return This

		def PerformOnQR(panPos, pcCode)
			if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return This

			on :stzListOfStrings
				return new stzListOfStrings( This.PerformOn(panPos, pcCode) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.PerformOn(panPos, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.PerformOn(panPos, pcCode) )

			on :stzListOfPairs
				return new stzListOfPairs( This.PerformOn(panPos, pcCode) )

			other
				StzRaise("Unsupported return type!")
			off

		#--

		def PerformOnPositions(panPos, pcCode)
			This.PerformOn(panPos, pcCode)

			def PerformOnPositionsQ(panPos, pcCode)
				This.PerformOnPositions(panPos, pcCode)
				return This
	
			def PerformOnPositionsQR(panPos, pcCode, pcReturnType)
				if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok
	
				switch pcReturnType
				on :stzList
					return This
	
				on :stzListOfStrings
					return new stzListOfStrings( This.PerformOnPositions(panPos, pcCode) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.PerformOnPositions(panPos, pcCode) )
	
				on :stzListOfLists
					return new stzListOfLists( This.PerformOnPositions(panPos, pcCode) )
	
				on :stzListOfPairs
					return new stzListOfPairs(This.PerformOnPositions(panPos, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off

		#--

		def PerformOnThesePositions(panPos, pcCode)
			This.PerformOn(panPos, pcCode)

			def PerformOnThesePositionsQ(panPos, pcCode)
				This.PerformOnThesePositions(panPos, pcCode)
				return This

			def PerformOnThesePositionsQR(panPos, pcCode, pcReturnType)
				if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok
	
				switch pcReturnType
				on :stzList
					return This
	
				on :stzListOfStrings
					return new stzListOfStrings( This.PerformOnThesePositions(panPos, pcCode) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.PerformOnThesePositions(panPos, pcCode) )
	
				on :stzListOfLists
					return new stzListOfLists( This.PerformOnThesePositions(panPos, pcCode) )
	
				on :stzListOfPairs
					return new stzListOfPairs( This.PerformOnThesePositions(panPos, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
	
				off

	  #------------------------------------------------------#
	 #   PERFORMING AN ACTION ON ITEMS AT GIVEN SECTIONS    #
	#------------------------------------------------------#

	def PerformOnSections(paSections, pcCode)

		# Checking correctness of paSections param

		If NOT isString(pcCode)
			StzRaise("Incorrect param! pcCode must be a string.")
		ok

		if NOT ( isList(paSections) and

			 Q(paSections).EachItemVerifyW(
				:That = 'isList(@item) and Q(@item).IsPairOfNumbers()' ) )

			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		# Getting all the positions from the provided sections
		# Example: [ [2,5], [7,9 ] ] --> [ 2, 3, 4, 5, 7, 8, 9 ]

		anSectionsExpanded = StzListQ(paSections).PerformQ('{
			@item = Q(@item).ExpandedIfPairOfNumbers()
		}').Content()
	
		anPos = ListsMergeQ( anSectionsExpanded ).DuplicatesRemoved()

		This.PerformOn(anPos, pcCode)

		#--

		def PerformOnSectionsQ(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)
			return This

		def PerformOnSectionsQR(paSections, pcCode, pcReturnType)
			if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return This

			on :stzListOfStrings
				return new stzListOfStrings( This.PerformOnSections(paSections, pcCode) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.PerformOnSections(paSections, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.PerformOnSections(paSections, pcCode) )

			on :stzListOfPairs
				return new stzListOfPairs( This.PerformOnSections(paSections, pcCode) )

			other
				StzRaise("Unsupported return type!")
			off

		#--

		def PerformOnTheseSections(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)

			def PerformOnTheseSectionsQ(paSections, pcCode)
				This.PerformOnTheseSections(paSections, pcCode)
				return This

			def PerformOnTheseSectionsQR(paSections, pcCode, pcReturnType)
				if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					StzRaise("Incorrect param! pcReturnType must be a string.")
				ok
	
				switch pcReturnType
				on :stzList
					return This
	
				on :stzListOfStrings
					return new stzListOfStrings( This.PerformOnTheseSections(paSections, pcCode) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.PerformOnTheseSections(paSections, pcCode) )
	
				on :stzListOfLists
					return new stzListOfLists( This.PerformOnTheseSections(paSections, pcCode) )
	
				on :stzListOfPairs
					return new stzListOfPairs( This.PerformOnTheseSections(paSections, pcCode) )
	
				other
					StzRaise("Unsupported return type!")
				off
	
	  #---------------------------------------------------------------#
	 #   PERFORMING AN ACTION ON ITEMS VERIFYING A GIVEN CONDITION   #
	#---------------------------------------------------------------#

	def PerformW(pcAction, pcCondition)
		
		if isList(pcAction) and Q(pcAction).IsDoNamedParam()
			pcAction = pcAction[2]
		ok

		if NOT isString(pcAction)
			StzRaise("Incorrect type! pcAction must be a string.")
		ok
		
		if isList(pcCondition) and Q(pcCondition).IsIfOrWhereNamedParam()

			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect type! pcCondition must be a string.")
		ok

		# No need to purify the pcCondition code here,
		# FindItemsW() will do it

		anPos = This.FindItemsW(pcCondition)

		# Do not purify pcAction code here,
		# PerformOn() will do it

		This.PerformOn(anPos, pcAction)

		#< @FunctionFluentForm

		def PerformWQ(pcAction, pcCondition)
			This.PerformW(pcAction, pcCondition)
			return This

		def PerformWQR(pcAction, pcCondition, pcReturnType)
			if IsList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return This

			on :stzListOfStrings
				return new stzListOfStrings( This.PerformW(pcAction, pcCondition) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.PerformW(pcAction, pcCondition) )

			on :stzListOfLists
				return new stzListOfLists( This.PerformW(pcAction, pcCondition) )

			on :stzListOfPairs
				return new stzListOfPairs( This.PerformW(pcAction, pcCondition) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def DoW( pcAction, pcCondition )
			This.PerformW( pcAction, pcCondition )

			def DoWQ( pcAction, pcCondition )
				return This.PerformWQ( pcAction, pcCondition )

			def DoWQR( pcAction, pcCondition, pcReturnType )
				return This.PerformWQR( pcAction, pcCondition, pcReturnType )
		#>

	  #==================================================#
	 #  CHECKING IF THE LIST IS EQUAL TO AN OTHER LIST  #
	#==================================================#

	def IsEqualToCS(paOtherList, pCaseSensitive)
		/*
		Two lists are equal when they have:
			1. same type
			2. same number of items AND
			3. same content
		*/

		# A check made to enable some external code
		# In Ring context use IsEqualToQ()

		if isObject(paOtherList)

			content = paOtherList.Content()

			if isList(content) and
		  	   len(content) = len(This.List()) and
		  	   This.HasSameContentAsCS(content, pCaseSensitive)

				return paOtherList
			else
				return FALSE
			ok
		ok

		if NOT isList(paOtherList)
			return FALSE
		ok

		# Doublechecking for potential performance gain

		if This.NumberOfItems() != len(paOtherList)
			return FALSE
		ok

		if isList(paOtherList) and
		   len(paOtherList) = len(This.List()) and
		   This.HasSameContentAsCS(paOtherList, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionFluentForm

		def IsEqualToCSQ(paOtherList)

			bResult = FALSE

			if isList(paOtherList)
				bResult = This.IsEqualToCS(paOtherList, pCaseSensitive)
				
			ok

			if bResult = TRUE
				return This
			else
				return new stzFalsObject
			ok

		#>

		#< @FunctionAlternativeForms

		def IsEqualCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsEqualToCS(paOtherList, pCaseSensitive)

		def IsNotEqualToCS(paOtherList, pCaseSensitive)
			return NOT This.IsEqualToCS(paOtherList, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtToCS(pcOtherList, pCaseSensitive)
			return This.IsEqualToCS(pcOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(paOtherList)
		return This.IsEqualToCS(paOtherList, TRUE)

		def IsEqualToQ(paOtherList)
			return This.IsEqualToCSQ(paOtherList, TRUE)

		#< @FunctionAlternativeForms

		def IsEqual(paOtherList)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsEqualTo(paOtherList)

			def IsEqualQ(paOtherList)
				return This.IsEqualToQ(paOtherList)

		#>

		#< @FunctionPassiveForm

		def IsNotEqualTo(paOtherList)
			return NOT This.IsEqualTo(paOtherList)

		#>

		#< @FunctionMisspelledForm

		def IsEqualtTo(pcOtherList)
			return This.IsEqualTo(pcOtherList)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST IS STRICTLY EQUAL TO AN OTHER LIST  #
	#-----------------------------------------------------------#

	def IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		/*
		Tow lists are striclty equal when:
			1. they are equal (in the sense of IsEqualTo() method)
			2. they have same order of items (ItemsHaveSameOrder())
		*/
		
		if This.IsEqualToCS(paOtherList, pCaseSensitive) and
		   This.ItemsHaveSameOrderAs(paOtherList)
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsStrictlyEqualCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		def IsIdenticalToCS(paOtherList, pCaseSensitive)
			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		def IsIdenticalCS(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualToCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(paOtherList)
		return This.IsStrictlyEqualToCS(paOtherList, TRUE)

		#< @FunctionAlternativeForms

		def IsStrictlyEqual(paOtherList, pCaseSensitive)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualTo(paOtherList)

		def IsIdenticalTo(paOtherList)
			return This.IsStrictlyEqualTo(paOtherList)

		def IsIdentical(paOtherList)
			if isList(paOtherList) and Q(paOtherList).IsToNamedParam()
				pOtherList = pOtherList[2]
			ok

			return This.IsStrictlyEqualTo(paOtherList)

		#>

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST IS QUEIT EQUAL TO AN OTHER LIST  #
	#--------------------------------------------------------#

	def IsQuietEqualTo(paOtherList)

		if This.IsEqualTo(paOtherList)
			return TRUE
		ok

		nDif = abs(This.NumberOfItems() - StzListQ(paOtherList).NumberOfItems())
		n = nDif / This.NumberOfItems()
		
		if n < QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return TRUE
		ok

		return FALSE

		def IsQuietEqual(paOtherList)
			return This.IsQuietEqualTo(paOtherList)

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS NEITHER EQUAL TO A GIVEN LIST NOR TO AN OTHER  #
	#-------------------------------------------------------------------------#

	def IsNeitherCS(paList1, paList2, pCaseSensitive)
		if CheckParams()
			if isList(paList1) and Q(paList1).IsEqualToNamedParam()
				paList1 = paList1[2]
			ok

			if isList(palist2) and Q(paList2).IsNorNamedParam()
				paList2 = paList2[2]
			ok

			if @BothAreStrings(paList1, paList2)
				return This.@IsNeither(paList1, paList2)
			ok

			if NOT @BothAreLists(paList1, paList2)
				StzRaise("Incorrect param type! paList1 and paList2 must both be lists.")
			ok
		ok

		bEqualToList1 = This.IsEqualToCS(paList1, pCaseSensitive)
		bEqualToList2 = This.IsEqualToCS(paList2, pCaseSensitive)

		if NOT bEqualToList1 and NOT bEqualToList2
			return TRUE
		else
			return FALSE
		ok

		def IsNeitherEqualToCS(paList1, paList2, pCaseSensitive)
			return This.IsNeitherCS(paList1, paList2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVITY

	def IsNeither(paList1, paList2)
		return This.IsNeitherCS(paList1, paList2, TRUE)

		def IsNeitherEqualTo(paList1, paList2)
			return This.IsNeither(paList1, paList2)

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS SAME ORDER AS AN OTHER LIST  #
	#--------------------------------------------------------#

	def ItemsHaveSameOrderAs(paOtherList)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		aContent = This.Content()
		nLenList = This.NumberOfItems()
		nLenOtherList = len(paOtherList)
		nMin = StzListOfNumbersQ([nLenList, nLenOtherList]).Min()

		bResult = TRUE

		for i = 1 to nMin
			if Q(aContent[i]).IsNotEqualTo(paOtherList[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult
	
		def ItemsHaveSameOrder(paOtherList)
			return This.ItemsHaveSameOrderAs(paOtherList)

	  #==========================================================#
	 #  CHECKING IF ALL THE ITEMS ARE EIGTHER NUMBERS OR ITEMS  #
	#==========================================================#

	def AllItemsAreNumbersOrStrings()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = TRUE
		for i = 1 to nLen
			if NOT (isNumber(aContent[i]) or isString(aContent[i]))
				bResult = FALSE
				exit
			ok
		next
		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AllItemsAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def ItemsAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def IsMadeOfNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def IsMadeOfStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		#--

		def AreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def AreAllNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AreAllStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		def AllAreNumbersOrStrings()
			return This.AllItemsAreNumbersOrStrings()

		def AllAreStringsOrNumbers()
			return This.AllItemsAreNumbersOrStrings()

		#>

	  #---------------------------------------------------------#
	 #  CHECKING IF THE LIST IS MADE OF A NUMBER AND A STRING  #
	#---------------------------------------------------------#

	def IsMadeOfANumberAndAString()
		acContent = This.Content()
		nLen = len(aContent)

		if nLen != 2
			return FALSE
		ok

		if ( isNumber(acContent[1]) and isString(acContent[2]) ) OR
		   ( isString(acContent[1]) and isNumber(acContent[2]) )

			return TRUE

		else

			return FALSE
		ok


		def IsMadeOfAStringAndANumber()
			return This.IsMadeOfANumberAndAString()

	  #----------------------------------------------------------#
	 #  CHECKING IF ALL THE ITEMS ARE EIGTHER NUMBERS OR ITEMS  #
	#==========================================================#

	def AllItemsAreNumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)

		bGotANumber = FALSE
		bGotAString = FALSE

		for i = 1 to nLen
			if isNumber(aContent[i])
				bGotANumber = TRUE
			but isString(aContent[i])
				bGotAString = TRUE
			ok

			if isNumber(aContent[i]) and bGotANumber
				i++

			but isString(aContent[i]) and bGotAString
				i++
			ok

		next

		bResult = bGotANumber AND bGotAString

		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreNumbersAndStrings()
			return This.AllItemsAreNumbersAndStrings()

		def AllItemsAndStringsOrNumbers()
			return This.AllItemsAndNumbersAndStrings()

		def ItemsAndStringsOrNumbers()
			return This.AllItemsAndNumbersAndStrings()

		def IsMadeOfNumbersAndStrings()
			return This.AllItemsAreNumbersAndStrings()

		def IsMadeOfStringsAndNumbers()
			return This.AllItemsAreNumbersAndStrings()

		#>

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 NUMBERS  #
	#===========================================#

	def BothAreNumbers()
		if This.NumberOfItems() = 2 and
		   isNumber(This.Item(1)) and isNumber(This.Item(2))

			return TRUE
		else
			return FALSE
		ok

		def ContainsTwoNumbers()
			return This.BothAreNumbers()

		def Contains2Numbers()
			return This.BothAreNumbers()

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 STRINGS  #
	#-------------------------------------------#

	def BothAreStrings()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and isString(This.Item(2))

			return TRUE
		else
			return FALSE
		ok

		def ContainsTwoStrings()
			return This.BothAreStrings()

		def Contains2Strings()
			return This.BothAreStrings()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 LISTS  #
	#-----------------------------------------#

	def BothAreLists()
		if This.NumberOfItems() = 2 and
		   isList(This.Item(1)) and isList(This.Item(2))

			return TRUE
		else
			return FALSE
		ok

		def ContainsTwoLists()
			return This.BothAreLists()

		def Contains2Lists()
			return This.BothAreLists()

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS 2 OBJECTS  #
	#-------------------------------------------#

	def BothAreObjects()
		if This.NumberOfItems() = 2 and
		   isObject(This.Item(1)) and isObject(This.Item(2))

			return TRUE
		else
			return FALSE
		ok

		def ContainsTwoObjects()
			return This.BothAreObjects()

		def Contains2Objects()
			return This.BothAreObjects()

	  #--------------------------------------------------------#
	 #  CHECKING IF THE LIST IS THE REVERSE OF AN OTHER LIST  #
	#--------------------------------------------------------#
	 #TODO: check performance

	def IsReverseOf(paOtherList)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		nLen = This.NumberOfItems()
		nLenOtherList = len(paOtherList)

		if nLen != nLenOtherList
			return FALSE
		ok

		aContent = This.Content()

		bResult = TRUE
		for i = 1 to nLen
			if Q(aContent[i]).IsDifferentFrom( paOtherList[ nLenOtherList - i + 1 ] )
				bResult = FALSE
				exit
			ok
		next i

		return bResult

		#< @FunctionAlternativeForms

		def IsReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsInverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)
		
		def IsInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAnInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsAnInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#==

		def IsTheReverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		def IsTheReversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsTheInverseOf(paOtherList)
			return This.IsReverseOf(paOtherList)
		
		def IsTheInversedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#--

		def IsTheInvertedCopyOf(paOtherList)
			return This.IsReverseOf(paOtherList)

		#>

	  #-------------------------------------#
	 #  REVERSING ITEMS ORDER IN THE LIST  #
	#-------------------------------------#

	def Reverse()

		aResult = ring_reverse( This.List() )
		This.Update( aResult )

		def ReverseQ()
			This.Reverse()
			return This

		#< @FunctionAlternativeForms

		def ReverseOrder()
			This.Reverse()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		def ReverseItems()
			This.Reverse()

			def ReverseItemsQ()
				This.ReverseItems()
				return This

		def ReverseItemsOrder()
			This.Reverse()

			def ReverseItemsOrderQ()
				This.ReverseItemsOrder()
				return This

		#>

	def Reversed()
		aResult = This.Copy().ReverseQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ItemsReversed()
			return This.Reversed()

		def ItemsOrderReversed()
			return This.Reversed()

		def OrderReversed()
			return This.Reversed()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS MORE ITEMS THAN AN OTHER LIST  #
	#----------------------------------------------------------#

	def HasMoreNumberOfItems(paOtherList)
		if isList(paOtherList) and Q(paOtherList).IsThenNamedParam()
			paOtherList = paOtherList[2]
		ok

		if This.NumberOfItems() > len(paOtherList)
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasMoreNumberOfItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def HasMoreItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def HasMoreItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		#--

		def ContainsMoreNumberOfItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreNumberOfItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreItems(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def ContainsMoreItemsThen(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		#--

		def IsLarger(paOtherList)
			return This.HasMoreNumberOfItems(paOtherList)

		def IsLargerThen(panOtherList)
			return This.HasMoreNumberOfItems(paOtherList)
	
		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS LESS ITEMS THAN AN OTHER LIST  #
	#----------------------------------------------------------#

	def HasLessNumberOfItems(paOtherList)
		if isList(paOtherList) and Q(paOtherList).IsThenNamedParam()
			paOtherList = paOtherList[2]
		ok

		if This.NumberOfItems() < len(paOtherList)
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasLessNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasLessItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasLessItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def ContainsLessNumberOfItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsLessItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def IsSmaller(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def IsSmallerThen(panOtherList)
			return This.HasLessNumberOfItems(paOtherList)
	
		#--

		def HasFewerNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasFewerItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def HasFewerItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#--

		def ContainsFewerNumberOfItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerNumberOfItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerItems(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		def ContainsFewerItemsThen(paOtherList)
			return This.HasLessNumberOfItems(paOtherList)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF A GIVEN VALUE IS ALSO A LIST  #
	#--------------------------------------------#

	def HasSameTypeAs(p)
		return isList(p)

		def HasSameType(p)
			return This.HasSameTypeAs(p)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF LIST HAS THE SAME CONTENT AS AN OTHER LIST OR ITEM  #
	#--------------------------------------------------------------------#

	def HasSameContentCS(paOtherList, pCaseSensitive)
		if isList(paOtherList) and Q(paOtherList).IsAsNamedParam()
			paOtherList = paOtherList[2]
		ok

		if NOT isList(paOtherList)
			StzRaise("Invalid param type! paOtherList should be a list.")
		ok

		# The two lists must have same number of items

		If  This.NumberOfItems() != len(paOtherList)
			return FALSE
		ok

		bResult = TRUE

		for item in paOtherList
			if NOT This.ContainsCS(item, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next
			
		return bResult
	
		def HasSameContentAsCS(paOtherList, pCaseSensitive)
			return This.HasSameContentCS(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasSameContent(paOtherList)
		return This.HasSameContentCS(paOtherList, TRUE)

		def HasSameContentAs(paOtherList)
			return This.HasSameContent(paOtherList)

	  #==================================================#
	 #  CHECKING IF ALL THE ITEMS ARE CONTIGUOUS LISTS  #
	#==================================================#

	def AllItemsAreContiguousLists()
		bResult = TRUE

		for item in This.List()
			if NOT ( isList(item) and StzListQ(item).IsContiguous() )
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def AllItemsAreContinuousLists()
			return This.AllItemsAreContiguousLists()

	  #=====================================#
	 #    CLASSIFYING (OR CATEGORIZING)    #
	#=====================================#
	
	def Classify()

		/* EXAMPLE

		aList = [
			:Arabic,
			:Arabic,
			:French,
			:English,
			:Spanish,
			:Spanish,
			:English,
			:Arabic
		]
		
		StzListQ(aList) {
		 	? ClassifyZ()
			#--> [
			# 	:Arabic  = [ 1, 2, 8 ],
			# 	:French  = [ 3 ],
			# 	:Enslish = [ 4, 7 ],
			#    	:Spanish = [ 5, 6 ]
			#    ]
		}
		*/

		acContent = This.StringifyNamedObjectsQ().Lowercased()

		nLen = len(acContent)
		anPosUndefined = []
		acSeen = []

		aResult = []

		for i = 1 to nLen
			
			if isString(acContent[i])

				if acContent[i] = :@NullObject or
				   acContent[i] = :@TrueObject or
				   acContent[i] = :@FalseObject

					anPosUndefined + i
					loop
				ok

				if ring_find(acSeen, acContent[i]) = 0
					aResult + [ acContent[i], [i] ]
					acSeen + acContent[i]

				else
					aResult[ acContent[i] ] + i
					
				ok
			else
				anPosUndefined + i
			ok
		next

		if len(anPosUndefined) > 0
			aResult + [ :@Undefined, anPosUndefined ]
		ok

		return aResult

		#< @FunctionFluentForms

		def ClassifyQ()
			return This.ClassifyQR(:stzList)

		def ClassifyQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Classify() )

			on :stzListOfHashList
				return new stzHashList( This.Classify() )

			other
				StzRaise("Unssupported return type!")

			off
		#>

		#< @FunctionAlternativeForm

		def classified()
			return this.classify()

		#>

	  #------------------------------------------#
	 #  CLASSIFYING THE LIST ON A GIVEN COLUMN  #
	#------------------------------------------#

	def ClassifyOn(pnColNumber)

	  #--------------------------------------------#
	 #   GETTING THE LIST OF CLASSES IN THE LIST  #
	#============================================#

	def Classes()

		aClasses = StzHashListQ( This.Classify() ).Keys()
		return aClasses


		#< @FunctionFluentForm

		def ClassesQ()
			return This.ClassesQR(:stzList)

		def ClassesQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Classes() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Classes() )

			other
				StzRaise("Unsupported return type!")
			off
		#>

	#--

	def NumberOfClasses()
		return len( This.Classes() )

		def NumberOfClassesQ()
			return new stzNumber( This.NumberOfClasses() )

		def CountClasses()
			return This.NumberOfClasses()

		def HowManyClasses()
			return This.NumberOfClasses()

		def HowManyClass()
			return This.NumberOfClasses()

	def Klass(pcClass)
		return This.Classify()[pcClass]

		def KlassQ(pcClass)
			return new stzString(This.Klass(pcClass))

	def NumberOfOccurrenceOfClass(pcClass)
		nResult = StzListQ( This.Classes() ).NumberOfOccurrence( pcClass )
		return nResult

		def CountClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def CountOccurrencesOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def HowManyOccurrencesOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)

		def HowManyOccurrenceOfClass(pcClass)
			return This.NumberOfOccurrenceOfClass(pcClass)


	def ClassFrequency(pcClass)
		nResult = This.NumberOfOccurrenceOfClass(pcClass) / This.NumberOfClasses()

		def ClassFreq(pcClass)

	def ClassesFrequencies()
		anResult = []
		for cClass in This.Classes()
			anResult + This.ClassFrequency(pcClass)
		next
		return anResult

		def ClassesFreq()
			return This.ClassesFrequencies()

	def ClassesAndTheirFrequencies()
		acClasses 	= This.Classes()
		anFrequencies 	= This.ClassesFrequencies()

		aResult = StzLisQ( acClasses ).AssociatedWith( anFrequencies )

		return aResult

		def ClassesAndTheirFreq()
			return This.ClassesAndTheirFrequencies()

		def ClassesXT()
			return This.ClassesAndTheirFrequencies()

	   #--------------------------------------------------------#
	  #   CLASSIFYING: SPECIEFIC CASE OF LISTS MADE OF LISTS   #
	 #   OF NUMBERS IN WHICH THE _:_ SYNTAX IS PREFERRED      #
	#--------------------------------------------------------#

	# @C prefix is used to say this function returns its result with
	# list of numbers in the _:_ Contiguous List syntax
	# provided by Ring. See example hereafter.

	def ClassifySF()	# Specific for lists of lists of numbers
				# Returs classes in the "_:_" syntax
				# @C for Continuous lists
	
		/* EXAMPLE
		o1 = new stzList([
			1:5, 3:9, 1:5, 10:15, 3:9, 12:20, 10:15, 1:5, 12:20
		])
		
		? o1.ClassifySF()	# Same as Categorize()
		#--> [
		#	[ "1:5",   [1, 3, 8 ] ],	
		#	[ "3:9",   [2, 5 ] ],
		#	[ "10:15", [4, 7 ] ],
		#	[ "12:20", [6, 9 ]
		#    ]

		*/

		acClasses@C = This.ClassesSF()

		aPositions = StzHashListQ( This.Classify() ).Values()

		aResult = StzListQ(acClasses@C).AssociatedWith(aPositions)

		return aResult

		#< @FunctionFluentForm

		def Classify@CQ()
			return This.Classify@CQR(:stzList)

		def Classify@CQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ClassifySF() )

			on :stzHashList
				return new stzHashList( This.ClassifySF() )

			other
				StzRaise("Unssupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def ClassifiedSF()
			return This.Classify@C()

		#>

	def ClassesSF()
		acClasses = This.Classes()

		for cClass in acClasses
			cClass = StzStringQ(cClass).ToListInShortForm()
		next

		return acClasses

		#< @FunctionFluentForm

		def Classes@CQ()
			return This.Classes@CQR(:stzList)

		def Classes@CQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ClassesSF() )

			on :stzListOfStrings
				return new stzListOfStrings( This.ClassesSF() )

			other
				StzRaise("Unsupported return type!")
			off
		#>

	def KlassSF(pcClass)
		aResult = []

		if isString(pcClass) and StzStringQ(pcClass).IsListInShortForm()
			cClass =Q(pcClass).WithoutSpaces()
			aResult = This.ClassifySF()[cClass]
		ok

		return aResult

		def Klass@CQ(pcClass)
			return new stzString( This.KlassSF(pcClass) )

	def NumberOfOccurrenceOfClassSF(pcClass)
		nResult = StzListQ( This.ClassesSF() ).NumberOfOccurrence( pcClass )
		return nResult

		def CountClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def CountOccurrencesOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyOccurrencesOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		def HowManyOccurrenceOfClassSF(pcClass)
			return This.NumberOfOccurrenceOfClassSF(pcClass)

		
	def ClassFrequencySF(pcClass)
		nResult = This.NumberOfOccurrenceOfClassSF(pcClass) / This.NumberOfClasses()
		return nResult

		def ClassFreqSF(pcClass)
			return This.ClassFrequencySF(pcClass)

	def ClassesFrequenciesSF()
		anResult = []
		for cClass in This.ClassesSF()
			anResult + This.ClassFrequencySF(pcClass)
		next
		return anResult

		def ClassesFreqSF()
			return This.ClassesFrequenciesSF()

	def ClassesAndTheirFrequenciesSF()
		acClasses 	= This.ClassesSF()
		anFrequencies 	= This.ClassesFrequencies()

		aResult = StzLisQ( acClasses ).AssociatedWith( anFrequencies )

		return aResult

		def ClassesAndTheirFreqSF()
			return This.ClassesAndTheirFrequenciesSF()

		def ClassesXTSF()
			return This.ClassesAndTheirFrequenciesSF()

	  #--------------------------------------------------------#
	 #   CLASSIFYING THE LIST ITEMS USING A GIVEN EXPRESSION  #
	#--------------------------------------------------------#

	def ClassifyByCS(pcExpr, pCaseSensitive)
		#EXAMPLE
		/*
		o1 = new stzList([ 3007, 2100, 170, 8, 10001, 2, 0, 150 ])
		? @@( o1.ClassifiedBy(' Q(@item).HowMany(0) ') )
		#--> [
		# 	[ "0", [ 8, 2 ] ],
		#	[ "1", [ 170, 0, 150 ] ],
		#	[ "2", [ 3007, 2100, 2100 ] ],
		#	[ "3", [ 10001 ] ]
		# ]
		*/

		#NOTE
		# Duplicates in the list are automatically removed and not
		# couted in the classification

		if CheckParams()
			if NOT isString(pcExpr)
				StzRaise("Incorrect param type! pcExpr must be a string.")
			ok
		ok

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		oExpr = new stzString(pcExpr)
		if NOT oExpr.ContainsOneOfTheseCS([ "@i", "@item" ], FALSE)
			StzRaise("Cant't proceed! The classifier must contain the keyword @i or @item or both.")
		ok

		cExpr = Q(pcExpr).TrimQ().RemoveTheseBoundsQ("{", "}").Trimmed()
		cCode = ' value = (' + cExpr + ')'

		aContentU = This.ContentU()
		nLen = len(aContentU)

		aResult = []
		oaSeen = new stzList([])

		for @i = 1 to nLen
			@item = aContentU[@i]
			eval(cCode)

			n = oaSeen.FindFirstCS(value, bCaseSensitive)
			if n = 0
				aResult + [ value, [ @item ] ]
				oaSeen.Add(value)

			else
				aResult[n][2] + @item
			ok

		next

		return aResult

		#< @FunctionFluentForms

		def ClassifyByCSQ(pcExpr, pCaseSensitive)
			return This.ClassifyByCSQR(pcExpr, pCaseSensitive, :stzList)

		def ClassifyByCSQR(pcExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ClassifyByCS(pcExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.ClassifyByCS(pcExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ClassifiedByCS(pcExpr, pCaseSensitive)
			return This.ClassifyByCS(pcExpr, pCaseSensitive)

		def ClassifiedUsingCS(pcExpr, pCaseSensitive)
			return This.ClassifyByCS(pcExpr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ClassifyBy(pcExpr)
		return This.ClassifyByCS(pcExpr, TRUE)

		#< @FunctionFluentForms

		def ClassifyByQ(pcExpr)
			return This.ClassifyByCSQ(pcExpr, TRUE)

		def ClassifyByQR(pcExpr, pcReturnType)
			return This.ClassifyByCSQR(pcExpr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def ClassifiedBy(pcExpr)
			return This.ClassifyBy(pcExpr)

		def ClassifiedUsing(pcExpr)
			return This.ClassifyBy(pcExpr)

		#>


	  #==================================#
	 #  GETTING THE PARTS OF THE LIST   #
	#==================================#

	def PartsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
			else
				aResult + aPart
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + aPart

		return aResult

		#< @FunctionFluentForms

		def PartsCSQ(pCaseSensitive)
			return This.PartsCSQR(pCaseSensitive, :stzList)

		def PartsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfLists( This.PartsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsCS(pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionCS(pCaseSensitive) # A verb: to partition
			return This.PartsCS(pCaseSensitive)

			def PartitionCSQ(pCaseSensitive)
				return This.PartitionCSQR(pCaseSensitive, :stzList)

			def PartitionCSQR(pCaseSensitive, pcReturnType)
				return This.PartsCSQR(pCaseSensitive, pcReturnType)

		def PartionedCS(pCaseSensitive)
			return This.PartsCS(pCaseSensitive)

			def PartionedCSQ(pCaseSensitive)
				return This.PartionedCSQR(pCaseSensitive, :stzList)

			def PartionedCSQR(pCaseSensitive, pcReturnType)
				return This.PartsCSQR(pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def Parts()
		return This.PartsCS(TRUE)

		#< @FunctionFluentForms

		def PartsQ()
			return This.PartsQR(:stzList)

		def PartsQR(pcReturnType)
			return This.PartsCSQR(TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def Partition() # A verb: to partition
			return This.Parts()

			def PartitionQ()
				return This.PartitionQR(:stzList)

			def PartitionQR(pcReturnType)
				return This.PartsQR(pcReturnType)

		def Partioned()
			return This.Parts()

			def PartionedQ()
				return This.PartionedQR(:stzList)

			def PartionedQR(pcReturnType)
				return This.PartsQR(pcReturnType)

		#>

	  #--------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE LIST  #
	#--------------------------------------------------#

	def FindPartsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ 1 ]
		ok

		# Doing the job

		aResult = [ 1 ]

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]
				aResult + i
			ok
	
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindPartsCSZ(pCaseSensitive)
			return This.FindPartsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindParts()
		return This.FindPartsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindPartsZ()
			return This.FindParts()

		#>

	  #--------------------------------------------------#
	 #  FINDING THE POSITIONS OF THE PARTS OF THE LIST  #
	#--------------------------------------------------#

	def FindPartsAsSectionsCS(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Doing the job

		aResult = [ [1] ]
		nLenResult = 1

		for i = 2 to nLen

			if acContent[i] != acContent[i-1]

				aResult[nLenResult] + (i-1)
				aResult + [ i ]
				nLenResult++
			ok
	
		next

		aResult[len(aResult)] + nLen
		return aResult

		#< @FunctionAlternativeForms

		def FindPartAsSectionsCSZ(pCaseSensitive)
			return This.FindPartsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def FindPartsAsSections()
		return This.FindPartsAsSectionsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindPartAsSectionsZ()
			return This.FindPartsAsSections()

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE PARTS OF THE LIST ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def PartsCSZ(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, 1 ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, i-n-1 ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, nLen-n ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirPositionsCS(pCaseSensitive)
			return This.PartsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZ()
		return This.PartsCSZ(TRUE)

		#< @FunctionAlternativeForms

		def PartAndTheirPositions()
			return This.PartsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING THE PARTS OF THE LIST ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------#

	def PartsCSZZ(pCaseSensitive)

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Stringifying the list and reparing it case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, [ 1, nLen ] ] ]
		ok

		# Doing the job

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acContent[i] = acContent[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, [ i-n-1, i-1 ] ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, [ nLen-n, nLen ] ]

		return aResult

		#< @FunctionAlternativeForms

		def PartsAndTheirSectionsCS(pCaseSensitive)
			return This.PartsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsZZ()
		return This.PartsCSZZ(TRUE)

		#< @FunctionAlternativeForms

		def PartAndTheirSections()
			return This.PartsZZ()

		#>

	  #---------------------------------------------------------------#
	 #  PARTIONONING A LIST BASED ON A GIVEN PARTITION EXPRESSION  #
	#===============================================================#

	/* Note:

	This function analyzes the list, by sequentially partitioning
	its content, using a given "partition expression", a "PartitionExpr",
	for short. Hence, it serves in answering this kind of question:

	How is the list composed in term of some item criteria
	(the item beeing, for example, lowercase or uppercase, or
	left-oriented or right-oriented).

	The PartitionExpr is what we should provide to the method in
	a param as a conditional code containing the @item keyword.

	For example:

	o1 = new stzList([ "TUNIS", "gafsa", "NABEUL", "beja" ])
	? o1.PartsUsing( 'Q(@item).StringCase()' )

	Uses the Kase() method in stzString as a PartitionExpr.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or NULL, then the classification done will return:

	[
		[ "TUNIS" ] = :Uppercase,
		[ " " ] = NULL,
		[ "gafsa" ] = :Lowercase,
		[ " " ] = NULL,
		[ "NABEUL" ] = :Uppercase,
		[ " " ] = NULL,
		[ "beja" ] = :Lowercase
	]

	*/
 
	def PartsUsingCS(paPartitionExpr, pCaseSensitive)
		/*
		Examples:

		o1 = new stzList([ "A", "b", "c", "28", "5", "X", "Y", "&", "" ])
		
		? o1.PartsUsing( 'Q(@item).IsLetter()' )
		#--> [
		#	[ "A", "b", "c" ] = TRUE,
		#	["28", "5" ] = FALSE,
		# 	[ "X", "Y" ] = TRUE,
		#o	[ "&", "" ] = FALSE
		# ]
		
		? o1.PartsUsing('Q(@item).Orientation()' )
		#--> [
		#	[ A", "b", "c", "28", "5", "X", "Y", "&" ] = :LeftToRight,
		#o	[ "" = :RightToLeft ]
		# ]
		
		? o1.PartsUsing( 'Q(@item).IsUppercase()' )
		#--> [
		# 	[ "A" ]  = TRUE,
		#	[ "b", "c", "28", "5" ] = FALSE,
		#	[ "X", Y" ] = TRUE,
		#o	[ "&", "" = FALSE
		# ]
		
		? o1.PartsUsing( 'Q(@item).Kase()' )
		#--> [
		#	[ "A" ] = :Uppercase,
		#	[ "b", "c" ] = :Lowercase,
		#	[ "28", "5" ] = NULL,
		#	[ "X", "Y" ] = :Uppercase,
		#o	[ "&", "" ] = NULL
		# ]

		*/

		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ @aContent ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
			else
				aResult + aPart
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + aPart

		return aResult

		#< @FunctionFluentForms

		def PartsUsingCSQ(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSQR(paPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSQR(paPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsUsingCS(paPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionUsingCS(paPartitionExpr, pCaseSensitive) # A verb: to partition
			return This.PartsUsingCS(paPartitionExpr, pCaseSensitive)

			def PartitionUsingCSQ(paPartitionExpr, pCaseSensitive)
				return This.PartitionUsingCSQR(paPartitionExpr, pCaseSensitive, :stzList)

			def PartitionCSUsingQR(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQR(paPartitionExpr, pCaseSensitive, pcReturnType)

		def PartionedUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCS(paPartitionExpr, pCaseSensitive)

			def PartionedUsingCSQ(paPartitionExpr, pCaseSensitive)
				return This.PartionedUsingCSQR(paPartitionExpr, pCaseSensitive, :stzList)

			def PartionedUsingCSQR(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSQR(paPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsing(paPartitionExpr)
		return This.PartsUsingCS(paPartitionExpr, TRUE)

		#< @FunctionFluentForms

		def PartsUsingQ(paPartitionExpr)
			return This.PartsUsingQR(paPartitionExpr, :stzList)

		def PartsUsingQR(paPartitionExpr, pcReturnType)
			return This.PartsUsingCSQR(paPartitionExpr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartitionUsing(paPartitionExpr) # A verb: to partition
			return This.PartsUsing(paPartitionExpr)

			def PartitionUsingQ(paPartitionExpr)
				return This.PartitionUsingQR(paPartitionExpr, :stzList)

			def PartitionUsingQR(paPartitionExpr, pcReturnType)
				return This.PartsUsingQR(paPartitionExpr, pcReturnType)

		def PartionedUsing(paPartitionExpr)
			return This.PartsUsing(paPartitionExpr)

			def PartionedUsingQ(paPartitionExpr)
				return This.PartionedUsingQR(paPartitionExpr, :stzList)

			def PartionedUsingQR(paPartitionExpr, pcReturnType)
				return This.PartsUsingQR(paPartitionExpr, pcReturnType)

		#>

	   #---------------------------------------------------------------------#
	  #  PARTIONONING A LIST BASED ON A GIVEN PARTITION EXPRESSION AND      #
	 #  RETURNING THE PARTS ALONG WITH THEIR RESPECTIVE EXPRESSION VALUES  #
	#=====================================================================#
 
	def PartsUsingCSXT(paPartitionExpr, pCaseSensitive)
		/*
		Examples:

		o1 = new stzList([ "A", "b", "c", "28", "5", "X", "Y", "&", "" ])
		
		? o1.PartsUsingXT( 'Q(@item).IsLetter()' )
		#--> [
		#	[ "A", "b", "c" ] = TRUE,
		#	["28", "5" ] = FALSE,
		# 	[ "X", "Y" ] = TRUE,
		#o	[ "&", "" ] = FALSE
		# ]
		
		? o1.PartsUsingXT('Q(@item).Orientation()' )
		#--> [
		#	[ A", "b", "c", "28", "5", "X", "Y", "&" ] = :LeftToRight,
		#o	[ "" = :RightToLeft ]
		# ]
		
		? o1.PartsUsingXT( 'Q(@item).IsUppercase()' )
		#--> [
		# 	[ "A" ]  = TRUE,
		#	[ "b", "c", "28", "5" ] = FALSE,
		#	[ "X", Y" ] = TRUE,
		#o	[ "&", "" = FALSE
		# ]
		
		? o1.PartsUsingXT( 'Q(@item).Kase()' )
		#--> [
		#	[ "A" ] = :Uppercase,
		#	[ "b", "c" ] = :Lowercase,
		#	[ "28", "5" ] = NULL,
		#	[ "X", "Y" ] = :Uppercase,
		#o	[ "&", "" ] = NULL
		# ]

		*/

		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, NULL ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ @aContent, NULL ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []

		for i = 2 to nLen

			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
			else
				aResult + [ aPart, aValues[i-1] ]
				aPart = [ @aContent[i] ]
			ok
	
		next
	
		aResult + [ aPart, aValues[nLen] ]

		return aResult

		#< @FunctionFluentForms

		def PartsUsingCSXTQ(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXTQR(paPartitionExpr, pCaseSensitive, :stzList)

		def PartsUsingCSXTQR(paPartitionExpr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfPairs( This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms

		def PartitionUsingCSXT(paPartitionExpr, pCaseSensitive) # A verb: to partition
			return This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive)

			def PartitionUsingCSXTQ(paPartitionExpr, pCaseSensitive)
				return This.PartitionUsingCSXTQR(paPartitionExpr, pCaseSensitive, :stzList)

			def PartitionCSUsingXTQR(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQR(paPartitionExpr, pCaseSensitive, pcReturnType)

		def PartionedUsingCSXT(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSXT(paPartitionExpr, pCaseSensitive)

			def PartionedUsingCSXTQ(paPartitionExpr, pCaseSensitive)
				return This.PartionedUsingCSXTQR(paPartitionExpr, pCaseSensitive, :stzList)

			def PartionedUsingCSXTQR(paPartitionExpr, pCaseSensitive, pcReturnType)
				return This.PartsUsingCSXTQR(paPartitionExpr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESESENSITIVITY

	def PartsUsingXT(paPartitionExpr)
		return This.PartsUsingCSXT(paPartitionExpr, TRUE)

		#< @FunctionFluentForms

		def PartsUsingXTQ(paPartitionExpr)
			return This.PartsUsingXTQR(paPartitionExpr, :stzList)

		def PartsUsingXTQR(paPartitionExpr, pcReturnType)
			return This.PartsUsingCSXTQR(paPartitionExpr, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def PartitionUsingXT(paPartitionExpr) # A verb: to partition
			return This.PartsUsingXT(paPartitionExpr)

			def PartitionUsingXTQ(paPartitionExpr)
				return This.PartitionUsingXTQR(paPartitionExpr, :stzList)

			def PartitionUsingXTQR(paPartitionExpr, pcReturnType)
				return This.PartsUsingXTQR(paPartitionExpr, pcReturnType)

		def PartionedUsingXT(paPartitionExpr)
			return This.PartsUsingXT(paPartitionExpr)

			def PartionedUsingXTQ(paPartitionExpr)
				return This.PartionedUsingXTQR(paPartitionExpr, :stzList)

			def PartionedUsingXTQR(paPartitionExpr, pcReturnType)
				return This.PartsUsingXTQR(paPartitionExpr, pcReturnType)

		#>

	  #-----------------------------#
	 #  FINDING PARTS IN THE LIST  #
	#=============================#

	def FindPartsUsingCS(paPartitionExpr, pCaseSensitive)
		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ 1 ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ 1 ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = @aContent[1]

		anResult = [ 1 ]

		for i = 2 to nLen

			if acValues[i] != acValues[i-1]
				anResult + i
			ok
	
		next

		return anResult

		def FindPartsUsingCSZ(paPartitionExpr, pCaseSensitive)
			return This.FindPartsUsingCS(paPartitionExpr, pCaseSensitive)

	def FindPartsUsing(paPartitionExpr)
		return This.FindPartsUsingCS(paPartitionExpr, TRUE)

		def FindPartsUsingZ(paPartitionExpr)
			return This.FindPartsUsing(paPartitionExpr)

	  #-------------------------------------------------------------------------#
	 #  FINDING PARTS IN THE LIST AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#=========================================================================#

	def FindPartsAsSectionsUsingCS(paPartitionExpr, pCaseSensitive)
		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ 1, nLen ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ 1, nLen ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluating the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aResult = [ [ 1 ] ]

		for i = 2 to nLen

			if acValues[i] != acValues[i-1]
				aResult[len(aResult)] + (i-1)
				aResult + [i]
			ok
	
		next

		aResult[len(aResult)] + nLen

		return aResult

		def FindPartsUsingCSZZ(paPartitionExpr, pCaseSensitive)
			return This.FindPartsAsSectionsUsingCS(paPartitionExpr, pCaseSensitive)

	def FindPartsAsSectionsUsing(paPartitionExpr)
		return This.FindPartsAsSectionsUsingCS(paPartitionExpr, TRUE)

		def FindPartsUsingZZ(paPartitionExpr)
			return This.FindPartsAsSectionsUsing(paPartitionExpr)

	  #----------------------------------------------------------#
	 #  GETTING PARTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#==========================================================#

	def PartsUsingCSZ(paPartitionExpr, pCaseSensitive)
		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ @aContent ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, i-n-1 ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, nLen-n ]

		return aResult

		def PartsAndTheirPositionsUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZ(paPartitionExpr, pCaseSensitive)

	def PartsUsingZ(paPartitionExpr)
		return This.PartsUsingCSZ(paPartitionExpr, TRUE)

		def PartsAndTheirPositionsUsing(paPartitionExpr)
			return This.PartsUsingZ(paPartitionExpr)

	  #-----------------------------------------------------------------------------#
	 #  gettING PARTS IN THE LIST AND RETURNING THEM ALO?G WITH THEIR POSITIONS  #
	#=============================================================================#

	def PartsUsingCSZZ(paPartitionExpr, pCaseSensitive)
		if CheckParams()
			if NOT isString(paPartitionExpr)
				StzRaise("Incorrect param type! paPartitionExpr must be a string.")
			ok

			if NOT StzStringQ(paPartitionExpr).ContainsCS("@item", FALSE)
				stzRaise("Syntax error! paPartitionExpr must contain the @Char keyword.")
			ok
		ok

		# Early check

		nLen = len(@aContent)

		if nLen < 2
			return [ [ @aContent, [1, nLen] ] ]
		ok

		# Getting the boolean behind pCaseSensitive

		bCaseSensitive = CaseSensitive(pCaseSensitive)

		# Special case

		if bCaseSensitive = FALSE and
			StzStringQ(paPartitionExpr).
			ContainsOneOfTheseCS([
				"charcase(", "isuppercase",
				"islowercase", "lower(", "upper(" ], FALSE)

				return [ [ @aContent, [1, nLen] ] ]
		ok

		# Preparing the data for case sensitivity

		if bCaseSensitive = FALSE
			acContent = This.StringifyQ().Lowercased()
		else
			acContent = This.Stringified()
		ok

		# Computing the values by evaluation the
		# expression against all the items

		cCode = StzStringQ(paPartitionExpr).TrimQ().TheseBoundsRemoved("{", "}")
		cCode = 'value = (' + cCode + ')'
		acValues = [] # Values stringified (to be used for comparison)
		aValues = []  # Values in their original types

		for @i = 1 to nLen
			@item = acContent[@i]
			eval(cCode)
			acValues + @@(value)
			aValues + value
		next

		# Getting the parts

		aPart = [ @aContent[1] ]

		aResult = []
		n = 0

		for i = 2 to nLen
			
			if acValues[i] = acValues[i-1]
				aPart + @aContent[i]
				n++
			else
				aResult + [ aPart, [ i-n-1, i-1 ] ]
				aPart = [ @aContent[i] ]
				n = 0
			ok
	
		next
	
		aResult + [ aPart, [ nLen-n, nLen ] ]

		return aResult

		def PartsAndTheirSectionsUsingCS(paPartitionExpr, pCaseSensitive)
			return This.PartsUsingCSZZ(paPartitionExpr, pCaseSensitive)

	def PartsUsingZZ(paPartitionExpr)
		return This.PartsUsingCSZZ(paPartitionExpr, TRUE)

		def PartsAndTheirSectionsUsing(paPartitionExpr)
			return This.PartsUsingZZ(paPartitionExpr)

	  #=====================================================#
	 #   THE LIST IS MADE OF CONTIGUOUS CHARS OR NUMBERS   #
	#=====================================================#

	def IsContiguous()
		bResult = FALSE

		if This.IsListOfNumbers()

			bResult = This.ToStzListOfNumbers().IsContiguous()

		but This.IsListOfChars()

			bResult = This.ToStzListOfChars().IsContiguous()

		ok

		return bResult

		def IsContinuous()
			return IsContiguous()

	  #==================================#
	 #  BISECTING THE LIST INTO HALVES  #
	#==================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfItems() / 2)
		acResult = This.Section(1, nPos)

		return acResult

		#-- MISSPELLED

		def FristHalf()
			return This.FirstHalf()

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

		#-- MISSPELLED

		def FristHalfAndPosition()
			return This.FirstHalfAndPosition()

		def FristHalfAndItsPosition()
			return This.FirstHalfAndPosition()


	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfItems() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()

		#-- MISSPELLED

		def FristHalfAndSection()
			return This.FirstHalfAndSection()

		def FristHalfAndItsSection()
			return This.FirstHalfAndSection()

	def FirstHalfXT()

		nPos = ceil(This.NumberOfItems() / 2)
		acResult = This.Section(1, nPos)

		return acResult

		#-- MISSPELLED

		def FristHalfXT()
			return This.FirstHalfXT()
		
	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

		#-- MISSPELLED

		def FristHalfAndPositionXT()
			return This.FirstHalfAndPositionXT()

		def FristHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfItems() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

		#-- MISSPELLED

		def FristHalfAndSectionXT()
			return This.FirstHalfAndSectionXT()

		def FristHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfItems()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfItems()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
				return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

	  #=============================================================#
	 #  CHECKING IF THE LIST CONTAINS SAME ITEMS AS AN OTHER LIST  #
	#=============================================================#

	def ContainsSameItemsAsCS(paOtherList, pCaseSensitive)
		if len( This.DifferentItemsWithCS(paOtherList, pCaseSensitive) ) = 0
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsSameItemsAs(paOtherList)
		return This.ContainsSameItemsAsCS(paOtherList, TRUE)

	   #------------------------------------------------------------#
	  #  GETTING THE LIST OF ITEMS FORMING THE DIFFERENCE BETWEEN  #
	 #  THE MAIN LIST AND AND OTHER GIVEN LIST                    #
	#------------------------------------------------------------#

	def DifferenceWithCS(paOtherList, pCaseSensitive)
		/*
		Returns a list composed of two hashlists:
			[
			:SURPLUS = [ "A", "B", ... ],
			:LACKING = [ "X", "Y", ... ]
			]
		*/
		aResult = [
				:SURPLUS = This.OverItemsComparedToCS(paOtherList, pCaseSensitive),
				:LACKING = This.LackingItemsComparedToCS(paOtherList, pCaseSensitive)
			  ]

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def DifferenceWith(paOtherList)
		return This.DifferenceWithCS(paOtherList, TRUE)

	   #---------------------------------------------------------#
	  #  GETTING THE LIST OF ITEMS WHICH ARE DIFFERENT BETWEEN  #
	 #  THE MAIN LIST AND AND OTHER GIVEN LIST                 #
	#---------------------------------------------------------#

	def DifferentItemsWithCS(paOtherList, pCaseSensitive)
		if NOT isList(pOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		aResult = This.OverItemsComparedToCS(paOtherList, pCaseSensitive)

		acLackingItems = This.LackingItemsComparedToCS(paOtherList, pCaseSensitive)
		nLen = len(acLackingItems)

		aContent = This.Content()

		for i = 1 to nLen
			aResult + aContent[i]
		next
	
		return aResult

		def DifferentItemsWithCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.DifferentItemsWithCS(paOtherList, pCaseSensitive) )

	#-- WITHOUT CASESENSITIVITY

	def DifferentItemsWith(paOtherList)
		if NOT isList(pOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		aResult = This.OverItemsComparedTo(paOtherList)
		aLacking = This.LackingItemsComparedTo(paOtherList)
		nLen = len(aLacking)

		for i = 1 to nLen
			aResult + aLacking[i]
		next
	
		return aResult

		def DifferentItemsWithQ(paOtherList)
			return new stzList( This.DifferentItemsWith(paOtherList) )

	  #--------------------------------------------------------------------#
	 #  GETTING THE OVER-ITEMS IN A GIVEN LIST COMPARED TO THE MAIN LIST  #
	#--------------------------------------------------------------------#

	def OverItemsComparedToCS(paOtherList, pCaseSensitive)
		if NOT isList(pOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		aResult = []

		oOtherList = new stzList(paOtherList)
		nLen = This.NumberOfItems()

		aContent = This.Content()

		for i = 1 to nLen

			if NOT oOtherList.ContainsCS(aContent[i], pCaseSensitive)
				aResult + aContent[i]
			ok
		next

		return aResult

		def OverItemsComparedToCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.OverItemsComparedToCS(paOtherList, pCaseSensitive) )

	#-- WITHOUT CASESENSITIVITY

	def OverItemsComparedTo(paOtherList)
		return This.OverItemsComparedToCS(paOtherList, TRUE)

		def OverItemsComparedToQ(paOtherList)
			return new stzList( This.OverItemsComparedTo(paOtherList) )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE LACKING-ITEMS IN THE LIST COMPARED TO AN OTHER GIVEN LIST  #
	#-------------------------------------------------------------------------#

	def LackingItemsComparedToCS(paOtherList, pCaseSensitive)
		aResult = []
		nLen = len(paOtherList)

		for i = 1 to nLen
			item = paOtherList[i]

			if NOT This.ContainsCS(item, pCaseSensitive)
				aResult + item
			ok
		next

		return aResult

		def LackingItemsComparedToCSQ(paOtherList, pCaseSensitive)
			return new stzList( This.LackingItemsComparedToCS(paOtherList, pCaseSensitive) )	

	#-- WITHOUT CASESENSITIVITY

	def LackingItemsComparedTo(paOtherList)
		return This.LackingItemsComparedToCS(paOtherList, TRUE)

		def LackingItemsComparedToQ(paOtherList)
			return new stzList( This.LackingItemsComparedTo(paOtherList) )	

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST HAS SAME NUMBER OF ITEMS AS AN OTHER GIVEN LIST  #
	#------------------------------------------------------------------------#

	def HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)
		If len(paOtherList) = This.NumberOfItems()
			return TRUE
		else
			return FALSE
		ok

		def HasSameWidthAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

		def HasSameSizeAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

		def ContainsSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)
			return This.HasSameNumberOfItemsAsCS(paOtherList, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasSameNumberOfItemsAs(paOtherList)
		return This.HasSameNumberOfItemsAsCS(paOtherList, TRUE)

		def HasSameWidthAs(paOtherList)
			return HasSameNumberOfItemsAs(paOtherList)

		def HasSameSizeAs(paOtherList)
			return HasSameNumberOfItemsAs(paOtherList)

		def ContainsSameNumberOfItemsAs(paOtherList)
			return This.HasSameNumberOfItemsAs(paOtherList)

	  #-------------------------------------------------------------------------------------#
	 #  GETTING THE COMMON-ITEMS (INTERSECTION) BETWEEN THE MAIN LIST AN OTHER GIVEN LIST  #
	#-------------------------------------------------------------------------------------#

	def CommonItemsWithCS(paOtherList, pCaseSensitive)

		if CheckParams()
			if NOT isList(paOtherList)
				StzRaise("Incorrect param type! paOtherList must be a list.")
			ok
		ok

		aContent = This.Content()
		nLen = len(aContent)
		aResult = []
		
		for i = 1 to nLen

			if (NOT Q(aResult).ContainsCS(aContent[i], pCaseSensitive)) and
			   Q(paOtherList).ContainsCS(aContent[i], pCaseSensitive)

				aResult + aContent[i]
			ok

		next

		return aResult

		#< FunctionFluentForm

		def CommonItemsWithCSQ(paOtherList, pCaseSensitive)
			return new stzlist( This.CommonItemsWithCS(paOtherList, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def IntersectionWithCS(paOtherList, pCaseSensitive)
			return This.CommonItemsWithCS(paOtherList, pCaseSensitive)

			def IntersectionWithCSQ(paOtherList, pCaseSensitive)
				return This.CommonItemsWithCSQ(paOtherList, pCaseSensitive)

		def IntersectWithCS(paOtherList, pCaseSensitive)
			return This.CommonItemsWithCS(paOtherList, pCaseSensitive)

			def IntersectWithCSQ(paOtherList, pCaseSensitive)
				return This.CommonItemsWithCSQ(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def CommonItemsWith(paOtherList)
		return This.CommonItemsWithCS(paOtherList, TRUE)

		#< @FunctionFluentForm

		def CommonItemsWithQ(paOtherList)
			return new stzlist( This.CommonItemsWith(paOtherList) )

		#>

		#< @FunctionAlternativeForms

		def IntersectionWith(paOtherList)
			return This.CommonItemsWith(paOtherList)

			def IntersectionWithQ(paOtherList)
				return This.CommonItemsWithQ(paOtherList)

		def IntersectWith(paOtherList)
			return This.CommonItemsWith(paOtherList)

			def IntersectWithQ(paOtherList)
				return This.CommonItemsWithQ(paOtherList)

		#>

	  #------------------------------------------------------------------------#
	 #  NUMBER OF COMMON ITEMS BETWEEN THE MAIN LIST AND AN OTHER GIVEN LIST  #
	#------------------------------------------------------------------------#

	def NumberOfCommonItemsWithCS(paItems, pCaseSensitive)
		return len(This.CommonItemsWithCS(paItems, pCaseSensitive))

		def SizeOfIntersectionWithCS(paItems, pCaseSensitive)
			return NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def CountCommonItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def HowManyCommonItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

		def HowManyCommonItemWithCS(paItem, pCaseSensitive)
			return This.NumberOfCommonItemsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfCommonItemsWith(paItems)
		return This.NumberOfCommonItemsWithCS(paItems, TRUE)

		def SizeOfIntersectionWith(paItems)
			return NumberOfCommonItemsWith(paItems)

		def CountCommonItemsWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

		def HowManyCommonItemsWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

		def HowManyCommonItemWith(paItem)
			return This.NumberOfCommonItemsWith(paItems)

	  #---------------------------------------------------------------------------#
	 #  NUMBER OF DIFFERENT ITEMS BETWEEN THE MAIN LIST AND AN OTHER GIVEN LIST  #
	#---------------------------------------------------------------------------#

	def NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)
		return len(This.DifferentItemsWithCS(paItems, pCaseSensitive))

		def CountDifferentItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

		def HowManyDifferentItemsWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

		def HowManyDifferentItemWithCS(paItem, pCaseSensitive)
			return This.NumberOfDifferentItemsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDifferentItemsWith(paItems)
		return This.NumberOfDifferentItemsWithCS(paItems, TRUE)

		def CountDifferentItemsWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

		def HowManyDifferentItemsWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

		def HowManyDifferentItemWith(paItem)
			return This.NumberOfDifferentItemsWith(paItems)

	  #=============================#
	 #  SORTING ORDER OF THE LIST  #
	#=============================#

	def SortingOrder()
		cResult = :Unsorted

		if This.IsSorted()
			if This.IsSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

	def HasSameSortingOrderAs(paOtherList)

		oTemp = new stzList(paOtherList)
		if oTemp.SortingOrder() = This.SortingOrder()
			return TRUE
		else
			return FALSE
		ok

		def HasSameOrderAs(paOtherList)
			return This.HasSameSortingOrderAs(paOtherList)

	  #-----------------------------------#
	 #  IS THE LIST SORTED OR UNSORTED?  #
	#-----------------------------------#
 
	def IsSorted()
		if This.IsSortedInAscending() or
		   This.IsSortedInDescending()
			return TRUE
		else
			return FALSE
		ok

		def ItemsAreSorted()
			return This.IsSorted()

	def IsSortedInAscending()

		# The idea is to sort a copy and then compare
		# it to the original content

		aContent = This.Content()
		nLen = len(aContent)

		aSorted = @SortList(aContent)

		bResult = TRUE

		for i = 1 to nLen
			cItem   = @@(aContent[i])
			cSorted = @@(aSorted[i])

			if cItem != cSorted
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ItemsAreSortedInAscending()
			return This.IsSortedInAscending()

		def IsSortedUp()
			return This.IsSortedInAscending()

		def ItemsAreSortedUp()
			return This.IsSortedInAscending()

	def IsSortedInDescending()
		aContent = This.Content()
		nLen = len(aContent)

		aSorted = ring_reverse( @SortList(aContent) )

		bResult = TRUE

		for i = 1 to nLen
			cItem   = @@(aContent[i])
			cSorted = @@(aSorted[i])

			if cItem != cSorted
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ItemsAreSortedInDescending()
			return This.IsSortedInDescending()

		def IsSortedDown()
			return This.IsSortedInAscending()

		def ItemsAreSortedDown()
			return This.IsSortedInAscending()

	def IsUnsorted()
		return NOT This.IsSorted()

		def ItemsAreUnSorted()
			return This.IsUnsorted()

		def IsNotSorted()
			return NOT This.IsUnsorted()

		def ItemsAreNotSorted()
			return NOT This.IsUnsorted()

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS SORTABLE (MADE OF SORTABLE ITEMS)  #
	#-------------------------------------------------------------#
 
	def IsSortable()
		if This.SortableItems() = This.NumberOfItems()
			return TRUE
		else
			return FALSE
		ok

	  #-------------------------------------#
	 #  SORTABLE ITEMS & UNSORTABLE ITEMS  #
	#-------------------------------------#
 
	def SortableItems()
		/*
		Number, strings and lists are sortable.

		Objects are not sortable except if they are stzNumber, stzString or stzList,
		or anyone of their derivaties.

		NB: This may change in the future and normal ring objects become sortable.

		*/

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			if isNumber(aContent[i]) or isString(aContent[i]) or isList(aContent[i]) or
			   @IsStzNumber(aContent[i]) or @IsStzString(aContent[i]) or @IsStzList(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

	def UnsortableItems()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i]) or isList(aContent[i]) or
			   @IsStzNumber(aContent[i]) or @IsStzString(aContent[i]) or @IsStzList(aContent[i])
				// do nothing, skip!
			else
				aResult + aContent[i]
			ok
		next
		return aResult

	  #----------------------------------#
	 #  SORTING THE ITEM IN ASSCENDING  #
	#----------------------------------#
 
	def SortInAscending()

		/*
		Ring native sort() function can sort a list made:
			- only of numbers
			- or only of strings.

		Softanza can do the same and more. Even heteregenous lists
		made of numbers, strings, lists and objects can be sorted !

		If the list is made of numbers and/or strings, then
		Ring native sort function is used.

		Otherwise, the list may contain items that are lists
		or objects, in addition to numbers and strings.

		In this case, Sofanza makes the sort by applying 10 steps:

		1- if the list contains stzNumbers they are numberified
		2- If the list contains stzStrings they are stringified
		3- if the list contains stzLists they are listified

		4- numbers are sorted first and put at the beginning
		5- stzNumbers are identified and set at their expected positions

		6- then strings are sorted and put after numbers
		5- stzStrings are identified and set at their expected positions

		7- then lists are sorted and put after strings
		8- stzLists are identified and set at their expected positions

		9- then objects are sorted based on type of their content
		   ~> if it is number, then the object is numberified and sorted
		      within the number. If it is a string, then it is sorted
		      within the strings, and so on.

		10. Remaining objects, whose Content() type is not a Ring type
		    (C or C++ object for example), are put at the end in the
		    order of their appearance.

		NOTE: In the mean time, stzObjects (and other objects) are
		not sortable yet ~> FUTURE

		*/

		aResult = @SortList( This.Content() )
		This.Update( aResult )

		#< @FunctionFluentForm

		def SortInAscendingQ()
			This.SortInAscending()
			return This

		#>

		#< @FunctionAlternativeForms

		def Sort()
			This.SortInAscending()

			def SortQ()
				return This.SortInAscendingQ()

		def SortUp()
			This.SortInAscending()

			def SortUpQ()
				return This.SortQ()

		#>

		#< @FunctionMisspelledForms

		def SortInAsending()
			This.SortInAscending()

			def SortInAsendingQ()
				return This.SortQ()

		def SortInAssending()
			This.SortInAscending()

			def SortInAssendingQ()
				return This.SortQ()

		#>

	def SortedInAscending()
		aResult = This.Copy().SortInAscendingQ().Content()
		return aResult

		def Sorted()
			return This.SortedInAscending()

		def SortedInAsending()
			return This.SortedInAscending()

		def SortedInAssending()
			return This.SortedInAscending()

		def SortedUp()
			return This.SortedInAscending()

	  #-----------------------------------#
	 #  SORTING THE ITEMS IN DESCENDING  #
	#-----------------------------------#

	def SortInDescending()
		aResult = ring_reverse( This.SortedInAscending() )
		This.Update( aResult )

		#< @FunctionFluentForm

		def SortInDescendingQ()
			This.SortInDescending()
			return This
		
		#>
	
		#< @FunctionAlternativeForms

		def SortDown()
			This.SortInDescending()

			def SortDownQ()
				return This.SortInDescendingQ()

		#>

		#< @FunctionMisspelledForms

		def SortInDesending()
			This.SortInDescending()

			def SortInDesendingQ()
				This.SortInDescending()
				return This


		def SortInDessending()
			This.SortInDescending()

			def SortInDessendingQ()
				This.SortInDescending()
				return This

		#>

	def SortedInDescending()
		aResult = This.Copy().SortInDescendingQ().Content()
		return aResult

		def SortedInDesending()
			return This.SortedInDescending()

		def SortedInDessending()
			return This.SortedInDescending()

		def SortedDown()
			return This.SortedInDescending()

	  #-------------------------------------------#
	 #  SORTING THE ITEM IN THE REVERSE ORDER  #
	#-------------------------------------------#
 
	def SortInReverseOrder()
		switch This.SortingOrder()
		on :Ascending
			This.SortInDescending()

		on: Descending
			This.SortInAscending()
		off

		def SortInReverseOrderQ()
			This.SortInReverse()
			return This

		def SortInReverse()
			This.SortInReverseOrder()

			def SortInReverseQ()
				This.SortInReverse()
				return This

	def SortedInReverse()
		aResult = This.Copy().SortInReverseQ().Content()
		return aResult

		def SortedInReverseOrder()
			return This.SortedInReverse()

	  #--------------------------------------------------------------#
	 #  SORTING THE ITEM BY AN EVALUATED EXPRESSION - IN ASCENDING  #
	#==============================================================#
 
	def SortBy(pcExpr)
		/* EXAMPLE
		o1 = new stzList([ "a", "abcde", "abc", "ab", "abcd" ])
		o1.SortBy('len(@item)')
		? o1.Content()

		#--> [ "a", "ab", "abc", "abcd", "abcde" ]

		*/

		if NOT (isString(pcExpr) and Q(pcExpr).ContainsCS("@item", :CS = FALSE))
			StzRaise("Incorrect param! pcExpr must be a string containing @item keyword.")
		ok

		aContent = This.Content()
		nLen = len(aContent)

		aContentXT = []

		cCode = ' value = (' + pcExpr + ')'

		for @i = 1 to nLen
			@item = aContent[@i]
			eval(cCode)
			aContentXT + [ @item, value ]
		next

		aContentXT = @SortOn(aContentXT, 2)

		aResult = []

		for i = 1 to nLen
			aResult + aContentXT[i][1]
		next

		This.UpdateWith(aResult)


		#< @FunctionFluentForm

		def SortByQ(pcExpr)
			This.SortBy(pcExpr)
			return This

		#>

		#< @FunctionAlternativeForms

		def SortByInAscending(pcExpr)
			This.SortBy(pcExpr)

			def SortByInAscendingQ(pcExpr)
				return This.SortByQ(pcExpr)

		def SortByUp(pcExpr)
			This.SortBy(pcExpr)

			def SortByUpQ(pcExpr)
				return This.SortByQ(pcExpr)

		#>

	def SortedBy(pcExpr)
		aResult = This.Copy().SortByQ(pcExpr).Content()
		return aResult

		def SortedByInAscending(pcExpr)
			return This.SortedBy(pcExpr)

		def SortedByUp(pcExpr)
			return This.SortedBy(pcExpr)

	  #---------------------------------------#
	 #  SORTING THE ITEM BY - IN DESCENDING  #
	#---------------------------------------#
 
	def SortByInDescending(pcExpr)
		aResult = ring_reverse( This.SortedByInAscending(pcExpr) )
		This.UpdateWith(aResult)

		def SortByInDescendingQ(pcExpr)
			This.SortByInDescending(pcExpr)
			return This

		def SortByDown(pcExpr)
			This.SortByInDescending(pcExpr)

			def SortByDownQ(pcExpr)
				return This.SortByInDescendingQ(pcExpr)

	def SortedByInDescending(pcExpr)
		aResult = ring_reverse( This.SortedByInAscending(pcExpr) )
		return aResult

		def SortedByDown(pcExpr)
			return This.SortedByInDescending(pcExpr)
		
	  #=======================================#
	 #     ASSOCIATE WITH AN ANOTHER LIST    #
	#=======================================#

	// Returns an Associative List (HashList) from the main list and an other list

	def AssociateWith(paOtherList)
		/* EXAMPLE

		o1 = new stzList([ "Name", "Age", "Job" ])
		o1.AssociateWith([ "Ali", 24, "Programmer" ])
		? o1.Content()

		#--> [ ["Name", "Ali"], ["Age", 24], ["Job", "Programmer"] ]

		*/

		if NOT isList(paOtherList)
			StzRaise("Incorrect param tpe!")
		ok

		aResult = []
		nLen  = This.NumberOfItems()
		nLenOtherList = len(paOtherList)

		aContent = This.Content()

		for i = 1 to nLen
			otherItem = NULL
			if i <= nLenOtherList
				otherItem = paOtherList[i]
			ok

			aResult + [ aContent[i], otherItem ]
		next

		This.Update( aResult )

		def AssociateWithQ(paOtherList)
			This.AssociateWith(paOtherList)
			return This

	def AssociatedWith(paOtherList)
		aResult = This.Copy().AssociateWithQ(paOtherList).Content()
		return aResult

	  #----------------------------#
	 #   REPEATED LEADING ITEMS   # #TODO: Add case sensitivity!
	#----------------------------#

	def HasRepeatedLeadingItems()
		if StzListQ(This.RepeatedLeadingItems()).IsEmpty()
			return FALSE
		else
			return TRUE
		ok

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedItems()
			return This.HasRepeatedLeadingItems()

		def HasLeadingItems()
			return This.HasRepeatedLeadingItems()
	
		#--

		def ContainsRepeatedLeadingItems()
			return This.HasRepeatedLeadingItems()

		def ContainsLeadingRepeatedItems()
			return This.HasRepeatedLeadingItems()

		def ContainsLeadingItems()
			return This.HasRepeatedLeadingItems()

		#>

	def HasRepeatedTrailingItems()
		if StzListQ(This.RepeatedTrailingItems()).IsEmpty()
			return FALSE
		else
			return TRUE
		ok

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedItems()
			return This.HasRepeatedTrailingItems()

		def HasTrailingItems()
			return This.HasRepeatedTrailingItems()
	
		#--

		def ContainsRepeatedTrailingItems()
			return This.HasRepeatedTrailingItems()

		def ContainsTrailingRepeatedItems()
			return This.HasRepeatedTrailingItems()

		def ContainsTrailingItems()
			return This.HasRepeatedTrailingItems()

		#>
	
	def RepeatedLeadingItems() # Same item is repeated at the start of the list

		/* Example:
			[ 'e', 'e', 'e', 'T', 'U', 'N', 'I', 'S' ]
			--> ['e','e','e']

			[ 'e', 'x', 'e', 'e', 'e', 'T', 'U', 'N', 'I', 'S' ]
			--> []
		*/

		aContent = This.Content()
		nLen = This.NumberOfItems()

		if NOT This.IsEmpty()
			cResult = ""
	
			i = 1
			while aContent[i] = aContent[1] and i <= nLen
				i++
			end

			if i > 2
				return This.NFirstItems(i-1)
			ok
		ok

		def RepeatedLeadingItemsQ()
			return new stzList( This.RepeatedLeadingItems() )
	
		def LeadingRepeatedItems()
			return This.RepeatedLeadingItems()

			def LeadingRepeatedItemsQ()
				return new stzList( This.LeadingRepeatedItems() )
	
		def LeadingItems()
			return This.RepeatedLeadingItems()

			def LeadingItemsQ()
				return new stzList( This.LeadingItems() )
	
	def RepeatedLeadingItem()
		if This.HasRepeatedLeadingItems()
			return This.Item(1)
		ok

		def RepeatedLeadingItemQ()
			return Q(This.RepeatedLeadingItem())
	
		def LeadingRepeatedItem()
			return This.RepeatedLeadingItem()

			def LeadingRepeatedItemQ()
				return Q(This.LeadingRepeatedItem())
	
		def LeadingItem()
			return This.RepeatedLeadingItem()

			def LeadingItemQ()
				return Q(This.LeadingItem())
	
	def NumberOfRepeatedLeadingItems()
		if This.HasRepeatedLeadingItems()
			return StzListQ( This.RepeatedLeadingItems() ).NumberOfItems()
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def NumberOfLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountRepeatedLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def CountLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyRepeatedLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyRepeatedLeadingItem()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingRepeatedItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingRepeatedItem()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingItems()
			return This.NumberOfRepeatedLeadingItems()

		def HowManyLeadingItem()
			return This.NumberOfRepeatedLeadingItems()

		#>

	def RepeatedLeadingItemIs(pItem)
		if This.HasRepeatedLeadingItems() and This.FirstItemQ().IsEqualTo(pItem)
			return TRUE
		else
			return FALSE
		ok

		def LeadingRepeatedItemIs(pItem)
			return This.RepeatedLeadingItemIs(pItem)

		def LeadingItemIs(pItem)
			return This.RepeatedLeadingItemIs(pItem)
	
	  #-----------------------------#
	 #   REPEATED TRAILING ITEMS   #
	#-----------------------------#

	def RepeatedTrailingItem()
		if This.HasRepeatedTrailingItems()
			return This.LastItem()
		ok

		def RepeatedTrailingItemQ()
			return Q(This.RepeatedTrailingItem())

		def TrailingRepeatedItem()
			return This.RepeatedTrailingItem()

			def TrailingRepeatedItemQ()
				return Q(This.TrailingRepeatedItem())

		def TrailingItem()
			return This.RepeatedTrailingItem()

			def TrailingItemQ()
				return Q(This.TrailingItem())
	
	def RepeatedTrailingItems()
		aResult = This.Copy().ReverseQ().RepeatedLeadingItems()
		return aResult

		def RepeatedTrailingItemsQ()
			return new stzList(This.RepeatedTrailingItems())
	
		def TrailingRepeatedItems()
			return This.RepeatedTrailingItems()

			def TrailingRepeatedItemsQ()
				return new stzList(This.TrailingRepeatedItems())
	
		def TrailingItems()
			return This.RepeatedTrailingItems()

			def TrailingItemsQ()
				return new stzList(This.TrailingItems())

	def NumberOfRepeatedTrailingItems()
		if This.HasRepeatedTrailingItems()
			return stzListQ( This.RepeatedTrailingItems() ).NumberOfItems()
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def NumberOfTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def NumberOfTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountRepeatedTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def CountTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyRepeatedTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyRepeatedTrailingItem()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyTrailingRepeatedItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowManyTrailingRepeatedItem()
			return This.NumberOfRepeatedTrailingItems()

		def HowmanyTrailingItems()
			return This.NumberOfRepeatedTrailingItems()

		def HowmanyTrailingItem()
			return This.NumberOfRepeatedTrailingItems()

		#>
	
	def RepeatedTrailingItemIs(pItem)
		if This.HasRepeatedLeadingItems() and This.LastItemQ().IsEqualTo(pItem)
			return TRUE
		else
			return FALSE
		ok

		def TrailingRepeatedItemIs(pItem)
			return This.RepeatedTrailingItemIs(pItem)

		def TrailingItemIs(pItem)
			return This.RepeatedTrailingItemIs(pItem)
	
	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING ITEMS   #
	#-------------------------------------#

	def RemoveRepeatedLeadingItems()
		if This.HasRepeatedLeadingItems()
			This.RemoveFirstNItems( This.NumberOfRepeatedLeadingItems() )
		ok

		def RemoveRepeatedLeadingItemsQ()
			This.RemoveRepeatedLeadingItems()
			return This

		def RemoveLeadingRepeatedItems()
			This.RemoveRepeatedLeadingItems()

			def RemoveLeadingRepeatedItemsQ()
				This.RemoveLeadingRepeatedItems()
				return This
	
		def RemoveLeadingItems()
			This.RemoveRepeatedLeadingItems()

			def RemoveLeadingItemsQ()
				This.RemoveLeadingItems()
				return This
	
	def RepeatedLeadingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedLeadingItemsQ().Content()
		return aResult

		def LeadingRepeatedItemsRemoved()
			return This.RepeatedLeadingItemsRemoved()

		def LeadingItemsRemoved()
			return This.RepeatedLeadingItemsRemoved()
	
	def RemoveRepeatedLeadingItem(pItem)
		if This.RepeatedLeadingItemQ().IsEqualTo(pItem)
			return This.RemoveRepeatedLeadingItems()
		ok

		def RemoveRepeatedLeadingItemQ(pItem)
			This.RemoveRepeatedLeadingItem(pItem)
			return This

		def RemoveLeadingRepeatedItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveLeadingRepeatedItemQ(pItem)
				This.RemoveLeadingRepeatedItem(pItem)
				return This
	
		def RemoveLeadingItem(pItem)
			This.RemoveRepeatedLeadingItem(pItem)

			def RemoveLeadingItemQ(pItem)
				This.RemoveLeadingItem(pItem)
				return This
	
	def RepeatedLeadingItemRemoved(pItem)
		aResult = This.Copy().RemoveRepeatedLeadingItemQ(pItem).Content()
		return aResult

		def LeadingRepeatedItemRemoved(pItem)
			return This.RepeatedLeadingItemRemoved(pItem)

		def LeadingItemRemoved(pItem)
			return This.RepeatedLeadingItemRemoved(pItem)

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING ITEMS   #
	#--------------------------------------#

	def RemoveRepeatedTrailingItems()
		if This.HasRepeatedTrailingItems()
			This.RemoveLastNItems( This.NumberOfRepeatedTrailingItems() )
		ok

		def RemoveRepeatedTrailingItemsQ()
			This.RemoveRepeatedTrailingItems()
			return This
	
		def RemoveTrailingRepeatedItems()
			This.RemoveRepeatedTrailingItems()

			def RemoveTrailingRepeatedItemsQ()
				This.RemoveTrailingRepeatedItems()
				return This
	
		def RemoveTrailingItems()
			This.RemoveRepeatedTrailingItems()

			def RemoveTrailingItemsQ()
				This.RemoveTrailingItems()
				return This
	
	def RepeatedTrailingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedTrailingItemsQ().Content()
		return aResult

		def TrailingRepeatedItemsRemoved()
			This.RepeatedTrailingItemsRemoved()

		def TrailingItemsRemoved()
			This.RepeatedTrailingItemsRemoved()
	
	def RemoveRepeatedTrailingItem(pItem)
		if This.RepeatedTrailingItemQ().IsEqualTo(pItem)
			This.RemoveRepeatedTrailingItems()
		ok

		def RemoveRepeatedTrailingItemQ(pItem)
			This.RemoveRepeatedTrailingItem(pItem)
			return This
	
		def RemoveTrailingRepeatedItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveTrailingRepeatedItemQ(pItem)
				This.RemoveTrailingRepeatedItem(pItem)
				return This
	
		def RemoveTrailingItem(pItem)
			This.RemoveRepeatedTrailingItem(pItem)

			def RemoveTrailingItemQ(pItem)
				This.RemoveTrailingItem(pItem)
				return This
	
	def RepeatedTrailingItemRemoved(pItem)
		aResult = This.Copy().RemoveRepeatedTrailingItemQ(pItem).Content()
		return aResult

		def TrailingRepeatedItemRemoved(pItem)
			return This.RepeatedTrailingItemRemoved(pItem)

		def TrailingItemRemoved(pItem)
			return This.RepeatedTrailingItemRemoved(pItem)
	
	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING ITEMS   #
	#--------------------------------------------------#

	def RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
		This.RemoveRepeatedLeadingItem(pItem1)
		This.RemoveRepeatedTrailingItem(pItem2)

		def RemoveRepeatedLeadingcharAndTrailingItemQ(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
			return This

		def RemoveLeadingItemAndTrailingItem(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveLeadingItemAndTrailingItemQ(pItem1, pItem2)
				This.RemoveLeadingItemAndTrailingItem(pItem1, pItem2)
				return This
	
		def RemoveTrailingItemAndLeadingItem(pItem1, pItem2)
			This.RemoveRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def RemoveTrailingItemAndLeadingItemQ(pItem1, pItem2)
				This.RemoveTrailingItemAndLeadingItem(pItem1, pItem2)
				return This
	
	def RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)
		aResult = This.Copy().RemoveRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2).Content()
		return aResult

		def RepeatedTrailingItemAndLeadingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def LeadingItemAndTrailingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)

		def TrailingItemAndLeadingItemRemoved(pItem1, pItem2)
			return This.RepeatedLeadingItemAndTrailingItemRemoved(pItem1, pItem2)
	
	def RemoveRepeatedLeadingAndTrailingItems()
		This.RemoveRepeatedLeadingItems()
		This.RemoveRepeatedTrailingItems()

		def RemoveRepeatedLeadingAndTrailingItemsQ()
			This.RemoveRepeatedLeadingAndTrailingItems()
			return This
	
		def RemoveLeadingAndTrailingRepeatedItems()
			This.RemoveRepeatedLeadingAndTrailingItems()

			def RemoveLeadingAndTrailingRepeatedItemsQ()
				This.RemoveLeadingAndTrailingRepeatedItems()
				return This
	
	def RepeatedLeadingAndTrailingItemsRemoved()
		aResult = This.Copy().RemoveRepeatedLEadingAndTrailingItems()
		return aResult

		def RepeatedTrailingAndLeadingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()

		def LeadingAndTrailingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()

		def TrailingAndLeadingItemsRemoved()
			return This.RepeatedLeadingAndTrailingItemsRemoved()
	
	  #-----------------------------#
	 #   REPLACING LEADING ITEMS   #
	#-----------------------------#

	def ReplaceRepeatedLeadingItem(pItem)
		/* Example:

		StzListQ([ '_', '_', '_', 'V', 'A', 'R', '-', '-', '-' ]).ReplaceRepeatedLeadingItem(:With = "-")

		--> Gives: [ '-', '-', '-', 'V', 'A', 'R', '-', '-', '-' ]
		*/

		if isList(pItem) and Q(pItem).IsWithOrByNamedParam()
			pItem = pItem[2]
		ok

		if This.HasRepeatedLeadingItems()
			n = This.NumberOfRepeatedLeadingItems()

			for i = 1 to n
				This.ReplaceAt(i, pItem)
			next

		ok

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingItemQ(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)
			return This
			
		#>
	
		#< @FunctionAlternativeForms
	
		def ReplaceLeadingRepeatedItem(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingRepeatedItemQ(pItem)
				This.ReplaceLeadingRepeatedItem(pItem)
				return This
	
		def ReplaceLeadingItem(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingItemQ(pItem)
				This.ReplaceLeadingItem(pItem)
				return This

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedLeadingItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceRepeatedLeadingItemsQ(pItem)
				This.ReplaceRepeatedLeadingItems(pItem)
				return This

		def ReplaceLeadingRepeatedItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingRepeatedItemsQ(pItem)
				This.ReplaceLeadingRepeatedItems(pItem)
				return This
	
		def ReplaceLeadingItems(pItem)
			This.ReplaceRepeatedLeadingItem(pItem)

			def ReplaceLeadingItemsQ(pItem)
				This.ReplaceLeadingItems(pItem)
				return This

		#>

	def RepeatedLeadingItemReplaced(pItem)
		aResult = This.Copy().ReplaceRepeatedLeadingItemQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def LeadingRepeatedItemReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)
	
		def LeadingItemReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		#-- Same functions with ...Items in plural

		def RepeatedLeadingItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		def LeadingRepeatedItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)
	
		def LeadingItemsReplaced(pItem)
			return This.RepeatedLeadingItemReplaced(pItem)

		#>
				
	  #------------------------------#
	 #   REPLACING TRAILING ITEMS   #
	#------------------------------#

	def ReplaceRepeatedTrailingItem(pItem)
		/* Example:

		stzListQ([ "_","_","_","V","A","R","-","-","-" ]).ReplaceRepeatedTrailingItemBy("_")

		Gives --> [ "_","_","_","V","A","R","_","_","_" ]
		*/

		if isList(pItem) and Q(pItem).IsWithOrByNamedParam()
			pItem = pItem[2]
		ok

		if This.HasRepeatedTrailingItems()
			n = This.NumberOfRepeatedTrailingItems()

			n = This.NumberOfItems() - n + 1
			for i = n to This.NumberOfItems()
				This.ReplaceAt(i, pItem)
			next

		ok

		#< @FunctionFluentForm

		def ReplaceRepeatedTrailingItemQ(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)
			return This
			
		#>
	
		#< @FunctionAlternativeForms
	
		def ReplaceTrailingRepeatedItem(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingRepeatedItemQ(pItem)
				This.ReplaceTrailingRepeatedItem(pItem)
				return This
	
		def ReplaceTrailingItem(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingItemQ(pItem)
				This.ReplaceTrailingItem(pItem)
				return This

		#-- Same functions with ...Items in plural

		def ReplaceRepeatedTrailingItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceRepeatedTrailingItemsQ(pItem)
				This.ReplaceRepeatedTrailingItems(pItem)
				return This

		def ReplaceTrailingRepeatedItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingRepeatedItemsQ(pItem)
				This.ReplaceTrailingRepeatedItems(pItem)
				return This
	
		def ReplaceTrailingItems(pItem)
			This.ReplaceRepeatedTrailingItem(pItem)

			def ReplaceTrailingItemsQ(pItem)
				This.ReplaceTrailingItems(pItem)
				return This

		#>

	def RepeatedTrailingItemReplaced(pItem)
		aResult = This.Copy().ReplaceRepeatedTrailingItemQ(pItem).Content()
		return aResult

		#< @FunctionAlternativeForms
	
		def TrailingRepeatedItemReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)
	
		def TrailingItemReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		#-- Same functions with ...Items in plural

		def RepeatedTrailingItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		def TrailingRepeatedItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)
	
		def TrailingItemsReplaced(pItem)
			return This.RepeatedTrailingItemReplaced(pItem)

		#>
	
	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING ITEMS   #
	#---------------------------------------------------#

	def ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
		This.ReplaceRepeatedLeadingItemWith(pItem1)
		This.ReplaceRepeatedTrailingItemWith(pItem2)

		def ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)
			return This

		def ReplaceRepeatedTrailingItemAndLeadingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceRepeatedTrailingItemAndLeadingItemQ(pItem1, pItem2)
				This.ReplaceRepeatedTrailingItemAndLeadingItem(pItem1, pItem2)
				return This
	
		def ReplaceLeadingItemAndTrailingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceLeadingItemAndTrailingItemQ(pItem1, pItem2)
				This.ReplaceLeadingItemAndTrailingItem(pItem1, pItem2)
				return This
	
		def ReplaceTrailingItemAndLeadingItem(pItem1, pItem2)
			This.ReplaceRepeatedLeadingItemAndTrailingItem(pItem1, pItem2)

			def ReplaceTrailingItemAndLeadingItemQ(pItem1, pItem2)
				This.ReplaceTrailingItemAndLeadingItem(pItem1, pItem2)
				return This
	
	def RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)
		aResult = This.Copy().ReplaceRepeatedLeadingItemAndTrailingItemQ(pItem1, pItem2).Content()
		return aResult
	
		def RepeatedTrailingItemAndLeadingItemReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)
	
		def TrailingItemAndLeadingItemReplaced(pItem1, pItem2)
			This.RepeatedLeadingcharAndTrailingItemReplaced(pItem1, pItem2)
	
	def ReplaceRepeatedLeadingAndTrailingItems(pItem)
		This.ReplaceRepeatedLeadingItem(pItem)
		This.ReplaceRepeatedTrailingItem(pItem)

		def ReplaceRepeatedLeadingAndTrailingItemsQ(pItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pItem)
			return This
	
		def ReplaceLeadingAndTrailingItems(pItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pItem)

			def ReplaceLeadingAndTrailingItemsQ(pItem)
				This.ReplaceLeadingAndTrailingItems(pItem)
				return This
	
		def ReplaceRepeatedTrailingAndLeadingItems(pItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pItem)

			def ReplaceRepeatedTrailingAndLeadingItemQ(pItem)
				This.ReplaceRepeatedTrailingAndLeadingItems(pItem)
				return This
	
		def ReplaceTrailingAndLeadingItems(pItem)
			This.ReplaceRepeatedLeadingAndTrailingItems(pItem)

			def ReplaceTrailingAndLeadingItemsQ(pItem)
				This.ReplaceTrailingAndLeadingItems(pItem)
				return This
	
	def RepeatedLeadingAndTrailingItemsReplaced(pItem)
		aResult = This.Copy().ReplaceRepeatedLeadingAndTrailingItemsQ(pItem).Content()
		return aResult

		def RepeatedTrailingAndLeadingItemsReplaced(pItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pItem)

		def LeadingAndTrailingItemsReplaced(pItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pItem)
	
		def TrailingAndLeadingItemsReplaced(pItem)
			return This.RepeatedLeadingAndTrailingItemsReplaced(pItem)

	  #==============================#
	 #     OPERATORS OVERLOADING    #
	#==============================#

	/*
		TODO: Operators should adopt same semantics in all classes...
	*/

	def operator(pcOp, pValue)
		
		if pcOp = "[]"

			if isNumber(pValue)
				return This.Item(pValue)

			but isString(pValue)
				oStr = new stzString(pValue)
			
				if oStr.NumberOfOccurrenceQ(":").IsEither(1, 2) and
				    oStr.Copy().RemoveQ(":").IsNumberInString()

					/* EXAMPLES

					? Q(1:5)['::-1']
					#--> [ 5, 4, 3, 2, 1 ]

					? Q(1:10)['2:8:2']
					#--> [ 2, 4, 6, 8 ]

					*/

					acNumbers = oStr.SplitAt(":")
					nLen = len(acNumbers)

					n1 = 1
					if acNumbers[1] != NULL
						n1 = 0+ acNumbers[1]
					ok

					n2 = This.NumberOfItems()
					if acNumbers[2] != NULL
						n2 = 0+ acNumbers[2]
					ok

					nStep = 1
					if nLen = 3
						nStep = 0+ acNumbers[3]
					ok

					aContent = This.Content()
					aResult = []

					if nStep < 0
						nTemp = n1
						n1 = n2
						n2 = nTemp
					ok

					for i = n1 to n2 step nStep
						aResult + aContent[i]
					next

					return aResult

				but oStr.TrimQ().IsBoundedBy([ "{", "}" ])

					pcCondition = StzStringQ(pValue).TrimQ().TheseBoundsRemoved("{", "}")
					anResult = []
	
					@i = 0
					for @item in This.List()
						@i++
						cCode = 'if ( ' + pcCondition + ' )' + NL +
							'	anResult + @i' + NL +
							'ok'
						eval(cCode)
					next
	
					return anResult
				ok

			else
				return This.FindAll(pValue)
			ok

		// Add an item at the beginning of the list
		but pcOp = "<<"
			This.InsertBeforePosition(1)

		// Add an item at the end of the list
		but pcOp = ">>"
			This.Add(pValue)

		but pcOp = "="
			return This.IsEqualTo(pValue)

		but pcOp = "=="
			return This.IsStrictlyEqualTo(pValue)

		// Divides the list on pValue sublists (a list of lists)
		but pcOp = "/" 

			if This.IsListOfNumbers() and isNumber(pValue)
				aContent = This.Content()
				nLen = len(aContent)

				aResult = []

				for i = 1 to nLen
					aResult + (aContent[i] / pValue)
				next

				return aResult

			but This.IsListOfNumbers() and @IsStzNumber(pValue)
				aContent = This.Content()
				nLen = len(aContent)

				aResult = []

				for i = 1 to nLen
					aResult + (aContent[i] / pValue.Content())
				next

				This.Update(aResult)
				return This

			but @IsStzString(pValue)
				aResult = This.SplittedUsing(pValue.Content())
				return new stzList(aResult)

			but isList(pValue)
				aResult = This.DistributedOver(pValue.Content())
				return aResult

			but @IsStzList(pValue)
				aResult = This.DistributedOver(pValue.Content())
				return new stzList(aResult)

			but @IsStzNumber(pValue)
				aResult = This.SplittedToNParts(pValue.NumericValue())
				return new stzList(aResult)

			but isNumber(pValue)
				aResult = This.SplittedToNParts(pValue)
				return aResult
			ok

		but pcOp = "-"
			if isList(pValue)

				if _bThese
					aResult = This.Copy().ManyRemoved(pValue)
					_bThese = FALSE # Resets the global flag
				else
					aResult = This.Copy().ItemRemoved(pValue)
				ok

				return aResult
			
			but @IsStzList(pValue) or @IsStzString(pValue)
				if _bThese
					This.RemoveMany(pValue.Content())
					_bThese = FALSE  # Resets the global flag
				else
					This.RemoveItem(pValue.Content())
				ok

				return This
			
			but @IsStzNumber(pValue)	
				anPos = This.FindAll(pValue.NumericValue())
				This.RemoveItemsAtPositions(anPos)

			else
				anPos = This.FindAll(pValue)
				aResult = This.RemoveItemsAtPositions(anPos)
				return This.Content()
			ok

		but pcOp = "*"
			if This.IsListOfNumbers() and isNumber(pValue)
				aContent = This.Content()
				nLen = len(aContent)

				aResult = []

				for i = 1 to nLen
					aResult + (aContent[i] * pValue)
				next

				return aResult

			but This.IsListOfNumbers() and @IsStzNumber(pValue)
				aContent = This.Content()
				nLen = len(aContent)

				aResult = []

				for i = 1 to nLen
					aResult + (aContent[i] * pValue.Content())
				next

				This.Update(aResult)
				return This

			but @IsStzString(pValue) or @IsStzList(pValue)
				This.MultiplyBy(pValue.Content())
				return This

			but @IsStzNumber(pValue)
				This.MultiplyBy(pValue.NumericValue())
				return This

			else
				aResult = This.Copy().MultiplyByQ(pValue).Content()
				return aResult
			ok

		but pcOp = "+"

			if isList(pValue)

				if _bThese
					aResult = This.Copy().ManyAdded(pValue)
					_bThese = FALSE # Resets the global flag
				else
					aResult = This.Copy().ItemAdded(pValue)
				ok

				return aResult
			
			but @IsStzList(pValue) or @IsStzString(pValue)
				if _bThese
					This.AddMany(pValue.Content())
					_bThese = FALSE  # Resets the global flag
				else
					This.AddItem(pValue.Content())
				ok

				return This
			
			but @IsStzNumber(pValue)	
				if _bThese
					This.AddMany(pValue.NumericValue())
					_bThese = FALSE  # Resets the global flag
				else
					This.AddItem(pValue.NumericValue())
				ok

				return This

			else
				This.Add(pValue)
				return This.Content()

			ok
		ok

	  #------------------------------#
	 #     CALCULATION OPERATORS    #
	#------------------------------#

	def MultiplyBy(p)
		switch ring_type(p)
		on "NUMBER"
			aContent = This.Content()
			nLen = len(aContent)

			aResult = []

			for i = 1 to p
				for j = 1 to nLen
					aResult + aContent[j]
				next
			next

			This.Update( aResult )

		on "STRING"
			for item in This.List()
				if isString(item)
					item += p

				but isNumber(item)
					for i = 1 to p-1
						item += item
					next

				but isList(item)
					item = StzListQ(item) * p
				ok
			next

		on "LIST"
			// TODO: Produces a list of lists (matrix)
			StzRaise("Unavailable feature!")


		other
			StzRaise("Unsupported type!")
		off

		#< @FunctionFluentForm

		def MultiplyByQ(p)
			This.MultiplyBy(p)
			return This

		#>

		#< @FunctionAlternativeForm

		def Multiply(p)
			This.MultiplyWith(p)

		#>

	def ItemsInPositions(panPos)
		aResult = []
		for n in panPos
			aResult + This.Item(n)
		next

		return aResult

		def ItemsInPositionsQ(panPos)
			return new stzList( This.ItemsInPositions(panPos) ) 

	def Minus(paOtherList)
		/*
		Example:
		o1 = new stzList([ "a", "b", "b", "b", "c" ])
		? o1 - [ "b", "b" ] -->  [ "a", "b", "c" ]
		*/
		aTempList = This.List()
		for item in paOtherList
			del(aTempList, ring_find(aTempList, item))
		next

		This.Update( aTempList )

		def MinusQ(paOtherList)
			This.Minus(paOtherList)
			return This

	  #===========================================#
	 #  EXTENDING THE LIST WITH THE GIVEN ITEMS  #
	#===========================================#

	def ExtendWith(paItems)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = len(paItems)

		for i = 1 to nLen
			@aContent + paItems[i]
			#NOTE
			# Using This.Add() is better then using @aContent directly,
			# but I do it to gain performance on large lists

		next

		#< @FunctionFluentForm

		def ExtendWithQ(paItems)
			This.ExtendWith(paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithItems(paItems)
			This.ExtendWith(paItems)

			def ExtendWithItemsQ(paItems)
				This.ExtendWithItems(paItems)
				return This

		#>

	def ExtendedWith(paItems)
		aResult = This.Copy().ExtendWithQ(paItems).Content()
		return aResult

		def ExtendedWithItems(paItems)
			return This.ExtendedWith(paItems)

	  #-------------------------------------#
	 #  EXTENDINF THE LIST TO N POSITIONS  #
	#-------------------------------------#

	def ExtendToPosition(n)

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()

		if n > nLen

			value = ""
			if This.IsListOfNumbers()
				value = 0
			ok

			nExtend = n - nLen
			for i = 1 to nExtend
				@aContent + value
			next
		ok
		
		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsToNItemsNamedParam() )

				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNItems(n)
			This.ExtendToPosition(n)
			
			def ExtendToNItemsQ(n)
				This.ExtendToNItems(n)
				return This

		def Extend(n)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNItems ])
				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		aResult = This.Copy().ExtendToPositionQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNItems(n)
			return This.ExtendedToPosition(n)

		#>

	  #-------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION WITH A GIVEN VALUE  #
	#-------------------------------------------------------------#

	def ExtendToPositionWith(n, pValue)

		if isString(pValue) and pValue = :ItemsRepeated
			This.ExtendToPositionWithItemsRepeated(n)
			return
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()

		if n > nLen

			nExtend = n - nLen
			for i = 1 to nExtend
				@aContent + pValue
			next
		ok

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pValue)
			This.ExtendToPositionWith(n, pValue)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pValue)
			This.ExtendToPositionWith(n, pValue)

			def ExtendToWithQ(n, pValue)
				This.ExtendToWith(n, pValue)
				return This

		#>

	def ExtendedToPositionWith(n, pValue)
		aResult = This.Copy().ExtendToPositionWithQ(n, pValue).Content()
		return aResult

		def ExtendedToWith(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

		#-- Misspelled

		def ExtendtedToWith(n, pValue)
			return This.ExtendedToPositionWith(n, pValue)

	  #----------------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION BY REPEATING THE LIST ITEMS  #
	#----------------------------------------------------------------------#
	
	def ExtendToPositionWithItemsRepeated(n)
		This.ExtendToPositionWithItemsIn(n, This.List())

		#< @FunctionFluentForm

		def ExtendToPositionWithItemsRepeatedQ(n)
			This.ExtendToPositionWithItemsRepeated(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ExtendToWithItemsRepeated(n)
			This.ExtendToPositionWithItemsRepeated(n)

			def ExtendToWithItemsRepeatedQ(n)
				This.ExtendToWithItemsRepeated(n)
				return This

		def ExtendToByRepeatingItems(n)
			This.ExtendToPositionWithItemsRepeated(n)

			def ExtendtoByRepeatingItemsQ(n)
				This.ExtendtoByRepeatingItems(n)
				return This

		#>

	def ExtendedToPositionWithItemsRepeated(n)
		aResult = This.Copy().ExtendToPositionWithItemsRepeatedQ(n).Content()
		return aResult

		#< @FunctionAlternativeForm

		def ExtendedToWithItemsRepeated(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		def ExtendedToByRepeatingItems(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		#>

		#< @FunctionMisspelledForm

		def ExtendtedToWithItemsRepeated(n)
			return This.ExtendedToPositionWithItemsRepeated(n)

		#>

	  #----------------------------------------------------------------------#
	 #  EXTENDING THE LIST TO A GIVEN POSITION BY REPEATING THE LIST ITEMS  #
	#----------------------------------------------------------------------#

	def ExtendToPositionWithItemsIn(n, paItems)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = len(paItems)
		nTemp = n - nLen
		aTemp = []

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				aTemp + paItems[j]
			next
		ok

		This.ExtendWith(aTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithItemsInQ(n, paItems)
			This.ExtendToPositionWithItemsIn(n, paItems)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithItemsIn(n, paItems)
			return This.ExtendToPositionWithItemsIn(n, paItems)

			def ExtendToWithItemsInQ(n, paItems)
				This.ExtendToWithItemsIn(n, paItems)
				return This

		#>

	def ExtendedToPositionWithItemsIn(n, paItems)
		aResult = This.Copy().ExtendToPositionWithItemsInQ(n, paItems).Content()
		return aResult

		def ExtendedToWithItemsIn(n, paItems)
			return This.ExtendedToPositionWithItemsIn(n, paItems)

		#-- Misspelled

		def ExtendtedToWithItemsIn(n, paItems)
			return This.ExtendedToPositionWithItemsIn(n, paItems)

	  #------------------------------------------------#
	 #  EXTENDING THE LIST - A GENERAL EXTENDED FORM  #
	#------------------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :List, :With = ["D", "E"])
		o1.Show()
		#--> [ "A", "B", "C", "D", "E" ])

		EXAMPLE 2

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :List, :ToPosition = 5 )
		o1.Show()
		#--> [ "A", "B", "C", "", "" ]

		EXAMPLE 3

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPosition = 5, :With = :ItemsRepeated )
		# Or: o1.ExtendXT( :ToPosition = 5, :ByRepeatingItems )
		o1.Show()
		#--> [ "A", "B", "C", "A", "B" ])

		EXAMPLE 4

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> [ "A", "B", "C", "*", "*" ]

		EXAMPLE 5

		o1 = new stzList([ "A", "B", "C" ])
		o1.ExtendXT( :ToPostion = 5, :WithItemsIn = [ "D", "E" ])
		o1.Show()
		#--> [ "A", "B", "C", "D", "E" ]

		*/

		if isString(n) and n = :List

			# Case 1: o1.ExtendXT( :List, :With = ["D", "E"])
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :List, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if isList(pWith) and Q(pWith).IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :ItemsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :ItemsRepeated or pWith[2] = :RepeatingItems )

					This.ExtendToPositionWithItemsRepeated(n[2])
					#NOTE this is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    Q(pWith).IsOneOfThese([
				:ByRepeatingItems, :WithItemsRepeated, :ByItemsRepeated ] )

				if isList(n) and Q(n).IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithItemsRepeated(n)
				return

			# Case 5: o1.ExtendXT( :ToPostion = 5, :WithItemsIn = [ "D", "E" ])
			but Q(pWith).IsWithItemsInNamedParam()
				This.ExtendToPositionWithItemsIn(n[2], pWith[2])
				return

			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionFluentForm

		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		aResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return aResult

		#< @FunctionMisspelledForm

		def ExtendtedXT(n, pWith)
			return This.ExtendedXT(n, pWith)

	  #------------------------------------------#
	 #  SHRINKING THE LIST TO A GIVEN POSITION  #
	#==========================================#

	def ShrinkTo(n)
		if isList(n) and Q(n).IsPositionNamedParam()
			n = n[2]
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveItemsAtPositions( (n+1) : nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNItems(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNItemsQ(n)
				This.ShrinkToNItems(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNItems(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================================#
	 #  MERGING THE LIST - IF IT IS A LIST OF LISTS  #
	#===============================================#

	def Merge()

		aContent = This.Content()
		nLen = This.NumberOfItems()

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				nLenList = len(aContent[i])
				for j = 1 to nLenList
					aResult + aContent[i][j]
				next
			else
				aResult + aContent[i]
			ok
		next

		This.Update(aResult)


		def MergeQ()
			This.Merge()
			return This

	def Merged()
		aResult = This.Copy().MergeQ().Content()
		return aResult

	  #-----------------------------------------#
	 #   MERGING THE LIST WITH AN OTHER LIST   #
	#-----------------------------------------#

	def MergeWith(paOtherList)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param! paOtherList must be a list.")
		ok

		nLen = len(paOtherList)

		for i = 1 to nLen
			This.Add(paOtherList[i])
		next

		def MergeWithQ(paOtherList)
			This.MergeWith(paOtherList)
			return This

	def MergedWith(paOtherList)
		aResult = This.Copy().MergeWithQ(paOtherList).Content()
		return aResult

	  #----------------------------#
	 #     FLATTENING THE LIST    #
	#----------------------------#
	
	def Flatten() 
		/* EXAMPLE

		o1 = new stzList([ "A", [ "]B[", "C" ], "D", [ [ "E", "F" ] ] ]
		? o1.Flatten()

		#--> [ "A", "B", "C", "D" ]

		*/

		aContent = This.Content()
		nLen = This.NumberOfItems()
		
		aResult = []
		aTemp = []

		for i = 1 to nLen

			if isList(aContent[i])

				aTemp = Q(aContent[i]).Flattened()
				nLenTemp = len(aTemp)

				for j = 1 to nLenTemp
					aResult + aTemp[j]
				next
			else
				aResult + aContent[i]
			ok
		next
		
		This.Update(aResult)

		#< @FunctionFluentForm

		def FlattenQ()
			This.Flatten()
			return This

		def FlattenQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.Flattened() )
				on :stzListOfStrings
					return new stzListOfStrings( This.Flattened() )

				on :stzListOfNumbers
					return new stzListOfNumbers( This.Flattened() )

				on :stzListOfLists
					return new stzListOfLists( This.Flattened() )

				on :stzListOfPairs
					return new stzListOfPairs( This.Flattened() )

				on :stzListOfObjects
					return new stzListOfObjects( This.Flattened() )

				other
					StzRaise("Unsupported return type!")
				off
		#>
	
	def Flattened()
		aResult = This.Copy().FlattenQ().Content()
		return aResult

	  #----------------------#
	 #     FROM/TO LIST     #
	#----------------------#
	#TODO
	# Do it for all Softanza classes()

	def ToStzSet()
		return new stzSet( This.ToSet() )

	def ToStzListOfNumbers()
		return new stzListOfNumbers( This.Content() )

	def ToStzListOfLists()
		return new stzListOfLists(This.Content())

	def ToStzListOfPairs()
		return new stzListOfPairs(This.Content())

	def ToStzListOfStrings()
		return new stzListOfStrings(This.Content())

	def ToStzHashList()
		return new stzHashList( This.List() )

	  #-----------------------------------------------------#
	 #     NUMBER OF OCCURRENCE OF AN ITEM IN THE LIST     #
	#-----------------------------------------------------#
	
	def NumberOfOccurrenceCS(pItem, pCaseSensitive)
		if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
			pItem = pItem[2]
		ok

		oListInStr = new stzString( This.ToCodeQ().LastNCharsRemoved(2) + ", ]" )

		nResult = len( oListInStr.SplitCS( " " + @@(pItem) + ",", pCaseSensitive) ) - 1
		return nResult


		#< @FunctionAlternativeForms

		def NumberOfOccurrencesCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def CountCS(pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def HowManyCS(pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		def ItemOccursNTimesCS(n, pItem, pCaseSensitive)
			return NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NumberOfOccurenceCS(pItem, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pItem, pCaseSensitive)

		#

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pItem)
		return This.NumberOfOccurrenceCS(pItem, TRUE)

		#< @FucntionAlternativeForms

		def NumberOfOccurrences(pItem)
			return This.NumberOfOccurrence(pItem)

		def Count(pItem)
			return NumberOfOccurrence(pItem)

		def HowMany(pItem)
			return NumberOfOccurrence(pItem)

		def ItemOccursNTimes(n, pItem)
			return NumberOfOccurrence(pItem)

		#>
	
		#< @FunctionMisspelledForm

		def NumberOfOccurence(pItem)
			return This.NumberOfOccurrence(pItem)

		#

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING N (OR MORE) TIMES IN THE LIST  #
	#=========================================================#

	def ItemsOccurringNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) >= n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringAtLeastNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringNTimesCS(n, pCaseSensitive)

			def ItemsOccurringAtLeastNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccuringNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringNTimes(n)
		return This.ItemsOccurringNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def ItemsOccurringNTimesQ(n)
			return This.ItemsOccurringNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimes(n) # On r instead of 2
			return This.ItemsOccurringNTimes(n)

			def ItemsOccuringNTimesQ(n)
				return This.ItemsOccurringNTimesQ(n)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNTimesOrMore(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringNTimesOrMoreQ(n)
				return This.ItemsOccuringNTimesQ(n)

		def ItemsOccurringNTimesAndMore(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringNTimesAndMoreQ(n)
				return This.ItemsOccuringNTimesQ(n)

		def ItemsOccurringAtLeastNTimes(n)
			return This.ItemsOccurringNTimes(n)

			def ItemsOccurringAtLeastNTimesQ(n)
				return This.ItemsOccuringNTimesQ(n)

		#>

	  #-------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING EXACTLY N TIMES IN THE LIST  #
	#-------------------------------------------------------#

	def ItemsOccurringExactlyNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) = n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringExactlyNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringExactlyNTimesCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringExactlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringExactlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringExactlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringExactlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#--

		def ItemsOccurringOnlyNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringOnlyNTimesOrMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesOrMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		def ItemsOccurringOnlyNTimesAndMoreCS(n, pCaseSensitive)
			return This.ItemsOccurringExactlyNTimesCS(n, pCaseSensitive)

			def ItemsOccurringOnlyNTimesAndMoreCSQ(n, pCaseSensitive)
				return This.ItemsOccuringExactlyNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringExactlyNTimes(n)
		return This.ItemsOccurringExactlyNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def ItemsOccurringExactlyNTimesQ(n)
			return This.ItemsOccurringExactlyNTimes(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringExactlyNTimes(n) # On r instead of 2
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccuringExactlyNTimesQ(n)
				return This.ItemsOccurringExactlyNTimesQ(n)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringExactlyNTimesOrMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringExactlyNTimesOrMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringExactlyNTimesAndMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringExactlyNTimesAndMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		#--

		def ItemsOccurringOnlyNTimes(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringOnlyNTimesOrMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesOrMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		def ItemsOccurringOnlyNTimesAndMore(n)
			return This.ItemsOccurringExactlyNTimes(n)

			def ItemsOccurringOnlyNTimesAndMoreQ(n)
				return This.ItemsOccuringExactlyNTimesQ(n)

		#>

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING MORE THAN N TIMES IN THE LIST  #
	#---------------------------------------------------------#

	def ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) > n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNoLessThanNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		def ItemsOccuringNoLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNoLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringMoreThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringMoreThanNTimes(n)
		return This.ItemsOccurringMoreThanNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def ItemsOccurringMoreThanNTimesQ(n)
			return This.ItemsOccurringMoreThanNTimes(n)

		#>

		#< @FunctionAlternativeForm

		def ItemsOccurringNoLessThanNTimes(n)
			return This.ItemsOccurringMoreThanNTimes(n)

			def ItemsOccurringNoLessThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringMoreThanNTimes(n) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimes(n)

			def ItemsOccuringMoreThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		def ItemsOccuringNoLessThanNTimes(n) # One r instead of 2
			return This.ItemsOccurringMoreThanNTimesCS(n)

			def ItemsOccuringNoLessThanNTimesQ(n)
				return This.ItemsOccurringMoreThanNTimesQ(n)

		#>

	  #---------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING LESS THAN N TIMES IN THE LIST  #
	#---------------------------------------------------------#

	def ItemsOccurringLessThanNTimesCS(n, pCaseSensitive) #TODO: Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) < n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringNoMoreThanNTimesCS(n, pCaseSensitive)
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccurringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringLessThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringLessThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		def ItemsOccuringNoMoreThanNTimesCS(n, pCaseSensitive) # One r instead of 2
			return This.ItemsOccurringLessThanNTimesCS(n, pCaseSensitive)

			def ItemsOccuringNoMoreThanNTimesCSQ(n, pCaseSensitive)
				return This.ItemsOccurringLessThanNTimesCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringLessThanNTimes(n)
		return This.ItemsOccurringLessThanNTimesCS(n, TRUE)

		#< @FunctionFluentForm

		def ItemsOccurringLessThanNTimesQ(n)
			return This.ItemsOccurringLessThanNTimes(n)

		#>

		#< @FunctionAlternativeForms

		def ItemsOccurringNoMoreThanNTimes(n)
			return This.ItemsOccurringLessThanNTimesCS(n)

			def ItemsOccurringNoMoreThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		#>

		#< @FunctionMisspelledForms

		def ItemsOccuringLessThanNTimes(n)
			return This.ItemsOccurringLessThanNTimes(n)

			def ItemsOccuringLessThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		def ItemsOccuringNoMoreThanNTimes(n)
			return This.ItemsOccurringLessThanNTimes(n)

			def ItemsOccuringNoMoreThanNTimesQ(n)
				return This.ItemsOccurringLessThanNTimesQ(n)

		#>

	  #-------------------------------------------------------#
	 #  GETTING ITEMS OCCURRING N TIMES OR LESS IN THE LIST  #
	#-------------------------------------------------------#

	def ItemsOccurringNTimesOrLessCS(n, pCaseSensitive) #TODO: Check for performance
		aIndex = This.IndexCS(pCaseSensitive)
		nLen = len(aIndex)

		aResult = []

		for i = 1 to nLen
			if len(aIndex[i][2]) <= n
				aResult + aIndex[i][1]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ItemsOccurringNTimesOrLessCSQ(n, pCaseSensitive)
			return new stzList( This.ItemsOccurringNTimesOrLessCS(n, pCaseSensitive) )

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesOrLessCS(n, pCaseSensitive) # On r instead of 2
			return This.ItemsOccurringNTimesOrLessCS(n, pCaseSensitive)

			def ItemsOccuringNTimesOrLessCSQ(n, pCaseSensitive)
				return This.ItemsOccurringNTimesOrLessCSQ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemsOccurringNTimesOrLess(n)
		return This.ItemsOccurringNTimesOrLessCS(n, TRUE)

		#< @FunctionFluentForm

		def ItemsOccurringNTimesOrLessQ(n)
			return This.ItemsOccurringNTimesOrLess(n)

		#>

		#< @FunctionMisspelledForm

		def ItemsOccuringNTimesOrLess(n) # On r instead of 2
			return This.ItemsOccurringNTimesOrLess(n)

			def ItemsOccuringNTimesOrLessQ(n)
				return This.ItemsOccurringNTimesOrLessQ(n)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF EACH ITEM CONTAINED IN THE LIST  #
	#==============================================================#

	def FindItemsCS(pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "Ab", "Im", "Ab", "Cf", "Fd", "Ab", "Cf" ])

		? @@( o1.FindItems() ) # Or PositionsOfEachItem()

		#--> [
		#	[ "Ab", [ 1, 3, 6 ] ],
		#	[ "Im", [ 2 ] ],
		#	[ "Cf", [ 4, 7 ] ],
		#	[ "Fd", [ 5 ] ]
		# ]

		*/

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aList = @aContent

		if pCaseSensitive = FALSE
			aList = This.Lowercased()
		ok

		nLenList = len(aList)

		# Early cheks

		if nLenList = 0
			return []
		ok

		acListStringified = []
		for i = 1 to nLenList
			acListStringified + @@(aList[i])
		next

		aResult = []
		acSeen = []
		for i = 1 to nLenList
			if ring_find(acSeen, acListStringified[i])
				loop
			ok

			anPos = []

			for j = 1 to nLenList
				if acListStringified[i] = acListStringified[j]
					anPos + j
				ok
			next

			aResult + [ aList[i], anPos ]
			acSeen + acListStringified[i]
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindItemsCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def ItemsCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def FindEachItemCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def FindEachItemCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		
		def ItemsAndTheirPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def PositionsOfEachItemCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def EachItemAndItsPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def EachItemCSZ(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def IndexCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		def IndexByPositionsCS(pCaseSensitive)
			return This.FindItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindItems()
		return This.FindItemsCS(TRUE)

		#< @FunctionAlternativeForm

		def FindItemsZ(pCaseSensitive)
			return This.FindItems()

		def ItemsZ()
			return This.FindItems()

		def FindEachItem()
			return This.FindItems()

		def FindEachItemZ()
			return This.FindItems()

		
		def ItemsAndTheirPositions()
			return This.FindItems()

		def PositionsOfEachItem()
			return This.FindItems()

		def EachItemAndItsPositions()
			return This.FindItems()

		def EachItemZ()
			return This.FindItems()

		def Index()
			return This.FindItems()

		def IndexByPositions()
			return This.FindItems()

		#>

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF OCCURRENCES OF EACH ITEM CONTAINED IN THE LIST  #
	#------------------------------------------------------------------------#

	def NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aList = @aContent

		if pCaseSensitive = FALSE
			aList = This.Lowercased()
		ok

		nLenList = len(aList)

		# Early cheks

		if nLenList = 0
			return []
		ok

		# Doing the job

		aItems = This.WithoutDuplicationCS(pCaseSensitive)
		nLenItems = len(aItems)

		aResult = []
	
		for i = 1 to nLenItems
			n = 0
			for j = 1 to nLenList
				if ring_type(aItems[i]) = ring_type(aList[j]) and
				   aItems[i] = aList[j]

					n++
				ok
			next
			aResult + [ aItems[i], n ]
		next
			
		return aResult

		#< @FunctionAlternativeForms

		def ItemsCountCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def NumberOfOccurrenceOfEachItemCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrenceItemsHaveCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrenceEachItemHasCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		#--

		def NumberOfOccurrencesOfItemsCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def NumberOfOccurrencesOfEachItemsCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrencesItemsHaveCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		def HowManyOccurrencesEachItemHasCS(pCaseSensitive)
			return This.NumberOfOccurrenceOfItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceOfItems()
		return This.NumberOfOccurrenceOfItemsCS(TRUE)

		#< @FunctionAlternativeForms

		def ItemsCount()
			return This.NumberOfOccurrenceOfItems()

		def NumberOfOccurrenceOfEachItem()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrenceItemsHave(paseSensitive)
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrenceEachItemHas()
			return This.NumberOfOccurrenceOfItems()

		#--

		def NumberOfOccurrencesOfItems()
			return This.NumberOfOccurrenceOfItems()

		def NumberOfOccurrencesOfEachItems()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrencesItemsHave()
			return This.NumberOfOccurrenceOfItems()

		def HowManyOccurrencesEachItemHas()
			return This.NumberOfOccurrenceOfItems()

		#>

	   #=============================================================#
	  #  FINING NEAREST OCCURRENCE OF AN ITEM TO A GIVEN POSITION,  #
	 #  SECTION, OR GIVEN OTHER ITEM                               #
	#=============================================================#

	#TODO
	# Add FindNNearest(n, pItem, pToPositionSectionOrItem, pCaseSensitive)

	def FindNearestCS(pItem, pToPositionSectionOrItem, pCaseSensitive)

		oParam = Q(pToPositionSectionOrItem)
		if oParam.IsToNamedParam()
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToPositionNamedParam()
			return This.FindNearestToPositionCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToPositionsNamedParam()
			return This.FindNearestToPositionsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToSectionNamedParam()

			n1 = pToPositionSectionOrItem[2][1]
			n2 = pToPositionSectionOrItem[2][2]

			return This.FindNearestToSectionCS(pItem, n1, n2, pCaseSensitive)

		but oParam.IsToSectionsNamedParam()
			return This.FindNearestToSectionsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToItemNamedParam()
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		but oParam.IsToItemsNamedParam()
			return This.FindNearestToItemsCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		else
			return This.FindNearestToItemCS(pItem, pToPositionSectionOrItem[2], pCaseSensitive)

		ok

	#-- WITHOUT CASESENSITIVITY

	def FindNearest(pItem, pToPositionSectionOrItem)
		return This.FindNearestCS(pItem, pToPositionSectionOrItem, TRUE)

	  #-----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN POSITION  #
	#=================================================================#

	def FindNearestToPositionCS(pItem, pnPos, pCaseSensitive)
		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(pnPos)
				if pnPos = :FirstItem
					pnPos = 1
				but pnPos = :LastItem
					pnPos = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok

		ok

		if NOT pnPos > 0 and pnPos < This.NumberOfItems()
			StzRaise("Index out of range!")
		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		anDiff = []
		for i = 1 to nLenPos
			anDiff + Abs(pnPos - anPos[i])
		next

		nResult = anPos[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPosition(pItem, pnPos)
		return This.FindNearestToPositionCS(pItem, pnPos, TRUE)
	
	  #------------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCES OF AN ITEM TO A GIVEN POSITION -- XT  #
	#------------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToPositionCSXT(pItem, pnPos, pCaseSensitive)
		if CheckParams()
			if NOT isNumber(pnPos)
				StzRaise("Incorrect param type! pnPos must be a number.")
			ok
		ok

		if pnPos < 1 ans pnPos > This.NumberOfItems()
			StzRaise("Index out of range! pnPost must be inside the list.")
		ok

		anResult = This.FindNearestToSectionCSXT(pItem, pnPos, pnPos, pCaseSensitive)

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositionXT(pItem, pnPos)
		return This.FindNearestToPositionCSXT(pItem, pnPos, TRUE)

	  #----------------------------------------------------------------#
	 #  FINDING NEAREST OCCURRENCE OF AN ITEM TO THE GIVEN POSITIONS  #
	#----------------------------------------------------------------#

	def FindNearestToPositionsCS(pItem, panPos, pCaseSensitive)
	
		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckParams()

			if NOT (isList(panPos) and @IsListOfNumbers(panPos))
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok

		nLenPos = len(panPos)
		if nLenPos = 0
			return 0
		ok

		anNearest = []
		anDiff = []

		for i = 1 to nLenPos
			anTemp = This.FindNearestToPositionCSXT(pItem, panPos[i], pCaseSensitive)
			nDiff1 = panPos[i] - anTemp[1]
			nDiff2 = anTemp[2] - panPos[i]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNearestToPositions(pItem, panPos)
		return This.FindNearestToPositionsCS(pItem, panPos, TRUE)

	  #----------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN SECTION  #
	#================================================================#

	def FindNearestToSectionCS(pItem, n1, n2, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(n1)
				if n1 = :FirstItem
					n1 = 1

				but n1 = :LastItem
					n1 = nLenList
				ok
			ok
			if isString(n2)
				if n2 = :LastItem
					n2 = nLenList

				but n2 = :FirstItem
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenList) and (n2 > 0 and n2 < nLenList) )
			StzRaise("Index out of range! n1 and n2 must be both inside the list.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pItem, n1, pCaseSensitive)
		nDistBefore = n1 - nNearestBefore

		nNearestAfter  = This.SectionQ(n2, nLenList).
				 FindNearestToPositionCS(pItem, 1, pCaseSensitive) + n2 - 1

		nDistAfter = nNearestAfter - n2
		
		if nDistBefore < nDistAfter
			nResult = nNearestBefore
		else
			nResult = nNearestAfter
		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSection(pItem, n1, n2)
		return This.FindNearestToSectionCS(pItem, n1, n2, TRUE)

	  #---------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN SECTION -- XT #
	#---------------------------------------------------------------------#
	# XT --> Returns both nearest positions, before and after

	def FindNearestToSectionCSXT(pItem, n1, n2, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckParams()

			if isString(n1)
				if n1 = :FirstItem
					n1 = 1

				but n1 = :LastItem
					n1 = nLenList
				ok
			ok
			if isString(n2)
				if n2 = :LastItem
					n2 = nLenList

				but n2 = :FirstItem
					n2 = 1
				ok
			ok
	
			if NOT ( isNumber(n1) and isNumber(n2) )
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		if NOT ( (n1 > 0 and n1 < nLenList) and (n2 > 0 and n2 < nLenList) )
			StzRaise("Index out of range! n1 and n2 must be both inside the list.")
		ok

		nNearestBefore = This.SectionQ(1, n1).
				 FindNearestToPositionCS(pItem, n1, pCaseSensitive)

		nNearestAfter  = This.SectionQ(n2, nLenList).
				 FindNearestToPositionCS(pItem, 1, pCaseSensitive) + n2 - 1

		anResult = [ nNearestBefore, nNearestAfter ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSectionXT(pItem, n1, n2)
		return This.FindNearestToSectionCSXT(pItem, n1, n2, TRUE)

	  #-------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO THE SECTIONS  #
	#-------------------------------------------------------------#

	def FindNearestToSectionsCS(pItem, paSections, pCaseSensitive)

		nLenList = This.NumberOfItems()

		if EarlyCheck()
			if nLenList = 0
				return 0
			ok
		ok

		if CheckParams()

			if NOT ( isList(paSections) and @IsListOfPairsOfNumbers(paSections) )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok

		ok

		nLenSections = len(paSections)
		anNearest = []
		anDiff = []

		for i = 1 to nLenSections
			anTemp = This.FindNearestToSectionCSXT(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nDiff1 = paSections[i][1] - anTemp[1]
			nDiff2 = anTemp[2] - paSections[i][2]

			if nDiff1 < nDiff2
				anNearest + anTemp[1]
				anDiff + nDiff1
	
			else
				anNearest + anTemp[2]
				anDiff + nDiff2
			ok
		next

		nResult = anNearest[ ring_find(anDiff, Min(anDiff)) ]
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToSections(pItem, paSections)
		return This.FindNearestToSectionsCS(pItem, paSections, TRUE)

	  #-------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO A GIVEN OTHER ITEM  #
	#===================================================================#

	def FindNearestToItemCS(pItem, pcOtherItem, pCaseSensitive)

		anPos = This.FindAllCS(pcOtherItem, pCaseSensitive)

		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		nResult = This.FindNearestToPositionsCS(pItem, anPos, pCaseSensitive)

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToItem(pItem, pcOtherSubStr)
		return This.FindNearestToItemCS(pItem, pcOtherSubStr, TRUE)

	  #------------------------------------------------------------------#
	 #  FINDING THE NEAREST OCCURRENCE OF AN ITEM TO GIVEN OTHER ITEMS  #
	#------------------------------------------------------------------#

	def FindNearestToItemsCS(pItem, pacOtherItems, pCaseSensitive)

		anPos = This.FindManyCS(pacOtherItems, pCaseSensitive)

		nLenPos = len(anPos)
		if nLenPos = 0
			return 0
		ok

		nResult = This.FindNearestToPositionsCS(pItem, anPos, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNearestToItems(pItem, pacOtherItems)
		return This.FindNearestToItemsCS(pItem, pcOtherSubStr, TRUE)

	  #==================================================#
	 #  CHECKING IF AN ITEM IS DUPPLICATED IN THE LIST  #
	#==================================================#

	def ItemIsDuplicatedCS(pItem, pCaseSensitive)

		nFirstPos = This.FindFirstCS(pItem, pCaseSensitive)

		nFindBefore = This.FindPreviousCS(pItem, :StartingAt = nFirstPos, pCaseSensitive)
		if nFindBefore != 0
			return TRUE
		ok

		nFindAfter = This.FindNext(pItem, :StartingAt = nFirstPos, pCaseSensitive)
		if nFindAfter != 0
			return TRUE
		ok

		return FALSE

		#< @FunctionAlternativeForms

		def ItemIsDuplicateCS(pItem, pCaseSensitive)
			return This.IsDuplicatedCS(pItem, pCaseSensitive)

		def ItemIsADuplicateCS(pItem, pCaseSensitive)
			return This.IsDuplicatedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ItemIsDuplicated(pItem)
		return This.ItemIsDuplicatedCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ItemIsDuplicate(pItem)
			return This.IsDuplicated(pItem)

		def ItemIsADuplicate(pItem)
			return This.IsDuplicated(pItem)

		#>

	  #-----------------------------------------------------#
	 #  CHECKING IF MANY ITEMS ARE DUPLICATED IN THE LIST  #
	#-----------------------------------------------------#

	def ItemsAreDuplicatedCS(paItems, pCaseSensitive)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = len(paItems)
		bResult = TRUE

		for i = 1 to nLen
			if NOT This.ItemIsDuplicatedCS(pItem, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def ItemsAreDuplicatesCS(paItems, pCaseSensitive)
			return This.ItemsAreDuplicatedCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ItemsAreDuplicated(paItems)
		return This.ItemsAreDuplicatedCS(paItems, TRUE)
		
		def ItemsAreDuplicates(paItems)
			return This.ItemsAreDuplicated(paItems)

	  #----------------------------------------------------#
	 #   CHECKING IF THE LIST CONTAINS DUPLICATED ITEMS   #
	#----------------------------------------------------#

	#WARNING: As implemented currently, duplication is performed
	# in a reasonable performance when the size of the list does
	# not exceed 30K items!

	def ContainsDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)


		if pCaseSensitive = TRUE

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next

		ok

		# Checking if an item is a duplicate

		bResult = FALSE
		acSeen = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
			else
				bResult = TRUE
				exit
			ok

		next

		return bResult
			
		#< @FunctionAlternativeForms

		def ContainsDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		def ContainsDuplicationsCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		def ContainsDuplicationCS(pCaseSensitive)
			return This.ContainsDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicates()
		return This.ContainsDuplicatesCS(TRUE)

		#< @FunctionAlternativeForms

		def ContainsDuplicatedItems()
			return This.ContainsDuplicates()

		def ContainsDuplications()
			return This.ContainsDuplicates()

		def ContainsDuplication()
			return This.ContainsDuplicates()

		#>

	  #-----------------------------------------------------#
	 #   CHECHKING IF A GIVEN ITEM IS DUPLICATED N-TIMES   #
	#-----------------------------------------------------#

	def ItemIsDuplicatedNTimesCS(n, pItem, pCaseSensitive)
		if This.NumberOfDuplicatesOfItemCS(pItem, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ItemIsDuplicatedNTimes(n, pItem)
		return This.ItemIsDuplicatedNTimesCS(n, pItem, TRUE)

	  #----------------------------------------------------#
	 #  CHECKING IF ALL ITEMS IN THE LIST ARE DUPLICATED  #
	#----------------------------------------------------#

	def AllItemsAreDuplicatedCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)


		if pCaseSensitive = TRUE

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])			
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next

		ok

		# Checking if an item is a duplicate

		bResult = TRUE
		acSeen = []
		acNonDuplicated = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
				acNonDuplicated + acStr[i]
			else
				nPos = ring_find( acNonDuplicated, acStr[i] )
				if nPos > 0
					ring_del(acNonDuplicated, nPos)
				ok
	
			ok

		next

		if len(acNonDuplicated) > 0
			bResult = FALSE
		ok

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def AllItemsAreDuplicated()
		return This.AllItemsAreDuplicatedCS(TRUE)

	  #-------------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS A SET (CONTAINS NO DUPLICATIONS AT ALL)  #
	#===================================================================#

	def ContainsNoDuplicatesCS(pCaseSensitive) # Alternative of IsSet()

		# Checking params

		if CheckParams()

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
	
			if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
				StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
			ok

		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if EarlyCheck()
			if nLen = 0
				return FALSE
			ok
		ok

		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next

		ok

		# Checking if an item is a duplicate

		bResult = TRUE
		acSeen = []
		acNonDuplicated = []

		for i = 1 to nLen

			n = ring_find( acSeen, acStr[i] )
			if n = 0
				acSeen + acStr[i]
				acNonDuplicated + acStr[i]
			else
				nPos = ring_find( acNonDuplicated, acStr[i] )
				if nPos > 0
					bResult = FALSE
					exit
				ok
	
			ok

		next

		return bResult

		#< @FunctionAlterativeForms

		def ContainsNoDuplicatesAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicatedItemsAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationsAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def ContainsNoDuplicationAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatedCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatesCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatedAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def NoItemsAreDuplicatesAtAllCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def IsSetCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		def IsASetCS(pCaseSensitive)
			return This.ContainsNoDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNoDuplicates()
		return This.ContainsNoDuplicatesCS(TRUE)

		#< @FunctionAlterativeForms

		def ContainsNoDuplicatesAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicatedItems()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicatedItemsAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplications()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicationsAtAll()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplication()
			return This.ContainsNoDuplicates()

		def ContainsNoDuplicationAtAll()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicated()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicates()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicatedAtAll()
			return This.ContainsNoDuplicates()

		def NoItemsAreDuplicatesAtAll()
			return This.ContainsNoDuplicates()

		def IsSet()
			return This.ContainsNoDuplicates()

		def IsASet()
			return This.ContainsNoDuplicates()

		#>

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)
		nResult = len( This.FindDuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForm

		def NumberOfDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def NumberOfDuplicationsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def NumberOfDuplicationCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#--

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicatedItemCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicationsCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicationCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManuDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(TRUE)

		#< @FunctionAlternativeForm

		def NumberOfDuplicatedItems()
			return This.NumberOfDuplicates()

		def NumberOfDuplications()
			return This.NumberOfDuplicates()

		def NumberOfDuplication()
			return This.NumberOfDuplicates()

		#--

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		def HowManyDuplicatedItems()
			return This.NumberOfDuplicates()

		def HowManyDuplicatedItem()
			return This.NumberOfDuplicates()

		def HowManyDuplications()
			return This.NumberOfDuplicates()

		def HowManyDuplication()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		def HowManuDuplicate()
			return This.NumberOfDuplicates()

		#>

	  #------------------------------------------#
	 #  GETTING DUPLICATES AND THEIR POSITIONS  #
	#------------------------------------------#

	def DuplicatesCSZ(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can use them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
			
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding duplicates positions

		acSeen = [ acStr[1] ]
		anPos = [ [] ]

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anPos + [ i ]
			else
				anPos[ n ] + i
			ok

		next

		# Composing the association of items and their positions

		aResult = []
		nLen = len(acSeen)

		for i = 1 to nLen
			del(anPos[i], 1)
			if len(anPos[i]) > 0
				aResult + [ aContent[anPos[i][1]], anPos[i] ]
			ok
		next
		

		return aResult


		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicatedItemsAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicatedItemsCSZ(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsAndTheirPositionsCS(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsCSZ(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesZ()
		return This.DuplicatesCSZ(TRUE)

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicatedItemsAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicatedItemsZ()
			return This.DuplicatesZ()

		def DuplicationsAndTheirPositions()
			return This.DuplicatesZ()

		def DuplicationsZ()
			return This.DuplicatesZ()

		#>

	  #----------------------------------#
	 #   FINDING DUPLICATES POSITIONS   #
	#----------------------------------#
	#NOTE 1 : The first occurrence of an item is not considered as a duplicate
	# 	   --> If you want to get also the first occurrence then you can
	# 		use FindDuplicatesXT() #TODO

	#NOTE 2 : We use a part of the code of DuplicatesZ(). There is a duplication
	# but this is better for performance then calling DuplicatesZ(), because it
	# performs extra work not needed here!

	def FindDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]

			else
				anPos + i
			ok

		next

		return anPos

		#< @FunctionAlternativeForms

		def FindDuplicationsCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		def FindDuplicationCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		def FindDuplicatedItemsCS(pCaseSensitive)
			return This.FindDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(TRUE)

		#< @FunctionAlternativeForms

		def FindDuplications()
			return This.FindDuplicates()

		def FindDuplication()
			return This.FindDuplicates()

		def FindDuplicatedItems()
			return This.FindDuplicates()

		#>

	  #------------------------------------------------------#
	 #  GETTING DUPLICATES AND THEIR POSITIONS -- EXTENDED  #
	#------------------------------------------------------#
	# Positions of first duplicates are also returned

	def DuplicatesCSXTZ(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anSeen = []

		anPos = []
		aResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
				aResult + [ aContent[i], [i] ]
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
				ok
				anPos + i

				aResult[n][2] + i
				
			ok

		next

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicatedItemsAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicatedItemsCSXTZ(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		def DuplicationsAndTheirPositionsCSXT(pCaseSensitive)
			return This.DuplicatesCSZ(pCaseSensitive)

		def DuplicationsCSXTZ(pCaseSensitive)
			return This.DuplicatesCSXTZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesXTZ()
		return This.DuplicatesCSXTZ(TRUE)

		#< @FunctionAlternativeForm

		def DuplicatesAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicatedItemsAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicatedItemsXTZ()
			return This.DuplicatesXTZ()

		def DuplicationsAndTheirPositionsXT()
			return This.DuplicatesXTZ()

		def DuplicationsXTZ()
			return This.DuplicatesXTZ()

		#>

	  #----------------------------------------#
	 #   FINDING DUPLICATES POSITIONS -- XT   #
	#----------------------------------------#
	# FinDuplicates() returns the positions of the duplicated items.
	# Hence, the first occurrences of those items are not returned.
	# To return them, use this eXTended version of the function

	def FindDuplicatesCSXT(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding duplicates positions

		acSeen = []
		anSeen = []

		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
				ok
				anPos + i
			ok

		next

		anPos = ring_sort(anPos)
		return anPos

		#< @FunctionAlternativeForms

		def FindDuplicationsCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		def FindDuplicationCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		def FindDuplicatedItemsCSXT(pCaseSensitive)
			return This.FindDuplicatesCSXT(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesCSXT(TRUE)

		#< @FunctionAlternativeForms

		def FindDuplicationsXT()
			return This.FindDuplicatesXT()

		def FindDuplicationXT()
			return This.FindDuplicatesXT()

		def FindDuplicatedItemsXT()
			return This.FindDuplicatesXT()

		#>

	  #----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF EACH DUPLICATED ITEM  #
	#----------------------------------------------------#

	def FindFirstDuplicatesCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])				
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding first duplicates positions

		acSeen = []
		anSeen = []
		anPos = []

		anResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anSeen + i
			else
				if ring_find(anPos, anSeen[n]) = 0
					anPos + anSeen[n]
					anResult + anSeen[n]
				ok
				anPos + i
			ok

		next

		return anResult

		#< @FunctionAlternativeForms

		def FindFirstDuplicatedItemsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstDuplicationsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicatedItemCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicateCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFirstOccurrenceOfEachDuplicationCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristDuplicatesCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristDuplicatedItemsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristDuplicationsCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicatedItemCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicateCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		def FindFristOccurrenceOfEachDuplicationCS(pCaseSensitive)
			return This.FindFirstDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDuplicates()
		return This.FindFirstDuplicatesCS(TRUE)

		#< @FunctionAlternativeForms

		def FindFirstDuplicatedItems()
			return This.FindFirstDuplicates()

		def FindFirstDuplications()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplicatedItem()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplicate()
			return This.FindFirstDuplicates()

		def FindFirstOccurrenceOfEachDuplication()
			return This.FindFirstDuplicates()

		#>

		#< @FunctionMisspelledForms

		def FindFristDuplicates()
			return This.FindFirstDuplicates()

		def FindFristDuplicatedItems()
			return This.FindFirstDuplicates()

		def FindFristDuplications()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplicatedItem()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplicate()
			return This.FindFirstDuplicates()

		def FindFristOccurrenceOfEachDuplication()
			return This.FindFirstDuplicates()

		#>

	  #----------------------------------#
	 #  GETTING THE LIST OF DUPLICATES  #
	#----------------------------------#

	def DuplicatesCS(pCaseSensitive)
		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return []
		ok

		acSeen = []
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not onlu numbers and strings, but also lists,
		# and get relatively beeter performance on larger lists (up to 30K items)

		if pCaseSensitive = TRUE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next


		ok

		# Finding duplicated items

		acSeen = [ acStr[1] ]
		anPos = [ [] ]

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				anPos + [ i ]
			else
				anPos[ n ] + i
			ok

		next

		# Constructing the list of items that are duplicated in the list

		aResult = []
		nLen = len(acSeen)

		for i = 1 to nLen
			if len(anPos[i]) > 1
				aResult + aContent[anPos[i][1]]
			ok
		next
		

		return aResult

		#< @FunctionFluentForm

		def DuplicatesCSQ(pCaseSensitive)
			return new stzList(This.DuplicatesCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForm

		def DuplicatedItemsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicatedItemsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		def DuplicationsCS(pCaseSensitive)
			return This.DuplicatesCS(pCaseSensitive)

			def DuplicationsCSQ(pCaseSensitive)
				return This.DuplicatesCSQ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(TRUE)

		#< @FunctionFluentForm

		def DuplicatesQ()
			return new stzList(This.Duplicates())

		#>

		#< @FunctionAlternativeForm

		def DuplicatedItems()
			return This.Duplicates()

			def DuplicatedItemsQ()
				return This.DuplicatesQ()

		def Duplications(pCaseSensitive)
			return This.Duplicates(pCaseSensitive)

			def DuplicationsQ(pCaseSensitive)
				return This.DuplicatesQ(pCaseSensitive)

		#>

	  #----------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN ITEM   #
	#----------------------------------------#

	def FindDuplicatesOfItemCS(pItem, pCaseSensitive)
		anPos = This.FindAllCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		anResult = []

		if nLen > 1
			anResult = Q(anPos).FirstItemRemoved()
		ok

		return anResult
		
		#< @FunctionAlternativeForms

		def FindDuplicatesOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		#--

		def PositionsOfDuplicatesOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def PositionsOfDuplicatesOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		#--

		def FindDuplicationsOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationsOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationOfItemCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		def FindDuplicationOfCS(pItem, pCaseSensitive)
			return This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfItem(pItem)
		return This.FindDuplicatesOfItemCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindDuplicatesOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#--

		def PositionsOfDuplicatesOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def PositionsOfDuplicatesOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#--

		def FindDuplicationsOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationsOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationOfItem(pItem)
			return This.FindDuplicatesOfItem(pItem)

		def FindDuplicationOf(pItem)
			return This.FindDuplicatesOfItem(pItem)

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOR DUPLICTAED  #
	#===============================================================#

	def ContainsNonDuplicatedItemsCS(pCaseSensitive)
		
		anPos = This.FindDuplicatesCSXT(pCaseSensitive)
		nLenPos = len(anPos)

		nLen = This.NumberOfItems()

		if NOT Q(anPos).IsEqualTo(1:nLen)
			return TRUE
		else
			return FALSE
		ok

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsNoDupplicationCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsNoDupplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsThatAreNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsItemsNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneNonDuplicatedItemsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemThatIsNonDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneItemThatIsNotDuplicatedCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		def ContainsAtLeastOneNonDuplicatedItemCS(pCaseSensitive)
			return This.ContainsNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedItems()
		return This.ContainsItemsThatAreNotDuplicatedCS(TRUE)

		#< @FunctionAlternativeForms

		def ContainsNoDupplication()
			return This.ContainsNonDuplicatedItems()

		def ContainsNoDupplications()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsThatAreNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsItemsNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneNonDuplicatedItems()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemThatIsNonDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneItemThatIsNotDuplicated()
			return This.ContainsNonDuplicatedItems()

		def ContainsAtLeastOneNonDuplicatedItem()
			return This.ContainsNonDuplicatedItems()

		#>

	  #--------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED ITEMS  #
	#--------------------------------------------#

	def NonDuplicatedItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok

		
		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not only numbers and strings, but also lists,
		# and get relatively better performance on larger lists (up to 30K items)


		if pCaseSensitive = TRUE

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next

		ok

		# Doing the job

		acSeen = []
		acResult = []
		anPos = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				acResult + acStr[i]
				anPos + i

			else
				nPos = ring_find(acResult, acStr[i])

				if nPos > 0
					ring_del(acResult, nPos)
					ring_del(anPos, nPos)
				ok

			ok

		next

		aResult = []
		nLen = len(anPos)

		for i = 1 to nLen
			aResult + aContent[anPos[i]]
		next

		return aResult


		#< @FunctionAlternativeForms

		def NonDuplicatesCS(pCaseSensitive)
			return This.NonDuplicatedItemsCS(pCaseSensitive)

		def UnduplicatedItemsCS(pCaseSensitive)
			return This.NonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedItems()
		return This.NonDuplicatedItemsCS(TRUE)

		#< @FunctionAlternativeForms

		def NonDuplicates()
			return This.NonDuplicatedItems()

		def UnduplicatedItems()
			return This.NonDuplicatedItems()

		#>

	  #----------------------------------#
	 #  NUMBER OF NON DUPLICATED ITEMS  #
	#----------------------------------#

	def NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		nResult = len(This.NonDuplicatedItemsCS(pCaseSensitive))
		return nResult

		#< @FunctionAlternativeForms

		def NumberOfNonDuplicatesCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def NumberOfUnduplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyNonDuplicatedItemCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyNonDuplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyNonDuplicatesCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyNonDuplicateCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#--

		def HowManyUnduplicatedItemsCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		def HowManyUnduplicatedItemCS(pCaseSensitive)
			return This.NumberOfNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedItems()
		return This.NumberOfNonDuplicatedItemsCS(TRUE)

		#< @FunctionAlternativeForms

		def NumberOfNonDuplicates()
			return This.NumberOfNonDuplicatedItems()

		def NumberOfUnduplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyNonDuplicatedItem()
			return This.NumberOfNonDuplicatedItems()

		def HowManyNonDuplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyNonDuplicates()
			return This.NumberOfNonDuplicatedItems()

		def HowManyNonDuplicate()
			return This.NumberOfNonDuplicatedItems()

		#--

		def HowManyUnduplicatedItems()
			return This.NumberOfNonDuplicatedItems()

		def HowManyUnduplicatedItem()
			return This.NumberOfNonDuplicatedItems()

		#>

	  #--------------------------------#
	 #  FINDING NON DUPLICATED ITEMS  #
	#--------------------------------#

	def FindNonDuplicatedItemsCS(pCaseSensitive)

		# Checking params

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT ( pCaseSensitive = TRUE or pCaseSensitive = FALSE )
			StzRais("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		if nLen = 0
			return FALSE
		ok


		acStr = []

		# We duplicate the code because we need to manage casesensitivty
		# while relying on the performant native ring_find()

		# We start by stringifying the list (casting all the items in to strings)
		# so we can find not only numbers and strings, but also lists,
		# and get relatively better performance on larger lists (up to 30K items)


		if pCaseSensitive = TRUE

			for i = 1 to nLen

				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])

				ok

				# Memorising the stringified items so we can used them later
	
				acStr + cItem
			next

		else // pCaseSensitive = FALSE

			for i = 1 to nLen
	
				# Stringifying the item
	
				if isNumber(aContent[i])
					cItem = ""+ aContent[i]
	
				but isString(aContent[i])
					cItem = @@(aContent[i])
	
				but isList(aContent[i])
					cItem = @@(aContent[i])
					
				but isObject(aContent[i])
					cItem = @ObjectVarName(aContent[i])
					
				ok
	
				# Memorising the stringified items so we can used them later
	
				acStr + Q(cItem).Lowercased()
			next

		ok

		# Doing the job

		acSeen = []
		acResult = []
		anResult = []

		for i = 1 to nLen

			n = ring_find(acSeen, acStr[i])

			if n = 0
				acSeen + acStr[i]
				acResult + acStr[i]
				anResult + i

			else
				nPos = ring_find(acResult, acStr[i])

				if nPos > 0
					ring_del(acResult, nPos)
					ring_del(anResult, nPos)
				ok

			ok

		next

		return anResult

		#< @FunctionAlternativeForms

		def FindUndiplicatedItemsCS(pCaseSensitive)
			return This.FindNonDuplicatedItemsCS(pCaseSensitive)

		def FindNonDuplicatesCS(pCaseSensitive)
			return This.FindNonDuplicatedItemsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedItems()
		return This.FindNonDuplicatedItemsCS(TRUE)

		#< @FunctionAlternativeForms

		def FindUndiplicatedItems()
			return This.FindNonDuplicatedItems()

		def FindNonDuplicates()
			return This.FindNonDuplicatedItems()

		#>

	  #--------------------------------------------#
	 #  NON DUPLICATED ITEMS AND THEIR POSITIONS  #
	#--------------------------------------------#

	def NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		aNonDuplicated = This.NonDuplicatedItemsCS(pCaseSensitive)
		nLen = len(aNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated item appears once
			nPos = This.FindFirstCS(aNonDuplicated[i], pCaseSensitive)
			aResult + [ aNonDuplicated[i], nPos ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def UndiplicatedItemsAndTheirPositionsCS(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def UndiplicatedItemsCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def NonDuplicatesAndTheirPositionsCS(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		def NonDuplicatesCSZ(pCaseSensitive)
			return This.NonDuplicatedItemsAndTheirPositionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedItemsAndTheirPositions()
		return This.NonDuplicatedItemsAndTheirPositionsCS(TRUE)

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		def UndiplicatedItemsAndTheirPositions()
			return This.NonDuplicatedItemsAndTheirPositions()

		def UndiplicatedItemsZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		def NonDuplicatesAndTheirPositions()
			return This.NonDuplicatedItemsAndTheirPositions()

		def NonDuplicatesZ()
			return This.NonDuplicatedItemsAndTheirPositions()

		#>

	  #-----------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE LIST   #
	#=========================================#

	def RemoveDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatedItemsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicatedItemsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDuplicationsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicationsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDuplicationCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDuplicationCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def RemoveDupplicatesCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicatesCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicatedItemsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicatedItemsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicationsCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicationsCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		def RemoveDupplicationCS(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)

			def RemoveDupplicationCSQ(pCaseSensitive)
				return This.RemoveDuplicatesCSQ(pCaseSensitive)

		#>

	def DuplicatesRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ToSetCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ToSetOfItemsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def UniqueItemsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ItemsCSU(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def ItemsWithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicatedItemsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicationsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DuplicationRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#--

		def WithoutDuplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDuplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForms # double p instead of one p #TODO: Generalize it

		def ItemsWithoutDupplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicatedItemsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicationsRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def DupplicationRemovedCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#--

		def WithoutDupplicatesCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDupplicationCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		def WithoutDupplicationsCS(pCaseSensitive)
			return This.DuplicatesRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(TRUE)

		#< @FunctionAlternativeForms

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

		def RemoveDuplicatedItems()
			This.RemoveDuplicates()

			def RemoveDuplicatedItemsQ()
				This.RemoveDuplicatedItems()
				return This

		def RemoveDuplications()
			This.RemoveDuplicates()

			def RemoveDuplicationsQ()
				This.RemoveDuplications()
				return This

		def RemoveDuplication()
			This.RemoveDuplicates()

			def RemoveDuplicationQ()
				This.RemoveDuplications()
				return This

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def RemoveDupplicates()
			This.RemoveDuplicates()

			def RemoveDupplicatesQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplicatedItems()
			This.RemoveDuplicates()

			def RemoveDupplicatedItemsQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplications()
			This.RemoveDuplicates()

			def RemoveDupplicationsQ()
				return This.RemoveDuplicatesQ()

		def RemoveDupplication()
			This.RemoveDuplicates()

			def RemoveDupplicationQ()
				return This.RemoveDuplicatesQ()

		#>

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ToSet()
			return This.DuplicatesRemoved()

			def ToSetQ()
				return new stzList(this.ToSet())

		def ToSetOfItems()
			return This.DuplicatesRemoved()

			def ToSetOfItemsQ()
				return This.ToSetQ()

		def UniqueItems()
			return This.DuplicatesRemoved()

			def UniqueItemsQ()
				return This.ToSetQ()

		def ItemsU()
			return This.DuplicatesRemoved()

			def ItemsUQ()
				return This.ToSetQ()

		def ItemsWithoutDuplication()
			return This.DuplicatesRemoved()

			def ItemsWithoutDuplicationQ()
				return This.ToSetQ()

		def DuplicatedItemsRemoved()
			return This.DuplicatesRemoved()

		def DuplicationsRemoved()
			return This.DuplicatesRemoved()

		def DuplicationRemoved()
			return This.DuplicatesRemoved()

		#--

		def WithoutDuplicates()
			return This.DuplicatesRemoved()

			def WithoutDuplicatesQ()
				return This.ToSetQ()

		def WithoutDuplication()
			return This.DuplicatesRemoved()

			def WithoutDuplicationQ()
				return This.ToSetQ()

		def WithoutDuplications()
			return This.DuplicatesRemoved()

			def WithoutDuplicationsQ()
				return This.ToSetQ()

		#>

		#< @FunctionMisspelledForms # double p instead of one p

		def ItemsWithoutDupplication()
			return This.DuplicatesRemoved()

		def DupplicatedItemsRemoved()
			return This.DuplicatesRemoved()

		def DupplicationsRemoved()
			return This.DuplicatesRemoved()

		def DupplicationRemoved()
			return This.DuplicatesRemoved()

		#--

		def WithoutDupplicates()
			return This.DuplicatesRemoved()

		def WithoutDupplication()
			return This.DuplicatesRemoved()

		def WithoutDupplications()
			return This.DuplicatesRemoved()

		#>

  	  #-----------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN ITEM   #
	#-----------------------------------------#

	def RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
		anPos = This.FindDuplicatesOfItemCS(pItem, pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfItemCSQ(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicatesOfThisItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicatesOfThisItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicationsOfItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationOfItemCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)

			def RemoveDuplicationOfItemCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfItemCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicatesOfCS(pItem, pCaseSensitive)
			if isList(pItem)
				This.RemoveDuplicatesOfItemsCS(pItem, pCaseSensitive)

			else
				This.RemoveDuplicatesOfItemCS(pItem, pCaseSensitive)
			ok

			def RemoveDuplicatesOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationsOfCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)

			def RemoveDuplicationsOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfCS(pItem, pCaseSensitive)
				return This

		def RemoveDuplicationOfCS(pItem, pCaseSensitive)
			This.RemoveDuplicatesOfCS(pItem, pCaseSensitive)

			def RemoveDuplicationOfCSQ(pItem, pCaseSensitive)
				This.RemoveDuplicationsOfCS(pItem, pCaseSensitive)
				return This

		#>

	def DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfItemCSQ(pItem, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationsOfItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationsOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationOfItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def DuplicationOfThisItemRemovedCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		#--

		def WithoutDuplicationOfItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def WithoutDuplicationsOfItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		def WithoutDuplicatingItemCS(pItem, pCaseSensitive)
			return This.DuplicatesOfItemRemovedCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfItem(pItem)
		This.RemoveDuplicatesOfItemCS(pItem, TRUE)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfItemQ(pItem)
			This.RemoveDuplicatesOfItem(pItem)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisItem(pItem)
			This.RemoveDuplicatesOfItem(pItem)

			def RemoveDuplicatesOfThisItemQ(pItem)
				This.RemoveDuplicatesOfThisItem(pItem)
				return This

		def RemoveDuplicationsOfItem(pItem)
			This.RemoveDuplicatesOfItem(pItem)

			def RemoveDuplicationsOfItemQ(pItem)
				This.RemoveDuplicationsOfItem(pItem)
				return This

		def RemoveDuplicatesOf(pItem)
			This.RemoveDuplicatesOfCS(pItem, TRUE)

			def RemoveDuplicatesOfQ(pItem)
				This.RemoveDuplicatesOf(pItem)
				return This

		def RemoveDuplicationsOf(pItem)
			This.RemoveDuplicatesOf(pItem)

			def RemoveDuplicationsOfQ(pItem)
				This.RemoveDuplicationsOf(pItem)
				return This

		def RemoveDuplicationOf(pItem)
			This.RemoveDuplicatesOf(pItem)

			def RemoveDuplicationOfQ(pItem)
				This.RemoveDuplicationsOf(pItem)
				return This

		#>

	def DuplicatesOfItemRemoved(pItem)
		return This.DuplicatesOfItemRemovedCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationsOfItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationsOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationOfItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def DuplicationOfThisItemRemoved(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		#--

		def WithoutDuplicationOfItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def WithoutDuplicationsOfItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		def WithoutDuplicatingItem(pItem)
			return This.DuplicatesOfItemRemoved(pItem)

		#>

	  #---------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN ITEMS   #
	#---------------------------------------------#

	def RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

		if NOT isList(paItems)
			StzRaise("Incorrect param! paItems must be a list.")
		ok

		nLen = len(paItems)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(paItems[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfItemsCSQ(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicatesOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicatesOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfTheseItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfTheseItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfTheseItemsCS(paItems, pCaseSensitive)
				return This

		#--

		def  RemoveDuplicatesOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicatesOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicatesOfManyItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationsOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
				return This

		def  RemoveDuplicationOfManyItemsCS(paItems, pCaseSensitive)
			This.RemoveDuplicatesOfItemsCS(paItems, pCaseSensitive)

			def RemoveDuplicationOfManyItemsCSQ(paItems, pCaseSensitive)
				This.RemoveDuplicationsOfManyItemsCS(paItems, pCaseSensitive)
				return This


		#>
		
	def DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfItemsCSQ(paItems, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationsOfItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationsOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationOfItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def DuplicationOfTheseItemsRemovedCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		#--

		def WithoutDuplicationOfItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def WithoutDuplicationsOfItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		def WithoutDuplicatingItemsCS(paItems, pCaseSensitive)
			return This.DuplicatesOfItemsRemovedCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfItems(paItems)
		This.RemoveDuplicatesOfItemsCS(paItems, TRUE)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfItemsQ(paItems)
			This.RemoveDuplicatesOfItems(paItems)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicatesOfTheseItemsQ(paItems)
				This.RemoveDuplicatesOfTheseItems(paItems)
				return This

		def  RemoveDuplicationsOfItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfItemsQ(paItems)
				This.RemoveDuplicationsOfItems(paItems)
				return This

		def  RemoveDuplicationsOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfTheseItemsQ(paItems)
				This.RemoveDuplicationsOfTheseItems(paItems)
				return This

		def  RemoveDuplicationOfTheseItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationOfTheseItemsQ(paItems)
				This.RemoveDuplicationsOfTheseItems(paItems)
				return This


		#--

		def  RemoveDuplicatesOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicatesOfManyItemsQ(paItems)
				This.RemoveDuplicatesOfManyItems(paItems)
				return This

		def  RemoveDuplicationsOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationsOfManyItemsQ(paItems)
				This.RemoveDuplicationsOfManyItems(paItems)
				return This

		def  RemoveDuplicationOfManyItems(paItems)
			This.RemoveDuplicatesOfItems(paItems)

			def RemoveDuplicationOfManyItemsQ(paItems)
				This.RemoveDuplicationsOfManyItems(paItems)
				return This

		#>

	def DuplicatesOfItemsRemoved(paItems)
		return This.DuplicatesOfItemsRemovedCS(paItems, TRUE)

		#< @FunctionAlternativeForm

		def DuplicatesOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationsOfItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationsOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationOfItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def DuplicationOfTheseItemsRemoved(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		#--

		def WithoutDuplicationOfItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def WithoutDuplicationsOfItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		def WithoutDuplicatingItems(paItems)
			return This.DuplicatesOfItemsRemoved(paItems)

		#>

	  #-----------------------------------------#
	 #   REMOVING NON DUPLICATES IN THE LIST   #
	#=========================================#

	def RemoveNonDuplicatesCS(pCaseSensitive)

		anPos = This.FindNonDuplicatesCS(pCaseSensitive)
		This.RemoveItemsAtPositions(anPos)

		#< @FunctionAlternativeForms

		def RemoveNonDuplicatesCSQ(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)
			return This

		def RemoveNonDuplicatedItemsCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicatedItemsCSQ(pCaseSensitive)
				This.RemoveNonDuplicatedItemsCS(pCaseSensitive)
				return This

		def RemoveNonDuplicationsCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicationsCSQ(pCaseSensitive)
				This.RemoveNonDuplicationsCS(pCaseSensitive)
				return This

		def RemoveNonDuplicationCS(pCaseSensitive)
			This.RemoveNonDuplicatesCS(pCaseSensitive)

			def RemoveNonDuplicationCSQ(pCaseSensitive)
				This.RemoveNonDuplicationCS(pCaseSensitive)
				return This

		#>

	def NonDuplicatesRemovedCS(pCaseSensitive)
		aResult = This.Copy().RemoveNonDuplicatesCSQ(pCaseSensitive).Content()
		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)

		def NonDuplicationsRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)

		def NonDuplicationRemovedCS(pCaseSensitive)
			return This.NonDuplicatesRemovedCS(pCaseSensitive)


		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNonDuplicates()
		This.RemoveNonDuplicatesCS(TRUE)

		#< @FunctionAlternativeForms

		def RemoveNonDuplicatesQ()
			This.RemoveNonDuplicates()
			return This

		def RemoveNonDuplicatedItems()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicatedItemsQ()
				This.RemoveNonDuplicatedItems()
				return This

		def RemoveNonDuplications()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicationsQ()
				This.RemoveNonDuplications()
				return This

		def RemoveNonDuplication()
			This.RemoveNonDuplicates()

			def RemoveNonDuplicationQ()
				This.RemoveNonDuplications()
				return This

		#>

	def NonDuplicatesRemoved()
		aResult = This.Copy().RemoveNonDuplicatesQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def NonDuplicatedItemsRemoved()
			return This.NonDuplicatesRemoved()

		def NonDuplicationsRemoved()
			return This.NonDuplicatesRemoved()

		def NonDuplicationRemoved()
			return This.NonDuplicatesRemoved()


		#>

	  #====================#
	 #     CONTAINMENT    #
	#====================#
	/*
		Review the function namings and make the same semantics
		here and in stzString class.
	*/

	  #----------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS A GIVEN ITEM  #
	#----------------------------------------------#

	def ContainsCS(pItem, pCaseSensitive)

		if This.FindFirstCS(pItem, pCaseSensitive) > 0
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def ContainsItemCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

			def ContainsNoItemCS(pItem, pCaseSensitive)
				return NOT This.ContainsItemCS(pItem, pCaseSensitive)
	
		#>

		#< @FunctionPassiveForm
	
		def ContainsNoCS(pItem, pCaseSensitive)
			return NOT This.ContainsCS(pItem, pCaseSensitive)

		def ContainsNoneOfTheseCS(paItems, pCaseSensitive)
			bResult = TRUE
			nLen = len(paItems)
			for i = 1 to nLen
				if This.ContainsCS(paItems[i], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
			return bRersult

		def ContainsNeitherCS(pItem1, pItem2, pCaseSensitive)
			if isList(pItem2) and Q(pItem2).IsNorNamedParam()
				pItem2 = pItem2[2]
			ok

			return This.ContainsNoneOfTheseCS([pItem1, pItem2], pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

		def ConttainsCS(pItem, pCaseSensitive)
			return This.ContainsCS(pItem, pCaseSensitive)

		#>


	#-- WITHOUT CASESENSITIVITY

	def Contains(pItem)
		return This.ContainsCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def ContainsItem(pItem)
			return This.Contains(pItem)

			def ContainsNoItem(pItem)
				return NOT This.ContainsItem(pItem)
	
		#>

		#< @FunctionPassiveForm
	
		def ContainsNo(pItem)
			return NOT This.Contains(pItem)

		def ContainsNoneOfThese(paItems)
			bResult = TRUE
			nLen = len(paItems)
			for i = 1 to nLen
				if This.Contains(paItems[i])
					bResult = FALSE
					exit
				ok
			next
			return bRersult

		def ContainsNeither(pItem1, pItem2)
			if isList(pItem2) and Q(pItem2).IsNorNamedParam()
				pItem2 = pItem2[2]
			ok

			return This.ContainsNoneOfThese([pItem1, pItem2])

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pItem)
			return This.Contains(pItem)

		def Conttains(pItem)
			return This.ContainsCS(pItem)

		#>

	  #---------------------------#
	 #  CONDITIONAL CONTAINMENT  #
	#===========================#

	def ContainsW(pcCondition)

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		nLen = len(@aContent)

		# Getting the executable section

		oCode = new stzCCode(pcCondition)
		anSection = oCode.ExecutableSection()

		n1 = anSection[1]
		n2 = anSection[2]
		if n2 = :Last
			n2 = nLen
		ok

		# Composing the conditional code

		cCode = 'bOk = (' + oCode.Content() + ')'
		
		# Evaluating the code against the items

		bResult = FALSE

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				bResult = TRUE
				exit
			ok
		next

		# Returning the result

		return bResult

	  #--------------------------------------#
	 #  CONDITIONAL CONTAINMENT -- XTended  #
	#--------------------------------------#

	def ContainsWXT(pcCondition)

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		nLen = len(@aContent)

		# Transpiling the conditional code

		oCode = new stzCCode(pcCondition)
		oCode.Transpile()

		# Getting the executable section

		anSection = oCode.ExecutableSection()
		n1 = anSection[1]
		n2 = anSection[2]
		if n2 = :Last
			n2 = nLen
		ok

		# Composing the conditional code

		cCode = 'bOk = ( ' + oCode.Content() + ' )'

		# Evaluating the code against the list items

		bResult = FALSE

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				bResult = TRUE
				exit
			ok
		next

		# Getting the result

		return bResult

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS CONTAINED IN A GIVEN LIST OR ITEM  #
	#-------------------------------------------------------------#

	def IsContainedInCS(p, pCaseSensitive)

		bResult = FALSE

		switch ring_type(p)
		on "LIST"	
			bResult = Q(p).ContainsManyCS( This.List(), pCaseSensitive )

		on "STRING"
			cListStringified = StzListQ(This.Content()).Stringified()
			bResult = StzStringQ(p).ContainsCS(cListStringified, pCaseSensitive)

		other
			# For now, number and object type are not concerned
			StzRaise("Unsupported type!")
		off

		return bResult

		#< @FunctionAlternativeForm

		def ExistsInCS(p, pCaseSensitive)
			return This.IsContainedInCS(p, pCaseSensitive)

		def IsIncludedInCS(p, pCaseSensitive)
			return This.IsContainedInCS(p, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(p)
		return This.IsContainedInCS(p, TRUE)

		#< @FunctionAlternativeForms

		def ExistsIn(p)
			return This.IsContainedIn(p)

		def IsIncludedIn(p)
			return This.IsContainedIn(p)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS BOTH OF THE PROVIDED ITEM  #
	#-----------------------------------------------------------#

	def ContainsBothCS(pItem1, pItem2, pCaseSensitive)
		if CheckParams()
			if isList(pItem2) and Q(pItem2).IsAndNamedParam()
				pItem2 = pItem[2]
			ok
		ok

		return This.ContainsManyCS([ pItem1, pItem2 ], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pItem1, pItem2)
		return This.ContainsBothCS(pItem1, pItem2, TRUE)

	  #-----------------------------------------------------------#
	 #    CONTAINING ONE GIVEN ITEM OR AN OTHER (BUT NOT BOTH)   #
	#-----------------------------------------------------------#

	def ContainsEitherCS(pItem1, pItem2, pCaseSensitive)
		if isList(pItem2) and Q(pItem2).IsOrNamedParam()
			pItem2 = pItem2[2]
		ok

		#NOTE
		# We can solve it quickly like this:
		# return This.ContainsOnlyOneOfTheseCS([ pItem1, pItem2 ], pCaseSensitive)

		b1 = This.ContainsCS(pItem1, pCaseSensitive)
		b2 = This.ContainsCS(pItem2, pCaseSensitive)

		if (b1 = 1 and b2 = 0) or (b1 = 0 and b2 = 1)
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsEither(pItem1, pItem2)
		return This.ContainsEitherCS(pItem1, pItem2, TRUE)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF EACH ONE OF THE GIVEN ITEMS EXISTS IN THE GIVEN LIST  #
	#--------------------------------------------------------------------#
	
	def EachItemExistsInCS(paOtherList, pCaseSensitive)

		bResult = StzListQ(paOtherList).ContainsEachCS(This.List(), pCaseSensitive)

		return bResult

		#< @FunctionAlternativeForms

		def ItemsExistInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		def AllItemsExistInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsIn(paOtherList, pCaseSensitive)

		def EachExistsInCS(paOtherList, pCaseSensitive)
			return This.EachItemExistsInCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVI

	def EachItemExistsIn(paOtherList)
		return This.EachItemExistsInCS(paOtherList, TRUE)

		#< @FunctionAlternativeForms

		def ItemsExistIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def AllItemsExistIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		def EachExistsIn(paOtherList)
			return This.EachItemExistsIn(paOtherList)

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST IS ONE OF THE ITEMS OF A GIVEN LIST  #
	#------------------------------------------------------------#

	def IsOneOfTheseCS(paOtherList, pCaseSensitive)
		bResult = StzListQ(paOtherList).ContainsCS( This.List(), pCaseSensitive )
		return bResult

		def IsNotOneOfTheseCS(paOtherList, pCaseSensitive)
			return NOT This.IsOneOfTheseCS(paOtherList, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def IsOneOfThese(paOtherList)
		return This.IsOneOfTheseCS(paOtherList, TRUE)

		def IsNotOneOfThese(paOtherList)
			return NOT This.IsOneOfThese(paOtherList)

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS EACH OF THE PROVIDED ITEMS  #
	#------------------------------------------------------------#

	def ContainsManyCS(paItems, pCaseSensitive)
		
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		bResult = TRUE
		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen
			if NOT This.ContainsCS(aContent[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		end

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfCS(paSetOfItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def IsMadeOfTheseCS(paSetOfItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def ContainsTheseCS(paSetOfItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def ContainsEachCS(paSetOfItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def ContainsEachOneOfTheseCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def ContainsAllCS(paItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)

		def ContainsAllTheseCS(paSetOfItems, pCaseSensitive)
			return This.ContainsManyCS(paSetOfItems, pCaseSensitive)


		#>

		#< @FunctionNagationForm

		def ContainsNoOneCS(paItems, pCaseSensitive)
			return NOT This.ContainsEachCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsMany(paSetOfItems)
		return This.ContainsManyCS(paSetOfItems, TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOf(paSetOfItems)
			return This.ContainsMany(paSetOfItems)

		def IsMadeOfThese(paSetOfItems)
			return This.ContainsMany(paSetOfItems)

		def ContainsThese(paSetOfItems)
			return This.ContainsMany(paSetOfItems)

		def ContainsEach()
			return This.ContainsMany(paSetOfItems)

		def ContainsEachOneOfThese(paItems)
			return This.ContainsMany(paSetOfItems)

		def ContainsAll(paItems)
			return This.ContainsMany(paSetOfItems)

		def ContainsAllThese(paSetOfItems)
			return This.ContainsMany(paSetOfItems)

		#>

		#< @FunctionNagationForm

		def ContainsNoOne()
			return NOT This.ContainsEach(paItems)

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS SOME OF THE PROVIDED ITEMS  #
	#------------------------------------------------------------#

	def ContainsSomeCS(paItems, pCaseSensitive)
		bResult = FALSE

		for item in paItems
			if This.ContainsCS(item, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def IsMadeOfSomeCS(paSetOfItems, pCaseSensitive)
			return This.ContainsSomeCS(paSetOfItems, pCaseSensitive)

		def IsMadeOfSomeOfTheseCS(paSetOfItems, pCaseSensitive)
			return This.ContainsSomeCS(paSetOfItems, pCaseSensitive)

		def IsMadeOfOneOrMoreOfTheseCS(paSetOfItems, pCaseSensitive)
			return This.ContainsSomeCS(paSetOfItems, pCaseSensitive)

		def IsMadeOfOneOrMoreOfCS(paSetOfItems, pCaseSensitive)
			return This.ContainsSomeCS(paSetOfItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSome(paSetOfItems)
		return This.ContainsSomeCS(paSetOfItems, TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfSome(paSetOfItems)
			return This.ContainsSome(paSetOfItems)

		def IsMadeOfSomeOfThese(paSetOfItems)
			return This.ContainsSome(paSetOfItems)

		def IsMadeOfOneOrMoreOfThese(paSetOfItems)
			return This.ContainsSome(paSetOfItems)

		def IsMadeOfOneOrMoreOf(paSetOfItems)
			return This.ContainsSome(paSetOfItems)

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONE OF THE PROVIDED ITEMS  #
	#-----------------------------------------------------------#
	
	def ContainsOneOfTheseCS(paItems, pCaseSensitive)
		
		aItems = Q(paItems).WithoutDupplication()
		nLen = len(paItems)

		bResult = FALSE

		for i = 1 to nLen
			if This.ContainsCS( paItems[i],  pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsAnyOneOfTheseCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsAnyOfTheseCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def IsMadeOfOneOfTheseCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def IsMadeOfAnyOfTheseCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsOneCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsOneOfTheCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		def ContainsAnyOfTheCS(pSetOfItems, pCaseSensitive)
			return This.ContainsOneOfTheseCS(pSetOfItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(pSetOfItems)
		return This.ContainsOneOfTheseCS(pSetOfItems, TRUE)

		#< @FunctionAlternativeForms

		def ContainsAny(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsAnyOneOfThese(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsAnyOfThese(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def IsMadeOfOneOfThese(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def IsMadeOfAnyOfThese(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsOne(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsOneOfThe(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		def ContainsAnyOfThe(pSetOfItems)
			return This.ContainsOneOfThese(pSetOfItems)

		#>

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ONE OF THE PROVIDED ITEMS  #
	#----------------------------------------------------------------#

	def ContainsOnlyOneOfTheseCS(paItems, pCaseSensitive)
		if CheckParam()
			if NOT (isList(paItems) and @IsListOfStrings(paItems))
				StzRaise("Incorrect param type! paItems must be a list of strings.")
			ok
		ok

		if EarlyCheck()
			if len(paItems) = 0
				return FALSE
			ok
		ok

		aItems = @WithoutDuplication(paItems)
		nLen = len(aItems)

		anOccurr = []
		
		for i = 1 to nLen
			anOccurr + This.ContainsCS(aItems[i], pCaseSensitive)
		next
		
		nOnes  = Q(anOccurr).HowMany(1)
		nZeros = Q(anOccurr).HowMany(0)

		if nOnes = 1 and nZeros = nLen - 1
			return TRUE
		else
			return FALSE
		ok

	#-- WTIHOUT CASESENSITIVITY

	def ContainsOnlyOneOfThese(paItems)
		return This.ContainsOnlyOneOfTheseCS(paItems, TRUE)

	  #---------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS N OF THE PROVIDED ITEMS  #
	#---------------------------------------------------------#

	def ContainsNCS(n, paItems, pCaseSensitive)
		bResult = FALSE
		m = 0
		for pItem in paItems
			if This.ContainsCS(pItem, pCaseSensitive)
				m++
				if n = m
					bResult = TRUE
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsNOccurrencesOfCS(n, paItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsNOccurrencesCS(n, paItems, pCaseSensitive)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNCS(n, pItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNOccurrencesOfCS(n, paItems, pCaseSensitive)
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		def ContainsExactlyNOccurrencesCS(n, paItems, pCaseSensitive)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsNCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsN(n, paItems)
		return This.ContainsNCS(n, paItems, TRUE)

		#< @FunctionAlternativeForms

		def ContainsNOccurrencesOf(n, paItems)
			return This.ContainsN(n, paItems)

		def ContainsNOccurrences(n, paItems)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsN(n, paItems)

		def ContainsExactlyN(n, pItems)
			return This.ContainsN(n, paItems)

		def ContainsExactlyNOccurrencesOf(n, paItems)
			return This.ContainsN(n, paItems)

		def ContainsExactlyNOccurrences(n, paItems)
			if isList(n) and Q(n).IsOfNamedParam()
				n = n[2]
			ok
			return This.ContainsN(n, paItems)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS MORE THEN N OCCURRENCES OF A GIVEN ITEM  #
	#-------------------------------------------------------------------------#

	def ContainsMoreThenCS(n, pItem, pCaseSensitive)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.NumberOfOccurrenceCS(pItem, pCaseSensitive) > n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVTY

	def ContainsMoreThen(n, pItem)
		return This.ContainsMoreThen(n, pItem)

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS LESS THEN N OCCURRENCES OF A GIVEN ITEM  #
	#-------------------------------------------------------------------------#

	def ContainsLessThenCS(n, pItem, pCaseSensitive)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.NumberOfOccurrenceCS(pItem, pCaseSensitive) < n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVTY

	def ContainsLessThen(n, pItem)
		return This.ContainsLessThen(n, pItem)

	  #--------------------------------------------------#
	 #  CHECKING IF EACH ITEM CONTAINS THE GIVEN VALUE  #
	#--------------------------------------------------#

	def EachContainsCS(pItem, pCaseSensitive)

		/* EXAMPLES

		EXAMPLE 1

		o1 = new stzList([ "eeee", "bbbb", "ccc", "" ])
		? o1.EachContains("")
		#--> TRUE
		
		EXAMPLE 2

		o1 = new stzList([ ["ee","","ee"], ["", "bb"], "ccc", "" ])
		? o1.EachContains("")
		#--> TRUE
		
		EXAMPLE 3

		o1 = new stzList([ "aa" ])
		? o1.EachContains("")
		#--> TRUE
		
		EXAMPLE 4

		o1 = new stzList([ 0, "aa" ])
		? o1.EachContains("")
		#--> FALSE

		*/


		bResult = TRUE

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) or isString(aContent[i]) )
				bResult = FALSE
				exit

			else
				bResult = Q(aContent[i]).ContainsCS(pItem, pCaseSensitive)
				if bResult = FALSE
					exit
				ok
			ok
		next

		return bResult

		#< @FunctionAlternativeForm

		def EachItemContainsCS(pItem, pCaseSensitive)
			return This.EachContainsCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def EachContains(pItem)
		return This.EachContainsCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def EachItemContains(pItem)
			return This.EachContains(pItem)

		#>

	  #---------------------------------------------------#
	 #  CHECKING IF EACH ITEM CONTAINS THE GIVEN STRING  #
	#---------------------------------------------------#

	def EachContainsTheseCS(paItems, pCaseSensitive)

		bResult = TRUE

		aContent = This.Content()
		nLen = len(aContent)

		for i = 1 to nLen

			if NOT ( isList(aContent[i]) or isString(aContent[i]) )
				bResult = FALSE
				exit

			else

				bResult = Q(aContent[i]).ContainsTheseCS(paItems, pCaseSensitive)
				if bResult = FALSE
					exit
				ok
			ok

		next

		return bResult

		#< @FunctionAlternativeForm

		def EachItemContainsTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachItemContainsAllTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachItemContainsAllOfTheseCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		def EachContainsManyCS(paItems, pCaseSensitive)
			return This.EachContainsTheseCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def EachContainsThese(paItems)
		return This.EachContainsTheseCS(paItems, TRUE)

		#< @FunctionAlternativeForm

		def EachItemContainsThese(paItems)
			return This.EachContainsThese(paItems)

		def EachItemContainsAllThese(paItems)
			return This.EachContainsThese(paItems)

		def EachItemContainsAllOfThese(paItems)
			return This.EachContainsThese(paItems)

		def EachContainsMany(paItems)
			return This.EachContainsThese(paItems)

		#>

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS NUMBERS  #
	#=========================================#

	def ContainsNumbers()
		bResult = FALSE

		for item in This.List()
			if isNumber(item)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsNoNumbers()
			return NOT This.ContainsNumbers()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS STRINGS  #
	#-----------------------------------------#

	def ContainsStrings()
		bResult = FALSE

		for item in This.List()
			if isString(item)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsNoStrings()
			return NOT This.ContainsStrings()

	  #---------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS LISTS  #
	#---------------------------------------#

	def ContainsLists()
		bResult = FALSE

		for item in This.List()
			if isList(item)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsNoLists()
			return NOT This.ContainsLists()

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS OBJECTS  #
	#-----------------------------------------#

	def ContainsObjects()
		for item in This.List()
			if isObject(item)
				return TRUE
			ok
		next

	def ContainsNoObjects()
		return NOT This.ContainsObjects()

	def ContainsObjectsAtSomeLevel() // TODO: Review this risky implementation!
		/*
		This solution is build upon the observation that
		list2code() Ring functions generates empty string
		for objects.

		Hence, list2Code([ 1, 2, "C"]) generates '[1,2,"C"]'
		but:
			o1 = new stzString("C")
			? list2code([ 1, 2, o1, "C"]) generates:

			'[1,2,,"C"]'

		As you can see, we can know that an object exists by
		analyzing list2code() for any generated empty string!

		WARNING: if Ring enhances this function to generate the
		name of the object, for example, then the logic used
		here must change accordingly...
		*/

		oCode = StzStringQ( list2code( This.List() ) )

		if oCode[4] = "," or
		   oCode[ oCode.NumberOfChars()-3 ] = "," or
		   oCode.Contains(",,") or
		   oCode.Contains("[,") or
		   oCode.Contains(",]")

			return TRUE
		else
			return FALSE
		ok
	
	def ContainsNoObjectsAtAnyLevel()
		return NOT This.ContainsObjectsAtSomeLevel()

	def ContainsAtAnyLevel(pItem) #TODO
		// TODO

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT STRINGS  #
	#============================================================#

	def ContainsItemsOtherThanStrings()
		if This.ContainsNumbers() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		def ContainsItemsWhichAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		#--

		def IsMadeOfItemsOtherThanStrings()
			return This.ContainsItemsOtherThanStrings()

		def IsMadeOfItemsThatAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		def IsMadeOfItemsWhichAreNotStrings()
			return This.ContainsItemsOtherThanStrings()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT NUMBERS  #
	#------------------------------------------------------------#

	def ContainsItemsOtherThanNumbers()
		if This.ContainsStrings() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def ContainsItemsWhichAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		#--

		def IsMadeOfItemsOtherThanNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def IsMadeOfItemsThatAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		def IsMadeOfItemsWhichAreNotNumbers()
			return This.ContainsItemsOtherThanNumbers()

		#>

	  #----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT LISTS  #
	#----------------------------------------------------------#

	def ContainsItemsOtherThanLists()
		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotLists()
			return This.ContainsItemsOtherThanLists()

		def ContainsItemsWhichAreNotLists()
			return This.ContainsItemsOtherThanLists()

		#--

		def IsMadeOfItemsOtherThanLists()
			return This.ContainsItemsOtherThanLists()

		def IsMadeOfItemsThatAreNotLists()
			return This.ContainsItemsOtherThanLists()

		def IsMadeOfItemsWhichAreNotLists()
			return This.ContainsItemsOtherThanLists()

		#>

	  #------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ITEMS THAT ARE NOT OBJECTS  #
	#------------------------------------------------------------#

	def ContainsItemsOtherThanObjects()
		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsLists()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsItemsThatAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		def ContainsItemsWhichAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		#--

		def IsMadeOfItemsOtherThanObjects()
			return This.ContainsItemsOtherThanObjects()

		def IsMadeOfItemsThatAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		def IsMadeOfItemsWhichAreNotObjects()
			return This.ContainsItemsOtherThanObjects()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT STRINGS  #
	#=================================================================#

	def ContainsOnlyItemsOtherThanStrings()

		if This.ContainsStrings()
			return FALSE
		ok

		if This.ContainsNumbers() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def ContainsOnlyItemsWhichAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		#--

		def IsMadeOfOnlyItemsOtherThanStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfOnlyItemsThatAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfOnlyItemsWhichAreNotStrings()
			return This.ContainsOnlyItemsOtherThanStrings()

		#==

		def ContainsItemsThatAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def ContainsItemsWhichAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		#--

		def ContainsItemsOtherThanStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsOtherThanStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsThatAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		def IsMadeOfItemsWhichAreNotStringsOnly()
			return This.ContainsOnlyItemsOtherThanStrings()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT NUMBERS  #
	#-----------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanNumbers()

		if This.ContainsNumbers()
			return FALSE
		ok

		if This.ContainsStrings() or
		   This.ContainsLists() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def ContainsOnlyItemsWhichAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#--

		def IsMadeOfOnlyItemsOtherThanNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfOnlyItemsThatAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfOnlyItemsWhichAreNotNumbers()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#==

		def ContainsItemsThatAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def ContainsItemsWhichAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def ContainsItemsOtherThanNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsOtherThanNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsThatAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		def IsMadeOfItemsWhichAreNotNumbersOnly()
			return This.ContainsOnlyItemsOtherThanNumbers()

		#>

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT LISTS  #
	#---------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanLists()

		if This.ContainsLists()
			return FALSE
		ok

		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsObjects()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def ContainsOnlyItemsWhichAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		#--

		def IsMadeOfOnlyItemsOtherThanLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfOnlyItemsThatAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfOnlyItemsWhichAreNotLists()
			return This.ContainsOnlyItemsOtherThanLists()

		#==

		def ContainsItemsThatAreNotlistsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def ContainsItemsWhichAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		#--

		def ContainsItemsOtherThanListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsOtherThanListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsThatAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		def IsMadeOfItemsWhichAreNotListsOnly()
			return This.ContainsOnlyItemsOtherThanLists()

		#>

	  #-----------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS ONLY ITEMS THAT ARE NOT OBJECTS  #
	#-----------------------------------------------------------------#

	def ContainsOnlyItemsOtherThanObjects()
		if This.ContainsObjects()
			return FALSE
		ok

		if This.ContainsNumbers() or
		   This.ContainsStrings() or
		   This.ContainsLists()

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ContainsOnlyItemsThatAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def ContainsOnlyItemsWhichAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def IsMadeOfOnlyItemsOtherThanObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfOnlyItemsThatAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfOnlyItemsWhichAreNotObjects()
			return This.ContainsOnlyItemsOtherThanObjects()

		#==

		def ContainsItemsThatAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def ContainsItemsWhichAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#--

		def ContainsItemsOtherThanObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsOtherThanObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsThatAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		def IsMadeOfItemsWhichAreNotObjectsOnly()
			return This.ContainsOnlyItemsOtherThanObjects()

		#>

	  #======================#
	 #    LIST STRUCTURE    #
	#======================#

	/*
	TODO:

	- Reveiew this section (its functions and its semantics)
	- Avoid using _ in names of functions

	- Merge with the next sections:
		LEVELS OF THE LIST, and
		SUBLISTS OF THE LIST --> LISTS IN LEVEL 1 OF THE LIST

	- Ensure they are all consistent and correct

	*/

	def ContainsOneOrMoreLists()
		if This.WalkUntilItemIsList() != NULL
			return TRUE
		else
			return FALSE
		ok

	def FirstList()
		If This.WalkUntilItemIsList() != NULL
			return This.LastItemIn( This.WalkUntilItemIsList() )
		ok

		def FirstListQ()
			return new stzList( This.FirstList() )

		#-- MISSPELLED

		def FristList()
			return This.FirstList()

			def FristListQ()
				return This.FirstListQ()

	def ListsPaths()
		return This.ItemsThatAreLists_AtAnyLevel_TheirPaths() #TODO: Refactor this!

		def ListsPathsQ()
			return new stzList( This.ListsPaths() )

	def ItemsThatAreLists_AtAnyLevel_TheirPaths()
		aResult = []
		aInfo = This.ItemsThatAreLists_AtAnyLevel_XT()
		for info in aInfo
			aResult + info[1][2]	// GetItemByPath(x,y) : Generalize!!!
		next
		
		return aResult

		def ItemsThatAreLists_AtAnyLevel_TheirPathsQ()
			return new stzList( This.ItemsThatAreLists_AtAnyLevel_TheirPaths() )

	def ItemByPath(panPath)
		if This.ContainsItemOnPath(panPath)
			cCode = "Result = "
			cCode += GenerateListAccessCode_FromNameAndPath("This.Content()", panPath)
			eval(cCode)
			return Result
		ok

		def ItemByPathQ(panPath)
			item = This.ItemByPath(panPath)
			switch ring_type( item )
			on "NUMBER"
				return new stzNumer(""+ item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

	def Paths()
		// TODO

	def ItemsAndTheirPaths()
		// TODO

	def IncludesPath(panPath)
		return StzListQ( This.Paths() ).Contains(panPath)

	def ContainsItemOnPath(panPath)
		#TODO

	def ContainsListOnPath(panPath)
		try
			cCode = "TempItem = "
			cCode += GenerateListAccessCode_FromNameAndPath("This.Content()",panPath)
	
			eval(cCode)
			if isList(TempItem)
				return TRUE
			else
				return FALSE
			ok
		catch
			return FALSE

		done

		
	def NumberOfLists_AtAnyLevel()
		return len( This.ItemsThatAreLists_AtAnyLevel_XT() )

	def ItemsThatAreLists_AtAnyLevel()
		aResult = []
		
		for anPath in This.ItemsThatAreLists_AtAnyLevel_TheirPaths()
			
			cPath = "aTempList = "
			cPath += GenerateListAccessCode_FromNameAndPath("This.Content()", anPath)

			eval(cPath)
			aResult + aTempList
		next
		return aResult


	def ItemsThatAreLists_InLevel(n)
		// TODO

	def ItemsThatAreLists_InPositionN_AtAnyLevel(n)
		// TODO

	def ItemsInLevel(n)
		// TODO

	def ItemsInPositionN_AtAnyLevel(n)
		// TODO

	// Returns a stzListOfHashlists:
	// for each list: its path, level and position.
	def ItemsThatAreLists_AtAnyLevel_XT()
		
		aResult = []
		aPath = []

		nLevel = -1
		nPosition = -1

		for c in list2code(This.Content())
			if c = "["
				nLevel++
				if nPosition > -1
					aPath + (nPosition+1)
				else
					aPath = []
				ok
				aResult + [ :Path = aPath, :Level = nLevel, :Position = nPosition+1 ]
				
				nPosition = 0

			but c = "]"
				nLevel--
				if len(aPath) > 0
					del(aPath, len(aPath))
				ok

			but c = ","
				nPosition++
				
			ok
			
		next
		oResult = new stzList(aResult)
		return oResult.Section(2, oResult.NumberOfItems())

		def ItemsThatAreLists_AtAnyLevel_XTQ()
			return new stzList( This.ItemsThatAreLists_AtAnyLevel_XT() )

	def NumberOfLevels()
				
		oCopy = @@( Q( This.Content() ).RemoveSectionsBetweenIBQ("]","[") )
		nResult = oCopy.NumberOfOccurrence("[")

		return nResult

		#< @FunctionAlternativeForms

		def CountLevels()
			return This.NumberOfLevels()

		def HowManyLevels()
			return This.NumberOfLevels()

		def HowManyLevel()
			return This.NumberOfLevels()

		#>
	
	def Depth()
		return This.NumberOfLevels()

	def ItemsThatAre_Lists_AtAnyLevel()
		aResult = []
		n = 0
		n1 = 0
		n2 = 0

		oListInString = StzStringQ( list2code(This.Content()) )

		bInsideList = FALSE
		for i = 2 to oListInString.NumberOfChars() - 1

			c = oListInString[i]

			if c = "["
				bInsideList = TRUE
				n1 = i
			ok

			if c = "]" and bInsideList = TRUE
				n2 = i
				cCode = oListInString.Section(n1, n2)
				eval("aTempList = " + cCode)

				aResult + aTempList
				bInsideList = FALSE
			ok
			
		next

		return aResult

		def ItemsThatAre_Lists_AtAnyLevelQ()
			return new stzListOfLists( This.ItemsThatAre_Lists_AtAnyLevel() )
			
	def ListsAtAnyLevel()
		return This.ItemsThatAre_Lists_AtAnyLevel()

		def ListsAtAnyLevelQ()
			return new stzListOfLists( This.ListsAtAnyLevel() )
	
	def Structure()
		// TODO
		
	def ShowStructure()
		/* Generates a treeview like this:
			LIST[]
			|
			+-- cItem1
			|
			+-- Item2[]
			| |
			| +-- nItem2.1
			| |
                        | +-- oItem2.2
			|
			+-- nItem3
		*/

		StzRaise("Unsupported feature yet!")

		#< @FuntionMisspelledForm

		def ShwoStructure()
			This.ShowStructure()

		#>

	  #---------------------------#
	 #     LEVELS OF THE LIST    #
	#===========================#

	def Levels()
		// TODO
		StzRaise("Unsupported feature yet!")

	def NthLevel(n)
		// TODO
		StzRaise("Unsupported feature yet!")

	def ContentOfLevel(n)
		// TODO
		StzRaise("Unsupported feature yet!")

		def ItemsOfLevel(n)
			return This.ContentOfLevel(n)

	def LevelsAndTheirItems()
		// TODO
		StzRaise("Unsupported feature yet!")

	  #-----------------------------------------------#
	 #   GETTING THE LIST OF ALL POSSIBLE SUBLISTS   #
	#===============================================#
	# By analogy to SubStrings() in stzString
	#TODO: Use the same implementation of SubSrtrings() in stzString
	#NOTE: Bring all the related functions

	#WARNING: SubLists() and Lists() are different.
	# SubLists() : Returns all the possible combinations of sections that
	#              we can compose from the list (look at SubStrings() in stzString)
	# Lists()    : Provides the list of items that are lists

	def Sublists()
		StzRaise("Not yet implemented!")

	  #====================#
	 #  SHOWING THE LIST  #
	#====================#

	def Show()
		? @@( This.Content() )

		#< @FuntionMisspelledForm

		def Shwo()
			This.Show()

		#>

	def ShowShort()
		? @@S( This.Content() )

		def ShowShortCopy()
			This.ShowShort()

		#< @FuntionMisspelledForms

		def ShwoShort()
			This.ShowShort()

		def ShwoShortCopy()
			This.ShowShort()

		#>

	def ShowShortXT(p)
		? @@SXT( This.Content(), p)

		def ShowShortenedXT(p)
			This.ShowShortXT(p)

		#< @FuntionMisspelledForms

		def ShwoShortXT(p)
			This.ShowShortXT(p)

		def ShwoShortenedXT(p)
			This.ShowShortXT(p)

		#>

	def ShowShortN(n)
		? @@SN( This.Content(), n )

		#< @FuntionMisspelledForm

		def ShwoShortN(n)
			This.ShowShortN(n)

		#>

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortUsing(pcMiddlePart)
			This.ShowShortUsing(pcMiddlePart)

		#>

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

		#< @FuntionMisspelledForm

		def ShwoShortNUsing(n, pcMiddlePart)
			This.ShowShortNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST  #
	#=========================================#

	def ToShort()
		return This.ToShortXT(10, 3, "...")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST WITH N ITEMS FROM EACH SIDE  #
	#---------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, "...")

	  #-------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST USiNG A GIVEN MIDDLE PART  #
	#-------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE LIST USING N ITEMS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #----------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE LIST -- EXTENDED  #
	#----------------------------------------------------#

	def ToShortXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		# nMinListSize : the minimum size to start shortening
		# --> if the size of the list is less than this value,
		#     the list will not be shortened (returned as is)

		# pNumberOfItemsToShow: the number of items to show from
		# both the beginning and end of the list
		# --> the other part of the item (coming in the middle)
		#     will be hided and replaced by pcMiddlePart

		/* EXAMPLES

		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).Shortened()
		#--> '[ "1", "2", "3", "...", "7", "8", "9" ]'
		
		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).ShortenedN(2)
		#--> '[ "1", "2", "...", "8", "9" ]'
		
		? Q([ "1", "2", "3", "4", "5", "6", "7", "8", "9"]).ShortenedXT(0, 2, "{...}")
		#--> '[ "1", "2", "{...}", "8", "9" ]'

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinListSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfItemsToShow)
			n1 = pNumberOfItemsToShow
			n2 = pNumberOfItemsToShow

		but isList(p) and Q(pNumberOfItemsToShow).IsPairOfNumbers()
			n1 = pNumberOfItemsToShow[1]
			n2 = pNumberOfItemsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfItemsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of items to show must be different of zero..")
		ok

		# Doing the job

		aPart1 = This.Section(1, n1)
		aPart2 = This.Section(nLen - n2 + 1, nLen)

		aResult = aPart1
		aResult + pcMiddlePart

		for i = 1 to n2
			aResult + aPart2[i]
		next

		return aResult

	  #-----------------------#
	 #  SHORTENING THE LIST  #
	#=======================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #------------------------------------------------#
	 #  SHORTENING THE LIST TO N ITEMS FROM EACH SIDE #
	#------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNItems(n)
			This.ShortenN(n)

			def ShortenToNItemsQ(n)
				This.ShortenToNItems(n)
				return This

		def ShortenToNItemsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsInEachSideQ(n)
				This.ShortenToNItemsInEachSide(n)
				return This

		def ShortenToNItemsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsFromEachSideQ(n)
				This.ShortenToNItemsFromEachSide(n)
				return This

		def ShortenToNItemsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNItemsAtEachSideQ(n)
				This.ShortenToNItemsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNItems(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNItemsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #---------------------------------------------------------------#
	 #  SHORTENING THE LIST USING THE GIVEN STRING AS A MIDDLE ITEM  #
	#---------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE LIST USING N ITEMS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNItemsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNItemsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNItemsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNItemsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE LIST -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
			This.ShortenXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinListSize, pNumberOfItemsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinListSize, pNumberOfItemsToShow, pcMiddlePart).Content()
		return cResult

	  #======================================#
	 #  FINDING ALL OCCURRENCES OF AN ITEM  #
	#======================================#

	#TODO
	# Compare the code of this function and the FindDuplicates() function
	#-> See if there is a window of enhancement

	#NOTE
	# The function uses This.Stringified() to turn the items of the list
	# into strings before finding them (necessary to find items other than
	# numbers and strings). Hence, when the function is called on a
	# child class like for example:

	# StzListOfPairs([ [1,3], [9, 9], [12, 15], [9, 9] ]).FindAll([9, 9])

	# and when the list is stringified, an error message will be raised
	# when the list of pairs is updated (Can't update the list of pairs
	# with a list of strings).

	# To avoid this problem, we force stzList to apply This.Stringified()
	# on itself and not in its child classes, by using instead of it:

	# StzListQ(this.Content()).Stringified()

	def FindAllOccurrencesCS(pItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "ring", "php", "ring", "ring", "_" ])
		? o1.Find("ring")

		*/

		if CheckParams()
	
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

			if isObject(pItem) and NOT @IsNamedObject(pItem)
				StzRaise("Can't find an unnamed object!")
			ok

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok

		ok

		# Remying on a Ring-native solution (using the @FindAll() optimised
		# function, provided by Softannza at the global level)

		aContent = This.Content()
		nLen = len(aContent)

		if EarlyCheck()
			if nLen = 0
				return []
			ok
		ok

		anResult = @FindAllCS( This.Content(), pItem, pCaseSensitive)

		if isList(anResult) > 0
			return anResult

		else # the returned value is -1 ~> @FindAll() was not able to compute pItem
		     # because it was not a number or string

		# we rely on an advanced Softanza solution that finds
		# not only numbers and strings (base on the strangifying of the list)

			cItem = ""
			if isList(pItem)
				cItem = @@(pItem)
	
			but isObject(pItem) and @IsStzObject(pItem) and pItem.IsNamed()
				cItem = pItem.ObjectName()
	
			else
				cItem = Q(pItem).Stringified()
	
			ok
	
			acContent = StzListQ(This.Content()).Stringified()
			nLen = len(acContent)
	
			# Managing case sensitivity
	
			if pCaseSensitive = FALSE
				cItem = ring_lower(cItem)
	
				for i = 1 to nLen
					if NOT ring_isLower(acContent[i])
						acContent[i] = ring_lower(acContent[i])
					ok
				next
			ok
	
			# Getting the occurrences
	
			anResult = []
	
			for i = 1 to nLen
				if acContent[i] = cItem
					anResult + i
				ok
			next
	
			return anResult
		ok

		#< @FunctionFluentForm

		def FindAllOccurrencesCSQ(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCSQR(pItem, pCaseSensitive, :stzList)

		def FindAllOccurrencesCSQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfUnicodes
				return new stzListOfUnicodes( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfSets
				return new stzListOfSets( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfGrids
				return new stzListOfGrids( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfTables
				return new stzListOfTables( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfEntities
				return new stzListOfEntities( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfBytes
				return new stzListOfBytes( This.FindAllCS(pItem, pCaseSensitive) )

			on :stzListOfObjects
				return new stzListOfObjects( This.FindAllCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForms

		def FindAllCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def FindAllCSQ(pItem, pCaseSensitive)
				return This.FindAllCSQR(pItem, pCaseSensitive, :stzList)
	
			def FindAllCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllOccurrencesCSQR(pItem, pCaseSensitive, pcReturnType)
			#>

		def FindItemCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def FindItemCSQ(pItem, pCaseSensitive)
				return This.FindItemCSQR(pItem, pCaseSensitive, :stzList)
	
			def FindItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQR(pItem, pCaseSensitive, pcReturnType)
			#>

		def PositionsCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def PositionsCSQ(pItem, pCaseSensitive)
				return This.PositionsCSQR(pItem, pCaseSensitive, :stzList)
	
			def PositionsCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQR(pItem, pCaseSensitive, pcReturnType)
			#>

		def OccurrencesCS(pItem, pCaseSensitive)
			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm

			def OccurrencesCSQ(pItem, pCaseSensitive)
				return This.OccurrencesCSQR(pItem, pCaseSensitive, :stzList)
	
			def OccurrencesCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQR(pItem, pCaseSensitive, pcReturnType)
			#>

		def FindCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindAllOccurrencesCS(pItem, pCaseSensitive)

			def FindCSQ(pItem, pCaseSensitive)
				return This.FindCSQR(pItem, pCaseSensitive, :stzList)

			def FindCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllCSQR(pItem, pCaseSensitive, pcReturnType)

		#>	

	#-- WITHOUT CASESENSITIVITY

	def FindAllOccurrences(pItem)
		aResult = This.FindAllOccurrencesCS(pItem, TRUE)
		return aResult

		#< @FunctionFluentForm

		def FindAllOccurrencesQ(pItem)
			return This.FindAllOccurrencesQR(pItem, :stzList)

		def FindAllOccurrencesQR(pItem, pcReturnType)
			return This.FindAllOccurrencesCSQR(pItem, TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForms

		def FindAll(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindAllQ(pItem)
				return This.FindAllQR(pItem, :stzlist)
	
			def FindAllQR(pItem, pcReturnType)
				return This.FindAllOccurrencesQR(pItem, pcReturnType)
	
			#>

		def FindItem(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindItemQ(pItem)
				return This.FindItemQR(pItem, :stzList)
	
			def FindItemQR(pItem, pcReturnType)
				return This.FindAllOccurrencesQR(pItem, pcReturnType)
			#>

		def Positions(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def PositionsQ(pItem)
				return This.PositionsQR(pItem, :stzList)
	
			def PositionsQR(pItem, pcReturnType)
				return This.FindAllOccurrencesQR(pItem, pcReturnType)
			#>

		def Occurrences(pItem)
			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def OccurrencesQ(pItem)
				return This.OccurrencesQR(pItem, :stzList)
	
			def OccurrencesQR(pItem, pcReturnType)
				return This.FindAllOccurrencesQR(pItem, pcReturnType)
			#>

		def Find(pItem)
			if isList(pItem) and Q(pItem).IsItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindAllOccurrences(pItem)

			#< @FunctionFluentForm

			def FindQ(pItem)
				return This.FindQR(pItem, :stzList)
	
			def FindQR(pItem, pcReturnType)
				return This.FindAllOccurrencesQR(pItem, pcReturnType)
			#>
		#>

	  #---------------------------------------------------#
	 #  FINDING POSITIONS WHERE THE ITEM DOES NOT EXIST  #
	#===================================================#

	def AntiFindCS(pItem, pCaseSensitive)
		/* Example

		o1 = new stzList([ "1", "2", "", "4", "5", "", "6", "7", "", "9" ])
		
		? @@( o1.Find("") ) + NL
		#--> [ 3, 6, 9 ]
		
		? @@( o1.AntiFind("") ) + NL
		#--> [ 1, 2, 4, 5, 7, 8, 10 ]

		*/

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anResult = Q(1:This.NumberOfItems()) - These(anPos)

		return anResult

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pItem)
		return This.AntiFindCS(pItem, TRUE)

	  #-------------------------------------------------------#
	 #    FINDING N OCCURRENCES OF AN ITEM INSIDE THE LIST   #
	#-------------------------------------------------------#

	# Finding works only for numbers and strings

	#TODO : Lists and objects will become findable after
	# designing an overall solution of the Equality problem
	# in SoftanzaLib

	# UPDATE: Lists are now findable (only objects are left for future)
	# UPDATE : Named objects are now findable!

	def FindNthOccurrenceCS(n, pItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ 1, 2, "*", 4, 5, "*", 7, 8, "*", 10 ])
		? o1.FindNth(3, "*")
		#--> 9

		*/

		if CheckParams()

			if isString(n)
				if n = :First or n = :FirstOccurrence
					return This.FindFirstCS(pItem, pCaseSensitive)
	
				but n = :Last or n = :LastOccurrence
					return This.FindLastCS(pItem, pCaseSensitive)
				ok
			ok
	
			if NOT isNumber(n)
				StzRaise("Incorrect  param type! n must be a number.")
			ok
	
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

			if isObject(pItem) and NOT @IsNamedObject(pItem)
				StzRaise("Can't process! Objects, unless they are named objects, can not be found yet.")
			ok

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok

		ok

		# Trying to use the Ring native find() function

		nResult = @FindNthSCS(This.Content(), n, pItem, 1, pCaseSensitive)

		if nResult != -1
			return nResult

		else
		# Otherwise, stringifying the list and doing the job
	
			cItem = ""
			if isList(pItem) or @IsNamedObject(pItem)
				cItem = @@(pItem)
			else
				cItem = Q(pItem).Stringified()
			ok
	
			acContent = StzListQ(This.Content()).Stringified()
			nLen = len(acContent)
	
			# Managing case sensitivity
	
			if pCaseSensitive = FALSE
				cItem = ring_lower(cItem)
	
				for i = 1 to nLen
					if NOT ring_isLower(acContent[i])
						acContent[i] = ring_lower(acContent[i])
					ok
				next
			ok
	
			# Counting the occurrences
	
			nOccurr = 0
	
			for i = 1 to nLen
	
				if acContent[i] = cItem
					nOccurr++
					if nOccurr = n
						return i
					ok
				ok
			next
	
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindNthItemCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def FindNthCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def NthOccurrenceCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		def ItemPositionByOccurrenceCS(n, pItem, pCaseSensitive)
			return This.FindNthOccurrenceCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pItem) 
		return This.FindNthOccurrenceCS(n, pItem, TRUE) 

		#< @FunctionAlternativeForms

		def FindNthItem(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def FindNth(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def Nth(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def NthOccurrence(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		def ItemPositionByOccurrence(n, pItem)
			return This.FindNthOccurrence(n, pItem)

		#>

	  #----------------------------------------------------------------#
	 #    FINDING NTH TO LAST OCCURRENCE OF AN ITEM INSIDE THE LIST   #
	#----------------------------------------------------------------#

	def NthToLast(n)
		return This.ItemAtPosition( This.NumberOfItems() - n )

	  #----------------------------------------------------------------#
	 #    FINDING NTH TO LAST OCCURRENCE OF AN ITEM INSIDE THE LIST   #
	#----------------------------------------------------------------#

	def NthToFirst(n)
		return This.ItemAtPosition(n + 1)

	  #---------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN THE LIST  #
	#---------------------------------------------------#

	def FindFirstOccurrenceCS(pItem, pCaseSensitive)
		return This.FindNthOccurrenceCS(1, pItem, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindFirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FirstOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFirstCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFirstOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)
	
		#>

		#< @FunctionMisspelledForms

		def FindFristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FristOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def FristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFristCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfFristOccurrenceCS(pItem, pCaseSensitive)
			return This.FindFirstOccurrenceCS(pItem, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstOccurrence(pItem)
		return This.FindFirstOccurrenceCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindFirst(pItem)
			return This.FindFirstOccurrence(pItem)

		def FirstOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)

		def First(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFirst(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFirstOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)
	
		#>

		#< @FunctionMisspelledForms

		def FindFrist(pItem)
			return This.FindFirstOccurrence(pItem)

		def FristOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)

		def Frist(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFrist(pItem)
			return This.FindFirstOccurrence(pItem)

		def PositionOfFristOccurrence(pItem)
			return This.FindFirstOccurrence(pItem)
	
		#>

	  #--------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN THE LIST  #
	#--------------------------------------------------#

	def FindLastOccurrenceCS(pItem, pCaseSensitive)

		if CheckParams()
			if isList(pItem) and StzListQ(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok

			if isObject(pItem) and NOT @IsNamedObject(pItem)
				StzRaise("Can't process! Objects, unless they are named objects, can not be found yet.")
			ok

			if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
				pCaseSensitive = pCaseSensitive[2]
			ok
		ok

		acReversed = ring_reverse( StzListQ(This.Content()).Stringified() )

		# Reversing the list after stringifying it

		nLen = len(acReversed)

		# Stringifying the item to look for

		cItem = ""
		if isList(pItem) or @IsNamedObject(pItem)
			cItem = @@(pItem)
		else
			cItem = Q(pItem).Stringified()
		ok

		# Managing case sensitivity

		if pCaseSensitive = FALSE
			cItem = ring_lower(cItem)
			for i = 1 to nLen
				acReversed[i] = ring_lower(acReversed[i])
			next
		ok

		# Doing the job

		nResult = 0

		n = ring_find(acReversed, cItem)
		if n > 0
			nResult = nLen - n + 1
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def LastOccurrenceCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def LastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfLastCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		def PositionOfLastOccurrenceCS(pItem, pCaseSensitive)
			return This.FindLastOccurrenceCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastOccurrence(pItem)

		return This.FindLastOccurrenceCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindLast(pItem)
			return This.FindLastOccurrence(pItem)

		def LastOccurrence(pItem)
			return This.FindLastOccurrenceCS(pItem)

		def Last(pItem)
			return This.FindLastOccurrenceCS(pItem)

		def PositionOfLast(pItem)
			return This.FindLastOccurrence(pItem)

		def PositionOfLastOccurrence(pItem)
			return This.FindLastOccurrence(pItem)

		#>

	  #------------------------------------------#
	 #   FINDING GIVEN OCCURRENCES OF AN ITEM   #
	#------------------------------------------#

	def FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)
		if CheckParams()
			if NOT isList(panOccurr)
				StzRaise("incorrect param type! panOccurr must be a list.")
			ok

			nLen = len(panOccurr)

			if isList(panOccurr[nLen]) and Q(panOccurr[nLen]).IsAndNamedParam()
				panOccurr[nLen] = panOccurr[nLen][2]
			ok

			for i = 1 to nLen
				if isString(panOccurr[i])
					if panOccurr[i] = :First or panOccurr[i] = :FirstOccurrence
						panOccurr[i] = 1
					but panOccurr[i] = :Last or panOccurr[i] = :LastOccurrence
						panOccurr[i] = This.NumberOfOccurrenceCS(pItem, pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panOccurr)
				StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
			ok

		ok

		anPos = This.FindAllCS(pItem, pCaseSensitive)
		return Q(anPos).ItemsAt(panOccurr)

		def FindOccurrencesCS(panOccurr, pItem, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pItem)
		return This.FindTheseOccurrencesCS(panOccurr, pItem, TRUE)

		def FindOccurrences(panOccurr, pItem)
			return This.FindTheseOccurrences(panOccurr, pItem)

	  #-------------------------------------------------------#
	 #   FINDING THE OCCURRENCES OF MANY ITEMS IN THE LIST   #
	#-------------------------------------------------------#
	
	def FindManyCS(paItems, pCaseSensitive)
		/*
		o1 = new stzList([ :one, :two, :one, :three, :one, :four ])
		? o1.FindMany([ :one, :two, :four ])
		#--> [ 1, 2, 3, 5, 6 ]
		*/

		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		aItems = U(paItems)
		nLen = len(aItems)

		anResult = []

		for i = 1 to nLen
			anPos = This.FindAllCS(aItems[i], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)

		return anResult

		#< @FunctionFluentForm

		def FindManyCSQ(paItems, pCaseSensitive)
			return This.FindManyCSQR(paItems, pCaseSensitive, :stzListOfNumbers)

		def FindManyCSQR(paItems, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(paItems, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(paItems, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		#

		#< @FunctionAlternativeForms

		def FindTheseItemsCS(paItems, pCaseSensitive)
			return This.FindManyCS(paItems, pCaseSensitive)

		def FindTheseCS(paItems, pCaseSensitive)
			return This.FindManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(paItems)
		return This.FindManyCS(paItems, TRUE)

		#< @FunctionFluentForm

		def FindManyQ(paItems)
			return This.FindManyQR(paItems, :stzListOfNumbers)

		def FindManyQR(paItems, pcReturnType)
			return This.FindManyCSQR(paItems, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def FindTheseItems(paItems)
			return This.FindMany(paItems)

		def FindThese(paItems)
			return This.FindMany(paItems)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING THE OCCURRENCES OF MANY ITEMS IN THE LIST -- EXTENDED  #
	#------------------------------------------------------------------#

	def TheseItemsCSZ(paItems, pCaseSensitive)
		/*
		o1 = new stzList([ :one, :two, :one, :three, :one, :four ])
		? o1.TheseItemsZZ([ :one, :two, :four ])
		#--> [ :one = [1, 3, 5], :two = [2], :three = [6] ]
		*/

		if CheckParams()
			if NOT isList(paItems)
				StzRaise("Incorrect param type! paItems must be a list.")
			ok
		ok

		nLen = len(paItems)

		aResult = []

		for i = 1 to nLen
			aResult + [ paItems[i], This.FindAllCS(paItems[i], pCaseSensitive) ]
		next

		return aResult

		#< @FunctionFluentForm

		def TheseItemsCSZQ(paItems, pCaseSensitive)
			return new stzList( This.TheseItemsCSZ(paItems, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def TheseItemsAndTheirPositionsCS(paItems, pCaseSensitive)
			return This.TheseItemsCSZ(paItems, pCaseSensitive)

			def TheseItemsAndTheirPositionsCSQ(paItems, pCaseSensitive)
				return This.TheseItemsCSZQ(paItems, pCaseSensitive)
		#>

	#-- CASESENSITIVITY

	def TheseItemsZ(paItems)
		return This.TheseItemsCSZ(paItems, TRUE)

		#< @FunctionFluentForm

		def TheseItemsZQ(paItems)
			return new stzList( This.TheseItemsZ(paItems) )

		#>

		#< @FunctionAlternativeForm

		def TheseItemsAndTheirPositions(paItems)
			return This.TheseItemsZ(paItems)

			def TheseItemsAndTheirPositionsQ(paItems)
				return This.TheseItemsZQ(paItems)
		#>

	  #-------------------------------------------#
	 #  FINDING ITEMS OTHER THAN THOSE PROVIDED  #
	#-------------------------------------------#

	def FindItemsOtherThanCS(paItems, pCaseSensitive)
		if CheckParams()

			if NOT isList(paItems)
				aTemp = []
				aTemp + paItems
				paItems = aTemp
			ok

		ok

		anPos = This.FindTheseItemsCS(paItems, pCaseSensitive)

		nLen = This.NumberOfItems()
		anResult = Q( 1 : nLen) - These(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindItemsExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindItemsOtherThanTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanTheseItemsCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindAllExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllItemsExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindAllItemsExceptTheseCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindExceptCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		def FindOtherThanCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#--

		def FindAllButCS(paItems, pCaseSensitive)
			return This.FindItemsOtherThanCS(paItems, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindItemsOtherThan(paItems)
		return This.FindItemsOtherThanCS(paItems, :CaseSensitive)

		#< @FunctionAlternativeForms

		def FindItemsExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindItemsOtherThanThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindItemsExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThanTheseItems(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThanThese(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindAllExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllItemsExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindAllItemsExceptThese(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindExcept(paItems)
			return This.FindItemsOtherThan(paItems)

		def FindOtherThan(paItems)
			return This.FindItemsOtherThan(paItems)

		#--

		def FindAllBut(paItems)
			return This.FindItemsOtherThan(paItems)

		#>

	  #-------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF AN ITEM, EXCEPT THE FIRST OCCURRENCE  #
	#-------------------------------------------------------------------#

	def FindAllExceptFirstCS(pItem, pCaseSensitive)
		anResult = This.FindAllCSQ(pItem, pCaseSensitive).Section(2, :LastItem)
		return anResult

		#< @FunctionFluentForm

		def FindAllExceptFirstCSQR(pItem, pcReturnType, pCaseSensitive)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptFirstCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptFirstCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptFirstCSQ(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCSQR(pItem, pCaseSensitive, :stzList)

		#

		#< @FunctionAlternativeForms

		def FindExceptFirstCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptFirstCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptFirstCSQR(pItem, pcReturnType, pCaseSensitive)
	
			def FindExceptFirstCSQ(pItem, pCaseSensitive)
				return This.FindAllExceptFirstCSQR(pItem, pCaseSenstive, :stzList)
	
		def FindFirstExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		def FindFirstButCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		def FindAllButFirstCS(pItem, pCaseSensitive)
			return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindExceptFristCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptFristCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptFristCSQR(pItem, pcReturnType, pCaseSensitive)
	
			def FindExceptFristCSQ(pItem, pCaseSensitive)
				return This.FindAllExceptFristCSQR(pItem, pCaseSenstive, :stzList)
	
		def FindFristExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		def FindFristButCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		def FindAllButFristCS(pItem, pCaseSensitive)
			return This.FindAllExceptFristCS(pItem, pCaseSensitive)

		#>

	#-- WITHoUT CASESENSITIVITY

	def FindAllExceptFirst(pItem)
		return This.FindAllExceptFirstCS(pItem, pCaseSensitive)

		#< @FunctionFluentForm

		def FindAllExceptFirstQR(pItem, pcReturnType)
			return This.FindAllExceptFirstCSQR(pItem, pcReturnType, TRUE)

		def FindAllExceptFirstQ(pItem)
			return This.FindAllExceptFirstQR(pItem, :stzList)

		#

		#< @FunctionAlternativeForms

		def FindExceptFirst(pItem)
			return This.FindAllExceptFirst(pItem)

			#< @FunctionFluentForm
	
			def FindExceptFirstQR(pItem, pcReturnType)
				return This.FindExceptFirstCSQR(pItem, pcReturType, TRUE)
	
			def FindExceptFirstQ(pItem)
				return This.FindAllExceptFirstQR(pItem, :stzList)
	
			#>

		def FindFirstExcept(pItem)
			return This.FindAllExceptFirst(pItem)

		def FindFirstBut(pItem)
			return This.FindAllExceptFirst(pItem)

		def FindAllButFirst(pItem)
			return This.FindAllExceptFirst(pItem)

		#>

		#< @FunctionMisspelledForms

		def FindExceptFrist(pItem)
			return This.FindAllExceptFrist(pItem)

			#< @FunctionFluentForm
	
			def FindExceptFristQR(pItem, pcReturnType)
				return This.FindAllExceptFristQR(pItem, pcReturnType)
	
			def FindExceptFristQ(pItem)
				return This.FindAllExceptFristQR(pItem, :stzList)
	
		def FindFristExcept(pItem)
			return This.FindAllExceptFrist(pItem)

		def FindFristBut(pItem)
			return This.FindAllExceptFrist(pItem)

		def FindAllButFrist(pItem)
			return This.FindAllExceptFrist(pItem)

		#>

	  #------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF AN ITEM, EXCEPT THE LAST OCCURRENCE  #
	#------------------------------------------------------------------#

	def FindAllExceptLastCS(pItem, pCaseSensitive)
		oTemp = new stzList( This.FindAllCS(pItem, pCaseSensitive) )
		return oTemp.Section( 1, oTemp.NumberOfItems()-1 )

		#< @FunctionFluentForm

		def FindAllExceptLastCSQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptLastCS(pItem, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptLastCS(pItem, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptLastCSQ(pItem, pCaseSensitive)
			return This.FindAllExceptLastCSQR(pItem, pCaseSensitive, :stzList)

		#

		#< @FunctionAlternativeForms

		def FindExceptLastCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

			#< @FunctionFluentForm
	
			def FindExceptLastCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.FindAllExceptLastCSQR(pItem, pCaseSensitive, pcReturnType)
	
			def FindExceptLastCSQ(pItem)
				return This.FindAllExceptLastQR(pItem, pCaseSensitive, :stzList)
	
			#>

		def FindLastExceptCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		def FindLastButCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		def FindAllButLastCS(pItem, pCaseSensitive)
			return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FindAllExceptLast(pItem)
		return This.FindAllExceptLastCS(pItem, pCaseSensitive)

		#< @FunctionFluentForm

		def FindAllExceptLastQR(pItem, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAllExceptLast(pItem) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindAllExceptLast(pItem) )
			other
				StzRaise("Unsupported return type!")
			off

		def FindAllExceptLastQ(pItem)
			return This.FindAllExceptLastQR(pItem, :stzList)

		#

		#< @FunctionAlternativeForm

		def FindExceptLast(pItem)
			return This.FindAllExceptLast(pItem)

			#< @FunctionFluentForm
	
			def FindExceptLastQR(pItem, pcReturnType)
				return This.FindExceptLastCSQR(pItem, pcReturnType, TRUE)
	
			def FindExceptLastQ(pItem)
				return This.FindAllExceptLastQR(pItem, :stzListOfNumbers)
	
			#>

		def FindLastExcept(pItem)
			return This.FindAllExceptLast(pItem)

		def FindLastBut(pItem)
			return This.FindAllExceptLast(pItem)

		def FindAllButLast(pItem)
			return This.FindAllExceptLast(pItem)

		#>

	  #======================================================#
	 #  CHECKING IF THE LIST CONTAINS AN ITEM AT ANY LEVEL  #
	#======================================================#

	def DeepContainsCS(pItem, pCaseSensitive)
		
		cList = @@( This.List() )

		cItem = @@(pItem)
		if isString(pItem)
			cItem = Q(cItem).FirstAndLastCharsRemoved()
		ok

		bResult = Q(cList).ContainsCS(cItem, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def DeepContains(pItem)
		return This.DeepContainsCS(pItem, TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE PROVIDED ITEMS ARE ALL CONTAINED IN THE LIST AT ANY LEVEL  #
	#-----------------------------------------------------------------------------#

	def DeepContainsManyCS(paItems, pCaseSensitive)
		bResult = TRUE
		nLen = len(paItems)

		for i = 1 to nLen

			if NOT This.DeepContainsCS(paItems[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok

		next

		return bResult

		#< @FunctionAlternativeForms

		def DeepContainsTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachOneOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsEachOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		def DeepContainsAllOfTheseCS(paItems, pCaseSensitive)
			return This.DeepContainsManyCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsMany(paItems)
		return This.DeepContainsManyCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def DeepContainsThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEach(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEachOneOfThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsEachOfThese(paItems)
			return This.DeepContainsMany(paItems)

		def DeepContainsAllOfThese(paItems)
			return This.DeepContainsMany(paItems)

		#>


	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS BOTH OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#-------------------------------------------------------------------------#

	def DeepContainsBothCS(pItem1, pItem2, pCaseSensitive)
		if isList(pItem2) and Q(pItem2).IsAndNamedParam()
			pItem2 = pItem2[2]
		ok

		return This.DeepContainsEachCS([ pItem1, pItem2 ], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsBoth(pItem1, pItem2)
		return This.DeepContainsBothCS(pItem1, pItem2, TRUE)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS AT LEAST ONE OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#--------------------------------------------------------------------------------#

	def DeepContainsOneOfTheseCS(paItems, pCaseSensitive)
		bResult = FALSE

		for i = 1 to len(paItems)
			if This.DeepContainsCS(paItems[i], pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def DeepContainsOneOfThese(paItems)
		return This.DeepContainsOneOfTheseCS(paItems, TRUE)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS AT LEAST N OF THE PROVIDED ITEMS AT ANY LEVEL  #
	#--------------------------------------------------------------------------------#

	def DeepContainsNOfTheseCS(n, paItems, pCaseSensitive)
		bResult = FALSE
		v = 0

		for i = 1 to len(paItems)
			if This.DeepContainsCS(paItems[i], pCaseSensitive)
				v++
				if v = n
					bResult = TRUE
					exit
				ok
			ok
		next

		return bResult

		def DeepContainsNItemsOfTheseCS(n, paItems, pCaseSensitive)
			return This.DeepContainsNOfTheseCS(n, paItems, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def DeepContainsNOfThese(n, paItems)
		return This.DeepContainsNOfTheseCS(n, paItems, TRUE)

		def DeepContainsNItemsOfThese(n, paItems)
			return This.DeepContainsNOfThese(n, paItems)

	  #================================#
	 #  FINDING AN ITEM AT ANY LEVEL  #
	#================================#

	/*
	TODO: Harmonize this section with  "LIST STRUCTURE" section
	--> There are some TODOs their, review them.
	*/

	// Finding pItem at any level of the list
	def DeepFindCS(pItem, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([
			"you",
			"other",
			[ "other", "you", [ "you" ], "other" ],
			"other",
			"you"
		])

		o1.DeepFind("you")
		#--> "you" is found in the following positions
		[
			[ [1, 1], [1, 5] ],	# positions 1 and 5 in the level [1, 1]
			[ [3, 1], [ 2 ]  ],	# positon 2 in the level [3, 1]
			[ [3, 2], [ 1 ]  ],	# position 1 in the level [3, 2]
		]
		*/

		oListStr = new stzString( @@(This.Content()) )
		cItem = @@(pItem)

		anPos = oListStr.FindCS(cItem, pCaseSensitive) #--> [21, 52]
		nLenPos = len(anPos)
	
		aResult = []

		for i = 1 to nLenPos
			nPos = anPos[i]
		
			oSection = oListStr.SectionQ(1, nPos)
		
			anPosBound1 = oSection.Find("[")
			anPosBound2 = oSection.Find("]")
		
			nLevel = len(anPosBound1) - len(anPosBound2)
		
			n1 = oListStr.FindFirstPrevious("[", :StartingAt = nPos)
			n2 = oListStr.FindFirstNext("]", :StartingAt = nPos)
		
			nPosition = oListStr.SectionQ(n1, nPos).NumberOfOccurrence(",") + 1
			
			aResult + [nLevel, nPosition]
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def DeepFind(pItem)
		return This.DeepFindCS(pItem, TRUE)

	  #-----------------------------------------------------#
	 #  FINDING THE LIST ITEMS IN AN OTHER LIST OR ITEM  #
	#-----------------------------------------------------#

	def FindInCS(pOtherListOrStr, pCaseSensitive)
		/* 
		EXAMPLE 1:

		o1 = new stzList([ "11", "22", "33" ])
		? o1.FindIn([ "11", "_", "22", "_", "33" ])
		#--> [ 1, 3, 4 ]

		EXAMPLE 2:

		o1 = new stzList([ "11", "22", "33" ])
		? o1.FindIn("**11**22**33**")
		#--> [ 3, 7, 11 ]

		*/

		if isList(pOtherListOrStr) and Q(pOtherListOrStr).IsListNamedParam()
			pOtherListOrStr = pOtherListOrStr[2]

			if NOT isList(paOtherListOrStr)
				StzRaise("Incorrect param type! pOtherListOrStr must be a list.")
			ok
		ok

		if isList(pOtherListOrStr) and Q(pOtherListOrStr).IsStringNamedParam()
			pOtherListOrStr = pOtherListOrStr[2]

			if NOT isString(paOtherListOrStr)
				StzRaise("Incorrect param type! pOtherListOrStr must be a string.")
			ok
		ok

		if NOT (isList(pOtherListOrStr) or isString(pOtherListOrStr))
			StzRaise("Incorrect param type! pOtherListOrStr must be a list or string.")
		ok

		anResult = Q(pOtherListOrStr).FindManyCS(This.Content(), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForm

		def FindItemsInCS(pOtherListOrStr, pCaseSensitive)
			return This.FindInCS(pOtherListOrStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindIn(pOtherListOrStr)
		return FindInCS(pOtherListOrStr, TRUE)

		#< @FunctionAlternativeForm

		def FindItemsIn(pOtherListOrStr)
			return FindIn(pOtherListOrStr)

		#>

	  #-------------------------------------------#
	 #  FINDING THE LIST ITEMS IN AN OTHER LIST  #
	#-------------------------------------------#

	def FindInListCS(paOtherList, pCaseSensitive)
		if NOT isList(paOtherList)
			StzRaise("Incorrect param type! paOtherList must be a list.")
		ok

		return This.FindInCS(paOtherList, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindItemsInListCS(paOtherList, pCaseSensitive)
			return This.FindInListCS(paOtherList, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInList(paOtherList)
		return This.FindInListCS(paOtherList, TRUE)

		#< @FunctionAlternativeForm

		def FindItemsInList(paOtherList)
			return This.FindInList(paOtherList)

		#>

	  #---------------------------------------------#
	 #  FINDING THE LIST ITEMS IN AN GIVEN ITEM  #
	#---------------------------------------------#

	def FindInStringCS(pcStr, pCaseSensitive)
		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		return This.FindInCS(pcStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FindItemsInStringCS(pcStr, pCaseSensitive)
			return This.FindInStringCS(pcStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInString(pcStr)
		return This.FindInStringCS(pcStr, TRUE)

		#< @FunctionAlternativeForm

		def FindItemsInString(pcStr)
			return This.FindInString(pcStr)

		#>

	  #=======================================================#
	 #    VISUALLY FINDING ALL OCCURRENCES OF A GIVEN ITEM   #
	#=======================================================#

	#NOTE: Works only if items are chars (string of 1 char each)
	#TODO: Implement a more general solution for longer items

	def VizFindAllOccurrencesCS(pItem, pCaseSensitive)
		
		cResult = This.ToCodeQ().Simplified()
		anPos = Q(cResult).FindAllCS( @@(pItem), pCaseSensitive )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anPos)
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindAllOccurrencesCSQ(pItem, pCaseSensitive)
			return new stzString( This.VizFindAllOccurrencesCS(pItem, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForms

		def VizFindAllCS(pItem, pCaseSensitive)
			return This.VizFindAllOccurrencesCS(pItem, pCaseSensitive)

			def VizFindAllCSQ(pItem, pCaseSensitive)
				return new stzString(This.VizFindAllCS(pItem, pCaseSensitive))
	

		def VizFindCS(pItem, pCaseSensitive)
			return This.VizFindAllOccurrencesCS(pItem, pCaseSensitive)

			def VizFindCSQ(pItem, pCaseSensitive)
				return new stzString(This.VizFindCS(pItem, pCaseSensitive))
		#>

	#-- WITHOUT CASESENSITIVITY

	def VizFindAllOccurrences(pItem)
		return This.VizFindAllOccurrencesCS(pItem, TRUE)

		#< @FunctionFluentForm

		def VizFindAllOccurrencesQ(pItem)
			return new stzString( This.VizFindAllOccurrences(pItem) )

		#>

		#< @FunctionAlternativeForms

		def VizFindAll(pItem)
			return This.VizFindAllOccurrences(pItem)

			def VizFindAllQ(pItem)
				return new stzString(This.VizFindAll(pItem))
	

		def VizFind(pItem)
			return This.VizFindAllOccurrences(pItem)

			def VizFindQ(pItem)
				return new stzString(This.VizFind(pItem))
		#>

	   #-------------------------------------------------#
	  #      FINDING NTH NEXT OCCURRENCE OF AN ITEM     #
	 #      STARTING AT A GIVEN POSITION               #
	#-------------------------------------------------#

	def FindNthNextOccurrenceCS( n, pItem, pnStartingAt, pCaseSensitive )

		if CheckParams()

			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

		ok

		# Trying to use the Ring native find() function first

		nResult = @FindNthSCS( This.Content(), n, pItem, pnStartingAt, pCaseSensitive )

		if nResult != -1
			return nResult
		else
		# else we remy on a Softanza solution
			nResult = This.SectionQ(pnStartingAt + 1, This.NumberOfItems()).
				FindNthCS(n, pItem, pCaseSensitive) + pnStartingAt
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindNextNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NextNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthNextSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthNextOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NthNextOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def NextNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNextNthSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthOccurrenceStartingAtCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthStartingAtCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthNextOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pItem, nStart )
		return This.FindNthNextOccurrenceCS( n, pItem, nStart, TRUE )

		#< @FunctionAlternativeForms

		def FindNextNthOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NthNextOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NextNthOccurrence( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNth( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthNext( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#--

		def FindNthNextOccurrenceS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNthOccurrenceS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NthNextOccurrenceS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def NextNthOccurrenceS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNextNthS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthNextS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#--

		def FindNthOccurrenceS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthOccurrenceStartingAt( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthS( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		def FindNthStartingAt( n, pItem, nStart )
			return This.FindNthNextOccurrence( n, pItem, nStart )

		#>

	   #-----------------------------------------------------#
	  #      FINDING NTH PREVIOUS OCCURRENCE OF AN ITEM     #
	 #      STARTING AT A GIVEN POSITION                   #
	#-----------------------------------------------------#

	def FindNthPreviousOccurrenceCS(n, pItem, nStart, pCaseSensitive)

		nResult  = This.SectionQ(1, nStart).
				ReverseQ().
				FindNthNextOccurrenceCS(n, pItem, nStart, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def FindPreviousNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def PreviousNthOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def NthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthPreviousCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#--

		def FindNthPreviousOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def PreviousNthOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )
	
		def NthPreviousOccurrenceSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindPreviousNthSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		def FindNthPreviousSCS( n, pItem, nStart, pCaseSensitive )
			return This.FindNthPreviousOccurrenceCS( n, pItem, nStart, pCaseSensitive )

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence(n, pItem, nStart)
		return This.FindNthPreviousOccurrenceCS(n, pItem, nStart, TRUE)

		#< @FunctionAlternativeForms

		def FindPreviousNthOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def PreviousNthOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def NthPreviousOccurrence( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNth( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindNthPrevious( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		#--

		def FindNthPreviousOccurrenceS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNthOccurrenceS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def PreviousNthOccurrenceS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )
	
		def NthPreviousOccurrenceS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindPreviousNthS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )

		def FindNthPreviousS( n, pItem, nStart )
			return This.FindNthPreviousOccurrence( n, pItem, nStart )


		#>

	   #---------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF AN ITEM     #
	 #      STARTING AT A GIVEN POSITION           #
	#---------------------------------------------#

	def FindNextOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ 1, 2, 3, "*", 5, 6, "*", 8, 9 ])
		? o1.FindNext("*", :StartingAt = 4)
		#--> 7

		*/

		if CheckParams()

			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

		ok

		# Trying with a Ring-based solution first (efficient if the list is
		# made of strings or numbers and if the item is a string or number)

		nResult = @FindNextCS(This.Content(), "*", 1_000_000, pCaseSensitive)

		if nResult != -1
			return nResult

		else
		# Otherwise we rely on an advance Softanza solution, based on the
		# fact of stringifying the items of the list, and permitting the
		# finding of not only numbers and strings, but also lists and
		# named objects...

			nResult = This.SectionQ(pnStartingAt + 1, :Last).
				FindFirstCS(pItem, pCaseSensitive)
	
			if nResult != 0
				nResult += pnStartingAt
			ok

			return nResult
		ok

		#< @FunctionAlternativeForms

		def FindNextSCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		def NextOccurrenceCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		#--

		# Here I use _ to distinguish the function with FindNextOccurrencesCS(panPos,CS)
		def FindNextOccurrence_SCS(pItem, nStart, pCaseSensitive)
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		def NextOccurrence_SCS( pItem, nStart, pCaseSensitive )
			return This.FindNextOccurrenceCS(pItem, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pItem, nStart)
		nResult = This.FindNextOccurrenceCS(pItem, nStart, TRUE)
		return nResult

		#< @FunctionAlternativeForms

		def FindNext( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		def NextOccurrence( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		#--

		# Here I use _ to distinguish the function with FindNextOccurrences(panPos)
		def FindNextOccurrence_S(pItem, nStart)
			return This.FindNextOccurrence(pItem, nStart)

		def FindNextS( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		def NextOccurrence_S( pItem, nStart )
			return This.FindNextOccurrence(pItem, nStart)

		#>

	   #-------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF AN ITEM     #
	 #      STARTING FROM A GIVEN POSITION N           #
	#-------------------------------------------------#

	def FindPreviousOccurrenceCS(pItem, pnStartingAt, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzList([ 1, 2, 3, "*", 5, 6, "*", 8, 9 ])
		? o1.FindPrevious("*", :StartingAt = 7)
		#--> 7

		*/

		if CheckParams()

			if isList(pItem) and Q(pItem).IsOfNamedParam()
				pItem = pItem[2]
			ok
	
			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

		ok

		nResult = This.SectionQ(1, pnStartingAt - 1).
			FindLastCS(pItem, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def FindPreviousCS( pItem, nStart, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		def PreviousOccurrenceCS( pItem, nStart, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		#--

		def FindPreviousOccurrence_SCS(pItem, nStart, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		def FindPreviousSCS( pItem, nStart, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		def PreviousOccurrence_SCS( pItem, nStart, pCaseSensitive )
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		#==

		def FindPreviousItemCS(pITem, nStart, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		def FindPreviousItemSCS(pITem, nStart, pCaseSensitive)
			return This.FindPreviousOccurrenceCS(pItem, nStart, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pItem, nStart)
		return This.FindPreviousOccurrenceCS(pItem, nStart, TRUE)

		#< @FunctionAlternativeForms

		def FindPrevious( pItem, nStart )
			return This.FindPreviousOccurrence(pItem, nStart)

		def PreviousOccurrence( pItem, nStart )
			return This.FindPreviousOccurrence(pItem, nStart)

		#--

		def FindPreviousOccurrence_S(pItem, nStart)
			return This.FindPreviousOccurrence(pItem, nStart)

		def FindPreviousS( pItem, nStart )
			return This.FindPreviousOccurrence(pItem, nStart)

		def PreviousOccurrence_S( pItem, nStart )
			return This.FindPreviousOccurrence(pItem, nStart)

		#==

		def FindPreviousItem(pITem, nStart)
			return This.FindPreviousOccurrence(pItem, nStart)

		def FindPreviousItemS(pITem, nStart)
			return This.FindPreviousOccurrence(pItem, nStart)

		#>

	   #-----------------------------------------#
	  #   FINDING NEXT OCCURRENCES OF AN ITEM   #
	 #   STARTING AT A GIVEN POSITION          #
	#-----------------------------------------#

	def FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection = This.SectionQ(pnStartingAt, :LastItem)

		anPos = oSection.FindAllCS(pItem, pCaseSensitive)
		
		anResult = StzListOfNumbersQ(anPos).
			   AddToEachQ(pnStartingAt - 1 ).
			   Content()

		return anResult

		#< @FunctionAlternativeForms

		def NextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#--

		def FindNextOccurrencesSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		def NextOccurrencesSCS(pItem, pnStartingAt, pCaseSensitive)
			return This.FindNextOccurrencesCS(pItem, pnStartingAt, pCaseSensitive)

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrences(pItem, pnStartingAt)
		return This.FindNextOccurrencesCS(pItem, pnStartingAt, TRUE)

		#< @FunctionAlternativeForms

		def NextOccurrences(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		#--

		def FindNextOccurrencesS(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		def NextOccurrencesS(pItem, pnStartingAt)
			return This.FindNextOccurrences(pItem, pnStartingAt)

		#>

	   #---------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF AN ITEM   #
	 #   STARTING AT A GIVEN POSITION              #
	#---------------------------------------------#

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfItems()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		oSection = This.SectionQ(1, pnStartingAt)

		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPos

		#< @FunctionAlternativeForm

		def FindPreviousOccurrencesSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, TRUE)

		#< @FunctionAlternativeForm

		def FindPreviousOccurrencesS(pcSubStr, pnStartingAt)
			return This.FindPreviousOccurrences(pcSubStr, pnStartingAt)

		#>

	  #===================================================#
	 #   FINDING ALL ITEMS VERIFYING A GIVEN CONDITION   #
	#===================================================#

	def FindAllItemsW(pcCondition)

		/*
		pcCondition can only contain the @i and This[@i...] keywords.
		@NextItem, @PreviousItem, @item ans so on can not be used.

		This is always the better option to take if you want a more
		performant code.

		If you want to be more expressive and include them in your
		pccondition string, use FindWXT() instead. 

		WARNING

		We can't use this solution:

			anPos = This.YieldW('@position', pcCondition)
			return anPos

		because YieldW() uses the current function FindW() --> Stackoverfolw!
		*/

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		# Identifying the executable section

		nLen = len(@aContent)

		oCode = new stzCCode(pcCondition)

		aExecutableSection = oCode.ExecutableSection()
		nStart = aExecutableSection[1]
		nEnd   = aExecutableSection[2]

		#WARNING: Very important check!
		# Read explanation in the stzCCode file --> ExectutableSection() method
		#TODO
		# check that this is done for all places where
		# ExecutableSection() is used in the library

		if isString(nEnd) and nEnd = :last
			nEnd = nLen
		ok

		if nEnd < 0
			nEnd += nLen
		but nEnd = :Last
			nEnd = nLen
		ok

		# Composing the code to be evaluated bu the loop

			#WARNING # Don't transpile conditional code in ..W() functions!
			# Only ...WXT() must contain Transpile() feature.
			# Therefore, the fellowing line is incorrect:
	
			# cCode = 'bOk = ( ' + StzCCodeQ(pcCondition).Transpiled() + ' )'
	
			# And you should put simply:

		cCode = 'bOk = (' + pcCondition + ' )'
? @@( This.Content() )
dfdf
		# Doing the job

		anResult = []

		for @i = nStart to nEnd

			#WARNING
			# You don't need to use any sophisticated keywords
			# like @item = @aContent[@i], since the code is
			# supposed to contain only @ and This[@i]-like keywords

			eval(cCode)
			if bOk
				anResult + @i
			ok
		next

		return anResult
		
		#< @FunctionAlternativeForms

		def FindAllW(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindW(pCondition)
			aResult = This.FindAllItemsW(pCondition)
			return aResult

		def FindWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindAllWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindAllItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindItemsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def FindItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def ItemsPositionsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def ItemsPositionsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsOfItemsW(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

		def PositionsOfItemsWhere(pCondition)
			return This.FindAllItemsW(pCondition)

	#>

	  #--------------------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#--------------------------------------------------------------#
	# Condditional code can contain keywords other then This[@i],
	# like @NextItem, @PreviousItem etc.

	def FindAllItemsWXT(pcCondition)
		
		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok

			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		# Identifying the executable section

		nLen = len(@aContent)

		oCode = new stzCCode(pcCondition)
		oCode.Transpile() # The sole difference with ..W() form of the function

		# Getting the bounds of the executable section

		aExecutableSection = oCode.ExecutableSection()
		nStart = aExecutableSection[1]
		nEnd   = aExecutableSection[2]

		if isString(nEnd) and nEnd = :last
			nEnd = nLen
		ok

		if nEnd < 0
			nEnd += nLen
		but nEnd = :Last
			nEnd = nLen
		ok

		# Composing the code to be evaluated by the loop

		cCode = 'bOk = (' + oCode.Content() + ' )'

		# Doing the job

		anResult = []

		for @i = nStart to nEnd

			#WARNING
			# You don't need to use any sophisticated keywords
			# like @item = @aContent[@i], since the code has
			# been already transpiled.

			eval(cCode)
			if bOk
				anResult + @i
			ok
		next

		return anResult
		
		#< @FunctionAlternativeForms

		def FindAllWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindAllWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindAllItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindItemsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def FindItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def ItemsPositionsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def ItemsPositionsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsOfItemsWXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

		def PositionsOfItemsWhereXT(pCondition)
			return This.FindAllItemsWXT(pCondition)

	#>

	  #--------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION  #
	#==================================================#

	def FindFirstW(pcCondition)
		return This.FindNthW(1, pcCondition)

		#< @FunctionAlternativeForms

		def FindFirstItemW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFirstOccurrenceW(pcCondition)
			return This.FindFirstW(pcCondition)

		#>

		#< @FunctionMisspelledForms

		def FindFristW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFristItemW(pcCondition)
			return This.FindFirstW(pcCondition)

		def FindFristOccurrenceW(pcCondition)
			return This.FindFirstW(pcCondition)

		#>

	  #-------------------------------------------------#
	 #  FINDING LAST ITEM VERIFYING A GIVEN CONDITION  #
	#-------------------------------------------------#

	def FindLastW(pcCondition) #TODO: Check for performance
		nLastW = This.NumberOfOccurrencesW(pcCondition)
		return FindNthW(nLastW , pcCondition)

		def FindLastItemW(pcCondition)
			return This.FindLastW(pcCondition)

		def FindLastOccurrenceW(pcCondition)
			return This.FindLastW(pcCondition)

	  #------------------------------------------------#
	 #  FINDING NTH ITEM VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------#

	def FindNthW(n, pcCondition)

		anTemp = This.FindW(pcCondition)
		nLen = len(anTemp)

		if isString(n)
			if ( n = :First or n = :FirstOccurrence )
				n = 1

			but ( n = :Last or n = :LastOccurrence )
				n = nLen
			ok
		ok

		nResult = 0

		if nLen > 0
			nResult = anTemp[n]
		ok

		return nResult

		def FindNthItemW(pcCondition)
			return This.FindNthW(n, pcCondition)

		def FindNthOccurrenceW(pcCondition)
			return This.FindNthW(n, pcCondition)

	  #------------------------------------------------------------#
	 #  FINDING NTH ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#------------------------------------------------------------#

	def FindNthWXT(n, pcCondition)

		anTemp = This.FindWXT(pcCondition)
		nLen = len(anTemp)

		if isString(n)
			if ( n = :First or n = :FirstOccurrence )
				n = 1

			but ( n = :Last or n = :LastOccurrence )
				n = nLen
			ok
		ok

		nResult = 0

		if nLen > 0
			nResult = anTemp[n]
		ok

		return nResult

		def FindNthItemWXT(pcCondition)
			return This.FindNthWXT(n, pcCondition)

		def FindNthOccurrenceWXT(pcCondition)
			return This.FindNthWXT(n, pcCondition)

	  #--------------------------------------------------------------#
	 #  FINDING FIRST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#--------------------------------------------------------------#

	def FindFirstWXT(pcCondition)
		return This.FindNthWXT(1, pcCondition)

		#< @FunctionAlternativeForms

		def FindFirstItemWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFirstOccurrenceWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		#>

		#< @FunctionMisspelledForms

		def FindFristWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFristItemWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		def FindFristOccurrenceWXT(pcCondition)
			return This.FindFirstWXT(pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING LAST ITEM VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#-------------------------------------------------------------#

	def FindLastWXT(pcCondition) #TODO # Check for performance
		n = This.NumberOfItemsWXT(pcCondition)
		return This.FindNthWXT(n, pcCondition)

		def FindLastItemWXT(pcCondition)
			return This.FindLastWXT(pcCondition)

		def FindLastOccurrenceWXT(pcCondition)
			return This.FindLastWXT(pcCondition)

	  #===================================================#
	 #  INFERING SECTION'S ITEMS FROM THE PROVIDED FORM  #
	#===================================================#

	/* NOTE

	For the mean time, this function is used to translate the section
	returned from the StzCCodeQ().ExecutableSection method, to fill
	it with the actual values of the current list.

	So, for example, if the lists has 10 items:

		--> [ 1, :Last ] is transformed to [ 1, 10 ]
		--> [ 2, -3 ] is transformed to [ 2, 7)
		--> Etc.

	TODO: In the future, it can be used to tranform all other forms used
	to create a section, sutch as [ :From = ..., :To = ... ].

	*/
	
	def InfereSection(paSection)
		aResult = []
		nStart = paSection[1]
		
		if nStart < 0
			nStart = This.NumberOfItems() - Abs(nStart) + 1
		ok

		nEnd = paSection[2]
		if isString(nEnd) and nEnd = :Last
			nEnd = This.NumberOfItems()
		ok

		if nEnd < 0
			nEnd = This.NumberOfItems() - Abs(nEnd) + 1
		ok

		aResult = [nStart, nEnd]
		return aResult

  	  #======================================#
	 #   GETTING ITEMS AT GIVEN POSITIONS   #
	#======================================#

	def ItemsAtPositions(panPos)
		if CheckParams()
			if NOT isList(panPos)
				StzRaise("incorrect param type! panPos must be a list.")
			ok

			nLen = len(panPos)
			for i = 1 to nLen
				if isString(panPos[i])
					if panPos[i] = :First or panPos[i] = :FirstPosition
						panPos[i] = 1
					but panPos[i] = :Last or panPos[i] = :LastPosition
						panOccurr[i] = This.NumberOfItemsCS(pCaseSensitive)
					ok
				ok
			next

			if NOT @IsListOfNumbers(panPos)
				StzRaise("Incorrect param type! panPos must be a list of numbers.")
			ok

		ok


		aResult = []
		nLen = len(panPos)
		aContent = This.List()

		for i = 1 to nLen
			aResult + aContent[panPos[i]]
		next

		return aResult

		#< @FunctionFluentForms

		def ItemsAtPositionsQ(panPos)
			return This.ItemsAtPositionsQR(panPos, :stzList)

		def ItemsAtPositionsQR(panPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsAtPositions(panPos) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsAtPositions(panPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsAtPositions(panPos) )

			on :stzListOfLists
				return new stzListOfLists( This.ItemsAtPositions(panPos) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsAtPositions(panPos) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsAtPositions(panPos) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsAtPositions(panPos) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllItemsAtPositions(panPos)
			return This.ItemsAtPositions(panPos)

		def ItemsAtThesePositions(panPos)
			return This.ItemsAtPositions(panPos)

		def AllItemsAtThesePositions(panPos)
			return This.ItemsAtPositions(panPos)

		def ItemsAt(panPos)
			return This.ItemsAtPositions(panPos)

		def AllItemsAt(panPos)
			return This.ItemsAtPositions(panPos)

		#>

	  #----------------------------------------------#
	 #   GETTING ITEMS OUTSIDE THE GIVEN POSITIONS  #
	#----------------------------------------------#

	def ItemsOutsidePositions(panPos)
		if NOT ( isList(panPos) and Q(panPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! panPos must be a list of numbers.")
		ok

		panPos = Q( 1 : This.NumberOfItems ) - These(panPos)
		aResult = This.ItemsAtPositions(panPos)

		return aResult

		#< @FunctionFluentForms

		def ItemsOutsidePositionsQ(panPos)
			return This.ItemsOutsidePositionsQR(panPos, :stzList)

		def ItemsOutsidePositionsQR(panPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsOutsidePositions(panPos) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsOutsidePositions(panPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsOutsidePositions(panPos) )

			on :stzListOfLists
				return new stzListOfLists( This.ItemsOutsidePositions(panPos) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsOutsidePositions(panPos) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsOutsidePositions(panPos) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsOutsidePositions(panPos) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllItemsOutsidePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsOutsideThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsOutsideThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsOutside(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsOutside(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsAtPositionsOtherThan(panPos)
			return This.ItemsOutsidePositions(panPos)

			def AllItemsAtPositionsOtherThen(panPos)
				return This.ItemsOutsidePositions(panPos)

		#--

		def AllItemsNotAtPositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsNotAtThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsNotAtThesePositions(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsNotAt(panPos)
			return This.ItemsOutsidePositions(panPos)

		def AllItemsNotAt(panPos)
			return This.ItemsOutsidePositions(panPos)

		def ItemsAtPositionsOtherThan(panPos)
			return This.ItemsOutsidePositions(panPos)

			def ItemsAtPositionsOtherThen(panPos)
				return This.ItemsOutsidePositions(panPos)

		#>

	  #===============================================#
	 #   GETTING ITEMS VERIFYING A GIVEN CONDITION   #
	#===============================================#

	/* #NOTE
	Note the semantic difference between "Getting" items, and "Finding" items.
		-> Getting items return the items themselves, while
		-> Finding items return their positions as numbers
		-> Their sections can also be found using FindAsSections() or simply FindZZ()
	*/

	def ItemsW(pcCondition)
		/* #WARNING

		Do not use this solution:

			return This.YieldW('@item', pcCondition)

		--> Stackoverflow!
		*/

		anPos = This.FindAllItemsW(pcCondition)
		aResult = This.ItemsAtThesePositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def ItemsWQ(pcCondition)
			return This.ItemsWQR(pcCondition, :stzList)

		def ItemsWQR(pcCondition, pcReturnType)
			if isList(pcCondition) and Q(pcCondition).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT (isString(pcReturnType) and Q(pcReturnType).IsStzType() )
				StzRaise("Incorrect param type! pcCondition must be a string containing a Softanza type.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsW(pcCondition) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsW(pcCondition) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsW(pcCondition) )
			
			on :stzListOfLists
				return new stzListOfLists( This.ItemsW(pcCondition) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsW(pcCondition) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsW(pcCondition) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsW(pcCondition) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def OnlyW(pcCondition)
			return This.ItemsW(pcCondition)

		#--

		def ItemsWhere(pcCondition)
			return This.ItemsW(pcCondition)
	
		def OnlyWhere(pcCondition)
			return This.ItemsW(pcCondition)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTINIG THE NTH ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------------------#

	def NthItemW(n, pcCondition)

		cResult = ItemsW(pcCondition)[n]
		return cResult

		#< @FunctionFluentForm

		def NthItemWQ(n, pCondition)
			item = This.NthItemW(n, pCondition)

			switch ring_type(item)
			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NthItemWhere(n, pcCondition)
			return This.NthItemW(n, pcCondition)

			def NthItemWhereQ(n, pcCondition)
				return This.NthItemWQ(n, pCondition)

		#>
		
	  #-------------------------------------------------------------------#
	 #  GETTINIG THE FIRST ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#-------------------------------------------------------------------#

	def FirstItemW(pCondition)
		return This.NthItemWhere(1, pCondition)

		#< @FunctionFluentForm

		def FirstItemWQ(pCondition)
			item = This.FirstItemW(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionMisspelledForm

		def FristItemW(pCondition)
			return This.FirstItemW(pCondition)

			def FristItemWQ(pCondition)
				return This.FirstItemWQ(pCondition)

		#>

	  #------------------------------------------------------------------#
	 #  GETTINIG THE LAST ITEM IN THE LIST VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------------------------#

	def LastItemW(pCondition)
		return This.ItemsW(pCondition)[ len(This.ItemsW(pCondition)) ]

		#< @FunctionFluentForm

		def LastItemWQ(pCondition)
			item = This.LastItemW(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

	  #----------------------------------------------------------#
	 #   GETTING ITEMS VERIFYING A GIVEN CONDITION -- EXTENDED  #
	#==========================================================#

	def ItemsWXT(pcCondition)

		anPos = This.FindAllItemsWXT(pcCondition)
		aResult = This.ItemsAtThesePositions(anPos)

		return aResult

		def ItemsWXTQ(pcCondition)
			return ItemsWXTQR(pcCondition, :stzList)

		def ItemsWXTQR(pcCondition, pcReturnType)
			if isList(pcCondition) and Q(pcCondition).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT (isString(pcReturnType) and Q(pcReturnType).IsStzType() )
				StzRaise("Incorrect param type! pcCondition must be a string containing a Softanza type.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.ItemsWXT(pcCondition) )

			on :stzListOfStrings
				return new stzListOfStrings( This.ItemsWXT(pcCondition) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.ItemsWXT(pcCondition) )
			
			on :stzListOfLists
				return new stzListOfLists( This.ItemsWXT(pcCondition) )

			on :stzListOfObjects
				return new stzListOfObjects( This.ItemsWXT(pcCondition) )

			on :stzListOfPairs
				return new stzListOfPairs( This.ItemsWXT(pcCondition) )

			on :stzListOfHashLists
				return new stzListOfHashLists( This.ItemsWXT(pcCondition) )

			other
				StzRaise("Unsupported return type!")
			off

			def OnlyWXT(pcCondition)
				return This.ItemsWXT(pcCondition)

			def OnlyWhereXT(pcCondition)
				return This.ItemsWXT(pcCondition)

	def NthItemWXT(n, pcCondition)

		cResult = ItemsWXT(pcCondition)[n]
		return cResult

		#< @FunctionFluentForm

		def NthItemWXTQ(n, pCondition)
			item = This.NthItemWXT(n, pCondition)

			switch ring_type(item)
			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NthItemWhereXT(n, pcCondition)
			return This.NthItemWXT(n, pcCondition)

			def NthItemWhereXTQ(n, pcCondition)
				return This.NthItemWXTQ(n, pCondition)

		#>
		
	def FirstItemWXT(pCondition)
		return This.NthItemWhereXT(1, pCondition)

		#< @FunctionFluentForm

		def FirstItemWXTQ(pCondition)
			item = This.FirstItemWXT(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

		#-- MISSPELLED

		def FristItemWXT(pCondition)
			return This.FirstItemWXT(pCondition)

			def FristItemWXTQ(pCondition)
				return This.FirstItemWXTQ(pCondition)

	def LastItemWXT(pCondition)
		return This.ItemsW(pCondition)[ len(This.ItemsWXT(pCondition)) ]

		#< @FunctionFluentForm

		def LastItemWXTQ(pCondition)
			item = This.LastItemWXT(pCondition)

			switch ring_type(item)

			on "NUMBER"
				return new stzNumber(item)

			on "STRING"
				return new stzString(item)

			on "LIST"
				return new stzList(item)

			on "OBJECT"
				return new stzObject(item)

			other
				StzRaise("Unsupported type!")
			off

		#>

	  #======================================================#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION   #
	#======================================================#

	def UniqueItemsW(pCondition)

		aResult = This.ItemsWQ(pCondition).ToSet()
		return aResult

		#< @FunctionFluentForm

		def UniqueItemsWQ(pCondition)
			return new stzList( This.UniqueItemsW(pCondition) )

		#>

		#< @FunctionAlternativeForms

		def UniqueItemsWhere(pCondition)
			return This.UniqueItemsW(pCondition)

			def UniqueItemsWhereQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		def ItemsWithoutDuplicationW(pCondition)
			return This.UniqueItemsW(pCondition)

			def ItemsWithoutDuplicationWQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		#--

		def ItemsWU(pCondition)
			return This.UniqueItemsW(pCondition)

			def ItemsWUQ(pCondition)
				return This.UniqueItemsWQ(pCondition)

		#>

	  #----------------------------------------------------------------------#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION -- WXT/EXTENSION  #
	#----------------------------------------------------------------------#

	def UniqueItemsWXT(pCondition)

		aResult = This.ItemsWXTQ(pCondition).ToSet()
		return aResult

		#< @FunctionFluentForm

		def UniqueItemsWXTQ(pCondition)
			return new stzList( This.UniqueItemsWXT(pCondition) )

		#>

		#< @FunctionAlternativeForms

		def UniqueItemsWhereXT(pCondition)
			return This.UniqueItemsWXT(pCondition)

			def UniqueItemsWhereXTQ(pCondition)
				return This.UniqueItemsWXTQ(pCondition)

		def ItemsWithoutDuplicationWXT(pCondition)
			return This.UniqueItemsWXT(pCondition)

			def ItemsWithoutDuplicationWXTQ(pCondition)
				return This.UniqueItemsWXTQ(pCondition)

		#--

		def ItemsWXTU(pCondition)
			return This.UniqueItemsWXTU(pCondition)

			def ItemsWXTUQ(pCondition)
				return This.UniqueItemsWXTUQ(pCondition)

		def ItemsWUXT(pCondition)
			return This.UniqueItemsWXTU(pCondition)

			def ItemsWUXTQ(pCondition)
				return This.UniqueItemsWXTUQ(pCondition)

		#>

	  #===============================================#
	 #   GETTING ALL ITEMS EXCEPT THE ONE PRPVIDED   #
	#===============================================#

	def AllItemsExceptCS(pItem, pCaseSensitive)
		aResult = This.ItemRemovedCS(pItem, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def AllItemsExcept(pItem)
		return This.AllItemsExceptCS(pItem, TRUE)

	  #================================================================================#
	 #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION ALONG WITH THEIR POSITIONS  #
	#================================================================================#

	def ItemsAndTheirPositionsW(pcCondition)
		/* Example
		o1 = new stzList([ "A", "m", "n", "B", "A", "x", "C", "z", "B" ])
		
		? o1.ItemsW('Q(@item).IsUppercase()')
		#--> [ "A", "B", "A", "C", "B" ]
		
		? o1.ItemsPositionsW('Q(@item).IsUppercase()') # Say also o1.FindItemsW(...)
		#--> [ 1, 4, 5, 7, 9 ]
		
		? o1.ItemsAndTheirPositionsW('Q(@item).IsUppercase()')
		#--> [ "A" = [1, 5], "B" = [4, 9], "C" = [7] ]
		*/

		aItems = This.ItemsW(pcCondition)
		anPos = This.FindItemsW(pcCondition)

		aPairs = StzListQ( aItems ).AssociatedWith( anPos )
	
		aUniqueItems = StzListQ(aItems).ToSet()

		aResult = []
		anItemPositions = []
		nLenUniqueItems = len(aUniqueItems)

		nLenAPairs = len(aPairs)

		for i = 1 to nLenUniqueItems
			pItem = aUniqueItems[i]
			
			for v = 1 to nLenAPairs
				aPair = aPairs[v]

				if ( isNumber(pItem) or isString(pItem) ) and
				   ( isNumber(aPair[1]) or isString(aPair[1]) )

					if aPair[1] = pItem
						anItemPositions + aPair[2]
					ok

				else
					if Q(aPair[1]).IsStrictlyEqualTo(pItem) # #TODO Check performance!
						anItemPositions + aPair[2]
					ok
				ok
			next
			
			aResult + [ pItem, anItemPositions ]
			anItemPositions = []

		next

		return aResult

		#< @FunctionAlternativeForms

		def ItemsAndTheirPositionsWhere(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWZ(pCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		#>

	   #======================================================#
	  #   GETTING UNIQUE ITEMS VERIFYING A GIVEN CONDITION 	 #
	 #   ALONG WITH THEIR POSITIONS -- EXTENDED             #
	#======================================================#

	def ItemsAndTheirPositionsWXT(pcCondition)
		/* #INFO
		This version is less performant then ItemsAndTheirPositionsW()
		but provides more features, like transpiling the conditional
		code, allowing us to compose more expressive conditions, usinf
		not only @i and This[@i]-like conditions, but also @Item,
		@CurrentItem, @NextItem, @PreviousItem, and so on.
		*/

		aItems = This.ItemsWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)

		aPairs = StzListQ( aItems ).AssociatedWith( anPos )
	
		aUniqueItems = StzListQ(aItems).ToSet()

		aResult = []
		anItemPositions = []
		nLenUniqueItems = len(aUniqueItems)

		nLenAPairs = len(aPairs)

		for i = 1 to nLenUniqueItems
			pItem = aUniqueItems[i]
			
			for v = 1 to nLenAPairs
				aPair = aPairs[v]

				if ( isNumber(pItem) or isString(pItem) ) and
				   ( isNumber(aPair[1]) or isString(aPair[1]) )
					if aPair[1] = pItem
						anItemPositions + aPair[2]
					ok

				else
					if Q(aPair[1]).IsStrictlyEqualTo(pItem) # #TODO Check performance!
						anItemPositions + aPair[2]
					ok
				ok
			next
			
			aResult + [ pItem, anItemPositions ]
			anItemPositions = []

		next

		return aResult

		#< @FunctionAlternativeForms

		def ItemsAndTheirPositionsWhereXT(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWXTUZ(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		def ItemsWUXTZ(pcCondition)
			return This.ItemsAndTheirPositionsW(pcCondition)

		#>

	  #=================================#
	 #   GETTING ITEMS OF TYPE NUMBER  #
	#=================================#

	def NumberOfNumbers()
		return len( This.Numbers() )

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumers()
			return This.NumberOfNumbers()

		def HowManyNumer()
			return This.NumberOfNumbers()

	def FindNumbers()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindNumbersZ()
			return This.FindNumbers()

	def FindNumbersAsSections()
		aContent = This.Copy().Content() + "X"
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isNumber(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isNumber(aContent[i]) and NOT isNumber(aContent[i-1])
				n1 = i
			ok

			if isNumber(aContent[i]) and NOT isNumber(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindNumbersZZ()
			return This.FindNumbersAsSections()
		
	def Numbers()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isNumber(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def NumbersQ()
			return This.NumbersQR(:stzList)

		def NumbersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyNumbers()
			return This.Numbers()

			def OnlyNumbersQ()
				return This.OnlyNumbersQR(:stzList)
	
			def OnlyNumbersQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNumbers() )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.OnlyNumbers() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	def FindNumber(paNumber) # Add case sensitivity

		if CheckParams()
			if NOT isNumber(paNumber)
				StzRaise("Incorrect param type! paNumber must be a list.")
			ok
		ok

		anPos = Q(This.Numbers()).Find(paNumber)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindNumbers()).ItemsAtPositions(anPos)
		ok

		return anResult

	def NumberZ(paNumber)
		if CheckParams()
			if NOT isNumber(paNumber) 
				StzRaise("Incorrect param type! paNumber must be a list.")
			ok
		ok

		anPos = This.FindNumber(paNumber)
		aResult = [ paNumber, anPos ]	
		return aResult

	def FindTheseNumbers(paNumbers)
		if CheckParams()
			if NOT ( isNumber(paNumbers) and Q(paNumbers).IsNumberOfNumbers() )
				StzRaise("Incorrect param type! paNumbers must be a list of lists.")
			ok
		ok

		paNumbers = U(paNumbers) # Duplicates removed
		nLen = len(paNumbers)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindNumber(paNumbers[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseNumbersZ(paNumbers)
		if CheckParams()
			if NOT ( isNumber(paNumbers) and Q(paNumbers).IsNumberOfNumbers() )
				StzRaise("Incorrect param type! paNumbers must be a list of lists.")
			ok
		ok

		nLen = len(paNumbers)
		aResult = []

		for i = 1 to nLen
			aResult + [ paNumbers[i], This.FindNumber(paNumbers[i]) ]
		next

		return aResult

	  #----------------------------------#
	 #   REMOVING ITEMS OF TYPE NUMBER  #
	#----------------------------------#

	def RemoveNumbers()
		This.RemoveItemsAtPositions( This.FindNumbers() )

		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

		def RemoveOnlyNumbers()
			This.RemoveNumbers()

			def RemoveOnlyNumbersQ()
				This.RemoveOnlyNumbers()
				return This

	def NumbersRemoved()
		aResult = This.Copy().RemoveNumbersQ().Content()
		return aResult

	  #-------------------------------------------#
	 #  GETTING THE NUMBERS AND THEIR POSITIONS  #
	#-------------------------------------------#

	def NumbersZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NumbersAndTheirPositions()
			return This.NumbersZ()

		def NumbersAndPositions()
			return This.NumbersZ()

	  #----------------------------------------#
	 #   GETTING ITEMS WHICH ARE NOT NUMBERS  #
	#========================================#

	def FindNonNumbers()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if NOT isNumber(aContent[i])
				aResult + i
			ok
		next
		
		return aResult	

	def NonNumbers()
		aResult = This.ItemsAtPositions( This.FindNonNumbers() )
		return aResult

		def NonNumbersQ()
			return This.NonNumbersQR(:stzList)

		def NonNumbersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonNumbers() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NonNumbers() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonNumbers()
			return This.NonNumbers()

			def OnlyNonNumbersQ()
				return This.OnlyNonNumbersQR(:stzList)
	
			def OnlyNonNumbersQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonNumbers() )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.OnlyNonNumbers() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #-----------------------------------------#
	 #   REMOVING ITEMS WHICH ARE NOT NUMBERS  #
	#-----------------------------------------#

	def RemoveNonNumbers()
		This.RemoveItemsAtPositions( This.FindNonNumbers() )

		def RemoveNonNumbersQ()
			This.RemoveNonNumbers()
			return This

		def RemoveOnlyNonNumbers()
			This.RemoveNonNumbers()

			def RemoveOnlyNonNumbersQ()
				This.RemoveOnlyNonNumbers()
				return This

		def RemoveAllExceptNumbers()
			This.RemoveNonNumbers()

			def RemoveAllExceptNumbersQ()
				This.RemoveAllExceptNumbers()
				return This
		
	def NonNumbersRemoved()
		aResult = This.Copy().RemoveNonNumbersQ().Content()
		return aResult

	  #-----------------------------------------------#
	 #  GETTING THE NON-NUMBERS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def NonNumbersZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isNumber(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonNumbersAndTheirPositions()
			return This.NonNumbersZ()

		def NonNumbersAndPositions()
			return This.NonNumbersZ()

	  #==============================================#
	 #   GETTING THE STRINGS CONTAINED IN THE LIST  #
	#==============================================#

	def NumberOfStrings()
		return len( This.Strings() )

		def CountStrings()
			return This.NumberOfStrings()

		def HowManyStrings()
			return This.NumberOfStrings()

		def HowManyString()
			return This.NumberOfStrings()

	def FindStrings()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindStringsZ()
			return This.FindStrings()

	def FindStringsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isString(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isString(aContent[i]) and NOT isString(aContent[i-1])
				n1 = i
			ok

			if isString(aContent[i]) and NOT isString(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindStringsZZ()
			return This.FindStringsAsSections()

	def Strings()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isString(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def StringsQ()
			return This.StringsQR(:stzList)

		def StringsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Strings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Strings() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyStrings()
			return This.Strings()

			def OnlyStringsQ()
				return This.OnlyStringsQR(:stzList)
	
			def OnlyStringsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyStrings() )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.OmlyStrings() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	#TODO
	# Add NumbersU(), ListsU() and ObjectsU()

	def StringsU()
		#TODO
		# Add caseSensitivity
	
		aContent = This.Content()
		nLen = len(aContent)
		acResult = []

		for i = 1 to nLen
			if isString(aContent[i]) and ring_find(acResult,aContent[i]) = 0
				acResult + aContent[i]
			ok
		next

		return acResult

		def StringsUQ()
			return new stzList( This.StringsU() )	

	def FindString(paString) # Add case sensitivity

		if CheckParams()
			if NOT isString(paString)
				StzRaise("Incorrect param type! paString must be a list.")
			ok
		ok

		anPos = Q(This.Strings()).Find(paString)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindStrings()).ItemsAtPositions(anPos)
		ok

		return anResult

	def StringZ(paString)
		if CheckParams()
			if NOT isString(paString) 
				StzRaise("Incorrect param type! paString must be a list.")
			ok
		ok

		anPos = This.FindString(paString)
		aResult = [ paString, anPos ]	
		return aResult

	def FindTheseStrings(paStrings)
		if CheckParams()
			if NOT ( isString(paStrings) and Q(paStrings).IsStringOfStrings() )
				StzRaise("Incorrect param type! paStrings must be a list of lists.")
			ok
		ok

		paStrings = U(paStrings) # Duplicates removed
		nLen = len(paStrings)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindString(paStrings[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseStringsZ(paStrings)
		if CheckParams()
			if NOT ( isString(paStrings) and Q(paStrings).IsStringOfStrings() )
				StzRaise("Incorrect param type! paStrings must be a list of lists.")
			ok
		ok

		nLen = len(paStrings)
		aResult = []

		for i = 1 to nLen
			aResult + [ paStrings[i], This.FindString(paStrings[i]) ]
		next

		return aResult

	  #-------------------------------------#
	 #   REMOVING ITEMS WHICH ARE STRINGS  #
	#-------------------------------------#

	def RemoveStrings()

		This.RemoveItemsAtThesePositions(This.FindStrings())

		def RemoveStringsQ()
			This.RemoveStrings()
			return This

		def RemoveOnlyStrings()
			This.RemoveStrings()

			def RemoveOnlyStringsQ()
				This.RemoveOnlyStrings()
				return This

	  #-------------------------------------------#
	 #  GETTING THE STRINGS AND THEIR POSITIONS  #
	#-------------------------------------------#

	def StringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def StringsAndTheirPositions()
			return This.StringsZ()

		def StringsAndPositions()
			return This.StringsZ()

	  #----------------------------------------#
	 #   GETTING ITEMS WHICH ARE NOT STRING   #
	#========================================#

	def FindNonStrings()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isString(aContent[i])
				anResult + i
			ok
		next
		
		return anResult		

	def NonStrings()
		aResult = This.ItemsAtPositions( This.FindNonStrings() )
		return aResult	

		def NonStringsQ()
			return This.NonStringsQR(:stzList)

		def NonStringsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.NonStrings() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonStrings()
			return This.NonStrings()

			def OnlyNonStringsQ()
				return This.OnlyNonStringsQR(:stzList)
	
			def OnlyNonStringsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonStrings() )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.OnlyNonStrings() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #-----------------------------------------------#
	 #  GETTING THE NON-STRINGS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def NonStringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonStringsAndTheirPositions()
			return This.NonStringsZ()

		def NonStringsAndPositions()
			return This.NonStringsZ()

	  #-----------------------------------------#
	 #   REMOVING ITEMS WHICH ARE NOT STRINGS  #
	#-----------------------------------------#

	def RemoveNonStrings()
		This.RemoveItemsAtPositions( This.FindNonStrings() )

		def RemoveNonStringsQ()
			This.RemoveNonStrings()
			return This

		def RemoveOnlyNonStrings()
			This.RemoveNonStrings()

			def RemoveOnlyNonStringsQ()
				This.RemoveOnlyNonStrings()
				return This

		def RemoveAllExceptStrings()
			This.RemoveNonStrings()

			def RemoveAllExceptStringsQ()
				This.RemoveAllExceptStrings()
				return This

	def NonStringsRemoved()
		acResult = This.Copy().RemoveNonStringsQ().Content()
		return acResult

	  #=================================================#
	 #  LOWERCASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def LowercaseStrings()
		aContent = This.Content()

		for i = 1 to This.NumberOfItems()

			if isString(aContent[i])
				cStrLow = Q(aContent[i]).Lowercased()
				This.ReplaceAt(i, cStrLow)
			ok
		next

		def LowercaseStringsQ()
			This.LowercaseStrings()
			return This

		def Lowercase()
			This.LowercaseStrings()

			def LowercaseQ()
				This.Lowercase()
				return This

		def ApplyLowercase()
			This.LowercaseStrings()

			def ApplyLowercaseQ()
				This.ApplyLowercase()
				return This

	def ListWithStringsLowercased()
		aResult = This.Copy().LowercaseStringsQ().Content()
		return aResult

		def Lowercased()
			return This.ListWithStringsLowercased()

	def StringsLowercased()
		aResult = []
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrLow = Q(aContent[i]).Lowercased()
				aResult + cStrLow
			ok
		next

		return aResult

	  #=================================================#
	 #  UPPERCASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def UppercaseStrings()
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen
			
			if isString(aContent[i])
				cStrUpp = Q(aContent[i]).Uppercased()
				This.ReplaceAt(i, cStrUpp)
			ok
		next

		def UppercaseStringsQ()
			This.UppercaseStrings()
			return This

		def Uppercase()
			This.UppercaseStrings()

			def UppercaseQ()
				This.Uppercase()
				return This

		def ApplyUppercase()
			This.UppercaseStrings()

			def ApplyUppercaseQ()
				This.ApplyUppercase()
				return This

	def ListWithStringsUppercased()
		aResult = This.Copy().UppercaseStringsQ().Content()
		return aResult

		def Uppercased()
			return This.ListWithStringsUppercased()

	def StringsUppercased()
		aResult = []
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrUpp = Q(aContent[i]).Uppercased()
				aResult + cStrUpp
			ok
		next

		return aResult
	
	  #=================================================#
	 #  TITLECASING THE STRINGS CONTAINED IN THE LIST  #
	#=================================================#

	def TitlecaseStrings()
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrTtl = Q(aContent[i]).Titlecased()
				This.ReplaceAt(i, cStrTtl)
			ok
		next

		def TitlecaseStringsQ()
			This.TitlecaseStrings()
			return This

		def Titlecase()
			This.TitlecaseStrings()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def ApplyTitlecase()
			This.TitlecaseStrings()

			def ApplyTitlecaseQ()
				This.ApplyTitlecase()
				return This

	def ListWithStringsTitlecased()
		aResult = This.Copy().TitlecaseStringsQ().Content()
		return aResult

		def Titlecased()
			return This.ListWithStringsTitlecased()

	def StringsTitlecased()
		aResult = []
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrTtl = Q(aContent[i]).Titlecased()
				aResult + cStrTtl
			ok
		next

		return aResult

	  #==================================================#
	 #  CAPITALIZING THE STRINGS CONTAINED IN THE LIST  #
	#==================================================#

	def CapitaliseStrings()
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen
			
			if isString(aContent[i])
				cStrCap = Q(aContent[i]).Capitalised()
				This.ReplaceAt(i, cStrCap)
			ok
		next

		def CapitaliseStringsQ()
			This.CapitaliseStrings()
			return This

		def CapitalizeStrings()
			This.CapitaliseStrings()

			def CapitalizeStringsQ()
				This.CapitalizeStrings()
				return This

		def Capitalise()
			This.CapitaliseStrings()

			def CapitaliseQ()
				This.CapitaliseStrings()
				return This

		def Capitalize()
			This.CapitalizeStrings()

			def CapitalizeQ()
				This.Capitalize()
				return This

		def ApplyCapitalcase()
			This.CapitalizeStrings()

			def ApplyCapitalcaseQ()
				This.ApplyCapitalcase()
				return This

	def ListWithStringsCapitalised()
		aResult = This.Copy().CapitaliseStringsQ().Content()
		return aResult

		def ListWithStringsCapitalized()
			return This.ListWithStringsCapitalised()

		def Capitalised()
			return This.ListWithStringsCapitalised()

		def Capitalized()
			return This.ListWithStringsCapitalised()

	def StringsCapitalised()
		aResult = []
		aContent = This.Content()
		nLen = This.NumberOfItems()

		for i = 1 to nLen

			if isString(aContent[i])
				cStrCap = Q(aContent[i]).Capitalised()
				aResult + cStrCap
			ok
		next

		return aResult

		def StringsCapitalized()
			return This.StringsCapitalised()

	#----

	def LowercaseListsOfStrings()
		for item in This.List()
			if isList(item) and Q(item).IsListOfStrings()
				item = StzListOfStringsQ(item).Lowercased()
			ok
		next

		def LowercaseListsOfStringsQ()
			This.LowercaseListsOfStrings()
			return This

	def ListsOfStringsLowercased()
		return This.Copy().LowercaseListsOfStringsQ().Content()

	#----

	def UppercaseListsOfStrings()
		for item in This.List()
			if isList(item) and Q(item).IsListOfStrings()
				item = StzListOfStringsQ(item).Uppercased()
			ok
		next

		def UppercaseListsOfStringsQ()
			This.LowercaseListsOfStrings()
			return This

	def ListsOfStringsUppercased()
		return This.Copy().UppercaseListsOfStringsQ().Content()

	  #-==============================================#
	 #     GETTING & REMOVING ITEMS OF TYPE LIST     #
	#===============================================#

	def NumberOfLists()
		return len( This.Lists() )

		def CountLists()
			return This.NumberOfLists()

		def HowManyLists()
			return This.NumberOfLists()

		def HowManyList()
			return This.NumberOfLists()

	  #---------------------------------------#
	 #  GETTING THE LISTS ITEMS IN THE LIST  #
	#---------------------------------------#

	def Lists()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isList(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ListsQ()
			return This.ListsQR(:stzList)

		def ListsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Lists() )

			on :stzListOfLists
				return new stzListOfLists( This.Lists() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyLists()
			return This.Lists()

			def OnlyListsQ()
				return This.OnlyListsQR(:stzList)
	
			def OnlyListsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyLists() )
	
				on :stzListOfLists
					return new stzListOfLists( This.OnlyLists() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	  #----------------------------------#
	 #  FINDING THE LISTS IN THE LISTS  #
	#----------------------------------#

	def FindLists()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

		def FindListsZ()
			return This.FindLists()

	def FindListsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isList(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isList(aContent[i]) and NOT isList(aContent[i-1])
				n1 = i
			ok

			if isList(aContent[i]) and NOT isList(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindListsZZ()
			return This.FindListsAsSections()

	def FindList(paList) # Add case sensitivity

		if CheckParams()
			if NOT isList(paList)
				StzRaise("Incorrect param type! paList must be a list.")
			ok
		ok

		anPos = Q(This.Lists()).Find(paList)
		anResult = []
		if len(anPos) > 0 
			anResult = Q(This.FindLists()).ItemsAtPositions(anPos)
		ok

		return anResult

	def ListZ(paList)
		if CheckParams()
			if NOT isList(paList) 
				StzRaise("Incorrect param type! paList must be a list.")
			ok
		ok

		anPos = This.FindList(paList)
		aResult = [ paList, anPos ]	
		return aResult

	def FindTheseLists(paLists)
		if CheckParams()
			if NOT ( isList(paLists) and Q(paLists).IsListOfLists() )
				StzRaise("Incorrect param type! paLists must be a list of lists.")
			ok
		ok

		paLists = U(paLists) # Duplicates removed
		nLen = len(paLists)
		anResult = []

		for i = 1 to nLen
			anPos = This.FindList(paLists[i])
			nLenPos = len(anPos)

			for j = 1 to nLenPos
				anResult + anPos[j]
			next
		next

		anResult = ring_sort(anResult)
		return anResult

	def TheseListsZ(paLists)
		if CheckParams()
			if NOT ( isList(paLists) and Q(paLists).IsListOfLists() )
				StzRaise("Incorrect param type! paLists must be a list of lists.")
			ok
		ok

		nLen = len(paLists)
		aResult = []

		for i = 1 to nLen
			aResult + [ paLists[i], This.FindList(paLists[i]) ]
		next

		return aResult

	  #--------------------------------------------#
	 #  REMOVING THE LISTS CONTAINED IN THE LIST  #
	#--------------------------------------------#

	def RemoveLists()
		anPos = This.FindLists()
		This.RemoveItemsAtThesePositions(anPos)

		def RemoveListsQ()
			This.RemoveLists()
			return This

		def RemoveOnlyLists()
			This.RemoveLists()

			def RemoveOnlyListsQ()
				This.RemoveOnlyLists()
				return This

	def ListsRemoved()
		aResult = This.Copy().RemoveListsQ().Content()
		return aResult

	  #-----------------------------------------#
	 #  GETTING THE /SS AND THEIR POSITIONS  #
	#-----------------------------------------#

	def ListsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isList(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def ListsAndTheirPositions()
			return This.ListsZ()

		def ListsAndPositions()
			return This.ListsZ()


	  #-------------------------------------------------#
	 #  GETTING THE SIZE OF EACH ITEM WHICH IS A LIST  #
	#=================================================#

	def ListsNumberOfItems()
		aResult = []
		for item in This.List()
			if isList(item)
				aResult + len(item)
			ok
		next
		return aResult
		
		def ListsSizes()
			return This.ListsNumberOfItems()

		def NumberOfItemsOfEachList()
			return This.ListsNumberOfItems()

		def SizeOfEachList()
			return This.ListsNumberOfItems()


	def ListsHaveSameNumberOfItems()
		bResult = TRUE
		for i=2 to len( This.Sublists() )
			if len( This.Sublists()[i] ) != len( This.Sublists()[i-1] )
				bResult = FALSE
			ok
		next
		return bResult

		def ListsHaveSameSize()
			return This.ListsHaveSameNumberOfItems()

	def ListsAtAnyLevelHaveSameNumberOfItems()
		bResult = TRUE
		for i=2 to len( This.listsAtAnyLevel() )
			if len( This.listsAtAnyLevel()[i] ) != len( This.listsAtAnyLevel()[i-1] )
				bResult = FALSE
			ok
		next
		return bResult

		def ListsAtAnyLevelHaveSameSize()
			return This.ListsAtAnyLevelHaveSameNumberOfItems()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF NUMBERS IN THE LIST  #
	#============================================#

	def FindListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF NUMBERS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfNumbers()
			return This.NumberOfListsOfNumbers()

		def HowManyListOfNumbers()
			return This.NumberOfListsOfNumbers()

		def CountListsOfNumbers()
			return This.NumberOfListsOfNumbers()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfNumbers(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForms

		def ListsOfNumbersQ()
			return new stzList(This.ListsOfNumbers())

		def ListOfNumbersQQ()
			return new stzListOfNumbers(This.ListsOfNumbers())

		def ListOfNumbersQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfNumbers())

			on :stzListOfNumbers
				return new stzListOfNumbers(This.ListsOfNumbers())

			other
				StzRaise("Insupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfNumbers()
			return This.ListsOfNumbers()

			def OnlyListsOfNumbersQ()
				return This.ListsOfNumbersQ()

			def OnlyListsOfNumbersQQ()
				return This.ListOfNumbersQQ()

			def OnlyListsOfNumbersQR(pcReturnType)
				return This.ListOfNumbersQR(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfNumbers()
		aResult = @WithoutDupplication(This.ListsOfNumbers())
		return aResult

		def ListsOfNumbersU()
			return This.UniqueListsOfNumbers()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF NUMBERS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfNumbersZ()
		aListsU = This.UniqueListsOfNumbers()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfNumbersZ()
			return This.ListsOfNumbersZ()

		def ListsOfNumbersAndTheirPositions()
			return This.ListsOfNumbersZ()

		def OnlyListsOfNumbersAndTheirPositions()
			return This.ListsOfNumbersZ()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF STRINGS IN THE LIST  #
	#============================================#

	def FindListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF STRINGS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfStrings()
			return This.NumberOfListsOfStrings()

		def HowManyListOfStrings()
			return This.NumberOfListsOfStrings()

		def CountListsOfStrings()
			return This.NumberOfListsOfStrings()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfStrings()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfStrings(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfStringsQ()
			return new stzList(This.ListsOfStrings())

		def ListOfStringsQQ()
			return new stzListOfStrings(This.ListsOfStrings())

		def ListOfStringsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfStrings())

			on :stzListOfStrings
				return new stzListOfStrings(This.ListsOfStrings())

			other
				StzRaise("Insupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfStrings()
			return This.ListsOfStrings()

			def OnlyListsOfStringsQ()
				return This.ListsOfStringsQ()

			def OnlyListsOfStringsQQ()
				return This.ListOfStringsQQ()

			def OnlyListsOfStringsQR(pcReturnType)
				return This.ListOfStringsQR(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfStrings()
		aResult = @WithoutDupplication(This.ListsOfStrings())
		return aResult

		def ListsOfStringsU()
			return This.UniqueListsOfStrings()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF STRINGS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfStringsZ()
		aListsU = This.UniqueListsOfStrings()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfStringsZ()
			return This.ListsOfStringsZ()

		def ListsOfStringsAndTheirPositions()
			return This.ListsOfStringsZ()

		def OnlyListsOfStringsAndTheirPositions()
			return This.ListsOfStringsZ()

	  #------------------------------------------#
	 #  FINDING THE LISTS OF LISTS IN THE LIST  #
	#==========================================#

	def FindListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF LISTS IN THE LIST  #
	#----------------------------------------------------#

	def NumberOfListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfLists()
			return This.NumberOfListsOfLists()

		def HowManyListOfLists()
			return This.NumberOfListsOfLists()

		def CountListsOfLists()
			return This.NumberOfListsOfLists()

	  #------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST  #
	#------------------------------------------#

	def ListsOfLists()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfLists(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfListsQ()
			return new stzList(This.ListsOfLists())

		def ListOfListsQQ()
			return new stzListOfLists(This.ListsOfLists())

		def ListOfListsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfLists())

			on :stzListOfLists
				return new stzListOfLists(This.ListsOfLists())

			other
				StzRaise("Insupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfLists()
			return This.ListsOfLists()

			def OnlyListsOfListsQ()
				return This.ListsOfListsQ()

			def OnlyListsOfListsQQ()
				return This.ListOfListsQQ()

			def OnlyListsOfListsQR(pcReturnType)
				return This.ListOfListsQR(pcReturnType)

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST WITHOUT DUPPLICATION  #
	#---------------------------------------------------------------#

	def UniqueListOfLists()
		aResult = @WithoutDupplication(This.ListsOfLists())
		return aResult

		def ListsOfListsU()
			return This.UniqueListsOfLists()

	  #---------------------------------------------------------------------#
	 #  GETTING THE LISTS OF LISTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#---------------------------------------------------------------------#

	def ListsOfListsZ()
		aListsU = This.UniqueListsOfLists()
		nLenU = len(aListsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aListsU[i])
			aResult + [ aListsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfListsZ()
			return This.ListsOfListsZ()

		def ListsOfListsAndTheirPositions()
			return This.ListsOfListsZ()

		def OnlyListsOfListsAndTheirPositions()
			return This.ListsOfListsZ()

	  #--------------------------------------------#
	 #  FINDING THE LISTS OF OBJECTS IN THE LIST  #
	#============================================#

	def FindListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				anResult + i
			ok
		next

		return anResult

	  #------------------------------------------------------#
	 #  GETTING THE NUMBER OF LISTS OF OBJECTS IN THE LIST  #
	#------------------------------------------------------#

	def NumberOfListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		nResult = 0

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				nResult++
			ok
		next

		return nResult

		def HowManyListsOfObjects()
			return This.NumberOfListsOfObjects()

		def HowManyListOfObjects()
			return This.NumberOfListsOfObjects()

		def CountListsOfObjects()
			return This.NumberOfListsOfObjects()

	  #--------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST  #
	#--------------------------------------------#

	def ListsOfObjects()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isList(aContent[i]) and @IsListOfObjects(aContent[i])
				aResult + aContent[i]
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def ListsOfObjectsQ()
			return new stzList(This.ListsOfObjects())

		def ListOfObjectsQQ()
			return new stzListOfObjects(This.ListsOfObjects())

		def ListOfObjectsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.ListsOfObjects())

			on :stzListOfObjects
				return new stzListOfObjects(This.ListsOfObjects())

			other
				StzRaise("Insupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyListsOfObjects()
			return This.ListsOfObjects()

			def OnlyListsOfObjectsQ()
				return This.ListsOfObjectsQ()

			def OnlyListsOfObjectsQQ()
				return This.ListOfObjectsQQ()

			def OnlyListsOfObjectsQR(pcReturnType)
				return This.ListOfObjectsQR(pcReturnType)

		#>

	  #-----------------------------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST WITHOUT DUPPLICATION  #
	#-----------------------------------------------------------------#

	def UniqueListOfObjects()
		aResult = @WithoutDupplication(This.ListsOfObjects())
		return aResult

		def ListsOfObjectsU()
			return This.UniqueListsOfObjects()

	  #-----------------------------------------------------------------------#
	 #  GETTING THE LISTS OF OBJECTS IN THE LIST ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------#

	def ListsOfObjectsZ()
		aoObjectsU = This.UniqueListsOfObjects()
		nLenU = len(aoObjectsU)

		aResult = []

		for i = 1 to nLenU
			anPos = This.FindAll(aoObjectsU[i])
			aResult + [ aoObjectsU[i], anPos ]
		next

		return aResult

		def OnlyListsOfObjectsZ()
			return This.ListsOfObjectsZ()

		def ListsOfObjectsAndTheirPositions()
			return This.ListsOfObjectsZ()

		def OnlyListsOfObjectsAndTheirPositions()
			return This.ListsOfObjectsZ()

	  #===============================================#
	 #  GETTING THE NUMBERS AND STRINGS IN THE LIST  #
	#===============================================#

	def FindNumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + i
			ok
		next

		return aResult

		def FindStringsAndNumbers()
			return This.FindNumbersAndStrings()

	def NumbersAndStrings()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		def StringsAndNumbers()
			return This.NumbersAndStrings()

	def NumbersAndStringsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isNumber(aContent[i]) or isString(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def StringsAndNumbersZ()
			return This.NumberAndStringsZ()

	def RemoveNumbersAndStrings()
		This.RemoveItemsAtPositions( This.FindNumbersAndStrings() )

		def RemoveStringsAndNumbers()

	def NumbersAndStringsRemoved()
		aResult = This.Copy().RemoveNumbersAndStringsQ().Content()
		return aResult

		def StringsAndNumbersRemoved()
			return This.NumbersAndStringsRemoved()

	  #=====================================#
	 #  GETTING THE NON-LISTS IN THE LIST  #
	#=====================================#

	def FindNonLists()
		aContent = This.Content()
		nLen = len(acontent)
		aResult = []

		for i = 1 to nLen
			if NOT isList(aContent[i])
				aResult + i
			ok
		next
		
		return aResult		

	def NonLists()
		aResult = This.ItemsAtPositions( This.FindNonLists() )
		return aResult		

		def NonListsQ()
			return This.NonListsQR(:stzList)

		def NonListsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NonLists() )

			on :stzListOfLists
				return new stzListOfLists( This.NonLists() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonLists()
			return This.NonLists()

			def OnlyNonListsQ()
				return This.OnlyNonListsQR(:stzList)
	
			def OnlyNonListsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.OnlyNonLists() )
	
				on :stzListOfLists
					return new stzListOfLists( This.OnlyNonLists() )
	
				other
					StzRaise("Unsupported return type!")
				off

	  #------------------------------------#
	 #  REMOVING NON LISTS FROM THE LIST  #
	#------------------------------------#

	def RemoveNonLists()
		anPos = This.FindNonLists()
		This.RemoveItemsAtThesePositions(anPos)

		def RemoveNonListsQ()
			This.RemoveNonLists()
			return This

		def RemoveOnlyNonLists()
			This.RemoveNonLists()

			def RemoveOnlyNonListsQ()
				This.RemoveOnlyNonLists()
				return This

		def RemoveAllExceptLists()
			This.RemoveNonLists()

			def RemoveAllExceptListsQ()
				This.RemoveAllExceptLists()
				return This

	def NonListsRemoved()
		aResult = This.Copy().RemoveNonListsQ().Content()
		return aResult

	  #---------------------------------------------#
	 #  GETTING THE NON-LISTS AND THEIR POSITIONS  #
	#---------------------------------------------#

	def NonListsZ()
		aContent = This.Content()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isList(aContent[i])
				aResult + [ aContent[i], i ]
			ok
		next

		return aResult

		def NonListsAndTheirPositions()
			return This.NonListsZ()

		def NonListsAndPositions()
			return This.NonListsZ()

	  #=================================================#
	 #     GETTING & REMOVING ITEMS OF TYPE OBJECT     #
	#=================================================#

	def NumberOfObjects()
		return len( This.Objects() )

		def CountObjecs()
			return This.NumberOfObjects()

		def HowManyObjects()
			return This.NumberOfObjects()

		def HowManyObject()
			return This.NumberOfObjects()


	def Objects()
		/* WARNING

		Do not use this solution:

			return This.ItemsW('isObject(@item)')

		#--> Stackovervlow!
		*/

		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		#< @FunctionFluentForm

		def ObjectsQ()
			return This.ObjectsQR(:stzObject)

		def ObjectsQR(pcReturnType)
			if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzObject
				return new stzObject( This.Objects() )

			on :stzObjectOfObjects
				return new stzObjectOfObjects( This.Objects() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def OnlyObjects()
			return This.Objects()

			def OnlyObjectsQ()
				return This.OnlyObjectsQR(:stzObject)
	
			def OnlyObjectsQR(pcReturnType)
				if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzObject
					return new stzObject( This.OnlyObjects() )
	
				on :stzObjectOfObjects
					return new stzObjectOfObjects( This.OnlyObjects() )
	
				other
					StzRaise("Unsupported return type!")
				off

		#>

	#--

	def RemoveObjects()
		This.RemoveItemsAtThesePositions(This.FindObjects())

		def RemoveObjectsQ()
			This.RemoveObjects()
			return This

		def RemoveOnlyObjects()
			This.RemoveObjects()

			def RemoveOnlyObjectsQ()
				This.RemoveOnlyObjects()
				return This

	def ObjectsRemoved()
		aResult = This.Copy().RemoveObjectsQ().Content()
		return aResult

	#--

	def FindNonObjects()
		aContent = This.COntent()
		nLen = len(aContent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def NonObjects()
		aContent = This.COntent()
		nLen = len(aContent)
		aResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				aResult + aContent[i]
			ok
		next

		return aResult

		def NonObjectsQ()
			return This.NonObjectsQR(:stzObject)

		def NonObjectsQR(pcReturnType)
			if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzObject
				return new stzObject( This.NonObjects() )

			on :stzObjectOfObjects
				return new stzObjectOfObjects( This.NonObjects() )

			other
				StzRaise("Unsupported return type!")
			off

		def OnlyNonObjects()
			return This.NonObjects()

			def OnlyNonObjectsQ()
				return This.OnlyNonObjectsQR(:stzObject)
	
			def OnlyNonObjectsQR(pcReturnType)
				if isObject(pcReturnType) and StzObjectQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzObject
					return new stzObject( This.OnlyNonObjects() )
	
				on :stzObjectOfObjects
					return new stzObjectOfObjects( This.OnlyNonObjects() )
	
				other
					StzRaise("Unsupported return type!")
				off

	def RemoveNonObjects()
		This.RemoveItemsAtThesePositions( This.FindNonObjects() )

		def RemoveNonObjectsQ()
			This.RemoveNonObjects()
			return This

		def RemoveOnlyNonObjects()
			This.RemoveNonObjects()

			def RemoveOnlyNonObjectsQ()
				This.RemoveOnlyNonObjects()
				return This

		def RemoveAllExceptObjects()
			This.RemoveNonObjects()

			def RemoveAllExceptObjectsQ()
				This.RemoveAllExceptObjects()
				return This

	def NonObjectsRemoved()
		aResult = This.Copy().RemoveNonObjectsQ().Content()
		return aResult

	  #--------------------------------------------------#
	 #     COUNTING ITEMS VERIFYING A GIVEN CONDITION   #
	#==================================================#

	def CountItemsW(pCondition)
		aItems = This.FindW(pCondition)

		nResult = len(aItems)

		return nResult
		
		#< @AlternativeFunctionNames

		def CountW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfOccurrenceW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfOccurrencesW(pCondition)
			return This.CountItemsW(pCondition)

		def NumberOfItemsW(pCondition)
			return This.CountItemsW(pCondition)

		def HowManyItemsW(pcCondition)
			return This.CountItemsW(pCondition)

		def HowManyItemW(pcCondition)
			return This.CountItemsW(pCondition)

		#>
			
	def NumberOfUniqueItemsW(pCondition)
		return len( This.UniqueItemsW(pCondition) )

		#< @FunctionAlternativeForms

		def NumberOfItemsUW(pCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def CountUniqueItemsW(pccondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def CountItemsUW(pccondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyUniqueItemsW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyUniqueItemW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyItemsUW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def HowManyItemUW(pcCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		def NumberOfItemsWithoutDuplicationW(pCondition)
			return This.NumberOfUniqueItemsW(pCondition)

		#>

	  #------------------------------------------------------------#
	 #     COUNTING ITEMS VERIFYING A GIVEN CONDITION -- XTended  #
	#------------------------------------------------------------#

	def CountItemsWXT(pCondition)
		aItems = This.FindWXT(pCondition)
		nResult = len(aItems)

		return nResult
		
		#< @AlternativeFunctionNames

		def CountWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfOccurrenceWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfOccurrencesWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def NumberOfItemsWXT(pCondition)
			return This.CountItemsWXT(pCondition)

		def HowManyItemsWXT(pcCondition)
			return This.CountItemsWXT(pCondition)

		def HowManyItemWXT(pcCondition)
			return This.CountItemsWXT(pCondition)

		#>
			
	def NumberOfUniqueItemsWXT(pCondition)
		return len( This.UniqueItemsWXT(pCondition) )

		#< @FunctionAlternativeForms

		def NumberOfItemsUWXT(pCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def CountUniqueItemsWXT(pccondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def CountItemsUWXT(pccondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyUniqueItemsWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyUniqueItemWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyItemsUWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def HowManyItemUWXT(pcCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		def NumberOfItemsWithoutDuplicationWXT(pCondition)
			return This.NumberOfUniqueItemsWXT(pCondition)

		#>

	  #--------------------------------------------------------------------#
	 #  INSERTING ITEM AFTER OR BEFORE ITEMS VERIFYING A GIVEN CONDITION  #
	#====================================================================#

	def InsertAfterW( pcCondition, pNewItem )
		anPos = This.FindItemsW(pcCondition)
		This.InsertAfterManyPositions( anPos, pNewItem )

		#< @FunctionFluentForm

		def InsertAfterWQ( pcCondition, pNewItem )
			This.InsertAfterW( pCondition, pNewItem )
			return This

		#>

		def InsertAfterWhere(pcCondition, pNewItem)
			This.InsertAfterW(pCondition, pNewItem)

			def InsertAfterWhereQ(pcCondition, pNewItem)
				This.InsertAfterWhere(pcCondition, pNewItem)
				return This

	def InsertBeforeW(pcCondition, pNewItem)
		/*
		o1.InsertBeforeW( :Where = '{ StzStringQ(item).IsUppercase() }', "*" )
		*/

		anPos = This.FindItemsW(pcCondition)
		This.InsertBeforeThesePositions(anPos, pNewItem)

		#< @FunctionFluentForm

		def InsertBeforeWQ(pcCondition, pNewItem)
			This.InsertBeforeW(pcCondition, pNewItem)
			return This

		#>

		def InsertAtW(pcCondition, pNewItem)
			This.InsertBeforeW(pcCondition, pNewItem)

			def InsertAtWQ(pcCondition, pNewItem)
				This.InsertAt(pcCondition, pNewItem)
				return This

	  #------------------------------------------------------------------------------------#
	 #  INSERTING ITEM AFTER OR BEFORE ITEMS VERIFYING A GIVEN CONDITION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------------------#

	def InsertAfterWXT( pcCondition, pNewItem )
		anPos = This.FindItemsWXT(pcCondition)
		This.InsertAfterManyPositions( anPos, pNewItem )

		#< @FunctionFluentForm

		def InsertAfterWXTQ( pcCondition, pNewItem )
			This.InsertAfterWXT( pCondition, pNewItem )
			return This

		#>

		def InsertAfterWhereXT(pcCondition, pNewItem)
			This.InsertAfterWXT(pCondition, pNewItem)

			def InsertAfterWhereXTQ(pcCondition, pNewItem)
				This.InsertAfterWhereXT(pcCondition, pNewItem)
				return This

	def InsertBeforeWXT(pcCondition, pNewItem)
		/*
		o1.InsertBeforeWXT( :Where = '{ StzStringQ(item).IsUppercase() }', "*" )
		*/

		anPos = This.FindItemsWXT(pcCondition)
		This.InsertBeforeThesePositions(anPos, pNewItem)

		#< @FunctionFluentForm

		def InsertBeforeWXTQ(pcCondition, pNewItem)
			This.InsertBeforeWXT(pcCondition, pNewItem)
			return This

		#>

		def InsertAtWXT(pcCondition, pNewItem)
			This.InsertBeforeWXT(pcCondition, pNewItem)

			def InsertAtWXTQ(pcCondition, pNewItem)
				This.InsertAtXT(pcCondition, pNewItem)
				return This

	  #-----------------------------------------------------------------#
	 #  INSERTING MANY ITEMS AFTER OR BEFORE A GIVEN SET OF POSITIONS  #
	#=================================================================#

	def InsertAfterManyPositions(panPos, pItem)

		for i = 1 to len(panPos)
			n = panPos[i] + i - 1
			This.InsertAfter(n, pItem)
		next

		#< @FunctionFluentForm

		def InsertAfterManyPositionsQ(panPos, pItem)
			This.InsertAfterManyPositions(panPos, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterThesePositions(panPos, pItem)
			This.InsertAfterManyPositions(panPos, pItem)

			def InsertAfterThesePositionsQ(panPos, pItem)
				This.InsertAfterThesePositions(panPos, pItem)
				return This

		def InsertAfterPositions(panPos, pItem)
			This.InsertAfterPositions(panPos, pItem)

			def InsertAfterPositionsQ(panPos, pItem)
				This.InsertAfterThesePositions(panPos, pItem)
				return This

		#>

	def InsertBeforeManyPositions(panPos, pItem)
		for i = 1 to len(panPos)
			n = panPos[i] + i - 1
			This.InsertBefore(n, pItem)
		next

		#< @FunctionFluentForm
		
		def InsertBeforeManyPositionsQ(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeThesePositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertBeforeThesePositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		def InsertBeforePositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertBeforePositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		def InsertAtPositions(panPos, pItem)
			This.InsertBeforeManyPositions(panPos, pItem)

			def InsertAtPositionsQ(panPos, pItem)
				This.InsertBeforeThesePositions(panPos, pItem)
				return This

		#>

	  #================================================#
	 #    GETTING A SECTION (OR SLICE) OF THE LIST    #
	#================================================#


	def SectionCS(n1, n2, pCaseSensitive)

		nLen = This.NumberOfItems()

		if CheckParams()

			# Managing the use of :From and :To named params
	
			if isList(n1) and
			   StzListQ(n1).IsOneOfTheseNamedParams([
					:From, :FromPosition, :FromItemAt, :FromItemAtPosition,

					:StartingAt, :StartingAtPosition,
					:StartingAtItemAt, :StartingAtItemAtPosition,

					:Between, :BetweenPosition, :BetweenCharAt,
					:BetweenItemAtPosition,

					:BetweenPositions, :BetweeItemsAtPosition
					])
	
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   StzListQ(n2).IsOneOfTheseNamedParams([

					:To, :ToPosition, :ToItemAt, :ToItemAtPosition,

					:Until, :UntilPosition, :UntilItemAt, :UntilItemAtPosition,

					:UpTo, :UpToPosition, :UpToItemAt, :UpToItemAtPosition,

					:And,

					:StartingAt, :StartingAtPosition, :StartingAtItemAt, :StartingAtItemAtPosition

					])
	
				n2 = n2[2]
			ok
	
			# Managing the use of :NthToFirst named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstItem ])
	
				n1 = n1[2] + 1
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToFirst, :NthToFirstItem ])
	
				n2 = n2[2] + 1
			ok
	
			# Managing the use of :NthToLast named param
	
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastItem ])
	
				n1 = nLen - n1[2]
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
						:NthToLast, :NthToLastItem ])
	
				n2 = nLen - n2[2]
	
			but isList(n2) and Q(n2).IsStoppingAtNamedParam()
	
				n2 = n2[2]
			ok
	
			# Managing the case of :First and :Last keywords
	
			if isString(n1)
				if Q(n1).IsOneOfThese([
					:First, :FirstItem
				])

					n1 = 1
	
				but Q(n1).IsOneOfThese([
					:Last, :LastItem
				])

					n1 = nLen
	
				but n1 = :@
					n1 = n2

				else
					n1 = This.FindFirstCS(n1, pCaseSensitive)
				ok
			ok
		
			if isString(n2)
				if Q(n2).IsOneOfThese([
					:End, :Last, :LastItem, :EndOfList
				])

					n2 = nLen
	
				but Q(n2).IsOneOfThese([
					:First, :FirstItem
				])

					n2 = 1
	
				but n2 = :@
					n2 = n1

				else
					nLen2 = StzStringQ(n2).NumberOfItems()
					n2 = This.FindLastCS(n2, pCaseSensitive) + nLen2 - 1
				ok
			ok

			if n1 = :@ and n2 = :@
				n1 = 1
				n2 = nLen
			ok

			# Params must be numbers
	
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect params! n1 and n2 must be numbers.")
			ok

		ok

		#NOTE: when positions are given in inversed order, the same
		# section as if they were not inverted is returned, so:
		#--> Q([ "r", "i", "n", "g" ]).Section(1,3) and .Section(3,1) both
		#    return [ "r", "i", "n" ]

		# In some languages, like Pyhton for example, reverting the positions,
		# inverts the section. So:
		#--> Q([ "r", "i", "n", "g" ]).Section(1,3) returns [ "r", "i", "n" ], but
		#    .Section(3,1) returns [ "n", "i", "r" ]

		# If you need to use this feature in Softanza, use the eXTended form
		# SectionXT(), like this :
		#--> Q([ "r", "i", "n", "g" ]).SectionXT(3,1) and it will return
		#    [ "n", "i", "r" ]

		# params must be in range

		if NOT 	( ( n1 >= 1 and n1 <= nLen ) and
			   ( n2 >= 1 and n2 <= nLen ) )
				
			StzRaise("Indexes out of range! n1 and n2 must be inside the list.")
		ok

		aContent = This.Content()
		aResult = []

		if n2 < n1
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok
		
		for i = n1 to n2
			aResult + aContent[i]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionCSQ(n1, n2, pCaseSensitive)
			return new stzList( This.SectionCS(n1, n2, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm

		def SliceCS(n1, n2, pCaseSensitive)
			return This.SectionCS(n1, n2, pCaseSensitive)

			#< @FunctionFluentForm

			def SliceCSQ(n1, n2, pCaseSensitive)
				return This.SectionCSQ(n1, n2, pCaseSensitive)

			#>
		#>	

	#-- WITHOUT CASESENSITIVITY

	def Section(n1, n2)
		return This.SectionCS(n1, n2, TRUE)

		def SectionQ(n1, n2)
			return new stzList(This.Section(n1, n2))

		def Slice(n1, n2)
			return This.Section(n1, n2)

			def SliceQ(n1, n2)
				return new stzList(This.Slice(n1, n2))

	  #------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE LIST -- Z/EXTENDED   #
	#------------------------------------------------------------#

	def SectionCSZ(n1, n2, pCaseSensitive)
		if CheckParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSZ(n1, n2, pCaseSensitive)
			return This.SectionCSZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZ(n1, n2)
		return This.SectionCSZ(n1, n2, TRUE)

		def SliceZ(n1, n2)
			return SectionZ(n1, n2)

	  #------------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE LIST -- ZZ/EXTENDED  #
	#------------------------------------------------------------#

	def SectionCSZZ(n1, n2, pCaseSensitive)
		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = This.NumberOfItems()
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCS(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSZZ(n1, n2, pCaseSensitive)
			return This.SectionCSZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVE

	def SectionZZ(n1, n2)
		return This.SectionCSZZ(n1, n2, TRUE)

		def SliceZZ(n1, n2)
			return SectionZZ(n1, n2)

	  #-------------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTended form  #
	#===================================================================#

	def SectionCSXT(n1, n2, pCaseSensitive)

		#NOTE:
		# This is an extended form of Section() that supports
		# two fency features (that we find in other languages like Python):
		# ~> n1 and n2 can be negative numbers, so their values are counted from the end
		# ~> n1 can be greater then n2, and hence the section is reversed

		nLen = This.NumberOfItemsCS(pCaseSensitive)

		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		# Managing negative values

		if n1 < 0
			n1 = nLen + n1 + 1
			# Be careful : + n1 and not - n1 because n1 is already negative!
		ok

		if n2 < 0
			n2 = nLen + n2 + 1
		ok

		# Managing the case where n1 > n2 --> section reversed

		aResult = []

		if n1 > n2
			aResult = This.SectionCSQ(n2, n1, pCaseSensitive).Reversed()

		else
			aResult = This.SectionCS(n2, n1, pCaseSensitive)
		ok

		return aResult

		def SliceCSXT(n1, n2, pCaseSensitive)
			return This.SectionCSXT(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXT(n1, n2)
		return This.SectionCSXT(n1, n2, TRUE)

		def SliceXT(n1, n2)
			return This.SectionXT(n1, n2)

	  #---------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZ form  #
	#---------------------------------------------------------------#

	def SectionCSXTZ(n1, n2, pCaseSensitive)
		if CheckParams()
			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), n1 ]
		return aResult

		def SliceCSXTZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZ(n1, n2)
		return This.SectionCSXTZ(n1, n2, TRUE)

		def SliceXTZ(n1, n2)
			return This.SectionXTZ(n1, n2)

	  #----------------------------------------------------------------#
	 #  GETTING THE SECTION BETWEEN n1 and n2 POSITIONS -- XTZZ form  #
	#----------------------------------------------------------------#

	def SectionCSXTZZ(n1, n2, pCaseSensitive)
		if CheckParams()

			if isString(n1) and (n1 = :Start or n1 = :StartOfList)
				n1 = 1
			ok

			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

			#--

			if isString(n1) and (n1 = :End or n1 = :EndOfList)
				n1 = nLen
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok

		ok

		aResult = [ This.SectionCSXT(n1, n2, pCaseSensitive), [n1, n2] ]
		return aResult

		def SliceCSXTZZ(n1, n2, pCaseSensitive)
			return This.SectionCSXTZZ(n1, n2, pCaseSensitive)

	#-- WITHOUT CASESENSITIIVTY

	def SectionXTZZ(n1, n2)
		return This.SectionCSXTZZ(n1, n2, TRUE)

		def SliceXTZZ(n1, n2)
			return This.SectionXTZZ(n1, n2)

	#TODO : RangeZ(), RangeZZ(), RangeXT(), RangeXTZ(), and RangeXTZZ()

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #
	#---------------------------------------#

	def Sections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")

		ok

		if len(paSections) = 0
			return []
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

		def Slices(paSections)
			return This.Sections(paSections)

		def ManySlices(paSections)
			return This.Sections(paSections)

		#>

	  #--------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- XT  #
	#--------------------------------------------#

	def SectionsXT(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")

		ok

		if len(paSections) = 0
			return []
		ok

		aResult = []

		for aSection in paSections
			aResult + This.SectionXT( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

		#>

	  #--------------------------------------------#
	 #   GETIING THE SECTIONS BETWEEN TWO ITEMS   #
	#--------------------------------------------#

	def SectionsBetweenCS(pItem1, pItem2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzList([ "T", "A", "Y", "O", "U", "B", "T", "A" ])
		? o1.SectionsBetween( "T", :And = "A" )
		#--> [ ["T", "A"], [ "T", "A", "Y", "O", "U", "B", "T", "A" ], ["T", "A"] ]

		*/

		if CheckParams()
	
			if isList(pItem2) and Q(pItem2).IsAndNamedParam()
				pItem2 = pItem2[2]
			ok

		ok

		anSections = []

		anPos1 = This.FindAllCS(pItem1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pItem2, pCaseSensitive) #--> [ 2, 8 ]

		#TODO
		# Use for/to instead of for/in ~> Better performance!

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		#< @FunctionAlternativeForm

		def SectionsBetweenItemsCS(pItem1, pItem2, pCaseSensitive)
			return This.SectionsBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def SectionsBetween(pItem1, pItem2)
		return This.SectionsBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def SectionsBetweenItems(pItem1, pItem2)
			return This.SectionsBetween(pItem1, pItem2)

		#>

	   #--------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND   #
	 #   RETURNING THEM AS PAIRS OF NUMBERS                         #
	#--------------------------------------------------------------#

	def FindAntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")

		? o1.FindAntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ [1, 2], [6, 6], [9, 10] ]

		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ ["A", "B"], ["F"], ["I", "J"] ]

		*/

		if isList(paSections) and Q(paSections).IsOfNamedParam()
			paSections = paSections[2]
		ok

		if isList(paSections) and len(paSections) = 0
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		aSorted = []
		for i = 1 to nLen
			aSorted + ring_sort(paSections[i])
		next
		#--> [ [3,5], [7,8] ]

		aAntiSections = []
		n1 = 1

		i = 0
		bLastPair = FALSE

		for i = 1 to nLen

			if i = nLen
				bLastPair = TRUE
			ok

			aPair = aSorted[i]

			if aPair[1] > n1
				n2 =  aPair[1] - 1
				aAntiSections + [ n1, n2 ]
			ok

			if NOT bLastPair
				n1 = aPair[2] + 1
			ok
		next

		nLast = aSorted[ nLen ][2]
		nLenList = This.NumberOfItems()

		if nLast < nLenList
			aAntiSections + [ nLast + 1, nLenList ]
		ok

		aResult = aAntiSections
		return aResult

		#< @FunctionFluentForm

		def FindAntiSectionsQ(paSections)
			return This.FindAntiSectionsQR(paSections, :stzList)

		def FindAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAntiSections(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAntiSections(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAntiSections(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		def AntiSectionsAsPairsOfNumbers(paSections)
			return This.FindAntiSections(paSections)

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ ["A", "B"], ["F"], ["I", "J"] ]
		*/

		aResult = This.Sections( This.FindAntiSections(paSections) )
		return aResult

		def SectionsOtherThan(paSections)
			return This.AntiSections(paSections)

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return new stzList( This.AntiSections(paSections) )

		#>

	def FindAsSectionsAndAntiSections(paSections)
		aAntiSections = This.FindAntiSections(paSections)
		nLen = len(aAntiSections)

		for i = 1 to nLen
			aList = aAntiSections[i]
			if len(aList) = 1
				aList + aList[1]

			but len(aList) > 2
				n1 = aList[1]
				n2 = aList[len(aList)]
				aList = [n1, n2]
			ok
		next

		aAllSections = aAntiSections
		nLen = len(aAllSections)

		for i = 1 to nLen
				aAllSections + aAllSections[i]
		next

		aAllSections = StzListOfPairsQ(aAllSections).SortedInAscending()

		aResult = aAllSections
		return aResult

		#< @FunctionFluentForm

		def FindAsSectionsAndAntiSectionsQ(paSections)
			return This.FindAsSectionsAndAntiSectionsQR(paSections, :stzList)

		def FindAsSectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsAndAntiSectionss(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		def SectionsAndAntiSectionsAsPairsOfNumbers(paSections)
			return This.FindAsSectionsAndAntiSections(paSections)

	def SectionsAndAntiSections(paSections)
		aAllSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections(aAllSections)
		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return new stzList( This.SectionsAntiSections(paSections) )

		#>

		#< @FunctionAlternativeForm

		def AllSectionsIncluding(paSections)
			return This.SectionsAndAntiSections(paSections)

			def AllSectionsIncludingQ(paSections)
				return new stzList( This.AllSectionsIncluding(paSections) )
	
		#>

	   #--------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND   #
	 #   RETURNING THEM AS PAIRS OF NUMBERS  -- INCLUDING BOUNDS    #
	#--------------------------------------------------------------#

	def FindAntiSectionsIB(paSections)
		/* EXAMPLE
		o1 = new stzList("A":"J")

		? o1.FindAntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ [1, 3], [5, 7], [8, 10] ]


		*/

		if CheckParams()
			if isList(paSections) and Q(paSections).IsOfNamedParam()
				paSections = paSections[2]
			ok
	
			if isList(paSections) and len(paSections) = 0
				return []
			ok
	
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
			ok
		ok

		# Doing the job

		aSorted = StzListOfPairsQ(paSections).SortedInAscending()
	
		nLen = len(aSorted)

		aAntiSectionsIB = []
		n1 = 1

		i = 0
		bLastPair = FALSE

		for i = 1 to nLen

			if i = nLen
				bLastPair = TRUE
			ok

			aPair = aSorted[i]

			if aPair[1] > n1
				n2 =  aPair[1]
				aAntiSectionsIB + [ n1, n2 ]
			ok

			if NOT bLastPair
				n1 = aPair[2]
			ok
		next

		nLast = aSorted[ nLen ][2]
		nLenList = This.NumberOfItems()

		if nLast < nLenList
			aAntiSectionsIB + [ nLast, nLenList ]
		ok

		aResult = aAntiSectionsIB
		return aResult

		#< @FunctionFluentForm

		def FindAntiSectionsIBQ(paSections)
			return This.FindAntiSectionsIBQR(paSections, :stzList)

		def FindAntiSectionsIBQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAntiSectionsIB(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAntiSectionsIB(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAntiSectionsIB(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		def AntiSectionsAsPairsOfNumbersIB(paSections)
			return This.FindAntiSectionsIB(paSections)

	def AntiSectionsIB(paSections)
		aResult = This.Sections( This.FindAntiSectionsIB(paSections) )
		return aResult

		#< @FunctionFluentForm

		def AntiSectionsIBQ(paSections)
			return new stzList( This.AntiSectionsIB(paSections) )

		#>

		#< @FunctionAlternativeForm

		def SectionsOtherThanIB(paSections)
			return This.AntiSectionsIB(paSections)

			def SectionsOtherThanIBQ(paSections)
				return This.AntiSectionsIBQ(paSections)

		#>

	def FindAsSectionsAndAntiSectionsIB(paSections)
		aAntiSectionsIB = This.FindAntiSectionsIB(paSections)
		nLen = len(aAntiSectionsIB)

		for i = 1 to nLen
			aList = aAntiSectionsIB[i]
			if len(aList) = 1
				aList + aList[1]

			but len(aList) > 2
				n1 = aList[1]
				n2 = aList[len(aList)]
				aList = [n1, n2]
			ok
		next

		aAllSectionsIB = aAntiSectionsIB
		nLen = len(aAllSectionsIB)

		for i = 1 to nLen
				aAllSections + aAllSectionsIB[i]
		next

		aAllSectionsIB = StzListOfPairsQ(aAllSectionsIB).SortedInAscending()

		aResult = aAllSectionsIB
		return aResult

		#< @FunctionFluentForm

		def FindAsSectionsAndAntiSectionsIBQ(paSections)
			return This.FindAsSectionsAndAntiSectionsIBQR(paSections, :stzList)

		def FindAsSectionsAndAntiSectionsIBQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsAndAntiSectionsIB(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsAndAntiSectionsIB(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsAndAntiSectionssIB(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		def SectionsAndAntiSectionsAsPairsOfNumbersIB(paSections)
			return This.FindAsSectionsAndAntiSectionsIB(paSections)

	def SectionsAndAntiSectionsIB(paSections)
		aAllSectionsIB = This.FindAsSectionsAndAntiSectionsIB(paSections)
		aResult = This.Sections(aAllSectionsIB)
		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsIBQ(paSections)
			return new stzList( This.SectionsAntiSectionsIB(paSections) )

		#>

		#< @FunctionAlternativeForm

		def AllSectionsIncludingIB(paSections)
			return This.SectionsAndAntiSectionsIB(paSections)

			def AllSectionsIncludingIBQ(paSections)
				return new stzList( This.AllSectionsIncludingIB(paSections) )
	
		#>

	  #===================================#
	 #    GETTING A RANGE OF THE LIST    #
	#===================================#

	def Range(pnStart, pnRange)

		# Chacking params

		if CheckParams()
			if isString(pnStart)
				if pnStart = :First or pnStart = :FirstChar
					pnStart = 1
	
				but pnStart = :Last or pnStart = :LastChar
					pnStart = This.NumberOfItems()
				ok
			ok
	
			if NOT Q([pnStart, pnRange]).BothAreNumbers()
				StzRaise("Incorrect param type! pnStart and pnRange must be both numbers.")
			ok
		ok

		# Doing the job

		if pnStart < 0
			pnStart = This.NumberOfItems() + pnStart + 1
		ok

		if pnStart = 0 or pnRange = 0
			return NULL
		ok

		aResult = []

		if pnRange > 0
			aResult + This.Section( pnStart, pnStart + pnRange -1 )

		else
			n1 = pnStart + pnRange + 1

			if n1 > 0
				aResult + This.Section( n1, pnStart )
			ok	
		ok

		return aResult

		#< @FunctionFluentForms

		def RangeQ(pnStart, pnRange)
			return This.RangeQR(pnStart, pnRange, :stzList)

		def RangeQR(pnStart, pnRange, pcReturntype)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzList
				return new stzList( This.Range(pnStart, pnRange) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Range(pnStart, pnRange) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Range(pnStart, pnRange) )

			on :stzListOfLists
				return new stzListOfLists( This.Range(pnStart, pnRange) )

			on :stzListOfObjects
				return new stzListOfObjects( This.Range(pnStart, pnRange) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #------------------------------------#
	 #   GETTING MANY RANGES OF THE LIST  #
	#------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

		#< @FunctionFluentForm

		def AntiRangesQ(paRanges)
			return new stzList( This.AntiRanges(paRanges) )

		#>

	def RangesAndAntiRanges(paRanges)
		aSections = SectionsToRanges(paRanges)
		aResult = This.SectionsAndAntiSections(aSections)
		
		return aResult

		#< @FunctionFluentForm

		def RangesAndAntiRangesQ(paRanges)
			return new stzList( This.RangesAndAntiRanges(paRanges) )

		#>

		#< @FunctionAlternativeForm

		def AllRangesIncluding(paRanges)
			return This.RangesAndAntiRanges(paRanges)

			def AllRangesIncludingQ(paRanges)
				return new stzList( This.AllRangesIncluding(paRanges) )
	
		#>

	  #---------------------------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def AntiRangesIB(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSectionsIB(aSections)

		return aResult

		def RangesOtherThanIB(paRanges)
			return This.AntiRangesIB()

		#< @FunctionFluentForm

		def AntiRangesIBQ(paRanges)
			return new stzList( This.AntiRangesIB(paRanges) )

		#>

	def RangesAndAntiRangesIB(paRanges)
		aSections = SectionsToRanges(paRanges)
		aResult = This.SectionsAndAntiSectionsIB(aSections)
		
		return aResult

		#< @FunctionFluentForm

		def RangesAndAntiRangesIBQ(paRanges)
			return new stzList( This.RangesAndAntiRangesIB(paRanges) )

		#>

		#< @FunctionAlternativeForm

		def AllRangesIncludingIB(paRanges)
			return This.RangesAndAntiRangesIB(paRanges)

			def AllRangesIncludingIBQ(paRanges)
				return new stzList( This.AllRangesIncludingIB(paRanges) )
	
		#>

	  #===================#
	 #     MULTINGUAL    #
	#===================#

	def AllItemsAreLanguageAbbreviations()
		bResult = TRUE
		for item in This.List()
			if NOT StringIsLanguageAbbreviation(item)
				bResult = FALSE
				exit
			ok
		next
		return bResult

	def IsMultilingualString()
	     
		/* A multilingual string is a hashlist of the form:
			[
			:en = "house",
			:fr = "maison",
			:ar = ""
		     	]

		The keys of the hashlit must be language abbreviations as
		defined by LocaleLanguageAbbreviations() in stzLocale
		*/

		# The MultilingualString must be a hashlist!
		if NOT This.IsHashlist()
			return FALSE
		ok

		# And the translations provided mus be all strings
		oHash = new stzHashList(This.List())
		aValues = oHash.Values()
		oList = new stzList(aValues)
		if NOT oList.AllItemsAreStrings()
			return FALSE
		ok

		# The keys of the hashlist are the language names or abbreviations
		# Let's check that they are well-formed
		aKeys = oHash.Keys()

		for str in aKeys
			oStr = new stzString(str)
			if NOT (oStr.IsLanguageName() or
				oStr.IsLanguageAbbreviation())
				
				return FALSE
			ok
		next
			
		# Otherwise, the list is a well-formed multilingual string
		return TRUE

	def IsLocaleList()

		if This.NumberOfItems() = 1 and isString(This.Item(1)) and

		   Q(This.Item(1)).IsOneOfThese([ :Default, :DefaultLocale,
				 :System, :SystemLocale, :c, "C", :CLocale
		   ])

			return TRUE
		ok

		# The list should not exceed 3 items

		if This.NumberOfItems() > 3
			return FALSE
		ok

		# It must be a hashlist

		if NOT This.IsHashList()
			return FALSE
		ok

		# The Hashlist must take the form:
		# 	[ :Language = "...", :Country = "...", ":Script = "..." ]
		# At least one item must be provided. And one, two, or three can
		# can be provided.

		oHash = new stzHashList(This.List())
		oKeys = new stzList(oHash.Keys())

		if NOT (oKeys.IsMadeOfSome([ :Language, :Script, :Country ]) ) 
				return FALSE
		ok

		cLanguage = This.List()[ :Language ]
		cScript   = This.List()[ :Script   ]
		cCountry  = This.List()[ :Country  ]

		if AllTheseAreNull([ cLanguage, cScript, cCountry ])
			return FALSE
		ok

		if NOT AllTheseAreStrings([ cLanguage, cScript, cCountry ])
			return FALSE
		ok
		
		if oKeys.Contains(:Language) and Q(cLanguage).IsNotLanguageName()
			return FALSE
		ok

		if oKeys.Contains(:Script) and Q(cScript).IsNotScriptName()
			return FALSE
		ok

		if oKeys.Contains(:Country) and Q(cCountry).IsNotCountryName()
			return FALSE
		ok

		# At this level we are sure it is a language identification list
		return TRUE

	  #----------------------------------------#
	 #   DISTRIBUTING THE ITEMS OF THE LIST   #
	#----------------------------------------#

	def DistributeOverXT( acBeneficiaryItems, anShareOfEachItem )

		/* Explanation
	
		Distributes the items of the main list over the items of the
		provided list, called metaphorically 'Beneficiary Items'
		(anShareOfEachItem) here as they 'benfit' from that distribution).
		
		The distribution is defined by the share of each item.
		
		The share of each item, defined by a list of numbers (anShareOfEachItem),
		determines how many items should be given to the beneficiaries.
		
		--> The beneficiary items can be of any type. In practice, they are
		strings and hence the returned result is a hashlist as demonstrated by
		the following example:
	
		o1 = new stzList([ :water, :coca, :milk, :spice, :cofee, :tea, :honey ] )
		? o1.DistributeOverXT([ :arem, :mohsen, :hamma ], :Using = [ 2, 3, 2 ] )
	
		Gives:
	
		[
			:arem   = [ :water, :coca ],
			:mohsen = [ :milk, :spice, :cofee ],
			:hamma  = [ :tea, honey ]
		]
	
		*/

		if isList(anShareOfEachItem) and Q(anShareOfEachItem).IsUsingNamedParam()
			anShareOfEachItem = anShareOfEachItem[2]
		ok

		# The acBeneficiaryItems param should be non empty list of items:

		if NOT ( isList(acBeneficiaryItems) and  len( acBeneficiaryItems) > 0 )
			StzRaise(stzListError(:CanNoteDistributeItemsOverTheList1))
		ok

		# Controlling the validity of the syntax of anShareOfEachItem param

		if NOT ( isList(anShareOfEachItem) and
			 Q(anShareOfEachItem).IsListOfNumbers() and
			 len(anShareOfEachItem) > 0 )
			 StzRaise("Incorrect param! anShareOfEachItem must be a non empty list of numbers.")
		ok

		# The sum of numbers in anShareOfEachItem should be equal to the
		# number of items of the main list

		if NOT Sum(anShareOfEachItem) = This.NumberOfItems()
			StzRaise(stzListError(:CanNoteDistributeItemsOverTheList2))
		ok

		# Now, we can perform the distribution

		aResult = []
		i = 0
		n = 1
		for cBenef in acBeneficiaryItems
			i++
			aResult + [ cBenef, This.Range(n, anShareOfEachItem[i]) ]
			n += anShareOfEachItem[i]
		next

		return aResult
	
	def DistributeOver( acBeneficiaryItems )
		nLenList = This.NumberOfItems()
		nLenBenef = len(acBeneficiaryItems)

		anShare = []

		if nLenBenef >= nLenList
			for i = 1 to nLenList
				anShare + 1
			next

		else
			n = floor( nLenList / nLenBenef )

			for i = 1 to nLenBenef	
				anShare + n
			next

			nRest = nLenList - ( n * nLenBenef )

			if nRest > 0
				for i = 1 to nRest
					anShare[i]++
				next
			ok
			
		ok

		aResult = This.DistributeOverXT( acBeneficiaryItems, :Using = anShare)
		return aResult

	  #=======================#
	 #     GETTING TYPES     #
	#=======================#

	# Deeling wuth the list itself

	def IsStzList()
		return TRUE

	def StzType()
		return :stzList


	  #----------------------------------------------#
	 #  GETTING THE TYPES OF EACH ITEM IN THE LIST  #
	#----------------------------------------------#

	def Types()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			aResult + ring_type(aContent[i])
		next

		return aResult

	def TypesXT()
		aResult = This.ListQ().AssociatedWith( This.Types() )
		return aResult

		def ItemsAndTypes()
			return This.TypesXT()

		def ItemsAndTheirTypes()
			return This.TypesXT()

	def UniqueTypes()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if ring_find(aResult, ring_type(aContent[i])) = 0
				aResult + ring_type(aContent[i])
			ok
		next

		return aResult

		def TypesU()
			return This.UniqueTypes()

		def TypesWithoutDuplication()
			return This.UniqueTypes()

	def TypesAndTheirPositions()
		acTypes = This.TypesU()
		nLen = len(acTypes)

		aResult = []

		for i = 1 to nLen

			cType = lower(acTypes[i])

			if  cType = "number"
				aResult + [ :Number, This.FindNumbers() ]

			but cType = "string"
				aResult + [ :String, This.FindStrings() ]

			but cType = "list"
				aResult + [ :List, This.FindLists() ]

			but cType = "object"
				aResult + [ :Object, This.FindObjects() ]
			ok

		next
		
		return aResult

		def TypesZ()
			return This.TypesAndTheirPositions()

	def TypesAndTheirSections()
		acTypes = This.TypesU()
		nLen = len(acTypes)

		aResult = []

		for i = 1 to nLen

			cType = lower(acTypes[i])

			if  cType = "number"
				aResult + [ :Number, This.FindNumbersZZ() ]

			but cType = "string"
				aResult + [ :String, This.FindStringsZZ() ]

			but cType = "list"
				aResult + [ :List, This.FindListsZZ() ]

			but cType = "object"
				aResult + [ :Object, This.FindObjectsZZ() ]
			ok

		next
		
		return aResult

		def TypesZZ()
			return This.TypesAndTheirSections()

	  #-------------------------------------------------------#
	 #  GETTING THE SOFTANZA TYPES OF EACH ITEM IN THE LIST  #
	#-------------------------------------------------------#
	# For non softanza objects a NULL is returned

	def StzTypes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		for i = 1 to nLen
			if isObject(aContent[i]) and aContent[i].IsStzObject()
				aResult + aContent[i].StzType()
			else
				aResult + NULL
			ok
		next

		return aResult

	def StzTypesXT()
		aResult = This.ListQ().AssociatedWith( This.StzTypes() )
		return aResult

	def UniqueStzTypes()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if ring_find(aResult, Q(aContent[i]).StzType()) = 0
				aResult + Q(aContent[i]).StzType()
			ok
		next

		return aResult

		def StzTypesU()
			return This.UniqueStzTypes()

		def StzTypesWithoutDuplication()
			return This.StzUniqueTypes()

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A GIVEN SUBLIST OF ITEMS  #
	#-------------------------------------------------------------#

	def StartsWithCS(paItems, pCaseSensitive)

		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLen = This.NumberOfItems()
		nLenItems = len(paItems)

		if nLenItems > nLen
			return FALSE
		ok

		if This.IsStrictlyEqualToCS(paItems, pCaseSensitive)
			return TRUE
		ok

		bResult = TRUE
		aContent = This.Content()

		for i = 1 to nLenItems
			if Q(aContent[i]).IsNotEqualToCS(paItems[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def BeginsWithCS(paItems, pCaseSensitive)
			return This.StartsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(paItems)
		return This.StartsWithCS(paItems, oCaseSensitive)

		def BeginsWith(paItems)
			return This.StartsWith()

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST ENDS WITH A GIVEN SUBLIST OF ITEMS  #
	#-----------------------------------------------------------#

	def EndsWithCS(paItems, pCaseSensitive)
		if NOT isList(paItems)
			StzRaise("Incorrect param type! paItems must be a list.")
		ok

		nLenItems = len(paItems)
		nLen = This.NumberOfItems()

		if nLenItems > nLen
			return FALSE
		ok

		if This.IsStrictlyEqualToCS(paItems, pCaseSensitive)
			return TRUE
		ok

		bResult = TRUE
		
		aLastItems = This.NLastItems( nLenItems )
		nLenLastItems = len(aLastItems)
		aContent = This.Content()

		for i = 1 to nLenLastItems

			if Q(aContent[i]).IsNotEqualToCS(aLastItems[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def FinishesWithCS(paItems, pCaseSensitive)
			return This.EndsWithCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(paItems)
		return This.EndsWithCS(paItems, TRUE)

		def FinishesWith(paItems)
			return This.EndsWith(paItems)

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A NUMBER  #
	#=============================================#

	def StartsWithANumber()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isNumber(This.Item(1))

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingNumber()
			return This.StartsWithANumber()

		def ContainsAStartingNumber()
			return This.StartsWithANumber()

		def ContainsALeadingNumber()
			return This.StartsWithANumber()

		def HasALeadingNumber()
			return This.StartsWithANumber()

		def HasAStartingNumber()
			return This.StartsWithANumber()

		#>

	  #-------------------------------------------#
	 #  CHECKING IF THE LSIT ENDS WITH A NUMBER  #
	#-------------------------------------------#

	def EndsWithANumber()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isNumber(This.LastItem())

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithATrailingNumber()
			return This.EndsWithANumber()

		def ContainsATrailingNumber()
			return This.EndsWithANumber()

		def HasATrailingNumber()
			return This.EndsWithANumber()

		#>

	  #---------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A STRING  #
	#=============================================#

	def StartsWithAString()
		bResult = FALSE
		
		if This.StringOfItems() > 1 and
		   isString(This.Item(1))

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingString()
			return This.StartsWithAString()

		def ContainsAStartingString()
			return This.StartsWithAString()

		def ContainsALeadingString()
			return This.StartsWithAString()

		def HasALeadingString()
			return This.StartsWithAString()

		def HasAStartingString()
			return This.StartsWithAString()

		#>

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST ENDS WITH A NUMBER  #
	#-------------------------------------------#

	def EndsWithAString()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isString(This.LastItem())

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithATrailingString()
			return This.EndsWithAString()

		def ContainsATrailingString()
			return This.EndsWithAString()

		def HasATrailingString()
			return This.EndsWithAString()

		#>

	  #-------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH A LIST  #
	#===========================================#

	def StartsWithAList()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isList(This.Item(1))

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingList()
			return This.StartsWithAList()

		def ContainsAStartingList()
			return This.StartsWithAList()

		def ContainsALeadingList()
			return This.StartsWithAList()

		def HasALeadingList()
			return This.StartsWithAList()

		def HasAStartingList()
			return This.StartsWithAList()

		#>

	  #-----------------------------------------#
	 #  CHECKING IF THE LIST ENDS WITH A LIST  #
	#-----------------------------------------#

	def EndsWithAList()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isList(This.LastItem())

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithATrailingList()
			return This.EndsWithAList()

		def ContainsATrailingList()
			return This.EndsWithAList()

		def HasATrailingList()
			return This.EndsWithAList()

		#>

	  #----------------------------------------------#
	 #  CHECKING IF THE LIST STARTS WITH AN OBJECT  #
	#==============================================#

	def StartsWithAObject()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isObject(This.Item(1))

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingObject()
			return This.StartsWithAObject()

		def ContainsAStartingObject()
			return This.StartsWithAObject()

		def ContainsALeadingObject()
			return This.StartsWithAObject()

		def HasALeadingObject()
			return This.StartsWithAObject()

		def HasAStartingObject()
			return This.StartsWithAObject()

		#>

	  #--------------------------------------------#
	 #  CHECKING IF THE LIST ENDS WITH AN OBJECT  #
	#--------------------------------------------#

	def EndsWithAObject()
		bResult = FALSE
		
		if This.NumberOfItems() > 1 and
		   isObject(This.LastItem())

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithATrailingObject()
			return This.EndsWithAObject()

		def ContainsATrailingObject()
			return This.EndsWithAObject()

		def HasATrailingObject()
			return This.EndsWithAObject()

		#>

	  #==============================================#
	 #  GETTING THE SIZES OF THE ITEMS OF THE LIST  #
	#==============================================#

	def Sizes()
		nLen = len(@aContent)
		anResult = []

		for i = 1 to nLen
			nSize = 0

			if isNumber(@aContent[i])
				nSize = StzNumberQ(@aContent[i]).
					StringValueQ().NumberOfChars()

			but isString(@aContent[i])
				oQString = new qstring2()
				oQString.append(@aContent[i])
				nSize = oQString.count()

			but isList(@aContent[i])
				nSize = len(@aContent[i])

			else
				if @IsStzObject(@aContent[i])
					nSize = @aContent[i].Size()
				ok
			ok

			anResult + nSize
		next

		return anResult

	def MaxSize()
		nResult = @Max(This.Sizes())
		return nResult

		def LargestSize() # Note this is different from LargestItem()
			return This.MaxSize()

	def MinSize()
		nResult = @Min(This.Sizes())
		return nResult

		def SmallestSize() # Note this is different from SmallestItem()
			return This.MinSize()

	  #==========================================#
	 #  SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#==========================================#

	def SmallestItem()

		if This.NumberOfItems() > 1
			aSorted = This.SortedInAscending()
			return aSorted[1]

		ok

		def Smallest()
			return This.SmallestItem()

	def LargestItem()
		if This.NumberOfItems() > 1
			aSorted = This.SortedInDescending()
			return aSorted[1]
		ok

		def Largest()
			return This.LargestItem()

		def GreatestItem()
			return This.LargestItem()

		def Greatest()
			return This.LargestItem()

	  #--------------------------------------------------#
	 #  FINDING SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#--------------------------------------------------#

	def FindSmallestItem()
		return This.FindAll( This.SmallestItem() )

		def FindSmallest()
			return This.FindSmallestItem()

		def FindAllOccurrencesOfSmallestItem()
			return This.FindSmallestItem()

		def FindAllOccurrencesOfSmallest()
			return This.FindSmallestItem()

	def FindLargestItem()
		return This.FindAll( This.LargestItem() )

		def FindLargest()
			return This.FindLargestItem()

		def FindAllOccurrencesOfLargestItem()
			return This.FindLargestItem()

		def FindAllOccurrencesOfLargest()
			return This.FindLargestItem()

	  #-------------------------------------------------------------------#
	 #  NUMBER OF OCCURRENCES OF SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#-------------------------------------------------------------------#

	def NumberOfOccurrencesOfSmallestItem()
		return len( This.FindAllOccurrencesOfSmallestItem() )

		def NumberOfOccurrenceOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfOccurrencesOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfOccurrenceOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def NumberOfSmallest()
			return This.NumberOfOccurrencesOfSmallestItem()

		def CoutOccurrencesOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def HowManyOccurrencesOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

		def HowManyOccurrenceOfSmallestItem()
			return This.NumberOfOccurrencesOfSmallestItem()

	def NumberOfOccurrencesOfLargestItem()
		return len( This.FindAllOccurrencesOfLargestItem() )

		def NumberOfOccurrenceOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfOccurrencesOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfOccurrenceOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def NumberOfLargest()
			return This.NumberOfOccurrencesOfLargestItem()

		def CoutOccurrencesOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def HowManyOccurrencesOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

		def HowManyOccurrenceOfLargestItem()
			return This.NumberOfOccurrencesOfLargestItem()

	  #--------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#--------------------------------------------------------------------#

	def FindNthOccurrenceOfSmallestItem(n)
		if CheckParams()
			if isString(n)
				if Q(n).IsEither(:First, :Or = :FirstItem)
					n = 1
				but Q(n).IsEither(:Last, :Or = :LastItem)
					n = This.NumberOfOccurrencesOfSmallestItem()
				ok
			ok
		ok

		return This.FindAll( This.SmallestItem() )[n]

		def FindNthOccurrenceOfSmallest(n)
			return This.FindNthSmallestItem(n)

	def FindNthOccurrenceOfLargestItem(n)
		if CheckParams()
			if isString(n)
				if Q(n).IsEither(:First, :Or = :FirstItem)
					n = 1
				but Q(n).IsEither(:Last, :Or = :LastItem)
					n = This.NumberOfOccurrencesOfLargestItem()
				ok
			ok
		ok

		return This.FindAll( This.LargestItem() )[n]

		def FindNthOccurrenceOfLargest(n)
			return This.FindNthLargestItem(n)

		def FindNthOccurrenceOfGreatestItem(n)
			return This.FindNthLargestItem(n)

		def FindNthOccurrenceOfGreatest(n)
			return This.FindNthLargestItem(n)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSCS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				return This.FindBeforeItemCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindBeforePositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				return This.FindAfterItemCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAfterPositionCS( p1, p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitive)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitive)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				n = This.FindFirstCS(p2[2], pCaseSensitive)
				return This.FindBeforePositionCS( p1[2], n, pCaseSensitive)

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindBeforePositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				n = This.FindLastCS(p2[2], pCaseSensitive)
				return This.FindAfterPositionCS( p1[2], n, pCaseSensitive)


			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAfterPositionCS( p1[2], p2[2], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindCSXT(p1, p2, TRUE)

	  #=====================================================#
	 #  FINDING OCCURRENCES OF AN ITEM IN A GIVEN SECTION  #
	#=====================================================#

	def FindInSectionCS(pItem, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstItem ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastItem ])
					n1 = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastItem ])
					n2 = This.NumberOfItems()
				but Q(n1).IsOneOfThese([ :First, :FirstItem ])
					n2 = 1
				ok
			ok

			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		anPos = This.SectionQ(n1, n2).FindCS(pItem, pCaseSensitive)
		nLen = len(anPos)

		n1 = Min([ n1, n2 ])

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

		#< @FunctionAlternativeForm

		def FindInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pItem, n1, n2)
		return This.FindInSectionCS(pItem, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindInSectionZ(pItem, n1, n2)
			return This.FindInSection(pItem, n1, n2)

		#>

	  #---------------------------------------------------#
	 #  FINDING OCCURRENCES OF AN ITEM IN MANY SECTIONS  #
	#---------------------------------------------------#

	def FindInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + anPos[j]
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pItem, paSections)
		return This.FindInSectionsCS(pItem, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindInManySections(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		#--

		def FindInSectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		def FindInManySectionsZ(pItem, paSections)
			return This.FindInSections(pItem, paSections)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#========================================================#

	def FindNthInSectionCS(n, pItem, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstItem ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastItem ])
					n1 = This.NumberOfItems()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastItem ])
					n2 = This.NumberOfItems()
				but Q(n1).IsOneOfThese([ :First, :FirstItem ])
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		nPos = This.SectionQ(n1, n2).FindNthCS(n, pItem, pCaseSensitive)
		nResult = n1 + nPos - 1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthInSectionCSZ(n, pItem, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSection(n, pItem, n1, n2)
		return This.FindNthInSectionCS(n, pItem, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindNthInSectionZ(n, pItem, n1, n2)
			return This.FindNthInSection(n, pItem, n1, n2)

		#>

	  #------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#------------------------------------------------------#

	def FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(paSections)
		nResult = 0
		nCounter = 0

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pItem, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				nCounter++
				if nCounter = n
					nResult = anPos[j]
					exit
				ok
			next
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthInManySectionsCS(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		#--

		def FindNthInSectionsCSZ(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZ(n, pItem, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSections(n, pItem, paSections)
		return This.FindNthInSectionsCS(n, pItem, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindNthInManySections(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		#--

		def FindNthInSectionsZ(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		def FindNthInManySectionsZ(n, pItem, paSections)
			return This.FindNthInSections(n, pItem, paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#==========================================================#

	def FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pItem, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSectionCS(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		def FindFristInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSection(pItem, n1, n2)
		return This.FindFirstInSectionCS(pItem, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindFirstInSectionZ(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSection(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		def FindFristInSectionZ(pItem, n1, n2)
			return This.FindFirstInSection(pItem, n1, n2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#--------------------------------------------------------#

	def FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindFirstInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindFirstInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFristInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindFristInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindFristInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSections(pItem, paSections)
		return This.FindFirstInSectionsCS(pItem, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindFirstInManySections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#--

		def FindFirstInSectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFirstInManySectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#>

		#< @FunctionMisspelledForms

		def FindFristInSections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFristInManySections(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#--

		def FindFristInSectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		def FindFristInManySectionsZ(pItem, paSections)
			return This.FindFirstInSections(pItem, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN A GIVEN SECTION  #
	#=========================================================#

	def FindLastInSectionCS(pItem, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pItem, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastInSectionCSZ(pItem, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pItem, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSection(pItem, n1, n2)
		return This.FindLastInSectionCS(pItem, n1, n2, TRUE)
		
		#< @FunctionAlternativeForm

		def FindLastInSectionZ(pItem, n1, n2)
			return This.FindLastInSection(pItem, n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF AN ITEM IN MANY SECTIONS  #
	#-------------------------------------------------------#

	def FindLastInSectionsCS(pItem, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindLastInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastInManySectionsCS(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		#--

		def FindLastInSectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZ(pItem, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSections(pItem, paSections)
		return This.FindLastInSectionsCS(pItem, paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindLastInManySections(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		#--

		def FindLastInSectionsZ(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		def FindLastInManySectionsZ(pItem, paSections)
			return This.FindLastInSections(pItem, paSections)

		#>

	  #====================================================================================#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN POSITION OR A GIVEN OTHER ITEM  #
	#====================================================================================#

	def FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		if CheckParams()
			if isList(pPosOrItem) and Q(pPosOrItem).IsPositionNamedParam()
				return This.FindbeforePositionCS(pItem, pPosOrItem[2], pCaseSensitive)
			ok
		ok

		return This.FindBeforeItemCS(pItem, pPosOrItem, pCaseSensitive)


		#< @FunctionAlternativeForms

		def FindAllBeforeCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesBeforeCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		#--

		def FindBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindAllBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesBeforeCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindBeforeCS(pItem, pPosOrItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBefore(pItem, pPosOrItem)
		return This.FindBeforeCS(pItem, pPosOrItem, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBefore(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindOccurrencesBefore(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		#--

		def FindBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindAllBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		def FindOccurrencesBeforeZ(pItem, pPosOrItem)
			return This.FindBefore(pItem, pPosOrItem)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN POSITION  #
	#==============================================================# 

	def FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		anResult = This.FindInSectionCS(pItem, 1, pnPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforePositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		#--

		def FindBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindAllBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesBeforePositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindBeforePositionCS(pItem, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforePosition(pItem, pnPos)
		return This.FindBeforePositionCS(pItem, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforePosition(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindOccurrencesBeforePosition(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		#--

		def FindBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindAllBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		def FindOccurrencesBeforePositionZ(pItem, pnPos)
			return This.FindBeforePosition(pItem, pnPos)

		#>

	  #----------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM BEFORE A GIVEN OTHER ITEM  #
	#================================================================# 

	def FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
		if EarlyCheck()
			if This.NumberOfItems() = 0
				return 0
			ok
		ok

		nPos = This.FindFirstCS(pcOtherSubStr, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, 1, nPos, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#--

		def FindBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindAllBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesBeforeItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindBeforeItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBeforeItem(pItem, pcOtherSubStr)
		return This.FindBeforeItemCS(pItem, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllBeforeItem(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindOccurrencesBeforeItem(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		#--

		def FindBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindAllBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		def FindOccurrencesBeforeItemZ(pItem, pcOtherSubStr)
			return This.FindBeforeItem(pItem, pcOtherSubStr)

		#>

	  #============================================================================#
	 #  FINDING THE OCCURRENCES OF A ITEM AFTER A GIVEN POSITION OR A GIVEN ITEM  #
	#============================================================================#

	def FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		if isList(pPosOrItem) and Q(pPosOrItem).IsPositionNamedParam()
			return This.FindAfterPositionCS(pItem, pPosOrItem[2], pCaseSensitive)
		else
			return This.FindAfterItemCS(pItem, pPosOrItem, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindAllAfterCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesAfterCS(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		#--

		def FindAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindAllAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		def FindOccurrencesAfterCSZ(pItem, pPosOrItem, pCaseSensitive)
			return This.FindAfterCS(pItem, pPosOrItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfter(pItem, pPosOrItem)
		return This.FindAfterCS(pItem, pPosOrItem, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfter(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindOccurrencesAfter(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		#--

		def FindAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindAllAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		def FindOccurrencesAfterZ(pItem, pPosOrItem)
			return This.FindAfter(pItem, pPosOrItem)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF AN ITEM AFTER A GIVEN POSITION  #
	#=============================================================# 

	def FindAfterPositionCS(pItem, pnPos, pCaseSensitive)
		nLen = This.NumberOfItems()
		if nLen = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, pnPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterPositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCS(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		#--

		def FindAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindAllAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		def FindOccurrencesAfterPositionCSZ(pItem, pnPos, pCaseSensitive)
			return This.FindAfterPositionCS(pItem, pnPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterPosition(pItem, pnPos)
		return This.FindAfterPositionCS(pItem, pnPos, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterPosition(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindOccurrencesAfterPosition(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		#--

		def FindAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindAllAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		def FindOccurrencesAfterPositionZ(pItem, pnPos)
			return This.FindAfterPosition(pItem, pnPos)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE OCCURRENCES OF A NITEM AFTER A GIVEN OTHER ITEM  #
	#===============================================================# 

	def FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
		nLen = This.NumberOfItems()
		if nLen = 0
			return 0
		ok

		nPos = This.FindLastCS(pcOtherSubStr, pCaseSensitive)
		if nPos = 0
			return 0
		ok

		anResult = This.FindInSectionCS(pItem, nPos, nLen, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindAllAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#--

		def FindAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindAllAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		def FindOccurrencesAfterItemCSZ(pItem, pcOtherSubStr, pCaseSensitive)
			return This.FindAfterItemCS(pItem, pcOtherSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAfterItem(pItem, pcOtherSubStr)
		return This.FindAfterItemCS(pItem, pcOtherSubStr, TRUE)

		#< @FunctionAlternativeForms

		def FindAllAfterItem(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindOccurrencesAfterItem(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		#--

		def FindAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindAllAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		def FindOccurrencesAfterItemZ(pItem, pcOtherSubStr)
			return This.FindAfterItem(pItem, pcOtherSubStr)

		#>

	  #==================================================================#
	 #  GETTING NUMBER OF OCCURRENCES OF AN ITEM IN THE GIVEN SECTIONS  #
	#==================================================================#

#TODO: Add
#	FindNearest("hi", :To = "emm")
#	FindNearest("hi", :ToPositio = 10)

	def NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		nResult = len( This.FindItemInSectionsCS(pItem, paSections, pCaseSensitive) )
		return nResult

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrenceInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrenceOfItemInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def NumberOfOccurrencesOfItemInTheseSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrencesInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrenceOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		def HowManyOccurrencesOfItemInSectionsCS(pItem, paSections, pCaseSensitive)
			return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceInSections(pItem, paSections)
		return This.NumberOfOccurrenceInSectionsCS(pItem, paSections, TRUE)

		#< @FunctionalternativeForms

		def NumberOfOccurrenceOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrenceInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrenceOfItemInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def NumberOfOccurrencesOfItemInTheseSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrenceInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrencesInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrenceOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		def HowManyOccurrencesOfItemInSections(pItem, paSections)
			return This.NumberOfOccurrenceInSections(pItem, paSections)

		#>

	  #======================================================#
	 #  GETTING NTH SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#======================================================#

	def NthSmallestItem(n)
		return This.Copy().RemoveDuplicatesQ().SortedInAscending()[n]

		def NthSmallest(n)
			return This.NthSmallestItem(n)

	def NthLargestItem(n)
		return This.Copy().RemoveDuplicatesQ().SortedInDescending()[n]

		def NthLargest(n)
			return This.NthLargestItem(n)

		def NthGreatestItem(n)
			return This.NthLargestItem(n)

		def NthGreatest(n)
			return This.NthLargestItem(n)

	  #------------------------------------------------------#
	 #  FINDING NTH SMALLEST AND LARGEST ITEMS IN THE LIST  #
	#------------------------------------------------------#

	def FindNthSmallestItem(n)
		return This.FindAll( This.NthSmallestItem(n) )

		def FindNthSmallest(n)
			return This.FindNthSmallestItem(n)

	def FindNthLargestItem(n)
		return This.FindAll( This.NthLargestItem(n) )

		def FindNthLargest(n)
			return This.FindNthLargestItem(n)

		def FindNthGreatestItem(n)
			return This.FindNthLargestItem(n)

		def FindNthGreatest(n)
			return This.FindNthLargestItem(n)

	  #-------------------------------#
	 #  FINDING OBJECTS IN THE LIST  #
	#===============================#

	def FindObjects()
		
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				anResult + i
			ok
		next

		return anResult
			
		def FindObjectsZ()
			return This.FindObjects()

	def FindObjectsAsSections()
		aContent = This.Copy().Content() + 0
		nLen = len(aContent)

		if nLen = 0
			return []

		but nLen = 1 and isObject(aContent[1])
			return [ [1, 1] ]
		ok

		aResult = []
		n1 = 1

		for i = 2 to nLen - 1
			if isObject(aContent[i]) and NOT isObject(aContent[i-1])
				n1 = i
			ok

			if isObject(aContent[i]) and NOT isObject(aContent[i+1])
				n2 = i
				aResult + [n1, n2]
			ok	

		next

		return aResult

		def FindObjectsZZ()
			return This.FindObjectsAsSections()

	def ObjectsZ()

		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		acSeen = []
		for i = 1 to nLen	
			if NOT isObject(aContent[i])
				i++
			ok

			cName = :@NoName

			if ObjectIsStzObject(aContent[i])
				cName = aContent[i].VarName()
			ok

			if ring_find(acSeen, cName)
				loop
			ok

			anPos = This.FindObject(cName)
			aResult + [ cName, anPos ]
			acSeen + cName

		next

		return aResult

		def ObjectsAndTheirPositions()
			return This.Objects()

	def TheseObjectsZ(paoObjects)

		if CheckParams() = TRUE
			if NOT ( isList(paoObjects) and Q(paoObjects).EachItemIsEitherA(:String, :Or, :Object) )
				StzRaise("Incorrect param type! paoObjects must be a list of strings and objects.")
			ok
	
		ok

		# Doing the job

		nLen = len(paoObjects)
		aResult = []
		acSeen = []

		for i = 1 to nLen
			if isObject(paoObjects[i])
				cName = @ObjectVarName(paoObjects[i])
			else
				cName = paoObjects[i]
			ok

			if ring_find(acSeen, cName) = 0
				anPos = This.FindObject(cName)
				aResult + [ cName, anPos ]
				acSeen + cName
			ok
		next


		return aResult

	  #-----------------------------------------------#
	 #  FINDING NAMED & UNNAMED OBJECTS IN THE LIST  #
	#===============================================#

	def FindNamedObjects()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				loop
			ok

			if @ObjectVarName(aContent[i]) != :@NoName
				anResult + i
			ok
		next

		return anResult

	def FindUnnamedObjects()
		aContent = This.Content()
		nLen = len(acontent)
		anResult = []

		for i = 1 to nLen
			if NOT isObject(aContent[i])
				loop
			ok

			if @ObjectVarName(aContent[i]) = :@NoName
				anResult + i
			ok
		next

		return anResult

	def FindNamedObject(p) # pass an object or an object name in string

		cObjectVarName = :@NoName
		if isObject(p)
			cObjectVarName = p.VarName()
		but isString(p)
			cObjectVarName = p
		else
			StzRaise("Incorrect param type! p must be an object or a string containing an object varname.")
		ok

		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if isObject(aContent[i]) and
			   aContent[i].VarName() = cObjectVarName

				anResult + i
				
			ok
		next

		return anResult

		def FindThisNamedObject(p)
			return This.FindNamedObject(p)

	def NamedObjectZ(paObject)
		if CheckParams()
			if NOT isObject(paObject) 
				StzRaise("Incorrect param type! paObject must be a list.")
			ok
		ok

		anPos = This.FindNamedObject(paObject)
		aResult = [ paObject, anPos ]	
		return aResult

	  #----------------------#
	 #  FINDING STZNUMBERS  #
	#======================#

	def FindStzNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzNumber(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzNumbers()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzNumber(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #----------------------#
	 #  FINDING STZSTRINGS  #
	#======================#

	def FindStzStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzString(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzStrings()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzString(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #---------------------#
	 #  FINDING STZLISTSS  #
	#=====================#

	def FindStzLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzList(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzLists()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzList(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #----------------------#
	 #  FINDING STZOBJECTS  #
	#======================#

	def FindStzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzObject(aContent[i])
				anResult + i
			ok
		next

		return anResult

	def StzObjects()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			if @IsStzObject(aContent[i])
				anResult + aContent[i]
			ok
		next

		return anResult

	  #===========================================================#
	 #  CHECKING IF THE LIST CONTAINS JUST STRINGS IN UPPERCASE  #
	#===========================================================#

	def IsUppercase()
		if This.IsListOfStrings()
		   	acContent = This.ToListOfStzStrings()
			nLen = len(acContent)

			bResult = TRUE

			for i = 1 to nLen
				if acContent[i].IsUppercase() = FALSE
					bResult = FALSE
					exit
				ok
			next

			return bResult

		else
			return FALSE
		ok

		#< @FunctionFluentForm

		def IsUppercaseQ()
			if This.IsUppercase()
				return This
			else
				return AFalseObject()
			ok

		#>

		#< @FunctionAlternativeForms

		def IsAnUppecase()
			return This.IsUppercase()

			def IsAnUppercaseQ()
				return This.IsUppercaseQ()

		def IsUppercased()
			return This.IsUppercase()

			def IsUppercasedQ()
				return This.IsUppercaseQ()

		def IsUpper()
			return This.IsUppercase()

			def IsUpperQ()
				return This.IsUppercaseQ()

		def IsInUppercase()
			return This.IsUppercase()

			def IsInUppercaseQ()
				return This.IsUppercaseQ()

		def InUppercase()
			return This.IsUppercase()

			def InUppercaseQ()
				return This.IsUppercaseQ()

		#>

	  #-----------------------------------------------------------#
	 #  CHECKING IF THE LIST CONTAINS JUST STRINGS IN LOWERCASE  #
	#-----------------------------------------------------------#

	def IsLowercase()
		if This.IsListOfStrings()
		   	acContent = This.ToListOfStzStrings()
			nLen = len(acContent)

			bResult = TRUE

			for i = 1 to nLen
				if acContent[i].IsLowercase() = FALSE
					bResult = FALSE
					exit
				ok
			next

			return bResult

		else
			return FALSE
		ok

		#< @FunctionFluentForm

		def IsLowercaseQ()
			if This.IsLowercase()
				return This
			else
				return AFalseObject()
			ok


		#>

		#< @FunctionAlternativeForms

		def IsALowercase()
			return This.IsLowercase()

			def IsALowercaseQ()
				return This.IsLowercaseQ()

		def IsLowercased()
			return This.IsLowercase()

			def IsLowercasedQ()
				return This.IsLowercaseQ()

		def IsLower()
			return This.IsLowercase()

			def IsLowerQ()
				return This.IsLowercaseQ()

		def InLowerCase()
			return This.IsLowercase()

			def InLowercaseQ()
				return This.IsLowercaseQ()
	
		def IsInLowerCase()
			return This.IsLowercase()

			def IsInLowercaseQ()
				return This.IsLowercaseQ()

		#>

	  #------------------------------------------------------------#
	 #  TRANSFORMING THE LIST TO ITS REPRESENTATION IN RING CODE  #
	#------------------------------------------------------------#

	def ToCode()
		cResult = @@( This.Content() )
		return cResult

		def ToCodeQ()
			return new stzString(This.ToCode())

	  #------------------------------------------------------------------#
	 #  STRINGIFYING THE LIST (ALL ITEMS ARE FORCED TO BECOME STRINGS)  #
	#------------------------------------------------------------------#
	#TODO: Abstract this function in stzObject

	def Stringify()

		nLen = len(@aContent)

		for i = 1 to nLen

			if isString(@aContent[i])
				loop

			but isNumber(@aContent[i])
				@aContent[i] = ""+ @aContent[i]

			but isList(@aContent[i])
				@aContent[i] = @@(@aContent[i])

			but isObject(@aContent[i])
				@aContent[i] = @ObjectVarName(@aContent[i])
			ok

		next

		#< @FunctionFluentForm

		def StringifyQ()
			This.Stringify()
			return This

		def StringifyQR(pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.Stringified() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def StringifyItems()
			This.Stringify()

			def StringifyItemsQ()
				return This.StringifyQ()

			def StringifyItemsQR(pcReturnType)
				return This.StringifyQR(pcReturnType)

		#>

	def Stringified()
		acResult = This.Copy().StringifyQ().Content()
		return acResult

		def ItemsStringified()
			return This.Stringified()

		def ToListOfStringifiedItems()
			return This.Stringified()

	  #--------------------------------------#
	 #  STRINGIFYING THE LISTS IN THE LIST  #
	#--------------------------------------#

	def StringifyLists()
		nLen = len(@aContent)

		for i = 1 to nLen
			if isList(@aContent[i])
				@aContent[i] = @@(@aContent[i])	
			ok
		next

		def StringifylistsQ()
			This.Stringifylists()
			return This

	def ListsStringified()
		aResult = This.Copy().StringifyListsQ().Content()
		return aResult

	  #----------------------------------------#
	 #  STRINGIFYING THE OBJECTS IN THE LIST  #
	#----------------------------------------#

	def StringifyObjects()

		nLen = len(@aContent)

		for i = 1 to nLen
			if isObject(@aContent[i])
				@aContent[i] = @ObjectVarName(@aContent[i])	
			ok
		next


		def StringifyObjectsQ()
			This.StringifyObjects()
			return This

	def ObjectsStringified()
		aResult = This.Copy().StringifyObjectsQ().Content()
		return aResult

	  #----------------------------------------------#
	 #  STRINGIFYING THE NAMED OBJECTS IN THE LIST  #
	#----------------------------------------------#

	def StringifyNamedObjects()

		nLen = len(@aContent)

		for i = 1 to nLen
			if @IsNamedObject(@aContent[i])
				@aContent[i] = @ObjectVarName(@aContent[i])	
			ok
		next


		def StringifyNamedObjectsQ()
			This.StringifyNamedObjects()
			return This

	def NamedObjectsStringified()
		aResult = This.Copy().StringifyNamedObjectsQ().Content()
		return aResult

	  #---------------------------------------------------------------------#
	 #  Q-STRINGIFYING THE LIST (ALL ITEMS ARE FORCED TO BECOME QSTRINGS)  #
	#---------------------------------------------------------------------#

	def QStringified()

		aContent = This.Content()
		nLen = len(aContent)

		aoResult = []
		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)
				cItem = item

			but isList(item)
				cItem = @@(item)

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			oQStr = new QString2()
			oQStr.append(cItem)
			aoResult + oQStr
		next

		return aoResult

		#< @FunctionAlternativeForms

		def ToListOfQStrings()
			return This.QStringified()

		def ToListOfQStringifiedItems()
			return This.QStringified()

		def ItemsQStringified()
			return This.QStringified()

		#>

	  #---------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING -- EXTENDED  #
	#---------------------------------------------------------------------------------------#
	# This extented version returns along the stringified items, the list of positions of
	# the items beeing affected by the replacement operation
	#--> Used internally in some places to boost performance

	def StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		#NOTE: General note on performance of code written here in SoftanzaLib

		# For all loops running on large data (tens of thousands of times and more), we
		# don't rely on softanza objects services (stzString and alike), we use Qt directly instead!

		# In fact the problem comes, not from Softanza objects themselves, but from
		# going back and forth between Ring and Qt

		# Resolving params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcOtherSubStr) and Q(pcOtherSubStr).IsWithOrByOrUsingNamedParam()
			pcOtherSubStr = pcOtherSubStr[2]
		ok

		if NOT isString(pcOtherSubStr)
			StzRaise("Incorrect param type! pcOtherSubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT (pCaseSensitive = TRUE or pCaseSensitive = FALSE)
			StzRaise("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		acResult = []
		anPos = []
		anPosExt = []
		cExtension = Q("_").RepeatedNTImes( ( Q(pcOtherSubStr).NumberOfChars() * 2 ) )

		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)

				oQStr = new QString2()
				oQStr.append(item)

				bExtend = FALSE
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = TRUE
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					oQStr.replace_2(pcSubStr, pcOtherSubStr, pCaseSensitive)
					cItem = oQStr.mid(0, oQStr.count())
					anPos + i
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem = cExtension + cItem + cExtension
					anPosExt + i
				ok

			but isList(item)
				item = @@(item)
				oQStr = new QString2()
				oQStr.append(item)

				bExtend = FALSE
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = TRUE
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else

					oQStr.replace_2(pcSubStr, pcOtherSubStr, pCaseSensitive)
					cItem = oQStr.mid(0, oQStr.count())
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem += cExtendion
					anPosExt + i
				ok

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			acResult + cItem
		next

		aResult = [ acResult, anPos, anPosExt ]
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyAndReplaceCSXTQR(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedAndCommaReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyAndReplaceXT(pcSubStr, pcOtherSubStr)
		This.StringifyAndReplaceCSXT(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionFluentForm

		def StringifyAndReplaceXTQ(pcSubStr, pcOtherSubStr)
			This.StringifyAndReplaceXT(pcSubStr, pcOtherSubStr)
			return This

		def StringifyAndReplaceXTQR(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyAndReplaceXTQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)
			return This.StringifiedAndReplacedXT(pcSubStr, pcOtherSubStr)

	  #-------------------------------------------------------------------------------#
	 #  STRINGIFYING THE ITEMS AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING  #
	#-------------------------------------------------------------------------------#

	def StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		aResult = This.Copy().StringifyAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()[1]
		This.Update(aResult)

		#< @FunctionFluentForm

		def StringifyAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyAndReplaceCSQR(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedAndCommaReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyAndReplace(pcSubStr, pcOtherSubStr)
		This.StringifyAndReplaceCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionFluentForm

		def StringifyAndReplaceQ(pcSubStr, pcOtherSubStr)
			This.StringifyAndReplace(pcSubStr, pcOtherSubStr)
			return This

		def StringifyAndReplaceQR(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedAndReplaced(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedAndReplaced(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyAndReplaceQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedAndReplaced(pcSubStr, pcOtherSubStr)
			return This.StringifiedAndReplaced(pcSubStr, pcOtherSubStr)

	  #----------------------------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS, LOWERCASING THEM, AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING -- EXTENDED  #
	#==========================================================================================================#

	# A special function used internally by Softanza to boost its performance

	def StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		# Resolving params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcOtherSubStr) and Q(pcOtherSubStr).IsWithOrByOrUsingNamedParam()
			pcOtherSubStr = pcOtherSubStr[2]
		ok

		if NOT isString(pcOtherSubStr)
			StzRaise("Incorrect param type! pcOtherSubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT (pCaseSensitive = TRUE or pCaseSensitive = FALSE)
			StzRaise("Incorrect param! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Doing the job

		aContent = This.Content()
		nLen = len(aContent)

		acResult = []
		anPos = []
		cItem = ""
		anPosExt = []
		cExtension = Q("_").RepeatedNTImes( ( Q(pcOtherSubStr).NumberOfChars() * 2 ) )
		
		cItem = ""

		for i = 1 to nLen
			item = aContent[i]
			if isNumber(item)
				cItem = ""+ item

			but isString(item)

				oQStr = new QString2()
				oQStr.append(item)


				bExtend = FALSE
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = TRUE
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					oQStr.replace_2(pcSubStr, pcOtherSubStr, pCaseSensitive)
					cItem = oQStr.mid(0, oQStr.count())
					anPos + i
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem = cExtension + cItem + cExtension
					anPosExt + i
				ok

			but isList(item)
				item = @@(item)
				oQStr = new QString2()
				oQStr.append(item)

				bExtend = FALSE
				if oQStr.contains(pcOtherSubStr, pCaseSensitive)
					bExtend = TRUE
				ok

				if NOT oQStr.contains(pcSubStr, pCaseSensitive)
					cItem = item
				else
					oQStr.replace_2(pcSubStr, pcOtherSubStr, pCaseSensitive)
					cItem = oQStr.mid(0, oQStr.count())
				ok

				if bExtend and ring_find(anPos, i) = 0
					cItem += cExtendion
					anPosExt + i
				ok

			but isObject(item)
				cItem = @ObjectVarName(aContent[i])
			ok

			oQLocale = new QLocale("C")
			cItem = oQLocale.toLower( cItem )
			acResult + cItem
		next

		aResult = [ acResult, anPos, anPosExt ]
		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyLowercaseAndReplaceCSXTQR(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedLowercasedAndCommaReplacedCSXT(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyLowercaseAndReplaceXT(pcSubStr, pcOtherSubStr)
		This.StringifyLowercaseAndReplaceCSXT(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceXTQ(pcSubStr, pcOtherSubStr)
			This.StringifyLowercaseAndReplaceXT(pcSubStr, pcOtherSubStr)
			return This

		def StringifyLowercaseAndReplaceXTQR(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyLowercaseAndReplaceXTQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)
			return This.StringifiedLowercasedAndReplacedXT(pcSubStr, pcOtherSubStr)

	  #-----------------------------------------------------------------------------------------------#
	 #  STRINGIFYING ITEMS, LOWERCASING THEM, AND REPLACING A SUBSTRING BY AN OTHER IN EACH STRING   #
	#-----------------------------------------------------------------------------------------------#
	# A special function used internally by Softanza to boost its performance

	def StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		#< QtBased | Uses QString2() #>

		aResult = This.Copy().StringifyLowercaseAndReplaceCSXTQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()[1]
		This.Update(aResult)
		
		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive)
			This.StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This

		def StringifyLowercaseAndReplaceCSQR(pcSubStr, pcOtherSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
		acResult = This.Copy().StringifyLowercaseAndReplaceCSQ(pcSubStr, pcOtherSubStr, pCaseSensitive).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)
			return This.StringifiedLowercasedAndCommaReplacedCS(pcSubStr, pcOtherSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StringifyLowercaseAndReplace(pcSubStr, pcOtherSubStr)
		This.StringifyLowercaseAndReplaceCS(pcSubStr, pcOtherSubStr, TRUE)

		#< @FunctionFluentForm

		def StringifyLowercaseAndReplaceQ(pcSubStr, pcOtherSubStr)
			This.StringifyLowercaseAndReplace(pcSubStr, pcOtherSubStr)
			return This

		def StringifyLowercaseAndReplaceQR(pcSubStr, pcOtherSubStr, pcReturnType)
			switch pcReturnType
			on :stzListOfStrings
				return new stzListOfstrings( This.StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)
		acResult = This.Copy().StringifyLowercaseAndReplaceQ(pcSubStr, pcOtherSubStr).Content()
		return acResult

		def ItemsStringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)
			return This.StringifiedLowercasedAndReplaced(pcSubStr, pcOtherSubStr)

	  #==================================================#
	 #  TRANSFORMING THE ITEMS OF THE LIST TO A STRING  #
	#==================================================#

	def ToString()
		return This.ToStringXT(:ConcatenatedUsing = NL)

		def ToStringQ()
			return new stzString( This.ToString() )

	def ToStringXT(pOption)
		if isString(pOption)
			if pOption = :AsCode
				return This.ToCode()

			but pOption = :Concatenated
				return This.StringifyQR(:stzListOfStrings).Concatenated()
			ok

		but isList(pOption) and
		    Q(pOption).IsOneOfTheseNamedParams([
			:Concatenated, :ConcatenatedUsing, :ConcatenatedWith ])

			if isList(pOption[2]) and
			   Q(pOption[2]).IsOneOfTheseNamedParams([ :Using, :With ])

				pOption[2] = pOption[2][2]
			ok

			return This.StringifyQR(:stzListOfStrings).ConcatenatedUsing(pOption[2])
		ok

		StzRaise("Unsupprorted syntax!")
			
		def ToStringXTQ(pOption)
			return new stzString( This.ToStringXT(pOption) )

	
	   #---------------------------------------------#
	  #  CHECKS IF THE LIST CONTAINS AT LEAST ONE   #
	 #  ITEM IN THE FORM OF A CONDITIONAL CODE     #
	#---------------------------------------------#

	def ContainsCCode()
		bResult = FALSE

		aTempList = This.List()
		nLen = len(aTempList)

		
		for i = 1 to nLen
			item = aTempList[i]

			if isList(item) and Q(item).IsWhereNamedParam()
				item = item[2]
			ok

			if isString(item) and
			   Q(item).TrimQ().IsBoundedBy(["{","}"])
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsConditionalCode()
			return This.ContainsCCode()

	  #====================================================#
	 #      CHECKING IF EACH ITEM IS EITHER ... OR ...    #
	#====================================================#

	def AllItemsAreEither(p1, p2, p3)

		/* EXAMPLE

		SYNTAX 1

		o1 = new stzList([ "to", -4, "be", "or", -8, "not", "to", -10, "be" ])
		? o1.EachItemIsEitherA( :Number, :Or, :String )
		#--> TRUE

		SYNTAX 2

		o1 = new stzList([ 6, -2, 9, 5, -10 ])
		? o1.EachItemIsEither(:Positive, :Or = :Negative, :Number )
		#--> TRUE

		*/

		# Checking params

		cSyntax = ""

		if isString(p2) and Q(p2).IsEither(:Or, :OrA)
			cSyntax = "1"

		but isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :Or, :OrA ])
			p2 = p2[2]
			cSyntax = "2"
		ok

		if cSyntax = ""
			StzRaise("Insupported syntax!")
		ok

		if NOT ( isString(p1) and isString(p2) and isString(p3) )
			StzRaise("Incorrect param types! p1, p2, and p3 must be all strings.")
		ok

		p1 = lower(p1)
		p2 = lower(p2)
		p3 = lower(p3)

		# Composing the conditional expression

		if cSyntax = "1"
			if p1 = :Object
				p1 = "n" + p1
			ok
			if p3 = :Object
				p3 = "n" + p3
			ok

			if p1 = "number" or p1 = "string" or p1 = "list"
				p1 = "A" + p1
			but p1 = "object"
				p1 = "An" + p1
			ok

			if p3 = "number" or p3 = "string" or p3 = "list"
				p3 = "A" + p3
			but p3 = "object"
				p3 = "An" + p3
			ok

			cCode = 'bOk = ( Q(aContent[@i]).Is' + p1 + '() or' + NL +
				'Q(aContent[@i]).Is' + p3 + '() )'

		but cSyntax = "2"

			if NOT This.AllItemsAre(p3)
				return FALSE
			ok
	
			if p1 = :Object
				p1 = "n" + p1
			ok
			if p2 = :Object
				p2 = "n" + p2
			ok

			if p1 = "number" or p1 = "string" or p1 = "list"
				p1 = "A" + p1
			but p1 = "object"
				p1 = "An" + p1
			ok

			if p2 = "number" or p2 = "string" or p2 = "list"
				p2 = "A" + p2
			but p2 = "object"
				p2 = "An" + p2
			ok

			cCode = 'bOk = ( Stz' + p3 + 'Q(aContent[@i]).Is' + p1 + '() ) or' + NL +
			        '( Stz' + p3 + 'Q(aContent[@i]).Is' + p2 + '() )'
	
		ok


		# Doing the job

		nLen = This.NumberOfItems()

		bResult = TRUE

		for @i = 1 to nLen
			@item = @aContent[@i]
			eval(cCode)

			if NOT bOk
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ItemsAreEither(p1, p2, p2)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEitherA(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def EachItemIsEitherAn(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		def ItemsHaveEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2)

		def AllItemsHaveEither(p1, p2, p3)
			return This.AllItemsAreEither(p1, p2, p3)

		#>

	def AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)
		if isList(p2) and Q(p2).IsANamedParam()
			p2 = p2[2]
		ok

		if This.AllItemsAreXT([p1, p3], paEvalDirection) or
		   This.AllItemsAreXT([p2, p3], paEvalDirection)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def ItemsAreEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherAXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def EachItemIsEitherAnXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def ItemsHaveEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		def AllItemsHaveEitherXT(p1, p2, p3, paEvalDirection)
			return This.AllItemsAreEitherXT(p1, p2, p3, paEvalDirection)

		#>

	  #----------------------------------------#
	 #      CHECKING IF ALL ITEMS ARE ...     #
	#----------------------------------------#

	def AllItemsAre(p)
		/* EXAMPLE

		? Q([ "ONE", "ONE", "ONE" ]).AllItemsAre("ONE")
		#--> TRUE

		
		? Q([ "ONE", "TWO", "THREE" ]).AllItemsAre([ :Strings ])
		#--> TRUE
		
		? Q([ "ONE", "TWO", "THREE" ]).AllItemsAre([ :Uppercase, :Strings ])
		#--> TRUE
		
		? Q([ "ONE", "TWO", "THREE" ]).AllItemsAre([ :Uppercase, W('len(@item)=3'), :Strings ])
		
		*/

		# Q([ "ONE", "ONE", "ONE" ]).AllItemsHave('len(@item) = 3')

		nLen = This.NumberOfItems()

		if isList(p) and Q(p).IsWhereNamedParam()

			p = p[2]
		ok

		if isString(p) and Q(p).TrimQ().IsBoundedBy([ "{", "}" ])

			cCode = 'bOk = (' + Q(p).TheseBoundsRemoved( "{", "}" ) + ')'

			bResult = TRUE
			for @i = 1 to nLen
				@item = @aContent[@i]
				eval(cCode)
				if NOT bOk
					bResult = FALSE
					exit
				ok
			next

			return bResult
			
		# ? Q([ "ONE", "TWO", "THREE" ]).AllItemsAre(:Strings)
		but isString(p) and
		    ( Q("stz" + p).IsStzClassName() or
		    Q("stz" + p).IsPluralOfStzClassName() )

			cMethod = ""

			if p = :Number or p = :Numbers
				cMethod = :IsANumber

			but p = :String or p = :Strings
				cMethod = :IsAString

			but p = :List or p = :Lists
				cMethod = :IsAList

			but p = :Object or p = :Objects
				cMethod = :IsAnObject
			
			else
				if Q('stz' + p).IsPluralOfAStzClass()
					p = PluralToStzClass('stz' + p)
				ok

				cMethod = 'Is' + Q(p).RemovedFromLeft("stz")

			ok

			# We could use this one line:
			# bResult = This.Check(:That = 'Q(@item).' + cMethod + '()')

			# But it should better for performance to make it manually

			cCode = 'bOk = ( Q(@item).' + cMethod + '() )'

			bResult = TRUE
			for @i = 1 to nLen
				@item = @aContent[@i]
				eval(cCode)
				if NOT bOk
					bResult = FALSE
					exit
				ok
			next

			return bResult

		# Q([ "ONE", "TWO", "THREE" ]).AllItemsAre([ :Uppercase, :Strings ])
		but isList(p) and Q(p).IsListOfStrings() and
		    Q("stz" + p[len(p)]).IsStzClassNameXT() # ..XT() --> in singular or plural form

			return This.AllItemsAreXT(p, :Default)

		but isList(p) and Q(p).ContainsCCode()

			return This.AllItemsAreXT(p, :Default)

		# ? Q([ "", "", "" ]).AllItemsAre("")
		else

			bResult = TRUE
			aItems = This.Content()
			nLen = len(aItems)

			for i = 1 to nLen

				if NOT Q(aItems[i]).IsEqualTo(p)
					bResult = FALSE
					exit
				ok
			next

			return bResult

		ok

		#< @FunctionAlternativeForms

		def ItemsAre(p)
			return This.AllItemsAre(p)

		def EachItemIs(p)
			return This.AllItemsAre(p)

		def EachItemIsA(p)
			return This.AllItemsAre(p)

		def EachItemIsAn(p)
			return This.AllItemsAre(p)

		def ItemsHave(p)
			return This.AllItemsAre(p)

		def AllItemsHave(p)
			return This.AllItemsAre(p)

		#>

	def AllItemsAreXT(p, paEvalDirection)

		if NOT isList(p)
			StzRaise("Incorrect param type! p must be a list.")
		ok

		if len(p) = 0
			return FALSE
		ok

		if isList(paEvalDirection) and
		   Q(paEvalDirection).IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if NOT Q(paEvalDirection).IsOneOfTheseCS([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], :CS = FALSE)

			StzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if Q(paEvalDirection).IsEither(:Default, :Or = :Nothing)
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		if Q(paEvalDirection).IsOneOfTheseCS([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			], :CS = FALSE)

			p = Q(p).Reversed()
		ok

		if len(p) = 1 and isString(p[1])
			return This.AllItemsAre(p[1])

		but Q(p).IsWhereNamedParam()
			return This.AllItemsAre(p[1])

		else
			nLenMethods = len(p)
			for i = 2 to nLenMethods
				if isList(p[i]) and Q(p[i]).IsWhereNamedParam()
					p[i] = p[i][2]
				ok
			next

			cMainClass = 'stz' + Q(p[1]).InfereStzClass()
			cCode = 'oObj = new ' + cMainClass + '(@item)'

			aContent = This.Content()
			nLenList = len(aContent)

			bResult = TRUE

			for i = 1 to nLenList
				@item = aContent[i]
		
				for j = 2 to nLenMethods

					if Q(p[j]).TrimQ().IsBoundedBy(["{","}"])
						cCode = 'bOk = (' + Q(p[j]).TrimQ().TheseBoundsRemoved("{","}") + ')'
					else
						cMethod = p[j]
						if cMethod = "number" or cMethod = "string" or cMethod = "list"
							cMethod = "A" + cMethod
						but cMethod = "object"
							cMethod = "AnObject"
						ok

						cCode = 'bOk = Q(@item).Is' + cMethod + '()'
					ok

					eval(cCode)
					if NOT bOk
						bResult = FALSE
						exit 2
					ok
				next j
			next i

			return bResult
		ok

		#< @FunctionAlternativeForms

		def ItemsAreXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		def EachItemIsXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		def EachItemIsAXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		def EachItemIsAnXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		def ItemsHaveXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		def AllItemsHaveXT(p, paEvalDirection)
			return This.AllItemsAreXT(pacDescriptors, paEvalDirection)

		#>

	  #================================#
	 #    USUED FOR NATURAL-CODING    #
	#================================#

	def IsAString()
		return FALSE

		def IsNotAString()
			return TRUE

	def IsAList()
		return TRUE

		def IsNotAList()
			return FALSE

	def IsAnObject()
		return TRUE

		def IsAObject()
			return TRUE

		def IsNotAnObject()
			return FALSE

	#--- ITEM

	def IsItem()
		return TRUE

		def IsAnItem()
			return This.IsItem()

	def IsItemOf(paList)
		return StzListQ(paList).Contains(This.Content())
	
		def AsAnItemOf(paList)
			return This.IsItemOf(paList)
	
	def IsItemIn(paList)
		return This.IsItemOf(paList)
	
		def IsAnItemIn(paList)
			return This.IsItemOf(paList)

	#--

	def IsMember()
		return TRUE

		def IsAMember()
			return This.IsMember()

	def IsMemberOf(paList)
		return StzListQ(paList).Contains(This.Content())
	
		def AsAMemberOf(paList)
			return This.IsMemberOf(paList)
	
	def IsMemberIn(paList)
		return This.IsMemberOf(paList)
	
		def IsAMemberIn(paList)
			return This.IsMemberOf(paList)


	#--- NUMBER

	def IsANumber()
		return FALSE

		def IsNotANumber()
			return TRUE

	def IsNumberOf(paList)
		return FALSE

		def IsANumberOf(paList)
			return FALSE
	
	def IsNumberIn(paList)
		return FALSE
	
		def IsANumberIn(paList)
			return FALSE

	#--- ITEM

	def IsLetter()
		return FALSE

		def IsALetter()
			return FALSE
	
	def IsLetterOf(pStrOrListOfChars)
		return FALSE

		def IsALetterOf(pcStr)
			return FALSE
	
	def IsLetterIn(pcStr)
		return FALSE

		def IsALetterIn(pcStr)
			FALSE

	def IsCharOf(pStrOrListOfChars)
		return FALSE

		def IsACharOf(pcStr)
			return FALSE

	def IsCharIn(pcStr)
		return FALSE

		def IsACharIn(pcStr)
			return FALSE

	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzlist"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	#===

	def ToListOfStzStrings()
		if NOT This.IsListOfStrings()
			StzRaise("Can't proceed! All items must be strings.")
		ok

		acContent = This.Content()
		nLen = len(acContent)

		aoResult = []

		for i = 1 to nLen
			aoResult + new stzString(acContent[i])
		next

		return aoResult

		def ToListOfStzStringsQ()
			return This.ToListOfStzStringsQR(:stzList)

		def ToListOfStzStringsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.ToListOfStzStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.ToListOfStzStrings() )

			on :stzListOfChars
				return new stzListOfChars( This.ToListOfStzStrings() )

			off

	  #==========================================#
	 #  TRANSFORMING THE LIST TO AN OTHER FORM  #
	#==========================================#

	def ToStzListOfChars()
		if NOT This.IsListOfChars()
			StzRaise("Can't cast the list into a stzListOfChars!")
		ok

		return new stzListOfChars( This.Content() )

	func ToListOfStzChars()
		if NOT This.IsListOfChars()
			StzRaise("Can't cast the list into a stzListOfChars!")
		ok

		acChars = This.Content()
		nLen = len(acChars)

		aResult = []

		for i = 1 to nLen
			oChar = new stzChar(acChars[i])
			aResult + oChar
		next

		return aResult

	  #========================================================#
	 #  TRANSFORMING THE LIST TO RING CODE (COMPUTABLE FORM)  #
	#========================================================#
 
	def ToListInStringInShortForm()
		cResult = This.ToCodeQ().ToListInShortForm()
		return cResult

		def ToListInShortForm()
			return This.ToListInStringInShortForm()

		def ToListInAStringInShortForm()
			return This.ToListInStringInShortForm()

	def ComputableForm()
		return @@( This.Content() )

		def ToListInString()
			return This.ComputableForm()

		def ToListInAString()
			return This.ComputableForm()

	  #===========================================#
	 #   GETTING A RANDOM POSITION IN THE LIST   #
	#===========================================#

	def RandomPosition()

		nResult = ARandomNumberBetween(1, This.NumberOfItems())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPosition()
			return This.RandomPosition()

		#--

		def APosition()
			return This.RandomPosition()

		def AnyPosition()
			return This.RandomPosition()

		def AnyRandomPosition()
			return This.RandomPosition()


		#>

	  #------------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST GREATER THAN THE ONE PROVIDED  #
	#------------------------------------------------------------------------#

	def RandomPositionGreaterThan(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfItems()

		if NOT ( n >= 1 and n < nLen - 1 )
			StzRaise("Out of range! n must be >= 1 and < (nLen-1).")
		ok

		nResult = ARandomNumberBetween(n+1, This.NumberOfItems())
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def RandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		def ARandomPositionAfter(n)
			return This.RandomPositionGreaterThan(n)

		#--

		def APositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)

		def AnyRandomPositionGreaterThan(n)
			return This.RandomPositionGreaterThan(n)


		#>

	  #---------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST LESS THAN THE ONE PROVIDED  #
	#---------------------------------------------------------------------#

	def RandomPositionLessThan(n)
		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		nLen = This.NumberOfItems()

		if NOT ( n > 1 and n <= nLen )
			StzRaise("Out of range! n must be > 1 and < nLen.")
		ok

		nResult = ARandomNumberBetween(1, n - 1)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def RandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		def ARandomPositionBefore(n)
			return This.RandomPositionLessThan(n)

		#--

		def APositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyPositionLessThan(n)
			return This.RandomPositionLessThan(n)

		def AnyRandomPositionLessThan(n)
			return This.RandomPositionLessThan(n)


		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM POSITION IN THE LIST EXECEPT THE ONE PROVIDED  #
	#-------------------------------------------------------------------#

	def RandomPositionExcept(n)

		if checkParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		aNumbers = Q( 1:This.NumberOfItems() ) - n
		nResult = ARandomNumberIn(aNumbers)
		return nResult

		#< @FunctionAlternativeForms

		def ARandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def RandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def ARandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#--

		def APositionExcept(n)
			return This.RandomPositionExcept(n)

		def APositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		def AnyRandomPositionExcept(n)
			return This.RandomPositionExcept(n)

		def AnyRandomPositionOtherThan(n)
			return This.RandomPositionExcept(n)

		#>

	  #-------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST  #
	#===========================================#

	def RandomSection()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aResult = This.Section(n1, n2)

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSection()
			return This.RandomSection()

		def ASection()
			return This.RandomSection()

		def AnySection()
			return This.RandomSection()

		def AnyRandomSection()
			return This.RandomSection()

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST ALONG WITH ITS POSITION  #
	#-------------------------------------------------------------------#

	def RandomSectionZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, n1 ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZ()
			return This.RandomSectionZ()

		def ASectionZ()
			return This.RandomSectionZ()

		def AnySectionZ()
			return This.RandomSectionZ()

		def AnyRandomSectionZ()
			return This.RandomSectionZ()

		#--

		def RandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ARandomSectionAndItsPosition()
			return This.RandomSectionZ()

		def ASectionAndItsPosition()
			return This.RandomSectionZ()

		def AnySectionAndItsPosition()
			return This.RandomSectionZ()

		def AnyRandomSectionAndItsPosition()
			return This.RandomSectionZ()

		#>

	  #------------------------------------------------------------------#
	 #   GETTING A RANDOM SECTION FROM THE LIST ALONG WITH ITS SECTION  #
	#------------------------------------------------------------------#

	def RandomSectionZZ()
		n1 = This.ARandomPosition()
		n2 = This.ARandomPositionOtherThan(n1)
		aSection = This.Section(n1, n2)

		if n1 > n2
			nTemp = n1
			n1 = n2
			n2 = nTemp
		ok

		aResult = [ aSection, [ n1, n2 ] ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomSectionZZ()
			return This.RandomSectionZZ()

		def ASectionZZ()
			return This.RandomSectionZZ()

		def AnySectionZZ()
			return This.RandomSectionZZ()

		def AnyRandomSectionZZ()
			return This.RandomSectionZZ()

		#>

	  #--------------------------------#
	 #  GETTING SOME RANDOM SECTIONS  #
	#--------------------------------#

	def RandomSections()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aSections = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aSections + [ n1, n2 ]
		next

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionAlternativeForms

		def SomeSections()
			return This.RandomSections()

		def SomeRandomSections()
			return This.RandomSections()

		def AnySections()
			return This.RandomSections()

		def AnyRandomSections()
			return This.RandomSections()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------#

	def RandomSectionsZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def SomeSectionsZ()
			return This.RandomSectionsZ()

		def SomeRandomSectionsZ()
			return This.RandomSectionsZ()

		def AnySectionsZ()
			return This.RandomSectionsZ()

		def AnyRandomSectionsZ()
			return This.RandomSectionsZ()

		#--

		def RandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def SomeSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def SomeRandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def AnySectionsAndTheirPositions()
			return This.RandomSectionsZ()

		def AnyRandomSectionsAndTheirPositions()
			return This.RandomSectionsZ()

		#>

	  #----------------------------------------------------------#
	 #  GETTING SOME RANDOM SECTIONS ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------#

	def RandomSectionsZZ()
		n = ARandomNumberIn(1:This.NumberOfItems())

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [ n1, n2 ] ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def SomeSectionsZZ()
			return This.RandomSectionsZZ()

		def SomeRandomSectionsZZ()
			return This.RandomSectionsZZ()

		def AnySectionsZZ()
			return This.RandomSectionsZZ()

		def AnyRandomSectionsZZ()
			return This.RandomSectionsZZ()

		#>

	  #-----------------------------#
	 #  GETTING N RANDOM SECTIONS  #
	#=============================#

	def NRandomSections(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aSections + [ n1, n2 ]
		next

		aResult = This.Sections(aSections)

		return aResult

	  #--------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------#

	def NRandomSectionsZ(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), n1 ]
		next

		return aResult

	  #-------------------------------------------------------#
	 #  GETTING N RANDOM SECTIONS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------#

	def NRandomSectionsZZ(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = []
		for i = 1 to n
			n1 = This.RandomPosition()
			n2 = This.RandomPositionOtherThan(n1)
			if n1 > n2
				nTemp = n1
				n1 = n2
				n2 = nTemp
			ok

			aResult + [ This.Section(n1, n2), [ n1, n2 ] ]
		next

		return aResult

	  #---------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST   #
	#=======================================#

	def RandomItem()

		cResult = This.ItemAtPosition( This.RandomPosition() )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomItem()
			return This.RandomItem()

		#--

		def AnItem()
			return This.RandomItem()

		def AnyItem()
			return This.RandomItem()

		def AnyRandomItem()
			return This.RandomItem()

		#>

	  #---------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST ALONG WITH ITS POSITION   #
	#---------------------------------------------------------------#

	def RandomItemZ()

		nPos =  This.RandomPosition()
		cItem = This.ItemAtPosition(nPos)
		aResult = [ cItem, nPos] 

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemZ()
			return This.RandomItemZ()

		#--

		def AnItemZ()
			return This.RandomItemZ()

		def AnyItemZ()
			return This.RandomItemZ()

		def AnyRandomItemZ()
			return This.RandomItemZ()

		#==

		def RandomItemAndItsPosition()
			return This.RandomItemZ()

		def ARandomItemAndItsPosition()
			return This.RandomItemZ()

		#--

		def AnItemAndItsPosition()
			return This.RandomItemZ()

		def AnyItemAndItsPosition()
			return This.RandomItemZ()

		def AnyRandomItemAndItsPosition()
			return This.RandomItemZ()

		#>

	  #------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED POSITION  #
	#==================================================================#

	def RandomItemAfterPosition(n)

		cResult = This.ItemAt( This.RandomPositionGreaterThan(n) )
		return cResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		#--

		def AnItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		def AnyItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		def AnyRandomItemAfterPosition(n)
			return This.RandomItemAfterPosition(n)

		#>

	   #--------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED  #
	 #  POSITION ALONG WITH ITS POSITION                      #
	#--------------------------------------------------------#

	def RandomItemAfterPositionZ(n)

		nPos = This.RandomPositionGreaterThan(n)
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#--

		def AnItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyRandomItemAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#==

		def RandomItemAndItsPositionAfterPosition(n)
			return This.RandomItemAfterPositionZ(n)

		def ARandomItemAndItsPositionAfterPosition(n)
			return This.RandomItemAfterPositionZ(n)

		#--

		def AnItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		def AnyRandomItemAndItsPositionAfterPositionZ(n)
			return This.RandomItemAfterPositionZ(n)

		#>

	  #--------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED ITEM  #
	#==============================================================#

	def RandomItemAfterCS(pItem, pCaseSensitive)
		nPos = This.RandomPositionAfter( This.FindFirstCS(pItem, pCaseSensitive) )
		result = This.ItemAt(nPos)
		return result

		#< @FunctionAlternativeForms

		def ARandomItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterCS(pItem, pCaseSensitive)

		def ARandomItemAfterItemCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		#--

		def AnItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		def AnyItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		def AnyRandomItemAfterCS(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemAfter(pItem)
		return This.RandomItemAfterCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemAfter(pItem)
			return This.RandomItemAfter(pItem)

		def ARandomItemAfterItem(pItem)
			return This.RandomItemAfterItem(pItem)

		#--

		def AnItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		def AnyItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		def AnyRandomItemAfter(pItem)
			return This.RandomItemAfterItem(pItem)

		#>

	   #--------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST AFTER THE PROVIDED  #
	 #  ITEM ALONG WITH ITS POSITION                          #
	#--------------------------------------------------------#

	def RandomItemAfterCSZ(pItem, pCaseSensitive)

		nPos = This.RandomPositionAfter( This.FindFirstCS(pItem, pCaseSensitive) )
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterCSZ(pItem, pCaseSensitive)

		def ARandomItemAfterItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		#--

		def AnItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		def AnyItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		def AnyRandomItemAfterCSZ(pItem, pCaseSensitive)
			return This.RandomItemAfterItemCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemAfterZ(pItem)
		return This.RandomItemAfterCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemAfterZ(pItem)
			return This.RandomItemAfterZ(pItem)

		def ARandomItemAfterItemZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		#--

		def AnItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		def AnyItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		def AnyRandomItemAfterZ(pItem)
			return This.RandomItemAfterItemZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED POSITION  #
	#===================================================================#

	def RandomItemBeforePosition(n)

		result = This.ItemAt( This.RandomPositionLessThan(n) )
		return result

		#< @FunctionAlternativeForms

		def ARandomItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		#--

		def AnItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		def AnyItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		def AnyRandomItemBeforePosition(n)
			return This.RandomItemBeforePosition(n)

		#>

	  #----------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED  #
	 #  POSITION ALONG WITH ITS POSITION                       #
	#---------------------------------------------------------#

	def RandomItemBeforePositionZ(n)
		nPos = This.RandomPositionLessThan(n)
		aResult = [ This.ItemAt(nPos), nPos ]
		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		#--

		def AnItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		def AnyItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		def AnyRandomItemBeforePositionZ(n)
			return This.RandomItemBeforePositionZ(n)

		#>

	  #---------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED ITEM  #
	#===============================================================#

	def RandomItemBeforeCS(pItem, pCaseSensitive)

		nPos = This.RandomPositionBefore( This.FindFirstCS(pItem, pCaseSensitive) )
		result = This.ItemAt(nPos)
		return result

		#< @FunctionAlternativeForms

		def ARandomItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def ARandomItemBeforeItemCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeItemCS(pItem, pCaseSensitive)

		#--

		def AnItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def AnyItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		def AnyRandomItemBeforeCS(pItem, pCaseSensitive)
			return This.RandomItemBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemBefore(pItem)
		return This.RandomItemBeforeCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def ARandomItemBeforeItem(pItem)
			return This.RandomItemBeforeItem(pItem)

		#--

		def AnItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def AnyItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		def AnyRandomItemBefore(pItem)
			return This.RandomItemBefore(pItem)

		#>

	   #--------------------------------------------------------------#
	  #   GETTING A RANDOM ITEM IN THE LIST BEFORE THE PROVIDED ONE  #
	 #  ALONG WITH ITS POSITION                                     #
	#--------------------------------------------------------------#

	def RandomItemBeforeCSZ(pItem, pCaseSensitive)

		nPos = This.RandomPositionBefore( This.FindFirstCS(pItem, pCaseSensitive) )
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def ARandomItemBeforeItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeItemCSZ(pItem, pCaseSensitive)

		#--

		def AnItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def AnyItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		def AnyRandomItemBeforeCSZ(pItem, pCaseSensitive)
			return This.RandomItemBeforeCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomItemBeforeZ(pItem)
		return This.RandomItemBeforeCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def ARandomItemBeforeItemZ(pItem)
			return This.RandomItemBeforeItemZ(pItem)

		#--

		def AnItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def AnyItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		def AnyRandomItemBeforeZ(pItem)
			return This.RandomItemBeforeZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE PROVIDED ONE  #
	#===================================================================#

	def RandomItemExceptCS(pItem, pCaseSensitive)
		anPos = This.AntiFindCS(pItem, pCaseSensitive)
		n = ARandomNumberIn(anPos)
		result = This.ItemAt(n)

		return result

		#< @FunctionAlternativeForms

		def ARandomItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def RandomItemExceptItemCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def ARandomItemExceptItemCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		#--

		def AnItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def AnyItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		def AnyRandomItemExceptCS(pItem, pCaseSensitive)
			return This.RandomItemExceptCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomItemExcept(pItem)
		return This.RandomItemExceptCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def RandomItemExceptItem(pItem)
			return This.RandomItemExcept(pItem)

		def ARandomItemExceptItem(pItem)
			return This.RandomItemExcept(pItem)

		#--

		def AnItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def AnyItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		def AnyRandomItemExcept(pItem)
			return This.RandomItemExcept(pItem)

		#>

	   #--------------------------------------------------------------#
	  #  GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE PROVIDED  #
	 #  ALONG WITH ITS POSITION                                     #
	#--------------------------------------------------------------#

	def RandomItemExceptCSZ(pItem, pCaseSensitive)
		anPos = This.AntiFindCS(pItem, pCaseSensitive)
		n = ARandomNumberIn(anPos)
		aResult = [ This.ItemAt(n), n ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def RandomItemExceptItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def ARandomItemExceptItemCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		#--

		def AnItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def AnyItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		def AnyRandomItemExceptCSZ(pItem, pCaseSensitive)
			return This.RandomItemExceptCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIIVTY

	def RandomItemExceptZ(pItem)
		return This.RandomItemExceptCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def ARandomItemExceptZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def RandomItemExceptItemZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def ARandomItemExceptItemZ(pItem)
			return This.RandomItemExceptZ(pItem)

		#--

		def AnItemExceptZ(pItem)
			return This.RandomItemExceptZ(pItem)

		def AnyItemExceptZ(pItem)
			return This.RandomItemExcept(pItem)

		def AnyRandomItemExceptZ(pItem)
			return This.RandomItemExcept(pItem)

		#>

	  #-------------------------------------------------------------------------------#
	 #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE AT THE POSITION PROVIDED  #
	#===============================================================================#

	def RandomItemExceptPosition(n)
		result = This.ItemAt( This.RandomPositionExcept(n) )
		return result

		#< @FunctionAlternativeForms

		def ARandomItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def RandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		#--

		def RandomItemExceptAt(n)
			return This.RandomItemExceptPosition(n)

		def ARandomItemExceptAt(n)
			return This.RandomItemExceptPosition(n)

		#==

		def AnItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemExceptItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		#--

		def AnItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemOtherThanItemAtPosition(n)
			return This.RandomItemExceptPosition(n)

		def AnyRandomItemOtherThanItemAt(n)
			return This.RandomItemExceptPosition(n)

		#>

	   #----------------------------------------------------------------------#
	  #   GETTING A RANDOM ITEM IN THE LIST EXECEPT THE ONE AT THE POSITION  #
	 #  PROVIDED ALONG WITH ITS POSITION                                    #
	#----------------------------------------------------------------------#

	def RandomItemExceptPositionZ(n)
		nPos = This.RandomPositionExcept(n)
		aResult = [ This.ItemAt(nPos), nPos ]

		return aResult

		#< @FunctionAlternativeForms

		def ARandomItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def RandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def RandomItemExceptAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def ARandomItemExceptAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#==

		def AnItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemExceptItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		#--

		def AnItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemOtherThanItemAtPositionZ(n)
			return This.RandomItemExceptPositionZ(n)

		def AnyRandomItemOtherThanItemAtZ(n)
			return This.RandomItemExceptPositionZ(n)

		#>

	  #--------------------------------------------#
	 #  GETIING N RANDOM POSITIONS FROM THE LIST  #
	#--------------------------------------------#

	def NRandomPositions(n)
		anResult = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		return anResult

		#< @FunctionAlternativeForms

		def NPositions(n)
			return This.NRandomPositions(n)

		def AnyNPositions(n)
			return This.NRandomPositions(n)

		def AnyRandomNPositions(n)
			return This.NRandomPositions(n)

		def AnyNRandomPositions(n)
			return This.NRandomPositions(n)

		#>

	  #----------------------------------------#
	 #  GETIING N RANDOM ITEMS FROM THE LIST  #
	#----------------------------------------#

	def NRandomItems(n)
		anPos = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		aResult = This.ItemsAtPositions(anPos)

		return aResult
	
		#< @functionAlternativeForm

		def NItems(n)
			return This.NRandomItems(n)

		def RandomNItems(n)
			return This.NRandomItems(n)

		def NRandomItemsC(n)
			return This.NRandomItems(n)

		def AnyNItems(n)
			return This.NRandomItems(n)

		def AnyNRandomItems(n)
			return This.NRandomItems(n)

		def AnyRandomNItems(n)
			return This.NRandomItems(n)

		#>

	  #-------------------------------------------------------------------#
	 #  GETIING N RANDOM ITEMS FROM THE LIST ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------#

	def NRandomItemsZ(n)
		anPos = NRandomNumbersIn(n, 1 : This.NumberOfItems() )
		aItems = This.ItemsAtPositions(anPos)
		aResult = Association([ aItems, anPos ])
		return aResult
		
		#< @functionAlternativeForms

		def NItemsZ(n)
			return This.NRandomItemsZ(n)

		def RandomNItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyNItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyNRandomItemsZ(n)
			return This.NRandomItemsZ(n)

		def AnyRandomNItemsZ(n)
			return This.NRandomItemsZ(n)

		#--

		def NRandomItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def NItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def RandomNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyNRandomItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)

		def AnyRandomNItemsAndTheirPositions(n)
			return This.NRandomItemsZ(n)


		#>

	  #-----------------------------------------------#
	 #  GETIING SOME RANDOM POSITIONS FROM THE LIST  #
	#-----------------------------------------------#

	def SomeRandomPositions()
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		anResult = This.NRandomPositions(n)
		return anResult

		#< @functionAlternativeForms

		def RandomPositions()
			return This.SomeRandomPositions()

		def SomePositions()
			return This.SomeRandomPositions()

		def AnyPositions()
			return This.SomeRandomPositions()

		def AnyRandomPositions()
			return This.SomeRandomPositions()

		#>

	  #-------------------------------------------#
	 #  GETIING SOME RANDOM ITEMS FROM THE LIST  #
	#-------------------------------------------#

	def SomeRandomItems()
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		aResult = This.NRandomItems(n)
	
		return aResult

		#< @FunctionAlternativeForm

		def SomeItems()
			return This.SomeRandomItems()

		def RandomItems()
			return This.SomeRandomItems()

		def AnyItems()
			return This.SomeRandomItems()

		def AnyRandomItems()
			return This.SomeRandomItems()

		#>

	  #----------------------------------------------------------------------#
	 #  GETIING SOME RANDOM ITEMS FROM THE LIST ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------#

	def SomeRandomItemsZ(pCaseSensitive)
		n = ARandomNumberIn( 1 : This.NumberOfItems() )
		anPos = This.NRandomPositions(n)
		aItems = This.ItemsAtPositions(anPos)
	
		aResult = Association([ aItems, anPos ])
		return aResult


		#< @FunctionAlternativeForm

		def SomeItemsZ()
			return This.SomeRandomItemsZ()

		def RandomItemsZ()
			return This.SomeRandomItemsZ()

		def AnyItemsZ()
			return This.SomeRandomItemsZ()

		def AnyRandomItemsZ()
			return This.SomeRandomItemsZ()

		#--

		def SomeRandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def SomeItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def RandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def AnyItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		def AnyRandomItemsAndTheirPositions()
			return This.SomeRandomItemsZ()

		#>

	  #---------------------------------------------------------#
	 #  GETTING AN ITEM FROM THE LIST OTHER THEN A GIVEN ITEM  #
	#---------------------------------------------------------#

	def AnItemOtherThanCS(pItem, pCaseSensitive)
		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anPos = Q(anPos) - These(anPos)
		n = ARandomNumberIn(anPos)
		result = This.ItemAt(n)
	
		return result

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)
	
		def AnItemDifferentOfCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)

		def AnItemDifferentToCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)

		def AnItemDifferentFromCS(pItem, pCaseSensitive)
			return This.AnItemOtherThanCS(pItem, pCaseSensitive)
	
		#--
	
		def ItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
		
		def ItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def ItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		#--
	
		def AnyItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		def AnyItemDifferentThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pcChar, pCaseSensitive)
	
		def AnyItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def AnyItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		#--

		def AnyRandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)
	
		def AnyRandomItemDifferentThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pcChar, pCaseSensitive)
	
		def AnyRandomItemDifferentToCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomItemDifferentFromCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		#--

		def RandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		def ARandomItemOtherThanCS(pItem, pCaseSensitive)
			return This.ANumberOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnItemOtherThan(pItem)
		return This.AnItemOtherThanCS(pItem, TRUE)

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnItemDifferentOf(pItem)
			return This.ANumberOtherThan(pItem)

		def AnItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)
	
		#--
	
		def ItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def ItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def ItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def ItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)
	
		#--
	
		def AnyItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnyItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)

		#--
	
		def AnyRandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyRandomItemDifferentThan(pItem)
			return This.ANumberOtherThan(pItem)
	
		def AnyRandomItemDifferentTo(pItem)
			return This.ANumberOtherThan(pItem)

		def AnyRandomItemDifferentFrom(pItem)
			return This.ANumberOtherThan(pItem)

		#--

		def RandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem)

		def ARandomItemOtherThan(pItem)
			return This.ANumberOtherThan(pItem, pCaseSensitive)

		#>

	  #---------------------------------------------------------------------------------#
	 #  GETTING AN ITEM FROM THE LIST OTHER THEN A GIVEN ITEM ALONG WITH ITS POSITION  #
	#---------------------------------------------------------------------------------#

	def AnItemOtherThanCSZ(pItem, pCaseSensitive)
		anPos = This.FindAllCS(pItem, pCaseSensitive)
		anPos = Q(anPos) - These(anPos)
		nPos = ARandomNumberIn(anPos)
		item = This.ItemAt(nPos)
	
		aResult = [ item, nPos ]
		return aResult
	

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnItemDifferentOfCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)

		def AnItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)

		def AnItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.AnItemOtherThanCSZ(pItem, pCaseSensitive)
	
		#--
	
		def ItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
		
		def ItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def ItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		#--
	
		def AnyItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnyItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pcChar, pCaseSensitive)
	
		def AnyItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def AnyItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#--
	
		def AnyRandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)
	
		def AnyRandomItemDifferentThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pcChar, pCaseSensitive)
	
		def AnyRandomItemDifferentToCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomItemDifferentFromCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def RandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		def ARandomItemOtherThanCSZ(pItem, pCaseSensitive)
			return This.ANumberOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnItemOtherThanZ(pItem)
		return This.AnItemOtherThanCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms
	
		def AnItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnItemDifferentOfZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		#--
	
		def ItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def ItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def ItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def ItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		#--
	
		def AnyItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnyItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#--
	
		def AnyRandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyRandomItemDifferentThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)
	
		def AnyRandomItemDifferentToZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def AnyRandomItemDifferentFromZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#--

		def RandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		def ARandomItemOtherThanZ(pItem)
			return This.ANumberOtherThanZ(pItem)

		#>

	  #-------------------------------------------------------#
	 #  GETTING A RANDOM ITEM OTHER THAN THE ITEMS PROVIDED  #
	#-------------------------------------------------------#

	def AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)
		anPos = This.FindManyCS(paItems, pCaseSensitive)
		aResult = This.AnyItemsInPositionsOtherThan(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def ARandomItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnItemOtherThanManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnyRandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def RandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def ARandomItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		def AnItemExceptManyCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCS(paItems, pCaseSensitive)

		#==

		def RandomItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def ARandomItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnItemOtherThanTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnyRandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def RandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def ARandomItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		def AnItemExceptTheseCS(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnyRandomItemOtherThanMany(paItems)
		return This.AnyRandomItemOtherThanManyCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def RandomItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def ARandomItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnItemOtherThanMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		#--

		def AnyRItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnyRandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def RandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def ARandomItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		def AnItemExceptMany(paItems)
			return This.AnyRandomItemOtherThanMany(paItems)

		#==

		def RandomItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def ARandomItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnItemOtherThanThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		#--

		def AnyRItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnyRandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def RandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def ARandomItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		def AnItemExceptThese(paItems)
			return This.AnyRandomItemOtherThanThese(paItems)

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING A RANDOM ITEM OTHER THAN THE ITEMS PROVIDED ALONG WITH THEIR POSITIONS  #
	#----------------------------------------------------------------------------------#

	def AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		anPos = This.FindManyCS(paItems, pCaseSensitive)
		aResult = [ This.AnyItemsInPositionsOtherThan(anPos), anPos ]

		return aResult

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def ARandomItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnItemOtherThanManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnyRandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def RandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def ARandomItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		def AnItemExceptManyCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanManyCSZ(paItems, pCaseSensitive)

		#==

		def RandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def ARandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnItemOtherThanTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		#--

		def AnyRItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnyRandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def RandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def ARandomItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		def AnItemExceptTheseCSZ(paItems, pCaseSensitive)
			return This.AnyRandomItemOtherThanTheseCSZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def AnyRandomItemOtherThanManyZ(paItems)
		return This.AnyRandomItemOtherThanManyCSZ(paItems, TRUE)

		#< @FunctionAlternativeForms

		def RandomItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def ARandomItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnItemOtherThanManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		#--

		def AnyRItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnyRandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def RandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def ARandomItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		def AnItemExceptManyZ(paItems)
			return This.AnyRandomItemOtherThanManyZ(paItems)

		#==

		def RandomItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def ARandomItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnItemOtherThanTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		#--

		def AnyRItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnyRandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def RandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def ARandomItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		def AnItemExceptTheseZ(paItems)
			return This.AnyRandomItemOtherThanTheseZ(paItems)

		#>

	  #--------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM  #
	#--------------------------------------------------#

	def NRandomItemsOtherThanCS(pItem, pCaseSensitive)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		anRandomPos = NRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositions(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def NItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def NRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def NItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#==

		def AnyNRandomItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomNItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyNItemsOtherThanCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def AnyNRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyRandomNItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyNItemsExceptCS(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanS(pItem)
		return This.NRandomItemsOtherThanCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def NItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#--

		def NRandomItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def NItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#==

		def AnyNRandomItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyRandomNItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyNItemsOtherThan(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#--

		def AnyNRandomItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyRandomNItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		def AnyNItemsExcept(pItem)
			return This.NRandomItemsOtherThan(pItem)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- Z/EXTENDED  #
	#----------------------------------------------------------------#

	def NRandomItemsOtherThanCSZ(pItem)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		anRandomPos = NRandomNumbersIn(anPos)
		aItems = This.ItemsAtPositions(anRandomPos)

		aResult = Association([ aItems, anRandomPos ])

		return aResult

		#< @FunctionAlternativeForms

		def NItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def NRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def NItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#==

		def AnyNRandomItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomNItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyNItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def AnyNRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyRandomNItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyNItemsExceptCSZ(pItem, pCaseSensitive)
			return This.NRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanZ(pItem)
		return This.NRandomItemsOtherThanCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def NItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#--

		def NRandomItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def NItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#==

		def AnyNRandomItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyRandomNItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyNItemsOtherThanZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#--

		def AnyNRandomItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyRandomNItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		def AnyNItemsExceptZ(pItem)
			return This.NRandomItemsOtherThanZ(pItem)

		#>

	  #----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- U/EXTENDED  #
	#----------------------------------------------------------------#

	#TODO

	  #-----------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN A GIVEN ITEM -- UZ/EXTENDED  #
	#-----------------------------------------------------------------#

	#TODO

	  #-----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM  #
	#-----------------------------------------------------#

	def SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		anRandomPos = SomeRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositions(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def SomeRandomItemsExceptCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def SomeItemsExceptCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#--

		def AnyRandomItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		def AnyItemsOtherThanCS(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SomeRandomItemsOtherThanpItem(pItem)
		return This.SomeRandomItemsOtherThanCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def SomeItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def SomeRandomItemsExcept(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def SomeItemsExcept(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		#--

		def AnyRandomItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		def AnyItemsOtherThan(pItem)
			return This.SomeRandomItemsOtherThan(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- Z/EXTENDED  #
	#-------------------------------------------------------------------#

	def SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)
		anPos = Q(1 : This.NumberOfItems()) - These( This.FindCS(pItem, pCaseSensitive) )
		anRandomPos = SomeRandomNumbersIn(anPos)
		aResult = This.ItemsAtPositionsQ(anRandomPos).AssociatedWith(anRandomPos)

		return aResult

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def SomeRandomItemsExceptCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def SomeItemsExceptCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#--

		def AnyRandomItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		def AnyItemsOtherThanCSZ(pItem, pCaseSensitive)
			return This.SomeRandomItemsOtherThanCSZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SomeRandomItemsOtherThanZ(pItem)
		return This.SomeRandomItemsOtherThanCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def SomeItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def SomeRandomItemsExceptZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def SomeItemsExceptZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		#--

		def AnyRandomItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		def AnyItemsOtherThanZ(pItem)
			return This.SomeRandomItemsOtherThanZ(pItem)

		#>

	  #-------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- U/EXTENDED  #
	#-------------------------------------------------------------------#

	#TODO

	  #--------------------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A GIVEN ITEM -- UZ/EXTENDED  #
	#--------------------------------------------------------------------#

	#TODO

	  #------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN MANY GIVEN ITEMS  #
	#------------------------------------------------------#

	def NRandomItemsOtherThanManyCS(paItems, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanMany(paItems)
		return This.NRandomItemsOtherThanManyCS(paItems, TRUE)

	  #---------------------------------------------------------------------#
	 #  GETTING N RANDOM ITEMS OTHER THAN MANY GIVEN ITEMS  -- Z/EXTENDED  #
	#---------------------------------------------------------------------#

	def NRandomItemsOtherThanManyCSZ(paItems, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- WITHOUT CASESENSITIVITY

	def NRandomItemsOtherThanManyZ(paItems)
		return This.NRandomItemsOtherThanManyCSZ(paItems, TRUE)

	#-- U/EXTENDED FORM

	#TODO

	#-- UZ/EXTENDED FORM

	#TODO

	  #-----------------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS OTHER THAN A MANY GIVEN ITEMS  #
	#-----------------------------------------------------------#

	def SomeRandomItemsOtherThanManyCS(paItems)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- Z/EXTENDED FORM

	def SomeRandomItemsOtherThanManyCSZ(paItems)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- U/EXTENDED FORM

	#TODO

	#-- UZ/EXTENDED FORM

	#TODO

	  #--------------------------------------------------------#
	 #  GETTING AN ITEM BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#========================================================#

	def AnItemBetweenCS(pMin, pMax, pCaseSensitive) # InSection
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- Z/EXTENDED FORM

	def AnItemBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- IB/EXTENDED FORM

	def AnItemBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#-- IBZ/EXTENDED FORM

	def AnItemBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------------------#
	 #  GETTING AN ITEM NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#------------------------------------------------------------#

	def AnItemNotBetweenCS(pMin, pMax, pCaseSensitive) # OutsideInSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING AN ITEM INSIDE THE GIVEN SECTIONS  #
	#=============================================#

	def AnItemBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING AN ITEM OUTSIDE THE GIVEN SECTIONS  #
	#----------------------------------------------#

	def AnItemNotBetweenManyCS(pMin, pMax, pCaseSensitive) # OutsideSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def AnItemNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #--------------------------------------------------------#
	 #  GETTING N ITEMS BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#========================================================#

	def NItemsBetweenCS(pMin, pMax, pCaseSensitive) # InSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-----------------------------------------------------------#
	 #  GETTING SOME ITEMS BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#-----------------------------------------------------------#

	def SomeItemsBetweenCS(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------------------#
	 #  GETTING N ITEMS NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#------------------------------------------------------------#

	def NItemsNotBetweenCS(pMin, pMax, pCaseSensitive) # OutsideSection
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------------------------#
	 #  GETTING SOME ITEMS NOT BETWEEN TWO OTHER ITEMS OR POSITIONS  #
	#---------------------------------------------------------------#

	def SomeItemsNotBetweenCS(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsNotBetweenCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING N ITEMS INSIDE THE GIVEN SECTIONS  #
	#=============================================#

	def NItemsBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #------------------------------------------------#
	 #  GETTING SOME ITEMS INSIDE THE GIVEN SECTIONS  #
	#------------------------------------------------#

	def SomeItemsBetweenManyCS(pMin, pMax, pCaseSensitive) # InSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsBetweenManyCSIB(pMin, pMax, pCaseSensitivity)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsBetweenManyCSIBZ(pMin, pMax, pCaseSensitivity)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING N ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#----------------------------------------------#

	def NItemsNotBetweenManyCS(pMin, pMax, pCaseSensitive) # NotInSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def NItemsNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------------#
	 #  GETTING SOME ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#-------------------------------------------------#

	def SomeItemsNotBetweenManyCS(pMin, pMax, pCaseSensitive) # NotInSections
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenManyCSZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	#---------------

	def SomeItemsNotBetweenManyCSIB(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsNotBetweenManyCSIBZ(pMin, pMax, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------#
	 #  GETTING AN ITEM NOT IN A GIVEN POSITION  #
	#===========================================#

	def AnItemOutsidePosition(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemOutsidePositionZ(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING AN ITEM NOT BETWEEN TWO POSITIONS  #
	#---------------------------------------------#

	def AnItemOutsidePositions(panPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def AnItemOutsidePositionsZ(panPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #---------------------------------------------#
	 #  GETTING N ITEMS NOT IN THE GIVEN POSITION  #
	#=============================================#

	def NItemsOutsidePosition(nPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsOutsidePositionZ(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

  	  #------------------------------------------------#
	 #  GETTING SOME ITEMS NOT IN THE GIVEN POSITION  #
	#------------------------------------------------#

	def SomeItemsOutsidePosition(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	def SomeItemsOutsidePositionZ(anPos)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #----------------------------------------------#
	 #  GETTING N ITEMS NOT IN THE GIVEN POSITIONS  #
	#----------------------------------------------#

	def NItemsOutsidePositions(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	def NItemsOutsidePositionsZ(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

	  #-------------------------------------------------#
	 #  GETTING SOME ITEMS NOT IN THE GIVEN POSITIONS  #
	#-------------------------------------------------#

	def SomeItemsOutsidePositions(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

		def SomeItemsInPositionsOtherThan(panPos, pCaseSensitive)
			return This.SomeItemsOutsidePositions(panPos, pCaseSensitive)

	def SomeItemsOutsidePositionsZ(panPos, pCaseSensitive)
		#TODO
		StzRaise("Unsupported feature yet!")

		def SomeItemsInPositionsOtherThanZ(panPos, pCaseSensitive)
			return This.SomeItemsOutsidePositionsZ(panPos, pCaseSensitive)


	  #-------------------------------------------------#
	 #  GETTING A RANDOM ITEM BEFORE A GIVEN POSITION  #
	#-------------------------------------------------#

	def AnyItemBeforeOrAfter(n) #TODO

	def AnyItemBeforeOrAfterZ(n) #TODO

	  #-----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS BEFORE A GIVEN POSITION  #
	#-----------------------------------------------------#

	def AnyItemsBeforePosition(n) #TODO

 	def AnyItemsBeforePositionZ(n) #TODO

	  #----------------------------------------------------#
	 #  GETTING SOME RANDOM ITEMS AFTER A GIVEN POSITION  #
	#----------------------------------------------------#

	def AnyItemsAfterPosition(n) #TODO

	def AnyItemsAfterPositionZ(n) #TODO

	  #---------------------------------------------------#
	 #  GETTING SOME RANDOM BETWEEN TWO GIVEN POSITIONS  #
	#---------------------------------------------------#

	def AnyItemBetweenPositions(n1, n2) #TODO

	def AnyItemBetweenPositionsZ(n1, n2) #TODO

	  #------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE LIST  #
	#================================================#

	def Randomize()
		nLen = This.NumberOfItems()
		anPos = NUniqueRandomNumbersIn(nLen, 1:nLen)
		This.UpdateWith( This.ItemsAtPositions(anPos) )

		#< @FunctionFluentForm

		def RandomizeQ()
			This.Randomize()
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositions()
			This.Randomise()

			def RandomizePositonsQ()
				This.RandomizePositions()
				return This

		#--

		def Randomise()
			This.Randomize()

			def RandomiseQ()
				This.Randomise()
				return This

		def RandomisePositions()
			This.Randomize()

			def RandomisePositionsQ()
				This.RandomisePositions()
				return This

	#--

		def Shuffle()
			This.Randomize()

			def ShuffleQ()
				This.Shuffle()
				return This

		def ShufflePositions()
			This.Randomize()

			def ShufflePositionsQ()
				This.ShufflePositions()
				return This

		#>

	def Randomized()
		aResult = This.Copy().RandomizeQ().Content()
		return aResult

		def Randomised()
			return This.Randomized()

		def Shuffeled()
			return This.Randomized()
		
	  #---------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE GIVEN SECTION OF THE LIST  #
	#---------------------------------------------------------------------#

	def RandomizeSection(n1, n2)
		if CheckParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param types! n1 and n2 must be both numbers.")
			ok
		ok

		nLen = n2 - n1 + 1
		anPos = NRandomNumbersBetweenU(nLen, n1, n2)
		aItems = This.ItemsAtPositions(anPos)

		j = 0
		for i = n1 to n2
			j++
			@aContent[i] = aItems[j]
		next

		#< @FunctionFluentForm

		def RandomizeSectionQ(n1, n2)
			This.RandomizeSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositionsInSection(n1, n2)
			This.RandomiseSection(n1, n2)

			def RandomizePositionsInSectionQ(n1, n2)
				This.RandomizePositionsInSection(n1, n2)
				return This

		#--

		def RandomiseSection(n1, n2)
			This.RandomizeSection(n1, n2)

			def RandomiseSectionQ(n1, n2)
				This.RandomiseSection(n1, n2)
				return This

		def RandomisePositionsInSection(n1, n2)
			This.RandomizeSection(n1, n2)

			def RandomisePositionsInSectionQ(n1, n2)
				This.RandomisePositionsInSection(n1, n2)
				return This

		#>

	def SectionRandomized(n1, n2)
		aResult = This.Copy().RandomizeSectionQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def PositionsInSectionRandomized(n1, n2)
			return This.SectionRandomized(n1, n2)

		#--

		def SectionRandomised(n1, n2)
			return This.SectionRandomized(n1, n2)

		def PositionsInSectionRandomised(n1, n2)
			return This.SectionRandomized(n1, n2)

		#>

	  #----------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS IN THE GIVEN SECTIONS OF THE LIST  #
	#----------------------------------------------------------------------#

	def RandomizeSections(panSections)
		if CheckParams() = TRUE # Generalise this all over the library
			if NOT ( isList(panSections) and @IsListOfPairsOfNumbers(panSections) )
				StzRaise("Incorrect param type! panSections must be a list of pairs of numbers.")
			ok
		ok

		nLen = len(panSections)

		for i = 1 to nLen
			This.RandomizeSection(panSections[i][1], panSections[i][2])
		next

		#< @FunctionFluentForm

		def RandomizeSectionsQ(panSections)
			This.RandomizeSections(panSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizePositionsInSections(panSections)
			This.RandomiseSections(panSections)

			def RandomizePositionsInSectionsQ(panSections)
				This.RandomizePositionsInSections(panSections)
				return This

		#--

		def RandomiseSections(panSections)
			This.RandomizeSections(panSections)

			def RandomiseSectionsQ(panSections)
				This.RandomiseSections(panSections)
				return This

		def RandomisePositionsInSections(panSections)
			This.RandomizeSections(panSections)

			def RandomisePositionsInSectionsQ(panSections)
				This.RandomisePositionsInSections(panSections)
				return This

		#>

	def SectionsRandomized(panSections)
		aResult = This.Copy().RandomizeSectionsQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def PositionsInSectionsRandomized(n1, n2)
			return This.SectionsRandomized(n1, n2)

		#--

		def SectionsRandomised(n1, n2)
			return This.SectionsRandomized(n1, n2)

		def PositionsInSectionsRandomised(n1, n2)
			return This.SectionsRandomized(n1, n2)

		#>

	  #-------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS BETWEEN TWO POSITIONS OR ITEMS  #
	#-------------------------------------------------------------------#

	def RandomizeBetweenCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsPositionOrPositionsNamedParam()
			p1 = p1[2]

			This.RandomizeBetweenPositions(p1, p2) # Or RandomizSection
		ok

		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)


		#< @FunctionFluentForm

		def RandomizeBetweenCSQ(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomiseBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomiseBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#--

		def RandomizePositionsBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomizePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomizePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		def RandomisePositionsBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenCS(p1, p2, pCaseSensitive)

			def RandomisePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomisePositionsBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#>

	def RandomizedBetweenCS(p1, p2, pCaseSensitive)
		aResult = This.RandomizeBetweenCSQ(p1, p2, pCaseSensitive).Content()
		return This

		def RanomisedBetweenCS(p1, p2, pCaseSensitive)
			return This.RandomizedBetweenCS(p1, p2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RandomizeBetween(p1, p2)
		This.RandomizeBetweenCS(p1, p2, TRUE)

		#< @FunctionFluentForm

		def RandomizeBetweenQ(p1, p2)
			This.RandomizeBetween(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomiseBetweenQ(p1, p2)
				This.RandomiseBetweenQ(p1, p2)
				return This

		#--

		def RandomizePositionsBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomizePositionsBetweenQ(p1, p2)
				This.RandomizePositionsBetweenQ(p1, p2)
				return This

		def RandomisePositionsBetween(p1, p2)
			This.RandomizeBetween(p1, p2)

			def RandomisePositionsBetweenQ(p1, p2)
				This.RandomisePositionsBetweenQ(p1, p2)
				return This

		#>

	def RandomizedBetween(p1, p2)
		aResult = This.RandomizeBetweenQ(p1, p2).Content()
		return This

		def RanomisedBetween(p1, p2)
			return This.RandomizedBetween(p1, p2)

	  #-------------------------------------------------------------#
	 #  RANDOMIZING ITEMS POSITIONS BETWEEN TWO ITEMS IN THE LIST  #
	#-------------------------------------------------------------#

	def RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)
		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)
	
		#< @FunctionFluentForm

		def RandomizeBetweenItemsCSQ(p1, p2, pCaseSensitive)
			This.RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseBetweenItemsCS(p1, p2, pCaseSensitive)
			This.RandomizeBetweenItemsCS(p1, p2, pCaseSensitive)

			def RandomiseBetweenItemsCSQ(p1, p2, pCaseSensitive)
				This.RandomiseBetweenItemsCS(p1, p2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomizeBetweenItems(p1, p2)
		This.RandomizeBetweenItemsCS(p1, p2, TRUE)

		#< @FunctionFluentForm

		def RandomizeBetweenItemsQ(p1, p2)
			This.RandomizeBetweenItems(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseBetweenItems(p1, p2)
			This.RandomizeBetweenItems(p1, p2)

			def RandomiseBetweenItemsQ(p1, p2)
				This.RandomiseBetweenItems(p1, p2)
				return This

		#>

	  #-----------------------------------------------------------------------#
	 #  RANDOMINZING THE ITEMS POSITIONS NOT BETWEEN TWO POSITIONS OR ITEMS  #
	#-----------------------------------------------------------------------#

	def RandomizeNotBetweenCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsPositionOrPositionsNamedParam()
			p1 = p1[2]

			This.RandomizeNotBetweenPositions(p1, p2) # Or RandomizSection
		ok

		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeSection(n1, n2)


		#< @FunctionFluentForm

		def RandomizeNotBetweenCSQ(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomiseNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomiseNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#--

		def RandomizePositionsNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomizePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomizePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		def RandomisePositionsNotBetweenCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenCS(p1, p2, pCaseSensitive)

			def RandomisePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				This.RandomisePositionsNotBetweenCSQ(p1, p2, pCaseSensitive)
				return This

		#>

	def RandomizedNotBetweenCS(p1, p2, pCaseSensitive)
		aResult = This.RandomizeNotBetweenCSQ(p1, p2, pCaseSensitive).Content()
		return This

		def RanomisedNotBetweenCS(p1, p2, pCaseSensitive)
			return This.RandomizedNotBetweenCS(p1, p2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RandomizeNotBetween(p1, p2)
		This.RandomizeNotBetweenCS(p1, p2, TRUE)

		#< @FunctionFluentForm

		def RandomizeNotBetweenQ(p1, p2)
			This.RandomizeNotBetween(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomiseNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomiseNotBetweenQ(p1, p2)
				This.RandomiseNotBetweenQ(p1, p2)
				return This

		#--

		def RandomizePositionsNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomizePositionsNotBetweenQ(p1, p2)
				This.RandomizePositionsNotBetweenQ(p1, p2)
				return This

		def RandomisePositionsNotBetween(p1, p2)
			This.RandomizeNotBetween(p1, p2)

			def RandomisePositionsNotBetweenQ(p1, p2)
				This.RandomisePositionsNotBetweenQ(p1, p2)
				return This

		#>

	def RandomizedNotBetween(p1, p2)
		aResult = This.RandomizeNotBetweenQ(p1, p2).Content()
		return This

		def RanomisedNotBetween(p1, p2)
			return This.RandomizedNotBetween(p1, p2)

	  #-----------------------------------------------------------------#
	 #  RANDOMIZING ITEMS POSITIONS NOT BETWEEN TWO ITEMS IN THE LIST  #
	#-----------------------------------------------------------------#

	def RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)
		n1 = This.FindFirstCS(p1, pCaseSensitive)
		n2 = This.FindLastCS(p2, pCaseSensitive)

		This.RandomizeAntiSection(n1, n2)
	
		#< @FunctionFluentForm

		def RandomizeNotBetweenItemsCSQ(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseNotBetweenItemsCS(p1, p2, pCaseSensitive)
			This.RandomizeNotBetweenItemsCS(p1, p2, pCaseSensitive)

			def RandomiseNotBetweenItemsCSQ(p1, p2, pCaseSensitive)
				This.RandomiseNotBetweenItemsCS(p1, p2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def RandomizeNotBetweenItems(p1, p2)
		This.RandomizeNotBetweenItemsCS(p1, p2, TRUE)

		#< @FunctionFluentForm

		def RandomizeNotBetweenItemsQ(p1, p2)
			This.RandomizeNotBetweenItems(p1, p2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RandomiseNotBetweenItems(p1, p2)
			This.RandomizeNotBetweenItems(p1, p2)

			def RandomiseNotBetweenItemsQ(p1, p2)
				This.RandomiseNotBetweenItems(p1, p2)
				return This

		#>

	  #------------------------------------------------------------#
	 #  RANDOMIZING POSITIONS OF ITEMS OUTSIDE THE GIVEN SECTION  #
	#------------------------------------------------------------#

	def RandomizeAntiSection(n1, n2)
		anSections = This.FindAntiSections([ [n1, n2] ]) # Or maybe AntiSectionsAsSections()
		This.RandomizeSections(anSections)

		#< @FunctionFluentForm

		def RandomizeAntiSectionQ(n1, n2)
			This.RandomizeAntiSection(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizeOutsideSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)
	
			def RandomizeOutsideSectionQ(n1, n2)
				This.RandomizeOutsideSection(n1, n2)
				return This

		#--

		def RandomiseAntiSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)

			def RandomiseAntiSectionQ(n1, n2)
				This.RandomiseAntiSection(n1, n2)
				return This

		def RandomiseOutsideSection(n1, n2)
			This.RandomizeAntiSection(n1, n2)
	
			def RandomiseOutsideSectionQ(n1, n2)
				This.RandomizeOutsideSection(n1, n2)
				return This

		#>

	def AntiSectionRandomized(n1, n2)
		aResult = This.Copy().RandomizeAntiSectionQ(n1, n2).Content()
		return aResult

		#< @FunctionAlternativeForms

		def OutsideSectionRandomized(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		#--

		def AntiSectionRandomised(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		def OutsideSectionRandomised(n1, n2)
			return This.AntiSectionRandomized(n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #  RANDOMIZING POSITIONS OF ITEMS OUTSIDE THE GIVEN SECTIONS  #
	#-------------------------------------------------------------#

	def RandomizeAntiSections(panSections)
		anSections = This.FindAntiSections(panSections) # Or maybe AntiSectionsAsSections()
		This.RandomizeSections(anSections)

		#< @FunctionFluentForm

		def RandomizeAntiSectionsQ(panSections)
			This.RandomizeAntiSections(panSections)
			return This

		#>

		#< @FunctionAlternativeForms

		def RandomizeOutsideSections(panSections)
			This.RandomizeAntiSections(panSections)
	
			def RandomizeOutsideSectionsQ(panSections)
				This.RandomizeOutsideSections(panSections)
				return This

		#--

		def RandomiseAntiSections(panSections)
			This.RandomizeAntiSections(panSections)

			def RandomiseAntiSectionsQ(panSections)
				This.RandomiseAntiSections(panSections)
				return This

		def RandomiseOutsideSections(panSections)
			This.RandomizeAntiSections(panSections)
	
			def RandomiseOutsideSectionsQ(panSections)
				This.RandomizeOutsideSections(panSections)
				return This

		#>

	def AntiSectionsRandomized(panSections)
		aResult = This.Copy().RandomizeAntiSectionsQ(panSections).Content()
		return aResult

		#< @FunctionAlternativeForms

		def OutsideSectionsRandomized(panSections)
			return This.AntiSectionsRandomized(panSections)

		#--

		def AntiSectionsRandomised(panSections)
			return This.AntiSectionsRandomized(panSections)

		def OutsideSectionsRandomised(panSections)
			return This.AntiSectionsRandomized(panSections)

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE NUMBERS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeNumbers()
		aSections = This.FindNumbersAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeNumbersQ()
			This.RandomizeNumbers()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseNumbers()
			This.RandomizeNumbers()

		def ShuffleNumbers()
			This.RandomizeNumbers()

		#>

	#-- @FunctionPassiveForm

	def NumbersRandomized()
		aResult = This.Copy().RandomizeNumbersQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def NumbersRansomised()
			return This.NumbersRandomized()

		def NumbersShuffled()
			return This.NumbersRandomized()

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE STRINGS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeStrings()
		aSections = This.FindStringsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeStringsQ()
			This.RandomizeStrings()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseStrings()
			This.RandomizeStrings()

		def ShuffleStrings()
			This.RandomizeStrings()

		#>

	#-- @FunctionPassiveForm

	def StringsRandomized()
		aResult = This.Copy().RandomizeStringsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def StringsRansomised()
			return This.StringsRandomized()

		def StringsShuffled()
			return This.StringsRandomized()

		#>

	  #-----------------------------------------------#
	 #  RANDOMINZING THE LISTS EXISTING IN THE LIST  #
	#===============================================#

	def RandomizeLists()
		aSections = This.FindListsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeListsQ()
			This.RandomizeLists()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseLists()
			This.RandomizeLists()

		def ShuffleLists()
			This.RandomizeLists()

		#>

	#-- @FunctionPassiveForm

	def ListsRandomized()
		aResult = This.Copy().RandomizeListsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ListsRansomised()
			return This.ListsRandomized()

		def ListsShuffled()
			return This.ListsRandomized()

		#>

	  #-------------------------------------------------#
	 #  RANDOMINZING THE OBJECTS EXISTING IN THE LIST  #
	#=================================================#

	def RandomizeObjects()
		aSections = This.FindObjectsAsSections()
		This.RandomizeSections(aSections)

		#< @FunctionFluentForm

		def RandomizeObjectsQ()
			This.RandomizeObjects()
			return This
		#>

		#< @FunctionAlternativeForms

		def RandomiseObjects()
			This.RandomizeObjects()

		def ShuffleObjects()
			This.RandomizeObjects()

		#>

	#-- @FunctionPassiveForm

	def ObjectsRandomized()
		aResult = This.Copy().RandomizeObjectsQ().Content()
		return aResult

		#< @FunctionAlternativeForms

		def ObjectsRansomised()
			return This.ObjectsRandomized()

		def ObjectsShuffled()
			return This.ObjectsRandomized()

		#>

	  #=========#
	 #  WHERE  #
	#=========#

	def Where(pcCondition)
		/* EXAMPLE

		o1 = new stzList([ :StartingAt, 5 ])
		? o1.IsAPairQ().Where('{ isString(@pair[1]) and isNumber(@pair[2]) }')
		#--> TRUE

		o1 = new stzList([ "ONE", "TWO", "THREE" ])
		? o1.IsAPairQ().Where('{ Q(@Pair).AllItemsAre([ :Uppercase, :Strings ]) }')
		#--> FALSE

		*/

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		cCondition = Q(pcCondition).
				TrimQ().
				RemoveTheseBoundsQ("{","}").
				ReplaceManyCSQ([ "@list", "@pair" ], "This", :CS = FALSE).
				Content()

		cCode = 'bOk = (' + cCondition + ')'

		eval(cCode)
		return bOk

	  #-----------------------------------------#
	 #  GETTING THE LIST OF CHARS IN THE LIST  #
	#-----------------------------------------#

	def Chars()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isString(item) and StzStringQ(item).IsChar()
				aResult + item
			ok
		next

		return aResult

	def NumberOfChars()
		return len(This.Chars())

	  #-------------------------------------------#
	 #  GETTING THE LIST OF LETTERS IN THE LIST  #
	#-------------------------------------------#

	def Letters()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isString(item) and Q(item).IsLetter()
				aResult + item
			ok
		next

		return aResult

	def NumberOfLetters()
		return len(This.Letters())

	  #=========================================#
	 #  GETTING THE LIST OF PAIRS IN THE LIST  #TODO: Add case sensitivity
	#=========================================#

	def ContainsPairs()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = FALSE

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsPair()
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def NumberOfPairs()
		return len(This.Pairs())

	def FindPairs()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsPair()
				anResult + i
			ok
		next

		return anResult

	def Pairs()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsPair()
				aResult + item
			ok
		next

		return aResult

	def PairsU()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = aContent[i]

			if NOT (isList(item) and Q(item).IsPair())
				loop
			ok

			cItem = @@(item)

			if ring_find(acSeen, cItem) = 0
				aResult + item
				acSeen + cItem
			ok
	
		next

		return aResult

	def PairsZ()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = acontent[i]

			if NOT (isList(item) and Q(item).IsPair())
				loop
			ok

			if ring_find(acSeen, @@(item)) = 0
				anPos = This.Find(aContent[i])
				aResult + [ item, anPos ]
				acSeen + @@(item)
			ok
	
		next

		return aResult

	  #--------------------------------------------------------#
	 #  PAIRIFYING THE LIST BY TRANFORMING EACH ITEM TO PAIR  #
	#--------------------------------------------------------#

	def Pairify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aPair = []

			if isList(aContent[i])

				nLenTemp = len(aContent[i])
				if nLenTemp = 0
					aPair + NULL + NULL

				but nLenTemp = 1
					aPair + aContent[i][1] + NULL

				but nLenTemp = 2
					aPair = aContent[i]

				else
					aPair + aContent[i][1] + aContent[i][2]
				ok
			
			else
				aPair + aContent[i] + NULL
			ok

			aResult + aPair
		next

		This.UpdateWith(aResult)

		def PairifyQ()
			This.Pairify()
			return This

	def Pairified()
		aResult = This.Copy().PairifyQ().Content()
		return aResult

	  #===========================================#
	 #  GETTING THE LIST OF SINGLES IN THE LIST  #TODO: Add case sensitivity
	#===========================================#

	def ContainsSingles()
		aContent = This.Content()
		nLen = len(aContent)

		bResult = FALSE

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def NumberOfSingles()
		return len(This.Singles())

		def HowManySingles()
			return This.NumberOfSingles()

		def HowManySingle()
			return This.NumberOfSingles()

	def FindSingles()
		aContent = This.Content()
		nLen = len(aContent)

		anResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				anResult + i
			ok
		next

		return anResult

	def Singles()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			item = aContent[i]
			if isList(item) and Q(item).IsSingle()
				aResult + item
			ok
		next

		return aResult

	def SinglesU()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = aContent[i]

			if NOT (isList(item) and Q(item).IsSingle())
				loop
			ok

			cItem = @@(item)

			if ring_find(acSeen, cItem) = 0
				aResult + item
				acSeen + cItem
			ok
	
		next

		return aResult

	def SinglesZ()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []
		acSeen = []

		for i = 1 to nLen

			item = acontent[i]

			if NOT (isList(item) and Q(item).IsSingle())
				loop
			ok

			if ring_find(acSeen, @@(item)) = 0
				anPos = This.Find(aContent[i])
				aResult + [ item, anPos ]
				acSeen + @@(item)
			ok
	
		next

		return aResult

	  #-----------------------------------------------------------#
	 #  SINGLIFYING THE LIST BY TRANFORMING EACH ITEM TO SINGLE  #
	#-----------------------------------------------------------#

	def Singlify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aSingle = []

			if isList(aContent[i])

				nLenTemp = len(aContent[i])
				if nLenTemp = 0
					aSingle + NULL

				else
					aSingle + aContent[i][1]
				ok
			
			else
				aSingle + aContent[i]
			ok

			aResult + aSingle
		next

		This.UpdateWith(aResult)

		def SinglifyQ()
			This.Singlify()
			return This

	def Singlified()
		aResult = This.Copy().SinglifyQ().Content()
		return aResult

	  #========================================================#
	 #  LISTIFYING THE LIST BY TRANFORMING EACH ITEM TO LIST  #
	#========================================================#

	def Listify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aList = []

			if isList(aContent[i])
				aList = aContent[i]

			else
				aList + aContent[i]
			ok

			aResult + aList
		next

		This.UpdateWith(aResult)
			 
		def ListifyQ()
			This.Listify()
			return This

	def Listified()
		aResult = This.Copy().ListifyQ().Content()
		return aResult

	  #-------------------------------------------------------------#
	 #  LISTIYING THE ITEMS OF THE LIST BY SIZING THEM TO N ITEMS  #
	#-------------------------------------------------------------#

	def NListify(n)
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			aList = []

			if NOT isList(aContent[i])
				aList + aContent[i]
				if n > 1
					for j = 1 to n-1
						aList + NULL
					next
				ok
			else

				nLenList = len(aContent[i])

				if n = nLenList
					aList = aContent[i]

				but n > nLenList
					aList = aContent[i]
					for j = 1 to n - nLenList
						aList + NULL
					next

				but n < nLenList
					for j = 1 to n
						aList + aContent[i][j]
					next
				ok
						
			ok

			aResult + aList
		next

		This.UpdateWith(aResult)

		#< @FunctionFluentForm

		def NListifyQ(n)
			This.NListify(n)
			return This

		#>

	def NListified(n)
		aResult = This.Copy().NListifyQ(n).Content()
		return aResult

	  #============================================================#
	 #  NUMBERIFYING THE LIST BY TRANFORMING EACH ITEM TO NUMBER  #
	#============================================================#

	def Numberify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen

			n = 0

			if isNumber(aContent[i])
				n = aContent[i]
				aResult + n

			but isString(aContent[i])
				cNumber = StzStringQ(acontent[i]).RemoveQ("_").Content()
				n = 0+ cNumber
				aResult + n
				
			but isList(aContent[i])
				anNumberified = StzListQ(aContent[i]).Numberified()
				nLenList = len(anNumberified)
				for j = 1 to nLenList
					aResult + anNumberified[j]
				next

			but isObject(aContent[i]) and Q(aContent[i]).IsStzNumber()
				n = aContent[i].NumericValue()
				aResult + n
			ok

		next

		This.UpdateWith(aResult)
			 
		def NumberifyQ()
			This.Numberify()
			return This

		def Numbrify()
			This.Numberify()

			def NumbrifyQ()
				This.Numbrify()
				return This

	def Numberified()
		aResult = This.Copy().NumberifyQ().Content()
		return aResult

		def Numbrified()
			return This.Numberified()

	  #----------------------------------------------------------------#
	 #  OBJECTIFYING THE LIST BY TRANFORMING EACH ITEM TO STZ OBJECT  #
	#----------------------------------------------------------------#

	def Objectify()
		
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			aResult + Q(aContent[i])
		next

		This.UpdateWith(aResult)

		def ObjectifyQ()
			This.Objectify()
			return This

		def Softanzify()
			This.Objectify()

			def SoftanzifyQ()
				This.Softanzify()
				return This

	def Objectified()
		aResult = This.Copy().ObjectifyQ().Content()
		return aResult

		def Softanzified()
			return This.Objecified()

	# Swapping the content of the stzList with an other stzList

	def SwapWith(pOtherStzList)

		if CheckParams()

			if NOT @IsStzList(pOtherStzList)
				StzRaise("Incorrect param type! pOtherStzList must be a stzList object.")
			ok
	
		ok

		aThis = This.Content()
		aOther = pOtherStzList.Content()

		This.UpdateWith(aOther)
		pOtherStzList.UpdateWith(aThis)


		def SwapWithQ(pOtherStzList)
			This.SwapWith(pOtherStzList)
			return This

		def SwapContentWith(pOtherStzList)
			This.SwapWith(pOtherStzList)

			def SwapContentWithQ(pOtherStzList)
				return This.SwapWithQ(pOtherStzList)


	  #=======================================#
	 #   SPLITTING THE LIST -- XT/EXTENDED   #
	#=======================================#

	#TODO
	# Add SplitAround(), SplitAroundPosition(), SplitAroundPositions(),
	# SplitAroundItem(), SplitAroundItems(),
	# SplitAroundSection(), SplitAroundSections()
	
	# Add ..IB() extensions to all those functions

	#todo
	# Make same feature in stzList

	#todo
	# add to...() as alternative of SplitTo..() all over the library


	def SplitCSXT(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.SplitAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.SplitAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.SplitAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSections(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.SplitBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSections(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.SplitAfterItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.SplitAfterItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSections(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.SplitBetweenCS(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositions(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.SplitBetweenItemsCS(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNParts(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.SplitToPartsOfNItems(pItem[2])

			but oParam.IsToPartsOfExactlyNItemsNamedParam()
				return This.SplitToPartsOfExactlyNItems(pItem[2])

			but oParam.IsToPartsOfNItemsXTNamedParam()
				return This.SplitToPartsOfNItemsXT(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtW(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeW(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterW(pItem[2])

			else
				return This.SplitAtItemCS(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionFluentForm

		def SplitCSXTQ(pItem, pCaseSensitive)
			return This.SplitCSXTQR(pItem, pCaseSensitive, :stzList)

		def SplitCSXTQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitCSXT(pItem, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitCSXT(pItem, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

	def SplittedCSXT(pItem, pCaseSensitive)
		return This.SplitCSXT(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXT(pItem)
		return This.SplitCSXT(pItem, TRUE)

		#< @FunctionFluentForm

		def SplitXTQ(pItem)
			return This.SplitXTQR(pItem, :stzList)

		def SplitXTQR(pItem, pcReturnType)
			return This.SplitCSXTQR(pItem, TRUE, pcReturnType)

		#>

	def SplittedXT(pItem)
		return This.SplitXT(pItem)

	  #--------------------------------------#
	 #  SPLITTING THE LIST -- XTZ/EXTENDED  #
	#--------------------------------------#

	def SplitCSXTZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.SplitAtItemCSZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.SplitAtItemCSZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.SplitAtItemsCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZ(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.SplitBeforeItemCSZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZ(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.SplitAfterItemCSZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.SplitAfterItemsCSZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZ(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.SplitBetweenCSZ(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZ(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.SplitBetweenItemsCSZ(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZ(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.SplitToPartsOfNItemsZ(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZ(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZ(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZ(pItem[2])

			else
				return This.SplitAtItemCSZ(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionFluentForm

		def SplitCSXTZQ(pItem, pCaseSensitive)
			return This.SplitCSXTZQR(pItem, pCaseSensitive, :stzList)

		def SplitCSXTZQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitCSXTZ(pItem, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

	def SplittedCSXTZ(pItem, pCaseSensitive)
		return This.SplitCSXTZ(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZ(pItem)
		return This.SplitCSXTZ(pItem, TRUE)

		def SplitXTZQ(pItem)
			return This.SplitXTZQR(pItem, :stzlist)

		def SplitXTZQR(pItem, pcReturnType)
			return This.SplitCSXTZQR(pItem, TRUE, pcReturnType)

	def SplittedXTZ(pItem)
		return This.SplitXTZ(pItem)

	  #---------------------------------------#
	 #  SPLITTING THE LIST -- XTZZ/EXTENDED  #
	#---------------------------------------#

	def SplitCSXTZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.SplitAtItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.SplitAtItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZZ(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.SplitBeforeItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZZ(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.SplitAfterItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.SplitAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZZ(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.SplitBetweenCSZZ(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZZ(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.SplitBetweenItemsCSZZ(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZZ(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.SplitToPartsOfNItemsZZ(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZZ(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZZ(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZZ(pItem[2])

			else
				return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionFluentForm

		def SplitCSXTZZQ(pItem, pCaseSensitive)
			return This.SplitCSXTZZQR(pItem, pCaseSensitive, :stzList)

		def SplitCSXTZZQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitCSXTZZ(pItem, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

	def SplittedCSXTZZ(pItem, pCaseSensitive)
		return This.SplitCSXTZZ(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZZ(pItem)
		return This.SplitCSXTZZ(pItem, TRUE)

		def SplitXTZZQ(pItem)
			return This.SplitXTZZQR(pItem, :stzlist)

		def SplitXTZZQR(pItem, pcReturnType)
			return This.SplitCSXTZZQR(pItem, TRUE, pcReturnType)

	def SplittedXTZZ(pItem)
		return This.SplitXTZZ(pItem)

	  #------------------------------#
	 #   SPLITTING AT A GIVEN Item  #
	#==============================#

	def SplitAtCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.SplitAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.SplitAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.SplitAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAtSections(pItem[2])

			else
				return This.SplitAtItemCS(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionFluentForm

		def SplitCSQ(pItem, pCaseSensitive)
			return This.SplitCSQR(pItem, pCaseSensitive, :stzList)

		def SplitCSQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitCS(pItem, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitCS(pItem, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off


		#>

	def SplittedAtCS(pItem, pCaseSensitive)
		return This.SplitAtCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pItem)
		return This.SplitAtCS(pItem, TRUE)

		def SplitAtQ(pItem)
			return This.SplitAtQR(pItem, :stzList)

		def SplitAtQR(pItem, pcReturnType)
			return This.SplitAtCSQR(pItem, TRUE, pcReturnType)

	def SplittedAt(pItem)
		return This.SplitAt(pItem)

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#===================================#

	def SplitAtPosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAtPosition(n)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForm

		def SplitAtPositionQ(pItem, pCaseSensitive)
			return This.SplitAtPositionQR(pItem, pCaseSensitive, :stzList)

		def SplitAtPositionQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtPosition(n) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtPosition(n) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtPosition(n) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtPosition(n) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtPosition(n) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtPosition(n) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtPosition(n) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtPosition(n) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtPosition(n) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtPosition(n) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtPosition(n) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitAtThisPositionQ(n)
				return This.SplitAtThisPositionQR(n, :stzList)

			def SplitAtThisPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		#>

	def SplittedAtPosition(n)
		return This.SplitAtPositions(n)

		def SplittedAtThisPosition(n)
			return This.SplitAtPositions(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtPositions(anPos)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForm

		def SplitAtPositionsQ(pItem, pCaseSensitive)
			return This.SplitAtPositions(anPos)QR(pItem, pCaseSensitive, :stzList)

		def SplitAtPositionsQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtPositions(anPos) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtPositions(anPos) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtPositions(anPos) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtPositions(anPos) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtPositions(anPos) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtPositions(anPos) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtPositions(anPos) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtPositions(anPos) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtPositions(anPos) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtPositions(anPos) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtPositions(anPos) )
	
				other
					StzRaise("Unsupported param type!")
				off


		#>

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtThesePositionsQ(anPos)
				return This.SplitAtThesePositionsQR(anPos, :stzList)
	
			def SplitAtThesePositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		def SplitAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtManyPositionsQ(anPos)
				return This.SplitAtManyPositionsQR(anPos, :stzList)
	
			def SplitAtManyPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		#>

	def SplittedAtPositions(anPos)
		return This.SplitAtPositions(anPos)

		#< @FunctionAlternativeForms

		def SplittedAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplittedAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	  #------------------------------------#
	 #   SPLITTING AT A GIVEN Item   #
	#====================================#

	def SplitAtItemCS(pItem, pCaseSensitive)
		anPos = This.FindCS(pItem, pCaseSensitive)
		if len(anPos) = 0
			return This.Content()
		ok

		aSections = StzSplitterQ(This.NumberOfItems()).SplitAtPositions(anPos)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForm

		def SplitAtItemCSQ(pItem, pCaseSensitive)
			return This.SplitAtItemCSQR(pItem, pCaseSensitive, :stzList)

		def SplitAtItemCSQR(pItem, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtItemCS(pItem, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

		#< @FunctionAlternativeForms

		def SplitsAtItemCS(pItem, pCaseSensitive)
			return This.SplitAtItemCS(pItem, pCaseSensitive)

			def SplitsAtItemCSQ(pItem, pCaseSensitive)
				return This.SplitAtItemCSQ(pItem, pCaseSensitive)

			def SplitsAtItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.SplitAtItemCSQR(pItem, pCaseSensitive, pcReturnType)

		def SplitAtThisItemCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.SplitAtItemCS(pItem, pCaseSensitive)

			def SplitAtThisItemCSQ(pItem, pCaseSensitive)
				return This.AtThisItemCSQR(pItem, pCaseSensitive, :stzList)
	
			def SplitAtThisItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.SplitAtItemCSQR(pItem, pCaseSensitive, pcReturnType)

		def SplitsAtThisItemCS(pItem, pCaseSensitive)
			return This.SplitAtThisItemCS(pItem, pCaseSensitive)

			def SplitsAtThisItemCSQ(pItem, pCaseSensitive)
				return This.SplitAtThisItemCSQR(pItem, pCaseSensitive, :stzList)
	
			def SplitsAtThisItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.SplitAtItemCSQR(pItem, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtItemCS(pItem, pCaseSensitive)
		return This.SplitAtItemCS(pItem, pCaseSensitive)

		def SplittedAtThisItemCS(pItem, pCaseSensitive)
			return This.SplittedAtItemCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtItem(pItem)
		return This.SplitAtItemCS(pItem, TRUE)

		#< @FunctionFluentForm

		def SplitAtItemQ(pItem)
			return This.SplitAtItemQR(pItem, :stzList)

		def SplitAtItemQR(pItem, pcReturnType)
			return This.SplitAtItemCSQR(pItem, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitsAtItem(pItem)
			return This.SplitAtItem(pItem)

			def SplitsAtItemQ(pItem)
				return This.SplitAtItemQ(pItem)

			def SplitsAtItemQR(pItem, pcReturnType)
				return This.SplitAtItemQR(pItem, pcReturnType)

		def SplitAtThisItem(pItem)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.SplitAtItem(pItem)

			def SplitAtThisItemQ(pItem)
				return This.SplitAtThisItemQR(pItem, :stzList)
	
			def SplitAtThisItemQR(pItem, pcReturnType)
				return This.SplitAtItemCSQR(pItem, pcReturnType)

		def SplitsAtThisItem(pItem)
			return This.SplitAtThisItem(pItem)

			def SplitsAtThisItemQ(pItem)
				return This.SplitAtThisItemQ(pItem)

			def SplitsAtThisItemQR(pItem, pcReturnType)
				return This.SplitAtThisItemQ(pItem, pcReturnType)

		#>

	def SplittedAtItem(pItem)
		return This.SplitAtItem(pItem)

		def SplittedAtThisItem(pItem)
			return This.SplittedAtItem(pItem)

	  #---------------------------------------------#
	 #  SPLITS AT A Item AND THEIR POSITIONS  #
	#---------------------------------------------#

	#TODO
	# Check it for performance

	def SplitAtItemCSZ(pItem, pCaseSensitive)
		acSplits = This.SplitAtItemCS(pItem, pCaseSensitive)
		anPos = This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		aResult = Association([ acSplits, anPos ])
		return aResult

		#< @FunctionAlternativeForms


		def SplitsAtItemCSZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZ(pItem, pCaseSensitive)

		def SplitAtThisItemCSZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZ(pItem, pCaseSensitive)

		def SplitsAtThisItemCSZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZ(pItem, pCaseSensitive)

		#--

		def SplitCSZ(pItem, pCaseSensitive)
			acSplits = This.SplitAtCS(pItem, pCaseSensitive)
			anPos = FindSplitsAtCS(pItem, pCaseSensitive)

			aResult = Association([ acSplits, anPos ])
			return aResult
	
		def SplitsCSZ(pItem, pCaseSensitive)
			return This.SplitCSZ(pItem, pCaseSensitive)

		#>

	def SplittedAtItemCSZ(pItem, pCaseSensitive)
		return This.SplitAtItemCSZ(pItem, pCaseSensitive)

		def SplittedAtThisItemCSZ(pItem, pCaseSensitive)
			return This.SplittedAtItemCSZ(pItem, pCaseSensitive)

		def SplittedCSZ(pItem, pCaseSensitive)
			return This.SPlitCSZ(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtItemZ(pItem)
		return This.SplitAtItemCSZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAtItemZ(pItem)
			return This.SplitAtItemZ(pItem)

		def SplitAtThisItemZ(pItem)
			return This.SplitAtItemZ(pItem)

		def SplitsAtThisItemZ(pItem)
			return This.SplitAtItemZ(pItem)

		#--

		def SplitZ(pItem)
			acSplits = This.SplitAt(pItem)
			anPos = FindSplitsAt(pItem)

			aResult = Association([ acSplits, anPos ])
			return aResult
	
		def SplitsZ(pItem)
			return This.SplitZ(pItem)

		#>

	def SplittedAtItemZ(pItem)
		return This.SplitAtItemZ(pItem)

		def SplittedAtThisItemZ(pItem)
			return This.SplittedAtItemZ(pItem)

		def SplittedZ(pItem)
			return This.SplitZ(pItem)

	  #--------------------------------------------#
	 #  SPLITS AT A Item AND THEIR SECTIONS  #
	#--------------------------------------------#

	#TODO
	# Check it for performance

	def SplitAtItemCSZZ(pItem, pCaseSensitive)
		acSplits  = This.SplitAtItemCS(pItem, pCaseSensitive)
		aSections = FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		aResult = Association([ acSplits, aSections ])
		return aResult

		#< @FunctionAlternativeForms


		def SplitsAtItemCSZZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

		def SplitAtThisItemCSZZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

		def SplitsAtThisItemCSZZ(pItem, pCaseSensitive)
			return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

		#>

	def SplittedAtItemCSZZ(pItem, pCaseSensitive)
		return This.SplitAtItemCSZZ(pItem, pCaseSensitive)

		def SplittedAtThisItemCSZZ(pItem, pCaseSensitive)
			return This.SplittedAtItemCSZZ(pItem, pCaseSensitive)

		def SplittedCSZZ(pItem, pCaseSensitive)
			return This.SplitCSZZ(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtItemZZ(pItem)
		return This.SplitAtItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def SplitsAtItemZZ(pItem)
			return This.SplitAtItemZZ(pItem)

		def SplitAtThisItemZZ(pItem)
			return This.SplitAtItemZZ(pItem)

		def SplitsAtThisItemZZ(pItem)
			return This.SplitAtItemZZ(pItem)

		#>

	def SplittedAtItemZZ(pItem)
		return This.SplitAtItemZZ(pItem)

		def SplittedAtThisItemZZ(pItem)
			return This.SplittedAtItemZZ(pItem)

		def SplittedZZ(pItem)
			return This.SplitZZ(pItem)

	  #----------------------------------#
	 #   SPLITTING AT MANY Items   #
	#==================================#

	def SplitAtItemsCS(paItems, pCaseSensitive)
		if CheckParams()
			if This.IsEmpty()
				return []
			ok
		ok

		anPos = This.FindManyCS(paItems, pCaseSensitive)
		if len(anPos) = 0
			return This.Content()
		ok

		aResult = This.SplitAtPositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitAtItemsCSQ(paItems, pCaseSensitive)
			return This.SplitAtItemsCSQR(paItems, pCaseSensitive, :stzList)

		def SplitAtItemsCSQR(paItems, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtItemsCS(paItems, pCaseSensitive) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseItemsCS(paItems, pCaseSensitive)
			return This.SplitAtItemsCS(paItems, pCaseSensitive)

			def SplitAtTheseItemsCSQ(paItems, pCaseSensitive)
				return This.SplitAtTheseItemsCSQR(paItems, pCaseSensitive, :stzList)
	
			def SplitAtTheseItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitAtItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		def SplitAtManyItemsCS(paItems, pCaseSensitive)
			return This.SplitAtItemsCS(paItems, pCaseSensitive)

			def SplitAtManyItemsCSQ(paItems, pCaseSensitive)
				return This.SplitAtManyItemsCSQR(paItems, pCaseSensitive, :stzList)
	
			def SplitAtManyItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitAtItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtItemsCS(paItems, pCaseSensitive)
		return This.SplitAtItemsCS(paItems, pCaseSensitive)

		#< @FunctionAlternativeForms

		def SplittedAtTheseItemsCS(paItems, pCaseSensitive)
			return This.SplitAtItemsCS(paItems, pCaseSensitive)

		def SplittedAtManyItemsCS(paItems, pCaseSensitive)
			return This.SplitAtItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtItems(paItems)
		return This.SplitAtItemsCS(paItems, TRUE)

		#< @FunctionFluentForm

		def SplitAtItemsQ(paItems)
			return This.SplitAtItemsQR(paItems, pCaseSensitive, :stzList)

		def SplitAtItemsQR(paItems, pcReturnType)
			return This.SplitAtItemsCSQR(paItems, TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseItems(paItems)
			return This.SplitAtItems(paItems)

			def SplitAtTheseItemsQ(paItems)
				return This.SplitAtTheseItemsQR(paItems, :stzList)
	
			def SplitAtTheseItemsQR(paItems, pcReturnType)
				return This.SplitAtItemsCSQR(paItems, TRUE, pcReturnType)
	
		def SplitAtManyItems(paItems)
			return This.SplitAtItems(paItems)

			def SplitAtManyItemsQ(paItems)
				return This.SplitAtManyItemsQR(paItems, pCaseSensitive, :stzList)
	
			def SplitAtManyItemsQR(paItems, pcReturnType)
				return This.SplitAtItemsCSQR(pItem, TRUE, pcReturnType)

		#>

	def SplittedAtItems(paItems)
		return This.SplitAtItems(paItems)

		#< @FunctionAlternativeForms

		def SplittedAtTheseItems(paItems)
			return This.SplitAtItems(paItems)

		def SplittedAtManyItems(paItems)
			return This.SplitAtItems(paItems)

		#>

	  #----------------------------------#
	 #   SPLITTING AT A GIVEN SECTION   #
	#==================================#

	def SplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAtSection(n1, n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForm

		def SplitAtSectionQ(n1, n2)
			return This.SplitAtSectionQR(n1, n2, :stzList)

		def SplitAtSectionQR(n1, n2, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtSection(n1, n2) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtSection(n1, n2) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtSection(n1, n2) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtSection(n1, n2) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtSection(n1, n2) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtSection(n1, n2) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtSection(n1, n2) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtSection(n1, n2) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtSection(n1, n2) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtSection(n1, n2) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtSection(n1, n2) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>


		#< @FunctionAlternativeForm

		def SplitAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQR(n1, n2, :stzList)

			def SplitAtThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAtSectionQR(n1, n2, pcReturnType)

		#>


	def SplittedAtSection(n1, n2)
		return This.SplitAtSection(n1, n2)

		def SplittedAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

	  #-----------------------------------------------------#
	 #   SPLITTING AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-----------------------------------------------------#

	def SplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAtSectionIB(n1, n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForm

		def SplitAtSectionIBQ(n1, n2)
			return This.SplitAtSectionIBQR(n1, n2, :stzList)

		def SplitAtSectionIBQR(n1, n2, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtSectionIB(n1, n2) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtSectionIB(n1, n2) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQR(n1, n2, :stzList)

			def SplitAtThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAtSectionIB(n1, n2)
		return This.SplitAtSectionIB(n1, n2)

		def SplittedAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

	  #--------------------------------#
	 #   SPLITTING AT MANY SECTIONS   #
	#--------------------------------#

	def SplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAtSections(paSections)
		aResult = This.AntiSections( paSections )

		return aResult

		#< @FunctionFluentForm

		def SplitAtSectionsQ(paSections)
			return This.SplitAtSectionsQR(pItem, :stzList)

		def SplitAtSectionsQR(paSections, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
				on :stzList
					return new stzList( This.SplitAtSections(paSections) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.SplitAtSections(paSections) )
	
				on :stzListOfItems
					return new stzListOfItems( This.SplitAtSections(paSections) )
	
				on :stzListOfNumbers
					return new stzListOfNumbers( This.SplitAtSections(paSections) )
	
				on :stzListOfObjects
					return new stzListOfObjects( This.SplitAtSections(paSections) )
	
				on :stzListOfLists
					return new stzListOfLists( This.SplitAtSections(paSections) )
	
				on :stzListOfPairs
					return new stzListOfpairs( This.SplitAtSections(paSections) )
	
				on :stzListOfSets
					return new stzListOfSets( This.SplitAtSections(paSections) )
	
				on :stzListOfHashLists
					return new stzListOfHashLists( This.SplitAtSections(paSections) )
	
				on :stzListOfGrids
					return new stzListOfGrids( This.SplitAtSections(paSections) )
	
				on :stzListOfTables
					return new stzListOfTables( This.SplitAtSections(paSections) )
	
				other
					StzRaise("Unsupported param type!")
				off

		#>


		#< @FunctionAlternativeForms

		def SplitAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQR(paSections, :stzList)

			def SplitAtTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAtSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAtSections(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSections(paSections)
			return This.SplittedAtSections(paSections)

	  #---------------------------------------------------#
	 #   SPLITTING AT MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------#

	def SplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAtSectionsIB(paSections)
		aResult = This.AntiSections( paSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAtSectionsIBQ(n1, n2)
			return This.SplitAtSectionsIBQR(n1, n2, pcReturnType)

		def SplitAtSectionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitAtSectionsIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQR(paSections, :stzList)

			def SplitAtTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAtSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAtSectionsIB(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSectionsIB(paSections)
			return This.SplittedAtSections(paSections)

	  #----------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN ITEM   #
	#----------------------------------------------------#

	def SplitBeforeCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.SplitBeforeItemCS(pItem, pCaseSensitive)

		else

			#-- Case when named params are provided

			if Q(pItem).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitBeforePosition(pItem[2])
	
			but Q(pItem).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitBeforePositions(pItem[2])

			but Q(pItem).IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.SplitBeforeItemCS(pItem[2], pCaseSensitive)
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but Q(pItem).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitBeforeSection(pItem[2])
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitBeforeSections(pItem[2])

			else
				return This.SplitBeforeItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionFluentForms

		def SplitBeforeCSQ(pItem, pCaseSensitive)
			return This.SplitBeforeCSQR(pItem, pCaseSensitive, :stzList)

		def SplitBeforeCSQR(pItem, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCS(pItem, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBeforeCS(pItem, pCaseSensitive)
		return This.SplitBeforeCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBefore(pItem)
		return This.SplitBeforeCS(pItem, TRUE)

		def SplitBeforeQ(pItem)
			return This.SplitBeforeQR(pItem, :stzList)

		def SplitBeforeQR(pItem, pcReturnType)
			return This.SplitBeforeCSQR(pItem, TRUE, pcReturnType)

	def SplittedBefore(pItem)
		return This.SplitBefore(pItem)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitBeforePosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforePosition(n)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforePositionQ(n)
			return This.SplitBeforePositionQR(n, :stzList)

		def SplitBeforePositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePosition(n) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforePosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitBeforeThisPositionQ(n)
				return This.SplitBeforeThisPositionQR(n, :stzList)

			def SplitBeforeThisPositionQR(n, pcReturnType)
				return This.SplitBeforePositionQR(n, pcReturnType)

		#>

	def SplittedBeforePosition(n)
		return This.SplitBeforePosition(n)

		def SplittedBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(anPos)

		if CheckParams()
			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforePositions(anPos)
		aResult = This.Sections( aSections )

		return aResult			

		#< @FunctionFluentForms

		def SplitBeforePositionsQ(anPos)
			return This.SplitBeforePositionsQR(anPos, :stzList)

		def SplitBeforePositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositions(anPos) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforePositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThesePositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeThesePositionsQ(anPos)
				return This.SplitBeforThesePositionsQR(anPos, :stzList)

			def SplitBeforeThesePositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		def SplitBeforeManyPositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeManyPositionsQ(anPos)
				return This.SplitBeforeManyPositionsQR(anPos, :stzList)

			def SplitBeforeManyPositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		#>

	def SplittedBeforePositions(anPos)
		return This.SplitBeforePositions(anPos)

		def SplittedBeforeThesePoitions(anPos)
			return This.SplittedBeforePositions(anPos)

		def SplittedBeforeManyPoitions(anPos)
			return This.SplittedBeforePositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN Item   #
	#----------------------------------------#

	def SplitBeforeItemCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		if len(anPos) = 0
			return This.Content()
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforePositions(anPos)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeItemCSQ(pItem, pCaseSensitive)
			return This.SplitBeforeItemCSQR(pItem, pCaseSensitive, :stzList)

		def SplitBeforeItemCSQR(pItem, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeItemCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeItemCS(pItem, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeItemCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisItemCS(pItem, pCaseSensitive)
			return This.SplitBeforeItemCS(pItem, pCaseSensitive)

			def SplitBeforeThisItemCSQ(pItem, pCaseSensitive)
				return This.SplitBeforeThisItemCSQR(pItem, pCaseSensitive, :stzList)

			def SplitBeforeThisItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.SplitBeforeItemCSQR(pItem, pCaseSensitive, pcReturnType)

		#>
				
	def SplittedBeforeItemCS(pItem, pCaseSensitive)
		return This.SplitBeforeItemCS(pItem, pCaseSensitive)

		def SplittedBeforeThisItemCS(pItem, pCaseSensitive)
			return This.SplittedBeforeItemCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeItem(pItem)
		return This.SplitBeforeItemCS(pItem, TRUE)

		#< @FunctionFluentForms

		def SplitBeforeItemQ(pItem)
			return This.SplitBeforeItemQR(pItem, :stzList)

		def SplitBeforeItemQR(pItem, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeItem(pItem) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeItem(pItem) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeItem(pItem) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisItem(pItem)
			return This.SplitBeforeItem(pItem)

			def SplitBeforeThisItemQ(pItem)
				return This.SplitBeforeThisItemQR(pItem, :stzList)

			def SplitBeforeThisItemQR(pItem, pcReturnType)
				return This.SplitBeforeItemQR(pItem, pcReturnType)

		#>

	def SplittedBeforeItem(pItem)
		return This.SplitBeforeItem(pItem)

		def SplittedBeforeThisItem(pItem)
			return This.SplittedBeforeItem(pItem)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY Items   #
	#--------------------------------------#

	def SplitBeforeItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindManyCS( paItems, pCaseSensitive )
		if len(anPos) = 0
			return This.Content()
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforePositions(anPos)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeItemsCSQ(paItems, pCaseSensitive)
			return This.SplitBeforeItemsCSQR(paItems, pCaseSensitive, :stzList)

		def SplitBeforeItemsCSQR(paItems, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeItemsCS(paItems, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeItemsCS(paItems, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeItemsCS(paItems, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.SplitBeforeItemsCS(paItems, pCaseSensitive)

			def SplitBeforeTheseItemsCSQ(paItems, pCaseSensitive)
				return This.SplitBeforeThisItemsCSQR(paItems, pCaseSensitive, :stzList)

			def SplitBeforeTheseItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitBeforeItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		def SplitBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.SplitBeforeItemsCS(paItems, pCaseSensitive)

			def SplitBeforeManyItemsCSQ(paItems, pCaseSensitive)
				return This.SplitBeforeManyItemsCSQR(paItems, pCaseSensitive, :stzList)

			def SplitBeforeManyItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitBeforeItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeItemsCS(paItems, pCaseSensitive)
		return This.SplitBeforeItemsCS(paItems, pCaseSensitive)

		def SplittedBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.SplittedBeforeItemsCS(paItems, pCaseSensitive)

		def SplittedBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.SplittedBeforeItemsCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeItems(paItems)
		return This.SplitBeforeItemsCS(paItems, TRUE)
	
		#< @FunctionFluentForms

		def SplitBeforeItemsQ(paItems)
			return This.SplitBeforeItemsQR(paItems, :stzList)

		def SplitBeforeItemsQR(paItems, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeItems(paItems) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeItems(paItems) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeItemsCS(paItems) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseItems(paItems)
			return This.SplitBeforeItems(paItems)

			def SplitBeforeTheseItemsQ(paItems)
				return This.SplitBeforeThisItemsQR(paItems, :stzList)

			def SplitBeforeTheseItemsQR(paItems, pcReturnType)
				return This.SplitBeforeItemsQR(paItems, pcReturnType)

		def SplitBeforeManyItems(paItems)
			return This.SplitBeforeItems(paItems)

			def SplitBeforeManyItemsQ(paItems)
				return This.SplitBeforeManyItemsQR(paItems, :stzList)

			def SplitBeforeManyItemsQR(paItems, pcReturnType)
				return This.SplitBeforeItemsQR(paItems, pcReturnType)

		#>

	def SplittedBeforeItems(paItems)
		return This.SplitBeforeItems(paItems)

		def SplittedBeforeTheseItems(paItems)
			return This.SplittedBeforeItems(paItems)

		def SplittedBeforeManyItems(paItems)
			return This.SplittedBeforeItems(paItems)

	  #--------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION   #
	#--------------------------------------#

	def SplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSection(n1, n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeSectionQ(n1, n2)
			return This.SplitBeforeSectionQR(n1, n2, :stzList)

		def SplitBeforeSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSection(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeSubSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeThisSectionQR(n1, n2, :stzList)

			def SplitBeforeThisSectionQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQR(n1, n2, pcReturnType)

		#>

	def SplittedBeforeSection(n1, n2)
		return This.SplitBeforeSection(n1, n2)

		def SplittedBeforeThisSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

	  #--------------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------#

	def SplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionIB(n1, n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeSectionIBQ(n1, n2)
			return This.SplitBeforeSectionIBQR(n1, n2, :stzList)

		def SplitBeforeSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeSubSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeThisSectionIBQR(n1, n2, :stzList)

			def SplitBeforeThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedBeforeSectionIB(n1, n2)
		return This.SplitBeforeSectionIB(n1, n2)

		def SplittedBeforeThisSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

	  #------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS   #
	#------------------------------------#

	def SplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSections(paSections)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsQ(paSections)
			return This.SplitBeforeSectionsQR(paSections, :stzList)

		def SplitBeforeSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSections(paSections) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeSubSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQR(paSections, :stzList)

			def SplitBeforeTheseSectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		def SplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQR(paSections, :stzList)

			def SplitBeforeManySectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		#>

	def SplittedBeforeSections(paSections)
		return This.SplitBeforeSections(paSections)

		def SplittedBeforeTheseSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplittedBeforeManySections(paSections)
			return This.SplittedBeforeSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#------------------------------------------------------#

	def SplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionsIB(paSections)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsIBQ(paSections)
			return This.SplitBeforeSectionsIBQR(paSections, :stzList)

		def SplitBeforeSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeSubSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>


		#< @FunctionAlternativeForms

		def SplitBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQR(paSections, :stzList)

			def SplitBeforeTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		def SplitBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQR(paSections, :stzList)

			def SplitBeforeManySectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedBeforeSectionsIB(paSections)
		return This.SplitBeforeSectionsIB(paSections)

		def SplittedBeforeTheseSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplittedBeforeManySectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

	  #--------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN ITEM  #
	#--------------------------------------------------#

	def SplitAfterCS(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.SplitAfterItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.SplitAfterPosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAfterPositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.SplitAfterItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.SplitAfterItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAfterSection(pItem[2])
		
			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAfterSections(pItem[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but oItem.IsListOfNumbers()
				return This.SplitAfterPositions(pItem)

			but oItem.IsListOfStrings()
				return This.SplitAfterItems(pItem)

			but oItem.IsListOfPairsOfNumbers()
				return This.SplitAfterSections(pItem)

			else
				return This.SplitAfterItemCS(pItem, pCaseSensitive)
			ok

		ok

		#< @FunctionFluentForms

		def SplitAfterCSQ(pItem, pCaseSensitive)
			return This.SplitAfterCSQR(pItem, pCaseSensitive, :stzList)

		def SplitAfterCSQR(pItem, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCS(pItem, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedAfterCS(pItem, pCaseSensitive)
		return This.SplitAfterCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfter(pItem)
		return This.SplitAfterCS(pItem, TRUE)

		#< @FunctionFluentForm

		def SplitAfterQ(pItem)
			return This.SplitAfterQR(pItem, :stzList)

		def SplitAfterQR(pItem, pcReturnType)
			return This.SplitAfterCSQR(pItem, TRUE, pcReturnType)

		#>

	def SplittedAfter(pItem)
		return This.SplitAfter(pItem)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterPosition(n)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterPositionQ(n)
			return This.SplitAfterPositionQR(n, :stzList)

		def SplitAfterPositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPosition(n) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitAfterThisPositionQ(n)
				return This.SplitAfterThisPositionQR(n, :stzList)

			def SplitAfterThisPositionQR(n, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPosition(n)
		return This.SplitAfterPosition(n)

		def SplittedAfterThisPosition(n)
			return This.SplittedAfterPosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterPositions(anPos)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterPositionsQ(anPos)
			return This.SplitAfterPositionsQR(anPos, :stzList)

		def SplitAfterPositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositions(anPos) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQR(anPos, :stzList)

			def SplitAfterThesePositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		def SplitAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQR(anPos, :stzList)

			def SplitAfterManyPositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPositions(anPos)
		return This.SplitAfterPositions(anPos)

		def SplittedAfterThesePositions(anPos)
			return This.SplittedAfterPositions(anPos)

		def SplittedAfterManyPositions(anPos)
			return This.SplittedAfterPositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN Item   #
	#----------------------------------------#

	def SplitAfterItemCS(pItem, pCaseSensitive)

		anPos = This.FindCS(pItem, pCaseSensitive)
		if len(anPos) = 0
			return This.Content()
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterPositions(anPos)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterItemCSQ(pItem, pCaseSensitive)
			return This.SplitAfterItemCSQR(pItem, pCaseSensitive, :stzList)

		def SplitAfterItemCSQR(pItem, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterItemCS(pItem, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterItemCS(pItem, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterItemCS(pItem, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisItemCS(pItem, pCaseSensitive)
			return This.SplitAfterItemCS(pItem, pCaseSensitive)

			def SplitAfterThisItemQCS(pItem, pCaseSensitive)
				return This.SplitAfterThisItemCSQR(pItem, pCaseSensitive, :stzList)

			def SplitAfterThisItemCSQR(pItem, pCaseSensitive, pcReturnType)
				return This.SplitAfterItemCSQR(pItem, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterItemCS(pItem, pCaseSensitive)
		return This.SplitAfterItemCS(pItem, pCaseSensitive)

		def SplittedAfterThisItemCS(pItem, pCaseSensitive)
			return This.SplittedAfterItemCS(pItem, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterItem(pItem)
		return This.SplitAfterItemCS(pItem, TRUE)

		#< @FunctionFluentForms

		def SplitAfterItemQ(pItem)
			return This.SplitAfterItemQR(pItem)

		def SplitAfterItemQR(pItem)
			return This.SplitAfterThisItemCSQR(pItem, :pCaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisItem(pItem)
			return This.SplitAfterItem(pItem)

			def SplitAfterThisItemQ(pItem)
				return This.SplitAfterThisItemQR(pItem, :stzList)

			def SplitAfterThisItemQR(pItem, pcReturnType)
				return This.SplitAfterItemQR(pItem, pcReturnType)

		#>

	def SplittedAfterItem(pItem)
		return This.SplitAfterItem(pItem)

		def SplittedAfterThisItem(pItem)
			return This.SplittedAfterItem(pItem)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY Items   #
	#--------------------------------------#

	def SplitAfterItemsCS(paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		if len(anPos) = 0
			return This.Content()
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterPositions(anPos)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterItemsCSQ(paItems, pCaseSensitive)
			return This.SplitAfterItemsCSQR(paItems, pCaseSensitive, :stzList)

		def SplitAfterItemsCSQR(paItems, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterItemsCS(paItems, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterItemsCS(paItems, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterItemsCS(paItems, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.SplitAfterItemsCS(paItems, pCaseSensitive)

			def SplitAfterTheseItemsQCS(paItems, pCaseSensitive)
				return This.SplitAfterTheseItemsCSQR(paItems, pCaseSensitive, :stzList)

			def SplitAfterTheseItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitAfterItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		def SplitAfterManyItemsCS(paItems, pCaseSensitive)
			return This.SplitAfterItemsCS(paItems, pCaseSensitive)

			def SplitAfterManyItemsQCS(paItems, pCaseSensitive)
				return This.SplitAfterManyItemsCSQR(paItems, pCaseSensitive, :stzList)

			def SplitAfterManyItemsCSQR(paItems, pCaseSensitive, pcReturnType)
				return This.SplitAfterItemsCSQR(paItems, pCaseSensitive)

		#>

	def SplittedAfterItemsCS(paItems, pCaseSensitive)
		return This.SplitAfterItemsCS(paItems, pCaseSensitive)

		def SplittedAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.SplittedAfterItemsCS(paItems, pCaseSensitive)

		def SplittedAfterManyItemsCS(paItems, pCaseSensitive)
			return This.SplittedAfterItemsCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterItems(paItems)
		return This.SplitAfterItemsCS(paItems, TRUE)

		#< @FunctionFluentForms

		def SplitAfterItemsQ(paItems)
			return This.SplitAfterItemsQR(paItems, :stzList)

		def SplitAfterItemsQR(paItems, pcReturnType)
			return This.SplitAfterItemsCSQR(paItems, :CaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseItems(paItems)
			return This.SplitAfterItems(paItems)

			def SplitAfterTheseItemsQ(paItems)
				return This.SplitAfterTheseItemsQR(paItems, :stzList)

			def SplitAfterTheseItemsQR(paItems, pcReturnType)
				return This.SplitAfterItemsQR(paItems, pcReturnType)

		def SplitAfterManyItems(paItems)
			return This.SplitAfterItems(paItems)

			def SplitAfterManyItemsQ(paItems)
				return This.SplitAfterManyItemsQR(paItems, :stzList)

			def SplitAfterManyItemsQR(paItems, pcReturnType)
				return This.SplitAfterItemsQR(paItems, pcReturnType)

		#>

	def SplittedAfterItems(paItems)
		return This.SplitAfterItems(paItems)

		def SplittedAfterTheseItems(paItems)
			return This.SplitAfterItems(paItems)

		def SplittedAfterManyItems(paItems)
			return This.SplitAfterItems(paItems)

	  #-------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION   #
	#-------------------------------------#

	def SplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterSection(n1 , n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterSectionQ(n1, n2)
			return This.SplitAfterSectionQR(n1, n2)

		def SplitAfterSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSection(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitAfterThisSectionQ(n1, n2)
				return This.SplitAfterThisSectionQR(n1, n2, :stzList)

			def SplitAfterThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionQR(n1, n2, pcReturnType)

		#>

	def SplittedAfterSection(n1, n2)
		return This.SplitAfterSection(n1, n2)

		def SplittedAfterThisSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

	  #-------------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-------------------------------------------------------#

	def SplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterSectionIB(n1 , n2)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterSectionIBQ(n1, n2)
			return This.SplitAfterSectionIBQR(n1, n2, :stzList)

		def SplitAfterSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSectionIB(n1, n2)
			return This.SplitAfterSectionIB(n1, n2)

			def SplitAfterThisSectionIBQ(n1, n2)
				return This.SplitAfterThisSectionIBQR(n1, n2, :stzList)

			def SplitAfterThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAfterSectionIB(n1, n2)
		return This.SplitAfterSectionIB(n1, n2)

		def SplittedAfterThisSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

	  #-----------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS   #
	#-----------------------------------#

	def SplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterSections(paSections)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterSectionsQ(paSections)
			return This.SplitAfterSectionsQR(paSections, :stzList)

		def SplitAfterSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSections(paSections) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSections(paSections)
			return This.SplitAfteSections(paSections)

			def SplitAfterTheseSectionsQ(paSections)
				return This.SplitAfterTheseSectionsQR(paSections, :stzList)

			def SplitAfterTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAfterSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAfterSections(paSections)
		return This.SplitAfterSections(paSections)

		def SplittedAfterTheseSections(paSections)
			return This.SplittedAfterSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------#

	def SplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfItems() ).SplitAfterSectionsIB(paSections)
		aResult = This.Sections( aSections )

		return aResult

		#< @FunctionFluentForms

		def SplitAfterSectionsIBQ(paSections)
			return This.SplitAfterSectionsIBQR(paSections, :stzList)

		def SplitAfterSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSectionsIB(paSections)
			return This.SplitAfteSectionsIB(paSections)

			def SplitAfterTheseSectionsIBQ(paSections)
				return This.SplitAfterTheseSectionsIBQR(paSections, :stzList)

			def SplitAfterTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAfterSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAfterSectionsIB(paSections)
		return This.SplitAfterSectionsIB(paSections)

		def SplittedAfterTheseSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR Items  #
	#=================================================#

	#TODO
	# Check it for correctness

	def SplitBetweenCS(pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitBetweenCSQ(Bound1, pItem2, pCaseSensitive)
			return This.SplitBetweenCSQR(Bound1, pItem2, pCaseSensitive, :stzList)

		def SplitBetweenCSQR(Bound1, pItem2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCS(pItem1, pItem2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCS(pItem1, pItem2, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenCS(pItem1, pItem2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCS(pItem1, pItem2, pCaseSensitive)
		return This.SplitBetweenCS(pItem1, pItem2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetween(pItem1, pItem2)
		return This.SplitBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenQ(Bound1, pItem2, pCaseSensitive)
			return This.SplitBetweenQR(Bound1, pItem2, :stzList)

		def SplitBetweenQR(Bound1, pItem2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetween(pItem1, pItem2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetween(pItem1, pItem2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetween(pItem1, pItem2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetween(pItem1, pItem2)
		return This.SplitBetween(pItem1, pItem2)

	  #---------------------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	#TODO
	# Check it for correctness

	def SplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)
		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitBetweenCSIBQ(Bound1, pItem2, pCaseSensitive)
			return This.SplitBetweenCSIBQR(Bound1, pItem2, pCaseSensitive, :stzList)

		def SplitBetweenCSIBQR(Bound1, pItem2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCSIB(pItem1, pItem2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCSIB(pItem1, pItem2, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenCSIB(pItem1, pItem2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCSIB(pItem1, pItem2, pCaseSensitive)
		return This.SplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenIB(pItem1, pItem2)
		return This.SplitBetweenCSIB(pItem1, pItem2, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenIBQ(Bound1, pItem2, pCaseSensitive)
			return This.SplitBetweenIBQR(Bound1, pItem2, :stzList)

		def SplitBetweenIBQR(Bound1, pItem2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenIB(pItem1, pItem2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenIB(pItem1, pItem2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenIB(pItem1, pItem2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenIB(pItem1, pItem2)
		return This.SplitBetweenIB(pItem1, pItem2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS   #
	#------------------------------------#

	def SplitBetweenPositions(n1, n2)
		This.SplitAtSection(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsQ(n1, n2)
			return This.SplitBetweenPositionsQR(n1, n2, :stzList)

		def SplitBetweenPositionsQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenPositions(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositions(n1, n2)
			return This.SplitBetweenPositions(n1, n2)

			def SplitBetweenThesePositionsQ(n1, n2)
				return This.SplitBetweenThesePositionsQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositions(n1, n2)
		return This.SplitBetweenPositions(n1, n2)

		def SplittedBetweenThesePositions(n1, n2)
			return This.SplittedBetweenPositions(n1, n2)

	  #-------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------#

	def SplitBetweenPositionsIB(n1, n2)
		This.SplitAtSectionIB(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsIBQ(n1, n2)
			return This.SplitBetweenPositionsIBQR(n1, n2, :stzList)

		def SplitBetweenPositionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenPositionsIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositionsIB(n1, n2)
			return This.SplitBetweenPositionsIB(n1, n2)

			def SplitBetweenThesePositionsIBQ(n1, n2)
				return This.SplitBetweenThesePositionsIBQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsIBQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsIBQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositionsIB(n1, n2)
		return This.SplitBetweenPositionsIB(n1, n2)

		def SplittedBetweenThesePositionsIB(n1, n2)
			return This.SplittedBetweenPositionsIB(n1, n2)

	  #-------------------------------#
	 #  SPLITTING BETWEEN TWO Items  #
	#-------------------------------#

	def SplitBetweenItemsCS(paItems, pCaseSensitive)
		aSections = This.FindAsSectionsCS(paItems, pCaseSensitive)
		aResult = This.SplitBetweenSections(aSections)
		return aResult

		#< @FunctionFluentForms

		def SplitBetweenItemsCSQ(paItems, pCaseSensitive)
			return This.SplitBetweenItemsCSQR(paItems, pCaseSensitive, :stzList)

		def SplitBetweenItemsCSQR(paItems, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenItemsCS(paItems, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenItemsCS(paItems, pCaseSensitive) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenItemsCS(paItems, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseItemsCS(paItems, pCaseSensitive)
			return This.SplitBetweenItemsCS(paItems, pCaseSensitive)

			def SplitBetweenTheseItemsCSQ(paItems, pCaseSensitive)
				return This.SplitBetweenTheseItemsCSQR(paItems, pCaseSensitive, :stzList)

			def SplitBetweenTheseItemsCSQR(paItems, pCaseSensitive, pcReturntype)
				return This.SplitBetweenItemsCSQR(paItems, pCaseSensitive, pcReturnType)

		#>

	def SplittedBetweenItemsCS(paItems, pCaseSensitive)
		aResult = This.Copy().SplitBetweenItemsCSQ(paItems, pCaseSensitive).Content()
		return aResult

		def SplittedBetweenTheseItemsCs(paItems, pCaseSensitive)
			return This.SplittedBetweenItemsCS(paItems, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenItems(paItems)
		return This.SplitBetweenItemsCS(paItems, TRUE)

		#< @FunctionFluentForms

		def SplitBetweenItemsQ(paItems)
			return This.SplitBetweenItemsQR(paItems, :stzList)

		def SplitBetweenItemsQR(paItems, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenItems(paItems) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenItems(paItems) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitBetweenItems(paItems) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseItems(paItems)
			return This.SplitBetweenItems(paItems)

			def SplitBetweenTheseItemsQ(paItems)
				return This.SplitBetweenTheseItemsQR(paItems, :stzList)

			def SplitBetweenTheseItemsQR(paItems, pcReturntype)
				return This.SplitBetweenItemsQR(paItems, pcReturnType)

		#>

	def SplittedBetweenItems(paItems)
		return This.SplittedBetweenItemsCS(paItems, TRUE)

		def SplittedBetweenTheseItems(paItems)
			return This.SplittedBetweenItems(paItems)

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#============================#

	def SplitToNParts(n)
		aSections = StzSplitterQ( This.NumberOfItems() ).SplitToNParts(n)
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToNPartsQ(n)
			return This.SplitToNPartsQR(n, :stzList)

		def SplitToNPartsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToNParts(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToNParts(n) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitToNParts(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToNParts(n)
		return This.SplitToNParts(n)

	  #---------------------------------------------#
	 #   SPLITTING TO PARTS OF (EXACTLY) N Items   #
	#---------------------------------------------#
	# Remaining part less the n Items is not returned

	def SplitToPartsOfNItems(n)
		aSections = StzSplitterQ( This.NumberOfItems() ).
				SplitToPartsOfExactlyNPositions(n)

		aResult = This.Sections( aSections )
		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNItemsQ(n)
			return This.SplitToPartsOfNItemsQR(n, :stzList)

		def SplitToPartsOfNItemsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNItems(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNItems(n) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitToPartsOfNItems(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfExactlyNItems(n)
			return This.SplitToPartsOfNItems(n)

			def SplitToPartsOfExactlyNItemsQ(n)
				return This.SplitToPartsOfExactlyNItemsQR(n, :stzList)

			def SplitToPartsOfExactlyNItemsQR(n, pcReturnType)
				return This.SplitToPartsOfNItemsQR(n, pcReturnType)

		#--

		def SplitToListsOfNItems(n)
			return This.SplitToPartsOfNItems(n)

			def SplitToListsOfNItemsQ(n)
				return This.SplitToPartsOfNItemsQ(n)

			def SplitToListsOfNItemsQR(n, pcReturnType)
				return This.SplitToPartsOfNItemsQR(n, pcReturnType)

		def SplitToListsOfExactlyNItems(n)
			return This.SplitToPartsOfNItems(n)

			def SplitToListsOfExactlyNItemsQ(n)
				return This.SplitToPartsOfExactlyNItemsQR(n, :stzList)

			def SplitToListsOfExactlyNItemsQR(n, pcReturnType)
				return This.SplitToPartsOfNItemsQR(n, pcReturnType)

		#>

	def SplittedToPartsOfNItems(n)
		return This.SplitToPartsOfNItems(n)

		def SplittedToPartsOfExactlyNItems(n)
			return This.SplitToPartsOfNItems(n)

		def SplittedToListsOfNItems(n)
			return This.SplittedToPartsOfNItems(n)

		def SplittedToListsOfExactlyNItems(n)
			return This.SplitToPartsOfNItems(n)

	  #----------------------------------------------#
	 #   SPLITTING TO PARTS OF N Items -- EXTENDED  #
	#----------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def SplitToPartsOfNItemsXT(n)
		aSections = StzSplitterQ( This.NumberOfItems() ).
				SplitToPartsOfNPositions(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNItemsXTQ(n)
			return This.SplitToPartsOfNItemsXTQR(n, :stzList)

		def SplitToPartsOfNItemsXTQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNItemsXT(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNItemsXT(n) )

			on :stzListOfItems
				return new stzListOfItems( This.SplitToPartsOfNItemsXT(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToPartsOfNItemsXT(n)
		return This.SplitToPartsOfNItemsXT(n)

		def SplittedToPartsOfExactlyNItemsXT(n)
			return This.SplitToPartsOfNItemsXT(n)

	  #---------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDTION   #
	#=======================================#

	def SplitW(pcCondition)
		/*
		? StzListQ(1:5).SplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.SplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.SplitAfterW(pcCondition[2])

			ok
		
		else

			return This.SplitAtW(pcCondition)
		ok

		#< @FunctionFluentForms

		def SplitWQ(pcCondition)
			return This.SplitWQR(pcCondition, :stzList)

		def SplitWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitW(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedW(pcConditon)
		return This.SplitW(pcCondition)

	  #-----------------------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDTION -- XT/EXTENDED  #
	#-----------------------------------------------------#

	def SplitWXT(pcCondition)
		/*
		? StzListQ(1:5).SplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.SplitAtWXT(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.SplitAtWXT(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.SplitBeforeWXT(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.SplitAfterWXT(pcCondition[2])

			ok
		
		else

			return This.SplitAtWXT(pcCondition)
		ok

		#< @FunctionFluentForms

		def SplitWXTQ(pcCondition)
			return This.SplitWXTQR(pcCondition, :stzList)

		def SplitWXTQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitWXT(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitWXT(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitWXT(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedWXT(pcConditon)
		return This.SplitWXT(pcCondition)

	  #------------------------------------#
	 #    SPLITTING AT A GIVEN CONDTION   #
	#====================================#

	def SplitAtW(pcCondition)

		anPos = This.FindW(pcCondition)
		aResult = This.SplitAtPositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitAtWQ(pcCondition)
			return This.SplitAtWQR(pcCondition, :stzList)

		def SplitAtWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtW(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitAtW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtW(pcConditon)
		return This.SplitAtW(pcCondition)

	  #---------------------------------------------------#
	 #    SPLITTING AT A GIVEN CONDTION -- WXT/EXTENDED  #
	#---------------------------------------------------#

	def SplitAtWXT(pcCondition)
		anPos = This.FindWXT(pcCondition)
		aResult = This.SplitAtPositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitAtWXTQ(pcCondition)
			return This.SplitAtWXTQR(pcCondition, :stzList)

		def SplitAtWXTQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtWXT(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtWXT(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitAtWXT(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtWXT(pcConditon)
		return This.SplitAtWXT(pcCondition)

	  #----------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDTION   #
	#========================================#

	def SplitBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.SplitBeforePositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeWQ(pcCondition)
			return This.SplitBeforeWQR(pcCondition, :stzList)

		def SplitBeforeWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeW(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeW(pcConditon)
		return This.SplitBeforeW(pcCondition)

	  #------------------------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDTION -- XT/EXTENDED  #
	#------------------------------------------------------#

	def SplitBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.SplitBeforePositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeWXTQ(pcCondition)
			return This.SplitBeforeWXTQR(pcCondition, :stzList)

		def SplitBeforeWXTQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeWXT(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeWXT(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitBeforeWXT(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeWXT(pcConditon)
		return This.SplitBeforeWXT(pcCondition)

	  #---------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDTION   #
	#=======================================#

	def SplitAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.SplitAfterPositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitAfterWQ(pcCondition)
			return This.SplitAfterWQR(pcCondition, :stzList)

		def SplitAfterWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterW(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterW(pcConditon)
		return This.SplitAfterW(pcCondition)

	  #------------------------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDTION -- WXT/EXTENDED  #
	#------------------------------------------------------#

	def SplitAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.SplitAfterPositions(anPos)

		return aResult

		#< @FunctionFluentForms

		def SplitAfterWXTQ(pcCondition)
			return This.SplitAfterWXTQR(pcCondition, :stzList)

		def SplitAfterWXTQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterWXT(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterWXT(pcCondition) )
			on :stzListOfItems
				return new stzListOfItems( This.SplitAfterWXT(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterWXT(pcConditon)
		return This.SplitAfterWXT(pcCondition)

	  #-----------------------------------------------------------#
	 #  NTH ITEM AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#===========================================================#
	# Utility function used to simplify code in stzListOfStrings

	def NthItemAfterSplittingStringUsing(n, cSep)
	#TODO: Remake it using FindNthSplitZZ(n)

		return This.Split(cSep)[n]

		def NthSplit(n, cSep)
			return This.NthItemAfterSplittingStringUsing(n, cSep)

	  #========================#
	 #   FINDING THE SPLITS   #
	#========================#

	def FindSplitsCSXT(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindSplitsAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindSplitsAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSections(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindSplitsBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSections(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindSplitsAfterItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindSplitsAfterItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSections(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindSplitsBetweenCS(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositions(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.FindSplitsBetweenItemsCS(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNParts(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindSplitsToPartsOfNItems(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtW(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindSplitsBeforeW(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindSplitsAfterW(pItem[2])

			else
				return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindSplitsCSXTZ(pItem, pCaseSensitive)
			return This.FindSplitsCSXT(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXT(pItem)
		return This.FindSplitsCSXT(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsXTZ(pItem)
			return This.FindSplitsXT(pItem)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN Item  #
	#====================================================#

	def FindSplitsAtCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSections(pItem[2])

			else
				return This.FindSplitsAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAt(pItem)
		return This.FindSplitsAtCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtZ(pItem)
			return This.FindSplitsAtCS(pSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN POSITION   #
	#========================================#

	def FindSplitsAtPosition(n)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAtPosition(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPosition(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtPositionZ(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtThisPositionZ(n)
			return This.FindSplitsAtPosition(n)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AT MANY POSITIONS   #
	#--------------------------------------#

	def FindSplitsAtPositions(anPos)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		#--

		def FindSplitsAtPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtThesePositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN Item   #
	#=========================================#

	def FindSplitsAtItemCS(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		anResult = This.FindManyCS( This.SplitsAtItemCS(pItem, pCaseSensitive), pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsAtItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItem(pItem)
		return This.FindSplitsAtItemCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindSplits(pItem)
			return This.FindSplitsCS(pItem, TRUE)

		def FindSplitsAtThisItem(pItem)
			return This.FindSplitsAtThisItemCS(pItem, TRUE)
		#--

		def FindSplitsAtItemZ(pItem)
			return This.FindSplitsAtItemCS(pItem, TRUE)

		def FindSplitsZ(pItem)
			return This.FindSplitsCS(pItem, TRUE)

		def FindSplitsAtThisItemZ(pItem)
			return This.FindSplitsAtThisItemCS(pItem, TRUE)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT GIVEN Items   #
	#----------------------------------------#

	def FindSplitsAtItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsAtItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItems(paItems)
		return This.FindSplitsAtItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItems(paItems)
			return This.FindSplitsAtItems(paItems)
	
		def FindSplitsAtManyItems(paItems)
			return This.FindSplitsAtItems(paItems)

		#--

		def FindSplitsAtItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		def FindSplitsAtTheseItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		def FindSplitsAtManyItemsZ(paItems)
			return This.FindSplitsAtItems(paItems)

		#>

	  #---------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION   #
	#=======================================#

	def FindSplitsAtSectionCS(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCS(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSection(n1, n2)
		return This.FindSplitsAtSectionCS(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSection(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#--

		def FindSplitsAtSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		def FindSplitsAtThisSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#==========================================================#

	def FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIB(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionCSIBZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIB(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIB(n1, n2)
		return This.FindSplitsAtSectionCSIB(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindSplitsAtSectionIBZ(n1, n2)
			return This.FindSplitsAtSectionIB(n1, n2)

		def FindSplitsAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS  #
	#====================================#

	def FindSplitsAtSectionsCS(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult
		
		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCS(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSections(paSections)
		return This.FindSplitsAtSectionsCS(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSections(paSections)
			return This.FindSplitsAtSections(paSections)

		#--

		def FindSplitsAtSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		def FindSplitsAtTheseSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS -- BOUNDS INCLUDED   #
	#========================================================#

	def FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok
	
		ok

		acSplits = This.SplitsAtSectionsIB(paSections)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsCSIBZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSIB(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsIB(paSections)
		return This.FindSplitsAtSectionsCSIB(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsIB(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#--

		def FindSplitsAtSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		def FindSplitsAtTheseSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN ITEM   #
	#=========================================================#

	def FindSplitsBeforeCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsBeforeItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSection(pItem[2])
		
			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSections(pItem[2])

			else
				return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBefore(pItem)
		return This.FindSplitsBeforeCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeZ(pItem)
			return This.FindSplitsBefore(pItem)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#============================================#

	def FindSplitsBeforePositionCS(n, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsBeforePosition(n)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionCSZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCS(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePosition(n)
		return This.FindSplitsBeforePositionCS(n, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPosition(n)
			return This.FindSplitsBeforePosition(n)

		#--

		def FindSplitsBeforePositionZ(n)
			return This.FindSplitsBeforePosition(n)

		def FindSplitsBeforeThisPositionZ(n)
			return This.FindSplitsBeforePosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#==========================================#

	def FindSplitsBeforePositionsCS(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositionsCS(anPos)
		anResult = This.FindManyCS(acSplits, pCaseSensitive)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCS(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositions(anPos)
		return This.FindSplitsBeforePositionsCS(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#--

		def FindSplitsBeforePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeThesePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN Item   #
	#---------------------------------------------#

	def FindSplitsBeforeItemCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsBeforeItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		def FindSplitsBeforeThisItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCS(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItem(pItem)
		return This.FindSplitsBeforeItemCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItem(pItem)
			return This.FindSplitsBeforeItem(pItem)

		#--

		def FindSplitsBeforeItemZ(pItem)
			return This.FindSplitsBeforeItem(pItem)

		def FindSplitsBeforeThisItemZ(pItem)
			return This.FindSplitsBeforeItem(pItem)	

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY Items   #
	#-------------------------------------------#

	def FindSplitsBeforeItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsBeforeItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItems(paItems)
		return This.FindSplitsBeforeItemsCS(paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItems(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeManyItems(paItems)
			return This.FindSplitsBeforeItems(paItems)

		#--

		def FindSplitsBeforeItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeTheseItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		def FindSplitsBeforeManyItemsZ(paItems)
			return This.FindSplitsBeforeItems(paItems)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION   #
	#-------------------------------------------#

	def FindSplitsBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSection(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#--

		def FindSplitsBeforeSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		def FindSplitsBeforeThisSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------#

	def FindSplitsBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIB(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#--

		def FindSplitsBeforeSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		def FindSplitsBeforeThisSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS   #
	#-----------------------------------------#

	def FindSplitsBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSections(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindSplitsBeforeSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeTheseSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsBeforeSectionsIB(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#--

		def FindSplitsBeforeSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeTheseSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN ITEM  #
	#-------------------------------------------------------#

	def FindSplitsAfterCS(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsAfterItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsAfterItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSection(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSections(pItem[2])

			else
				return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfter(pItem)
		return This.FindSplitsAfterCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterZ(pItem)
			return This.FindSplitsAfterCS(pItem, pCaseSensitive)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsAfterPosition(n)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPosition(n)

		#TODO
		# Add FindSplitsAfterPosition(n) to stzSplitter class
		#TODO
		# Add alsos all other similar functions for finding splits

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPosition(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterThisPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsAfterPositions(anPos)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositions(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositions(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#--

		def FindSplitsAfterPositionsZ(anPos)
			return This.FindSplitsAfterPositions(anPos)

		def FindSplitsAfterThesePositionsZ(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositionsZ(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN Item   #
	#---------------------------------------------#

	def FindSplitsAfterItemCS(pItem, pCaseSensitive)

		anPos = This.FindCS(pItem, pCaseSensitive)
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		#--

		def FindSplitsAfterItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		def FindSplitsAfterThisItemCSZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItem(pItem)
		return This.FindSplitsAfterItemCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItem(pItem)
			return This.FindSplitsAfterItem(pItem)

		#--

		def FindSplitsAfterItemZ(pItem)
			return This.FindSplitsAfterItem(pItem)

		def FindSplitsAfterThisItemZ(pItem)
			return This.FindSplitsAfterItem(pItem)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY Items   #
	#-------------------------------------------#

	def FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		anPos = This.FindCS( paItems, pCaseSensitive )
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsAfterItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItems(paItems)
		return This.FindSplitsAfterItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItems(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterManyItems(paItems)
			return This.FindSplitsAfterItems(paItems)

		#--

		def FindSplitsAfterItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterTheseItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		def FindSplitsAfterManyItemsZ(paItems)
			return This.FindSplitsAfterItems(paItems)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION  #
	#-----------------------------------------#

	def FindSplitsAfterSection(n1, n2)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSection(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSection(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#--

		def FindSplitsAfterSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		def FindSplitsAfterThisSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------#

	def FindSplitsAfterSectionIB(n1, n2)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSectionIB(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIB(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		#--

		def FindSplitsAfterSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		def FindSplitsAfterThisSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS   #
	#----------------------------------------#

	def FindSplitsAfterSections(paSections)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSections(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#--

		def FindSplitsAfterSectionsZ(paSections)
			return This.FindSplitsAfterSections(paSections)

		def FindSplitsAfterTheseSectionsZ(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------#

	def FindSplitsAfterSectionsIB(paSections)

		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsAfterSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#--

		def FindSplitsAfterSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		def FindSplitsAfterTheseSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR Items  #
	#======================================================#

	def FindSplitsBetweenCS(pItem1, pItem2, pCaseSensitive)
		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

		anResult = StzSplitterQ( This.NumberOfItems() ).
			   FindSplitsBetweenSections(aSections)
			
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSZ(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetween(pItem1, pItem2)
		return This.FindSplitsBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenZ(pItem1, pItem2)
			return This.FindSplitsBetween(pItem1, pItem2)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	def FindSplitsBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

		anResult = StzSplitterQ( This.NumberOfItems() ).
			   FindSplitsBetweenSections(aSections)
	
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSIBZ(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIB(pItem1, pItem2)
		return This.FindSplitsBetweenCSIB(pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenIBZ(pItem1, pItem2)
			return This.FindSplitsBetweenIB(pItem1, pItem2)

		#>

	  #----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS  #
	#----------------------------------------#

	def FindSplitsBetweenPositions(n1, n2)
		This.FindSplitsAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositions(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#--

		def FindSplitsBetweenPositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		def FindSplitsBetweenThesePositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#>
		
	  #------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------#

	def FindSplitsBetweenPositionsIB(n1, n2)
		This.FindSplitsAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#--

		def FindSplitsBetweenPositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		def FindSplitsBetweenThesePositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO Items  #
	#-----------------------------------------#

	def FindSplitsBetweenItemsCS(paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		anResult = This.FindSplitsBetweenSections(aSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		#--

		def FindSplitsBetweenItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		def FindSplitsBetweenTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenItems(paItems)
		return This.FindSplitsBetweenItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItems(paItems)
			return This.FindSplitsBetweenItems(paItems)

		#--

		def FindSplitsBetweenItemsZ(paItems)
			return This.FindSplitsBetweenItems(paItems)

		def FindSplitsBetweenTheseItemsZ(paItems)
			return This.FindSplitsBetweenItems(paItems)

		#>

	  #---------------------------------#
	 #    FINDING SPLITS TO N PARTS    #
	#=================================#

	def FindSplitsToNParts(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).FindSplitsToNParts(n)
		return anResult

		def FindSplitsToNPartsZ(n)
			return This.FindSplitsToNParts(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N Items   #
	#--------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindSplitsToPartsOfNItems(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).
				FindSplitsToPartsOfExactlyNPositions(n)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItems(n)
			return This.FindSplitsToPartsOfNItems(n)

		#--

		def FindSplitsToPartsOfNItemsZ(n)
			return This.FindSplitsToPartsOfNItems(n)

		def FindSplitsToPartsOfExactlyNItemsZ(n)
			return This.FindSplitsToPartsOfNItems(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF N Items -- EXTENDED   #
	#----------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindSplitsToPartsOfNItemsXT(n)
		anResult = StzSplitterQ( This.NumberOfItems() ).
				FindSplitsToPartsOfNPositionsXT(n)

		return anResult

		def FindSplitsToPartsOfNItemsXTZ(n)
			return This.FindSplitsToPartsOfNItemsXT(n)

	  #-------------------------------------------#
	 #   FINDING SPLITS UNDER A GIVEN CONDTION   #
	#===========================================#

	def FindSplitsW(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindSplitsBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindSplitsAfterW(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsWZ(pcCondition)
			return This.FindSplitsWZ(pcCondition)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS UNDER A GIVEN CONDTION -- XT/EXTENDED  #
	#---------------------------------------------------------#

	def FindSplitsWXT(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindSplitsAtWXT(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindSplitsAtWXT(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindSplitsBeforeWXT(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindSplitsAfterWXT(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWXTZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsWXTZ(pcCondition)
			return This.FindSplitsWXTZ(pcCondition)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT A POSITION UNDER A GIVEN CONDTION  #
	#========================================================#

	def FindSplitsAtW(pcCondition)
		
		anPos = This.FindW(pcCondition)
		anResult = This.FindSplitsAtPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWZ(pcCondition)
			return This.FindSplitsAtW(pcCondition)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS AT A POSITION UNDER A GIVEN CONDTION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def FindSplitsAtWXT(pcCondition)
		
		anPos = This.FindWXT(pcCondition)
		anResult = This.FindSplitsAtPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWXTZ(pcCondition)
			return This.FindSplitsAtWXT(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN CONDTION   #
	#============================================#

	def FindSplitsBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		anResult = This.FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeWZ(pcCondition)
			return This.FindSplitsBeforeW(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN CONDTION -- WXT/EXTENDED  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		anResult = This.FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeWXTZ(pcCondition)
			return This.FindSplitsBeforeWXT(pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN CONDTION   #
	#===========================================#

	def FindSplitsAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		anResult = This.FindSplitsAfterPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterWZ(pcCondition)
			return This.FindSplitsAfterW(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------#

	def FindSplitsAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		anResult = This.FindSplitsAfterPositions(anPos)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterWXTZ(pcCondition)
			return This.FindSplitsAfterWXT(pcCondition)

		#>

	  #==================================================#
	 #   FINDING THE SPLITS AS SECTIONS -- ZZ/EXTENDED  #
	#==================================================#

	def FindSplitsCSXTZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindSplitsAtItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindSplitsAtItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindSplitsBeforeItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindSplitsAfterItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindSplitsAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindSplitsBetweenCSZZ(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositionsZZ(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.FindSplitsBetweenItemsCSZZ(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNPartsZZ(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindSplitsToPartsOfNItemsZZ(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtWZZ(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindSplitsBeforeWZZ(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindSplitsAfterWZZ(pItem[2])

			else
				return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsCSXT(pItem, pCaseSensitive)
			return This.FindSplitsAsSectionsCSXTZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXTZZ(pItem)
		return This.FindSplitsCSXTZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsAsSectionsXT(pItem)
			return This.FindSplitsAsSectionsXTZZ(pItem)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN Item  #
	#==================================================================#

	def FindSplitsAtCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsAtItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsAtItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pItem[2])

			else
				return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
			ok

		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtZZ(pItem)
		return This.FindSplitsAtCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSections(pItem)
			return This.FindSplitsAtCSZZ(pSubStr)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN POSITION   #
	#======================================================#

	def FindSplitsAtPositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT isNumber(n)
				StzRaise("Incorrect pram type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAtPosition(n)
		aResult = This.FindManyAsSections(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAtPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionZZ(n)
		return This.FindSplitsAtPositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSections(n)
			return This.FindSplitsAtPositionZZ(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY POSITIONS   #
	#----------------------------------------------------#

	def FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.SplitsAtPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAtPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAtManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtPositionsZZ(anPos)
		return This.FindSplitsAtPositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#--

		def FindSplitsAtPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtThesePositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN Item   #
	#=======================================================#

	def FindSplitsAtItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindSplitsAtItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItemZZ(pItem)
		return This.FindSplitsAtItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsZZ(pItem)
			return This.FindSplitsCSZZ(pItem, TRUE)

		def FindSplitsAtThisItemZZ(pItem)
			return This.FindSplitsAtThisItemCSZZ(pItem, TRUE)
		#--

		def FindSplitsAtItemAsSectionsZZ(pItem)
			return This.FindSplitsAtItemAsSectionsCSZZ(pItem, TRUE)

		def FindSplitsAsSections(pItem)
			return This.FindSplitsAsSectionsCS(pItem, TRUE)

		def FindSplitsAtThisItemAsSections(pItem)
			return This.FindSplitsAtThisItemAsSectionsCS(pItem, TRUE)

		#>


	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT GIVEN Items   #
	#------------------------------------------------------#

	def FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsAtItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAtManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAtItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtItemsZZ(paItems)
		return This.FindSplitsAtItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseItemsZZ(paItems)
			return This.FindSplitsAtItemsZZ(paItems)
	
		def FindSplitsAtManyItemsZZ(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		#--

		def FindSplitsAtItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		def FindSplitsAtTheseItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		def FindSplitsAtManyItemsAsSections(paItems)
			return This.FindSplitsAtItemsZZ(paItems)

		#>

	  #-----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION   #
	#=====================================================#

	def FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAtSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionZZ(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		def FindSplitsAtThisSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be numbers.")
			ok
		ok

		acSplits = This.SplitsAtSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCSIB(n1, n2, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAtSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAtThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.SplitAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAtSectionIBZZ(n1, n2)

		def FindSplitsAtThisSectionAsSectionsIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY SECTIONS   #
	#---------------------------------------------------#

	def FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsAtSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAtSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAtTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSectionsZZ(paSections, pCaseSensitive)
		return This.FindSplitsAtSectionsCSZZ(paSections, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsZZ(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#--

		def FindSplitsAtSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		def FindSplitsAtTheseSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN ITEM   #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		else

			#-- Case when named params are provided

			if Q(pItem).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pItem[2])
	
			but Q(pItem).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pItem[2])

			but Q(pItem).IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsBeforeItemCSZZ(pItem[2], pCaseSensitive)
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsBeforeItemsCSZZ(pItem[2], pCaseSensitive)

			but Q(pItem).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pItem[2])
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pItem[2])

			else
				return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeZZ(pItem)
		return This.FindSplitsBeforeCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSections(pItem)
			return This.FindSplitsBeforeZZ(pItem)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsBeforePositionCSZZ(n, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsBeforePosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsBeforePositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		def FindSplitsBeforeThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsBeforePositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionZZ(n)
		return This.FindSplitsBeforePositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionZZ(n)
			return This.FindSplitsBeforePositionZZ(n)

		#--

		def FindSplitsBeforePositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		def FindSplitsBeforeThisPositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforePositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsBeforePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsBeforeManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforePositionsZZ(anPos)
		return This.FindSplitsBeforePositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#--

		def FindSplitsBeforePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeThesePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN Item   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBeforeItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsBeforeItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsBeforeThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsBeforeItemCSZZ(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItemZZ(pItem)
		return This.FindSplitsBeforeItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisItemZZ(pItem)
			return This.FindSplitsBeforeItem(pItem)

		#--

		def FindSplitsBeforeItemAsSections(pItem)
			return This.FindSplitsBeforeItemZZ(pItem)

		def FindSplitsBeforeThisItemAsSections(pItem)
			return This.FindSplitsBeforeItemZZ(pItem)	

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY Items   #
	#---------------------------------------------------------#

	def FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBeforeItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsBeforeItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBeforeManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBeforeItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeItemsZZ(paItems)
		return This.FindSplitsBeforeItemsCSZZ(paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseItemsZZ(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeManyItemsZZ(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		#--

		def FindSplitsBeforeItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeTheseItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		def FindSplitsBeforeManyItemsAsSections(paItems)
			return This.FindSplitsBeforeItemsZZ(paItems)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionZZ(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#----------------------------------------------------------------------------#

	def FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBeforeThisSectionAsSectionsCsIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionIBZZ(n1, n2)
		return This.FindSplitsBeforeSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIBZZ(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok

		ok

		acSplits = This.SplitsBeforeSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSZZ(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.SplitBeforeSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsZZ(paSections)
		return This.FindSplitsBeforeSectionsCSZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsZZ(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsAsSections(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------------------#

	def FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsBeforeSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsBeforeSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsBeforeManySectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsBeforeSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSectionsIBZZ(paSections)
		return This.FindSplitsBeforeSectionsCSIBZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN ITEM  #
	#---------------------------------------------------------------------#

	def FindSplitsAfterCSZZ(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		else

			#-- Case when named params are provided

			if Q(pItem).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPositionZZ(pItem[2])
	
			but Q(pItem).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pItem[2])

			but Q(pItem).IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindSplitsAfterItemCSZZ(pItem[2], pCaseSensitive)
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindSplitsAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but Q(pItem).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pItem[2])

			but Q(pItem).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pItem[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pItem).IsListOfNumbers()
				return This.FindSplitsAfterPositionsZZ(pItem)

			but Q(pItem).IsListOfStrings()
				return This.FindSplitsAfterItemsZZ(pItem)

			but Q(pItem).IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSectionsZZ(pItem)

			else
				return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterZZ(pItem)
		return This.FindSplitsAfterCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSections(pItem)
			return This.FindSplitsAfterCSZZ(pItem, pCaseSensitive)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

		ok

		acSplits = This.SplitsAfterPosition(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionCSZZ(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		def FindSplitsAfterThisPositionAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsAfterPositionCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionZZ(n)
		return This.FindSplitsAfterPositionCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionZZ(n)
			return This.FindSplitsAfterPositionZZ(n)

		def FindSplitsAfterThisPositionAsSections(n)
			return This.FindSplitsAfterPositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok
		ok

		acSplits = This.plitsAfterPositions(anPos)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#--

		def FindSplitsAfterPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterThesePositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterThesePositionsCSZZ(anPos, pCaseSensitive)

		def FindSplitsAfterManyPositionsAsSectionsCS(anPos, pCaseSensitive)
			return This.FindSplitsAfterManyPositionsCSZZ(anPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterPositionsZZ(anPos)
		return This.FindSplitsAfterPositionsCSZZ(anPos, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsZZ(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsZZ(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#--

		def FindSplitsAfterPositionsAsSections(anPos)
			return This.FindSplitsAfterPositionsZZ(anPos)

		def FindSplitsAfterThesePositionsAsSections(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsAsSections(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN Item   #
	#-----------------------------------------------------------#

	def FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAfterItemCS(pItem, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindSplitsAfterItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		def FindSplitsAfterThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindSplitsAfterItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItemZZ(pItem)
		return This.FindSplitsAfterItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisItemZZ(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		#--

		def FindSplitsAfterItemAsSections(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		def FindSplitsAfterThisItemAsSections(pItem)
			return This.FindSplitsAfterItemZZ(pItem)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY Items   #
	#---------------------------------------------------------#

	def FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsAfterItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsAfterItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsAfterManyItemsAsSectionsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsAfterItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterItemsZZ(paItems)
		return This.FindSplitsAfterItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseItemsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterManyItemsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		#--

		def FindSplitsAfterItemsAsSections(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterTheseItemsAsSections(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		def FindSplitsAfterManyItemsAsSectionsZZ(paItems)
			return This.FindSplitsAfterItemsZZ(paItems)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION   #
	#--------------------------------------------------------#

	def FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSection(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionZZ(n1, n2)
		return This.FindSplitsAfterSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionZZ(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT @BothAreNumbers(n1, n2)
				StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionIB(n1, n2)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsAfterSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsAfterThisSectionAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsAfterSectionCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionIBZZ(n1, n2)
		return This.FindSplitsAfterSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIBZZ(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS   #
	#------------------------------------------------------#

	def FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSections(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCS(paSections, pCaseSensitive)
			return This.FindSplitsAfterTheseSectionsCSZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSectionsZZ(paSections)
		return This.FindSplitsAfterSectionsCSZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsZZ(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSections(paSections)
			return This.FindSplitsAfterSectionsZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSections(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------#

	def FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
			ok
		ok

		acSplits = This.SplitsAfterSectionsIB(paSections)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

		return aResult


		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsCSIBZZ(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#--

		def FindSplitsAfterSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		def FindSplitsAfterTheseSectionsAsSectionsCSIB(paSections, pCaseSensitive)
			return This.FindSplitsAfterSectionsCSIBZZ(paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESNSITIVITY

	def FindSplitsAfterSectionsIBZZ(paSections)
		return This.FindSplitsAfterSectionsCSIBZZ(paSections, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIBZZ(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR Items  #
	#====================================================================#

	def FindSplitsBetweenCSZZ(pItem1, pItem2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
				StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
			ok
		ok

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCS(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenZZ(pItem1, pItem2)
		return This.FindSplitsBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSections(pItem1, pItem2)
			return This.FindSplitsBetweenZZ(pItem1, pItem2)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------------------#

	def FindSplitsBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		aResult = This.FindSplitsBetweenSectionsCSZZ(aSections, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCSIB(pItem1, pItem2, pCaseSensitive)
			return This.FindSplitsBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIBZZ(pItem1, pItem2)
		return This.FindSplitsBetweenCSIBZZ(pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsIB(pItem1, pItem2)
			return This.FindSplitsBetweenIBZZ(pItem1, pItem2)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS  #
	#------------------------------------------------------#

	def FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCS(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsZZ(n1, n2)
		return This.FindSplitsAtSectionCSZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsZZ(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsCSIBZZ(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#--

		def FindSplitsBetweenPositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		def FindSplitsBetweenThesePositionsAsSectionsCSIB(n1, n2, pCaseSensitive)
			return This.FindSplitsBetweenPositionsCSIBZZ(n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenPositionsIBZZ(n1, n2)
		return This.FindSplitsAtSectionCSIBZZ(n1, n2, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIBZZ(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO Items  #
	#-------------------------------------------------------#

	def FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSplits = This.SplitsBetweenItemsCS(paItems, pCaseSensitive)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindSplitsBetweenItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		def FindSplitsBetweenTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindSplitsBetweenItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenItemsZZ(paItems)
		return This.FindSplitsBetweenItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseItemsZZ(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		#--

		def FindSplitsBetweenItemsAsSections(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		def FindSplitsBetweenTheseItemsAsSections(paItems)
			return This.FindSplitsBetweenItemsZZ(paItems)

		#>

	  #-----------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) TO N PARTS    #
	#===============================================#

	def FindSplitsToNPartsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToNPartsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		def FindSplitsToNPartsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToNPartsCSZZ(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToNPartsZZ(n)
		return This.FindSplitsToNPartsCSZZ(n, TRUE)

		def FindSplitsToNPartsAsSections(n)
			return This.FindSplitsToNPartsZZ(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N Items   #
	#--------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNItemsZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItemsCSZZ(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		#--

		def FindSplitsToPartsOfNItemsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		def FindSplitsToPartsOfExactlyNItemsAsSectionsCS(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsToPartsOfNItemsZZ(n)
		return This.FindSplitsToPartsOfNItemsCSZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNItemsZZ(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		#--

		def FindSplitsToPartsOfNItemsAsSections(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		def FindSplitsToPartsOfExactlyNItemsAsSections(n)
			return This.FindSplitsToPartsOfNItemsZZ(n)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) TO PARTS OF N Items -- EXTENDED   #
	#------------------------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindSplitsToPartsOfNItemsCSXTZZ(n, pCaseSensitive)
		if This.IsEmppty()
			return []
		ok

		if CheckParams()
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok
		ok

		acSplits = This.SplitsToPartsOfNItemsXTZZ(n)
		aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNItemsAsSectionsCSXT(n, pCaseSensitive)
			return This.FindSplitsToPartsOfNItemsCSXTZZ(n, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY()

	def FindSplitsToPartsOfNItemsXTZZ(n)
		return This.FindSplitsToPartsOfNItemsCSXTZZ(n, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNItemsAsSectionsXT(n)
			return This.FindSplitsToPartsOfNItemsXTZZ(n)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) UNDER A GIVEN CONDTION   #
	#==========================================================#

	def FindSplitsWCSZZ(pcCondition, pCaseSensitive)

		if This.IsEmpty()
			return []
		ok

		if isList(pcCondition)
			oCondition = StzStringQ(pcCondition)
			if oCondition.IsWhereNamedParam()
				return This.FindSplitsAtWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsAtNamedParam()
				return This.FindSplitsAtWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsBeforeNamedParam()
				return This.FindSplitsBeforeWCSZZ(pcCondition[2], pCaseSensitive)

			but oCondition.IsAfterNamedParam()
				return This.FindSplitsAfterWCSZZ(pcCondition[2], pCaseSensitive)

			ok
		
		else

			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsWZZ(pcCondition)
		return This.FindSplitsWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsW(pcCondition)
			return This.FindSplitsWZZ(pcCondition)

		#>

	  #-------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDTION   #
	#-------------------------------------------------------#

	def FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().TheseBoundsRemoved( "{","}" )

		if Q(pcCondition).ContainsCS("@Item", :CS = FALSE)

			aSections = This.FindItemsAsSectionsWCS(pcCondition, pCaseSensitive)
			aResult = This.FindSplitsAtSectionsCSZZ(aSections, pCaseSensitive)

			/* TODO: should we resolve it like this:

			acSplits = This.SplitsAtWCSZZ(pcCondition, pCaseSensitive)
			aResult = This.FindManyAsSectionsCS(acSplits, pCaseSensitive)

			*/

		else

			anPos = This.FindWCS(pcCondition, pCaseSensitive)
			aResult = This.FindSplitsAtPositionsCSZZ(anPos, pCaseSensitive)

		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectiosnWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAtWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtWZZ(pcCondition)
		return This.FindSplitsAtWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectiosnW(pcCondition)
			return This.FindSplitsAtWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok

		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsCS("@Item",  :CaseSensitive = FALSE)
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)

		else
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)
		ok

		aResult = This.FindSplitsBeforePositionsCSZZ(anPos, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsBeforeWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeWZZ(pcCondition)
		return This.FindSplitsBeforeWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsW(pcCondition)
			return This.FindSplitsBeforeWZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) AFTER A GIVEN CONDTION   #
	#----------------------------------------------------------#

	def FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
				pcCondition = pcCondition[2]
			ok
	
			if NOT isString(pcCondition)
				StzRaise("Incorrect param type! pcCondition must be a string.")
			ok
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsCS("@Item",  :CaseSensitive = FALSE)
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)

		else
			anPos = This.FindItemsWCS(pcCondition, pCaseSensitive)
		ok

		aResult = This.FindSplitsAfterPositionsCSZZ(anPos, pCaseSensitive)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsWCS(pcCondition, pCaseSensitive)
			return This.FindSplitsAfterWCSZZ(pcCondition, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterWZZ(pcCondition)
		return This.FindSplitsAfterWCSZZ(pcCondition, TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsW(pcCondition)
			return This.FindSplitsAfterWZZ(pcCondition)

		#>

	  #===========================#
	 #   FINDING THE NTH SPLIT   #
	#===========================#

	def FindNthSplitCSXT(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pItem[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindNthSplitAtItemCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindNthSplitAtItemsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pItem[2], pCaseSensitive)

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionCS(n, pItem[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindNthSplitBeforeItemCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsCS(n, pItem[2], pCaseSensitive)

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionCS(n, pItem[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindNthSplitAfterItemCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindNthSplitAfterItemsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsCS(n, pItem[2], pCaseSensitive)

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindNthSplitBetweenCS(n, pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsCS(n, pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenItemsNamedParam()
				return This.FindNthSplitBetweenItemsCS(n, pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindNthSplitToPartsOfNItemsCS(n, pItem[2], pCaseSensitive)

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtWCS(n, pItem[2], pCaseSensitive)

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeWCS(n, pItem[2], pCaseSensitive)

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterWCS(n, pItem[2], pCaseSensitive)

			else
				return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitCSXTZ(pItem, pCaseSensitive)
			return This.FindNthSplitCSXT(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXT(n, pItem)
		return This.FindNthSplitCSXT(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitXTZ(n, pItem)
			return This.FindNthSplitXT(n, pItem)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN Item  #
	#=======================================================#

	def FindNthSplitAtCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionCS(n, pItem[2], pCaseSensitive)
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitAtItemCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitAtItemsCS(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionCS(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsCS(n, pItem[2], pCaseSensitive)

			else
				return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtCS(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAt(n, pItem)
		return This.FindNthSplitAtCS(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtZ(n, pItem)
			return This.FindNthSplitAtCS(n, pSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN POSITION   #
	#===========================================#

	#NOTE
	# Case sensitivty has no added value here,
	# since the split is based on position
	# and there is no use of ...CS() functions
	# in the implementatin

	def FindNthSplitAtPosition(n, nPos) 
		    
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isNumber(n, nPos) and (n = 1 or n = 2) )
				StzRaise("Incorrect pram type! n must be a number equal to 1 or 2.")
				# Because after splitting the string at a given position, there will
				# be only two splits, right?
			ok

		ok

		nResult = 0

		if n = 1
			nResult = 1

		but n = 2
			nResult + (nPos + 1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPosition(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtThisPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY POSITIONS   #
	#-----------------------------------------#

	def FindNthSplitAtPositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()

			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
				StzRaise("Incorrect param type! anPos must be a list of numbers.")
			ok

		ok

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtPositions(anPos)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nResult += ( nLen + 1 )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#--

		def FindNthSplitAtPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtThesePositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#>

	  #---------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN ITEM   #
	#=======================================#

	def FindNthSplitAtItemCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT isString(pItem)
				StzRaise("Incorrect param type! pItem must be a string.")
			ok
		ok

		if n = 1
			return 1
		ok

		nLenSubStr = StzStringQ(pItem).NumberOfItems()
		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitCS(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCS(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAtItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitCSZ(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCSZ(n, pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItem(n, pItem)
		return This.FindNthSplitAtItemCS(n, pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplit(n, pItem)
			return This.FindNthSplitCS(n, pItem, TRUE)

		def FindNthSplitAtThisItem(n, pItem)
			return This.FindNthSplitAtThisItemCS(n, pItem, TRUE)
		#--

		def FindNthSplitAtItemZ(n, pItem)
			return This.FindNthSplitAtItemCS(n, pItem, TRUE)

		def FindNthSplitZ(n, pItem)
			return This.FindNthSplitCS(n, pItem, TRUE)

		def FindNthSplitAtThisItemZ(pItem)
			return This.FindNthSplitAtThisItemCS(n, pItem, TRUE)

		#>

	  #--------------------------------------#
	 #   FINDING NTH SPLIT AT GIVEN ITEMS   #
	#--------------------------------------#

	def FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
	
			if NOT ( isNumber(n) and n > 0 )
				StzRaise("Incorrect param type! n must be a number greater then 0.")
			ok

			if NOT (isList(paItems) and Q(paItems).IsListOfStrings())
				StzRaise("Incorrect param type! paItems must be a list of strings.")
			ok
		ok

		#>

		if n = 1
			return 1
		ok

		acSplits = This.SplitsAtItemCS(pItem, pCaseSensitive)
		
		for i = 1 to n-1
			nLen = StzStringQ(acSplits[i]).NumberOfItems()
			nLenSubStr = StzStringQ(paItems[i]).NumberOfItems()
			nResult += ( nLen + nLenSubStr )
		next

		return nResult


		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAtItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItems(n, paItems)
		return This.FindNthSplitAtItemsCS(n, paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItems(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)
	
		def FindNthSplitAtManyItems(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		#--

		def FindNthSplitAtItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		def FindNthSplitAtTheseItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		def FindNthSplitAtManyItemsZ(n, paItems)
			return This.FindNthSplitAtItems(n, paItems)

		#>

	  #------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION   #
	#==========================================#

	def FindNthSplitAtSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if CheckParams()
			if NOT @AllAreNumbers([n, n1, n2 ])
				StzRaise("Incorrect params type! n, n1 and n2 must all be numbers.")
			ok

			if NOT ( n = 1 or n = 2 )
				StzRaise("Incorrect values ! n must be equal to 1 or 2.")
				# Since the split make two parts only.
			ok
		ok

		if n = 1
			return 1
		
		but n = 2
			return n2 + 1
		ok
		
		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSection(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#--

		def FindNthSplitAtSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		def FindNthSplitAtThisSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------#

	def FindNthSplitAtSectionIB(n, n1, n2)
		nResult = This.FindNthSplitAtSection(n, n1, n2)
		if nResult > 1
			nResult - (n2 - n1)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIB(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#--

		def FindNthSplitAtSectionIBZ(n, n1, n2)
			return This.FindNthSplitAtSectionIB(n, n1, n2)

		def FindNthSplitAtThisSectionIBZ(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#>

	  #----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY SECTIONS   #
	#----------------------------------------#

	def FindNthSplitAtSections(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		StzRaise("Feature not yet implemented!")

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSections(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#--

		def FindNthSplitAtSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		def FindNthSplitAtTheseSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN ITEM   #
	#------------------------------------------------------------#

	def FindNthSplitBeforeCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePosition(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositions(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitBeforeItemCS(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitBeforeItemsCS(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSection(n, pItem[2])
		
			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSections(n, pItem[2])

			else
				return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBefore(n, pItem)
		return This.FindNthSplitBeforeCS(n, pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeZ(n, pItem)
			return This.FindNthSplitBefore(n, pItem)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitBeforePosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePosition(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPosition(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#--

		def FindNthSplitBeforePositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		def FindNthSplitBeforeThisPositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitBeforePositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#--

		def FindNthSplitBeforePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeThesePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN Item   #
	#------------------------------------------------#

	def FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitBeforeThisItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCS(n, pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItem(n, pItem)
		return This.FindNthSplitBeforeItemCS(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItem(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		#--

		def FindNthSplitBeforeItemZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		def FindNthSplitBeforeThisItemZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)	

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY ITEMS   #
	#-----------------------------------------#

	def FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindManyCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItems(n, paItems)
		return This.FindNthSplitBeforeItemsCS(n, paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItems(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeManyItems(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		#--

		def FindNthSplitBeforeItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeTheseItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		def FindNthSplitBeforeManyItemsZ(n, paItems)
			return This.FindNthSplitBeforeItems(n, paItems)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION   #
	#----------------------------------------------#

	def FindNthSplitBeforeSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSection(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSection(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		def FindNthSplitBeforeThisSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-----------------------------------------------------------------#

	def FindNthSplitBeforeSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionIB(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		def FindNthSplitBeforeThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SECTIONS   #
	#--------------------------------------------#

	def FindNthSplitBeforeSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSections(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSections(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySections(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#--

		def FindNthSplitBeforeSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeTheseSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySectionsZ(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINING NTH SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIB(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIB(paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#--

		def FindNthSplitBeforeSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN ITEM  #
	#-----------------------------------------#

	def FindNthSplitAfterCS(n, pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPosition(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositions(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitAfterItemCS(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitAfterItemsCS(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSection(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSections(n, pItem[2])

			else
				return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfter(n, pItem)
		return This.FindNthSplitAfterCS(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterZ(n, pItem)
			return This.FindNthSplitAfterCS(n, pItem, pCaseSensitive)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitAfterPosition(n, nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPosition(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterThisPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitAfterPositions(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositions(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositions(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#--

		def FindNthSplitAfterPositionsZ(n, anPos)
			return This.FindNthSplitAfterPositions(n, anPos)

		def FindNthSplitAfterThesePositionsZ(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositionsZ(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN ITEM   #
	#-------------------------------------------#

	def FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAfterItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		def FindNthSplitAfterThisItemCSZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCS(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItem(n, pItem)
		return This.FindNthSplitAfterItemCS(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItem(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		#--

		def FindNthSplitAfterItemZ(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		def FindNthSplitAfterThisItemZ(n, pItem)
			return This.FindNthSplitAfterItem(n, pItem)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY Items   #
	#----------------------------------------------#

	def FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		anPos = This.FindManyCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAfterItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItems(n, paItems)
		return This.FindNthSplitAfterItemsCS(n, paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItems(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterManyItems(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		#--

		def FindNthSplitAfterItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterTheseItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		def FindNthSplitAfterManyItemsZ(n, paItems)
			return This.FindNthSplitAfterItems(n, paItems)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION  #
	#--------------------------------------------#

	def FindNthSplitAfterSection(n, n1, n2)

		if NOT @BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSection(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSection(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#--

		def FindNthSplitAfterSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		def FindNthSplitAfterThisSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindNthSplitAfterSectionIB(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionIB(n, n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		#--

		def FindNthSplitAfterSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		def FindNthSplitAfterThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)


		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS   #
	#-------------------------------------------#

	def FindNthSplitAfterSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSections(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#--

		def FindNthSplitAfterSectionsZ(n, paSections)
			return This.FindNthSplitAfterSections(n, paSections)

		def FindNthSplitAfterTheseSectionsZ(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterSectionsIB(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#--

		def FindNthSplitAfterSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		def FindNthSplitAfterTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR Items  #
	#=========================================================#

	def FindNthSplitBetweenCS(n, pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

		nResult = StzSplitterQ( This.NumberOfItems() ).
			   FindNthSplitBetweenSections(n, aSections)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSZ(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCS(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetween(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCS(n, pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenZ(n, pItem1, pItem2)
			return This.FindNthSplitBetween(n, pItem1, pItem2)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIB(n, pItem1, pItem2, pCaseSensitive)

		anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
		anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

		aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
		anFirstBounds  = aListOfBounds[1]
		anSecondBounds = aListOfBounds[2]

		nLen = len(anFirstBounds)
		for i = 1 to nLen
			anFirstBounds[i]--
			anSecondBounds[i]++
		next

		aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

		nResult = StzSplitterQ( This.NumberOfItems() ).
			   FindNthSplitBetweenSections(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSIBZ(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIB(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIB(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCSIB(n, pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenIBZ(n, pItem1, pItem2)
			return This.FindNthSplitBetweenIB(n, pItem1, pItem2)

		#>

	  #-------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS  #
	#-------------------------------------------#

	def FindNthSplitBetweenPositions(n, n1, n2)
		This.FindNthSplitAtSection(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositions(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		def FindNthSplitBetweenThesePositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#>
		
	  #---------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIB(n, n1, n2)
		This.FindNthSplitAtSectionIB(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		def FindNthSplitBetweenThesePositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO Items  #
	#--------------------------------------------#

	def FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		nResult = This.FindNthSplitBetweenSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBetweenItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		def FindNthSplitBetweenTheseItemsCSZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCS(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenItems(n, paItems)
		return This.FindNthSplitBetweenItemsCS(n, paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItems(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		#--

		def FindNthSplitBetweenItemsZ(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		def FindNthSplitBetweenTheseItemsZ(n, paItems)
			return This.FindNthSplitBetweenItems(n, paItems)

		#>

	  #------------------------------------#
	 #    FINDING NTH SPLIT TO N PARTS    #
	#====================================#

	def FindNthSplitToNParts(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitToNParts(n, nPos)
		return nResult

		def FindNthSplitToNPartsZ(n, nPos)
			return This.FindNthSplitToNParts(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N Items   #
	#-----------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindNthSplitToPartsOfNItems(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfExactlyNPositions(n, nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNItems(n, nPos)
			return This.FindNthSplitToPartsOfNItems(n, nPos)

		#--

		def FindNthSplitToPartsOfNItemsZ(n, nPos)
			return This.FindNthSplitToPartsOfNItems(n, nPos)

		def FindNthSplitToPartsOfExactlyNItemsZ(n, nPos)
			return This.FindNthSplitToPartsOfNItems(n, nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF N Items -- EXTENDED   #
	#-------------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindNthSplitToPartsOfNItemsXT(n, nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfNPositionsXT(n, nPos)

		return nResult

		def FindNthSplitToPartsOfNItemsXTZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsXT(n, nPos)

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT UNDER A GIVEN CONDTION   #
	#==============================================#

	def FindNthSplitW(n, pcCondition)
		/*
		? StzSplitterQ(1:5).FindNthSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindNthSplitBeforeW(n, pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindNthSplitAfterW(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitWZ(n, pcCondition)
			return This.FindNthSplitWZ(n, pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT UNDER A GIVEN CONDTION -- WXT/EXTENDED  #
	#-------------------------------------------------------------#

	def FindNthSplitWXT(n, pcCondition)
		/*
		? StzSplitterQ(1:5).FindNthSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindNthSplitAtWXT(n, pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindNthSplitAtWXT(n, pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindNthSplitBeforeWXT(n, pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindNthSplitAfterWXT(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWXTZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitWXTZ(n, pcCondition)
			return This.FindNthSplitWXTZ(n, pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINSING NTH SPLIT AT A GIVEN CONDTION   #
	#===========================================#

	def FindNthSplitAtW(n, pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindNthSplitAtPositionsZ(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtWZ(n, pcCondition)
			return This.FindNthSplitAtW(n, pcCondition)

		#>

	  #----------------------------------------------------------#
	 #   FINSING NTH SPLIT AT A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------#

	def FindNthSplitAtWXT(n, pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindNthSplitAtPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtWXTZ(n, pcCondition)
			return This.FindNthSplitAtWXT(n, pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN CONDTION   #
	#===============================================#

	def FindNthSplitBeforeW(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeWZ(n, pcCondition)
			return This.FindNthSplitBeforeW(n, pcCondition)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN CONDTION -- WXT/EXTENSION  #
	#---------------------------------------------------------------#

	def FindNthSplitBeforeWXT(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeWXTZ(n, pcCondition)
			return This.FindNthSplitBeforeWXT(n, pcCondition)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN CONDTION   #
	#==============================================#

	def FindNthSplitAfterW(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindNthSplitAfterPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterWZ(pcCondition)
			return This.FindNthSplitAfterW(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN CONDTION  -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterWXT(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindNthSplitAfterPositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterWXTZ(pcCondition)
			return This.FindNthSplitAfterWXT(pcCondition)

		#>

	  #====================================================#
	 #   FINDING THE NTH SPLIT AS SECTION -- ZZ/EXTENDED  #
	#====================================================#

	def FindNthSplitCSXTZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCSZZ(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindNthSplitAtItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindNthSplitAtItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindNthSplitBeforeItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionZZ(n, pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindNthSplitAfterItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindNthSplitAfterItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindNthSplitBetweenCSZZ(n, pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsZZ(n, pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.FindNthSplitBetweenItemsCSZZ(n, pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsZZ(n, pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindNthSplitToPartsOfNItemsZZ(n, pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterWZZ(n, pItem[2])

			else
				return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionCSXT(n, pItem, pCaseSensitive)
			return This.FindNthSplitCSXTZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXTZZ(n, pItem)
		return This.FindNthSplitCSXTXT(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionXT(n, pItem)
			return This.FindNthSplitXTZZ(n, pItem)

		#>

	  #----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#====================================================#

	def FindNthSplitAtCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitAtItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitAtItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pItem[2])

			else
				return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAtCSZZ(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtZZ(n, pItem)
		return This.FindNthSplitAtCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSection(n, pItem)
			return This.FindNthSplitAtCSZZ(n, pSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#========================================================#

	def FindNthSplitAtPositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPositionAsSection(n, nPos)
			return This.FindNthSplitAtPositionZZ(n, nPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-----------------------------------------------------#

	def FindNthSplitAtPositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#--

		def FindNthSplitAtPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#>

	  #---------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN ITEM  #
	#===================================================#

	def FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindAsSectionsCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindNthSplitAtItemCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItemZZ(pItem)
		return This.FindNthSplitAtItemCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, TRUE)

		def FindNthSplitAtThisItemZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, TRUE)
		#--

		def FindNthSplitAtItemAsSectionZZ(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, TRUE)

		def FindNthSplitAsSection(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, TRUE)

		def FindNthSplitAtThisItemAsSection(pItem)
			return This.FindNthSplitAtItemZZ(n, pItem, TRUE)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTIONS) AT GIVEN Items  #
	#--------------------------------------------------------#

	def FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAtItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtTheseItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAtManyItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAtItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtItemsZZ(n, paItems)
		return This.FindNthSplitAtItemsCSZZ(n, paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseItemsZZ(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)
	
		def FindNthSplitAtManyItemsZZ(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		#--

		def FindNthSplitAtItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		def FindNthSplitAtTheseItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		def FindNthSplitAtManyItemsAsSections(n, paItems)
			return This.FindNthSplitAtItemsZZ(n, paItems)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=======================================================#

	def FindNthSplitAtSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindNthSplitAtSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIBZZ(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSectionIB(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-----------------------------------------------------#

	def FindNthSplitAtSectionsZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAtSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSectionsZZ(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#--

		def FindNthSplitAtSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		def FindNthSplitAtTheseSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING NTH SPIT (AS SECTION) BEFORE A GIVEN ITEM   #
	#------------------------------------------------------------------------#

	def FindNthSplitBeforeCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitBeforeItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitBeforeItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pItem[2])
		
			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pItem[2])

			else
				return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeZZ(n, pItem)
		return This.FindNthSplitBeforeCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSection(n, pItem)
			return This.FindNthSplitBeforeZZ(n, pItem)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitBeforePositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPositionZZ(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#--

		def FindNthSplitBeforePositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		def FindNthSplitBeforeThisPositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitBeforePositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#--

		def FindNthSplitBeforePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeThesePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemCSZZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemAsSectionsCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitBeforeThisItemAsSectionsCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitBeforeItemCSZZ(n, pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItemZZ(n, pItem)
		return This.FindNthSplitBeforeItemCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisItemZZ(n, pItem)
			return This.FindNthSplitBeforeItem(n, pItem)

		#--

		def FindNthSplitBeforeItemAsSection(n, pItem)
			return This.FindNthSplitBeforeItemZZ(n, pItem)

		def FindNthSplitBeforeThisItemAsSection(n, pItem)
			return This.FindNthSplitBeforeItemZZ(n, pItem)	

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY Items   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBeforeItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeTheseItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBeforeManyItemsAsSectionsCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBeforeItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeItemsZZ(n, paItems)
		return This.FindNthSplitBeforeItemsCSZZ(n, paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseItemsZZ(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeManyItemsZZ(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		#--

		def FindNthSplitBeforeItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeTheseItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		def FindNthSplitBeforeManyItemsAsSection(n, paItems)
			return This.FindNthSplitBeforeItemsZZ(n, paItems)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindNthSplitBeforeSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBeforeSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsZZ(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#--

		def FindNthSplitBeforeSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSection(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIBZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindNthSplitBeforeSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		#>

	  #------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN ITEM  #
	#------------------------------------------------------#

	def FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])
				return This.FindNthSplitAfterPositionZZ(n, pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindNthSplitAfterItemCSZZ(n, pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindNthSplitAfterItemsCSZZ(n, pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pItem[2])

			else
				return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterZZ(n, pItem)
		return This.FindNthSplitAfterCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSection(n, pItem)
			return This.FindNthSplitAfterCSZZ(n, pItem, pCaseSensitive)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitAfterPositionZZ(n, Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPositionZZ(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		def FindNthSplitAfterThisPositionAsSection(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitAfterPositionsZZ(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositionsZZ(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsZZ(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#--

		def FindNthSplitAfterPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterPositionsZZ(anPos)

		def FindNthSplitAfterThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemCSZZ(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		#--

		def FindNthSplitAfterItemAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		def FindNthSplitAfterThisItemAsSectionCS(n, pItem, pCaseSensitive)
			return This.FindNthSplitAfterItemCSZZ(n, pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItemZZ(n, pItem)
		return This.FindNthSplitAfterItemCSZZ(n, pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisItemZZ(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		#--

		def FindNthSplitAfterItemAsSection(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		def FindNthSplitAfterThisItemAsSection(n, pItem)
			return This.FindNthSplitAfterItemZZ(n, pItem)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY Items   #
	#-----------------------------------------------------------#

	def FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitAfterItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitAfterManyItemsAsSectionCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitAfterItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterItemsZZ(n, paItems)
		return This.FindNthSplitAfterItemsCSZZ(n, paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseItemsZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterManyItemsZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		#--

		def FindNthSplitAfterItemsAsSection(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterTheseItemsAsSection(n, paItems)
			return This.FindNthSplitAfterItemsZZ(n, paItems)

		def FindNthSplitAfterManyItemsAsSectionZZ(n, paItems)
			return This.FindNthSplitAfterItemsZZ(paItems)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#----------------------------------------------------------#

	def FindNthSplitAfterSectionZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindNthSplitAfterSectionIBZZ(n, n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionIBZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n1, n2)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#--------------------------------------------------------#

	def FindNthSplitAfterSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsZZ(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterSectionsZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterSectionsIBZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitAfterSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items  #
	#======================================================================#

	def FindNthSplitBetweenCSZZ(n, pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBetweenZZ(n, pItem1, pItem2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCS(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSZZ(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenZZ(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCS(n, pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSection(n, pItem1, pItem2)
			return This.FindNthSplitBetweenZZ(n, pItem1, pItem2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitBetweenIBZZ(n, pItem1, pItem2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCSIB(n, pItem1, pItem2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIBZZ(n, pItem1, pItem2)
		return This.FindNthSplitBetweenCSIBZZ(n, pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionIB(n, pItem1, pItem2)
			return This.FindNthSplitBetweenIBZZ(n, pItem1, pItem2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#--------------------------------------------------------#

	def FindNthSplitBetweenPositionsZZ(n, n1, n2)
		This.FindNthSplitAtSectionZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#>
		
	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIBZZ(n, n1, n2)
		This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIBZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO Items  #
	#---------------------------------------------------------#

	def FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)
		aSections = This.FindAsSections(paItems, pCaseSensitive)
		aResult = This.FindNthSplitBetweenSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsCSZZ(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		#--

		def FindNthSplitBetweenItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		def FindNthSplitBetweenTheseItemsAsSectionCS(n, paItems, pCaseSensitive)
			return This.FindNthSplitBetweenItemsCSZZ(n, paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenItemsZZ(n, paItems)
		return This.FindNthSplitBetweenItemsCSZZ(n, paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseItemsZZ(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		#--

		def FindNthSplitBetweenItemsAsSection(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		def FindNthSplitBetweenTheseItemsAsSection(n, paItems)
			return This.FindNthSplitBetweenItemsZZ(n, paItems)

		#>

	  #-------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) TO N PARTS    #
	#=================================================#

	def FindNthSplitToNPartsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindNthSplitToNPartsZZ(n, nPos)
		return aResult

		def FindNthSplitToNPartsAsSection(n, nPos)
			return This.FindNthSplitToNPartsZZ(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N Items   #
	#-----------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindNthSplitToPartsOfNItemsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfExactlyNPositionsZZ(n, nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNItemsZZ(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		#--

		def FindNthSplitToPartsOfNItemsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		def FindNthSplitToPartsOfExactlyNItemsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNItemsZZ(n, nPos)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindNthSplitToPartsOfNItemsIBZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindNthSplitToPartsOfNPositionsIBZZ(n, nPos)

		return aResult

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) UNDER A GIVEN CONDTION   #
	#============================================================#

	def FindNthSplitWZZ(n, pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionW(n, pcCondition)
			return This.FindNthSplitWZZ(n, pcCondition)

		#>

	  #---------------------------------------------------------#
	 #    FINSING NTH SPLIT (AS SECTION) AT A GIVEN CONDTION   #
	#=========================================================#

	def FindNthSplitAtWZZ(n, pcCondition)
			
		aSections = This.FindItemsAsSectionsW(pcCondition)
		aResult = This.FindNthSplitAtSectionsZZ(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionW(n, pcCondition)
			return This.FindNthSplitAtWZZ(n, pcCondition)

		#>

	  #------------------------------------------------------------------------#
	 #    FINSING NTH SPLIT (AS SECTION) AT A GIVEN CONDTION -- WXT/EXTENDED  #
	#------------------------------------------------------------------------#

	def FindNthSplitAtWXTZZ(n, pcCondition)
			
		aSections = This.FindItemsAsSectionsWXT(pcCondition)
		aResult = This.FindNthSplitAtSectionsZZ(n, aSections)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionWXT(n, pcCondition)
			return This.FindNthSplitAtWXTZZ(n, pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#==============================================================#

	def FindNthSplitBeforeWZZ(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeAsSectionW(n, pcCondition)
			return This.FindNthSplitBeforeWZZ(n, pcCondition)

		#>

	  #-----------------------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTIONS) BEFORE A GIVEN CONDTION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBeforeWXTZZ(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeAsSectionWXT(n, pcCondition)
			return This.FindNthSplitBeforeWXTZZ(n, pcCondition)

		#>

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN CONDTION   #
	#============================================================#

	def FindNthSplitAfterWZZ(n, pcCondition)
		anPos = This.FindItemsW(pcCondition)
		aResult = This.FindNthSplitAfterPositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionW(n, pcCondition)
			return This.FindNthSplitAfterWZZ(n, pcCondition)

		#>

	  #---------------------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- WXT/EXTENDED  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterWXTZZ(n, pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		aResult = This.FindNthSplitAfterPositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionWXT(n, pcCondition)
			return This.FindNthSplitAfterWXTZZ(n, pcCondition)

		#>

	  #============================#
	 #   FINDING THE LAST SPLIT   #
	#============================#

	def FindLastSplitCSXT(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindLastSplitAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindLastSplitAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSections(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindLastSplitBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSections(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindLastSplitAfterItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindLastSplitAfterItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSections(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindLastSplitBetweenCS(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositions(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.FindLastSplitBetweenItemsCS(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNParts(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindLastSplitToPartsOfNItems(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindLastSplitAtW(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindLastSplitBeforeW(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindLastSplitAfterW(pItem[2])

			else
				return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitCSXTZ(pItem, pCaseSensitive)
			return This.FindLastSplitCSXT(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXT(pItem)
		return This.FindLastSplitCSXT(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitXTZ(pItem)
			return This.FindLastSplitXT(pItem)

		#>

	  #----------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN ITEM   #
	#========================================#

	def FindLastSplitAtCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPosition(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositions(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAtItemCS(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAtItemsCS(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSection(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSections(pItem[2])

			else
				return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAt(pItem)
		return This.FindLastSplitAtCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtZ(pItem)
			return This.FindLastSplitAtCS(pSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN POSITION   #
	#============================================#

	def FindLastSplitAtPosition(nPos)
		if EarlyChek()
			if This.IsEmpty()
				return []
			ok
		ok

		if ParamCheck()
			if NOT isNumber(nPos)
				StzRaise("Incorrect pram type! n must be a number.")
			ok
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPosition(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtThisPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY POSITIONS   #
	#------------------------------------------#

	def FindLastSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfItems()).FindLastSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#--

		def FindLastSplitAtPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtThesePositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN Item   #
	#=============================================#

	def FindLastSplitAtItemCS(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitAtItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCSZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItem(pItem)
		return This.FindLastSplitAtItemCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplit(pItem)
			return This.FindLastSplitCS(pItem, TRUE)

		def FindLastSplitAtThisItem(pItem)
			return This.FindLastSplitAtThisItemCS(pItem, TRUE)
		#--

		def FindLastSplitAtItemZ(pItem)
			return This.FindLastSplitAtItemCS(pItem, TRUE)

		def FindLastSplitZ(pItem)
			return This.FindLastSplitCS(pItem, TRUE)

		def FindLastSplitAtThisItemZ(pItem)
			return This.FindLastSplitAtThisItemCS(pItem, TRUE)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT GIVEN Items   #
	#--------------------------------------------#

	def FindLastSplitAtItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)
		nResult = This.FindLastSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitAtItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItems(paItems)
		return This.FindLastSplitAtItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItems(paItems)
			return This.FindLastSplitAtItems(paItems)
	
		def FindLastSplitAtManyItems(paItems)
			return This.FindLastSplitAtItems(paItems)

		#--

		def FindLastSplitAtItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		def FindLastSplitAtTheseItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		def FindLastSplitAtManyItemsZ(paItems)
			return This.FindLastSplitAtItems(paItems)

		#>

	  #-------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION   #
	#===========================================#

	def FindLastSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSection(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#--

		def FindLastSplitAtSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		def FindLastSplitAtThisSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindLastSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindLastSplitAtSectionIBZ(n1, n2)
			return This.FindLastSplitAtSectionIB(n1, n2)

		def FindLastSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS   #
	#-----------------------------------------#

	def FindLastSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSections(paSections)
			return This.FindLastSplitAtSections(paSections)

		#--

		def FindLastSplitAtSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		def FindLastSplitAtTheseSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsIB(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#--

		def FindLastSplitAtSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		def FindLastSplitAtTheseSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN ITEM   #
	#--------------------------------------------#

	def FindLastSplitBeforeCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitBeforeItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitBeforeItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSection(pItem[2])
		
			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSections(pItem[2])

			else
				return This.FindLastSplitAtItemCS(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBefore(pItem)
		return This.FindLastSplitBeforeCS(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeZ(pItem)
			return This.FindLastSplitBefore(pItem)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPosition(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#--

		def FindLastSplitBeforePositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		def FindLastSplitBeforeThisPositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#--

		def FindLastSplitBeforePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeThesePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN Item   #
	#-------------------------------------------------#

	def FindLastSplitBeforeItemCS(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		def FindLastSplitBeforeThisItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCS(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItem(pItem)
		return This.FindLastSplitBeforeItemCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItem(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		#--

		def FindLastSplitBeforeItemZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		def FindLastSplitBeforeThisItemZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)	

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY Items   #
	#-----------------------------------------------#

	def FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItems(paItems)
		return This.FindLastSplitBeforeItemsCS(paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItems(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeManyItems(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		#--

		def FindLastSplitBeforeItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeTheseItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		def FindLastSplitBeforeManyItemsZ(paItems)
			return This.FindLastSplitBeforeItems(paItems)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSection(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#--

		def FindLastSplitBeforeSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		def FindLastSplitBeforeThisSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIB(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#--

		def FindLastSplitBeforeSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		def FindLastSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS   #
	#---------------------------------------------#

	def FindLastSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSections(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindLastSplitBeforeSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeTheseSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#--

		def FindLastSplitBeforeSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN ITEM  #
	#------------------------------------------#

	def FindLastSplitAfterCS(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPosition(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositions(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAfterItemCS(pItem[2], pCaseSensitive)
		
			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAfterItemsCS(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSection(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSections(pItem[2])

			else
				return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfter(pItem)
		return This.FindLastSplitAfterCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterZ(pItem)
			return This.FindLastSplitAfterCS(pItem, pCaseSensitive)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPosition(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterThisPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositions(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositions(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#--

		def FindLastSplitAfterPositionsZ(anPos)
			return This.FindLastSplitAfterPositions(anPos)

		def FindLastSplitAfterThesePositionsZ(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositionsZ(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN Item   #
	#-------------------------------------------------#

	def FindLastSplitAfterItemCS(pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		#--

		def FindLastSplitAfterItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		def FindLastSplitAfterThisItemCSZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCS(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItem(pItem)
		return This.FindLastSplitAfterItemCS(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItem(pItem)
			return This.FindLastSplitAfterItem(pItem)

		#--

		def FindLastSplitAfterItemZ(pItem)
			return This.FindLastSplitAfterItem(pItem)

		def FindLastSplitAfterThisItemZ(pItem)
			return This.FindLastSplitAfterItem(pItem)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY Items   #
	#-----------------------------------------------#

	def FindLastSplitAfterItemsCS(paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitAfterItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItems(paItems)
		return This.FindLastSplitAfterItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItems(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterManyItems(paItems)
			return This.FindLastSplitAfterItems(paItems)

		#--

		def FindLastSplitAfterItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterTheseItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		def FindLastSplitAfterManyItemsZ(paItems)
			return This.FindLastSplitAfterItems(paItems)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION  #
	#---------------------------------------------#

	def FindLastSplitAfterSection(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSection(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#--

		def FindLastSplitAfterSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		def FindLastSplitAfterThisSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindLastSplitAfterSectionIB(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		#--

		def FindLastSplitAfterSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		def FindLastSplitAfterThisSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)


		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS   #
	#--------------------------------------------#

	def FindLastSplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSections(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#--

		def FindLastSplitAfterSectionsZ(paSections)
			return This.FindLastSplitAfterSections(paSections)

		def FindLastSplitAfterTheseSectionsZ(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindLastSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#--

		def FindLastSplitAfterSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		def FindLastSplitAfterTheseSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR Items  #
	#==========================================================#

	def FindLastSplitBetweenCS(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetween(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSZ(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCS(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetween(pItem1, pItem2)
		return This.FindLastSplitBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenZ(pItem1, pItem2)
			return This.FindLastSplitBetween(pItem1, pItem2)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenIB(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSIBZ(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIB(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIB(pItem1, pItem2)
		return This.FindLastSplitBetweenCSIB(pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenIBZ(pItem1, pItem2)
			return This.FindLastSplitBetweenIB(pItem1, pItem2)

		#>

	  #--------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS  #
	#--------------------------------------------#

	def FindLastSplitBetweenPositions(n1, n2)
		This.FindLastSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositions(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#--

		def FindLastSplitBetweenPositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		def FindLastSplitBetweenThesePositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#>
		
	  #----------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIB(n1, n2)
		This.FindLastSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#--

		def FindLastSplitBetweenPositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		def FindLastSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO Items  #
	#---------------------------------------------#

	def FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)
		aSections = This.Find(paItems, pCaseSensitive)
		nResult = This.FindLastSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		#--

		def FindLastSplitBetweenItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		def FindLastSplitBetweenTheseItemsCSZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCS(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenItems(paItems)
		return This.FindLastSplitBetweenItemsCS(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItems(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		#--

		def FindLastSplitBetweenItemsZ(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		def FindLastSplitBetweenTheseItemsZ(paItems)
			return This.FindLastSplitBetweenItems(paItems)

		#>

	  #-------------------------------------#
	 #    FINDING LAST SPLIT TO N PARTS    #
	#=====================================#

	def FindLastSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitToNParts(nPos)
		return nResult

		def FindLastSplitToNPartsZ(nPos)
			return This.FindLastSplitToNParts(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N Items   #
	#------------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindLastSplitToPartsOfNItems(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNItems(nPos)
			return This.FindLastSplitToPartsOfNItems(nPos)

		#--

		def FindLastSplitToPartsOfNItemsZ(nPos)
			return This.FindLastSplitToPartsOfNItems(nPos)

		def FindLastSplitToPartsOfExactlyNItemsZ(nPos)
			return This.FindLastSplitToPartsOfNItems(nPos)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindLastSplitToPartsOfNItemsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindLastSplitToPartsOfNItemsXTZ(nPos)
			return This.FindLastSplitToPartsOfNItemsXT(nPos)

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT UNDER A GIVEN CONDTION   #
	#===============================================#

	def FindLastSplitW(pcCondition)
		/*
		? StzSplitterQ(1:5).FindLastSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterW(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitWZ(pcCondition)
			return This.FindLastSplitWZ(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT UNDER A GIVEN CONDTION -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindLastSplitWXT(pcCondition)
		/*
		? StzSplitterQ(1:5).FindLastSplitWXT('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtWXT(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtWXT(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeWXT(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterWXT(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWXTZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitWXTZ(pcCondition)
			return This.FindLastSplitWXTZ(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN CONDTION   #
	#============================================#

	def FindLastSplitAtW(pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAtPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtWZ(pcCondition)
			return This.FindLastSplitAtW(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN CONDTION -- WXT/EXTENDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtWXT(pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAtPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtWXTZ(pcCondition)
			return This.FindLastSplitAtWXT(pcCondition)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN CONDTION   #
	#================================================#

	def FindLastSplitBeforeW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWZ(pcCondition)
			return This.FindLastSplitBeforeW(pcCondition)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN CONDTION -- WXT/EXTENDED  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWXTZ(pcCondition)
			return This.FindLastSplitBeforeWXT(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN CONDTION   #
	#===============================================#

	def FindLastSplitAfterW(pcCondition)
		anPos = This.FindItemsW(pcCondition)
		nResult = This.FindLastSplitAfterPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWZ(pcCondition)
			return This.FindLastSplitAfterW(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN CONDTION -- WXT/EXTENDED  #
	#--------------------------------------------------------------#

	def FindLastSplitAfterWXT(pcCondition)
		anPos = This.FindItemsWXT(pcCondition)
		nResult = This.FindLastSplitAfterPositions(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWXTZ(pcCondition)
			return This.FindLastSplitAfterWXT(pcCondition)

		#>

	  #=====================================================#
	 #   FINDING THE LAST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#=====================================================#

	def FindLastSplitCSXTZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtItem, :AtThisItem,
						:UsingItem, :UsingThisItem ]) 

				return This.FindLastSplitAtItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtItems, :AtTheseItems,
						:UsingItems, :UsingTheseItems ]) 

				return This.FindLastSplitAtItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pItem[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeItem, :BeforeThisItem ]) 
				return This.FindLastSplitBeforeItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeItems, :BeforeTheseItems ]) 
				return This.SplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pItem[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterItem, :AfterThisItem ]) 
				return This.FindLastSplitAfterItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterItems, :AfterTheseItems ]) 
				return This.FindLastSplitAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pItem[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pItem) and len(pItem) = 2
				
				if isList(pItem[2]) and Q(pItem[2]).IsAndNamedParam()
					pItem[2] = pItem[2][2]
				ok

				return This.FindLastSplitBetweenCSZZ(pItem[1], pItem[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositionsZZ(pItem[1], pItem[2])

			but oParam.IsBetweenItemsNamedParam()
				return This.FindLastSplitBetweenItemsCSZZ(pItem[1], pItem[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNPartsZZ(pItem[2])

			but oParam.IsToPartsOfNItemsNamedParam()
				return This.FindLastSplitToPartsOfNItemsZZ(pItem[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindLastSplitAtWZZ(pItem[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindLastSplitBeforeWZZ(pItem[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindLastSplitAfterWZZ(pItem[2])

			else
				return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionCSXT(pItem, pCaseSensitive)
			return This.FindLastSplitCSXTZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitZZXT(pItem)
		return This.FindLastSplitCSXTZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionXT(pItem)
			return This.FindLastSplitXTZZ(pItem)

		#>

	  #-----------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#=====================================================#

	def FindLastSplitAtCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		else

			oParam = Q(pItem)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pItem[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pItem[2])

			but oParam.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAtItemCSZZ(pItem[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAtItemsCSZZ(pItem[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pItem[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pItem[2])

			else
				return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtZZ(pItem)
		return This.FindLastSplitAtCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSection(pItem)
			return This.FindLastSplitAtCSZZ(pSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#=========================================================#

	def FindLastSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPositionAsSection(nPos)
			return This.FindLastSplitAtPositionZZ(nPos)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#------------------------------------------------------#

	def FindLastSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfItems()).FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#--

		def FindLastSplitAtPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtThesePositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN ITEM   #
	#=====================================================#

	def FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)
		if EarlyCheck()
			if This.IsEmpty()
				return []
			ok
		ok

		aSections = This.FindAsSectionsCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemCSZZ(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitAtItemAsSectionsCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAtThisItemAsSectionsCS(pItem, pCaseSensitive)
			if isList(pItem) and Q(pItem).IsAtOrAtItemNamedParam()
				pItem = pItem[2]
			ok

			return This.FindLastSplitAtItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItemZZ(pItem)
		return This.FindLastSplitAtItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, TRUE)

		def FindLastSplitAtThisItemZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, TRUE)
		#--

		def FindLastSplitAtItemAsSectionZZ(pItem)
			return This.FindLastSplitAtItemZZ(pItem, TRUE)

		def FindLastSplitAsSection(pItem)
			return This.FindLastSplitAtItemZZ(pItem, TRUE)

		def FindLastSplitAtThisItemAsSection(pItem)
			return This.FindLastSplitAtItemZZ(pItem, TRUE)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTIONS) AT GIVEN Items  #
	#---------------------------------------------------------#

	def FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(paItems, pCaseSensitive)

		aResult = This.FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitAtItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAtManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitAtItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtItemsZZ(paItems)
		return This.FindLastSplitAtItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseItemsZZ(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)
	
		def FindLastSplitAtManyItemsZZ(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		#--

		def FindLastSplitAtItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		def FindLastSplitAtTheseItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		def FindLastSplitAtManyItemsAsSections(paItems)
			return This.FindLastSplitAtItemsZZ(paItems)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#========================================================#

	def FindLastSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionZZ(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindLastSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAtSectionIBZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#------------------------------------------------------#

	def FindLastSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsZZ(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#--

		def FindLastSplitAtSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		def FindLastSplitAtTheseSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING LAST SPIT (AS SECTION) BEFORE A GIVEN ITEM   #
	#-------------------------------------------------------------------------#

	def FindLastSplitBeforeCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isList(pItem)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if Q(pItem).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pItem[2])
	
			but Q(pItem).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pItem[2])

			but Q(pItem).IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitBeforeItemCSZZ(pItem[2], pCaseSensitive)
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitBeforeItemsCSZZ(pItem[2], pCaseSensitive)

			but Q(pItem).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pItem[2])
		
			but Q(pItem).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pItem[2])

			else
				return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)
			ok
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeZZ(pItem)
		return This.FindLastSplitBeforeCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSection(pItem)
			return This.FindLastSplitBeforeZZ(pItem)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPositionZZ(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#--

		def FindLastSplitBeforePositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		def FindLastSplitBeforeThisPositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#--

		def FindLastSplitBeforePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeThesePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#--------------------------------------------------------------#

	def FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitBeforeThisItemAsSectionsCS(pItem, pCaseSensitive)
			return This.FindLastSplitBeforeItemCSZZ(pItem, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItemZZ(pItem)
		return This.FindLastSplitBeforeItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisItemZZ(pItem)
			return This.FindLastSplitBeforeItem(pItem)

		#--

		def FindLastSplitBeforeItemAsSection(pItem)
			return This.FindLastSplitBeforeItemZZ(pItem)

		def FindLastSplitBeforeThisItemAsSection(pItem)
			return This.FindLastSplitBeforeItemZZ(pItem)	

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY Items   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitBeforeItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeTheseItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBeforeManyItemsAsSectionsCS(paItems, pCaseSensitive)
			return This.FindLastSplitBeforeItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeItemsZZ(paItems)
		return This.FindLastSplitBeforeItemsCSZZ(paItems, TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseItemsZZ(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeManyItemsZZ(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		#--

		def FindLastSplitBeforeItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeTheseItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		def FindLastSplitBeforeManyItemsAsSection(paItems)
			return This.FindLastSplitBeforeItemsZZ(paItems)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionZZ(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#>

	  #-------------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindLastSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsZZ(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeManySectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN ITEM   #
	#--------------------------------------------------------#

	def FindLastSplitAfterCSZZ(pItem, pCaseSensitive)
		if NOT isList(pItem)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		else

			oItem = Q(pItem)

			if oItem.IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPositionZZ(pItem[2])
	
			but oItem.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Item, :ThisItem ]) 
				return This.FindLastSplitAfterItemCSZZ(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Items, :TheseItems ]) 
				return This.FindLastSplitAfterItemsCSZZ(pItem[2], pCaseSensitive)

			but oItem.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pItem[2])

			but oItem.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pItem[2])

			else
				return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

			ok
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterZZ(pItem)
		return This.FindLastSplitAfterCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSection(pItem)
			return This.FindLastSplitAfterCSZZ(pItem, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPositionZZ(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		def FindLastSplitAfterThisPositionAsSection(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositionsZZ(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsZZ(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#--

		def FindLastSplitAfterPositionsAsSection(anPos)
			return This.FindLastSplitAfterPositionsZZ(anPos)

		def FindLastSplitAfterThesePositionsAsSection(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsAsSection(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN Item   #
	#--------------------------------------------------------------#

	def FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)
		if NOT isString(pItem)
			StzRaise("Incorrect param type! pItem must be a string.")
		ok

		anPos = This.FindCS(pItem, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemCSZZ(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		#--

		def FindLastSplitAfterItemAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		def FindLastSplitAfterThisItemAsSectionCS(pItem, pCaseSensitive)
			return This.FindLastSplitAfterItemCSZZ(pItem, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItemZZ(pItem)
		return This.FindLastSplitAfterItemCSZZ(pItem, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisItemZZ(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		#--

		def FindLastSplitAfterItemAsSection(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		def FindLastSplitAfterThisItemAsSection(pItem)
			return This.FindLastSplitAfterItemZZ(pItem)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY Items   #
	#------------------------------------------------------------#

	def FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)
		if NOT ( isList(paItems) and Q(paItems).IsListOfStrings() )
			StzRaise("Incorrect param type! paItems must be a list of strings.")
		ok

		anPos = This.FindCS( paItems, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitAfterItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitAfterManyItemsAsSectionCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitAfterItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterItemsZZ(paItems)
		return This.FindLastSplitAfterItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseItemsZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterManyItemsZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		#--

		def FindLastSplitAfterItemsAsSection(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterTheseItemsAsSection(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		def FindLastSplitAfterManyItemsAsSectionZZ(paItems)
			return This.FindLastSplitAfterItemsZZ(paItems)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterSectionZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionZZ(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionIBZZ(n1, n2)

		if NOT @BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindLastSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsZZ(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSection(paSections)
			return This.FindLastSplitAfterSectionsZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSection(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items  #
	#=======================================================================#

	def FindLastSplitBetweenCSZZ(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenZZ(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCS(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenZZ(pItem1, pItem2)
		return This.FindLastSplitBetweenCS(pItem1, pItem2, TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSection(pItem1, pItem2)
			return This.FindLastSplitBetweenZZ(pItem1, pItem2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR Items -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pItem1, pItem2) )
			StzRaise("Incorrect params types! pItem1 and pItem2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pItem1, pItem2)
			aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitBetweenIBZZ(pItem1, pItem2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pItem1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pItem2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfItems() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCSIB(pItem1, pItem2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIBZZ(pItem1, pItem2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIBZZ(pItem1, pItem2)
		return This.FindLastSplitBetweenCSIBZZ(pItem1, pItem2, TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionIB(pItem1, pItem2)
			return This.FindLastSplitBetweenIBZZ(pItem1, pItem2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#---------------------------------------------------------#

	def FindLastSplitBetweenPositionsZZ(n1, n2)
		This.FindLastSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIBZZ(n1, n2)
		This.FindLastSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO Items  #
	#----------------------------------------------------------#

	def FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)
		aSections = This.FindAsSections(paItems, pCaseSensitive)
		aResult = This.FindLastSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsCSZZ(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		#--

		def FindLastSplitBetweenItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		def FindLastSplitBetweenTheseItemsAsSectionCS(paItems, pCaseSensitive)
			return This.FindLastSplitBetweenItemsCSZZ(paItems, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenItemsZZ(paItems)
		return This.FindLastSplitBetweenItemsCSZZ(paItems, TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseItemsZZ(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		#--

		def FindLastSplitBetweenItemsAsSection(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		def FindLastSplitBetweenTheseItemsAsSection(paItems)
			return This.FindLastSplitBetweenItemsZZ(paItems)

		#>

	  #--------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) TO N PARTS    #
	#==================================================#

	def FindLastSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).FindLastSplitToNPartsZZ(nPos)
		return aResult

		def FindLastSplitToNPartsAsSection(nPos)
			return This.FindLastSplitToNPartsZZ(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N Items   #
	#------------------------------------------------------#
	# Remaining part less the n Items is not returned

	def FindLastSplitToPartsOfNItemsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNItemsZZ(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		#--

		def FindLastSplitToPartsOfNItemsAsSection(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		def FindLastSplitToPartsOfExactlyNItemsAsSection(nPos)
			return This.FindLastSplitToPartsOfNItemsZZ(nPos)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) TO PARTS OF N Items -- INCLUDING BOUNDS   #
	#-----------------------------------------------------------------------------#
	# The remaing part (if any) less then n Items is also returned

	def FindLastSplitToPartsOfNItemsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfItems() ).
				FindLastSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) UNDER A GIVEN CONDTION   #
	#=============================================================#

	def FindLastSplitWZZ(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeWZZ(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterWZZ(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionW(pcCondition)
			return This.FindLastSplitWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) UNDER A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def FindLastSplitWXTZZ(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtWXTZZ(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtWXTZZ(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeWXTZZ(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterWXTZZ(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWXTZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionWXT(pcCondition)
			return This.FindLastSplitWXTZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDTION   #
	#==========================================================#

	def FindLastSplitAtWZZ(pcCondition)
			
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAtPositionsZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionW(pcCondition)
			return This.FindLastSplitAtWZZ(pcCondition)

		#>

	  #-------------------------------------------------------------------------#
	 #    FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDTION -- WXT/EXTENDED  #
	#-------------------------------------------------------------------------#

	def FindLastSplitAtWXTZZ(pcCondition)
			
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAtPositionsZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionWXT(pcCondition)
			return This.FindLastSplitAtWXTZZ(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION   #
	#==============================================================#

	def FindLastSplitBeforeWZZ(pcCondition)
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitBeforeZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeAsSectionW(pcCondition)
			return This.FindLastSplitBeforeWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN CONDTION -- WXT/EXTENDED  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitBeforeWXTZZ(pcCondition)
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitBeforeZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeAsSectionWXT(pcCondition)
			return This.FindLastSplitBeforeWXTZZ(pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDTION   #
	#=============================================================#

	def FindLastSplitAfterWZZ(pcCondition)
		anPos = This.FindW(pcCondition)
		nResult = This.FindLastSplitAfterZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionW(pcCondition)
			return This.FindLastSplitAfterWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDTION -- WXT/EXTENDED  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterWXTZZ(pcCondition)
		anPos = This.FindWXT(pcCondition)
		nResult = This.FindLastSplitAfterZZ(anPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionWXT(pcCondition)
			return This.FindLastSplitAfterWXTZZ(pcCondition)

		#>

	  #===========================================#
	 #  GETTING THE UNICODES CODES OF EACH ITEM  #
	#===========================================#

	def Unicodes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				i++
			ok

			aResult + Q(aContent[i]).Unicode()
		next

		return aResult

		def Unicode()
			return This.Unicodes()

	def HexUnicodes()
		aContent = This.Content()
		nLen = len(aContent)

		aResult = []

		for i = 1 to nLen
			if isObject(aContent[i])
				i++
			ok

			aResult + Q(aContent[i]).HexUnicode()
		next

		return aResult

		def HexUnicode()
			return This.HexUnicodes()

	  #-----------------------------------------------------------#
	 #  GETTING THE NAMES (IN UNICODE) OF THE CHARS IN THE LIST  #
	#-----------------------------------------------------------#

	def Names()
		acChars = This.Chars()
		nLen = len(acChars)

		acResult = []

		for i = 1 to nLen
			acResult + StzCharQ(acChars[i]).Name()
		next

		return acResult

		#< @FunctionAlternativeForms

		def NamesInUnicode()
			return This.Names()

		def UnicodeNames()
			return This.Names()

		#--

		def CharsNames()
			return This.Names()

		def CharsNamesInUnicode()
			return This.Names()

		def UnicodeCharsNames()
			return This.Names()

		#>

	    /////////////////////////////////////////////////////
	   /// #===========================================# ///
	  /// #   CHECKING IF THE LIST IS A NAMED PARAM   # ///
	 /// #===========================================# ///
	/////////////////////////////////////////////////////

	#NOTE
	# Currently (V1) Softanza supports more then 1500 named params

	#TODO: Add @ to all params, like this:
	# (This.Item(1) = :ParamName or This.Item(1) = :ParamName@ ) )

	def IsOnPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnPosition)

			return TRUE
		else
			return FALSE
		ok

		def IsInPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and This.Item(1) = :InPosition)
	
				return TRUE
			else
				return FALSE
			ok
	
		// def IsAtPositionNamedParam() --> Exists below in the file


	def IsOnPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnPositions)

			return TRUE
		else
			return FALSE
		ok

		def IsInPositionsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and This.Item(1) = :InPositions)
	
				return TRUE
			else
				return FALSE
			ok
	
		// def IsAtPositionsNamedParam() # Exists in the file below

	def IsOnSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSection)

			return TRUE
		else
			return FALSE
		ok

		// def IsInSectionNamedParam() # Exists in the file below
	
		// def IsAtSectionNamedParam() # Idem


	def IsOnSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OnSections)

			return TRUE
		else
			return FALSE
		ok

		// def IsInSectionsNamedParam() # Exists in the file below
	
		// def IsAtSectionsNamedParam() # Idem

	#--

	def IsHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Harvest)

			return TRUE
		else
			return FALSE
		ok

	def IsAndHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvest)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvest)

			return TRUE
		else
			return FALSE
		ok

	def IsThenHarvestNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvest)

			return TRUE
		else
			return FALSE
		ok

	def IsYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Yield)

			return TRUE
		else
			return FALSE
		ok

	def IsAndYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYield)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYield)

			return TRUE
		else
			return FALSE
		ok

	def IsThenYieldNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYield)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :HarvestSection)

			return TRUE
		else
			return FALSE
		ok

	def IsAndHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvestSection)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvestSection)

			return TRUE
		else
			return FALSE
		ok

	def IsThenHarvestSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvestSection)

			return TRUE
		else
			return FALSE
		ok

	def IsYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :YieldSection)

			return TRUE
		else
			return FALSE
		ok

	def IsAndYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYieldSection)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYieldSection)

			return TRUE
		else
			return FALSE
		ok

	def IsThenYieldSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYieldSection)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :HarvestSections)

			return TRUE
		else
			return FALSE
		ok

	def IsAndHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndHarvestSections)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenHarvestSections)

			return TRUE
		else
			return FALSE
		ok

	def IsThenHarvestSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenHarvestSections)

			return TRUE
		else
			return FALSE
		ok

	def IsYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :YieldSections)

			return TRUE
		else
			return FALSE
		ok

	def IsAndYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndYieldSections)

			return TRUE
		else
			return FALSE
		ok

	def IsAndThenYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndThenYieldSections)

			return TRUE
		else
			return FALSE
		ok

	def IsThenYieldSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThenYieldSections)

			return TRUE
		else
			return FALSE
		ok
	#--

	def IsNCharsBeforeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NCharsBefore)

			return TRUE
		else
			return FALSE
		ok

	def IsNCharsAfterNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NCharsAfter)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsToNPartsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToNParts)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNChars)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItems)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNItemsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItemsXT)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNStrings)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNSubStringss)

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsAtWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AtWhere)

			return TRUE
		else
			return FALSE
		ok

	def IsWhereOrAtWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsAtWhereOrWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsWhereOrAtWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsAtWhereOrWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsAtWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBeforeWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeWhere)

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeOrBeforeWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsBeforeWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsBeforeWhereOrBeforeNamedParam()
		if This.IsWhereNamedParam() or This.IsBeforeWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsBeforeOrBeforeWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsBeforeWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsBeforeWhereOrBeforeNamedParams()
		if This.IsWhereNamedParam() or This.IsBeforeWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	#--

	#--

	def IsAfterWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterWhere)

			return TRUE
		else
			return FALSE
		ok

	def IsAfterOrAfterWhereNamedParam()
		if This.IsWhereNamedParam() or This.IsAfterWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsAfterWhereOrAfterNamedParam()
		if This.IsWhereNamedParam() or This.IsAfterWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsAfterOrAfterWhereNamedParams()
		if This.IsWhereNamedParam() or This.IsAfterWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	def IsAfterWhereOrAfterNamedParams()
		if This.IsWhereNamedParam() or This.IsAfterWhereNamedParam()
			return TRUE
		else
			return FALSE
		ok

	#==

	def IsToPartsOfExactlyNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNItems)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfExactlyNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNChars)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfExactlyNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNStrings)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfExactlyNSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfExactlyNSubStrings)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsToPartsOfNItemsXT()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNItemsXT)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNCharsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNCharsXT)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNStringsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNStringsXT)

			return TRUE
		else
			return FALSE
		ok

	def IsToPartsOfNSubStringsXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToPartsOfNSubStringsXT)

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToItem)

			return TRUE
		else
			return FALSE
		ok

	def IsToItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToItems)

			return TRUE
		else
			return FALSE
		ok

	def IsUntilItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilItem)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToItem)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsDownToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownTo)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItem)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItemAt)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToItemAtPosition)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToChar)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToCharAt)

			return TRUE
		else
			return FALSE
		ok

	def IsDownToCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :DownToCharAtPosition)

			return TRUE
		else
			return FALSE
		ok

	#--

	#TODO: Move IsToCharNamedParam() here

	def IsUntilCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilChar)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToChar)

			return TRUE
		else
			return FALSE
		ok

	#--

	# Move IsToSubStringNamedParam() here

	def IsUntilSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilSubString)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToSubString)

			return TRUE
		else
			return FALSE
		ok

	#--

	#TODO : Move IsToStringNamedParam() here

	def IsUntilStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilString)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToString)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsToStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStringItem)

			return TRUE
		else
			return FALSE
		ok

	def IsUntilStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilStringItem)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToStringItem)

			return TRUE
		else
			return FALSE
		ok

	#--

	#TODO : Move IsToNumberNamedParam() here

	def IsUntilNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilNumber)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToNumber)

			return TRUE
		else
			return FALSE
		ok

	#--

	#TODO: Move IsToListNamedParam() here

	def IsUntilListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilList)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToList)

			return TRUE
		else
			return FALSE
		ok

	#--

	#TODO : Move IsToObjectNamedParam() here

	def IsUntilObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UntilObject)

			return TRUE
		else
			return FALSE
		ok

	def IsUpToObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UpToObject)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsOneOfTheseNamedParams(pacParamNames)
		if CheckParams()
			if NOT ( isList(pacParamNames) and @IsListOfStrings(pacParamNames) )
				StzRaise("Incorrect param type! pacParamNames must be a list of strings.")
			ok
		ok

		nLen = len(pacParamNames)
		bResult = FALSE

		for i = 1 to nLen
			cCode = 'bFound = This.Is' + pacParamNames[i] + 'NamedParam()'
			eval(cCode)
			if bFound
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionMisspelledForm

		def IsOneTheseNamedParams(pacParamNames)
			return This.IsOneOfTheseNamedParams(pacParamNames)

		#>

	def IsRemoveAtOptionsNamedParam()
		bResult = FALSE

		if This.IsHashList() and

		   This.ToStzHashList().KeysQ().IsMadeOfSome([
			:RemoveNCharsBefore, :RemoveNCharsAfter,
			:RemoveThisSubStringBefore,:RemoveThisSubStringAfter,
			:RemoveThisCharBefore,:RemoveThisCharBefore,
			:RemoveThisBound, :RemoveThisBoundingSubString,
			:CaseSensitive, :CS ])
			#NOTE: I've decided to keep CS as a suffix in the function
			# name and never use it as an internal option...
			#--> more simple mental model to keep things memprable

			if This.ToStzHashList().
				KeysQR(:stzListOfStrings).
				ContainsBothCS(:CaseSensitive, :CS, :CS = FALSE)

				StzRaise("Incorrect format! :CaseSensitive and :CS can not be used both in the same time")
			ok

			if This.ToStzHashList().
				KeysQR(:stzListOfStrings).
				ContainsBothCS(:RemoveThisBound, :RemoveThisBoundingSubString, :CS = FALSE)

				StzRaise("Incorrect format! :RemoveThisBound and :RemoveThisBoundingSubString can not be used both in the same time")
			ok

			bOk1 = FALSE
			nRemoveNCharsBefore = This.Content()[ :RemoveNCharsBefore ]
			cType = ring_type(nRemoveNCharsBefore)
		   	if cType = "NUMBER" or ( cType = "STRING" and nRemoveNCharsBefore = NULL )
				bOk1 = TRUE
			ok

			bOk2 = FALSE
			nRemoveNCharsAfter = This.Content()[ :RemoveNCharsAfter ]
			cType = ring_type(nRemoveNCharsAfter)
		   	if cType = "NUMBER" or ( cType = "STRING" and nRemoveNCharsAfter = NULL )
				bOk2 = TRUE
			ok

			bOk3 = FALSE
			cRemoveSubStringBefore = This.Content()[ :RemoveSubStringBefore ]
			cType = ring_type(cRemoveSubStringBefore)
		   	if cType = "STRING"
				bOk3 = TRUE
			ok

			bOk4 = FALSE
			cRemoveSubStringAfter = This.Content()[ :RemoveSubStringAfter ]
			cType = ring_type(cRemoveSubStringAfter)
		   	if cType = "STRING"
				bOk4 = TRUE
			ok

			bOk5 = FALSE
			cRemoveThisBound = This.Content()[ :cRemoveThisBound ]
			cType = ring_type(cRemoveThisBound)
		   	if cType = "STRING"
				bOk5 = TRUE
			ok

			if bOk1 and bOk2 and bOk3 and bOk4 and bOk5
				bResult = TRUE
			ok
		ok

		return bResult

	def IsTextBoxedOptionsNamedParam()
		/*
		Example:

		? StzStringQ("TEXT1").BoxedXT([
			:Line = :Thin,	# or :Dashed
		
			:AllCorners = :Round # can also be :Rectangualr
			# :Corners = [ :Round, :Rectangular, :Round, :Rectangular ],
		
			:Width = 17,
			:TextAdjustedTo = :Center # or :Left or :Right or :Justified,
			
			:EachChar = FALSE # TRUE,
			:Hilighted = [ 1, 3 ] # Hilight the 1st and 3rd chars,

			:Numbered = TRUE
		])
		*/
		if This.IsEmpty()
			return TRUE
		ok

		aListOfBoxOptions = [
			:Line,
			:AllCorners,
			:Corners,
			:Width,
			:TextAdjustedTo,
			:EachChar,
			:EachWord,
			:Hilighted,
			:HilightedIf,
			:Numbered
		]

		if StzNumberQ(This.NumberOfItems()).IsBetween(1, len(aListOfBoxOptions)) and
		   This.IsHashList() and
		   StzHashListQ(This.Content()).KeysQ().IsMadeOfSome(aListOfBoxOptions)
		
			return TRUE

		else
			return FALSE
		ok

	def IsBoxOptionsNamedParam()

		if This.IsEmpty()
			return TRUE
		ok

		aListOfBoxOptions = [
			:Line,
			:AllCorners,
			:Corners,
			:Width,
			:TextAdjustedTo,
			:EachChar,

			:Casesensitive,
			:CS,

			:Numbered,
			:Spacified,

			:Shadowed,
			:ShadowChar,
			:ShadowOrientation
			
		]

		if StzNumberQ(This.NumberOfItems()).IsBetween(1, len(aListOfBoxOptions)) and
		   This.IsHashList() and
		   StzHashListQ(This.Content()).KeysQ().IsMadeOfSome(aListOfBoxOptions)
		
			return TRUE

		else
			return FALSE
		ok

	def IsConstraintsOptionsNamedParam()
		/* EXAMPLE
		[
			:OnStzString = [
				:MustBeUppercase 	= '{ Q(@str).IsUppercase() }',
				:MustNotExceed@n@Chars 	= '{ Q(@str).NumberOfChars() <= n }',
				:MustBeginWithLetter@c@	= '{ Q(@str).BeginsWithCS(c, :CS = FALSE) }'
			],
		
			:OnStzNumber = [
				:MustBeStrictlyPositive = '{ @number > 0 }'
			],
		
			:OnStzList = [
				:MustBeAHashList = '{ Q(@list).IsHashList() }'
			]
		]
		*/
		
		try
			VerifyConstraints([
				:MustBeAHashList,
				:KeysMustBeOnStzTypes,
				:ValuesMustBeRingCodeInStrings
			])

			return TRUE

		catch
			return FALSE
		done

	#--

	def IsCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Cell)

			return TRUE
		else
			return FALSE
		ok

	def IsOfCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCell)

			return TRUE
		else
			return FALSE
		ok

	def IsCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Cells)

			return TRUE
		else
			return FALSE
		ok

	def IsOfCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCells)

			return TRUE
		else
			return FALSE
		ok

	def IsInCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InCell)

			return TRUE
		else
			return FALSE
		ok

	def IsInCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InCells)

			return TRUE
		else
			return FALSE
		ok

	def IsCellValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :CellValue)

			return TRUE
		else
			return FALSE
		ok

	def IsOfCellValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCellValue)

			return TRUE
		else
			return FALSE
		ok

	def IsCellPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :CellPart)

			return TRUE
		else
			return FALSE
		ok

	def IsPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Part)

			return TRUE
		else
			return FALSE
		ok

	def IsSubPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubPart)

			return TRUE
		else
			return FALSE
		ok
	#--

	def IsSubValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubValue)

			return TRUE
		else
			return FALSE
		ok

	def IsOfSubValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubValue)

			return TRUE
		else
			return FALSE
		ok

	def IsSubValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubValues)

			return TRUE
		else
			return FALSE
		ok

	def IsOfSubValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubValues)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsOfCellPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfCellPart)

			return TRUE
		else
			return FALSE
		ok

	def IsOfPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfPart)

			return TRUE
		else
			return FALSE
		ok

	def IsOfSubPartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubPart)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Col or This.Item(1) = :Column) )

			return TRUE
		else
			return FALSE
		ok

		def IsColumnNamedParam()
			return This.IsColNamedParam()

	def IsColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ColNumber or This.Item(1) = :ColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsColumnNumberNamedParam()
			return This.IsColNumberNamedParam()

	def IsColOrColNumberNamedParam()
		if This.IsColNumberNamedParam() or This.IsColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsColOrColNumberNamedParams()
			return This.IsColOrColNumberNamedParam()

		def IsColNumberOrColNamedParam()
			return This.IsColOrColNumberNamedParam()

		def IsColNumberOrColNamedParams()
			return This.IsColOrColNumberNamedParam()

	#--

	def IsOfColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfCol or This.Item(1) = :OfColumn) )

			return TRUE
		else
			return FALSE
		ok

		def IsOfColumnNamedParam()
			return This.IsOfColNamedParam()

	def IsOfColOrColumnNamedParam()
		if This.IsOfColNamedParam() or This.IsOfColumnNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsOfColumnOrColNamedParam()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColOrOfColumnNamedParam()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrOfColNamedParam()
			return This.IsOfColOrColumnNamedParam()

		#--

		def IsOfColOrColumnNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrColNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColOrOfColumnNamedParams()
			return This.IsOfColOrColumnNamedParam()

		def IsOfColumnOrOfColNamedParams()
			return This.IsOfColOrColumnNamedParam()

	#--

	def IsInColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InCol or This.Item(1) = :InColumn) )

			return TRUE
		else
			return FALSE
		ok

		def IsInColumnNamedParam()
			return This.IsInColNamedParam()

	def IsInColOrColumnNamedParam()
		if This.IsInColNamedParam() or This.IsInColumnNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsInColumnOrColNamedParam()
			return This.IsInColOrColumnNamedParam()

		def IsInColOrInColumnNamedParam()
			return This.IsInColOrColumnNamedParam()

		def IsInColumnOrInColNamedParam()
			return This.IsInColOrColumnNamedParam()

		#--

		def IsInColOrColumnNamedParams()
			return This.IsInColOrColumnNamedParam()

		def IsInColumnOrColNamedParams()
			return This.IsInColOrColumnNamedParams()

		def IsInColOrInColumnNamedParams()
			return This.IsInColOrColumnNamedParams()

		def IsInColumnOrInColNamedParams()
			return This.IsInColOrColumnNamedParam()

	#--

	def IsColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Cols or This.Item(1) = :Columns) )

			return TRUE
		else
			return FALSE
		ok

		def IsColumnsNamedParam()
			return This.IsColsNamedParam()

	def IsColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ColsNumbers or This.Item(1) = :ColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsColumnsNumbersNamedParam()
			return This.IsColsNumbersNamedParam()

	def IsColsOrColsNumberNamedParam()
		if This.IsColsNumbersNamedParam() or This.IsColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsColsNumbersOrColsNamedParam()
			return This.IsColsOrColsNumberNamedParam()

		def IsColsOrColsNumberNamedParams()
			return This.IsColsOrColsNumberNamedParam()

		def IsColsNumbersOrColsNamedParams()
			return This.IsColsOrColsNumberNamedParam()

	#--

	def IsOfColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfCols or This.Item(1) = :OfColumns) )

			return TRUE
		else
			return FALSE
		ok

		def IsOfColumnsNamedParam()
			return This.IsOfColsNamedParam()

	def IsOfColsOrColumnsNamedParam()
		if This.IsOfColsNamedParam() or This.IsOfColumnsNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsOfColumnsOrColsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColsOrOfColumnsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrOfColsNamedParam()
			return This.IsOfColsOrColumnsNamedParam()

		#--

		def IsOfColsOrColumnsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrColsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColsOrOfColumnsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

		def IsOfColumnsOrOfColsNamedParams()
			return This.IsOfColsOrColumnsNamedParam()

	#--

	def IsInColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InCols or This.Item(1) = :InColumns) )

			return TRUE
		else
			return FALSE
		ok

		def IsInColumnsNamedParam()
			return This.IsInColsNamedParam()

	def IsInColsOrColumnsNamedParam()
		if This.IsInColsNamedParam() or This.IsInColumnsNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsInColumnsOrColNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColsOrInColumnsNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrInColNamedParam()
			return This.IsInColsOrColumnsNamedParam()

		#--

		def IsInColsOrColumnsNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrColNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColsOrInColumnsNamedParams()
			return This.IsInColsOrColumnsNamedParam()

		def IsInColumnsOrInColNamedParams()
			return This.IsInColsOrColumnsNamedParam()

	#==

	def IsByColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ByColNumber or This.Item(1) = :ByColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsByColumnNumberNamedParam()
			return This.IsByColNumberNamedParam()

	def IsByColOrByColNumberNamedParam()
		if This.IsByColNumberNamedParam() or This.IsByColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByColOrByColNumberNamedParams()
			return This.IsByColOrByColNumberNamedParam()

		def IsByColNumberOrByColNamedParam()
			return This.IsByColOrByColNumberNamedParam()

		def IsByColNumberOrColNamedParams()
			return This.IsByColOrByColNumberNamedParam()

	def IsByColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ByColsNumbers or This.Item(1) = :ByColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsByColumnsNumbersNamedParam()
			return This.IsByColsNumbersNamedParam()

	def IsByColsOrByColsNumbersNamedParam()
		if This.IsByColsNumbersNamedParam() or This.IsByColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByColsOrByColsNumbersNamedParams()
			return This.IsByColsOrByColsNumbersNamedParam()

		def IsByColsNumbersOrByColsNamedParam()
			return This.IsByColsOrByColsNumbersNamedParam()

		def IsByColsNumbersOrColsNamedParams()
			return This.IsByColsOrColsNumberNamedParam()

	#--

	def IsInColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InColNumber or This.Item(1) = :InColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsInColumnNumberNamedParam()
			return This.IsInColNumberNamedParam()

	def IsInColOrInColNumberNamedParam()
		if This.IsInColNumberNamedParam() or This.IsInColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInColOrInColNumberNamedParams()
			return This.IsInColOrInColNumberNamedParam()

		def IsInColNumberOrInColNamedParam()
			return This.IsInColOrInColNumberNamedParam()

		def IsInColInNumberOrColNamedParams()
			return This.IsInColOrInColNumberNamedParam()

	def IsInColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :InColsNumbers or This.Item(1) = :InColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsInColumnsNumbersNamedParam()
			return This.IsInColsNumbersNamedParam()

	def IsInColsOrInColsNumbersNamedParam()
		if This.IsInColsNumbersNamedParam() or This.IsInColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInColsOrInColsNumbersNamedParams()
			return This.IsInColsOrInColsNumbersNamedParam()

		def IsInColsNumbersOrInColsNamedParam()
			return This.IsInColsOrinColsNumbersNamedParam()

		def IsInColsNumbersOrInColsNamedParams()
			return This.IsInColsOrInColsNumberNamedParam()

	#--

	def IsOfColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfColNumber or This.Item(1) = :OfColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsOfColumnNumberNamedParam()
			return This.IsOfColNumberNamedParam()

	def IsOfColOrOfColNumberNamedParam()
		if This.IsOfColNumberNamedParam() or This.IsOfColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfColOrOfColNumberNamedParams()
			return This.IsOfColOrOfColNumberNamedParam()

		def IsOfColNumberOrOfColNamedParam()
			return This.IsOfColOrOfColNumberNamedParam()

		def IsOfColNumberOrOfColNamedParams()
			return This.IsOfColOrOfColNumberNamedParam()

	def IsOfColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :OfColsNumbers or This.Item(1) = :OfColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsOfColumnsNumbersNamedParam()
			return This.IsOfColsNumbersNamedParam()

	def IsOfColsOrOfColsNumbersNamedParam()
		if This.IsOfColsNumbersNamedParam() or This.IsOfColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfColsOrOfColsNumbersNamedParams()
			return This.IsOfColsOrOFColsNumbersNamedParam()

		def IsOfColsNumbersOrOfColsNamedParam()
			return This.IsOfColsOrOfColsNumbersNamedParam()

		def IsOfColsNumbersOrOfColsNamedParams()
			return This.IsOfColsOrOfColsNumberNamedParam()

	#--

	def IsToColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ToColNumber or This.Item(1) = :ToColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsToColumnNumberNamedParam()
			return This.IsToColNumberNamedParam()

	def IsToColOrToColNumberNamedParam()
		if This.IsToColNumberNamedParam() or This.IsToColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToColOrToColNumberNamedParams()
			return This.IsToColOrToColNumberNamedParam()

		def IsToColNumberOrToColNamedParam()
			return This.IsToColOrToColNumberNamedParam()

		def IsToColNumberOrToColNamedParams()
			return This.IsToColOrToColNumberNamedParam()

	def IsToColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :ToColsNumbers or This.Item(1) = :ToColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsToColumnsNumbersNamedParam()
			return This.IsToColsNumbersNamedParam()

	def IsToColsOrToColsNumbersNamedParam()
		if This.IsToColsNumbersNamedParam() or This.IsToColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToColsOrToColsNumbersNamedParams()
			return This.IsToColsOrToColsNumbersNamedParam()

		def IsToColsNumbersOrToColsNamedParam()
			return This.IsToColsOrToColsNumbersNamedParam()

		def IsToColsNumbersOrtoColsNamedParams()
			return This.IsToColsOrToColsNumberNamedParam()

	#--

	def IsUsingColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :UsingColNumber or This.Item(1) = :UsingColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsUsingColumnNumberNamedParam()
			return This.IsUsingColNumberNamedParam()

	def IsUsingColOrUsingColNumberNamedParam()
		if This.IsUsingColNumberNamedParam() or This.IsUsingColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsUsingColOrUsingColNumberNamedParams()
			return This.IsUsingColOrUsingColNumberNamedParam()

		def IsUsingColNumberOrUsingColNamedParam()
			return This.IsUsingColOrUsingColNumberNamedParam()

		def IsUsingColNumberOrUsingColNamedParams()
			return This.IsUsingColOrUsingColNumberNamedParam()

	def IsUsingColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :UsingColsNumbers or This.Item(1) = :UsingColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsUsingColumnsNumbersNamedParam()
			return This.IsUsingColsNumbersNamedParam()

	def IsUsingColsOrUsingColsNumbersNamedParam()
		if This.IsUsingColsNumbersNamedParam() or This.IsUsingColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsUsingColsOrUsingColsNumbersNamedParams()
			return This.IsUsingColsOrUsingColsNumbersNamedParam()

		def IsUsingColsNumbersOrUsingColsNamedParam()
			return This.IsUsingColsOrUsingColsNumbersNamedParam()

		def IsUsingColsNumbersOrUsingColsNamedParams()
			return This.IsUsingColsOrUsingColsNumberNamedParam()

	#--

	def IsWithColNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :WithColNumber or This.Item(1) = :WithColumnNumber) )

			return TRUE
		else
			return FALSE
		ok

		def IsWithColumnNumberNamedParam()
			return This.IsWithColNumberNamedParam()

	def IsWithColOrWithColNumberNamedParam()
		if This.IsWithColNumberNamedParam() or This.IsWithColNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithColOrWithColNumberNamedParams()
			return This.IsWithColOrWithColNumberNamedParam()

		def IsWithColNumberOrWithColNamedParam()
			return This.IsWithColOrWithColNumberNamedParam()

		def IsWithColNumberOrWithColNamedParams()
			return This.IsWithColOrWithColNumberNamedParam()

	def IsWithColsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :WithColsNumbers or This.Item(1) = :WithColumnsNumbers) )

			return TRUE
		else
			return FALSE
		ok

		def IsWithColumnsNumbersNamedParam()
			return This.IsWithColsNumbersNamedParam()

	def IsWithColsOrWithColsNumbersNamedParam()
		if This.IsWithColsNumbersNamedParam() or This.IsWithColsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithColsOrWithColsNumbersNamedParams()
			return This.IsWithColsOrWithColsNumbersNamedParam()

		def IsWithColsNumbersOrWithColsNamedParam()
			return This.IsWithColsOrWithColsNumbersNamedParam()

		def IsWithColsNumbersOrWithColsNamedParams()
			return This.IsWithColsOrColsNumberNamedParam()

	#==

	def IsByRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ByRowNumber )

			return TRUE
		else
			return FALSE
		ok


	def IsByRowOrByRowNumberNamedParam()
		if This.IsByRowNumberNamedParam() or This.IsByRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByRowOrByRowNumberNamedParams()
			return This.IsByRowOrByRowNumberNamedParam()

		def IsByRowNumberOrByRowNamedParam()
			return This.IsByRowOrByRowNumberNamedParam()

		def IsByRowNumberOrByRowNamedParams()
			return This.IsByRowOrByRowNumberNamedParam()

	def IsByRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ByRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsByRowsOrByRowsNumbersNamedParam()
		if This.IsByRowsNumbersNamedParam() or This.IsByRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByRowsOrByRowsNumbersNamedParams()
			return This.IsByRowsOrByRowsNumbersNamedParam()

		def IsByRowsNumbersOrByRowsNamedParam()
			return This.IsByRowsOrByRowsNumbersNamedParam()

		def IsByRowsNumbersOrByRowsNamedParams()
			return This.IsByRowsOrByRowsNumberNamedParam()

	#--

	def IsInRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRowNumber )

			return TRUE
		else
			return FALSE
		ok

	def IsInRowOrInRowNumberNamedParam()
		if This.IsInRowNumberNamedParam() or This.IsInRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInRowOrInRowNumberNamedParams()
			return This.IsInRowOrInRowNumberNamedParam()

		def IsInRowNumberOrInRowNamedParam()
			return This.IsInRowOrInRowNumberNamedParam()

		def IsInRowNumberOrInRowNamedParams()
			return This.IsInRowOrInRowNumberNamedParam()

	def IsInRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsInRowsOrInRowsNumbersNamedParam()
		if This.IsInRowsNumbersNamedParam() or This.IsInRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInRowsOrInRowsNumbersNamedParams()
			return This.IsInRowsOrInRowsNumbersNamedParam()

		def IsInRowsNumbersOrInRowsNamedParam()
			return This.IsInRowsOrInRowsNumbersNamedParam()

		def IsInRowsNumbersOrInRowsNamedParams()
			return This.IsInRowsOrInRowsNumberNamedParam()

	#--

	def IsOfRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRowNumber )

			return TRUE
		else
			return FALSE
		ok

	def IsOfRowOrOfRowNumberNamedParam()
		if This.IsOfRowNumberNamedParam() or This.IsOfRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfRowOrOfRowNumberNamedParams()
			return This.IsOfRowOrOfRowNumberNamedParam()

		def IsOfRowNumberOrOfRowNamedParam()
			return This.IsOfRowOrOfRowNumberNamedParam()

		def IsOfRowNumberOrOfRowNamedParams()
			return This.IsOfRowOrOfRowNumberNamedParam()

	def IsOfRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsOfRowsOrOfRowsNumbersNamedParam()
		if This.IsOfRowsNumbersNamedParam() or This.IsOfRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfRowsOrOfRowsNumbersNamedParams()
			return This.IsOfRowsOrOfRowsNumbersNamedParam()

		def IsOfRowsNumbersOrOfRowsNamedParam()
			return This.IsOfRowsOrOfRowsNumbersNamedParam()

		def IsOfRowsNumbersOrOfRowsNamedParams()
			return This.IsOfRowsOrOfRowsNumberNamedParam()

	#--

	def IsToRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToRowNumber )

			return TRUE
		else
			return FALSE
		ok

	def IsToRowOrToRowNumberNamedParam()
		if This.IsToRowNumberNamedParam() or This.IsToRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToRowOrToRowNumberNamedParams()
			return This.IsToRowOrToRowNumberNamedParam()

		def IsToRowNumberOrToRowNamedParam()
			return This.IsToRowOrToRowNumberNamedParam()

		def IsToRowNumberOrToRowNamedParams()
			return This.IsToRowOrToRowNumberNamedParam()

	def IsToRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsToRowsOrToRowsNumbersNamedParam()
		if This.IsToRowsNumbersNamedParam() or This.IsToRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToRowsOrToRowsNumbersNamedParams()
			return This.IsToRowsOrToRowsNumbersNamedParam()

		def IsToRowsNumbersOrToRowsNamedParam()
			return This.IsToRowsOrToRowsNumbersNamedParam()

		def IsToRowsNumbersOrToRowsNamedParams()
			return This.IsToRowsOrToRowsNumberNamedParam()

	#--

	def IsUsingRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingRowNumber )

			return TRUE
		else
			return FALSE
		ok

	def IsUsingRowOrUsingRowNumberNamedParam()
		if This.IsUsingRowNumberNamedParam() or This.IsUsingRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsUsingRowOrUsingRowNumberNamedParams()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

		def IsUsingRowNumberOrUsingRowNamedParam()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

		def IsUsingRowNumberOrUsingRowNamedParams()
			return This.IsUsingRowOrUsingRowNumberNamedParam()

	def IsUsingRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsUsingRowsOrUsingRowsNumbersNamedParam()
		if This.IsUsingRowsNumbersNamedParam() or This.IsUsingRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsUsingRowsOrUsingRowsNumbersNamedParams()
			return This.IsUsingRowsOrUsingRowsNumbersNamedParam()

		def IsUsingRowsNumbersOrUsingRowsNamedParam()
			return This.IsUsingRowsOrUsingRowsNumbersNamedParam()

		def IsUsingRowsNumbersOrUsingRowsNamedParams()
			return This.IsUsingRowsOrUsingRowsNumberNamedParam()

	#--

	def IsWithRowNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :WithRowNumber )

			return TRUE
		else
			return FALSE
		ok

	def IsWithRowOrWithRowNumberNamedParam()
		if This.IsWithRowNumberNamedParam() or This.IsWithRowNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithRowOrWithRowNumberNamedParams()
			return This.IsWithRowOrWithRowNumberNamedParam()

		def IsWithRowNumberOrWithRowNamedParam()
			return This.IsWithRowOrWithRowNumberNamedParam()

		def IsWithRowNumberOrWithRowNamedParams()
			return This.IsWithRowOrWithRowNumberNamedParam()

	def IsWithRowsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :WithRowsNumbers )

			return TRUE
		else
			return FALSE
		ok

	def IsWithRowsOrWithRowsNumbersNamedParam()
		if This.IsWithRowsNumbersNamedParam() or This.IsWithRowsNumbersNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithRowsOrWithRowsNumbersNamedParams()
			return This.IsWithRowsOrWithRowsNumbersNamedParam()

		def IsWithRowsNumbersOrWithRowsNamedParam()
			return This.IsWithRowsOrWithRowsNumbersNamedParam()

		def IsWithRowsNumbersOrWithRowsNamedParams()
			return This.IsWithRowsOrWithRowsNumberNamedParam()

	#==

	def IsRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Row)

			return TRUE
		else
			return FALSE
		ok

	def IsOfRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRow)

			return TRUE
		else
			return FALSE
		ok

	def IsInRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRow)

			return TRUE
		else
			return FALSE
		ok

	def IsRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Rows)

			return TRUE
		else
			return FALSE
		ok

	def IsOfRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfRows)

			return TRUE
		else
			return FALSE
		ok

	def IsInRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InRows)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Occurrence)

			return TRUE
		else
			return FALSE
		ok

	def IsNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Nth)

			return TRUE
		else
			return FALSE
		ok

	def IsNthOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NthOccurrence)

			return TRUE
		else
			return FALSE
		ok

	def IsNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :N)

			return TRUE
		else
			return FALSE
		ok
	#--

	def IsCaseSensitiveNamedParam()
		aContent = This.Content()
		nLen = len(aContent)

		if NOT nLen = 2
			return FALSE
		ok

		if NOT isString(aContent[1])
			return FALSE
		ok

		if NOT isNumber(aContent[2])
			return FALSE
		ok

		if NOT ( aContent[1] = :CaseSensitive or aContent[1] = :CS )
			return FALSE
		ok

		if NOT ( aContent[2] = 0 or aContent[2] = 1 )
			return FALSE
		ok

		return TRUE

	def IsRangeNamedParam()

		if This.IsEmpty()
			return TRUE
		ok

		if NOT (This.IsHashList() and This.NumberOfItems() <= 2)
			return FALSE
		ok

		if This.NumberOfItems() = 1

			if This.Item(1)[1] = :Start or This.Item(1)[1] = :Range
				return TRUE
			ok
		ok

		if This.NumberOfItems() = 2

			if StzHashListQ( This.List() ).KeysQ().IsEqualTo([ :Start, :Range ]) and
			   StzHashListQ( This.List() ).ValuesQ().BothAreNumbers()

				return TRUE

			else

				return FALSE
			ok
		ok


	#--

	def IsStartingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStartingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStartingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartingAtOccurrence )

			return TRUE

		else
			return FALSE
		ok

	def IsStartAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStartAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStartAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StartAtOccurrence )

			return TRUE

		else
			return FALSE
		ok


	#--

	def IsEndiingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAt )

			return TRUE

		else
			return FALSE
		ok

	def IsEndingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsEndingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EndingAtOccurrence )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsStoppingAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStoppingAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStoppingAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StoppingAtOccurrence )

			return TRUE

		else
			return FALSE
		ok

	def IsStopAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStopAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStopAtOccurrenceNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StopAtOccurrence )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsInStringNNamedParam()
		if This.NumberOfItems() = 2 and

		   ( isString(This.Item(1)) and Q(This.Item(1)).IsOneOfThese([
					:InStringAt, :InStringItemAt,
					:inStringAtPosition, :InStringItemAtPosition,
					:InStringN, :InStringItemN ]) )

			return TRUE

		else
			return FALSE
		ok

		def IsInStringItemNNamedParam()
			return This.IsInStringNNamedParam()

		def IsInStringAtPositionNNamedParam()
			return This.IsInStringNNamedParam()

		def IsInStringAtPositionNamedParam()
			return This.IsInStringNNamedParam()

	def IsExceptNamedParam()
		# Used initially by ReplaceWordsWithMarquersExceptXT(pcByOption, paExcept)
		#TODO: generalize to all the functions we want to provide exceptions to it

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Except )

			return TRUE

		else
			return FALSE
		ok

	def IsAsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :As )

			return TRUE

		else
			return FALSE
		ok

	def IsThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :Then or This.Item(1) = :Then@) )

			return TRUE

		else
			return FALSE
		ok

	def IsAndThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AndThen or This.Item(1) = :AndThen@) )

			return TRUE

		else
			return FALSE
		ok

	def IsFromFileNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and  This.Item(1) = :FromFile

			return TRUE

		else
			return FALSE
		ok

	def IsFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :From or This.Item(1) = :FromPosition)  )

			return TRUE

		else
			return FALSE
		ok

	def IsFromOrOfNamedParam()
		if This.IsFromNamedParam() or This.IsOfNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsFromOrOfNamedParams()
			return This.IsFromOrOfNamedParam()

		def IsOfOrFromNamedParam()
			return This.IsFromOrOfNamedParam()

		def IsOfOrFromNamedParams()
			return This.IsFromOrOfNamedParam()

	#--

	def IsFromCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCell )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCellAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCellAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCells )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCellsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCellsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCellsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsToCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCell )

			return TRUE

		else
			return FALSE
		ok

	def IsToCellAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToCellAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToCellsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCells )

			return TRUE

		else
			return FALSE
		ok

	def IsToCellsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToCellsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCellsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Value )

			return TRUE

		else
			return FALSE
		ok

	def IsOfValueNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfValue )

			return TRUE

		else
			return FALSE
		ok

	def IsValuesNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Values )

			return TRUE

		else
			return FALSE
		ok

	def IsStringOrSubStringNamedParam()
		if This.IsStringNamedPAram() or This.IsSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsStringOrSubStringNamedParams()
			return This.IsStringOrSubStringNamedParam()

		def IsSubStringOrStringONamedParam()
			return This.IsStringOrSubStringNamedParam()

		def IsSubStringOrStringONamedParams()
			return This.IsStringOrSubStringNamedParam()

	#--

	def IsToOrOfNamedParam()
		if This.IsToNamedParam() or This.IsOfNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsToOrOfNamedParams()
			return This.IsToOrOfNamedParam()

		def IsOfOrToNamedParam()
			return This.IsToOrOfNamedParam()

		def IsOfOrToNamedParams()
			return This.IsToOrOfNamedParam()

	#==

	def IsToNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsToNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToString )

			return TRUE

		else
			return FALSE
		ok

	def IsToSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsToSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSubStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsToCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToChar )

			return TRUE

		else
			return FALSE
		ok

	def IsToListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToList )

			return TRUE

		else
			return FALSE
		ok

	def IsToListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToLists )

			return TRUE

		else
			return FALSE
		ok

	def IsToPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPair )

			return TRUE

		else
			return FALSE
		ok

	def IsToHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsToSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToSet )

			return TRUE

		else
			return FALSE
		ok

	def IsToObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToObject )

			return TRUE

		else
			return FALSE
		ok

	def IsToObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToObjects )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsToOrToNumberNamedParam()
		if This.IsToNamedParam() or This.IsToNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToNumberOrToNamedParam()
			return This.IsToOrToNumberNamedParam()

		def IsToOrToNumberNamedParams()
			return This.IsToOrToNumberNamedParam()

		def IsToNumberOrToNamedParams()
			return This.IsToOrToNumberNamedParam()

	def IsToOrToCharNamedParam()
		if This.IsToNamedParam() or This.IsToCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToCharOrToNamedParam()
			return This.IsToOrToCharNamedParam()

		def IsToOrToCharNamedParams()
			return This.IsToOrToCharNamedParam()

		def IsToCharOrToNamedParams()
			return This.IsToOrToCharNamedParam()

	def IsToOrToStringNamedParam()
		if This.IsToNamedParam() or This.IsToStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToStringOrToNamedParam()
			return This.IsToOrToStringNamedParam()

		def IsToOrToStringNamedParams()
			return This.IsToOrToStringNamedParam()

		def IsToStringOrToNamedParams()
			return This.IsToOrToStringNamedParam()

	def IsToOrToSubStringNamedParam()
		if This.IsToNamedParam() or This.IsToSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToSubStringOrToNamedParam()
			return This.IsToOrToSubStringNamedParam()

		def IsToOrToSubStringNamedParams()
			return This.IsToOrToSubStringNamedParam()

		def IsToSubStringOrToNamedParams()
			return This.IsToOrToSubStringNamedParam()

	def IsToOrToListNamedParam()
		if This.IsToNamedParam() or This.IsToListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToListOrToNamedParam()
			return This.IsToOrToListNamedParam()

		def IsToOrToListNamedParams()
			return This.IsToOrToListNamedParam()

		def IsToListOrToNamedParams()
			return This.IsToOrToListNamedParam()

	def IsToOrToHashListNamedParam()
		if This.IsToNamedParam() or This.IsToHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToHashListOrToNamedParam()
			return This.IsToOrToHashListNamedParam()

		def IsToOrToHashListNamedParams()
			return This.IsToOrToHashListNamedParam()

		def IsToHashListOrToNamedParams()
			return This.IsToOrToHashListNamedParam()

	def IsToOrToPairNamedParam()
		if This.IsToNamedParam() or This.IsToPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToPairOrToNamedParam()
			return This.IsToOrToPairNamedParam()

		def IsToOrToPairNamedParams()
			return This.IsToOrToPairNamedParam()

		def IsToPairOrToNamedParams()
			return This.IsToOrToPairNamedParam()

	def IsToOrToSetNamedParam()
		if This.IsToNamedParam() or This.IsToSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToSetOrToNamedParam()
			return This.IsToOrToSetNamedParam()

		def IsToOrToSetNamedParams()
			return This.IsToOrToSetNamedParam()

		def IsToSetOrToNamedParams()
			return This.IsToOrToSetNamedParam()

	def IsToOrToObjectNamedParam()
		if This.IsToNamedParam() or This.IsToObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsToStringOrToObjectParam()
			return This.IsToOrToStringNamedParam()

		def IsToOrToObjectNamedParams()
			return This.IsToOrToObjectNamedParam()

		def IsToStringOrToObjectParams()
			return This.IsToOrToStringNamedParam()

	#==

	def IsOfNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfString )

			return TRUE

		else
			return FALSE
		ok

	def IsOfSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfChar )

			return TRUE

		else
			return FALSE
		ok

	def IsOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfList )

			return TRUE

		else
			return FALSE
		ok

	def IsOfPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfPair )

			return TRUE

		else
			return FALSE
		ok

	def IsOfHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsOfSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSet )

			return TRUE

		else
			return FALSE
		ok

	def IsOfObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsOfOrOfNumberNamedParam()
		if This.IsOfNamedParam() or This.IsOfNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfNumberOrOfNamedParam()
			return This.IsOfOrOfNumberNamedParam()

		def IsOfOrOfNumberNamedParams()
			return This.IsOfOrOfNumberNamedParam()

		def IsOfNumberOrOfNamedParams()
			return This.IsOfOrOfNumberNamedParam()

	def IsOfOrOfCharNamedParam()
		if This.IsOfNamedParam() or This.IsOfCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfCharOrOfNamedParam()
			return This.IsOfOrOfCharNamedParam()

		def IsOfOrOfCharNamedParams()
			return This.IsOfOrOfCharNamedParam()

		def IsOfCharOrOfNamedParams()
			return This.IsOfOrOfCharNamedParam()

	def IsOfOrOfStringNamedParam()
		if This.IsOfNamedParam() or This.IsOfStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfStringOrOfNamedParam()
			return This.IsOfOrOfStringNamedParam()

		def IsOfOrOfStringNamedParams()
			return This.IsOfOrOfStringNamedParam()

		def IsOfStringOrOfNamedParams()
			return This.IsOfOrOfStringNamedParam()

	def IsOfOrOfSubStringNamedParam()
		if This.IsOfNamedParam() or This.IsOfSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfSubStringOrOfNamedParam()
			return This.IsOfOrOfSubStringNamedParam()

		def IsOfOrOfSubStringNamedParams()
			return This.IsOfOrOfSubStringNamedParam()

		def IsOfSubStringOrOfNamedParams()
			return This.IsOfOrOfSubStringNamedParam()

	def IsOfOrOfListNamedParam()
		if This.IsOfNamedParam() or This.IsOfListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfListOrOfNamedParam()
			return This.IsOfOrOfListNamedParam()

		def IsOfOrOfListNamedParams()
			return This.IsOfOrOfListNamedParam()

		def IsOfListOrOfNamedParams()
			return This.IsOfOrOfListNamedParam()

	def IsOfOrOfHashListNamedParam()
		if This.IsOfNamedParam() or This.IsOfHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfHashListOrOfNamedParam()
			return This.IsOfOrOfHashListNamedParam()

		def IsOfOrOfHashListNamedParams()
			return This.IsOfOrOfHashListNamedParam()

		def IsOfHashListOrOfNamedParams()
			return This.IsOfOrOfHashListNamedParam()

	def IsOfOrOfPairNamedParam()
		if This.IsOfNamedParam() or This.IsOfPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfPairOrOfNamedParam()
			return This.IsOfOrOfPairNamedParam()

		def IsOfOrOfPairNamedParams()
			return This.IsOfOrOfPairNamedParam()

		def IsOfPairOrOfNamedParams()
			return This.IsOfOrOfPairNamedParam()

	def IsOfOrOfSetNamedParam()
		if This.IsOfNamedParam() or This.IsOfSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfSetOrOfNamedParam()
			return This.IsOfOrOfSetNamedParam()

		def IsOfOrOfSetNamedParams()
			return This.IsOfOrOfSetNamedParam()

		def IsOfSetOrOfNamedParams()
			return This.IsOfOrOfSetNamedParam()

	def IsOfOrOfObjectNamedParam()
		if This.IsOfNamedParam() or This.IsOfObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOfStringOrOfObjectParam()
			return This.IsOfOrOfStringNamedParam()

		def IsOfOrOfObjectNamedParams()
			return This.IsOfOrOfObjectNamedParam()

		def IsOfStringOrOfObjectParams()
			return This.IsOfOrOfStringNamedParam()

	#==

	def IsByNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsByStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByString )

			return TRUE

		else
			return FALSE
		ok

	def IsBySubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BySubString )

			return TRUE

		else
			return FALSE
		ok

	def IsByCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByChar )

			return TRUE

		else
			return FALSE
		ok

	def IsByListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByList )

			return TRUE

		else
			return FALSE
		ok

	def IsByPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByPair )

			return TRUE

		else
			return FALSE
		ok

	def IsByHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsBySetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BySet )

			return TRUE

		else
			return FALSE
		ok

	def IsByObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsByOrByNumberNamedParam()
		if This.IsByNamedParam() or This.IsByNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByNumberOrByNamedParam()
			return This.IsByOrByNumberNamedParam()

		def IsByOrByNumberNamedParams()
			return This.IsByOrByNumberNamedParam()

		def IsByNumberOrByNamedParams()
			return This.IsByOrByNumberNamedParam()

	def IsByOrByCharNamedParam()
		if This.IsByNamedParam() or This.IsByCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByCharOrByNamedParam()
			return This.IsByOrByCharNamedParam()

		def IsByOrByCharNamedParams()
			return This.IsByOrByCharNamedParam()

		def IsByCharOrByNamedParams()
			return This.IsByOrByCharNamedParam()

	def IsByOrByStringNamedParam()
		if This.IsByNamedParam() or This.IsByStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByStringOrByNamedParam()
			return This.IsByOrByStringNamedParam()

		def IsByOrByStringNamedParams()
			return This.IsByOrByStringNamedParam()

		def IsByStringOrByNamedParams()
			return This.IsByOrByStringNamedParam()

	def IsByOrBySubStringNamedParam()
		if This.IsByNamedParam() or This.IsBySubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsBySubStringOrByNamedParam()
			return This.IsByOrBySubStringNamedParam()

		def IsByOrBySubStringNamedParams()
			return This.IsByOrBySubStringNamedParam()

		def IsBySubStringOrByNamedParams()
			return This.IsByOrBySubStringNamedParam()

	def IsByOrByListNamedParam()
		if This.IsByNamedParam() or This.IsByListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByListOrByNamedParam()
			return This.IsByOrByListNamedParam()

		def IsByOrByListNamedParams()
			return This.IsByOrByListNamedParam()

		def IsByListOrByNamedParams()
			return This.IsByOrByListNamedParam()

	def IsByOrByHashListNamedParam()
		if This.IsByNamedParam() or This.IsByHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByHashListOrByNamedParam()
			return This.IsByOrByHashListNamedParam()

		def IsByOrByHashListNamedParams()
			return This.IsByOrByHashListNamedParam()

		def IsByHashListOrByNamedParams()
			return This.IsByOrByHashListNamedParam()

	def IsByOrByPairNamedParam()
		if This.IsByNamedParam() or This.IsByPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByPairOrByNamedParam()
			return This.IsByOrByPairNamedParam()

		def IsByOrByPairNamedParams()
			return This.IsByOrByPairNamedParam()

		def IsByPairOrByNamedParams()
			return This.IsByOrByPairNamedParam()

	def IsByOrBySetNamedParam()
		if This.IsByNamedParam() or This.IsBySetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsBySetOrByNamedParam()
			return This.IsByOrBySetNamedParam()

		def IsByOrBySetNamedParams()
			return This.IsByOrBySetNamedParam()

		def IsBySetOrByNamedParams()
			return This.IsByOrBySetNamedParam()

	def IsByOrByObjectNamedParam()
		if This.IsByNamedParam() or This.IsByObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByStringOrByObjectParam()
			return This.IsByOrByStringNamedParam()

		def IsByOrByObjectNamedParams()
			return This.IsByOrByObjectNamedParam()

		def IsByStringOrByObjectParams()
			return This.IsByOrByStringNamedParam()

	#==

	def IsInNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsInStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InString )

			return TRUE

		else
			return FALSE
		ok

	def IsInSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsInCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InChar )

			return TRUE

		else
			return FALSE
		ok

	def IsInListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InList )

			return TRUE

		else
			return FALSE
		ok

	def IsInPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InPair )

			return TRUE

		else
			return FALSE
		ok

	def IsInHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsInSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InSet )

			return TRUE

		else
			return FALSE
		ok

	def IsInObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsInOrInNumberNamedParam()
		if This.IsInNamedParam() or This.IsInNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInNumberOrInNamedParam()
			return This.IsInOrInNumberNamedParam()

		def IsInOrInNumberNamedParams()
			return This.IsInOrInNumberNamedParam()

		def IsInNumberOrInNamedParams()
			return This.IsInOrInNumberNamedParam()

	def IsInOrInCharNamedParam()
		if This.IsInNamedParam() or This.IsInCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInCharOrInNamedParam()
			return This.IsInOrInCharNamedParam()

		def IsInOrInCharNamedParams()
			return This.IsInOrInCharNamedParam()

		def IsInCharOrInNamedParams()
			return This.IsInOrInCharNamedParam()

	def IsInOrInStringNamedParam()
		if This.IsInNamedParam() or This.IsInStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInStringOrInNamedParam()
			return This.IsInOrInStringNamedParam()

		def IsInOrInStringNamedParams()
			return This.IsInOrInStringNamedParam()

		def IsInStringOrInNamedParams()
			return This.IsInOrInStringNamedParam()

	def IsInOrInSubStringNamedParam()
		if This.IsInNamedParam() or This.IsInSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInSubStringOrInNamedParam()
			return This.IsInOrInSubStringNamedParam()

		def IsInOrInSubStringNamedParams()
			return This.IsInOrInSubStringNamedParam()

		def IsInSubStringOrInNamedParams()
			return This.IsInOrInSubStringNamedParam()

	def IsInOrInListNamedParam()
		if This.IsInNamedParam() or This.IsInListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInListOrInNamedParam()
			return This.IsInOrInListNamedParam()

		def IsInOrInListNamedParams()
			return This.IsInOrInListNamedParam()

		def IsInListOrInNamedParams()
			return This.IsInOrInListNamedParam()

	def IsInOrInHashListNamedParam()
		if This.IsInNamedParam() or This.IsInHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInHashListOrInNamedParam()
			return This.IsInOrInHashListNamedParam()

		def IsInOrInHashListNamedParams()
			return This.IsInOrInHashListNamedParam()

		def IsInHashListOrInNamedParams()
			return This.IsInOrInHashListNamedParam()

	def IsInOrInPairNamedParam()
		if This.IsInNamedParam() or This.IsInPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInPairOrInNamedParam()
			return This.IsInOrInPairNamedParam()

		def IsInOrInPairNamedParams()
			return This.IsInOrInPairNamedParam()

		def IsInPairOrInNamedParams()
			return This.IsInOrInPairNamedParam()

	def IsInOrInSetNamedParam()
		if This.IsInNamedParam() or This.IsInSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInSetOrInNamedParam()
			return This.IsInOrInSetNamedParam()

		def IsInOrInSetNamedParams()
			return This.IsInOrInSetNamedParam()

		def IsInSetOrInNamedParams()
			return This.IsInOrInSetNamedParam()

	def IsInOrInObjectNamedParam()
		if This.IsInNamedParam() or This.IsInObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInObjectOrInNamedParam()
			return This.IsInOrInStringNamedParam()

		def IsInOrInObjectNamedParams()
			return This.IsInOrInObjectNamedParam()

		def IsInObjectOrInNamedParams()
			return This.IsInOrInObjectNamedParam()

	#==

	def IsWithNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsWithStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithString )

			return TRUE

		else
			return FALSE
		ok

	def IsWithSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsWithCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithChar )

			return TRUE

		else
			return FALSE
		ok

	def IsWithListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithList )

			return TRUE

		else
			return FALSE
		ok

	def IsWithPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithPair )

			return TRUE

		else
			return FALSE
		ok

	def IsWithHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsWithSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithSet )

			return TRUE

		else
			return FALSE
		ok

	def IsWithObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsWithOrWithNumberNamedParam()
		if This.IsWithNamedParam() or This.IsWithNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithNumberOrWithNamedParam()
			return This.IsWithOrWithNumberNamedParam()

		def IsWithOrWithNumberNamedParams()
			return This.IsWithOrWithNumberNamedParam()

		def IsWithNumberOrWithNamedParams()
			return This.IsWithOrWithNumberNamedParam()

	def IsWithOrWithCharNamedParam()
		if This.IsWithNamedParam() or This.IsWithCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithCharOrWithNamedParam()
			return This.IsWithOrWithCharNamedParam()

		def IsWithOrWithCharNamedParams()
			return This.IsWithOrWithCharNamedParam()

		def IsWithCharOrWithNamedParams()
			return This.IsWithOrWithCharNamedParam()

	def IsWithOrWithStringNamedParam()
		if This.IsWithNamedParam() or This.IsWithStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithStringOrWithNamedParam()
			return This.IsWithOrWithStringNamedParam()

		def IsWithOrWithStringNamedParams()
			return This.IsWithOrWithStringNamedParam()

		def IsWithStringOrWithNamedParams()
			return This.IsWithOrWithStringNamedParam()

	def IsWithOrWithSubStringNamedParam()
		if This.IsWithNamedParam() or This.IsWithSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithSubStringOrWithNamedParam()
			return This.IsWithOrWithSubStringNamedParam()

		def IsWithOrWithSubStringNamedParams()
			return This.IsWithOrWithSubStringNamedParam()

		def IsWithSubStringOrWithNamedParams()
			return This.IsWithOrWithSubStringNamedParam()

	def IsWithOrWithListNamedParam()
		if This.IsWithNamedParam() or This.IsWithListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithListOrWithNamedParam()
			return This.IsWithOrWithListNamedParam()

		def IsWithOrWithListNamedParams()
			return This.IsWithOrWithListNamedParam()

		def IsWithListOrWithNamedParams()
			return This.IsWithOrWithListNamedParam()

	def IsWithOrWithHashListNamedParam()
		if This.IsWithNamedParam() or This.IsWithHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithHashListOrWithNamedParam()
			return This.IsWithOrWithHashListNamedParam()

		def IsWithOrWithHashListNamedParams()
			return This.IsWithOrWithHashListNamedParam()

		def IsWithHashListOrWithNamedParams()
			return This.IsWithOrWithHashListNamedParam()

	def IsWithOrWithPairNamedParam()
		if This.IsWithNamedParam() or This.IsWithPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithPairOrWithNamedParam()
			return This.IsWithOrWithPairNamedParam()

		def IsWithOrWithPairNamedParams()
			return This.IsWithOrWithPairNamedParam()

		def IsWithPairOrWithNamedParams()
			return This.IsWithOrWithPairNamedParam()

	def IsWithOrWithSetNamedParam()
		if This.IsWithNamedParam() or This.IsWithSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithSetOrWithNamedParam()
			return This.IsWithOrWithSetNamedParam()

		def IsWithOrWithSetNamedParams()
			return This.IsWithOrWithSetNamedParam()

		def IsWithSetOrWithNamedParams()
			return This.IsWithOrWithSetNamedParam()

	def IsWithOrWithObjectNamedParam()
		if This.IsWithNamedParam() or This.IsWithObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithObjectOrWithNamedParam()
			return This.IsWithOrWithObjectNamedParam()

		def IsWithOrWithObjectNamedParams()
			return This.IsWithOrWithObjectNamedParam()

		def IsWithObjectOrWithNamedParams()
			return This.IsWithOrWithObjectNamedParam()

	#==

	def IsInsideNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideString )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideChar )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideList )

			return TRUE

		else
			return FALSE
		ok

	def IsInsidePairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsidePair )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideSet )

			return TRUE

		else
			return FALSE
		ok

	def IsInsideObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InsideObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsInsideOrInsideNumberNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideNumberOrInsideNamedParam()
			return This.IsInsideOrInsideNumberNamedParam()

		def IsInsideOrInsideNumberNamedParams()
			return This.IsInsideOrInsideNumberNamedParam()

		def IsInsideNumberOrInsideNamedParams()
			return This.IsInsideOrInsideNumberNamedParam()

	def IsInsideOrInsideCharNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideCharOrInsideNamedParam()
			return This.IsInsideOrInsideCharNamedParam()

		def IsInsideOrInsideCharNamedParams()
			return This.IsInsideOrInsideCharNamedParam()

		def IsInsideCharOrInsideNamedParams()
			return This.IsInsideOrInsideCharNamedParam()

	def IsInsideOrInsideStringNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideStringOrInsideNamedParam()
			return This.IsInsideOrInsideStringNamedParam()

		def IsInsideOrInsideStringNamedParams()
			return This.IsInsideOrInsideStringNamedParam()

		def IsInsideStringOrInsideNamedParams()
			return This.IsInsideOrInsideStringNamedParam()

	def IsInsideOrInsideSubStringNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideSubStringOrInsideNamedParam()
			return This.IsInsideOrInsideSubStringNamedParam()

		def IsInsideOrInsideSubStringNamedParams()
			return This.IsInsideOrInsideSubStringNamedParam()

		def IsInsideSubStringOrInsideNamedParams()
			return This.IsInsideOrInsideSubStringNamedParam()

	def IsInsideOrInsideListNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideListOrInsideNamedParam()
			return This.IsInsideOrInsideListNamedParam()

		def IsInsideOrInsideListNamedParams()
			return This.IsInsideOrInsideListNamedParam()

		def IsInsideListOrInsideNamedParams()
			return This.IsInsideOrInsideListNamedParam()

	def IsInsideOrInsideHashListNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideHashListOrInsideNamedParam()
			return This.IsInsideOrInsideHashListNamedParam()

		def IsInsideOrInsideHashListNamedParams()
			return This.IsInsideOrInsideHashListNamedParam()

		def IsInsideHashListOrInsideNamedParams()
			return This.IsInsideOrInsideHashListNamedParam()

	def IsInsideOrInsidePairNamedParam()
		if This.IsInsideNamedParam() or This.IsInsidePairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsidePairOrInsideNamedParam()
			return This.IsInsideOrInsidePairNamedParam()

		def IsInsideOrInsidePairNamedParams()
			return This.IsInsideOrInsidePairNamedParam()

		def IsInsidePairOrInsideNamedParams()
			return This.IsInsideOrInsidePairNamedParam()

	def IsInsideOrInsideSetNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideSetOrInsideNamedParam()
			return This.IsInsideOrInsideSetNamedParam()

		def IsInsideOrInsideSetNamedParams()
			return This.IsInsideOrInsideSetNamedParam()

		def IsInsideSetOrInsideNamedParams()
			return This.IsInsideOrInsideSetNamedParam()

	def IsInsideOrInsideObjectNamedParam()
		if This.IsInsideNamedParam() or This.IsInsideObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsInsideObjectOrInsideNamedParam()
			return This.IsInsideOrInsideObjectNamedParam()

		def IsInsideOrInsideObjectNamedParams()
			return This.IsInsideOrInsideObjectNamedParam()

		def IsInsideObjectOrInsideNamedParams()
			return This.IsInsideOrInsideObjectNamedParam()

	#==

	def IsOnNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsOnStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnString )

			return TRUE

		else
			return FALSE
		ok

	def IsOnSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsOnCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnChar )

			return TRUE

		else
			return FALSE
		ok

	def IsOnListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnList )

			return TRUE

		else
			return FALSE
		ok

	def IsOnPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnPair )

			return TRUE

		else
			return FALSE
		ok

	def IsOnHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsOnSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnSet )

			return TRUE

		else
			return FALSE
		ok

	def IsOnObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OnObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsOnOrOnNumberNamedParam()
		if This.IsOnNamedParam() or This.IsOnNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnNumberOrOnNamedParam()
			return This.IsOnOrOnNumberNamedParam()

		def IsOnOrOnNumberNamedParams()
			return This.IsOnOrOnNumberNamedParam()

		def IsOnNumberOrOnNamedParams()
			return This.IsOnOrOnNumberNamedParam()

	def IsOnOrOnCharNamedParam()
		if This.IsOnNamedParam() or This.IsOnCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnCharOrOnNamedParam()
			return This.IsOnOrOnCharNamedParam()

		def IsOnOrOnCharNamedParams()
			return This.IsOnOrOnCharNamedParam()

		def IsOnCharOrOnNamedParams()
			return This.IsOnOrOnCharNamedParam()

	def IsOnOrOnStringNamedParam()
		if This.IsOnNamedParam() or This.IsOnStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnStringOrOnNamedParam()
			return This.IsOnOrOnStringNamedParam()

		def IsOnOrOnStringNamedParams()
			return This.IsOnOrOnStringNamedParam()

		def IsOnStringOrOnNamedParams()
			return This.IsOnOrOnStringNamedParam()

	def IsOnOrOnSubStringNamedParam()
		if This.IsOnNamedParam() or This.IsOnSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnSubStringOrOnNamedParam()
			return This.IsOnOrOnSubStringNamedParam()

		def IsOnOrOnSubStringNamedParams()
			return This.IsOnOrOnSubStringNamedParam()

		def IsOnSubStringOrOnNamedParams()
			return This.IsOnOrOnSubStringNamedParam()

	def IsOnOrOnListNamedParam()
		if This.IsOnNamedParam() or This.IsOnListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnListOrOnNamedParam()
			return This.IsOnOrOnListNamedParam()

		def IsOnOrOnListNamedParams()
			return This.IsOnOrOnListNamedParam()

		def IsOnListOrOnNamedParams()
			return This.IsOnOrOnListNamedParam()

	def IsOnOrOnHashListNamedParam()
		if This.IsOnNamedParam() or This.IsOnHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnHashListOrOnNamedParam()
			return This.IsOnOrOnHashListNamedParam()

		def IsOnOrOnHashListNamedParams()
			return This.IsOnOrOnHashListNamedParam()

		def IsOnHashListOrOnNamedParams()
			return This.IsOnOrOnHashListNamedParam()

	def IsOnOrOnPairNamedParam()
		if This.IsOnNamedParam() or This.IsOnPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnPairOrOnNamedParam()
			return This.IsOnOrOnPairNamedParam()

		def IsOnOrOnPairNamedParams()
			return This.IsOnOrOnPairNamedParam()

		def IsOnPairOrOnNamedParams()
			return This.IsOnOrOnPairNamedParam()

	def IsOnOrOnSetNamedParam()
		if This.IsOnNamedParam() or This.IsOnSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnSetOrOnNamedParam()
			return This.IsOnOrOnSetNamedParam()

		def IsOnOrOnSetNamedParams()
			return This.IsOnOrOnSetNamedParam()

		def IsOnSetOrOnNamedParams()
			return This.IsOnOrOnSetNamedParam()

	def IsOnOrOnObjectNamedParam()
		if This.IsOnNamedParam() or This.IsOnObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOnObjectOrOnNamedParam()
			return This.IsOnOrOnObjectNamedParam()

		def IsOnOrOnObjectNamedParams()
			return This.IsOnOrOnObjectNamedParam()

		def IsOnObjectOrOnNamedParams()
			return This.IsOnOrOnObjectNamedParam()

	#==

	def IsOverNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsOverStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverString )

			return TRUE

		else
			return FALSE
		ok

	def IsOverSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsOverCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverChar )

			return TRUE

		else
			return FALSE
		ok

	def IsOverListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverList )

			return TRUE

		else
			return FALSE
		ok

	def IsOverPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverPair )

			return TRUE

		else
			return FALSE
		ok

	def IsOverHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsOverSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSet )

			return TRUE

		else
			return FALSE
		ok

	def IsOverObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsOverOrOverNumberNamedParam()
		if This.IsOverNamedParam() or This.IsOverNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverNumberOrOverNamedParam()
			return This.IsOverOrOverNumberNamedParam()

		def IsOverOrOverNumberNamedParams()
			return This.IsOverOrOverNumberNamedParam()

		def IsOverNumberOrOverNamedParams()
			return This.IsOverOrOverNumberNamedParam()

	def IsOverOrOverCharNamedParam()
		if This.IsOverNamedParam() or This.IsOverCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverCharOrOverNamedParam()
			return This.IsOverOrOverCharNamedParam()

		def IsOverOrOverCharNamedParams()
			return This.IsOverOrOverCharNamedParam()

		def IsOverCharOrOverNamedParams()
			return This.IsOverOrOverCharNamedParam()

	def IsOverOrOverStringNamedParam()
		if This.IsOverNamedParam() or This.IsOverStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverStringOrOverNamedParam()
			return This.IsOverOrOverStringNamedParam()

		def IsOverOrOverStringNamedParams()
			return This.IsOverOrOverStringNamedParam()

		def IsOverStringOrOverNamedParams()
			return This.IsOverOrOverStringNamedParam()

	def IsOverOrOverSubStringNamedParam()
		if This.IsOverNamedParam() or This.IsOverSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverSubStringOrOverNamedParam()
			return This.IsOverOrOverSubStringNamedParam()

		def IsOverOrOverSubStringNamedParams()
			return This.IsOverOrOverSubStringNamedParam()

		def IsOverSubStringOrOverNamedParams()
			return This.IsOverOrOverSubStringNamedParam()

	def IsOverOrOverListNamedParam()
		if This.IsOverNamedParam() or This.IsOverListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverListOrOverNamedParam()
			return This.IsOverOrOverListNamedParam()

		def IsOverOrOverListNamedParams()
			return This.IsOverOrOverListNamedParam()

		def IsOverListOrOverNamedParams()
			return This.IsOverOrOverListNamedParam()

	def IsOverOrOverHashListNamedParam()
		if This.IsOverNamedParam() or This.IsOverHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverHashListOrOverNamedParam()
			return This.IsOverOrOverHashListNamedParam()

		def IsOverOrOverHashListNamedParams()
			return This.IsOverOrOverHashListNamedParam()

		def IsOverHashListOrOverNamedParams()
			return This.IsOverOrOverHashListNamedParam()

	def IsOverOrOverPairNamedParam()
		if This.IsOverNamedParam() or This.IsOverPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverPairOrOverNamedParam()
			return This.IsOverOrOverPairNamedParam()

		def IsOverOrOverPairNamedParams()
			return This.IsOverOrOverPairNamedParam()

		def IsOverPairOrOverNamedParams()
			return This.IsOverOrOverPairNamedParam()

	def IsOverOrOverSetNamedParam()
		if This.IsOverNamedParam() or This.IsOverSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverSetOrOverNamedParam()
			return This.IsOverOrOverSetNamedParam()

		def IsOverOrOverSetNamedParams()
			return This.IsOverOrOverSetNamedParam()

		def IsOverSetOrOverNamedParams()
			return This.IsOverOrOverSetNamedParam()

	def IsOverOrOverObjectNamedParam()
		if This.IsOverNamedParam() or This.IsOverObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsOverObjectOrOverNamedParam()
			return This.IsOverOrOverObjectNamedParam()

		def IsOverOrOverObjectNamedParams()
			return This.IsOverOrOverObjectNamedParam()

		def IsOverObjectOrOverNamedParams()
			return This.IsOverOrOverObjectNamedParam()

	#==

	def IsAgainstNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverString )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverChar )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverList )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstPairNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverPair )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstHashListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverHashList )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstSetNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverSet )

			return TRUE

		else
			return FALSE
		ok

	def IsAgainstObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OverObject )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAgainstOrAgainstNumberNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstNumberNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstNumberOrAgainstNamedParam()
			return This.IsAgainstOrAgainstNumberNamedParam()

		def IsAgainstOrAgainstNumberNamedParams()
			return This.IsAgainstOrAgainstNumberNamedParam()

		def IsAgainstNumberOrAgainstNamedParams()
			return This.IsAgainstOrAgainstNumberNamedParam()

	def IsAgainstOrAgainstCharNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstCharNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstCharOrAgainstNamedParam()
			return This.IsAgainstOrAgainstCharNamedParam()

		def IsAgainstOrAgainstCharNamedParams()
			return This.IsAgainstOrAgainstCharNamedParam()

		def IsAgainstCharOrAgainstNamedParams()
			return This.IsAgainstOrAgainstCharNamedParam()

	def IsAgainstOrAgainstStringNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstStringOrAgainstNamedParam()
			return This.IsAgainstOrAgainstStringNamedParam()

		def IsAgainstOrAgainstStringNamedParams()
			return This.IsAgainstOrAgainstStringNamedParam()

		def IsAgainstStringOrAgainstNamedParams()
			return This.IsAgainstOrAgainstStringNamedParam()

	def IsAgainstOrAgainstSubStringNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstSubStringOrAgainstNamedParam()
			return This.IsAgainstOrAgainstSubStringNamedParam()

		def IsAgainstOrAgainstSubStringNamedParams()
			return This.IsAgainstOrAgainstSubStringNamedParam()

		def IsAgainstSubStringOrAgainstNamedParams()
			return This.IsAgainstOrAgainstSubStringNamedParam()

	def IsAgainstOrAgainstListNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstListOrAgainstNamedParam()
			return This.IsAgainstOrAgainstListNamedParam()

		def IsAgainstOrAgainstListNamedParams()
			return This.IsAgainstOrAgainstListNamedParam()

		def IsAgainstListOrAgainstNamedParams()
			return This.IsAgainstOrAgainstListNamedParam()

	def IsAgainstOrAgainstHashListNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstHashListNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstHashListOrAgainstNamedParam()
			return This.IsAgainstOrAgainstHashListNamedParam()

		def IsAgainstOrAgainstHashListNamedParams()
			return This.IsAgainstOrAgainstHashListNamedParam()

		def IsAgainstHashListOrAgainstNamedParams()
			return This.IsAgainstOrAgainstHashListNamedParam()

	def IsAgainstOrAgainstPairNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstPairNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstPairOrAgainstNamedParam()
			return This.IsAgainstOrAgainstPairNamedParam()

		def IsAgainstOrAgainstPairNamedParams()
			return This.IsAgainstOrAgainstPairNamedParam()

		def IsAgainstPairOrAgainstNamedParams()
			return This.IsAgainstOrAgainstPairNamedParam()

	def IsAgainstOrAgainstSetNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstSetNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstSetOrAgainstNamedParam()
			return This.IsAgainstOrAgainstSetNamedParam()

		def IsAgainstOrAgainstSetNamedParams()
			return This.IsAgainstOrAgainstSetNamedParam()

		def IsAgainstSetOrAgainstNamedParams()
			return This.IsAgainstOrAgainstSetNamedParam()

	def IsAgainstOrAgainstObjectNamedParam()
		if This.IsAgainstNamedParam() or This.IsAgainstObjectNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAgainstObjectOrAgainstNamedParam()
			return This.IsAgainstOrAgainstObjectNamedParam()

		def IsAgainstOrAgainstObjectNamedParams()
			return This.IsAgainstOrAgainstObjectNamedParam()

		def IsAgainstObjectOrAgainstNamedParams()
			return This.IsAgainstOrAgainstObjectNamedParam()

	#==

	def IsRespectivelyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Respectively )

			return TRUE

		else
			return FALSE
		ok

	#==

	def IsSeedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Seed )

			return TRUE

		else
			return FALSE
		ok
	
	#==

	def IsEqualToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EqualTo )

			return TRUE

		else
			return FALSE
		ok

	def IsEqualsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Equals )

			return TRUE

		else
			return FALSE
		ok

	#==

	def IsToNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :To )

			return TRUE

		else
			return FALSE
		ok

	def IsToTheseNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToThis )

			return TRUE

		else
			return FALSE
		ok

	def IsToManyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToMany )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOf )

			return TRUE

		else
			return FALSE
		ok

	def IsToOrToPositionNamedParam()

		if This.IsToNamedParam() or This.IsToPositionNamedParam()
			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsToOrToPositionNamedParams()
			return This.IsToOrToPositionNamedParam()

		def IsToPositionOrToNamedParam()
			return This.IsToOrToPositionNamedParam()

		def IsToPositionOrToNamedParams()
			return This.IsToOrToPositionNamedParam()

		#>

	def IsToPositionOfItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfItem )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfString )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionOfStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositionOfChar )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsFromPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromOrFromPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :FromPosition or This.Item(1) = :From)  )

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsFromOrFromPositionNamedParams()
			return This.IsFromOrFromPositionNamedParam()

		def IsFromPositionOrFromNamedParam()
			return This.IsFromOrFromPositionNamedParam()

		def IsFromPositionOrFromNamedParams()
			return This.IsFromOrFromPositionNamedParam()

		#>

	def IsFromPositionOfItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfItem )

			return TRUE

		else
			return FALSE
		ok

	def IsFromPositionOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfString )

			return TRUE

		else
			return FALSE
		ok

	def IsFromPositionOfStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsFromPositionOfCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositionOfChar )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Of )

			return TRUE

		else
			return FALSE
		ok

	def IsOnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :On )

			return TRUE

		else
			return FALSE
		ok

	def IsInNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :In )

			return TRUE

		else
			return FALSE
		ok

	def IsInANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :InA )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsInSideNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :InSide or This.Item(1) = :Inside@) )

			return TRUE

		else
			return FALSE
		ok

	def IsInSideANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and 
			(This.Item(1) = :InSideA or This.Item(1) = :InsideA@) )

			return TRUE

		else
			return FALSE
		ok

	def IsInOrInsideNamedParam()
		if This.IsInNamedParam() or This.IsInsideNamedParam()
			return TRUE

		else
			return FALSE
		ok

		def IsInOrInsideNamedParams()
			return This.IsInOrInsideNamedParam()

		def IsInsideOrInNamedParam()
			return This.IsInOrInsideNamedParam()

		def IsInsideOrInNamedParams()
			return This.IsInOrInsideNamedParam()

	def IsWhereNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Where ) and
		   isString( This.Item(2) )

			return TRUE

		else
			return FALSE
		ok

	def IsThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :That ) and
		   isString( This.Item(2) )

			return TRUE

		else
			return FALSE
		ok

	def IsThatOrWhereNamedParam()
		if This.IsThatNamedParam() or This.IsWhatNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsThatOrWhereNamedParams()
			return This.IsThatOrWhereNamedParam()

		def IsWhereOrThatNamedParam()
			return This.IsThatOrWhereNamedParam()

		def IsWhereOrThatNamedParams()
			return This.IsThatOrWhereNamedParam()

	def IsPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Position )

			return TRUE

		else
			return FALSE
		ok

	def IsThisPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Positions )

			return TRUE

		else
			return FALSE
		ok

	def IsThesePositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThesePositions )

			return TRUE

		else
			return FALSE
		ok

	def IsPositionOrPositionsNamedParam()
		if This.IsPositionNamedParam() or This.IsPositionsNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsPositionOrPositionsNamedParams()
			return This.IsPositionOrPositionsNamedParam()

	def IsAlongWithNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AlongWith or This.Item(1) = :AlongWith@)  )

			return TRUE

		else
			return FALSE
		ok

	def IsAlongWithTheirNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AlongWithTheir or This.Item(1) = :AlongWithTheir@)  )

			return TRUE

		else
			return FALSE
		ok

	def IsOrOrAndNamedParam()
		if This.IsOrNamedParam() or This.AndNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAndOrOrNamedParam()
			return This.IsOrOrAndNamedParam()

	def IsAndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :And or This.Item(1) = :And@)  )

			return TRUE

		else
			return FALSE
		ok

	def IsAndTheirNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  (This.Item(1) = :AndTheir or This.Item(1) = :AndTheir@)  )

			return TRUE

		else
			return FALSE
		ok

	def IsAndItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndString )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAndCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndChar )

			return TRUE

		else
			return FALSE
		ok

	def IsAndPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAndPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsAndItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsAndItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsAndStringItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndStringItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsOrNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Or )

			return TRUE

		else
			return FALSE
		ok

	def IsOrANamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrA )

			return TRUE

		else
			return FALSE
		ok

	def IsOrAnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrAn )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsNorNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Nor )

			return TRUE

		else
			return FALSE
		ok

	def IsWhileNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :While )

			return TRUE

		else
			return FALSE
		ok

	def IsNotNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Not )

			return TRUE

		else
			return FALSE
		ok

	def IsIfNamedParam()
		if This.NumberOfItems() = 2 and
		   This.Item(1) = :If and
		   isString(This.Item(2))

			return TRUE

		else
			return FALSE
		ok

	def IsIfOrWhereNamedParam()
		return This.IsIfNamedParam() or This.IsWhereNamedParam()

		def IsWhereOrIfNamedParam()
			return This.IsIfOrWhereNamedParam()

		def IsWhereOrIfNamedParams()
			return This.IsIfOrWhereNamedParam()

		def IsIfOrWhereNamedParams()
			return This.IsIfOrWhereNamedParam()


	def IsWithNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :With or This.Item(1) = :With@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsWithManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithMany or This.Item(1) = :WithMany@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithOrAndNamedParam()
		if This.IsWithNamedParam() or This.IsAndNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithOrAndNamedParams()
			return This.IsWithOrAndNamedParam()

		def IsAndOrWithNamedParam()
			return This.IsWithOrAndNamedParam()

		def IsAndOrWithNamedParams()
			return This.IsWithOrAndNamedParam()

	def IsWithItemsInNamedParam() 
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :By or This.Item(1) = :By@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsWithCharsInNamedParam() 
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithCharsIn or This.Item(1) = :WithCharsIn@ ) )

			return TRUE

		else
			return FALSE
		ok

	#==

	def IsUsingItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingItem)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingThisItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisItem)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingItems)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseItems)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsUsingStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingString)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingThisStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisString)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingStrings)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseStrings)

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsUsingSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingSubString)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingThisSubString)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingSubStrings)

			return TRUE
		else
			return FALSE
		ok

	def IsUsingTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :UsingTheseSubStrings)

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsByItemsInNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByItemsIn or This.Item(1) = :ByItemsIn@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsUsingItemsInNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingItemsIn or This.Item(1) = :UsingItemsIn@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsWithTheirNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithTheir or This.Item(1) = :WithTheir@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsByNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :By or This.Item(1) = :By@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsByManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByMany or This.Item(1) = :ByMany@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsByManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :ByManyXT or This.Item(1) = :ByManyXT@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUsingManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingManyXT or This.Item(1) = :UsingManyXT@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithManyXTNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :WithManyXT or This.Item(1) = :WithManyXT@ ) )
		  
			return TRUE

		else
			return FALSE
		ok

	#--

	def IsByOrUsingNamedParam()
		if This.IsByNamedParam() or This.IsUsingNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsByOrUsingNamedParams()
			return This.IsByOrUsingNamedParam()

		def IsUsingOrByNamedParam()
			return This.IsByOrUsingNamedParam()

		def IsUsingOrByNamedParams()
			return This.IsByOrUsingNamedParam()

	#--

	def IsByManyOrWithManyOrUsingManyNamedParam()
		if This.IsByManyNamedParam() or
		   This.IsWithNamedParam() or
		   This.IsUsingNamedParam()

			return TRUE
		else
			return FALSE
		ok

		#--

		def IsByManyOrUsingManyOrWithManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrByManyOrUsingManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrUsingManyOrByManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrByManyOrWithManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrWithManyOrByManyNamedParam()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

		#-- ...Param(s) with s

		def IsByManyOrWithManyOrUsingManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

		def IsByManyOrUsingManyOrWithManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrByManyOrUsingManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsWithManyOrUsingManyOrByManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrByManyOrWithManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()
	
		def IsUsingManyOrWithManyOrByManyNamedParams()
			return This.IsByManyOrWithManyOrUsingManyNamedParam()

	#--

	def IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
		if This.IsByManyXTNamedParam() or
		   This.IsWithXTNamedParam() or
		   This.IsUsingXTNamedParam()

			return TRUE
		else
			return FALSE
		ok

		#--

		def IsByManyXTOrUsingManyXTOrWithManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrByManyXTOrUsingManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrUsingManyXTOrByManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrByManyXTOrWithManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrWithManyXTOrByManyXTNamedParam()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

		#-- ...Param(s) with s

		def IsByManyXTOrWithManyXTOrUsingManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

		def IsByManyXTOrUsingManyXTOrWithManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrByManyXTOrUsingManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsWithManyXTOrUsingManyXTOrByManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrByManyXTOrWithManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()
	
		def IsUsingManyXTOrWithManyXTOrByManyXTNamedParams()
			return This.IsByManyXTOrWithManyXTOrUsingManyXTNamedParam()

	#==

	def IsByColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :ByCol, :ByCol@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsByColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :ByColumn, :ByColumn@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUsingColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :UsingCol, :UsingCol@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUsingColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :UsingColumn, :UsingColumn@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :WithCol, :WithCol@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  StzStringQ(This.Item(1)).IsOneOfThese([ :WithColumn, :WithColumn@ ]) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsByRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByRow )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithRow )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUsingRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UsingRow )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsByCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ByCell )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :WithCell )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUsingCellNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UsingCell )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsWithOrByNamedParam()
		return This.IsWithNamedParam() OR This.IsByNamedParam()

		def IsByOrWithNamedParam()
			return This.IsWithOrByNamedParam()

		def IsByOrWithNamedParams()
			return This.IsWithOrByNamedParam()

		def IsWithOrByNamedParams()
			return This.IsWithOrByNamedParam()

	def IsUsingNamedParam()
		if len(This.Content()) = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :Using or This.Item(1) = :Using@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsUsingManyNamedParam()
		if This.NumberOfItems() = 2 and ( isString(This.Item(1)) and
			( This.Item(1) = :UsingMany or This.Item(1) = :UsingMany@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :At
			return TRUE

		else
			return FALSE
		ok

	def IsAtOrUsingNamedParam()
		if This.IsAtNamedParam() or This.IsUsingNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsUsingOrAtNamedParam()
			return This.IsAtOrUsingNamedParam()

		def IsUsingOrAtNamedParams()
			return This.IsAtOrUsingNamedParam()

		def IsAtOrUsingNamedParams()
			return This.IsAtOrUsingNamedParam()

	#--

	def IsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisPositionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThesePositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThesePositions )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyPositionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtOrAtPositionNamedParam()
		if This.IsAtNamedParam() or
		   This.IsAtPositionNamedParam()

			return TRUE

		else
			return FALSE
		ok

		def IsAtPositionOrAtNamedParam()
			return This.IsAtOrAtPositionNamedParam()

		def IsAtPositionOrAtNamedParams()
			return This.IsAtOrAtPositionNamedParam()

		def IsAtOrAtPositionNamedParams()
			return This.IsAtOrAtPositionNamedParam()

	def IsAtOrAtPositionsNamedParam()
		if This.IsAtNamedParam() or
		   This.IsAtPositionsNamedParam()

			return TRUE

		else
			return FALSE
		ok

		def IsAtPositionsOrAtNamedParam()
			return This.IsAtOrAtPositionsNamedParam()

		def IsAtPositionsOrAtNamedParams()
			return This.IsAtOrAtPositionsNamedParam()

		def IsAtOrAtPositionsNamedParams()
			return This.IsAtOrAtPositionsNamedParam()

	#==

	def IsAtItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAtItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyItems )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtString )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisString )

			return TRUE

		else
			return FALSE
		ok

	def IsAtStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyStrings )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtStringItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisStringItemNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsAtStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyStringItems )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtSubStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsAtOrAtSubStringNamedParam()
		if This.IsAtNamedParam() or This.IsAtSubStringNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IfAtSubStringOrAtNamedParam()
			return This.IsAtOrAtSubStringNamedParam()

		def IsAtOrAtSubStringNamedParams()
			return This.IsAtOrAtSubStringNamedParam()

		def IfAtSubStringOrAtNamedParams()
			return This.IsAtOrAtSubStringNamedParam()

	def IsAtThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSubString )

			return TRUE

		else
			return FALSE
		ok

	def IsAtSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSubStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManySubStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySubStrings )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtCharNamedParam()
		if This.NumberOfItems() = 2 and
			( isChar(This.Item(1)) and  This.Item(1) = :AtChar )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisCharNamedParam()
		if This.NumberOfItems() = 2 and
			( isChar(This.Item(1)) and  This.Item(1) = :AtThisChar )

			return TRUE

		else
			return FALSE
		ok

	def IsAtCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isChar(This.Item(1)) and  This.Item(1) = :AtChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyChars )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtNumberNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisNumberNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsAtNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyNumbers )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtList )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisList )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyLists )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtSubListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubList )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisSubListNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSubList )

			return TRUE

		else
			return FALSE
		ok

	def IsAtSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManySubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySubLists )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtPairNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPair )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisPairNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisPair )

			return TRUE

		else
			return FALSE
		ok

	def IsAtPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtPairs )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThesePairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThesePairs )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyPairs )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfNumbersNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfNumbers )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfChars )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfChars )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfStringsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfStrings )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfStringItems )

			return TRUE

		else
			return FALSE
		ok


	def IsAtListsOfStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfStringItems )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfLists )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfSubLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfSubListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfSubLists )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfPairs )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfPairs )

			return TRUE

		else
			return FALSE
		ok
	def IsAtListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfPairs )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfPairs )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfPairsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfPairs )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfHashLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfHashLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfHashLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfHashLists )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfHashListsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfHashLists )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtObjectNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtObject )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisObjectNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisObject )

			return TRUE

		else
			return FALSE
		ok

	def IsAtObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtObjects )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseObjects )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyObjectsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyObjects )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtSectionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSection )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisSectionNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisSection )

			return TRUE

		else
			return FALSE
		ok

	def IsAtSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManySectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManySections )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfSections )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfSectionsNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfSections )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtRangeNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtRange )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisRangeNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisRange )

			return TRUE

		else
			return FALSE
		ok

	def IsAtRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyRanges )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAtListOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListOfRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtThisListOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtThisListOfRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtListsOfRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtTheseListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtTheseListsOfRanges )

			return TRUE

		else
			return FALSE
		ok

	def IsAtManyListsOfRangesNamedParam()
		if This.NumberOfItems() = 2 and
			( isString(This.Item(1)) and  This.Item(1) = :AtManyListsOfRanges )

			return TRUE

		else
			return FALSE
		ok


	#==

	def IsUsingOrAtOrWhereNamedParam()
		# Use IsOneOfTheseNamedParams([ ..., ..., ... ]) instead

		if This.IsUsingNamedParam() or
		   This.IsAtNamedParam() or
		   This.IsWhereNamedParam()

			return TRUE
		else
			return FALSE
		ok

		def IsUsingOrWhereOrAtNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
		
		def IsAtOrUsingOrWhereNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsAtOrWhereOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsWhereOrAtOrUsingNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsWhereOrUsingOrAtNamedParam()
			return This.IsUsingOrAtOrWhereNamedParam()

		#--

		def IsUsingOrWhereOrAtNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
		
		def IsAtOrUsingOrWhereNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsAtOrWhereOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsWhereOrAtOrUsingNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()
	
		def IsWhereOrUsingOrAtNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()

		def IsUsingOrAtOrWhereNamedParams()
			return This.IsUsingOrAtOrWhereNamedParam()


	def IsStepNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  Q(This.Item(1)).IsOneOfThese([ :Step, :Steps ]) ) and
		   isNumber( This.Item(2) )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsNameNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Name ) and
		   isString(This.Item(2))
		  
			return TRUE

		else
			return FALSE
		ok

	def IsNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Named ) and
		   isString(This.Item(2))
		  
			return TRUE

		else
			return FALSE
		ok

	def IsNamedAsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NamedAs ) and
		   isString(This.Item(2))
		  
			return TRUE

		else
			return FALSE
		ok

	def IsRaiseNamedParam()
		if This.NumberOfItems() <= 4 and
		   This.IsHashList() and
		   This.ToStzHashList().KeysQ().IsMadeOfSome([ :Where, :What, :Why, :Todo ]) and
		   This.ToStzHashList().ValuesQ().AllItemsVerifyW("isString(@item) and @item != NULL")

			return TRUE

		else
			return FALSE
		ok

	def IsReturnedAsNamedParam()

		if This.NumberOfItems() = 2 and This.Item(1) = :ReturnedAs

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnedAsNamedParam()

		if This.NumberOfItems() = 2 and This.Item(1) = :AndReturnedAs

			return TRUE

		else
			return FALSE
		ok

	def IsReturnNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :Return

			return TRUE

		else
			return FALSE
		ok

	def IsReturnAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnAs

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnAs

			return TRUE

		else
			return FALSE
		ok

	def IsReturnItAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnItAs

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnItAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnItAs

			return TRUE

		else
			return FALSE
		ok

	def IsReturnThemAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :ReturnThemAs

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnThemAsNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and This.Item(1) = :AndReturnThemAs

			return TRUE

		else
			return FALSE
		ok

	def IsReturningNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:Returning, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturn, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturningNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturning, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsReturnNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:ReturnNth, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsReturningNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:ReturningNth, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturnNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturnNth, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsAndReturningNthNamedParam()
		if This.NumberOfItems() = 2 and
		   isString(This.Item(1)) and Q(This.Item(1)).IsEqualToCS(:AndReturningNth, :CS = FALSE)

			return TRUE

		else
			return FALSE
		ok

	def IsUpToNCharsNamedParam()
		if This.NumberOfItems() = 2 and
 		   isString(This.Item(1)) and  This.Item(1) = :UpToNChars
		  
			return TRUE

		else
			return FALSE
		ok

	def IsUpToNItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
 		   ( isString(This.Item(1)) and  This.Item(1) = :UpToNItems )
		  
			return TRUE

		else
			return FALSE
		ok

	def IsBeforeNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :Before )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeItem )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeItems )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThisItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisItem )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeTheseItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseItems )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBeforePositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforePosition )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThisPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforePositions )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThesePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThesePositions )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBeforeSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThisSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeTheseSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThisSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSubStringPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSubStringsPositions )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeTheseSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSubStringsPositions )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsAfterSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThisSubStringNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterTheseSubStringsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStringPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThisSubStringPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSubStringPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSubStringsPositions )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterTheseSubStringsPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSubStringsPositions )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBeforeSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSection )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeThisSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThisSection )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeSections )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeTheseSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeTheseSections )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsAfterSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSection )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThisSectionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisSection )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterSections )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterTheseSectionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseSections )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBeforeOrAtNamedParam()
		if This.IsBeforeNamedParam() or This.IsAtNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAtOrBeforeNamedParam()
			return This.IsBeforeOrAtNamedParam()

	def IsAfterNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :After )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThese )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterMany )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterItem )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterItems )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThisItemNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisItem )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterTheseItemsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterTheseItems )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThisPositionNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThisPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterPositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterPositions )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterThesePositionsNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AfterThesePositions )

			return TRUE
		else
			return FALSE
		ok

	def IsAfterOrAtNamedParam()
		if This.IsAfterNamedParam() or This.IsAtNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAtOrAfterNamedParam()
			return This.IsAfterOrAtNamedParam()

	def IsBeforeOrAfterNamedParam()
		if This.IsBeforeNamedPAram() or This.IsAfterNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsAfterOrBeforeNamedParam()
			return This.IsBeforeOrAfterNamedParam()

	def IsWidthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Width )

			return TRUE

		else
			return FALSE
		ok

	def IsWithOrUsingNamedParam()
		if This.IsWithNamedParam() or This.IsUsingNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsWithOrUsingNamedParams()
			return This.IsWithOrUsingNamedParam()

		def IsUsingOrWithNamedParam()
			return This.IsWithOrUsingNamedParam()

		def IsUsingOrWithNamedParams()
			return This.IsWithOrUsingNamedParam()

	def IsMadeOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :MadeOf )

			return TRUE

		else
			return FALSE
		ok

	def IsNthTofirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirst )

			return TRUE

		else
			return FALSE
		ok

	def IsNthToFirstCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirstChar )

			return TRUE

		else
			return FALSE
		ok

	def IsNthToFirstItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToFirstItem )

			return TRUE

		else
			return FALSE
		ok

	def IsNthToLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLast )

			return TRUE

		else
			return FALSE
		ok

	def IsNthToLastCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLastChar )

			return TRUE

		else
			return FALSE
		ok

	def IsNthToLastItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :NthToLastItem )

			return TRUE

		else
			return FALSE
		ok

	def IsStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :String )

			return TRUE

		else
			return FALSE
		ok

	def IsThisStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisString )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsThisStringItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsStringOrStringItemNamedParam()
		if This.IsStringNamedParam() or This.IsStringItemNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsStringItemOrStringNamedParam()
			return This.IsStringOrStringItemNamedParam()

	#--

	def IsNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Number )

			return TRUE

		else
			return FALSE
		ok

	def IsThisNumberNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisNumber )

			return TRUE

		else
			return FALSE
		ok

	def IsNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Numbers )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseNumbers )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsCharNamedParam()
		if This.CharOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Char )

			return TRUE

		else
			return FALSE
		ok

	def IsThisCharNamedParam()
		if This.CharOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisChar )

			return TRUE

		else
			return FALSE
		ok

	def IsCharsNamedParam()
		if This.CharOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Chars )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseCharsNamedParam()
		if This.CharOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseChars )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsThisItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisItem )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseItems )

			return TRUE

		else
			return FALSE
		ok

	def IsThisListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisList )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseLists )

			return TRUE

		else
			return FALSE
		ok

	def IsThisObjectNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisObject )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseObjects )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsItemNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Item )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Items )

			return TRUE

		else
			return FALSE
		ok

	def IsItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Items )

			return TRUE

		else
			return FALSE
		ok

	def IsItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Strings )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsThisStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsItemAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsCharAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsCharsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsSubStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsThisSubStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ThisSubStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsSubStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseSubStringsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseSubStringsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsSubStringAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsSubStringsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :SubStringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Between )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenXT )

			return TRUE

		else
			return FALSE
		ok	

	def IsBetweenIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenIB )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenIBSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenIBS )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenS )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCSNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCS )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsBetweenRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRow )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRows )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenRowsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenRowsAt )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsBetweenColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCol )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumn )
	
				return TRUE
	
			else
				return FALSE
			ok

	def IsBetweenColAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColAt )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnAtNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnAt )
	
				return TRUE
	
			else
				return FALSE
			ok

	def IsBetweenColAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColAtPosition )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnAtPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnAtPosition )
	
				return TRUE
	
			else
				return FALSE
			ok
	
	def IsBetweenColsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAtPosition )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnsAtPositionNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAtPosition )
	
				return TRUE
	
			else
				return FALSE
			ok

	def IsBetweenColsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAtPositions )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnsAtPositionsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAtPositions )
	
				return TRUE
	
			else
				return FALSE
			ok

	def IsBetweenColsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCols )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnsNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumns )
	
				return TRUE
	
			else
				return FALSE
			ok

	def IsBetweenColsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColsAt )

			return TRUE

		else
			return FALSE
		ok

		def IsBetweenColumnsAtNamedParam()
			if This.NumberOfItems() = 2 and
			   ( isString(This.Item(1)) and  This.Item(1) = :BetweenColumnsAt )
	
				return TRUE
	
			else
				return FALSE
			ok

	#--

	def IsFromPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsItemFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsItemFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsItemsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ItemsFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToItemsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItem )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItems )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromItemPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromItemPosition )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsStringFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsStringsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenString )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItem )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsStringItemFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsCharFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsCharsFromPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsFromPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsCharFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsCharsFromNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharsFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCharPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :CharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenChar )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenChars )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFirstPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FirstPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsLastPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :LastPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToCharsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToCharAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenCharAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToCharAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromCharAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromCharAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Strings )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :theseStringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsTheseStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseStringsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsStringItemsFromPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsFromPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsStringItemsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :StringItemsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemsAtNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemsAtPositionNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsBetweenStringItemsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :BetweenStringItemsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsFromStringItemsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :FromStringItemsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsToStringItemsAtPositionsNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToStringItemsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAndColNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndCol )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColumnNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumn )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColat )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColumnAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnAt )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColumnAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColNamed )

			return TRUE

		else
			return FALSE
		ok

	def IsAndColumnNamedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndColumnNamed )

			return TRUE

		else
			return FALSE
		ok

	def IsColsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Cols )

			return TRUE

		else
			return FALSE
		ok

	def IsColumnsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Columns )

			return TRUE

		else
			return FALSE
		ok

	def IsColsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsColumnsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColumnsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsColsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	def IsColumnsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ColumnsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAndRowNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRow )

			return TRUE

		else
			return FALSE
		ok

	def IsAndRowAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRowAt )

			return TRUE

		else
			return FALSE
		ok

	def IsAndRowAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndRowAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsRowsAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAt )

			return TRUE

		else
			return FALSE
		ok

	def IsRowsAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsRowsAtPositionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :RowsAtPositions )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :This )

			return TRUE

		else
			return FALSE
		ok

	def IsAndThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndThis )

			return TRUE

		else
			return FALSE
		ok

	def IsAndThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :AndThat )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsEvalNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Eval )

			return TRUE

		else
			return FALSE
		ok

	def IsEvaluateNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Evaluate )

			return TRUE

		else
			return FALSE
		ok

	def IsEvalFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvalFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsEvaluateFromNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvaluateFrom )

			return TRUE

		else
			return FALSE
		ok

	def IsEvalDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvalDirection )

			return TRUE

		else
			return FALSE
		ok

	def IsEvaluationDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :EvaluationDirection )

			return TRUE

		else
			return FALSE
		ok

	def IsOrThisNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrThis )

			return TRUE

		else
			return FALSE
		ok

	def IsOrThatNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OrThat )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubString )

			return TRUE
		else
			return FALSE
		ok

	def IsSubstringOrSubstringsNamedParam()
		if This.IsSubStringNamedParam() or
		   This.IsSubStringsNamedParam()

			return TRUE
		else
			return FALSE
		ok

		def IsSubStringsOrSubStringNamedParam()
			return This.IsSubstringOrSubstringsNamedParam()

		#--

		def IsSubstringOrSubstringsNamedParams()
			return This.IsSubstringOrSubstringsNamedParam()

		def IsSubStringsOrSubStringNamedParams()
			return This.IsSubstringOrSubstringsNamedParam()


	def IsThisSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThisSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsAndSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsBetweenSubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BetweenSubString )

			return TRUE
		else
			return FALSE
		ok

	def IsBoundedBySubStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBySubString )

			return TRUE
		else
			return FALSE
		ok

	def IsSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :SubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :TheseSubStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsAndSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsOfSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsInSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsBetweenSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BetweenSubStrings )

			return TRUE
		else
			return FALSE
		ok

	def IsBoundedBySubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBySubStrings )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBoundedByNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedBy )

			return TRUE
		else
			return FALSE
		ok

	def IsBoundedByIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundedByIB )

			return TRUE
		else
			return FALSE
		ok


	def IsIsBoundedByNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :IsBoundedBy )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsBoundsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Bounds )

			return TRUE
		else
			return FALSE
		ok

	def IsBoundsIBNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :BoundsIB )

			return TRUE
		else
			return FALSE
		ok

	def IsBoundedByOrBoundsNamedParam()
		if This.IsBoundedByNamedParam() or This.IsBoundsNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def BoudedByOrBoundsNamedParams()
			return This.BoundedByOrBoundsNamedParam()

		def BoundsOrBoundedByNamedParam()
			return This.BoundedByOrBoundsNamedParam()

		def BoundsOrBoundedByNamedParams()
			return This.BoundedByOrBoundsNamedParam()

	def IsIsBoundedByOrBoundsNamedParam()
		if This.IsIsBoundedByNamedParam() or This.IsBoundsNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsIsBoudedByOrBoundsNamedParams()
			return This.IsIsBoundedByOrBoundsNamedParam()

		def BoundsOrIsIsBoundedByNamedParam()
			return This.IsIsBoundedByOrBoundsNamedParam()

		def BoundsOrIsIsBoundedByNamedParams()
			return This.IsIsBoundedByOrBoundsNamedParam()

	def IsBoundedByIBOrBoundsIBNamedParam()
		if This.IsBoundedByIBNamedParam() or This.IsBoundsIBNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def BoudedIBByOrBoundsIBNamedParams()
			return This.IsBoundedByIBOrBoundsIBNamedParam()

		def BoundsIBOrBoundedByIBNamedParam()
			return This.IsBoundedByIBOrBoundsIBNamedParam()

		def BoundsIBOrBoundedIBByNamedParams()
			return This.IsBoundedByIBOrBoundsIBNamedParam()

	def IsIsBoundedByIBOrBoundsIBNamedParam()
		if This.IsIsBoundedByIBNamedParam() or This.IsBoundsIBNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsIsBoudedByIBOrBoundsIBNamedParams()
			return This.IsIsBoundedByIBOrBoundsIBNamedParam()

		def BoundsIBOrIsIsBoundedByIBNamedParam()
			return This.IsIsBoundedByIBOrBoundsIBNamedParam()

		def BoundsIBOrIsIsBoundedByIBNamedParams()
			return This.IsIsBoundedByIBOrBoundsIBNamedParam()

	#==

	def IsSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Section )

			return TRUE
		else
			return FALSE
		ok

	def IsThisSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ThisSection )

			return TRUE
		else
			return FALSE
		ok

	def IsAndSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSection )

			return TRUE
		else
			return FALSE
		ok

	def IsOfSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSection )

			return TRUE
		else
			return FALSE
		ok

	def IsInSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSection )

			return TRUE
		else
			return FALSE
		ok

	def IsSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Sections )

			return TRUE
		else
			return FALSE
		ok

	def IsTheseSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :TheseSections )

			return TRUE
		else
			return FALSE
		ok

	def IsAndSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :AndSections )

			return TRUE
		else
			return FALSE
		ok

	def IsOfSubSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :OfSections )

			return TRUE
		else
			return FALSE
		ok

	def IsInSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InSections )

			return TRUE
		else
			return FALSE
		ok

	def IsSectionOrInSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Section or This.Item(1) = :InSection) )

			return TRUE
		else
			return FALSE
		ok

	def IsSectionsOrInSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and (This.Item(1) = :Sections or This.Item(1) = :InSections) )

			return TRUE
		else
			return FALSE
		ok

		def IsSectionsOrInSectionsNamedParams()
			return This.IsSectionsOrInSectionsNamedParam()

	def IsToSectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToSection )

			return TRUE
		else
			return FALSE
		ok

	def IsToSectionsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToSections )

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsListSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ListSize )

			return TRUE
		else
			return FALSE
		ok

	def IsStringSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StringSize )

			return TRUE
		else
			return FALSE
		ok

	def IsNumberOfItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NumberOfItems )

			return TRUE
		else
			return FALSE
		ok

	def IsNumberOfCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :NumberOfChars )

			return TRUE
		else
			return FALSE
		ok

	def IsInAListOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfNItems )

			return TRUE
		else
			return FALSE
		ok

	def IsInAListOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfSizeN )

			return TRUE
		else
			return FALSE
		ok

	def IsInAListOfSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfSize )

			return TRUE
		else
			return FALSE
		ok

	def IsInAListOfNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOfN )

			return TRUE
		else
			return FALSE
		ok

	def IsInAListOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAListOf )

			return TRUE
		else
			return FALSE
		ok

	def IsInAStringOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAStringOfN )

			return TRUE
		else
			return FALSE
		ok

	def IsInAStringOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InAStringOfSizeN )

			return TRUE
		else
			return FALSE
		ok

	def IsInListOfNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfNItems )

			return TRUE
		else
			return FALSE
		ok

	def IsInListOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfSizeN )

			return TRUE
		else
			return FALSE
		ok

	def IsInListOfSizeNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfSize )

			return TRUE
		else
			return FALSE
		ok

	def IsInListOfNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOfN )

			return TRUE
		else
			return FALSE
		ok

	def IsInListOfNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InListOf )

			return TRUE
		else
			return FALSE
		ok

	def IsInStringOfNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InStringOf )

			return TRUE
		else
			return FALSE
		ok

	def IsInStringOfSizeNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :InStringOfSizeN )

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :Start )

			return TRUE
		else
			return FALSE
		ok

	def IsStartOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartOfString )

			return TRUE
		else
			return FALSE
		ok

	def IsStartOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartOfList )

			return TRUE
		else
			return FALSE
		ok


	def IsEndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :End )

			return TRUE
		else
			return FALSE
		ok

	def IsEndOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :EndOfList )

			return TRUE
		else
			return FALSE
		ok

	def IsEndOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :EndOfString )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsFromStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStart )

			return TRUE
		else
			return FALSE
		ok

	def IsFromStartOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStartOfString )

			return TRUE
		else
			return FALSE
		ok

	def IsFromStartOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromStartOfList )

			return TRUE
		else
			return FALSE
		ok


	def IsFromEndNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEnd )

			return TRUE
		else
			return FALSE
		ok

	def IsFromEndOfListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEndOfList )

			return TRUE
		else
			return FALSE
		ok

	def IsFromEndOfStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :FromEndOfString )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsStartingAtCharNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtChar )

			return TRUE
		else
			return FALSE
		ok

	def IsStartingAtCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtCharAt )

			return TRUE
		else
			return FALSE
		ok

	def IsStartingAtCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtCharAtPosition )

			return TRUE
		else
			return FALSE
		ok

	def IsStartingAtItemNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItem )

			return TRUE
		else
			return FALSE
		ok

	def IsStartingAtItemAtNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItemAt )

			return TRUE
		else
			return FALSE
		ok

	def IsStartingAtItemAtPositionNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :StartingAtItemAtPosition )

			return TRUE
		else
			return FALSE
		ok

	#--

	def IsToEndNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEnd )

			return TRUE
		else
			return FALSE
		ok

	def IsToEndOfStringNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEndOfString )

			return TRUE
		else
			return FALSE
		ok

	def IsToEndOfListNamedPAram()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToEndOfList )

			return TRUE
		else
			return FALSE
		ok

	def IsToStartNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStart )

			return TRUE
		else
			return FALSE
		ok

	def IsToStartofListNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStartOfList )

			return TRUE
		else
			return FALSE
		ok

	def IsToStartofStringNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and This.Item(1) = :ToStartOfString )

			return TRUE
		else
			return FALSE
		ok

	#==

	def IsOfSizeNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :OfSize )

			return TRUE

		else
			return FALSE
		ok

	def IsSizeNamedParam()

		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Size )

			return TRUE

		else
			return FALSE
		ok

	def IsDoNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Do )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Until )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilCharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilCharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsUntilItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilItemAtPosition )

			return TRUE

		else
			return FALSE
		ok


	def IsUntilXTNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UntilXT )

			return TRUE

		else
			return FALSE
		ok

	def IsUptoNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpTo )

			return TRUE

		else
			return FALSE
		ok

	def IsUptoPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToPosition )

			return TRUE

		else
			return FALSE
		ok

		# Misspelled form

		def IsUpToPosionNamedParam()
			return This.IsUptoPositionNamedParam()

	def IsUpToNNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :UpToN or This.Item(1) = :UpToN@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsUpToCharAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToCharAt )

			return TRUE

		else
			return FALSE
		ok

	def IsUpToCharAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToCharAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsUpToItemAtNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToItemAt )

			return TRUE

		else
			return FALSE
		ok

	def IsUpToItemAtPositionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :UpToItemAtPosition )

			return TRUE

		else
			return FALSE
		ok

	def IsUnderNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Under )

			return TRUE

		else
			return FALSE
		ok

	def IsExpressionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :Expression )

			return TRUE

		else
			return FALSE
		ok

	def IsToNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNChars )

			return TRUE

		else
			return FALSE
		ok

	def IsToNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNItems )

			return TRUE

		else
			return FALSE
		ok

	def IsToNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNStrings )

			return TRUE

		else
			return FALSE
		ok

	def IsToNStringItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNStringItems )

			return TRUE

		else
			return FALSE
		ok

	def IsToNNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNNumbers )

			return TRUE

		else
			return FALSE
		ok

	def IsToNListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNLists )

			return TRUE

		else
			return FALSE
		ok

	def IsToNObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and  This.Item(1) = :ToNObjects )

			return TRUE

		else
			return FALSE
		ok

	def IsLastSepNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :LastSep or This.Item(1) = :LastSep@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsToEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToEach or This.Item(1) = :ToEach@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsBeforeEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeEach or This.Item(1) = :BeforeEach@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAfterEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterEach or This.Item(1) = :AfterEach@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsToNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToNth or This.Item(1) = :ToNth@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsToFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToFirst or This.Item(1) = :ToFirst@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsToLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ToLast or This.Item(1) = :ToLast@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAfterNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterNth or This.Item(1) = :AfterNth@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAfterFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterFirst or This.Item(1) = :AfterFirst@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAfterLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AfterLast or This.Item(1) = :AfterLast@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsBeforeNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeNth or This.Item(1) = :BeforeNth@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsBeforeTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeThese )

			return TRUE
		else
			return FALSE
		ok

	def IsBeforeManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :BeforeMany )

			return TRUE
		else
			return FALSE
		ok


	def IsBeforeFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeFirst or This.Item(1) = :BeforeFirst@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsBeforeLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :BeforeLast or This.Item(1) = :BeforeLast@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAroundNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Around or This.Item(1) = :Around@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAroundTheseNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AroundThese )

			return TRUE
		else
			return FALSE
		ok

	def IsAroundManyNamedParam()
		if ( This.NumberOfItems() = 2 ) and
		   ( isString(This.Item(1)) and This.Item(1) = :AroundMany )

			return TRUE
		else
			return FALSE
		ok

	def IsAroundEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundEach or This.Item(1) = :AroundEach@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAroundNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundNth or This.Item(1) = :AroundNth@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAroundFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundFirst or This.Item(1) = :AroundFirst@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsAroundLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :AroundLast or This.Item(1) = :AroundLast@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Each or This.Item(1) = :Each@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsFirstNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :First or This.Item(1) = :First@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsLastNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Last or This.Item(1) = :Last@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsConcatenatedNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Concatenated or This.Item(1) = :Concatenated@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsConcatenatedUsingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ConcatenatedUsing or This.Item(1) = :ConcatenatedUsing@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsConcatenatedWithNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :ConcatenatedWith or This.Item(1) = :ConcatenatedWith@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNChars or This.Item(1) = :EachNChars@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNItemsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNItems or This.Item(1) = :EachNItems@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNStrings or This.Item(1) = :EachNStrings@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNNumbers or This.Item(1) = :EachNNumbers@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNLists or This.Item(1) = :EachNLists@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNPairsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNPairs or This.Item(1) = :EachNPairs@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsEachNObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :EachNObjects or This.Item(1) = :EachNObjects@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsDirectionNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Direction or This.Item(1) = :Direction@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsGoingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Going or This.Item(1) = :Going@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsDirectionOrGoingNamedParam()
		if This.IsDirectionNamedParam() or This.IsGoingNamedParam()
			return TRUE
		else
			return FALSE
		ok

		def IsGoingOrDirectionNamedParam()
			return This.IsDirectionOrGoingNamedParam()

		#--

		def IsDirectionOrGoingNamedParams()
			return This.IsDirectionOrGoingNamedParam()

		def IsGoingOrDirectionNamedParams()
			return This.IsDirectionOrGoingNamedParam()

	def IsComingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Coming or This.Item(1) = :Coming@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsSteppingNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Stepping or This.Item(1) = :Stepping@ ) )

			return TRUE

		else
			return FALSE
		ok

	
	def IsUsingOrWithOrByNamedParam()

		if This.IsUsingNamedParam() or
		   This.IsWithNamedParam() or
		   This.IsByNamedParam()

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsUsingOrByOrWithNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrWithOrUsingNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrUsingOrWithNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrByOrUsingNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrUsingOrByNamedParam()
			return This.IsUsingOrWithOrByNamedParam()

		#--

		def IsUsingOrWithOrByNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsUsingOrByOrWithNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrWithOrUsingNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsByOrUsingOrWithNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrByOrUsingNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		def IsWithOrUsingOrByNamedParams()
			return This.IsUsingOrWithOrByNamedParam()

		#>

	def IsNextNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Next or This.Item(1) = :Next@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsNextNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :NextNth or This.Item(1) = :NextNth@  or 
			 This.Item(1) = :NthNext or This.Item(1) = :NthNext@) )

			return TRUE

		else
			return FALSE
		ok

		def IsNthNextNamedParam()
			return This.IsNextNthNamedParam()

	def IsPreviousNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Previous or This.Item(1) = :Previous@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsPreviousNthNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :PreviousNth or This.Item(1) = :PreviousNth@  or 
			 This.Item(1) = :NthPrevious or This.Item(1) = :NthPrevious@) )

			return TRUE

		else
			return FALSE
		ok

		def IsNthPreviousNamedParam()
			return This.IsPreviousNthNamedParam()

	#--

	def IsExactlyNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :Exactly or This.Item(1) = :Exactly@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsMoreThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :MoreThen or This.Item(1) = :MoreThen@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsLessThenNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :LessThen or This.Item(1) = :LessThen@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfThese or This.Item(1) = :OfThese@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseSubStringsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseSubStrings or This.Item(1) = :OfTheseSubStrings@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseNumbersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseNumbers or This.Item(1) = :OfTheseNumbers@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseListsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseLists or This.Item(1) = :OfTheseLists@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseObjectsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseObjects or This.Item(1) = :OfTheseObjects@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseCharsNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseChars or This.Item(1) = :OfTheseChars@ ) )

			return TRUE

		else
			return FALSE
		ok

	def IsOfTheseLettersNamedParam()
		if This.NumberOfItems() = 2 and
		   ( isString(This.Item(1)) and
			(This.Item(1) = :OfTheseLetters or This.Item(1) = :OfTheseLetters@ ) )

			return TRUE

		else
			return FALSE
		ok

	#--

	def IsAndOrAndPositionOrAndSubStringNamedParam()
		if This.IsAndNamedParam() or
		   This.IsAndPositionNamedParam() or
		   This.IsAndSubstringNamedParam()

			return TRUE
		else
			return FALSE
		ok

		def IsAndOrAndSubStringOrAndPositionNamedParam()
			return This.IsAndOrAndPositionOrAndSubStringNamedParam()

		#--

		def IsAndOrAndPositionOrAndSubStringNamedParams()
			return This.IsAndOrAndPositionOrAndSubStringNamedParam()

		def IsAndOrAndSubStringOrAndPositionNamedParams()
			return This.IsAndOrAndSubStringOrAndPositionNamedParam()
